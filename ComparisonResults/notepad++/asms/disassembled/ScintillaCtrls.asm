.data:00000000 ;
.data:00000000 ; +-------------------------------------------------------------------------+
.data:00000000 ; |   This file has been generated by The Interactive Disassembler (IDA)    |
.data:00000000 ; |           Copyright (c) 2015 Hex-Rays, <support@hex-rays.com>           |
.data:00000000 ; |                      License info: 48-3677-7074-51                      |
.data:00000000 ; |             Michalis Polychronakis, Stony Brook University              |
.data:00000000 ; +-------------------------------------------------------------------------+
.data:00000000 ;
.data:00000000 ; Input MD5   : AFD92D65DD8D7F838A7FD0D541571C3B
.data:00000000 ; Input CRC32 : D0A1D683
.data:00000000
.data:00000000 ; File Name   : C:\workspace\notepad-plus-plus-6.7.9.2\PowerEditor\visual.net\Unicode Debug\ScintillaCtrls.obj
.data:00000000 ; Format      : COFF (X386MAGIC)
.data:00000000 ; includelib "libcpmtd"
.data:00000000 ; includelib "uuid.lib"
.data:00000000 ; must resolve: ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
.data:00000000 ; must resolve: ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
.data:00000000 ; must resolve: ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
.data:00000000 ; must resolve: ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
.data:00000000 ; must resolve: ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
.data:00000000 ; must resolve: ?id@?$numpunct@D@std@@2V0locale@2@A
.data:00000000 ; must resolve: ?id@?$numpunct@_W@std@@2V0locale@2@A
.data:00000000 ; includelib "LIBCMTD"
.data:00000000 ; includelib "OLDNAMES"
.data:00000000
.data:00000000                 include uni.inc ; see unicode subdir of ida for info on unicode
.data:00000000
.data:00000000                 .686p
.data:00000000                 .mmx
.data:00000000                 .model flat
.data:00000000
.data:00000000 ; ===========================================================================
.data:00000000
.data:00000000 ; Segment type: Pure data
.data:00000000 ; Segment permissions: Read/Write
.data:00000000 ; Segment alignment 'qword' can not be represented in assembly
.data:00000000 _data           segment para public 'DATA' use32
.data:00000000                 assume cs:_data
.data:00000000 _acTop_xpm      dd offset $SG143447     ; "12 12 56 1"
.data:00000004                 dd offset $SG143448     ; " \tc #FFFFFF"
.data:00000008                 dd offset $SG143449     ; ".\tc #8AB2E9"
.data:0000000C                 dd offset $SG143450     ; "+\tc #CCDCF6"
.data:00000010                 dd offset $SG143451     ; "@\tc #80ABEA"
.data:00000014                 dd offset $SG143452     ; "#\tc #7DA9E8"
.data:00000018                 dd offset $SG143453     ; "$\tc #C7DAF3"
.data:0000001C                 dd offset $SG143454     ; "%\tc #79A7E6"
.data:00000020                 dd offset $SG143455     ; "&\tc #ADC8EF"
.data:00000024                 dd offset $SG143456     ; "*\tc #87B0E8"
.data:00000028                 dd offset $SG143457     ; "=\tc #BBD2F0"
.data:0000002C                 dd offset $SG143458     ; "-\tc #6EA0E2"
.data:00000030                 dd offset $SG143459     ; ";\tc #A8C7EE"
.data:00000034                 dd offset $SG143460     ; ">\tc #A3C2ED"
.data:00000038                 dd offset $SG143461     ; ",\tc #75A4E3"
.data:0000003C                 dd offset $SG143462     ; "'\tc #A7C4EB"
.data:00000040                 dd offset $SG143463     ; ")\tc #6297E1"
.data:00000044                 dd offset $SG143464     ; "!\tc #A1C1EC"
.data:00000048                 dd offset $SG143465     ; "~\tc #92B7E8"
.data:0000004C                 dd offset $SG143466     ; "{\tc #99BBE9"
.data:00000050                 dd offset $SG143467     ; "]\tc #6197DD"
.data:00000054                 dd offset $SG143468     ; "^\tc #96B9E6"
.data:00000058                 dd offset $SG143469     ; "/\tc #538EDB"
.data:0000005C                 dd offset $SG143470     ; "(\tc #99BBEA"
.data:00000060                 dd offset $SG143471     ; "_\tc #80AAE3"
.data:00000064                 dd offset $SG143472     ; ":\tc #81ABE3"
.data:00000068                 dd offset $SG143473     ; "<\tc #8AB1E4"
.data:0000006C                 dd offset $SG143474     ; "[\tc #4B88D6"
.data:00000070                 dd offset $SG143475     ; "}\tc #4882D1"
.data:00000074                 dd offset $SG143476     ; "|\tc #4384D6"
.data:00000078                 dd offset $SG143477     ; "1\tc #90B5E7"
.data:0000007C                 dd offset $SG143478     ; "2\tc #74A3E0"
.data:00000080                 dd offset $SG143479     ; "3\tc #77A4E0"
.data:00000084                 dd offset $SG143480     ; "4\tc #81ABE2"
.data:00000088                 dd offset $SG143481     ; "5\tc #437FD3"
.data:0000008C                 dd offset $SG143482     ; "6\tc #7FA2DF"
.data:00000090                 dd offset $SG143483     ; "7\tc #3577D2"
.data:00000094                 dd offset $SG143484     ; "8\tc #87AFE4"
.data:00000098                 dd offset $SG143485     ; "9\tc #72A1DF"
.data:0000009C                 dd offset $SG143486     ; "0\tc #7CA9E1"
.data:000000A0                 dd offset $SG143487     ; "a\tc #3F7AD0"
.data:000000A4                 dd offset $SG143488     ; "b\tc #85A4DE"
.data:000000A8                 dd offset $SG143489     ; "c\tc #FBFCFE"
.data:000000AC                 dd offset $SG143490     ; "d\tc #236ECD"
.data:000000B0                 dd offset $SG143491     ; "e\tc #7EA8E1"
.data:000000B4                 dd offset $SG143492     ; "f\tc #79A6E0"
.data:000000B8                 dd offset $SG143493     ; "g\tc #3D77D0"
.data:000000BC                 dd offset $SG143494     ; "h\tc #87A4DC"
.data:000000C0                 dd offset $SG143495     ; "i\tc #1A62C9"
.data:000000C4                 dd offset $SG143496     ; "j\tc #75A3DF"
.data:000000C8                 dd offset $SG143497     ; "k\tc #3C74CF"
.data:000000CC                 dd offset $SG143498     ; "l\tc #8DA6DE"
.data:000000D0                 dd offset $SG143499     ; "m\tc #1859C4"
.data:000000D4                 dd offset $SG143500     ; "n\tc #3B71CC"
.data:000000D8                 dd offset $SG143501     ; "o\tc #8EA5DD"
.data:000000DC                 dd offset $SG143502     ; "p\tc #164EC0"
.data:000000E0                 dd offset $SG143503     ; "q\tc #92A7DD"
.data:000000E4                 dd offset $SG143504     ; "    .+      "
.data:000000E8                 dd offset $SG143505     ; "    @#$     "
.data:000000EC                 dd offset $SG143506     ; "    %&*=    "
.data:000000F0                 dd offset $SG143507     ; "    -;>,'   "
.data:000000F4                 dd offset $SG143508     ; "    )!~{]^  "
.data:000000F8                 dd offset $SG143509     ; "    /(_:<[} "
.data:000000FC                 dd offset $SG143510     ; "    |123456 "
.data:00000100                 dd offset $SG143511     ; "    7890abc "
.data:00000104                 dd offset $SG143512     ; "    defgh   "
.data:00000108                 dd offset $SG143513     ; "    ijkl    "
.data:0000010C                 dd offset $SG143514     ; "    mno     "
.data:00000110                 dd offset $SG143515     ; "    pq      "
.data:00000114                 align 8
.data:00000118 _acBottom_xpm   dd offset $SG143517     ; "12 12 54 1"
.data:0000011C                 dd offset $SG143518     ; " \tc #FFFFFF"
.data:00000120                 dd offset $SG143519     ; ".\tc #C4D7F3"
.data:00000124                 dd offset $SG143520     ; "+\tc #72A1E3"
.data:00000128                 dd offset $SG143521     ; "@\tc #C1D6F2"
.data:0000012C                 dd offset $SG143522     ; "#\tc #6397E1"
.data:00000130                 dd offset $SG143523     ; "$\tc #5990DD"
.data:00000134                 dd offset $SG143524     ; "%\tc #BBD2F0"
.data:00000138                 dd offset $SG143525     ; "&\tc #7AA6E5"
.data:0000013C                 dd offset $SG143526     ; "*\tc #9ABDEA"
.data:00000140                 dd offset $SG143527     ; "=\tc #4A87D9"
.data:00000144                 dd offset $SG143528     ; "-\tc #B1CAEE"
.data:00000148                 dd offset $SG143529     ; ";\tc #75A4E3"
.data:0000014C                 dd offset $SG143530     ; ">\tc #99BBE9"
.data:00000150                 dd offset $SG143531     ; ",\tc #95B9E8"
.data:00000154                 dd offset $SG143532     ; "'\tc #3A7CD4"
.data:00000158                 dd offset $SG143533     ; ")\tc #A9C6EC"
.data:0000015C                 dd offset $SG143534     ; "!\tc #71A0E0"
.data:00000160                 dd offset $SG143535     ; "~\tc #86AFE5"
.data:00000164                 dd offset $SG143536     ; "{\tc #8DB2E6"
.data:00000168                 dd offset $SG143537     ; "]\tc #2A72CF"
.data:0000016C                 dd offset $SG143538     ; "^\tc #73A0E0"
.data:00000170                 dd offset $SG143539     ; "/\tc #6B9DE0"
.data:00000174                 dd offset $SG143540     ; "(\tc #95B8E8"
.data:00000178                 dd offset $SG143541     ; "_\tc #81ABE3"
.data:0000017C                 dd offset $SG143542     ; ":\tc #72A1DF"
.data:00000180                 dd offset $SG143543     ; "<\tc #83ADE3"
.data:00000184                 dd offset $SG143544     ; "[\tc #1B65C9"
.data:00000188                 dd offset $SG143545     ; "}\tc #5F95DC"
.data:0000018C                 dd offset $SG143546     ; "|\tc #8BB3E5"
.data:00000190                 dd offset $SG143547     ; "1\tc #77A4E0"
.data:00000194                 dd offset $SG143548     ; "2\tc #679ADC"
.data:00000198                 dd offset $SG143549     ; "3\tc #7AA6E1"
.data:0000019C                 dd offset $SG143550     ; "4\tc #195CC6"
.data:000001A0                 dd offset $SG143551     ; "5\tc #FCFDFE"
.data:000001A4                 dd offset $SG143552     ; "6\tc #8DB2E4"
.data:000001A8                 dd offset $SG143553     ; "7\tc #4885D6"
.data:000001AC                 dd offset $SG143554     ; "8\tc #7CA9E1"
.data:000001B0                 dd offset $SG143555     ; "9\tc #6698DB"
.data:000001B4                 dd offset $SG143556     ; "0\tc #71A1DE"
.data:000001B8                 dd offset $SG143557     ; "a\tc #1752C0"
.data:000001BC                 dd offset $SG143558     ; "b\tc #88ABE0"
.data:000001C0                 dd offset $SG143559     ; "c\tc #3D77D0"
.data:000001C4                 dd offset $SG143560     ; "d\tc #6E9FDD"
.data:000001C8                 dd offset $SG143561     ; "e\tc #699BDC"
.data:000001CC                 dd offset $SG143562     ; "f\tc #1547BD"
.data:000001D0                 dd offset $SG143563     ; "g\tc #8DA6DE"
.data:000001D4                 dd offset $SG143564     ; "h\tc #376BC9"
.data:000001D8                 dd offset $SG143565     ; "i\tc #6295DA"
.data:000001DC                 dd offset $SG143566     ; "j\tc #1440B9"
.data:000001E0                 dd offset $SG143567     ; "k\tc #8DA0DB"
.data:000001E4                 dd offset $SG143568     ; "l\tc #315FC4"
.data:000001E8                 dd offset $SG143569     ; "m\tc #1339B7"
.data:000001EC                 dd offset $SG143570     ; "n\tc #909FDA"
.data:000001F0                 dd offset $SG143571     ; "o\tc #1233B4"
.data:000001F4                 dd offset $SG143572     ; "         .+ "
.data:000001F8                 dd offset $SG143573     ; "        @#$ "
.data:000001FC                 dd offset $SG143574     ; "       %&*= L"
.data:00000200                 dd offset $SG143575     ; "      -;>,' "
.data:00000204                 dd offset $SG143576     ; "     )!>~{] "
.data:00000208                 dd offset $SG143577     ; "    ^/(_:<[ "
.data:0000020C                 dd offset $SG143578     ; "    (}|1234 "
.data:00000210                 dd offset $SG143579     ; "    567890a "
.data:00000214                 dd offset $SG143580     ; "      bcdef "
.data:00000218                 dd offset $SG143581     ; "       ghij "
.data:0000021C                 dd offset $SG143582     ; "        klm "
.data:00000220                 dd offset $SG143583     ; "         no "
.data:00000224                 align 8
.data:00000228 _bookmark_xpm   dd offset $SG143585     ; "13 14 54 1"
.data:0000022C                 dd offset $SG143586     ; " \tc None"
.data:00000230                 dd offset $SG143587     ; ".\tc #545254"
.data:00000234                 dd offset $SG143588     ; "+\tc #3C3E3C"
.data:00000238                 dd offset $SG143589     ; "@\tc #646464"
.data:0000023C                 dd offset $SG143590     ; "#\tc #A4A4A4"
.data:00000240                 dd offset $SG143591     ; "$\tc #B7B8B7"
.data:00000244                 dd offset $SG143592     ; "%\tc #747284"
.data:00000248                 dd offset $SG143593     ; "&\tc #B4B2C4"
.data:0000024C                 dd offset $SG143594     ; "*\tc #DCD7E4"
.data:00000250                 dd offset $SG143595     ; "=\tc #1C1A1C"
.data:00000254                 dd offset $SG143596     ; "-\tc #403E58"
.data:00000258                 dd offset $SG143597     ; ";\tc #5C5A8C"
.data:0000025C                 dd offset $SG143598     ; ">\tc #7C7EAC"
.data:00000260                 dd offset $SG143599     ; ",\tc #7C8EBC"
.data:00000264                 dd offset $SG143600     ; "'\tc #242644"
.data:00000268                 dd offset $SG143601     ; ")\tc #282668"
.data:0000026C                 dd offset $SG143602     ; "!\tc #24367C"
.data:00000270                 dd offset $SG143603     ; "~\tc #244A84"
.data:00000274                 dd offset $SG143604     ; "{\tc #2C5098"
.data:00000278                 dd offset $SG143605     ; "]\tc #14162C"
.data:0000027C                 dd offset $SG143606     ; "^\tc #142E7C"
.data:00000280                 dd offset $SG143607     ; "/\tc #143789"
.data:00000284                 dd offset $SG143608     ; "(\tc #204990"
.data:00000288                 dd offset $SG143609     ; "_\tc #174091"
.data:0000028C                 dd offset $SG143610     ; ":\tc #0C0630"
.data:00000290                 dd offset $SG143611     ; "<\tc #24327C"
.data:00000294                 dd offset $SG143612     ; "[\tc #2450A0"
.data:00000298                 dd offset $SG143613     ; "}\tc #345DB4"
.data:0000029C                 dd offset $SG143614     ; "|\tc #3C68B8"
.data:000002A0                 dd offset $SG143615     ; "1\tc #141244"
.data:000002A4                 dd offset $SG143616     ; "2\tc #24428C"
.data:000002A8                 dd offset $SG143617     ; "3\tc #3462B9"
.data:000002AC                 dd offset $SG143618     ; "4\tc #4470C4"
.data:000002B0                 dd offset $SG143619     ; "5\tc #4C7FD6"
.data:000002B4                 dd offset $SG143620     ; "6\tc #4472CC"
.data:000002B8                 dd offset $SG143621     ; "7\tc #24224C"
.data:000002BC                 dd offset $SG143622     ; "8\tc #5C8DEC"
.data:000002C0                 dd offset $SG143623     ; "9\tc #5C94F6"
.data:000002C4                 dd offset $SG143624     ; "0\tc #5482DF"
.data:000002C8                 dd offset $SG143625     ; "a\tc #619DF7"
.data:000002CC                 dd offset $SG143626     ; "b\tc #6CA6FC"
.data:000002D0                 dd offset $SG143627     ; "c\tc #64A2FC"
.data:000002D4                 dd offset $SG143628     ; "d\tc #1C2E5C"
.data:000002D8                 dd offset $SG143629     ; "e\tc #6CA2FC"
.data:000002DC                 dd offset $SG143630     ; "f\tc #74B2FC"
.data:000002E0                 dd offset $SG143631     ; "g\tc #7CB8FC"
.data:000002E4                 dd offset $SG143632     ; "h\tc #1C3264"
.data:000002E8                 dd offset $SG143633     ; "i\tc #346AD4"
.data:000002EC                 dd offset $SG143634     ; "j\tc #7CBEFC"
.data:000002F0                 dd offset $SG143635     ; "k\tc #3C72DC"
.data:000002F4                 dd offset $SG143636     ; "l\tc #243250"
.data:000002F8                 dd offset $SG143637     ; "m\tc #346AB4"
.data:000002FC                 dd offset $SG143638     ; "n\tc #3C82DC"
.data:00000300                 dd offset $SG143639     ; "o\tc #6C6A6C"
.data:00000304                 dd offset $SG143640     ; "     .+.     "
.data:00000308                 dd offset $SG143641     ; "   @##$##@   "
.data:0000030C                 dd offset $SG143642     ; "  @%&***&%@  "
.data:00000310                 dd offset $SG143643     ; " =-;>,,,>;-= "
.data:00000314                 dd offset $SG143644     ; " ')!~{{{~!)' "
.data:00000318                 dd offset $SG143645     ; "])^/({{{(_^)]"
.data:0000031C                 dd offset $SG143646     ; ":<_[}|||}[_<:"
.data:00000320                 dd offset $SG143647     ; "12[3455563[21"
.data:00000324                 dd offset $SG143648     ; "7_365899063_7"
.data:00000328                 dd offset $SG143649     ; " /|09abc904/ "
.data:0000032C                 dd offset $SG143650     ; " d}8efgfb83d "
.data:00000330                 dd offset $SG143651     ; "  hiafjgakh  "
.data:00000334                 dd offset $SG143652     ; "   l~mnm~l   "
.data:00000338                 dd offset $SG143653     ; "     o@o     "
.data:00000338 _data           ends
.data:00000338
.rdata:0000033C ; ===========================================================================
.rdata:0000033C
.rdata:0000033C ; Segment type: Pure data
.rdata:0000033C ; Segment permissions: Read
.rdata:0000033C _rdata          segment dword public 'DATA' use32
.rdata:0000033C                 assume cs:_rdata
.rdata:0000033C                 ;org 33Ch
.rdata:0000033C $SG143447       db '12 12 56 1',0       ; DATA XREF: .data:_acTop_xpmo
.rdata:00000347                 align 4
.rdata:00000348 $SG143448       db ' ',9,'c #FFFFFF',0  ; DATA XREF: .data:00000004o
.rdata:00000354 $SG143449       db '.',9,'c #8AB2E9',0  ; DATA XREF: .data:00000008o
.rdata:00000360 $SG143450       db '+',9,'c #CCDCF6',0  ; DATA XREF: .data:0000000Co
.rdata:0000036C $SG143451       db '@',9,'c #80ABEA',0  ; DATA XREF: .data:00000010o
.rdata:00000378 $SG143452       db '#',9,'c #7DA9E8',0  ; DATA XREF: .data:00000014o
.rdata:00000384 $SG143453       db '$',9,'c #C7DAF3',0  ; DATA XREF: .data:00000018o
.rdata:00000390 $SG143454       db '%',9,'c #79A7E6',0  ; DATA XREF: .data:0000001Co
.rdata:0000039C $SG143455       db '&',9,'c #ADC8EF',0  ; DATA XREF: .data:00000020o
.rdata:000003A8 $SG143456       db '*',9,'c #87B0E8',0  ; DATA XREF: .data:00000024o
.rdata:000003B4 $SG143457       db '=',9,'c #BBD2F0',0  ; DATA XREF: .data:00000028o
.rdata:000003C0 $SG143458       db '-',9,'c #6EA0E2',0  ; DATA XREF: .data:0000002Co
.rdata:000003CC $SG143459       db ';',9,'c #A8C7EE',0  ; DATA XREF: .data:00000030o
.rdata:000003D8 $SG143460       db '>',9,'c #A3C2ED',0  ; DATA XREF: .data:00000034o
.rdata:000003E4 $SG143461       db ',',9,'c #75A4E3',0  ; DATA XREF: .data:00000038o
.rdata:000003F0 $SG143462       db 27h,9,'c #A7C4EB',0  ; DATA XREF: .data:0000003Co
.rdata:000003FC $SG143463       db ')',9,'c #6297E1',0  ; DATA XREF: .data:00000040o
.rdata:00000408 $SG143464       db '!',9,'c #A1C1EC',0  ; DATA XREF: .data:00000044o
.rdata:00000414 $SG143465       db '~',9,'c #92B7E8',0  ; DATA XREF: .data:00000048o
.rdata:00000420 $SG143466       db '{',9,'c #99BBE9',0  ; DATA XREF: .data:0000004Co
.rdata:0000042C $SG143467       db ']',9,'c #6197DD',0  ; DATA XREF: .data:00000050o
.rdata:00000438 $SG143468       db '^',9,'c #96B9E6',0  ; DATA XREF: .data:00000054o
.rdata:00000444 $SG143469       db '/',9,'c #538EDB',0  ; DATA XREF: .data:00000058o
.rdata:00000450 $SG143470       db '(',9,'c #99BBEA',0  ; DATA XREF: .data:0000005Co
.rdata:0000045C $SG143471       db '_',9,'c #80AAE3',0  ; DATA XREF: .data:00000060o
.rdata:00000468 $SG143472       db ':',9,'c #81ABE3',0  ; DATA XREF: .data:00000064o
.rdata:00000474 $SG143473       db '<',9,'c #8AB1E4',0  ; DATA XREF: .data:00000068o
.rdata:00000480 $SG143474       db '[',9,'c #4B88D6',0  ; DATA XREF: .data:0000006Co
.rdata:0000048C $SG143475       db '}',9,'c #4882D1',0  ; DATA XREF: .data:00000070o
.rdata:00000498 $SG143476       db '|',9,'c #4384D6',0  ; DATA XREF: .data:00000074o
.rdata:000004A4 $SG143477       db '1',9,'c #90B5E7',0  ; DATA XREF: .data:00000078o
.rdata:000004B0 $SG143478       db '2',9,'c #74A3E0',0  ; DATA XREF: .data:0000007Co
.rdata:000004BC $SG143479       db '3',9,'c #77A4E0',0  ; DATA XREF: .data:00000080o
.rdata:000004C8 $SG143480       db '4',9,'c #81ABE2',0  ; DATA XREF: .data:00000084o
.rdata:000004D4 $SG143481       db '5',9,'c #437FD3',0  ; DATA XREF: .data:00000088o
.rdata:000004E0 $SG143482       db '6',9,'c #7FA2DF',0  ; DATA XREF: .data:0000008Co
.rdata:000004EC $SG143483       db '7',9,'c #3577D2',0  ; DATA XREF: .data:00000090o
.rdata:000004F8 $SG143484       db '8',9,'c #87AFE4',0  ; DATA XREF: .data:00000094o
.rdata:00000504 $SG143485       db '9',9,'c #72A1DF',0  ; DATA XREF: .data:00000098o
.rdata:00000510 $SG143486       db '0',9,'c #7CA9E1',0  ; DATA XREF: .data:0000009Co
.rdata:0000051C $SG143487       db 'a',9,'c #3F7AD0',0  ; DATA XREF: .data:000000A0o
.rdata:00000528 $SG143488       db 'b',9,'c #85A4DE',0  ; DATA XREF: .data:000000A4o
.rdata:00000534 $SG143489       db 'c',9,'c #FBFCFE',0  ; DATA XREF: .data:000000A8o
.rdata:00000540 $SG143490       db 'd',9,'c #236ECD',0  ; DATA XREF: .data:000000ACo
.rdata:0000054C $SG143491       db 'e',9,'c #7EA8E1',0  ; DATA XREF: .data:000000B0o
.rdata:00000558 $SG143492       db 'f',9,'c #79A6E0',0  ; DATA XREF: .data:000000B4o
.rdata:00000564 $SG143493       db 'g',9,'c #3D77D0',0  ; DATA XREF: .data:000000B8o
.rdata:00000570 $SG143494       db 'h',9,'c #87A4DC',0  ; DATA XREF: .data:000000BCo
.rdata:0000057C $SG143495       db 'i',9,'c #1A62C9',0  ; DATA XREF: .data:000000C0o
.rdata:00000588 $SG143496       db 'j',9,'c #75A3DF',0  ; DATA XREF: .data:000000C4o
.rdata:00000594 $SG143497       db 'k',9,'c #3C74CF',0  ; DATA XREF: .data:000000C8o
.rdata:000005A0 $SG143498       db 'l',9,'c #8DA6DE',0  ; DATA XREF: .data:000000CCo
.rdata:000005AC $SG143499       db 'm',9,'c #1859C4',0  ; DATA XREF: .data:000000D0o
.rdata:000005B8 $SG143500       db 'n',9,'c #3B71CC',0  ; DATA XREF: .data:000000D4o
.rdata:000005C4 $SG143501       db 'o',9,'c #8EA5DD',0  ; DATA XREF: .data:000000D8o
.rdata:000005D0 $SG143502       db 'p',9,'c #164EC0',0  ; DATA XREF: .data:000000DCo
.rdata:000005DC $SG143503       db 'q',9,'c #92A7DD',0  ; DATA XREF: .data:000000E0o
.rdata:000005E8 $SG143504       db '    .+      ',0     ; DATA XREF: .data:000000E4o
.rdata:000005F5                 align 4
.rdata:000005F8 $SG143505       db '    @#$     ',0     ; DATA XREF: .data:000000E8o
.rdata:00000605                 align 4
.rdata:00000608 $SG143506       db '    %&*=    ',0     ; DATA XREF: .data:000000ECo
.rdata:00000615                 align 4
.rdata:00000618 $SG143507       db '    -;>,',27h,'   ',0 ; DATA XREF: .data:000000F0o
.rdata:00000625                 align 4
.rdata:00000628 $SG143508       db '    )!~{]^  ',0     ; DATA XREF: .data:000000F4o
.rdata:00000635                 align 4
.rdata:00000638 $SG143509       db '    /(_:<[} ',0     ; DATA XREF: .data:000000F8o
.rdata:00000645                 align 4
.rdata:00000648 $SG143510       db '    |123456 ',0     ; DATA XREF: .data:000000FCo
.rdata:00000655                 align 4
.rdata:00000658 $SG143511       db '    7890abc ',0     ; DATA XREF: .data:00000100o
.rdata:00000665                 align 4
.rdata:00000668 $SG143512       db '    defgh   ',0     ; DATA XREF: .data:00000104o
.rdata:00000675                 align 4
.rdata:00000678 $SG143513       db '    ijkl    ',0     ; DATA XREF: .data:00000108o
.rdata:00000685                 align 4
.rdata:00000688 $SG143514       db '    mno     ',0     ; DATA XREF: .data:0000010Co
.rdata:00000695                 align 4
.rdata:00000698 $SG143515       db '    pq      ',0     ; DATA XREF: .data:00000110o
.rdata:000006A5                 align 4
.rdata:000006A8 $SG143517       db '12 12 54 1',0       ; DATA XREF: .data:_acBottom_xpmo
.rdata:000006B3                 align 4
.rdata:000006B4 $SG143518       db ' ',9,'c #FFFFFF',0  ; DATA XREF: .data:0000011Co
.rdata:000006C0 $SG143519       db '.',9,'c #C4D7F3',0  ; DATA XREF: .data:00000120o
.rdata:000006CC $SG143520       db '+',9,'c #72A1E3',0  ; DATA XREF: .data:00000124o
.rdata:000006D8 $SG143521       db '@',9,'c #C1D6F2',0  ; DATA XREF: .data:00000128o
.rdata:000006E4 $SG143522       db '#',9,'c #6397E1',0  ; DATA XREF: .data:0000012Co
.rdata:000006F0 $SG143523       db '$',9,'c #5990DD',0  ; DATA XREF: .data:00000130o
.rdata:000006FC $SG143524       db '%',9,'c #BBD2F0',0  ; DATA XREF: .data:00000134o
.rdata:00000708 $SG143525       db '&',9,'c #7AA6E5',0  ; DATA XREF: .data:00000138o
.rdata:00000714 $SG143526       db '*',9,'c #9ABDEA',0  ; DATA XREF: .data:0000013Co
.rdata:00000720 $SG143527       db '=',9,'c #4A87D9',0  ; DATA XREF: .data:00000140o
.rdata:0000072C $SG143528       db '-',9,'c #B1CAEE',0  ; DATA XREF: .data:00000144o
.rdata:00000738 $SG143529       db ';',9,'c #75A4E3',0  ; DATA XREF: .data:00000148o
.rdata:00000744 $SG143530       db '>',9,'c #99BBE9',0  ; DATA XREF: .data:0000014Co
.rdata:00000750 $SG143531       db ',',9,'c #95B9E8',0  ; DATA XREF: .data:00000150o
.rdata:0000075C $SG143532       db 27h,9,'c #3A7CD4',0  ; DATA XREF: .data:00000154o
.rdata:00000768 $SG143533       db ')',9,'c #A9C6EC',0  ; DATA XREF: .data:00000158o
.rdata:00000774 $SG143534       db '!',9,'c #71A0E0',0  ; DATA XREF: .data:0000015Co
.rdata:00000780 $SG143535       db '~',9,'c #86AFE5',0  ; DATA XREF: .data:00000160o
.rdata:0000078C $SG143536       db '{',9,'c #8DB2E6',0  ; DATA XREF: .data:00000164o
.rdata:00000798 $SG143537       db ']',9,'c #2A72CF',0  ; DATA XREF: .data:00000168o
.rdata:000007A4 $SG143538       db '^',9,'c #73A0E0',0  ; DATA XREF: .data:0000016Co
.rdata:000007B0 $SG143539       db '/',9,'c #6B9DE0',0  ; DATA XREF: .data:00000170o
.rdata:000007BC $SG143540       db '(',9,'c #95B8E8',0  ; DATA XREF: .data:00000174o
.rdata:000007C8 $SG143541       db '_',9,'c #81ABE3',0  ; DATA XREF: .data:00000178o
.rdata:000007D4 $SG143542       db ':',9,'c #72A1DF',0  ; DATA XREF: .data:0000017Co
.rdata:000007E0 $SG143543       db '<',9,'c #83ADE3',0  ; DATA XREF: .data:00000180o
.rdata:000007EC $SG143544       db '[',9,'c #1B65C9',0  ; DATA XREF: .data:00000184o
.rdata:000007F8 $SG143545       db '}',9,'c #5F95DC',0  ; DATA XREF: .data:00000188o
.rdata:00000804 $SG143546       db '|',9,'c #8BB3E5',0  ; DATA XREF: .data:0000018Co
.rdata:00000810 $SG143547       db '1',9,'c #77A4E0',0  ; DATA XREF: .data:00000190o
.rdata:0000081C $SG143548       db '2',9,'c #679ADC',0  ; DATA XREF: .data:00000194o
.rdata:00000828 $SG143549       db '3',9,'c #7AA6E1',0  ; DATA XREF: .data:00000198o
.rdata:00000834 $SG143550       db '4',9,'c #195CC6',0  ; DATA XREF: .data:0000019Co
.rdata:00000840 $SG143551       db '5',9,'c #FCFDFE',0  ; DATA XREF: .data:000001A0o
.rdata:0000084C $SG143552       db '6',9,'c #8DB2E4',0  ; DATA XREF: .data:000001A4o
.rdata:00000858 $SG143553       db '7',9,'c #4885D6',0  ; DATA XREF: .data:000001A8o
.rdata:00000864 $SG143554       db '8',9,'c #7CA9E1',0  ; DATA XREF: .data:000001ACo
.rdata:00000870 $SG143555       db '9',9,'c #6698DB',0  ; DATA XREF: .data:000001B0o
.rdata:0000087C $SG143556       db '0',9,'c #71A1DE',0  ; DATA XREF: .data:000001B4o
.rdata:00000888 $SG143557       db 'a',9,'c #1752C0',0  ; DATA XREF: .data:000001B8o
.rdata:00000894 $SG143558       db 'b',9,'c #88ABE0',0  ; DATA XREF: .data:000001BCo
.rdata:000008A0 $SG143559       db 'c',9,'c #3D77D0',0  ; DATA XREF: .data:000001C0o
.rdata:000008AC $SG143560       db 'd',9,'c #6E9FDD',0  ; DATA XREF: .data:000001C4o
.rdata:000008B8 $SG143561       db 'e',9,'c #699BDC',0  ; DATA XREF: .data:000001C8o
.rdata:000008C4 $SG143562       db 'f',9,'c #1547BD',0  ; DATA XREF: .data:000001CCo
.rdata:000008D0 $SG143563       db 'g',9,'c #8DA6DE',0  ; DATA XREF: .data:000001D0o
.rdata:000008DC $SG143564       db 'h',9,'c #376BC9',0  ; DATA XREF: .data:000001D4o
.rdata:000008E8 $SG143565       db 'i',9,'c #6295DA',0  ; DATA XREF: .data:000001D8o
.rdata:000008F4 $SG143566       db 'j',9,'c #1440B9',0  ; DATA XREF: .data:000001DCo
.rdata:00000900 $SG143567       db 'k',9,'c #8DA0DB',0  ; DATA XREF: .data:000001E0o
.rdata:0000090C $SG143568       db 'l',9,'c #315FC4',0  ; DATA XREF: .data:000001E4o
.rdata:00000918 $SG143569       db 'm',9,'c #1339B7',0  ; DATA XREF: .data:000001E8o
.rdata:00000924 $SG143570       db 'n',9,'c #909FDA',0  ; DATA XREF: .data:000001ECo
.rdata:00000930 $SG143571       db 'o',9,'c #1233B4',0  ; DATA XREF: .data:000001F0o
.rdata:0000093C $SG143572       db '         .+ ',0     ; DATA XREF: .data:000001F4o
.rdata:00000949                 align 4
.rdata:0000094C $SG143573       db '        @#$ ',0     ; DATA XREF: .data:000001F8o
.rdata:00000959                 align 4
.rdata:0000095C $SG143574       db '       %&*= L',0    ; DATA XREF: .data:000001FCo
.rdata:0000096A                 align 4
.rdata:0000096C $SG143575       db '      -;>,',27h,' ',0 ; DATA XREF: .data:00000200o
.rdata:00000979                 align 4
.rdata:0000097C $SG143576       db '     )!>~{] ',0     ; DATA XREF: .data:00000204o
.rdata:00000989                 align 4
.rdata:0000098C $SG143577       db '    ^/(_:<[ ',0     ; DATA XREF: .data:00000208o
.rdata:00000999                 align 4
.rdata:0000099C $SG143578       db '    (}|1234 ',0     ; DATA XREF: .data:0000020Co
.rdata:000009A9                 align 4
.rdata:000009AC $SG143579       db '    567890a ',0     ; DATA XREF: .data:00000210o
.rdata:000009B9                 align 4
.rdata:000009BC $SG143580       db '      bcdef ',0     ; DATA XREF: .data:00000214o
.rdata:000009C9                 align 4
.rdata:000009CC $SG143581       db '       ghij ',0     ; DATA XREF: .data:00000218o
.rdata:000009D9                 align 4
.rdata:000009DC $SG143582       db '        klm ',0     ; DATA XREF: .data:0000021Co
.rdata:000009E9                 align 4
.rdata:000009EC $SG143583       db '         no ',0     ; DATA XREF: .data:00000220o
.rdata:000009F9                 align 4
.rdata:000009FC $SG143585       db '13 14 54 1',0       ; DATA XREF: .data:_bookmark_xpmo
.rdata:00000A07                 align 4
.rdata:00000A08 $SG143586       db ' ',9,'c None',0     ; DATA XREF: .data:0000022Co
.rdata:00000A11                 align 4
.rdata:00000A14 $SG143587       db '.',9,'c #545254',0  ; DATA XREF: .data:00000230o
.rdata:00000A20 $SG143588       db '+',9,'c #3C3E3C',0  ; DATA XREF: .data:00000234o
.rdata:00000A2C $SG143589       db '@',9,'c #646464',0  ; DATA XREF: .data:00000238o
.rdata:00000A38 $SG143590       db '#',9,'c #A4A4A4',0  ; DATA XREF: .data:0000023Co
.rdata:00000A44 $SG143591       db '$',9,'c #B7B8B7',0  ; DATA XREF: .data:00000240o
.rdata:00000A50 $SG143592       db '%',9,'c #747284',0  ; DATA XREF: .data:00000244o
.rdata:00000A5C $SG143593       db '&',9,'c #B4B2C4',0  ; DATA XREF: .data:00000248o
.rdata:00000A68 $SG143594       db '*',9,'c #DCD7E4',0  ; DATA XREF: .data:0000024Co
.rdata:00000A74 $SG143595       db '=',9,'c #1C1A1C',0  ; DATA XREF: .data:00000250o
.rdata:00000A80 $SG143596       db '-',9,'c #403E58',0  ; DATA XREF: .data:00000254o
.rdata:00000A8C $SG143597       db ';',9,'c #5C5A8C',0  ; DATA XREF: .data:00000258o
.rdata:00000A98 $SG143598       db '>',9,'c #7C7EAC',0  ; DATA XREF: .data:0000025Co
.rdata:00000AA4 $SG143599       db ',',9,'c #7C8EBC',0  ; DATA XREF: .data:00000260o
.rdata:00000AB0 $SG143600       db 27h,9,'c #242644',0  ; DATA XREF: .data:00000264o
.rdata:00000ABC $SG143601       db ')',9,'c #282668',0  ; DATA XREF: .data:00000268o
.rdata:00000AC8 $SG143602       db '!',9,'c #24367C',0  ; DATA XREF: .data:0000026Co
.rdata:00000AD4 $SG143603       db '~',9,'c #244A84',0  ; DATA XREF: .data:00000270o
.rdata:00000AE0 $SG143604       db '{',9,'c #2C5098',0  ; DATA XREF: .data:00000274o
.rdata:00000AEC $SG143605       db ']',9,'c #14162C',0  ; DATA XREF: .data:00000278o
.rdata:00000AF8 $SG143606       db '^',9,'c #142E7C',0  ; DATA XREF: .data:0000027Co
.rdata:00000B04 $SG143607       db '/',9,'c #143789',0  ; DATA XREF: .data:00000280o
.rdata:00000B10 $SG143608       db '(',9,'c #204990',0  ; DATA XREF: .data:00000284o
.rdata:00000B1C $SG143609       db '_',9,'c #174091',0  ; DATA XREF: .data:00000288o
.rdata:00000B28 $SG143610       db ':',9,'c #0C0630',0  ; DATA XREF: .data:0000028Co
.rdata:00000B34 $SG143611       db '<',9,'c #24327C',0  ; DATA XREF: .data:00000290o
.rdata:00000B40 $SG143612       db '[',9,'c #2450A0',0  ; DATA XREF: .data:00000294o
.rdata:00000B4C $SG143613       db '}',9,'c #345DB4',0  ; DATA XREF: .data:00000298o
.rdata:00000B58 $SG143614       db '|',9,'c #3C68B8',0  ; DATA XREF: .data:0000029Co
.rdata:00000B64 $SG143615       db '1',9,'c #141244',0  ; DATA XREF: .data:000002A0o
.rdata:00000B70 $SG143616       db '2',9,'c #24428C',0  ; DATA XREF: .data:000002A4o
.rdata:00000B7C $SG143617       db '3',9,'c #3462B9',0  ; DATA XREF: .data:000002A8o
.rdata:00000B88 $SG143618       db '4',9,'c #4470C4',0  ; DATA XREF: .data:000002ACo
.rdata:00000B94 $SG143619       db '5',9,'c #4C7FD6',0  ; DATA XREF: .data:000002B0o
.rdata:00000BA0 $SG143620       db '6',9,'c #4472CC',0  ; DATA XREF: .data:000002B4o
.rdata:00000BAC $SG143621       db '7',9,'c #24224C',0  ; DATA XREF: .data:000002B8o
.rdata:00000BB8 $SG143622       db '8',9,'c #5C8DEC',0  ; DATA XREF: .data:000002BCo
.rdata:00000BC4 $SG143623       db '9',9,'c #5C94F6',0  ; DATA XREF: .data:000002C0o
.rdata:00000BD0 $SG143624       db '0',9,'c #5482DF',0  ; DATA XREF: .data:000002C4o
.rdata:00000BDC $SG143625       db 'a',9,'c #619DF7',0  ; DATA XREF: .data:000002C8o
.rdata:00000BE8 $SG143626       db 'b',9,'c #6CA6FC',0  ; DATA XREF: .data:000002CCo
.rdata:00000BF4 $SG143627       db 'c',9,'c #64A2FC',0  ; DATA XREF: .data:000002D0o
.rdata:00000C00 $SG143628       db 'd',9,'c #1C2E5C',0  ; DATA XREF: .data:000002D4o
.rdata:00000C0C $SG143629       db 'e',9,'c #6CA2FC',0  ; DATA XREF: .data:000002D8o
.rdata:00000C18 $SG143630       db 'f',9,'c #74B2FC',0  ; DATA XREF: .data:000002DCo
.rdata:00000C24 $SG143631       db 'g',9,'c #7CB8FC',0  ; DATA XREF: .data:000002E0o
.rdata:00000C30 $SG143632       db 'h',9,'c #1C3264',0  ; DATA XREF: .data:000002E4o
.rdata:00000C3C $SG143633       db 'i',9,'c #346AD4',0  ; DATA XREF: .data:000002E8o
.rdata:00000C48 $SG143634       db 'j',9,'c #7CBEFC',0  ; DATA XREF: .data:000002ECo
.rdata:00000C54 $SG143635       db 'k',9,'c #3C72DC',0  ; DATA XREF: .data:000002F0o
.rdata:00000C60 $SG143636       db 'l',9,'c #243250',0  ; DATA XREF: .data:000002F4o
.rdata:00000C6C $SG143637       db 'm',9,'c #346AB4',0  ; DATA XREF: .data:000002F8o
.rdata:00000C78 $SG143638       db 'n',9,'c #3C82DC',0  ; DATA XREF: .data:000002FCo
.rdata:00000C84 $SG143639       db 'o',9,'c #6C6A6C',0  ; DATA XREF: .data:00000300o
.rdata:00000C90 $SG143640       db '     .+.     ',0    ; DATA XREF: .data:00000304o
.rdata:00000C9E                 align 10h
.rdata:00000CA0 $SG143641       db '   @##$##@   ',0    ; DATA XREF: .data:00000308o
.rdata:00000CAE                 align 10h
.rdata:00000CB0 $SG143642       db '  @%&***&%@  ',0    ; DATA XREF: .data:0000030Co
.rdata:00000CBE                 align 10h
.rdata:00000CC0 $SG143643       db ' =-;>,,,>;-= ',0    ; DATA XREF: .data:00000310o
.rdata:00000CCE                 align 10h
.rdata:00000CD0 $SG143644       db ' ',27h,')!~{{{~!)',27h,' ',0
.rdata:00000CD0                                         ; DATA XREF: .data:00000314o
.rdata:00000CDE                 align 10h
.rdata:00000CE0 $SG143645       db '])^/({{{(_^)]',0    ; DATA XREF: .data:00000318o
.rdata:00000CEE                 align 10h
.rdata:00000CF0 $SG143646       db ':<_[}|||}[_<:',0    ; DATA XREF: .data:0000031Co
.rdata:00000CFE                 align 10h
.rdata:00000D00 $SG143647       db '12[3455563[21',0    ; DATA XREF: .data:00000320o
.rdata:00000D0E                 align 10h
.rdata:00000D10 $SG143648       db '7_365899063_7',0    ; DATA XREF: .data:00000324o
.rdata:00000D1E                 align 10h
.rdata:00000D20 $SG143649       db ' /|09abc904/ ',0    ; DATA XREF: .data:00000328o
.rdata:00000D2E                 align 10h
.rdata:00000D30 $SG143650       db ' d}8efgfb83d ',0    ; DATA XREF: .data:0000032Co
.rdata:00000D3E                 align 10h
.rdata:00000D40 $SG143651       db '  hiafjgakh  ',0    ; DATA XREF: .data:00000330o
.rdata:00000D4E                 align 10h
.rdata:00000D50 $SG143652       db '   l~mnm~l   ',0    ; DATA XREF: .data:00000334o
.rdata:00000D5E                 align 10h
.rdata:00000D60 $SG143653       db '     o@o     ',0    ; DATA XREF: .data:00000338o
.rdata:00000D6E                 align 10h
.rdata:00000D6E _rdata          ends
.rdata:00000D6E
.text$mn:00000D70 ; ===========================================================================
.text$mn:00000D70
.text$mn:00000D70 ; Segment type: Pure code
.text$mn:00000D70 ; Segment permissions: Read/Execute
.text$mn:00000D70 _text$mn        segment para public 'CODE' use32
.text$mn:00000D70                 assume cs:_text$mn
.text$mn:00000D70                 ;org 0D70h
.text$mn:00000D70                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00000D70
.text$mn:00000D70 ; =============== S U B R O U T I N E =======================================
.text$mn:00000D70
.text$mn:00000D70 ; Attributes: bp-based frame
.text$mn:00000D70
.text$mn:00000D70 ; HWND __thiscall ScintillaCtrls::createSintilla(ScintillaCtrls *this, HWND)
.text$mn:00000D70                 public ?createSintilla@ScintillaCtrls@@QAEPAUHWND__@@PAU2@@Z
.text$mn:00000D70 ?createSintilla@ScintillaCtrls@@QAEPAUHWND__@@PAU2@@Z proc near
.text$mn:00000D70
.text$mn:00000D70 var_20          = dword ptr -20h
.text$mn:00000D70 var_1C          = dword ptr -1Ch
.text$mn:00000D70 var_18          = dword ptr -18h
.text$mn:00000D70 var_14          = dword ptr -14h
.text$mn:00000D70 var_10          = dword ptr -10h
.text$mn:00000D70 var_C           = dword ptr -0Ch
.text$mn:00000D70 var_4           = dword ptr -4
.text$mn:00000D70 arg_0           = dword ptr  8
.text$mn:00000D70
.text$mn:00000D70                 push    ebp
.text$mn:00000D71                 mov     ebp, esp
.text$mn:00000D73                 push    0FFFFFFFFh
.text$mn:00000D75                 push    offset __ehhandler$?createSintilla@ScintillaCtrls@@QAEPAUHWND__@@PAU2@@Z
.text$mn:00000D7A                 mov     eax, large fs:0
.text$mn:00000D80                 push    eax
.text$mn:00000D81                 sub     esp, 14h
.text$mn:00000D84                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000D89                 xor     eax, ebp
.text$mn:00000D8B                 push    eax
.text$mn:00000D8C                 lea     eax, [ebp+var_C]
.text$mn:00000D8F                 mov     large fs:0, eax
.text$mn:00000D95                 mov     [ebp+var_10], ecx
.text$mn:00000D98                 mov     eax, [ebp+var_10]
.text$mn:00000D9B                 mov     ecx, [ebp+arg_0]
.text$mn:00000D9E                 mov     [eax+14h], ecx
.text$mn:00000DA1                 push    5Ch ; '\'       ; unsigned int
.text$mn:00000DA3                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00000DA8                 add     esp, 4
.text$mn:00000DAB                 mov     [ebp+var_18], eax
.text$mn:00000DAE                 mov     [ebp+var_4], 0
.text$mn:00000DB5                 cmp     [ebp+var_18], 0
.text$mn:00000DB9                 jz      short loc_DC8
.text$mn:00000DBB                 mov     ecx, [ebp+var_18]
.text$mn:00000DBE                 call    ??0ScintillaEditView@@QAE@XZ ; ScintillaEditView::ScintillaEditView(void)
.text$mn:00000DC3                 mov     [ebp+var_1C], eax
.text$mn:00000DC6                 jmp     short loc_DCF
.text$mn:00000DC8 ; ---------------------------------------------------------------------------
.text$mn:00000DC8
.text$mn:00000DC8 loc_DC8:                                ; CODE XREF: ScintillaCtrls::createSintilla(HWND__ *)+49j
.text$mn:00000DC8                 mov     [ebp+var_1C], 0
.text$mn:00000DCF
.text$mn:00000DCF loc_DCF:                                ; CODE XREF: ScintillaCtrls::createSintilla(HWND__ *)+56j
.text$mn:00000DCF                 mov     edx, [ebp+var_1C]
.text$mn:00000DD2                 mov     [ebp+var_20], edx
.text$mn:00000DD5                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000DDC                 mov     eax, [ebp+var_20]
.text$mn:00000DDF                 mov     [ebp+var_14], eax
.text$mn:00000DE2                 mov     ecx, [ebp+var_10]
.text$mn:00000DE5                 mov     edx, [ecx+14h]
.text$mn:00000DE8                 push    edx
.text$mn:00000DE9                 mov     eax, [ebp+var_10]
.text$mn:00000DEC                 mov     ecx, [eax+10h]
.text$mn:00000DEF                 push    ecx
.text$mn:00000DF0                 mov     edx, [ebp+var_14]
.text$mn:00000DF3                 mov     eax, [edx]
.text$mn:00000DF5                 mov     ecx, [ebp+var_14]
.text$mn:00000DF8                 mov     edx, [eax+4]
.text$mn:00000DFB                 call    edx
.text$mn:00000DFD                 lea     eax, [ebp+var_14]
.text$mn:00000E00                 push    eax
.text$mn:00000E01                 mov     ecx, [ebp+var_10]
.text$mn:00000E04                 call    ?push_back@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@QAEXABQAVScintillaEditView@@@Z ; std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::push_back(ScintillaEditView * const &)
.text$mn:00000E09                 mov     ecx, [ebp+var_14] ; this
.text$mn:00000E0C                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:00000E11                 mov     ecx, [ebp+var_C]
.text$mn:00000E14                 mov     large fs:0, ecx
.text$mn:00000E1B                 pop     ecx
.text$mn:00000E1C                 mov     esp, ebp
.text$mn:00000E1E                 pop     ebp
.text$mn:00000E1F                 retn    4
.text$mn:00000E1F ?createSintilla@ScintillaCtrls@@QAEPAUHWND__@@PAU2@@Z endp
.text$mn:00000E1F
.text$mn:00000E1F ; ---------------------------------------------------------------------------
.text$mn:00000E22                 align 10h
.text$mn:00000E30
.text$mn:00000E30 ; =============== S U B R O U T I N E =======================================
.text$mn:00000E30
.text$mn:00000E30 ; Attributes: bp-based frame
.text$mn:00000E30
.text$mn:00000E30 ; struct ScintillaEditView *__thiscall ScintillaCtrls::getScintillaEditViewFrom(ScintillaCtrls *this, HWND)
.text$mn:00000E30                 public ?getScintillaEditViewFrom@ScintillaCtrls@@QAEPAVScintillaEditView@@PAUHWND__@@@Z
.text$mn:00000E30 ?getScintillaEditViewFrom@ScintillaCtrls@@QAEPAVScintillaEditView@@PAUHWND__@@@Z proc near
.text$mn:00000E30
.text$mn:00000E30 var_8           = dword ptr -8
.text$mn:00000E30 var_4           = dword ptr -4
.text$mn:00000E30 arg_0           = dword ptr  8
.text$mn:00000E30
.text$mn:00000E30                 push    ebp
.text$mn:00000E31                 mov     ebp, esp
.text$mn:00000E33                 sub     esp, 8
.text$mn:00000E36                 mov     [ebp+var_8], ecx
.text$mn:00000E39                 mov     eax, [ebp+arg_0]
.text$mn:00000E3C                 push    eax             ; HWND
.text$mn:00000E3D                 mov     ecx, [ebp+var_8] ; this
.text$mn:00000E40                 call    ?getIndexFrom@ScintillaCtrls@@AAEHPAUHWND__@@@Z ; ScintillaCtrls::getIndexFrom(HWND__ *)
.text$mn:00000E45                 mov     [ebp+var_4], eax
.text$mn:00000E48                 cmp     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000E4C                 jz      short loc_E5B
.text$mn:00000E4E                 mov     ecx, [ebp+var_8]
.text$mn:00000E51                 call    ?size@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@QBEIXZ ; std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::size(void)
.text$mn:00000E56                 cmp     [ebp+var_4], eax
.text$mn:00000E59                 jb      short loc_E5F
.text$mn:00000E5B
.text$mn:00000E5B loc_E5B:                                ; CODE XREF: ScintillaCtrls::getScintillaEditViewFrom(HWND__ *)+1Cj
.text$mn:00000E5B                 xor     eax, eax
.text$mn:00000E5D                 jmp     short loc_E6D
.text$mn:00000E5F ; ---------------------------------------------------------------------------
.text$mn:00000E5F
.text$mn:00000E5F loc_E5F:                                ; CODE XREF: ScintillaCtrls::getScintillaEditViewFrom(HWND__ *)+29j
.text$mn:00000E5F                 mov     ecx, [ebp+var_4]
.text$mn:00000E62                 push    ecx
.text$mn:00000E63                 mov     ecx, [ebp+var_8]
.text$mn:00000E66                 call    ??A?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@QAEAAPAVScintillaEditView@@I@Z ; std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::operator[](uint)
.text$mn:00000E6B                 mov     eax, [eax]
.text$mn:00000E6D
.text$mn:00000E6D loc_E6D:                                ; CODE XREF: ScintillaCtrls::getScintillaEditViewFrom(HWND__ *)+2Dj
.text$mn:00000E6D                 mov     esp, ebp
.text$mn:00000E6F                 pop     ebp
.text$mn:00000E70                 retn    4
.text$mn:00000E70 ?getScintillaEditViewFrom@ScintillaCtrls@@QAEPAVScintillaEditView@@PAUHWND__@@@Z endp
.text$mn:00000E70
.text$mn:00000E70 ; ---------------------------------------------------------------------------
.text$mn:00000E73                 align 10h
.text$mn:00000E80
.text$mn:00000E80 ; =============== S U B R O U T I N E =======================================
.text$mn:00000E80
.text$mn:00000E80 ; Attributes: bp-based frame
.text$mn:00000E80
.text$mn:00000E80 ; bool __thiscall ScintillaCtrls::destroyScintilla(ScintillaCtrls *this, HWND)
.text$mn:00000E80                 public ?destroyScintilla@ScintillaCtrls@@QAE_NPAUHWND__@@@Z
.text$mn:00000E80 ?destroyScintilla@ScintillaCtrls@@QAE_NPAUHWND__@@@Z proc near
.text$mn:00000E80
.text$mn:00000E80 var_64          = dword ptr -64h
.text$mn:00000E80 var_58          = byte ptr -58h
.text$mn:00000E80 var_4C          = dword ptr -4Ch
.text$mn:00000E80 var_40          = dword ptr -40h
.text$mn:00000E80 var_3C          = dword ptr -3Ch
.text$mn:00000E80 var_38          = dword ptr -38h
.text$mn:00000E80 var_34          = dword ptr -34h
.text$mn:00000E80 var_30          = dword ptr -30h
.text$mn:00000E80 var_2C          = dword ptr -2Ch
.text$mn:00000E80 var_28          = dword ptr -28h
.text$mn:00000E80 var_24          = dword ptr -24h
.text$mn:00000E80 var_20          = dword ptr -20h
.text$mn:00000E80 var_1C          = dword ptr -1Ch
.text$mn:00000E80 Dst             = dword ptr -18h
.text$mn:00000E80 var_14          = dword ptr -14h
.text$mn:00000E80 var_D           = byte ptr -0Dh
.text$mn:00000E80 var_C           = dword ptr -0Ch
.text$mn:00000E80 var_4           = dword ptr -4
.text$mn:00000E80 arg_0           = dword ptr  8
.text$mn:00000E80
.text$mn:00000E80                 push    ebp
.text$mn:00000E81                 mov     ebp, esp
.text$mn:00000E83                 push    0FFFFFFFFh
.text$mn:00000E85                 push    offset __ehhandler$?destroyScintilla@ScintillaCtrls@@QAE_NPAUHWND__@@@Z
.text$mn:00000E8A                 mov     eax, large fs:0
.text$mn:00000E90                 push    eax
.text$mn:00000E91                 sub     esp, 58h
.text$mn:00000E94                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000E99                 xor     eax, ebp
.text$mn:00000E9B                 push    eax
.text$mn:00000E9C                 lea     eax, [ebp+var_C]
.text$mn:00000E9F                 mov     large fs:0, eax
.text$mn:00000EA5                 mov     [ebp+var_14], ecx
.text$mn:00000EA8                 mov     eax, [ebp+arg_0]
.text$mn:00000EAB                 push    eax             ; HWND
.text$mn:00000EAC                 mov     ecx, [ebp+var_14] ; this
.text$mn:00000EAF                 call    ?getIndexFrom@ScintillaCtrls@@AAEHPAUHWND__@@@Z ; ScintillaCtrls::getIndexFrom(HWND__ *)
.text$mn:00000EB4                 mov     [ebp+Dst], eax
.text$mn:00000EB7                 cmp     [ebp+Dst], 0FFFFFFFFh
.text$mn:00000EBB                 jnz     short loc_EC4
.text$mn:00000EBD                 xor     al, al
.text$mn:00000EBF                 jmp     loc_FA0
.text$mn:00000EC4 ; ---------------------------------------------------------------------------
.text$mn:00000EC4
.text$mn:00000EC4 loc_EC4:                                ; CODE XREF: ScintillaCtrls::destroyScintilla(HWND__ *)+3Bj
.text$mn:00000EC4                 mov     ecx, [ebp+Dst]
.text$mn:00000EC7                 push    ecx
.text$mn:00000EC8                 mov     ecx, [ebp+var_14]
.text$mn:00000ECB                 call    ??A?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@QAEAAPAVScintillaEditView@@I@Z ; std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::operator[](uint)
.text$mn:00000ED0                 mov     edx, [eax]
.text$mn:00000ED2                 mov     [ebp+var_20], edx
.text$mn:00000ED5                 mov     eax, [ebp+var_20]
.text$mn:00000ED8                 mov     edx, [eax]
.text$mn:00000EDA                 mov     ecx, [ebp+var_20]
.text$mn:00000EDD                 mov     eax, [edx+8]
.text$mn:00000EE0                 call    eax
.text$mn:00000EE2                 mov     ecx, [ebp+Dst]
.text$mn:00000EE5                 push    ecx
.text$mn:00000EE6                 mov     ecx, [ebp+var_14]
.text$mn:00000EE9                 call    ??A?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@QAEAAPAVScintillaEditView@@I@Z ; std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::operator[](uint)
.text$mn:00000EEE                 mov     edx, [eax]
.text$mn:00000EF0                 mov     [ebp+var_24], edx
.text$mn:00000EF3                 mov     eax, [ebp+var_24]
.text$mn:00000EF6                 mov     [ebp+var_1C], eax
.text$mn:00000EF9                 cmp     [ebp+var_1C], 0
.text$mn:00000EFD                 jz      short loc_F12
.text$mn:00000EFF                 push    1
.text$mn:00000F01                 mov     ecx, [ebp+var_1C]
.text$mn:00000F04                 mov     edx, [ecx]
.text$mn:00000F06                 mov     ecx, [ebp+var_1C]
.text$mn:00000F09                 mov     eax, [edx]
.text$mn:00000F0B                 call    eax
.text$mn:00000F0D                 mov     [ebp+var_28], eax
.text$mn:00000F10                 jmp     short loc_F19
.text$mn:00000F12 ; ---------------------------------------------------------------------------
.text$mn:00000F12
.text$mn:00000F12 loc_F12:                                ; CODE XREF: ScintillaCtrls::destroyScintilla(HWND__ *)+7Dj
.text$mn:00000F12                 mov     [ebp+var_28], 0
.text$mn:00000F19
.text$mn:00000F19 loc_F19:                                ; CODE XREF: ScintillaCtrls::destroyScintilla(HWND__ *)+90j
.text$mn:00000F19                 mov     ecx, [ebp+Dst]
.text$mn:00000F1C                 push    ecx             ; Dst
.text$mn:00000F1D                 lea     edx, [ebp+var_4C]
.text$mn:00000F20                 push    edx             ; int
.text$mn:00000F21                 lea     eax, [ebp+var_58]
.text$mn:00000F24                 push    eax             ; char
.text$mn:00000F25                 mov     ecx, [ebp+var_14]
.text$mn:00000F28                 call    ?begin@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@2@XZ ; std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::begin(void)
.text$mn:00000F2D                 mov     [ebp+var_2C], eax
.text$mn:00000F30                 mov     ecx, [ebp+var_2C]
.text$mn:00000F33                 mov     [ebp+var_30], ecx
.text$mn:00000F36                 mov     [ebp+var_4], 0
.text$mn:00000F3D                 mov     ecx, [ebp+var_30]
.text$mn:00000F40                 call    ??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>::operator+(int)
.text$mn:00000F45                 mov     byte ptr [ebp+var_4], 2
.text$mn:00000F49                 lea     ecx, [ebp+var_58]
.text$mn:00000F4C                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>(void)
.text$mn:00000F51                 sub     esp, 0Ch
.text$mn:00000F54                 mov     ecx, esp
.text$mn:00000F56                 mov     [ebp+var_38], esp
.text$mn:00000F59                 lea     edx, [ebp+var_4C]
.text$mn:00000F5C                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:00000F5D                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>> const &)
.text$mn:00000F62                 mov     [ebp+var_34], eax
.text$mn:00000F65                 mov     eax, [ebp+var_34]
.text$mn:00000F68                 mov     [ebp+var_3C], eax
.text$mn:00000F6B                 mov     byte ptr [ebp+var_4], 3
.text$mn:00000F6F                 lea     ecx, [ebp+var_64]
.text$mn:00000F72                 push    ecx             ; int
.text$mn:00000F73                 mov     ecx, [ebp+var_14]
.text$mn:00000F76                 mov     byte ptr [ebp+var_4], 2
.text$mn:00000F7A                 call    ?erase@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@2@@Z ; std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::erase(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>)
.text$mn:00000F7F                 mov     [ebp+var_40], eax
.text$mn:00000F82                 lea     ecx, [ebp+var_64]
.text$mn:00000F85                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>(void)
.text$mn:00000F8A                 mov     [ebp+var_D], 1
.text$mn:00000F8E                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000F95                 lea     ecx, [ebp+var_4C]
.text$mn:00000F98                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>(void)
.text$mn:00000F9D                 mov     al, [ebp+var_D]
.text$mn:00000FA0
.text$mn:00000FA0 loc_FA0:                                ; CODE XREF: ScintillaCtrls::destroyScintilla(HWND__ *)+3Fj
.text$mn:00000FA0                 mov     ecx, [ebp+var_C]
.text$mn:00000FA3                 mov     large fs:0, ecx
.text$mn:00000FAA                 pop     ecx
.text$mn:00000FAB                 mov     esp, ebp
.text$mn:00000FAD                 pop     ebp
.text$mn:00000FAE                 retn    4
.text$mn:00000FAE ?destroyScintilla@ScintillaCtrls@@QAE_NPAUHWND__@@@Z endp
.text$mn:00000FAE
.text$mn:00000FAE ; ---------------------------------------------------------------------------
.text$mn:00000FB1                 align 10h
.text$mn:00000FC0
.text$mn:00000FC0 ; =============== S U B R O U T I N E =======================================
.text$mn:00000FC0
.text$mn:00000FC0 ; Attributes: bp-based frame
.text$mn:00000FC0
.text$mn:00000FC0 ; void __thiscall ScintillaCtrls::destroy(ScintillaCtrls *__hidden this)
.text$mn:00000FC0                 public ?destroy@ScintillaCtrls@@QAEXXZ
.text$mn:00000FC0 ?destroy@ScintillaCtrls@@QAEXXZ proc near
.text$mn:00000FC0
.text$mn:00000FC0 var_1C          = dword ptr -1Ch
.text$mn:00000FC0 var_18          = dword ptr -18h
.text$mn:00000FC0 var_14          = dword ptr -14h
.text$mn:00000FC0 var_10          = dword ptr -10h
.text$mn:00000FC0 var_C           = dword ptr -0Ch
.text$mn:00000FC0 var_8           = dword ptr -8
.text$mn:00000FC0 var_4           = dword ptr -4
.text$mn:00000FC0
.text$mn:00000FC0                 push    ebp
.text$mn:00000FC1                 mov     ebp, esp
.text$mn:00000FC3                 sub     esp, 1Ch
.text$mn:00000FC6                 mov     [ebp+var_8], ecx
.text$mn:00000FC9                 mov     [ebp+var_4], 0
.text$mn:00000FD0                 mov     ecx, [ebp+var_8]
.text$mn:00000FD3                 call    ?size@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@QBEIXZ ; std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::size(void)
.text$mn:00000FD8                 mov     [ebp+var_14], eax
.text$mn:00000FDB                 jmp     short loc_FE6
.text$mn:00000FDD ; ---------------------------------------------------------------------------
.text$mn:00000FDD
.text$mn:00000FDD loc_FDD:                                ; CODE XREF: ScintillaCtrls::destroy(void):loc_1043j
.text$mn:00000FDD                 mov     eax, [ebp+var_4]
.text$mn:00000FE0                 add     eax, 1
.text$mn:00000FE3                 mov     [ebp+var_4], eax
.text$mn:00000FE6
.text$mn:00000FE6 loc_FE6:                                ; CODE XREF: ScintillaCtrls::destroy(void)+1Bj
.text$mn:00000FE6                 mov     ecx, [ebp+var_4]
.text$mn:00000FE9                 cmp     ecx, [ebp+var_14]
.text$mn:00000FEC                 jnb     short loc_1045
.text$mn:00000FEE                 mov     edx, [ebp+var_4]
.text$mn:00000FF1                 push    edx
.text$mn:00000FF2                 mov     ecx, [ebp+var_8]
.text$mn:00000FF5                 call    ??A?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@QAEAAPAVScintillaEditView@@I@Z ; std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::operator[](uint)
.text$mn:00000FFA                 mov     eax, [eax]
.text$mn:00000FFC                 mov     [ebp+var_10], eax
.text$mn:00000FFF                 mov     ecx, [ebp+var_10]
.text$mn:00001002                 mov     edx, [ecx]
.text$mn:00001004                 mov     ecx, [ebp+var_10]
.text$mn:00001007                 mov     eax, [edx+8]
.text$mn:0000100A                 call    eax
.text$mn:0000100C                 mov     ecx, [ebp+var_4]
.text$mn:0000100F                 push    ecx
.text$mn:00001010                 mov     ecx, [ebp+var_8]
.text$mn:00001013                 call    ??A?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@QAEAAPAVScintillaEditView@@I@Z ; std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::operator[](uint)
.text$mn:00001018                 mov     edx, [eax]
.text$mn:0000101A                 mov     [ebp+var_18], edx
.text$mn:0000101D                 mov     eax, [ebp+var_18]
.text$mn:00001020                 mov     [ebp+var_C], eax
.text$mn:00001023                 cmp     [ebp+var_C], 0
.text$mn:00001027                 jz      short loc_103C
.text$mn:00001029                 push    1
.text$mn:0000102B                 mov     ecx, [ebp+var_C]
.text$mn:0000102E                 mov     edx, [ecx]
.text$mn:00001030                 mov     ecx, [ebp+var_C]
.text$mn:00001033                 mov     eax, [edx]
.text$mn:00001035                 call    eax
.text$mn:00001037                 mov     [ebp+var_1C], eax
.text$mn:0000103A                 jmp     short loc_1043
.text$mn:0000103C ; ---------------------------------------------------------------------------
.text$mn:0000103C
.text$mn:0000103C loc_103C:                               ; CODE XREF: ScintillaCtrls::destroy(void)+67j
.text$mn:0000103C                 mov     [ebp+var_1C], 0
.text$mn:00001043
.text$mn:00001043 loc_1043:                               ; CODE XREF: ScintillaCtrls::destroy(void)+7Aj
.text$mn:00001043                 jmp     short loc_FDD
.text$mn:00001045 ; ---------------------------------------------------------------------------
.text$mn:00001045
.text$mn:00001045 loc_1045:                               ; CODE XREF: ScintillaCtrls::destroy(void)+2Cj
.text$mn:00001045                 mov     esp, ebp
.text$mn:00001047                 pop     ebp
.text$mn:00001048                 retn
.text$mn:00001048 ?destroy@ScintillaCtrls@@QAEXXZ endp
.text$mn:00001048
.text$mn:00001048 ; ---------------------------------------------------------------------------
.text$mn:00001049                 align 10h
.text$mn:00001050
.text$mn:00001050 ; =============== S U B R O U T I N E =======================================
.text$mn:00001050
.text$mn:00001050 ; Attributes: bp-based frame
.text$mn:00001050
.text$mn:00001050 ; int __thiscall ScintillaCtrls::getIndexFrom(ScintillaCtrls *this, HWND)
.text$mn:00001050                 public ?getIndexFrom@ScintillaCtrls@@AAEHPAUHWND__@@@Z
.text$mn:00001050 ?getIndexFrom@ScintillaCtrls@@AAEHPAUHWND__@@@Z proc near
.text$mn:00001050                                         ; CODE XREF: ScintillaCtrls::getScintillaEditViewFrom(HWND__ *)+10p
.text$mn:00001050                                         ; ScintillaCtrls::destroyScintilla(HWND__ *)+2Fp
.text$mn:00001050
.text$mn:00001050 var_C           = dword ptr -0Ch
.text$mn:00001050 var_8           = dword ptr -8
.text$mn:00001050 var_4           = dword ptr -4
.text$mn:00001050 arg_0           = dword ptr  8
.text$mn:00001050
.text$mn:00001050                 push    ebp
.text$mn:00001051                 mov     ebp, esp
.text$mn:00001053                 sub     esp, 0Ch
.text$mn:00001056                 mov     [ebp+var_8], ecx
.text$mn:00001059                 mov     [ebp+var_4], 0
.text$mn:00001060                 mov     ecx, [ebp+var_8]
.text$mn:00001063                 call    ?size@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@QBEIXZ ; std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::size(void)
.text$mn:00001068                 mov     [ebp+var_C], eax
.text$mn:0000106B                 jmp     short loc_1076
.text$mn:0000106D ; ---------------------------------------------------------------------------
.text$mn:0000106D
.text$mn:0000106D loc_106D:                               ; CODE XREF: ScintillaCtrls::getIndexFrom(HWND__ *):loc_109Bj
.text$mn:0000106D                 mov     eax, [ebp+var_4]
.text$mn:00001070                 add     eax, 1
.text$mn:00001073                 mov     [ebp+var_4], eax
.text$mn:00001076
.text$mn:00001076 loc_1076:                               ; CODE XREF: ScintillaCtrls::getIndexFrom(HWND__ *)+1Bj
.text$mn:00001076                 mov     ecx, [ebp+var_4]
.text$mn:00001079                 cmp     ecx, [ebp+var_C]
.text$mn:0000107C                 jnb     short loc_109D
.text$mn:0000107E                 mov     edx, [ebp+var_4]
.text$mn:00001081                 push    edx
.text$mn:00001082                 mov     ecx, [ebp+var_8]
.text$mn:00001085                 call    ??A?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@QAEAAPAVScintillaEditView@@I@Z ; std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::operator[](uint)
.text$mn:0000108A                 mov     ecx, [eax]      ; this
.text$mn:0000108C                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:00001091                 cmp     eax, [ebp+arg_0]
.text$mn:00001094                 jnz     short loc_109B
.text$mn:00001096                 mov     eax, [ebp+var_4]
.text$mn:00001099                 jmp     short loc_10A0
.text$mn:0000109B ; ---------------------------------------------------------------------------
.text$mn:0000109B
.text$mn:0000109B loc_109B:                               ; CODE XREF: ScintillaCtrls::getIndexFrom(HWND__ *)+44j
.text$mn:0000109B                 jmp     short loc_106D
.text$mn:0000109D ; ---------------------------------------------------------------------------
.text$mn:0000109D
.text$mn:0000109D loc_109D:                               ; CODE XREF: ScintillaCtrls::getIndexFrom(HWND__ *)+2Cj
.text$mn:0000109D                 or      eax, 0FFFFFFFFh
.text$mn:000010A0
.text$mn:000010A0 loc_10A0:                               ; CODE XREF: ScintillaCtrls::getIndexFrom(HWND__ *)+49j
.text$mn:000010A0                 mov     esp, ebp
.text$mn:000010A2                 pop     ebp
.text$mn:000010A3                 retn    4
.text$mn:000010A3 ?getIndexFrom@ScintillaCtrls@@AAEHPAUHWND__@@@Z endp
.text$mn:000010A3
.text$mn:000010A3 ; ---------------------------------------------------------------------------
.text$mn:000010A6                 align 4
.text$mn:000010A6 _text$mn        ends
.text$mn:000010A6
.text$x:000010A8 ; ===========================================================================
.text$x:000010A8
.text$x:000010A8 ; Segment type: Pure code
.text$x:000010A8 ; Segment permissions: Read/Execute
.text$x:000010A8 _text$x         segment para public 'CODE' use32
.text$x:000010A8                 assume cs:_text$x
.text$x:000010A8                 ;org 10A8h
.text$x:000010A8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000010A8
.text$x:000010A8 ; =============== S U B R O U T I N E =======================================
.text$x:000010A8
.text$x:000010A8
.text$x:000010A8 __unwindfunclet$?createSintilla@ScintillaCtrls@@QAEPAUHWND__@@PAU2@@Z$0 proc near
.text$x:000010A8                                         ; DATA XREF: .xdata$x:00009970o
.text$x:000010A8                 mov     eax, [ebp-18h]
.text$x:000010AB                 push    eax             ; void *
.text$x:000010AC                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:000010B1                 pop     ecx
.text$x:000010B2                 retn
.text$x:000010B2 __unwindfunclet$?createSintilla@ScintillaCtrls@@QAEPAUHWND__@@PAU2@@Z$0 endp
.text$x:000010B2
.text$x:000010B3
.text$x:000010B3 ; =============== S U B R O U T I N E =======================================
.text$x:000010B3
.text$x:000010B3
.text$x:000010B3 __ehhandler$?createSintilla@ScintillaCtrls@@QAEPAUHWND__@@PAU2@@Z proc near
.text$x:000010B3                                         ; DATA XREF: ScintillaCtrls::createSintilla(HWND__ *)+5o
.text$x:000010B3
.text$x:000010B3 arg_4           = dword ptr  8
.text$x:000010B3
.text$x:000010B3                 mov     edx, [esp+arg_4]
.text$x:000010B7                 lea     eax, [edx+0Ch]
.text$x:000010BA                 mov     ecx, [edx-18h]
.text$x:000010BD                 xor     ecx, eax
.text$x:000010BF                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000010C4                 mov     eax, offset __ehfuncinfo$?createSintilla@ScintillaCtrls@@QAEPAUHWND__@@PAU2@@Z
.text$x:000010C9                 jmp     ___CxxFrameHandler3
.text$x:000010C9 __ehhandler$?createSintilla@ScintillaCtrls@@QAEPAUHWND__@@PAU2@@Z endp
.text$x:000010C9
.text$x:000010CE
.text$x:000010CE ; =============== S U B R O U T I N E =======================================
.text$x:000010CE
.text$x:000010CE
.text$x:000010CE __unwindfunclet$?destroyScintilla@ScintillaCtrls@@QAE_NPAUHWND__@@@Z$0 proc near
.text$x:000010CE                                         ; DATA XREF: .xdata$x:00009978o
.text$x:000010CE                 lea     ecx, [ebp-58h]
.text$x:000010D1                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>(void)
.text$x:000010D1 __unwindfunclet$?destroyScintilla@ScintillaCtrls@@QAE_NPAUHWND__@@@Z$0 endp
.text$x:000010D1
.text$x:000010D6
.text$x:000010D6 ; =============== S U B R O U T I N E =======================================
.text$x:000010D6
.text$x:000010D6
.text$x:000010D6 __unwindfunclet$?destroyScintilla@ScintillaCtrls@@QAE_NPAUHWND__@@@Z$1 proc near
.text$x:000010D6                                         ; DATA XREF: .xdata$x:00009980o
.text$x:000010D6                                         ; .xdata$x:00009988o
.text$x:000010D6                 lea     ecx, [ebp-4Ch]
.text$x:000010D9                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>(void)
.text$x:000010D9 __unwindfunclet$?destroyScintilla@ScintillaCtrls@@QAE_NPAUHWND__@@@Z$1 endp
.text$x:000010D9
.text$x:000010DE
.text$x:000010DE ; =============== S U B R O U T I N E =======================================
.text$x:000010DE
.text$x:000010DE
.text$x:000010DE __unwindfunclet$?destroyScintilla@ScintillaCtrls@@QAE_NPAUHWND__@@@Z$2 proc near
.text$x:000010DE                                         ; DATA XREF: .xdata$x:00009990o
.text$x:000010DE                 mov     ecx, [ebp-38h]
.text$x:000010E1                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>(void)
.text$x:000010E1 __unwindfunclet$?destroyScintilla@ScintillaCtrls@@QAE_NPAUHWND__@@@Z$2 endp
.text$x:000010E1
.text$x:000010E6
.text$x:000010E6 ; =============== S U B R O U T I N E =======================================
.text$x:000010E6
.text$x:000010E6
.text$x:000010E6 __ehhandler$?destroyScintilla@ScintillaCtrls@@QAE_NPAUHWND__@@@Z proc near
.text$x:000010E6                                         ; DATA XREF: ScintillaCtrls::destroyScintilla(HWND__ *)+5o
.text$x:000010E6
.text$x:000010E6 arg_4           = dword ptr  8
.text$x:000010E6
.text$x:000010E6                 mov     edx, [esp+arg_4]
.text$x:000010EA                 lea     eax, [edx+0Ch]
.text$x:000010ED                 mov     ecx, [edx-5Ch]
.text$x:000010F0                 xor     ecx, eax
.text$x:000010F2                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000010F7                 mov     eax, offset __ehfuncinfo$?destroyScintilla@ScintillaCtrls@@QAE_NPAUHWND__@@@Z
.text$x:000010FC                 jmp     ___CxxFrameHandler3
.text$x:000010FC __ehhandler$?destroyScintilla@ScintillaCtrls@@QAE_NPAUHWND__@@@Z endp
.text$x:000010FC
.text$x:000010FC ; ---------------------------------------------------------------------------
.text$x:00001101                 align 4
.text$x:00001101 _text$x         ends
.text$x:00001101
.text$mn:00001104 ; ===========================================================================
.text$mn:00001104
.text$mn:00001104 ; Segment type: Pure code
.text$mn:00001104 ; Segment permissions: Read/Execute
.text$mn:00001104 _text$mn        segment para public 'CODE' use32
.text$mn:00001104                 assume cs:_text$mn
.text$mn:00001104                 ;org 1104h
.text$mn:00001104 ; COMDAT (pick any)
.text$mn:00001104                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001104
.text$mn:00001104 ; =============== S U B R O U T I N E =======================================
.text$mn:00001104
.text$mn:00001104 ; Attributes: bp-based frame
.text$mn:00001104
.text$mn:00001104 ; public: __thiscall std::allocator<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>>::allocator<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>>(class std::allocator<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>> const &)
.text$mn:00001104                 public ??$?0U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@1@@Z
.text$mn:00001104 ??$?0U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@1@@Z proc near
.text$mn:00001104                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>(std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>> const &)+Ep
.text$mn:00001104
.text$mn:00001104 var_4           = dword ptr -4
.text$mn:00001104
.text$mn:00001104                 push    ebp
.text$mn:00001105                 mov     ebp, esp
.text$mn:00001107                 push    ecx
.text$mn:00001108                 mov     [ebp+var_4], ecx
.text$mn:0000110B                 mov     eax, [ebp+var_4]
.text$mn:0000110E                 mov     esp, ebp
.text$mn:00001110                 pop     ebp
.text$mn:00001111                 retn    4
.text$mn:00001111 ??$?0U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@1@@Z endp
.text$mn:00001111
.text$mn:00001111 _text$mn        ends
.text$mn:00001111
.text$mn:00001114 ; ===========================================================================
.text$mn:00001114
.text$mn:00001114 ; Segment type: Pure code
.text$mn:00001114 ; Segment permissions: Read/Execute
.text$mn:00001114 _text$mn        segment para public 'CODE' use32
.text$mn:00001114                 assume cs:_text$mn
.text$mn:00001114                 ;org 1114h
.text$mn:00001114 ; COMDAT (pick any)
.text$mn:00001114                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001114
.text$mn:00001114 ; =============== S U B R O U T I N E =======================================
.text$mn:00001114
.text$mn:00001114 ; Attributes: bp-based frame
.text$mn:00001114
.text$mn:00001114 ; public: __thiscall std::_Wrap_alloc<class std::allocator<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>>>::_Wrap_alloc<class std::allocator<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>>>(class std::allocator<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>> const &)
.text$mn:00001114                 public ??$?0V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@1@@Z
.text$mn:00001114 ??$?0V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@1@@Z proc near
.text$mn:00001114                                         ; CODE XREF: std::_Hash<std::_Umap_traits<Buffer *,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *,std::_Uhash_compare<Buffer *,std::hash<Buffer *>,std::equal_to<Buffer *>>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>,0>>::_Hash<std::_Umap_traits<Buffer *,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *,std::_Uhash_compare<Buffer *,std::hash<Buffer *>,std::equal_to<Buffer *>>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>,0>>(std::_Uhash_compare<Buffer *,std::hash<Buffer *>,std::equal_to<Buffer *>> const &,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>> const &)+4Ep
.text$mn:00001114
.text$mn:00001114 var_4           = dword ptr -4
.text$mn:00001114 arg_0           = dword ptr  8
.text$mn:00001114
.text$mn:00001114                 push    ebp
.text$mn:00001115                 mov     ebp, esp
.text$mn:00001117                 push    ecx
.text$mn:00001118                 mov     [ebp+var_4], ecx
.text$mn:0000111B                 mov     eax, [ebp+arg_0]
.text$mn:0000111E                 push    eax
.text$mn:0000111F                 mov     ecx, [ebp+var_4]
.text$mn:00001122                 call    ??$?0U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@1@@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>(std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>> const &)
.text$mn:00001127                 mov     eax, [ebp+var_4]
.text$mn:0000112A                 mov     esp, ebp
.text$mn:0000112C                 pop     ebp
.text$mn:0000112D                 retn    4
.text$mn:0000112D ??$?0V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@1@@Z endp
.text$mn:0000112D
.text$mn:0000112D _text$mn        ends
.text$mn:0000112D
.text$mn:00001130 ; ===========================================================================
.text$mn:00001130
.text$mn:00001130 ; Segment type: Pure code
.text$mn:00001130 ; Segment permissions: Read/Execute
.text$mn:00001130 _text$mn        segment para public 'CODE' use32
.text$mn:00001130                 assume cs:_text$mn
.text$mn:00001130                 ;org 1130h
.text$mn:00001130 ; COMDAT (pick any)
.text$mn:00001130                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001130
.text$mn:00001130 ; =============== S U B R O U T I N E =======================================
.text$mn:00001130
.text$mn:00001130 ; Attributes: bp-based frame
.text$mn:00001130
.text$mn:00001130 ; char * __cdecl std::_Allocate<char>(unsigned int, char *)
.text$mn:00001130                 public ??$_Allocate@D@std@@YAPADIPAD@Z
.text$mn:00001130 ??$_Allocate@D@std@@YAPADIPAD@Z proc near
.text$mn:00001130                                         ; CODE XREF: std::allocator<char>::allocate(uint)+Dp
.text$mn:00001130
.text$mn:00001130 var_4           = dword ptr -4
.text$mn:00001130 arg_0           = dword ptr  8
.text$mn:00001130
.text$mn:00001130                 push    ebp
.text$mn:00001131                 mov     ebp, esp
.text$mn:00001133                 push    ecx
.text$mn:00001134                 mov     [ebp+var_4], 0
.text$mn:0000113B                 cmp     [ebp+arg_0], 0
.text$mn:0000113F                 jnz     short loc_1143
.text$mn:00001141                 jmp     short loc_1163
.text$mn:00001143 ; ---------------------------------------------------------------------------
.text$mn:00001143
.text$mn:00001143 loc_1143:                               ; CODE XREF: std::_Allocate<char>(uint,char *)+Fj
.text$mn:00001143                 cmp     [ebp+arg_0], 0FFFFFFFFh
.text$mn:00001147                 ja      short loc_115E
.text$mn:00001149                 mov     eax, [ebp+arg_0]
.text$mn:0000114C                 push    eax             ; unsigned int
.text$mn:0000114D                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00001152                 add     esp, 4
.text$mn:00001155                 mov     [ebp+var_4], eax
.text$mn:00001158                 cmp     [ebp+var_4], 0
.text$mn:0000115C                 jnz     short loc_1163
.text$mn:0000115E
.text$mn:0000115E loc_115E:                               ; CODE XREF: std::_Allocate<char>(uint,char *)+17j
.text$mn:0000115E                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:00001163
.text$mn:00001163 loc_1163:                               ; CODE XREF: std::_Allocate<char>(uint,char *)+11j
.text$mn:00001163                                         ; std::_Allocate<char>(uint,char *)+2Cj
.text$mn:00001163                 mov     eax, [ebp+var_4]
.text$mn:00001166                 mov     esp, ebp
.text$mn:00001168                 pop     ebp
.text$mn:00001169                 retn
.text$mn:00001169 ??$_Allocate@D@std@@YAPADIPAD@Z endp
.text$mn:00001169
.text$mn:00001169 ; ---------------------------------------------------------------------------
.text$mn:0000116A                 align 4
.text$mn:0000116A _text$mn        ends
.text$mn:0000116A
.text$mn:0000116C ; ===========================================================================
.text$mn:0000116C
.text$mn:0000116C ; Segment type: Pure code
.text$mn:0000116C ; Segment permissions: Read/Execute
.text$mn:0000116C _text$mn        segment para public 'CODE' use32
.text$mn:0000116C                 assume cs:_text$mn
.text$mn:0000116C                 ;org 116Ch
.text$mn:0000116C ; COMDAT (pick any)
.text$mn:0000116C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000116C
.text$mn:0000116C ; =============== S U B R O U T I N E =======================================
.text$mn:0000116C
.text$mn:0000116C ; Attributes: bp-based frame
.text$mn:0000116C
.text$mn:0000116C ; class ScintillaEditView * * __cdecl std::_Allocate<class ScintillaEditView *>(unsigned int, class ScintillaEditView * *)
.text$mn:0000116C                 public ??$_Allocate@PAVScintillaEditView@@@std@@YAPAPAVScintillaEditView@@IPAPAV1@@Z
.text$mn:0000116C ??$_Allocate@PAVScintillaEditView@@@std@@YAPAPAVScintillaEditView@@IPAPAV1@@Z proc near
.text$mn:0000116C                                         ; CODE XREF: std::allocator<ScintillaEditView *>::allocate(uint)+Dp
.text$mn:0000116C
.text$mn:0000116C var_4           = dword ptr -4
.text$mn:0000116C arg_0           = dword ptr  8
.text$mn:0000116C
.text$mn:0000116C                 push    ebp
.text$mn:0000116D                 mov     ebp, esp
.text$mn:0000116F                 push    ecx
.text$mn:00001170                 mov     [ebp+var_4], 0
.text$mn:00001177                 cmp     [ebp+arg_0], 0
.text$mn:0000117B                 jnz     short loc_117F
.text$mn:0000117D                 jmp     short loc_11A5
.text$mn:0000117F ; ---------------------------------------------------------------------------
.text$mn:0000117F
.text$mn:0000117F loc_117F:                               ; CODE XREF: std::_Allocate<ScintillaEditView *>(uint,ScintillaEditView * *)+Fj
.text$mn:0000117F                 cmp     [ebp+arg_0], 3FFFFFFFh
.text$mn:00001186                 ja      short loc_11A0
.text$mn:00001188                 mov     eax, [ebp+arg_0]
.text$mn:0000118B                 shl     eax, 2
.text$mn:0000118E                 push    eax             ; unsigned int
.text$mn:0000118F                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00001194                 add     esp, 4
.text$mn:00001197                 mov     [ebp+var_4], eax
.text$mn:0000119A                 cmp     [ebp+var_4], 0
.text$mn:0000119E                 jnz     short loc_11A5
.text$mn:000011A0
.text$mn:000011A0 loc_11A0:                               ; CODE XREF: std::_Allocate<ScintillaEditView *>(uint,ScintillaEditView * *)+1Aj
.text$mn:000011A0                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:000011A5
.text$mn:000011A5 loc_11A5:                               ; CODE XREF: std::_Allocate<ScintillaEditView *>(uint,ScintillaEditView * *)+11j
.text$mn:000011A5                                         ; std::_Allocate<ScintillaEditView *>(uint,ScintillaEditView * *)+32j
.text$mn:000011A5                 mov     eax, [ebp+var_4]
.text$mn:000011A8                 mov     esp, ebp
.text$mn:000011AA                 pop     ebp
.text$mn:000011AB                 retn
.text$mn:000011AB ??$_Allocate@PAVScintillaEditView@@@std@@YAPAPAVScintillaEditView@@IPAPAV1@@Z endp
.text$mn:000011AB
.text$mn:000011AB _text$mn        ends
.text$mn:000011AB
.text$mn:000011AC ; ===========================================================================
.text$mn:000011AC
.text$mn:000011AC ; Segment type: Pure code
.text$mn:000011AC ; Segment permissions: Read/Execute
.text$mn:000011AC _text$mn        segment para public 'CODE' use32
.text$mn:000011AC                 assume cs:_text$mn
.text$mn:000011AC                 ;org 11ACh
.text$mn:000011AC ; COMDAT (pick any)
.text$mn:000011AC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000011AC
.text$mn:000011AC ; =============== S U B R O U T I N E =======================================
.text$mn:000011AC
.text$mn:000011AC ; Attributes: bp-based frame
.text$mn:000011AC
.text$mn:000011AC ; struct std::_List_node<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>, void *> * __cdecl std::_Allocate<struct std::_List_node<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>, void *>>(unsigned int, struct std::_List_node<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>, void *> *)
.text$mn:000011AC                 public ??$_Allocate@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@YAPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@0@IPAU10@@Z
.text$mn:000011AC ??$_Allocate@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@YAPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@0@IPAU10@@Z proc near
.text$mn:000011AC                                         ; CODE XREF: std::allocator<std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *>>::allocate(uint)+Dp
.text$mn:000011AC
.text$mn:000011AC var_4           = dword ptr -4
.text$mn:000011AC arg_0           = dword ptr  8
.text$mn:000011AC
.text$mn:000011AC                 push    ebp
.text$mn:000011AD                 mov     ebp, esp
.text$mn:000011AF                 push    ecx
.text$mn:000011B0                 mov     [ebp+var_4], 0
.text$mn:000011B7                 cmp     [ebp+arg_0], 0
.text$mn:000011BB                 jnz     short loc_11BF
.text$mn:000011BD                 jmp     short loc_11E5
.text$mn:000011BF ; ---------------------------------------------------------------------------
.text$mn:000011BF
.text$mn:000011BF loc_11BF:                               ; CODE XREF: std::_Allocate<std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *>>(uint,std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *)+Fj
.text$mn:000011BF                 cmp     [ebp+arg_0], 0FFFFFFFh
.text$mn:000011C6                 ja      short loc_11E0
.text$mn:000011C8                 mov     eax, [ebp+arg_0]
.text$mn:000011CB                 shl     eax, 4
.text$mn:000011CE                 push    eax             ; unsigned int
.text$mn:000011CF                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:000011D4                 add     esp, 4
.text$mn:000011D7                 mov     [ebp+var_4], eax
.text$mn:000011DA                 cmp     [ebp+var_4], 0
.text$mn:000011DE                 jnz     short loc_11E5
.text$mn:000011E0
.text$mn:000011E0 loc_11E0:                               ; CODE XREF: std::_Allocate<std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *>>(uint,std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *)+1Aj
.text$mn:000011E0                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:000011E5
.text$mn:000011E5 loc_11E5:                               ; CODE XREF: std::_Allocate<std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *>>(uint,std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *)+11j
.text$mn:000011E5                                         ; std::_Allocate<std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *>>(uint,std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *)+32j
.text$mn:000011E5                 mov     eax, [ebp+var_4]
.text$mn:000011E8                 mov     esp, ebp
.text$mn:000011EA                 pop     ebp
.text$mn:000011EB                 retn
.text$mn:000011EB ??$_Allocate@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@YAPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@0@IPAU10@@Z endp
.text$mn:000011EB
.text$mn:000011EB _text$mn        ends
.text$mn:000011EB
.text$mn:000011EC ; ===========================================================================
.text$mn:000011EC
.text$mn:000011EC ; Segment type: Pure code
.text$mn:000011EC ; Segment permissions: Read/Execute
.text$mn:000011EC _text$mn        segment para public 'CODE' use32
.text$mn:000011EC                 assume cs:_text$mn
.text$mn:000011EC                 ;org 11ECh
.text$mn:000011EC ; COMDAT (pick any)
.text$mn:000011EC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000011EC
.text$mn:000011EC ; =============== S U B R O U T I N E =======================================
.text$mn:000011EC
.text$mn:000011EC ; Attributes: bp-based frame
.text$mn:000011EC
.text$mn:000011EC ; struct std::_Container_proxy * __cdecl std::_Allocate<struct std::_Container_proxy>(unsigned int, struct std::_Container_proxy *)
.text$mn:000011EC                 public ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z
.text$mn:000011EC ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z proc near
.text$mn:000011EC                                         ; CODE XREF: std::allocator<std::_Container_proxy>::allocate(uint)+Dp
.text$mn:000011EC
.text$mn:000011EC var_4           = dword ptr -4
.text$mn:000011EC arg_0           = dword ptr  8
.text$mn:000011EC
.text$mn:000011EC                 push    ebp
.text$mn:000011ED                 mov     ebp, esp
.text$mn:000011EF                 push    ecx
.text$mn:000011F0                 mov     [ebp+var_4], 0
.text$mn:000011F7                 cmp     [ebp+arg_0], 0
.text$mn:000011FB                 jnz     short loc_11FF
.text$mn:000011FD                 jmp     short loc_1225
.text$mn:000011FF ; ---------------------------------------------------------------------------
.text$mn:000011FF
.text$mn:000011FF loc_11FF:                               ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+Fj
.text$mn:000011FF                 cmp     [ebp+arg_0], 1FFFFFFFh
.text$mn:00001206                 ja      short loc_1220
.text$mn:00001208                 mov     eax, [ebp+arg_0]
.text$mn:0000120B                 shl     eax, 3
.text$mn:0000120E                 push    eax             ; unsigned int
.text$mn:0000120F                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00001214                 add     esp, 4
.text$mn:00001217                 mov     [ebp+var_4], eax
.text$mn:0000121A                 cmp     [ebp+var_4], 0
.text$mn:0000121E                 jnz     short loc_1225
.text$mn:00001220
.text$mn:00001220 loc_1220:                               ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+1Aj
.text$mn:00001220                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:00001225
.text$mn:00001225 loc_1225:                               ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+11j
.text$mn:00001225                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+32j
.text$mn:00001225                 mov     eax, [ebp+var_4]
.text$mn:00001228                 mov     esp, ebp
.text$mn:0000122A                 pop     ebp
.text$mn:0000122B                 retn
.text$mn:0000122B ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z endp
.text$mn:0000122B
.text$mn:0000122B _text$mn        ends
.text$mn:0000122B
.text$mn:0000122C ; ===========================================================================
.text$mn:0000122C
.text$mn:0000122C ; Segment type: Pure code
.text$mn:0000122C ; Segment permissions: Read/Execute
.text$mn:0000122C _text$mn        segment para public 'CODE' use32
.text$mn:0000122C                 assume cs:_text$mn
.text$mn:0000122C                 ;org 122Ch
.text$mn:0000122C ; COMDAT (pick any)
.text$mn:0000122C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000122C
.text$mn:0000122C ; =============== S U B R O U T I N E =======================================
.text$mn:0000122C
.text$mn:0000122C ; Attributes: bp-based frame
.text$mn:0000122C
.text$mn:0000122C ; class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>> * __cdecl std::_Allocate<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>>(unsigned int, class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>> *)
.text$mn:0000122C                 public ??$_Allocate@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@IPAV10@@Z
.text$mn:0000122C ??$_Allocate@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@IPAV10@@Z proc near
.text$mn:0000122C                                         ; CODE XREF: std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>::allocate(uint)+Dp
.text$mn:0000122C
.text$mn:0000122C var_4           = dword ptr -4
.text$mn:0000122C arg_0           = dword ptr  8
.text$mn:0000122C
.text$mn:0000122C                 push    ebp
.text$mn:0000122D                 mov     ebp, esp
.text$mn:0000122F                 push    ecx
.text$mn:00001230                 mov     [ebp+var_4], 0
.text$mn:00001237                 cmp     [ebp+arg_0], 0
.text$mn:0000123B                 jnz     short loc_123F
.text$mn:0000123D                 jmp     short loc_1265
.text$mn:0000123F ; ---------------------------------------------------------------------------
.text$mn:0000123F
.text$mn:0000123F loc_123F:                               ; CODE XREF: std::_Allocate<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>(uint,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *)+Fj
.text$mn:0000123F                 cmp     [ebp+arg_0], 3FFFFFFFh
.text$mn:00001246                 ja      short loc_1260
.text$mn:00001248                 mov     eax, [ebp+arg_0]
.text$mn:0000124B                 shl     eax, 2
.text$mn:0000124E                 push    eax             ; unsigned int
.text$mn:0000124F                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00001254                 add     esp, 4
.text$mn:00001257                 mov     [ebp+var_4], eax
.text$mn:0000125A                 cmp     [ebp+var_4], 0
.text$mn:0000125E                 jnz     short loc_1265
.text$mn:00001260
.text$mn:00001260 loc_1260:                               ; CODE XREF: std::_Allocate<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>(uint,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *)+1Aj
.text$mn:00001260                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:00001265
.text$mn:00001265 loc_1265:                               ; CODE XREF: std::_Allocate<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>(uint,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *)+11j
.text$mn:00001265                                         ; std::_Allocate<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>(uint,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *)+32j
.text$mn:00001265                 mov     eax, [ebp+var_4]
.text$mn:00001268                 mov     esp, ebp
.text$mn:0000126A                 pop     ebp
.text$mn:0000126B                 retn
.text$mn:0000126B ??$_Allocate@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@IPAV10@@Z endp
.text$mn:0000126B
.text$mn:0000126B _text$mn        ends
.text$mn:0000126B
.text$mn:0000126C ; ===========================================================================
.text$mn:0000126C
.text$mn:0000126C ; Segment type: Pure code
.text$mn:0000126C ; Segment permissions: Read/Execute
.text$mn:0000126C _text$mn        segment para public 'CODE' use32
.text$mn:0000126C                 assume cs:_text$mn
.text$mn:0000126C                 ;org 126Ch
.text$mn:0000126C ; COMDAT (pick any)
.text$mn:0000126C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000126C
.text$mn:0000126C ; =============== S U B R O U T I N E =======================================
.text$mn:0000126C
.text$mn:0000126C ; Attributes: bp-based frame
.text$mn:0000126C
.text$mn:0000126C ; class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>> * __cdecl std::_Copy_backward<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>> *, class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>> *>(class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<cl
.text$mn:0000126C                 public ??$_Copy_backward@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@PAV12@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@PAV10@00@Z
.text$mn:0000126C ??$_Copy_backward@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@PAV12@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@PAV10@00@Z proc near
.text$mn:0000126C                                         ; CODE XREF: ?_Insert_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CB
.text$mn:0000126C
.text$mn:0000126C var_1           = byte ptr -1
.text$mn:0000126C arg_0           = dword ptr  8
.text$mn:0000126C arg_4           = dword ptr  0Ch
.text$mn:0000126C arg_8           = dword ptr  10h
.text$mn:0000126C
.text$mn:0000126C                 push    ebp
.text$mn:0000126D                 mov     ebp, esp
.text$mn:0000126F                 push    ecx
.text$mn:00001270                 mov     eax, [ebp+arg_8]
.text$mn:00001273                 push    eax
.text$mn:00001274                 mov     ecx, [ebp+arg_0]
.text$mn:00001277                 push    ecx
.text$mn:00001278                 call    ??$_Ptr_cat@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@0@Z ; std::_Ptr_cat<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *)
.text$mn:0000127D                 add     esp, 8
.text$mn:00001280                 mov     [ebp+var_1], al
.text$mn:00001283                 movzx   edx, [ebp+var_1]
.text$mn:00001287                 push    edx
.text$mn:00001288                 mov     eax, [ebp+arg_8]
.text$mn:0000128B                 push    eax
.text$mn:0000128C                 mov     ecx, [ebp+arg_4]
.text$mn:0000128F                 push    ecx
.text$mn:00001290                 mov     edx, [ebp+arg_0]
.text$mn:00001293                 push    edx
.text$mn:00001294                 call    ??$_Copy_backward@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@PAV12@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@PAV10@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Copy_backward<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_Nonscalar_ptr_iterator_tag)
.text$mn:00001299                 add     esp, 10h
.text$mn:0000129C                 mov     esp, ebp
.text$mn:0000129E                 pop     ebp
.text$mn:0000129F                 retn
.text$mn:0000129F ??$_Copy_backward@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@PAV12@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@PAV10@00@Z endp
.text$mn:0000129F
.text$mn:0000129F _text$mn        ends
.text$mn:0000129F
.text$mn:000012A0 ; ===========================================================================
.text$mn:000012A0
.text$mn:000012A0 ; Segment type: Pure code
.text$mn:000012A0 ; Segment permissions: Read/Execute
.text$mn:000012A0 _text$mn        segment para public 'CODE' use32
.text$mn:000012A0                 assume cs:_text$mn
.text$mn:000012A0                 ;org 12A0h
.text$mn:000012A0 ; COMDAT (pick any)
.text$mn:000012A0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000012A0
.text$mn:000012A0 ; =============== S U B R O U T I N E =======================================
.text$mn:000012A0
.text$mn:000012A0 ; Attributes: bp-based frame
.text$mn:000012A0
.text$mn:000012A0 ; class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>> * __cdecl std::_Copy_backward<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>> *, class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>> *>(class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<cl
.text$mn:000012A0                 public ??$_Copy_backward@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@PAV12@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@PAV10@00U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:000012A0 ??$_Copy_backward@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@PAV12@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@PAV10@00U_Nonscalar_ptr_iterator_tag@0@@Z proc near
.text$mn:000012A0                                         ; CODE XREF: std::_Copy_backward<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::e
.text$mn:000012A0
.text$mn:000012A0 arg_0           = dword ptr  8
.text$mn:000012A0 arg_4           = dword ptr  0Ch
.text$mn:000012A0 arg_8           = dword ptr  10h
.text$mn:000012A0
.text$mn:000012A0                 push    ebp
.text$mn:000012A1                 mov     ebp, esp
.text$mn:000012A3
.text$mn:000012A3 loc_12A3:                               ; CODE XREF: std::_Copy_backward<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::e
.text$mn:000012A3                 mov     eax, [ebp+arg_0]
.text$mn:000012A6                 cmp     eax, [ebp+arg_4]
.text$mn:000012A9                 jz      short loc_12C9
.text$mn:000012AB                 mov     ecx, [ebp+arg_4]
.text$mn:000012AE                 sub     ecx, 4
.text$mn:000012B1                 mov     [ebp+arg_4], ecx
.text$mn:000012B4                 mov     edx, [ebp+arg_8]
.text$mn:000012B7                 sub     edx, 4
.text$mn:000012BA                 mov     [ebp+arg_8], edx
.text$mn:000012BD                 mov     eax, [ebp+arg_4]
.text$mn:000012C0                 mov     ecx, [eax]
.text$mn:000012C2                 mov     edx, [ebp+arg_8]
.text$mn:000012C5                 mov     [edx], ecx
.text$mn:000012C7                 jmp     short loc_12A3
.text$mn:000012C9 ; ---------------------------------------------------------------------------
.text$mn:000012C9
.text$mn:000012C9 loc_12C9:                               ; CODE XREF: std::_Copy_backward<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::e
.text$mn:000012C9                 mov     eax, [ebp+arg_8]
.text$mn:000012CC                 pop     ebp
.text$mn:000012CD                 retn
.text$mn:000012CD ??$_Copy_backward@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@PAV12@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@PAV10@00U_Nonscalar_ptr_iterator_tag@0@@Z endp
.text$mn:000012CD
.text$mn:000012CD ; ---------------------------------------------------------------------------
.text$mn:000012CE                 align 10h
.text$mn:000012CE _text$mn        ends
.text$mn:000012CE
.text$mn:000012D0 ; ===========================================================================
.text$mn:000012D0
.text$mn:000012D0 ; Segment type: Pure code
.text$mn:000012D0 ; Segment permissions: Read/Execute
.text$mn:000012D0 _text$mn        segment para public 'CODE' use32
.text$mn:000012D0                 assume cs:_text$mn
.text$mn:000012D0                 ;org 12D0h
.text$mn:000012D0 ; COMDAT (pick any)
.text$mn:000012D0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000012D0
.text$mn:000012D0 ; =============== S U B R O U T I N E =======================================
.text$mn:000012D0
.text$mn:000012D0 ; Attributes: bp-based frame
.text$mn:000012D0
.text$mn:000012D0 ; int __cdecl std::_Debug_pointer<char>(int, wchar_t *, unsigned int)
.text$mn:000012D0                 public ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z
.text$mn:000012D0 ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z proc near
.text$mn:000012D0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+15p
.text$mn:000012D0                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+1Bp
.text$mn:000012D0
.text$mn:000012D0 arg_0           = dword ptr  8
.text$mn:000012D0 arg_4           = dword ptr  0Ch
.text$mn:000012D0 arg_8           = dword ptr  10h
.text$mn:000012D0
.text$mn:000012D0                 push    ebp
.text$mn:000012D1                 mov     ebp, esp
.text$mn:000012D3                 cmp     [ebp+arg_0], 0
.text$mn:000012D7                 jnz     short loc_12EE
.text$mn:000012D9                 mov     eax, [ebp+arg_8]
.text$mn:000012DC                 push    eax             ; unsigned int
.text$mn:000012DD                 mov     ecx, [ebp+arg_4]
.text$mn:000012E0                 push    ecx             ; wchar_t *
.text$mn:000012E1                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:000012E6                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:000012EB                 add     esp, 0Ch
.text$mn:000012EE
.text$mn:000012EE loc_12EE:                               ; CODE XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+7j
.text$mn:000012EE                 pop     ebp
.text$mn:000012EF                 retn
.text$mn:000012EF ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z endp
.text$mn:000012EF
.text$mn:000012EF _text$mn        ends
.text$mn:000012EF
.text$mn:000012F0 ; ===========================================================================
.text$mn:000012F0
.text$mn:000012F0 ; Segment type: Pure code
.text$mn:000012F0 ; Segment permissions: Read/Execute
.text$mn:000012F0 _text$mn        segment para public 'CODE' use32
.text$mn:000012F0                 assume cs:_text$mn
.text$mn:000012F0                 ;org 12F0h
.text$mn:000012F0 ; COMDAT (pick any)
.text$mn:000012F0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000012F0
.text$mn:000012F0 ; =============== S U B R O U T I N E =======================================
.text$mn:000012F0
.text$mn:000012F0 ; Attributes: bp-based frame
.text$mn:000012F0
.text$mn:000012F0 ; int __cdecl std::_Debug_pointer<ScintillaEditView *>(int, wchar_t *, unsigned int)
.text$mn:000012F0                 public ??$_Debug_pointer@PAVScintillaEditView@@@std@@YAXPAPAVScintillaEditView@@PB_WI@Z
.text$mn:000012F0 ??$_Debug_pointer@PAVScintillaEditView@@@std@@YAXPAPAVScintillaEditView@@PB_WI@Z proc near
.text$mn:000012F0                                         ; CODE XREF: std::_Debug_range2<ScintillaEditView * *>(ScintillaEditView * *,ScintillaEditView * *,wchar_t const *,uint,std::random_access_iterator_tag)+17p
.text$mn:000012F0                                         ; std::_Debug_range2<ScintillaEditView * *>(ScintillaEditView * *,ScintillaEditView * *,wchar_t const *,uint,std::random_access_iterator_tag)+2Bp ...
.text$mn:000012F0
.text$mn:000012F0 arg_0           = dword ptr  8
.text$mn:000012F0 arg_4           = dword ptr  0Ch
.text$mn:000012F0 arg_8           = dword ptr  10h
.text$mn:000012F0
.text$mn:000012F0                 push    ebp
.text$mn:000012F1                 mov     ebp, esp
.text$mn:000012F3                 cmp     [ebp+arg_0], 0
.text$mn:000012F7                 jnz     short loc_130E
.text$mn:000012F9                 mov     eax, [ebp+arg_8]
.text$mn:000012FC                 push    eax             ; unsigned int
.text$mn:000012FD                 mov     ecx, [ebp+arg_4]
.text$mn:00001300                 push    ecx             ; wchar_t *
.text$mn:00001301                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:00001306                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:0000130B                 add     esp, 0Ch
.text$mn:0000130E
.text$mn:0000130E loc_130E:                               ; CODE XREF: std::_Debug_pointer<ScintillaEditView *>(ScintillaEditView * *,wchar_t const *,uint)+7j
.text$mn:0000130E                 pop     ebp
.text$mn:0000130F                 retn
.text$mn:0000130F ??$_Debug_pointer@PAVScintillaEditView@@@std@@YAXPAPAVScintillaEditView@@PB_WI@Z endp
.text$mn:0000130F
.text$mn:0000130F _text$mn        ends
.text$mn:0000130F
.text$mn:00001310 ; ===========================================================================
.text$mn:00001310
.text$mn:00001310 ; Segment type: Pure code
.text$mn:00001310 ; Segment permissions: Read/Execute
.text$mn:00001310 _text$mn        segment para public 'CODE' use32
.text$mn:00001310                 assume cs:_text$mn
.text$mn:00001310                 ;org 1310h
.text$mn:00001310 ; COMDAT (pick any)
.text$mn:00001310                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001310
.text$mn:00001310 ; =============== S U B R O U T I N E =======================================
.text$mn:00001310
.text$mn:00001310 ; Attributes: bp-based frame
.text$mn:00001310
.text$mn:00001310 ; int __cdecl std::_Debug_pointer<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>(int, wchar_t *, unsigned int)
.text$mn:00001310                 public ??$_Debug_pointer@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@PB_WI@Z
.text$mn:00001310 ??$_Debug_pointer@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@PB_WI@Z proc near
.text$mn:00001310                                         ; CODE XREF: std::_Debug_range2<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,wchar_t const *,uint,std::random_access_iterator_tag)+17p
.text$mn:00001310                                         ; std::_Debug_range2<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,wchar_t const *,uint,std::random_access_iterator_tag)+2Bp ...
.text$mn:00001310
.text$mn:00001310 arg_0           = dword ptr  8
.text$mn:00001310 arg_4           = dword ptr  0Ch
.text$mn:00001310 arg_8           = dword ptr  10h
.text$mn:00001310
.text$mn:00001310                 push    ebp
.text$mn:00001311                 mov     ebp, esp
.text$mn:00001313                 cmp     [ebp+arg_0], 0
.text$mn:00001317                 jnz     short loc_132E
.text$mn:00001319                 mov     eax, [ebp+arg_8]
.text$mn:0000131C                 push    eax             ; unsigned int
.text$mn:0000131D                 mov     ecx, [ebp+arg_4]
.text$mn:00001320                 push    ecx             ; wchar_t *
.text$mn:00001321                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:00001326                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:0000132B                 add     esp, 0Ch
.text$mn:0000132E
.text$mn:0000132E loc_132E:                               ; CODE XREF: std::_Debug_pointer<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,wchar_t const *,uint)+7j
.text$mn:0000132E                 pop     ebp
.text$mn:0000132F                 retn
.text$mn:0000132F ??$_Debug_pointer@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@PB_WI@Z endp
.text$mn:0000132F
.text$mn:0000132F _text$mn        ends
.text$mn:0000132F
.text$mn:00001330 ; ===========================================================================
.text$mn:00001330
.text$mn:00001330 ; Segment type: Pure code
.text$mn:00001330 ; Segment permissions: Read/Execute
.text$mn:00001330 _text$mn        segment para public 'CODE' use32
.text$mn:00001330                 assume cs:_text$mn
.text$mn:00001330                 ;org 1330h
.text$mn:00001330 ; COMDAT (pick any)
.text$mn:00001330                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001330
.text$mn:00001330 ; =============== S U B R O U T I N E =======================================
.text$mn:00001330
.text$mn:00001330 ; Attributes: bp-based frame
.text$mn:00001330
.text$mn:00001330 ; int __cdecl std::_Debug_range2<ScintillaEditView * *>(int, int, wchar_t *, unsigned int)
.text$mn:00001330                 public ??$_Debug_range2@PAPAVScintillaEditView@@@std@@YAXPAPAVScintillaEditView@@0PB_WIUrandom_access_iterator_tag@0@@Z
.text$mn:00001330 ??$_Debug_range2@PAPAVScintillaEditView@@@std@@YAXPAPAVScintillaEditView@@0PB_WIUrandom_access_iterator_tag@0@@Z proc near
.text$mn:00001330                                         ; CODE XREF: std::_Debug_range<ScintillaEditView * *>(ScintillaEditView * *,ScintillaEditView * *,wchar_t const *,uint)+2Ap
.text$mn:00001330
.text$mn:00001330 arg_0           = dword ptr  8
.text$mn:00001330 arg_4           = dword ptr  0Ch
.text$mn:00001330 arg_8           = dword ptr  10h
.text$mn:00001330 arg_C           = dword ptr  14h
.text$mn:00001330
.text$mn:00001330                 push    ebp
.text$mn:00001331                 mov     ebp, esp
.text$mn:00001333                 mov     eax, [ebp+arg_0]
.text$mn:00001336                 cmp     eax, [ebp+arg_4]
.text$mn:00001339                 jz      short loc_1380
.text$mn:0000133B                 mov     ecx, [ebp+arg_C]
.text$mn:0000133E                 push    ecx             ; unsigned int
.text$mn:0000133F                 mov     edx, [ebp+arg_8]
.text$mn:00001342                 push    edx             ; wchar_t *
.text$mn:00001343                 mov     eax, [ebp+arg_0]
.text$mn:00001346                 push    eax             ; int
.text$mn:00001347                 call    ??$_Debug_pointer@PAVScintillaEditView@@@std@@YAXPAPAVScintillaEditView@@PB_WI@Z ; std::_Debug_pointer<ScintillaEditView *>(ScintillaEditView * *,wchar_t const *,uint)
.text$mn:0000134C                 add     esp, 0Ch
.text$mn:0000134F                 mov     ecx, [ebp+arg_C]
.text$mn:00001352                 push    ecx             ; unsigned int
.text$mn:00001353                 mov     edx, [ebp+arg_8]
.text$mn:00001356                 push    edx             ; wchar_t *
.text$mn:00001357                 mov     eax, [ebp+arg_4]
.text$mn:0000135A                 push    eax             ; int
.text$mn:0000135B                 call    ??$_Debug_pointer@PAVScintillaEditView@@@std@@YAXPAPAVScintillaEditView@@PB_WI@Z ; std::_Debug_pointer<ScintillaEditView *>(ScintillaEditView * *,wchar_t const *,uint)
.text$mn:00001360                 add     esp, 0Ch
.text$mn:00001363                 mov     ecx, [ebp+arg_4]
.text$mn:00001366                 cmp     ecx, [ebp+arg_0]
.text$mn:00001369                 jnb     short loc_1380
.text$mn:0000136B                 mov     edx, [ebp+arg_C]
.text$mn:0000136E                 push    edx             ; unsigned int
.text$mn:0000136F                 mov     eax, [ebp+arg_8]
.text$mn:00001372                 push    eax             ; wchar_t *
.text$mn:00001373                 push    offset ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "invalid iterator range"
.text$mn:00001378                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:0000137D                 add     esp, 0Ch
.text$mn:00001380
.text$mn:00001380 loc_1380:                               ; CODE XREF: std::_Debug_range2<ScintillaEditView * *>(ScintillaEditView * *,ScintillaEditView * *,wchar_t const *,uint,std::random_access_iterator_tag)+9j
.text$mn:00001380                                         ; std::_Debug_range2<ScintillaEditView * *>(ScintillaEditView * *,ScintillaEditView * *,wchar_t const *,uint,std::random_access_iterator_tag)+39j
.text$mn:00001380                 pop     ebp
.text$mn:00001381                 retn
.text$mn:00001381 ??$_Debug_range2@PAPAVScintillaEditView@@@std@@YAXPAPAVScintillaEditView@@0PB_WIUrandom_access_iterator_tag@0@@Z endp
.text$mn:00001381
.text$mn:00001381 ; ---------------------------------------------------------------------------
.text$mn:00001382                 align 4
.text$mn:00001382 _text$mn        ends
.text$mn:00001382
.text$mn:00001384 ; ===========================================================================
.text$mn:00001384
.text$mn:00001384 ; Segment type: Pure code
.text$mn:00001384 ; Segment permissions: Read/Execute
.text$mn:00001384 _text$mn        segment para public 'CODE' use32
.text$mn:00001384                 assume cs:_text$mn
.text$mn:00001384                 ;org 1384h
.text$mn:00001384 ; COMDAT (pick any)
.text$mn:00001384                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001384
.text$mn:00001384 ; =============== S U B R O U T I N E =======================================
.text$mn:00001384
.text$mn:00001384 ; Attributes: bp-based frame
.text$mn:00001384
.text$mn:00001384 ; int __cdecl std::_Debug_range2<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *>(int, int, wchar_t *, unsigned int)
.text$mn:00001384                 public ??$_Debug_range2@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z
.text$mn:00001384 ??$_Debug_range2@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z proc near
.text$mn:00001384                                         ; CODE XREF: std::_Debug_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,wchar_t const *,uint)+2Ap
.text$mn:00001384
.text$mn:00001384 arg_0           = dword ptr  8
.text$mn:00001384 arg_4           = dword ptr  0Ch
.text$mn:00001384 arg_8           = dword ptr  10h
.text$mn:00001384 arg_C           = dword ptr  14h
.text$mn:00001384
.text$mn:00001384                 push    ebp
.text$mn:00001385                 mov     ebp, esp
.text$mn:00001387                 mov     eax, [ebp+arg_0]
.text$mn:0000138A                 cmp     eax, [ebp+arg_4]
.text$mn:0000138D                 jz      short loc_13D4
.text$mn:0000138F                 mov     ecx, [ebp+arg_C]
.text$mn:00001392                 push    ecx             ; unsigned int
.text$mn:00001393                 mov     edx, [ebp+arg_8]
.text$mn:00001396                 push    edx             ; wchar_t *
.text$mn:00001397                 mov     eax, [ebp+arg_0]
.text$mn:0000139A                 push    eax             ; int
.text$mn:0000139B                 call    ??$_Debug_pointer@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@PB_WI@Z ; std::_Debug_pointer<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,wchar_t const *,uint)
.text$mn:000013A0                 add     esp, 0Ch
.text$mn:000013A3                 mov     ecx, [ebp+arg_C]
.text$mn:000013A6                 push    ecx             ; unsigned int
.text$mn:000013A7                 mov     edx, [ebp+arg_8]
.text$mn:000013AA                 push    edx             ; wchar_t *
.text$mn:000013AB                 mov     eax, [ebp+arg_4]
.text$mn:000013AE                 push    eax             ; int
.text$mn:000013AF                 call    ??$_Debug_pointer@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@PB_WI@Z ; std::_Debug_pointer<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,wchar_t const *,uint)
.text$mn:000013B4                 add     esp, 0Ch
.text$mn:000013B7                 mov     ecx, [ebp+arg_4]
.text$mn:000013BA                 cmp     ecx, [ebp+arg_0]
.text$mn:000013BD                 jnb     short loc_13D4
.text$mn:000013BF                 mov     edx, [ebp+arg_C]
.text$mn:000013C2                 push    edx             ; unsigned int
.text$mn:000013C3                 mov     eax, [ebp+arg_8]
.text$mn:000013C6                 push    eax             ; wchar_t *
.text$mn:000013C7                 push    offset ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "invalid iterator range"
.text$mn:000013CC                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:000013D1                 add     esp, 0Ch
.text$mn:000013D4
.text$mn:000013D4 loc_13D4:                               ; CODE XREF: std::_Debug_range2<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,wchar_t const *,uint,std::random_access_iterator_tag)+9j
.text$mn:000013D4                                         ; std::_Debug_range2<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,wchar_t const *,uint,std::random_access_iterator_tag)+39j
.text$mn:000013D4                 pop     ebp
.text$mn:000013D5                 retn
.text$mn:000013D5 ??$_Debug_range2@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z endp
.text$mn:000013D5
.text$mn:000013D5 ; ---------------------------------------------------------------------------
.text$mn:000013D6                 align 4
.text$mn:000013D6 _text$mn        ends
.text$mn:000013D6
.text$mn:000013D8 ; ===========================================================================
.text$mn:000013D8
.text$mn:000013D8 ; Segment type: Pure code
.text$mn:000013D8 ; Segment permissions: Read/Execute
.text$mn:000013D8 _text$mn        segment para public 'CODE' use32
.text$mn:000013D8                 assume cs:_text$mn
.text$mn:000013D8                 ;org 13D8h
.text$mn:000013D8 ; COMDAT (pick any)
.text$mn:000013D8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000013D8
.text$mn:000013D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000013D8
.text$mn:000013D8 ; Attributes: bp-based frame
.text$mn:000013D8
.text$mn:000013D8 ; int __cdecl std::_Debug_range<ScintillaEditView * *>(int, int, wchar_t *, unsigned int)
.text$mn:000013D8                 public ??$_Debug_range@PAPAVScintillaEditView@@@std@@YAXPAPAVScintillaEditView@@0PB_WI@Z
.text$mn:000013D8 ??$_Debug_range@PAPAVScintillaEditView@@@std@@YAXPAPAVScintillaEditView@@0PB_WI@Z proc near
.text$mn:000013D8                                         ; CODE XREF: std::_Uninit_move<ScintillaEditView *,ScintillaEditView *,ScintillaEditView *>(ScintillaEditView * *,ScintillaEditView * *,ScintillaEditView * *,std::_Wrap_alloc<std::allocator<ScintillaEditView *>> &,ScintillaEditView * *,std::_Scalar_ptr_iterator_tag)+16p
.text$mn:000013D8
.text$mn:000013D8 var_1           = byte ptr -1
.text$mn:000013D8 arg_0           = dword ptr  8
.text$mn:000013D8 arg_4           = dword ptr  0Ch
.text$mn:000013D8 arg_8           = dword ptr  10h
.text$mn:000013D8 arg_C           = dword ptr  14h
.text$mn:000013D8
.text$mn:000013D8                 push    ebp
.text$mn:000013D9                 mov     ebp, esp
.text$mn:000013DB                 push    ecx
.text$mn:000013DC                 lea     eax, [ebp+arg_0]
.text$mn:000013DF                 push    eax
.text$mn:000013E0                 lea     ecx, [ebp+var_1]
.text$mn:000013E3                 push    ecx
.text$mn:000013E4                 call    ??$_Iter_cat@PAPAVScintillaEditView@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVScintillaEditView@@@Z ; std::_Iter_cat<ScintillaEditView * *>(ScintillaEditView * * const &)
.text$mn:000013E9                 add     esp, 8
.text$mn:000013EC                 mov     dl, [eax]
.text$mn:000013EE                 movzx   eax, dl
.text$mn:000013F1                 push    eax
.text$mn:000013F2                 mov     ecx, [ebp+arg_C]
.text$mn:000013F5                 push    ecx             ; unsigned int
.text$mn:000013F6                 mov     edx, [ebp+arg_8]
.text$mn:000013F9                 push    edx             ; wchar_t *
.text$mn:000013FA                 mov     eax, [ebp+arg_4]
.text$mn:000013FD                 push    eax             ; int
.text$mn:000013FE                 mov     ecx, [ebp+arg_0]
.text$mn:00001401                 push    ecx             ; int
.text$mn:00001402                 call    ??$_Debug_range2@PAPAVScintillaEditView@@@std@@YAXPAPAVScintillaEditView@@0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<ScintillaEditView * *>(ScintillaEditView * *,ScintillaEditView * *,wchar_t const *,uint,std::random_access_iterator_tag)
.text$mn:00001407                 add     esp, 14h
.text$mn:0000140A                 mov     esp, ebp
.text$mn:0000140C                 pop     ebp
.text$mn:0000140D                 retn
.text$mn:0000140D ??$_Debug_range@PAPAVScintillaEditView@@@std@@YAXPAPAVScintillaEditView@@0PB_WI@Z endp
.text$mn:0000140D
.text$mn:0000140D ; ---------------------------------------------------------------------------
.text$mn:0000140E                 align 10h
.text$mn:0000140E _text$mn        ends
.text$mn:0000140E
.text$mn:00001410 ; ===========================================================================
.text$mn:00001410
.text$mn:00001410 ; Segment type: Pure code
.text$mn:00001410 ; Segment permissions: Read/Execute
.text$mn:00001410 _text$mn        segment para public 'CODE' use32
.text$mn:00001410                 assume cs:_text$mn
.text$mn:00001410                 ;org 1410h
.text$mn:00001410 ; COMDAT (pick any)
.text$mn:00001410                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001410
.text$mn:00001410 ; =============== S U B R O U T I N E =======================================
.text$mn:00001410
.text$mn:00001410 ; Attributes: bp-based frame
.text$mn:00001410
.text$mn:00001410 ; int __cdecl std::_Debug_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *>(int, int, wchar_t *, unsigned int)
.text$mn:00001410                 public ??$_Debug_range@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@0PB_WI@Z
.text$mn:00001410 ??$_Debug_range@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@0PB_WI@Z proc near
.text$mn:00001410                                         ; CODE XREF: ??$_Uninit_move@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@V12@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@PAV10@00AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@0@0U_No
.text$mn:00001410                                         ; std::fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::alloc
.text$mn:00001410
.text$mn:00001410 var_1           = byte ptr -1
.text$mn:00001410 arg_0           = dword ptr  8
.text$mn:00001410 arg_4           = dword ptr  0Ch
.text$mn:00001410 arg_8           = dword ptr  10h
.text$mn:00001410 arg_C           = dword ptr  14h
.text$mn:00001410
.text$mn:00001410                 push    ebp
.text$mn:00001411                 mov     ebp, esp
.text$mn:00001413                 push    ecx
.text$mn:00001414                 lea     eax, [ebp+arg_0]
.text$mn:00001417                 push    eax
.text$mn:00001418                 lea     ecx, [ebp+var_1]
.text$mn:0000141B                 push    ecx
.text$mn:0000141C                 call    ??$_Iter_cat@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@@Z ; std::_Iter_cat<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> * const &)
.text$mn:00001421                 add     esp, 8
.text$mn:00001424                 mov     dl, [eax]
.text$mn:00001426                 movzx   eax, dl
.text$mn:00001429                 push    eax
.text$mn:0000142A                 mov     ecx, [ebp+arg_C]
.text$mn:0000142D                 push    ecx             ; unsigned int
.text$mn:0000142E                 mov     edx, [ebp+arg_8]
.text$mn:00001431                 push    edx             ; wchar_t *
.text$mn:00001432                 mov     eax, [ebp+arg_4]
.text$mn:00001435                 push    eax             ; int
.text$mn:00001436                 mov     ecx, [ebp+arg_0]
.text$mn:00001439                 push    ecx             ; int
.text$mn:0000143A                 call    ??$_Debug_range2@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,wchar_t const *,uint,std::random_access_iterator_tag)
.text$mn:0000143F                 add     esp, 14h
.text$mn:00001442                 mov     esp, ebp
.text$mn:00001444                 pop     ebp
.text$mn:00001445                 retn
.text$mn:00001445 ??$_Debug_range@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@0PB_WI@Z endp
.text$mn:00001445
.text$mn:00001445 ; ---------------------------------------------------------------------------
.text$mn:00001446                 align 4
.text$mn:00001446 _text$mn        ends
.text$mn:00001446
.text$mn:00001448 ; ===========================================================================
.text$mn:00001448
.text$mn:00001448 ; Segment type: Pure code
.text$mn:00001448 ; Segment permissions: Read/Execute
.text$mn:00001448 _text$mn        segment para public 'CODE' use32
.text$mn:00001448                 assume cs:_text$mn
.text$mn:00001448                 ;org 1448h
.text$mn:00001448 ; COMDAT (pick any)
.text$mn:00001448                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001448
.text$mn:00001448 ; =============== S U B R O U T I N E =======================================
.text$mn:00001448
.text$mn:00001448 ; Attributes: bp-based frame
.text$mn:00001448
.text$mn:00001448 ; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<struct std::_Wrap_alloc<class std::allocator<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<int const, struct Style>>>>>>>>(class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<int const, struct Style>>>> *, class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<int const, struct Style>>>> *, struct std::_Wrap_alloc<struct std::_Wrap_alloc<class std::allocator<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<int const, struct Style>>>>>>> &)
.text$mn:00001448                 public ??$_Destroy_range@U?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@0@0AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@std@@@0@@Z
.text$mn:00001448 ??$_Destroy_range@U?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@0@0AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@std@@@0@@Z proc near
.text$mn:00001448                                         ; CODE XREF: std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>>>>::_Destroy(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>> *)+21p
.text$mn:00001448
.text$mn:00001448 var_1           = byte ptr -1
.text$mn:00001448 arg_0           = dword ptr  8
.text$mn:00001448 arg_4           = dword ptr  0Ch
.text$mn:00001448 arg_8           = dword ptr  10h
.text$mn:00001448
.text$mn:00001448                 push    ebp
.text$mn:00001449                 mov     ebp, esp
.text$mn:0000144B                 push    ecx
.text$mn:0000144C                 mov     eax, [ebp+arg_4]
.text$mn:0000144F                 push    eax
.text$mn:00001450                 mov     ecx, [ebp+arg_0]
.text$mn:00001453                 push    ecx
.text$mn:00001454                 call    ??$_Ptr_cat@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@0@0@Z ; std::_Ptr_cat<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>> *)
.text$mn:00001459                 add     esp, 8
.text$mn:0000145C                 mov     [ebp+var_1], al
.text$mn:0000145F                 movzx   edx, [ebp+var_1]
.text$mn:00001463                 push    edx
.text$mn:00001464                 mov     eax, [ebp+arg_8]
.text$mn:00001467                 push    eax
.text$mn:00001468                 mov     ecx, [ebp+arg_4]
.text$mn:0000146B                 push    ecx
.text$mn:0000146C                 mov     edx, [ebp+arg_0]
.text$mn:0000146F                 push    edx
.text$mn:00001470                 call    ??$_Destroy_range@U?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@0@0AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>>>>>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>> *,std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>>>> &,std::_Nonscalar_ptr_iterator_tag)
.text$mn:00001475                 add     esp, 10h
.text$mn:00001478                 mov     esp, ebp
.text$mn:0000147A                 pop     ebp
.text$mn:0000147B                 retn
.text$mn:0000147B ??$_Destroy_range@U?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@0@0AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@std@@@0@@Z endp
.text$mn:0000147B
.text$mn:0000147B _text$mn        ends
.text$mn:0000147B
.text$mn:0000147C ; ===========================================================================
.text$mn:0000147C
.text$mn:0000147C ; Segment type: Pure code
.text$mn:0000147C ; Segment permissions: Read/Execute
.text$mn:0000147C _text$mn        segment para public 'CODE' use32
.text$mn:0000147C                 assume cs:_text$mn
.text$mn:0000147C                 ;org 147Ch
.text$mn:0000147C ; COMDAT (pick any)
.text$mn:0000147C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000147C
.text$mn:0000147C ; =============== S U B R O U T I N E =======================================
.text$mn:0000147C
.text$mn:0000147C ; Attributes: bp-based frame
.text$mn:0000147C
.text$mn:0000147C ; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<struct std::_Wrap_alloc<class std::allocator<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<int const, struct Style>>>>>>>>(class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<int const, struct Style>>>> *, class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<int const, struct Style>>>> *, struct std::_Wrap_alloc<struct std::_Wrap_alloc<class std::allocator<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<int const, struct Style>>>>>>> &, struct std::_Nonscalar_ptr_iterator_tag)
.text$mn:0000147C                 public ??$_Destroy_range@U?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@0@0AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:0000147C ??$_Destroy_range@U?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@0@0AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z proc near
.text$mn:0000147C                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>>>>>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>> *,std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>>>> &)+28p
.text$mn:0000147C
.text$mn:0000147C arg_0           = dword ptr  8
.text$mn:0000147C arg_4           = dword ptr  0Ch
.text$mn:0000147C arg_8           = dword ptr  10h
.text$mn:0000147C
.text$mn:0000147C                 push    ebp
.text$mn:0000147D                 mov     ebp, esp
.text$mn:0000147F                 jmp     short loc_148A
.text$mn:00001481 ; ---------------------------------------------------------------------------
.text$mn:00001481
.text$mn:00001481 loc_1481:                               ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>>>>>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>> *,std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>>>> &,std::_Nonscalar_ptr_iterator_tag)+22j
.text$mn:00001481                 mov     eax, [ebp+arg_0]
.text$mn:00001484                 add     eax, 4
.text$mn:00001487                 mov     [ebp+arg_0], eax
.text$mn:0000148A
.text$mn:0000148A loc_148A:                               ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>>>>>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>> *,std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>>>> &,std::_Nonscalar_ptr_iterator_tag)+3j
.text$mn:0000148A                 mov     ecx, [ebp+arg_0]
.text$mn:0000148D                 cmp     ecx, [ebp+arg_4]
.text$mn:00001490                 jz      short loc_14A0
.text$mn:00001492                 mov     edx, [ebp+arg_0]
.text$mn:00001495                 push    edx
.text$mn:00001496                 mov     ecx, [ebp+arg_8]
.text$mn:00001499                 call    ??$destroy@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@1@@Z ; std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>>>>::destroy<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>> *)
.text$mn:0000149E                 jmp     short loc_1481
.text$mn:000014A0 ; ---------------------------------------------------------------------------
.text$mn:000014A0
.text$mn:000014A0 loc_14A0:                               ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>>>>>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>> *,std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>>>> &,std::_Nonscalar_ptr_iterator_tag)+14j
.text$mn:000014A0                 pop     ebp
.text$mn:000014A1                 retn
.text$mn:000014A1 ??$_Destroy_range@U?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@0@0AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z endp
.text$mn:000014A1
.text$mn:000014A1 ; ---------------------------------------------------------------------------
.text$mn:000014A2                 align 4
.text$mn:000014A2 _text$mn        ends
.text$mn:000014A2
.text$mn:000014A4 ; ===========================================================================
.text$mn:000014A4
.text$mn:000014A4 ; Segment type: Pure code
.text$mn:000014A4 ; Segment permissions: Read/Execute
.text$mn:000014A4 _text$mn        segment para public 'CODE' use32
.text$mn:000014A4                 assume cs:_text$mn
.text$mn:000014A4                 ;org 14A4h
.text$mn:000014A4 ; COMDAT (pick any)
.text$mn:000014A4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000014A4
.text$mn:000014A4 ; =============== S U B R O U T I N E =======================================
.text$mn:000014A4
.text$mn:000014A4 ; Attributes: bp-based frame
.text$mn:000014A4
.text$mn:000014A4 ; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<struct std::_Wrap_alloc<class std::allocator<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>>>>>(class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>> *, class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>> *, struct std::_Wrap_alloc<struct
.text$mn:000014A4                 public ??$_Destroy_range@U?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@0AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@0@@Z
.text$mn:000014A4 ??$_Destroy_range@U?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@0AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@0@@Z proc near
.text$mn:000014A4                                         ; CODE XREF: std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::_Destroy(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *)+21p
.text$mn:000014A4
.text$mn:000014A4 var_1           = byte ptr -1
.text$mn:000014A4 arg_0           = dword ptr  8
.text$mn:000014A4 arg_4           = dword ptr  0Ch
.text$mn:000014A4 arg_8           = dword ptr  10h
.text$mn:000014A4
.text$mn:000014A4                 push    ebp
.text$mn:000014A5                 mov     ebp, esp
.text$mn:000014A7                 push    ecx
.text$mn:000014A8                 mov     eax, [ebp+arg_4]
.text$mn:000014AB                 push    eax
.text$mn:000014AC                 mov     ecx, [ebp+arg_0]
.text$mn:000014AF                 push    ecx
.text$mn:000014B0                 call    ??$_Ptr_cat@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@0@Z ; std::_Ptr_cat<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *)
.text$mn:000014B5                 add     esp, 8
.text$mn:000014B8                 mov     [ebp+var_1], al
.text$mn:000014BB                 movzx   edx, [ebp+var_1]
.text$mn:000014BF                 push    edx
.text$mn:000014C0                 mov     eax, [ebp+arg_8]
.text$mn:000014C3                 push    eax
.text$mn:000014C4                 mov     ecx, [ebp+arg_4]
.text$mn:000014C7                 push    ecx
.text$mn:000014C8                 mov     edx, [ebp+arg_0]
.text$mn:000014CB                 push    edx
.text$mn:000014CC                 call    ??$_Destroy_range@U?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@0AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>> &,std::_Nonscalar_ptr_iterator_tag)
.text$mn:000014D1                 add     esp, 10h
.text$mn:000014D4                 mov     esp, ebp
.text$mn:000014D6                 pop     ebp
.text$mn:000014D7                 retn
.text$mn:000014D7 ??$_Destroy_range@U?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@0AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@0@@Z endp
.text$mn:000014D7
.text$mn:000014D7 _text$mn        ends
.text$mn:000014D7
.text$mn:000014D8 ; ===========================================================================
.text$mn:000014D8
.text$mn:000014D8 ; Segment type: Pure code
.text$mn:000014D8 ; Segment permissions: Read/Execute
.text$mn:000014D8 _text$mn        segment para public 'CODE' use32
.text$mn:000014D8                 assume cs:_text$mn
.text$mn:000014D8                 ;org 14D8h
.text$mn:000014D8 ; COMDAT (pick any)
.text$mn:000014D8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000014D8
.text$mn:000014D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000014D8
.text$mn:000014D8 ; Attributes: bp-based frame
.text$mn:000014D8
.text$mn:000014D8 ; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<struct std::_Wrap_alloc<class std::allocator<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>>>>>(class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>> *, class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>> *, struct std::_Wrap_alloc<struct
.text$mn:000014D8                 public ??$_Destroy_range@U?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@0AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:000014D8 ??$_Destroy_range@U?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@0AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z proc near
.text$mn:000014D8                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>> &)+28p
.text$mn:000014D8
.text$mn:000014D8 arg_0           = dword ptr  8
.text$mn:000014D8 arg_4           = dword ptr  0Ch
.text$mn:000014D8 arg_8           = dword ptr  10h
.text$mn:000014D8
.text$mn:000014D8                 push    ebp
.text$mn:000014D9                 mov     ebp, esp
.text$mn:000014DB                 jmp     short loc_14E6
.text$mn:000014DD ; ---------------------------------------------------------------------------
.text$mn:000014DD
.text$mn:000014DD loc_14DD:                               ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>> &,std::_Nonscalar_ptr_iterator_tag)+22j
.text$mn:000014DD                 mov     eax, [ebp+arg_0]
.text$mn:000014E0                 add     eax, 4
.text$mn:000014E3                 mov     [ebp+arg_0], eax
.text$mn:000014E6
.text$mn:000014E6 loc_14E6:                               ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>> &,std::_Nonscalar_ptr_iterator_tag)+3j
.text$mn:000014E6                 mov     ecx, [ebp+arg_0]
.text$mn:000014E9                 cmp     ecx, [ebp+arg_4]
.text$mn:000014EC                 jz      short loc_14FC
.text$mn:000014EE                 mov     edx, [ebp+arg_0]
.text$mn:000014F1                 push    edx
.text$mn:000014F2                 mov     ecx, [ebp+arg_8]
.text$mn:000014F5                 call    ??$destroy@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@@Z ; std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::destroy<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *)
.text$mn:000014FA                 jmp     short loc_14DD
.text$mn:000014FC ; ---------------------------------------------------------------------------
.text$mn:000014FC
.text$mn:000014FC loc_14FC:                               ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>> &,std::_Nonscalar_ptr_iterator_tag)+14j
.text$mn:000014FC                 pop     ebp
.text$mn:000014FD                 retn
.text$mn:000014FD ??$_Destroy_range@U?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@0AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z endp
.text$mn:000014FD
.text$mn:000014FD ; ---------------------------------------------------------------------------
.text$mn:000014FE                 align 10h
.text$mn:000014FE _text$mn        ends
.text$mn:000014FE
.text$mn:00001500 ; ===========================================================================
.text$mn:00001500
.text$mn:00001500 ; Segment type: Pure code
.text$mn:00001500 ; Segment permissions: Read/Execute
.text$mn:00001500 _text$mn        segment para public 'CODE' use32
.text$mn:00001500                 assume cs:_text$mn
.text$mn:00001500                 ;org 1500h
.text$mn:00001500 ; COMDAT (pick any)
.text$mn:00001500                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001500
.text$mn:00001500 ; =============== S U B R O U T I N E =======================================
.text$mn:00001500
.text$mn:00001500 ; Attributes: bp-based frame
.text$mn:00001500
.text$mn:00001500 ; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<class ScintillaEditView *>>>(class ScintillaEditView * *, class ScintillaEditView * *, struct std::_Wrap_alloc<class std::allocator<class ScintillaEditView *>> &)
.text$mn:00001500                 public ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVScintillaEditView@@@std@@@std@@@std@@YAXPAPAVScintillaEditView@@0AAU?$_Wrap_alloc@V?$allocator@PAVScintillaEditView@@@std@@@0@@Z
.text$mn:00001500 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVScintillaEditView@@@std@@@std@@@std@@YAXPAPAVScintillaEditView@@0AAU?$_Wrap_alloc@V?$allocator@PAVScintillaEditView@@@std@@@0@@Z proc near
.text$mn:00001500                                         ; CODE XREF: std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::_Destroy(ScintillaEditView * *,ScintillaEditView * *)+21p
.text$mn:00001500
.text$mn:00001500 var_1           = byte ptr -1
.text$mn:00001500 arg_0           = dword ptr  8
.text$mn:00001500 arg_4           = dword ptr  0Ch
.text$mn:00001500 arg_8           = dword ptr  10h
.text$mn:00001500
.text$mn:00001500                 push    ebp
.text$mn:00001501                 mov     ebp, esp
.text$mn:00001503                 push    ecx
.text$mn:00001504                 mov     eax, [ebp+arg_4]
.text$mn:00001507                 push    eax
.text$mn:00001508                 mov     ecx, [ebp+arg_0]
.text$mn:0000150B                 push    ecx
.text$mn:0000150C                 call    ??$_Ptr_cat@PAVScintillaEditView@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVScintillaEditView@@0@Z ; std::_Ptr_cat<ScintillaEditView *,ScintillaEditView *>(ScintillaEditView * *,ScintillaEditView * *)
.text$mn:00001511                 add     esp, 8
.text$mn:00001514                 mov     [ebp+var_1], al
.text$mn:00001517                 movzx   edx, [ebp+var_1]
.text$mn:0000151B                 push    edx
.text$mn:0000151C                 mov     eax, [ebp+arg_8]
.text$mn:0000151F                 push    eax
.text$mn:00001520                 mov     ecx, [ebp+arg_4]
.text$mn:00001523                 push    ecx
.text$mn:00001524                 mov     edx, [ebp+arg_0]
.text$mn:00001527                 push    edx
.text$mn:00001528                 call    ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVScintillaEditView@@@std@@@std@@@std@@YAXPAPAVScintillaEditView@@0AAU?$_Wrap_alloc@V?$allocator@PAVScintillaEditView@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<ScintillaEditView *>>>(ScintillaEditView * *,ScintillaEditView * *,std::_Wrap_alloc<std::allocator<ScintillaEditView *>> &,std::_Scalar_ptr_iterator_tag)
.text$mn:0000152D                 add     esp, 10h
.text$mn:00001530                 mov     esp, ebp
.text$mn:00001532                 pop     ebp
.text$mn:00001533                 retn
.text$mn:00001533 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVScintillaEditView@@@std@@@std@@@std@@YAXPAPAVScintillaEditView@@0AAU?$_Wrap_alloc@V?$allocator@PAVScintillaEditView@@@std@@@0@@Z endp
.text$mn:00001533
.text$mn:00001533 _text$mn        ends
.text$mn:00001533
.text$mn:00001534 ; ===========================================================================
.text$mn:00001534
.text$mn:00001534 ; Segment type: Pure code
.text$mn:00001534 ; Segment permissions: Read/Execute
.text$mn:00001534 _text$mn        segment para public 'CODE' use32
.text$mn:00001534                 assume cs:_text$mn
.text$mn:00001534                 ;org 1534h
.text$mn:00001534 ; COMDAT (pick any)
.text$mn:00001534                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001534
.text$mn:00001534 ; =============== S U B R O U T I N E =======================================
.text$mn:00001534
.text$mn:00001534 ; Attributes: bp-based frame
.text$mn:00001534
.text$mn:00001534 ; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<class ScintillaEditView *>>>(class ScintillaEditView * *, class ScintillaEditView * *, struct std::_Wrap_alloc<class std::allocator<class ScintillaEditView *>> &, struct std::_Scalar_ptr_iterator_tag)
.text$mn:00001534                 public ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVScintillaEditView@@@std@@@std@@@std@@YAXPAPAVScintillaEditView@@0AAU?$_Wrap_alloc@V?$allocator@PAVScintillaEditView@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
.text$mn:00001534 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVScintillaEditView@@@std@@@std@@@std@@YAXPAPAVScintillaEditView@@0AAU?$_Wrap_alloc@V?$allocator@PAVScintillaEditView@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z proc near
.text$mn:00001534                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<ScintillaEditView *>>>(ScintillaEditView * *,ScintillaEditView * *,std::_Wrap_alloc<std::allocator<ScintillaEditView *>> &)+28p
.text$mn:00001534                 push    ebp
.text$mn:00001535                 mov     ebp, esp
.text$mn:00001537                 pop     ebp
.text$mn:00001538                 retn
.text$mn:00001538 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVScintillaEditView@@@std@@@std@@@std@@YAXPAPAVScintillaEditView@@0AAU?$_Wrap_alloc@V?$allocator@PAVScintillaEditView@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z endp
.text$mn:00001538
.text$mn:00001538 ; ---------------------------------------------------------------------------
.text$mn:00001539                 align 4
.text$mn:00001539 _text$mn        ends
.text$mn:00001539
.text$mn:0000153C ; ===========================================================================
.text$mn:0000153C
.text$mn:0000153C ; Segment type: Pure code
.text$mn:0000153C ; Segment permissions: Read/Execute
.text$mn:0000153C _text$mn        segment para public 'CODE' use32
.text$mn:0000153C                 assume cs:_text$mn
.text$mn:0000153C                 ;org 153Ch
.text$mn:0000153C ; COMDAT (pick any)
.text$mn:0000153C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000153C
.text$mn:0000153C ; =============== S U B R O U T I N E =======================================
.text$mn:0000153C
.text$mn:0000153C ; Attributes: bp-based frame
.text$mn:0000153C
.text$mn:0000153C ; void __cdecl std::_Fill<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>> *, class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>>(class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>> *, class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class B
.text$mn:0000153C                 public ??$_Fill@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@0ABV10@@Z
.text$mn:0000153C ??$_Fill@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@0ABV10@@Z proc near
.text$mn:0000153C                                         ; CODE XREF: std::fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>
.text$mn:0000153C
.text$mn:0000153C arg_0           = dword ptr  8
.text$mn:0000153C arg_4           = dword ptr  0Ch
.text$mn:0000153C arg_8           = dword ptr  10h
.text$mn:0000153C
.text$mn:0000153C                 push    ebp
.text$mn:0000153D                 mov     ebp, esp
.text$mn:0000153F                 jmp     short loc_154A
.text$mn:00001541 ; ---------------------------------------------------------------------------
.text$mn:00001541
.text$mn:00001541 loc_1541:                               ; CODE XREF: std::_Fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int
.text$mn:00001541                 mov     eax, [ebp+arg_0]
.text$mn:00001544                 add     eax, 4
.text$mn:00001547                 mov     [ebp+arg_0], eax
.text$mn:0000154A
.text$mn:0000154A loc_154A:                               ; CODE XREF: std::_Fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int
.text$mn:0000154A                 mov     ecx, [ebp+arg_0]
.text$mn:0000154D                 cmp     ecx, [ebp+arg_4]
.text$mn:00001550                 jz      short loc_155E
.text$mn:00001552                 mov     edx, [ebp+arg_8]
.text$mn:00001555                 mov     eax, [edx]
.text$mn:00001557                 mov     ecx, [ebp+arg_0]
.text$mn:0000155A                 mov     [ecx], eax
.text$mn:0000155C                 jmp     short loc_1541
.text$mn:0000155E ; ---------------------------------------------------------------------------
.text$mn:0000155E
.text$mn:0000155E loc_155E:                               ; CODE XREF: std::_Fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int
.text$mn:0000155E                 pop     ebp
.text$mn:0000155F                 retn
.text$mn:0000155F ??$_Fill@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@0ABV10@@Z endp
.text$mn:0000155F
.text$mn:0000155F _text$mn        ends
.text$mn:0000155F
.text$mn:00001560 ; ===========================================================================
.text$mn:00001560
.text$mn:00001560 ; Segment type: Pure code
.text$mn:00001560 ; Segment permissions: Read/Execute
.text$mn:00001560 _text$mn        segment para public 'CODE' use32
.text$mn:00001560                 assume cs:_text$mn
.text$mn:00001560                 ;org 1560h
.text$mn:00001560 ; COMDAT (pick any)
.text$mn:00001560                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001560
.text$mn:00001560 ; =============== S U B R O U T I N E =======================================
.text$mn:00001560
.text$mn:00001560 ; Attributes: bp-based frame
.text$mn:00001560
.text$mn:00001560 ; public: static void __cdecl std::_Alloc_destroy::_Fn<struct std::_Wrap_alloc<class std::allocator<struct std::_Container_proxy>>, struct std::_Container_proxy>(int, struct std::_Wrap_alloc<class std::allocator<struct std::_Container_proxy>> &, struct std::_Container_proxy *)
.text$mn:00001560                 public ??$_Fn@U?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@U_Container_proxy@2@@_Alloc_destroy@std@@SAXHAAU?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@1@PAU_Container_proxy@1@@Z
.text$mn:00001560 ??$_Fn@U?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@U_Container_proxy@2@@_Alloc_destroy@std@@SAXHAAU?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@1@PAU_Container_proxy@1@@Z proc near
.text$mn:00001560                                         ; CODE XREF: std::allocator_traits<std::_Wrap_alloc<std::allocator<std::_Container_proxy>>>::destroy<std::_Container_proxy>(std::_Wrap_alloc<std::allocator<std::_Container_proxy>> &,std::_Container_proxy *)+Dp
.text$mn:00001560
.text$mn:00001560 arg_4           = dword ptr  0Ch
.text$mn:00001560 arg_8           = dword ptr  10h
.text$mn:00001560
.text$mn:00001560                 push    ebp
.text$mn:00001561                 mov     ebp, esp
.text$mn:00001563                 mov     eax, [ebp+arg_8]
.text$mn:00001566                 push    eax
.text$mn:00001567                 mov     ecx, [ebp+arg_4]
.text$mn:0000156A                 call    ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:0000156F                 pop     ebp
.text$mn:00001570                 retn
.text$mn:00001570 ??$_Fn@U?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@U_Container_proxy@2@@_Alloc_destroy@std@@SAXHAAU?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@1@PAU_Container_proxy@1@@Z endp
.text$mn:00001570
.text$mn:00001570 ; ---------------------------------------------------------------------------
.text$mn:00001571                 align 4
.text$mn:00001571 _text$mn        ends
.text$mn:00001571
.text$mn:00001574 ; ===========================================================================
.text$mn:00001574
.text$mn:00001574 ; Segment type: Pure code
.text$mn:00001574 ; Segment permissions: Read/Execute
.text$mn:00001574 _text$mn        segment para public 'CODE' use32
.text$mn:00001574                 assume cs:_text$mn
.text$mn:00001574                 ;org 1574h
.text$mn:00001574 ; COMDAT (pick any)
.text$mn:00001574                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001574
.text$mn:00001574 ; =============== S U B R O U T I N E =======================================
.text$mn:00001574
.text$mn:00001574 ; Attributes: bp-based frame
.text$mn:00001574
.text$mn:00001574 ; int __cdecl std::_Alloc_construct::_Fn<std::_Wrap_alloc<std::allocator<std::_Container_proxy>>,std::_Container_proxy,std::_Container_proxy>(int, int, void *, int)
.text$mn:00001574                 public ??$_Fn@U?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@U_Container_proxy@2@U32@@_Alloc_construct@std@@SAXHAAU?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z
.text$mn:00001574 ??$_Fn@U?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@U_Container_proxy@2@U32@@_Alloc_construct@std@@SAXHAAU?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z proc near
.text$mn:00001574                                         ; CODE XREF: std::allocator_traits<std::_Wrap_alloc<std::allocator<std::_Container_proxy>>>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Wrap_alloc<std::allocator<std::_Container_proxy>> &,std::_Container_proxy *,std::_Container_proxy &&)+1Ap
.text$mn:00001574
.text$mn:00001574 arg_4           = dword ptr  0Ch
.text$mn:00001574 arg_8           = dword ptr  10h
.text$mn:00001574 arg_C           = dword ptr  14h
.text$mn:00001574
.text$mn:00001574                 push    ebp
.text$mn:00001575                 mov     ebp, esp
.text$mn:00001577                 mov     eax, [ebp+arg_C]
.text$mn:0000157A                 push    eax
.text$mn:0000157B                 call    ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>(std::_Container_proxy &)
.text$mn:00001580                 add     esp, 4
.text$mn:00001583                 push    eax             ; int
.text$mn:00001584                 mov     ecx, [ebp+arg_8]
.text$mn:00001587                 push    ecx             ; void *
.text$mn:00001588                 mov     ecx, [ebp+arg_4]
.text$mn:0000158B                 call    ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:00001590                 pop     ebp
.text$mn:00001591                 retn
.text$mn:00001591 ??$_Fn@U?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@U_Container_proxy@2@U32@@_Alloc_construct@std@@SAXHAAU?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z endp
.text$mn:00001591
.text$mn:00001591 ; ---------------------------------------------------------------------------
.text$mn:00001592                 align 4
.text$mn:00001592 _text$mn        ends
.text$mn:00001592
.text$mn:00001594 ; ===========================================================================
.text$mn:00001594
.text$mn:00001594 ; Segment type: Pure code
.text$mn:00001594 ; Segment permissions: Read/Execute
.text$mn:00001594 _text$mn        segment para public 'CODE' use32
.text$mn:00001594                 assume cs:_text$mn
.text$mn:00001594                 ;org 1594h
.text$mn:00001594 ; COMDAT (pick any)
.text$mn:00001594                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001594
.text$mn:00001594 ; =============== S U B R O U T I N E =======================================
.text$mn:00001594
.text$mn:00001594 ; Attributes: bp-based frame
.text$mn:00001594
.text$mn:00001594 ; public: static void __cdecl std::_Alloc_destroy::_Fn<struct std::_Wrap_alloc<class std::allocator<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<int const, struct Style>>>>>>, class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<int const, struct Style>>>>>(int, struct std::_Wrap_alloc<class std::allocator<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<int const, struct Style>>>>>> &, class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<int const, struct Style>>>> *)
.text$mn:00001594                 public ??$_Fn@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@2@@_Alloc_destroy@std@@SAXHAAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@1@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@1@@Z
.text$mn:00001594 ??$_Fn@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@2@@_Alloc_destroy@std@@SAXHAAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@1@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@1@@Z proc near
.text$mn:00001594                                         ; CODE XREF: std::allocator_traits<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>>>>::destroy<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>>(std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>>> &,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>> *)+Dp
.text$mn:00001594
.text$mn:00001594 arg_4           = dword ptr  0Ch
.text$mn:00001594 arg_8           = dword ptr  10h
.text$mn:00001594
.text$mn:00001594                 push    ebp
.text$mn:00001595                 mov     ebp, esp
.text$mn:00001597                 mov     eax, [ebp+arg_8]
.text$mn:0000159A                 push    eax
.text$mn:0000159B                 mov     ecx, [ebp+arg_4]
.text$mn:0000159E                 call    ??$destroy@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@1@@Z ; std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>>>::destroy<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>> *)
.text$mn:000015A3                 pop     ebp
.text$mn:000015A4                 retn
.text$mn:000015A4 ??$_Fn@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@2@@_Alloc_destroy@std@@SAXHAAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@1@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@1@@Z endp
.text$mn:000015A4
.text$mn:000015A4 ; ---------------------------------------------------------------------------
.text$mn:000015A5                 align 4
.text$mn:000015A5 _text$mn        ends
.text$mn:000015A5
.text$mn:000015A8 ; ===========================================================================
.text$mn:000015A8
.text$mn:000015A8 ; Segment type: Pure code
.text$mn:000015A8 ; Segment permissions: Read/Execute
.text$mn:000015A8 _text$mn        segment para public 'CODE' use32
.text$mn:000015A8                 assume cs:_text$mn
.text$mn:000015A8                 ;org 15A8h
.text$mn:000015A8 ; COMDAT (pick any)
.text$mn:000015A8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000015A8
.text$mn:000015A8 ; =============== S U B R O U T I N E =======================================
.text$mn:000015A8
.text$mn:000015A8 ; Attributes: bp-based frame
.text$mn:000015A8
.text$mn:000015A8 ; public: static unsigned int __cdecl std::_Alloc_max_size::_Fn<struct std::_Wrap_alloc<class std::allocator<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>>>>(int, struct std::_Wrap_alloc<class std::allocator<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>>> const &)
.text$mn:000015A8                 public ??$_Fn@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@_Alloc_max_size@std@@SAIHABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@1@@Z
.text$mn:000015A8 ??$_Fn@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@_Alloc_max_size@std@@SAIHABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@1@@Z proc near
.text$mn:000015A8                                         ; CODE XREF: std::allocator_traits<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::max_size(std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>> const &)+9p
.text$mn:000015A8
.text$mn:000015A8 arg_4           = dword ptr  0Ch
.text$mn:000015A8
.text$mn:000015A8                 push    ebp
.text$mn:000015A9                 mov     ebp, esp
.text$mn:000015AB                 mov     ecx, [ebp+arg_4]
.text$mn:000015AE                 call    ?max_size@?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>::max_size(void)
.text$mn:000015B3                 pop     ebp
.text$mn:000015B4                 retn
.text$mn:000015B4 ??$_Fn@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@_Alloc_max_size@std@@SAIHABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@1@@Z endp
.text$mn:000015B4
.text$mn:000015B4 ; ---------------------------------------------------------------------------
.text$mn:000015B5                 align 4
.text$mn:000015B5 _text$mn        ends
.text$mn:000015B5
.text$mn:000015B8 ; ===========================================================================
.text$mn:000015B8
.text$mn:000015B8 ; Segment type: Pure code
.text$mn:000015B8 ; Segment permissions: Read/Execute
.text$mn:000015B8 _text$mn        segment para public 'CODE' use32
.text$mn:000015B8                 assume cs:_text$mn
.text$mn:000015B8                 ;org 15B8h
.text$mn:000015B8 ; COMDAT (pick any)
.text$mn:000015B8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000015B8
.text$mn:000015B8 ; =============== S U B R O U T I N E =======================================
.text$mn:000015B8
.text$mn:000015B8 ; Attributes: bp-based frame
.text$mn:000015B8
.text$mn:000015B8 ; public: static void __cdecl std::_Alloc_destroy::_Fn<struct std::_Wrap_alloc<class std::allocator<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>>>, class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>>(int, struct std::_Wrap_alloc<class std::allocator<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>
.text$mn:000015B8                 public ??$_Fn@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@@_Alloc_destroy@std@@SAXHAAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@1@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@@Z
.text$mn:000015B8 ??$_Fn@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@@_Alloc_destroy@std@@SAXHAAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@1@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@@Z proc near
.text$mn:000015B8                                         ; CODE XREF: std::allocator_traits<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::destroy<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>(std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>> &,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *)+Dp
.text$mn:000015B8
.text$mn:000015B8 arg_4           = dword ptr  0Ch
.text$mn:000015B8 arg_8           = dword ptr  10h
.text$mn:000015B8
.text$mn:000015B8                 push    ebp
.text$mn:000015B9                 mov     ebp, esp
.text$mn:000015BB                 mov     eax, [ebp+arg_8]
.text$mn:000015BE                 push    eax
.text$mn:000015BF                 mov     ecx, [ebp+arg_4]
.text$mn:000015C2                 call    ??$destroy@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@@Z ; std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>::destroy<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *)
.text$mn:000015C7                 pop     ebp
.text$mn:000015C8                 retn
.text$mn:000015C8 ??$_Fn@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@@_Alloc_destroy@std@@SAXHAAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@1@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@@Z endp
.text$mn:000015C8
.text$mn:000015C8 ; ---------------------------------------------------------------------------
.text$mn:000015C9                 align 4
.text$mn:000015C9 _text$mn        ends
.text$mn:000015C9
.text$mn:000015CC ; ===========================================================================
.text$mn:000015CC
.text$mn:000015CC ; Segment type: Pure code
.text$mn:000015CC ; Segment permissions: Read/Execute
.text$mn:000015CC _text$mn        segment para public 'CODE' use32
.text$mn:000015CC                 assume cs:_text$mn
.text$mn:000015CC                 ;org 15CCh
.text$mn:000015CC ; COMDAT (pick any)
.text$mn:000015CC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000015CC
.text$mn:000015CC ; =============== S U B R O U T I N E =======================================
.text$mn:000015CC
.text$mn:000015CC ; Attributes: bp-based frame
.text$mn:000015CC
.text$mn:000015CC ; int __cdecl std::_Alloc_construct::_Fn<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const &>(int, int, void *, int)
.text$mn:000015CC                 public ??$_Fn@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@ABV32@@_Alloc_construct@std@@SAXHAAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@1@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@ABV31@@Z
.text$mn:000015CC ??$_Fn@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@ABV32@@_Alloc_construct@std@@SAXHAAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@1@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@ABV31@@Z proc near
.text$mn:000015CC                                         ; CODE XREF: std::allocator_traits<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::construct<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const &>(std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>> &,std::_List_unchecked_iterator<std::_List_val<std::_List_simp
.text$mn:000015CC
.text$mn:000015CC arg_4           = dword ptr  0Ch
.text$mn:000015CC arg_8           = dword ptr  10h
.text$mn:000015CC arg_C           = dword ptr  14h
.text$mn:000015CC
.text$mn:000015CC                 push    ebp
.text$mn:000015CD                 mov     ebp, esp
.text$mn:000015CF                 mov     eax, [ebp+arg_C]
.text$mn:000015D2                 push    eax
.text$mn:000015D3                 call    ??$forward@ABV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@YAABV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@ABV10@@Z ; std::forward<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const &>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const &)
.text$mn:000015D8                 add     esp, 4
.text$mn:000015DB                 push    eax             ; int
.text$mn:000015DC                 mov     ecx, [ebp+arg_8]
.text$mn:000015DF                 push    ecx             ; void *
.text$mn:000015E0                 mov     ecx, [ebp+arg_4]
.text$mn:000015E3                 call    ??$construct@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@ABV12@@?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@ABV21@@Z ; std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>::construct<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const &>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const &)
.text$mn:000015E8                 pop     ebp
.text$mn:000015E9                 retn
.text$mn:000015E9 ??$_Fn@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@ABV32@@_Alloc_construct@std@@SAXHAAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@1@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@ABV31@@Z endp
.text$mn:000015E9
.text$mn:000015E9 ; ---------------------------------------------------------------------------
.text$mn:000015EA                 align 4
.text$mn:000015EA _text$mn        ends
.text$mn:000015EA
.text$mn:000015EC ; ===========================================================================
.text$mn:000015EC
.text$mn:000015EC ; Segment type: Pure code
.text$mn:000015EC ; Segment permissions: Read/Execute
.text$mn:000015EC _text$mn        segment para public 'CODE' use32
.text$mn:000015EC                 assume cs:_text$mn
.text$mn:000015EC                 ;org 15ECh
.text$mn:000015EC ; COMDAT (pick any)
.text$mn:000015EC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000015EC
.text$mn:000015EC ; =============== S U B R O U T I N E =======================================
.text$mn:000015EC
.text$mn:000015EC ; Attributes: bp-based frame
.text$mn:000015EC
.text$mn:000015EC ; int __cdecl std::_Alloc_construct::_Fn<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>(int, int, void *, int)
.text$mn:000015EC                 public ??$_Fn@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@V32@@_Alloc_construct@std@@SAXHAAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@1@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@$$QAV31@@Z
.text$mn:000015EC ??$_Fn@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@V32@@_Alloc_construct@std@@SAXHAAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@1@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@$$QAV31@@Z proc near
.text$mn:000015EC                                         ; CODE XREF: std::allocator_traits<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::construct<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>(std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>> &,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types
.text$mn:000015EC
.text$mn:000015EC arg_4           = dword ptr  0Ch
.text$mn:000015EC arg_8           = dword ptr  10h
.text$mn:000015EC arg_C           = dword ptr  14h
.text$mn:000015EC
.text$mn:000015EC                 push    ebp
.text$mn:000015ED                 mov     ebp, esp
.text$mn:000015EF                 mov     eax, [ebp+arg_C]
.text$mn:000015F2                 push    eax
.text$mn:000015F3                 call    ??$forward@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@YA$$QAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@AAV10@@Z ; std::forward<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> &)
.text$mn:000015F8                 add     esp, 4
.text$mn:000015FB                 push    eax             ; int
.text$mn:000015FC                 mov     ecx, [ebp+arg_8]
.text$mn:000015FF                 push    ecx             ; void *
.text$mn:00001600                 mov     ecx, [ebp+arg_4]
.text$mn:00001603                 call    ??$construct@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@V12@@?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@$$QAV21@@Z ; std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>::construct<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> &&)
.text$mn:00001608                 pop     ebp
.text$mn:00001609                 retn
.text$mn:00001609 ??$_Fn@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@V32@@_Alloc_construct@std@@SAXHAAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@1@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@$$QAV31@@Z endp
.text$mn:00001609
.text$mn:00001609 ; ---------------------------------------------------------------------------
.text$mn:0000160A                 align 4
.text$mn:0000160A _text$mn        ends
.text$mn:0000160A
.text$mn:0000160C ; ===========================================================================
.text$mn:0000160C
.text$mn:0000160C ; Segment type: Pure code
.text$mn:0000160C ; Segment permissions: Read/Execute
.text$mn:0000160C _text$mn        segment para public 'CODE' use32
.text$mn:0000160C                 assume cs:_text$mn
.text$mn:0000160C                 ;org 160Ch
.text$mn:0000160C ; COMDAT (pick any)
.text$mn:0000160C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000160C
.text$mn:0000160C ; =============== S U B R O U T I N E =======================================
.text$mn:0000160C
.text$mn:0000160C ; Attributes: bp-based frame
.text$mn:0000160C
.text$mn:0000160C ; struct std::random_access_iterator_tag __cdecl std::_Iter_cat<class ScintillaEditView * *>(class ScintillaEditView * * const &)
.text$mn:0000160C                 public ??$_Iter_cat@PAPAVScintillaEditView@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVScintillaEditView@@@Z
.text$mn:0000160C ??$_Iter_cat@PAPAVScintillaEditView@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVScintillaEditView@@@Z proc near
.text$mn:0000160C                                         ; CODE XREF: std::_Debug_range<ScintillaEditView * *>(ScintillaEditView * *,ScintillaEditView * *,wchar_t const *,uint)+Cp
.text$mn:0000160C
.text$mn:0000160C var_1           = byte ptr -1
.text$mn:0000160C arg_0           = dword ptr  8
.text$mn:0000160C
.text$mn:0000160C                 push    ebp
.text$mn:0000160D                 mov     ebp, esp
.text$mn:0000160F                 push    ecx
.text$mn:00001610                 mov     eax, [ebp+arg_0]
.text$mn:00001613                 mov     cl, [ebp+var_1]
.text$mn:00001616                 mov     [eax], cl
.text$mn:00001618                 mov     eax, [ebp+arg_0]
.text$mn:0000161B                 mov     esp, ebp
.text$mn:0000161D                 pop     ebp
.text$mn:0000161E                 retn
.text$mn:0000161E ??$_Iter_cat@PAPAVScintillaEditView@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVScintillaEditView@@@Z endp
.text$mn:0000161E
.text$mn:0000161E ; ---------------------------------------------------------------------------
.text$mn:0000161F                 align 10h
.text$mn:0000161F _text$mn        ends
.text$mn:0000161F
.text$mn:00001620 ; ===========================================================================
.text$mn:00001620
.text$mn:00001620 ; Segment type: Pure code
.text$mn:00001620 ; Segment permissions: Read/Execute
.text$mn:00001620 _text$mn        segment para public 'CODE' use32
.text$mn:00001620                 assume cs:_text$mn
.text$mn:00001620                 ;org 1620h
.text$mn:00001620 ; COMDAT (pick any)
.text$mn:00001620                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001620
.text$mn:00001620 ; =============== S U B R O U T I N E =======================================
.text$mn:00001620
.text$mn:00001620 ; Attributes: bp-based frame
.text$mn:00001620
.text$mn:00001620 ; struct std::random_access_iterator_tag __cdecl std::_Iter_cat<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>> *>(class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>> * const &)
.text$mn:00001620                 public ??$_Iter_cat@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@@Z
.text$mn:00001620 ??$_Iter_cat@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@@Z proc near
.text$mn:00001620                                         ; CODE XREF: std::_Debug_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,wchar_t const *,uint)+Cp
.text$mn:00001620
.text$mn:00001620 var_1           = byte ptr -1
.text$mn:00001620 arg_0           = dword ptr  8
.text$mn:00001620
.text$mn:00001620                 push    ebp
.text$mn:00001621                 mov     ebp, esp
.text$mn:00001623                 push    ecx
.text$mn:00001624                 mov     eax, [ebp+arg_0]
.text$mn:00001627                 mov     cl, [ebp+var_1]
.text$mn:0000162A                 mov     [eax], cl
.text$mn:0000162C                 mov     eax, [ebp+arg_0]
.text$mn:0000162F                 mov     esp, ebp
.text$mn:00001631                 pop     ebp
.text$mn:00001632                 retn
.text$mn:00001632 ??$_Iter_cat@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@@Z endp
.text$mn:00001632
.text$mn:00001632 ; ---------------------------------------------------------------------------
.text$mn:00001633                 align 4
.text$mn:00001633 _text$mn        ends
.text$mn:00001633
.text$mn:00001634 ; ===========================================================================
.text$mn:00001634
.text$mn:00001634 ; Segment type: Pure code
.text$mn:00001634 ; Segment permissions: Read/Execute
.text$mn:00001634 _text$mn        segment para public 'CODE' use32
.text$mn:00001634                 assume cs:_text$mn
.text$mn:00001634                 ;org 1634h
.text$mn:00001634 ; COMDAT (pick any)
.text$mn:00001634                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001634
.text$mn:00001634 ; =============== S U B R O U T I N E =======================================
.text$mn:00001634
.text$mn:00001634 ; Attributes: bp-based frame
.text$mn:00001634
.text$mn:00001634 ; int __cdecl std::_Move<ScintillaEditView * *,ScintillaEditView * *>(void *Src, int, void *Dst)
.text$mn:00001634                 public ??$_Move@PAPAVScintillaEditView@@PAPAV1@@std@@YAPAPAVScintillaEditView@@PAPAV1@00@Z
.text$mn:00001634 ??$_Move@PAPAVScintillaEditView@@PAPAV1@@std@@YAPAPAVScintillaEditView@@PAPAV1@00@Z proc near
.text$mn:00001634                                         ; CODE XREF: std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::erase(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>)+82p
.text$mn:00001634
.text$mn:00001634 var_1           = byte ptr -1
.text$mn:00001634 Src             = dword ptr  8
.text$mn:00001634 arg_4           = dword ptr  0Ch
.text$mn:00001634 Dst             = dword ptr  10h
.text$mn:00001634
.text$mn:00001634                 push    ebp
.text$mn:00001635                 mov     ebp, esp
.text$mn:00001637                 push    ecx
.text$mn:00001638                 mov     eax, [ebp+Dst]
.text$mn:0000163B                 push    eax
.text$mn:0000163C                 mov     ecx, [ebp+Src]
.text$mn:0000163F                 push    ecx
.text$mn:00001640                 call    ??$_Ptr_cat@PAVScintillaEditView@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVScintillaEditView@@0@Z ; std::_Ptr_cat<ScintillaEditView *,ScintillaEditView *>(ScintillaEditView * *,ScintillaEditView * *)
.text$mn:00001645                 add     esp, 8
.text$mn:00001648                 mov     [ebp+var_1], al
.text$mn:0000164B                 movzx   edx, [ebp+var_1]
.text$mn:0000164F                 push    edx
.text$mn:00001650                 mov     eax, [ebp+Dst]
.text$mn:00001653                 push    eax             ; Dst
.text$mn:00001654                 mov     ecx, [ebp+arg_4]
.text$mn:00001657                 push    ecx             ; int
.text$mn:00001658                 mov     edx, [ebp+Src]
.text$mn:0000165B                 push    edx             ; Src
.text$mn:0000165C                 call    ??$_Move@PAPAVScintillaEditView@@PAPAV1@@std@@YAPAPAVScintillaEditView@@PAPAV1@00U_Scalar_ptr_iterator_tag@0@@Z ; std::_Move<ScintillaEditView * *,ScintillaEditView * *>(ScintillaEditView * *,ScintillaEditView * *,ScintillaEditView * *,std::_Scalar_ptr_iterator_tag)
.text$mn:00001661                 add     esp, 10h
.text$mn:00001664                 mov     esp, ebp
.text$mn:00001666                 pop     ebp
.text$mn:00001667                 retn
.text$mn:00001667 ??$_Move@PAPAVScintillaEditView@@PAPAV1@@std@@YAPAPAVScintillaEditView@@PAPAV1@00@Z endp
.text$mn:00001667
.text$mn:00001667 _text$mn        ends
.text$mn:00001667
.text$mn:00001668 ; ===========================================================================
.text$mn:00001668
.text$mn:00001668 ; Segment type: Pure code
.text$mn:00001668 ; Segment permissions: Read/Execute
.text$mn:00001668 _text$mn        segment para public 'CODE' use32
.text$mn:00001668                 assume cs:_text$mn
.text$mn:00001668                 ;org 1668h
.text$mn:00001668 ; COMDAT (pick any)
.text$mn:00001668                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001668
.text$mn:00001668 ; =============== S U B R O U T I N E =======================================
.text$mn:00001668
.text$mn:00001668 ; Attributes: bp-based frame
.text$mn:00001668
.text$mn:00001668 ; int __cdecl std::_Move<ScintillaEditView * *,ScintillaEditView * *>(void *Src, int, void *Dst)
.text$mn:00001668                 public ??$_Move@PAPAVScintillaEditView@@PAPAV1@@std@@YAPAPAVScintillaEditView@@PAPAV1@00U_Scalar_ptr_iterator_tag@0@@Z
.text$mn:00001668 ??$_Move@PAPAVScintillaEditView@@PAPAV1@@std@@YAPAPAVScintillaEditView@@PAPAV1@00U_Scalar_ptr_iterator_tag@0@@Z proc near
.text$mn:00001668                                         ; CODE XREF: std::_Move<ScintillaEditView * *,ScintillaEditView * *>(ScintillaEditView * *,ScintillaEditView * *,ScintillaEditView * *)+28p
.text$mn:00001668
.text$mn:00001668 var_4           = dword ptr -4
.text$mn:00001668 Src             = dword ptr  8
.text$mn:00001668 arg_4           = dword ptr  0Ch
.text$mn:00001668 Dst             = dword ptr  10h
.text$mn:00001668
.text$mn:00001668                 push    ebp
.text$mn:00001669                 mov     ebp, esp
.text$mn:0000166B                 push    ecx
.text$mn:0000166C                 mov     eax, [ebp+arg_4]
.text$mn:0000166F                 sub     eax, [ebp+Src]
.text$mn:00001672                 sar     eax, 2
.text$mn:00001675                 mov     [ebp+var_4], eax
.text$mn:00001678                 mov     ecx, [ebp+var_4]
.text$mn:0000167B                 shl     ecx, 2
.text$mn:0000167E                 push    ecx             ; Size
.text$mn:0000167F                 mov     edx, [ebp+Src]
.text$mn:00001682                 push    edx             ; Src
.text$mn:00001683                 mov     eax, [ebp+Dst]
.text$mn:00001686                 push    eax             ; Dst
.text$mn:00001687                 call    _memmove
.text$mn:0000168C                 add     esp, 0Ch
.text$mn:0000168F                 mov     ecx, [ebp+var_4]
.text$mn:00001692                 mov     edx, [ebp+Dst]
.text$mn:00001695                 lea     eax, [edx+ecx*4]
.text$mn:00001698                 mov     esp, ebp
.text$mn:0000169A                 pop     ebp
.text$mn:0000169B                 retn
.text$mn:0000169B ??$_Move@PAPAVScintillaEditView@@PAPAV1@@std@@YAPAPAVScintillaEditView@@PAPAV1@00U_Scalar_ptr_iterator_tag@0@@Z endp
.text$mn:0000169B
.text$mn:0000169B _text$mn        ends
.text$mn:0000169B
.text$mn:0000169C ; ===========================================================================
.text$mn:0000169C
.text$mn:0000169C ; Segment type: Pure code
.text$mn:0000169C ; Segment permissions: Read/Execute
.text$mn:0000169C _text$mn        segment para public 'CODE' use32
.text$mn:0000169C                 assume cs:_text$mn
.text$mn:0000169C                 ;org 169Ch
.text$mn:0000169C ; COMDAT (pick any)
.text$mn:0000169C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000169C
.text$mn:0000169C ; =============== S U B R O U T I N E =======================================
.text$mn:0000169C
.text$mn:0000169C ; Attributes: bp-based frame
.text$mn:0000169C
.text$mn:0000169C ; struct std::_Scalar_ptr_iterator_tag __cdecl std::_Ptr_cat<class ScintillaEditView *, class ScintillaEditView *>(class ScintillaEditView * *, class ScintillaEditView * *)
.text$mn:0000169C                 public ??$_Ptr_cat@PAVScintillaEditView@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVScintillaEditView@@0@Z
.text$mn:0000169C ??$_Ptr_cat@PAVScintillaEditView@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVScintillaEditView@@0@Z proc near
.text$mn:0000169C                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<ScintillaEditView *>>>(ScintillaEditView * *,ScintillaEditView * *,std::_Wrap_alloc<std::allocator<ScintillaEditView *>> &)+Cp
.text$mn:0000169C                                         ; std::_Move<ScintillaEditView * *,ScintillaEditView * *>(ScintillaEditView * *,ScintillaEditView * *,ScintillaEditView * *)+Cp ...
.text$mn:0000169C
.text$mn:0000169C var_1           = byte ptr -1
.text$mn:0000169C
.text$mn:0000169C                 push    ebp
.text$mn:0000169D                 mov     ebp, esp
.text$mn:0000169F                 push    ecx
.text$mn:000016A0                 mov     al, [ebp+var_1]
.text$mn:000016A3                 mov     esp, ebp
.text$mn:000016A5                 pop     ebp
.text$mn:000016A6                 retn
.text$mn:000016A6 ??$_Ptr_cat@PAVScintillaEditView@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVScintillaEditView@@0@Z endp
.text$mn:000016A6
.text$mn:000016A6 ; ---------------------------------------------------------------------------
.text$mn:000016A7                 align 4
.text$mn:000016A7 _text$mn        ends
.text$mn:000016A7
.text$mn:000016A8 ; ===========================================================================
.text$mn:000016A8
.text$mn:000016A8 ; Segment type: Pure code
.text$mn:000016A8 ; Segment permissions: Read/Execute
.text$mn:000016A8 _text$mn        segment para public 'CODE' use32
.text$mn:000016A8                 assume cs:_text$mn
.text$mn:000016A8                 ;org 16A8h
.text$mn:000016A8 ; COMDAT (pick any)
.text$mn:000016A8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000016A8
.text$mn:000016A8 ; =============== S U B R O U T I N E =======================================
.text$mn:000016A8
.text$mn:000016A8 ; Attributes: bp-based frame
.text$mn:000016A8
.text$mn:000016A8 ; struct std::_Nonscalar_ptr_iterator_tag __cdecl std::_Ptr_cat<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<int const, struct Style>>>>, class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<int const, struct Style>>>>>(class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<int const, struct Style>>>> *, class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<int const, struct Style>>>> *)
.text$mn:000016A8                 public ??$_Ptr_cat@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@0@0@Z
.text$mn:000016A8 ??$_Ptr_cat@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@0@0@Z proc near
.text$mn:000016A8                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>>>>>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>> *,std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>>>> &)+Cp
.text$mn:000016A8
.text$mn:000016A8 var_1           = byte ptr -1
.text$mn:000016A8
.text$mn:000016A8                 push    ebp
.text$mn:000016A9                 mov     ebp, esp
.text$mn:000016AB                 push    ecx
.text$mn:000016AC                 mov     al, [ebp+var_1]
.text$mn:000016AF                 mov     esp, ebp
.text$mn:000016B1                 pop     ebp
.text$mn:000016B2                 retn
.text$mn:000016B2 ??$_Ptr_cat@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@0@0@Z endp
.text$mn:000016B2
.text$mn:000016B2 ; ---------------------------------------------------------------------------
.text$mn:000016B3                 align 4
.text$mn:000016B3 _text$mn        ends
.text$mn:000016B3
.text$mn:000016B4 ; ===========================================================================
.text$mn:000016B4
.text$mn:000016B4 ; Segment type: Pure code
.text$mn:000016B4 ; Segment permissions: Read/Execute
.text$mn:000016B4 _text$mn        segment para public 'CODE' use32
.text$mn:000016B4                 assume cs:_text$mn
.text$mn:000016B4                 ;org 16B4h
.text$mn:000016B4 ; COMDAT (pick any)
.text$mn:000016B4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000016B4
.text$mn:000016B4 ; =============== S U B R O U T I N E =======================================
.text$mn:000016B4
.text$mn:000016B4 ; Attributes: bp-based frame
.text$mn:000016B4
.text$mn:000016B4 ; struct std::_Nonscalar_ptr_iterator_tag __cdecl std::_Ptr_cat<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>, class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>>(class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>> *, class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_s
.text$mn:000016B4                 public ??$_Ptr_cat@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@0@Z
.text$mn:000016B4 ??$_Ptr_cat@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@0@Z proc near
.text$mn:000016B4                                         ; CODE XREF: std::_Copy_backward<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::e
.text$mn:000016B4                                         ; std::_Destroy_range<std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>> &)+Cp ...
.text$mn:000016B4
.text$mn:000016B4 var_1           = byte ptr -1
.text$mn:000016B4
.text$mn:000016B4                 push    ebp
.text$mn:000016B5                 mov     ebp, esp
.text$mn:000016B7                 push    ecx
.text$mn:000016B8                 mov     al, [ebp+var_1]
.text$mn:000016BB                 mov     esp, ebp
.text$mn:000016BD                 pop     ebp
.text$mn:000016BE                 retn
.text$mn:000016BE ??$_Ptr_cat@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@0@Z endp
.text$mn:000016BE
.text$mn:000016BE ; ---------------------------------------------------------------------------
.text$mn:000016BF                 align 10h
.text$mn:000016BF _text$mn        ends
.text$mn:000016BF
.text$mn:000016C0 ; ===========================================================================
.text$mn:000016C0
.text$mn:000016C0 ; Segment type: Pure code
.text$mn:000016C0 ; Segment permissions: Read/Execute
.text$mn:000016C0 _text$mn        segment para public 'CODE' use32
.text$mn:000016C0                 assume cs:_text$mn
.text$mn:000016C0                 ;org 16C0h
.text$mn:000016C0 ; COMDAT (pick any)
.text$mn:000016C0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000016C0
.text$mn:000016C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000016C0
.text$mn:000016C0 ; Attributes: bp-based frame
.text$mn:000016C0
.text$mn:000016C0 ; class ScintillaEditView * * & __cdecl std::_Rechecked<class ScintillaEditView * *, class ScintillaEditView * *>(class ScintillaEditView * * &, class ScintillaEditView * *)
.text$mn:000016C0                 public ??$_Rechecked@PAPAVScintillaEditView@@PAPAV1@@std@@YAAAPAPAVScintillaEditView@@AAPAPAV1@PAPAV1@@Z
.text$mn:000016C0 ??$_Rechecked@PAPAVScintillaEditView@@PAPAV1@@std@@YAAAPAPAVScintillaEditView@@AAPAPAV1@PAPAV1@@Z proc near
.text$mn:000016C0                                         ; CODE XREF: std::_Uninitialized_move<ScintillaEditView * *,ScintillaEditView * *,std::_Wrap_alloc<std::allocator<ScintillaEditView *>>>(ScintillaEditView * *,ScintillaEditView * *,ScintillaEditView * *,std::_Wrap_alloc<std::allocator<ScintillaEditView *>> &)+3Bp
.text$mn:000016C0
.text$mn:000016C0 arg_0           = dword ptr  8
.text$mn:000016C0 arg_4           = dword ptr  0Ch
.text$mn:000016C0
.text$mn:000016C0                 push    ebp
.text$mn:000016C1                 mov     ebp, esp
.text$mn:000016C3                 mov     eax, [ebp+arg_0]
.text$mn:000016C6                 mov     ecx, [ebp+arg_4]
.text$mn:000016C9                 mov     [eax], ecx
.text$mn:000016CB                 mov     eax, [ebp+arg_0]
.text$mn:000016CE                 pop     ebp
.text$mn:000016CF                 retn
.text$mn:000016CF ??$_Rechecked@PAPAVScintillaEditView@@PAPAV1@@std@@YAAAPAPAVScintillaEditView@@AAPAPAV1@PAPAV1@@Z endp
.text$mn:000016CF
.text$mn:000016CF _text$mn        ends
.text$mn:000016CF
.text$mn:000016D0 ; ===========================================================================
.text$mn:000016D0
.text$mn:000016D0 ; Segment type: Pure code
.text$mn:000016D0 ; Segment permissions: Read/Execute
.text$mn:000016D0 _text$mn        segment para public 'CODE' use32
.text$mn:000016D0                 assume cs:_text$mn
.text$mn:000016D0                 ;org 16D0h
.text$mn:000016D0 ; COMDAT (pick any)
.text$mn:000016D0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000016D0
.text$mn:000016D0 ; =============== S U B R O U T I N E =======================================
.text$mn:000016D0
.text$mn:000016D0 ; Attributes: bp-based frame
.text$mn:000016D0
.text$mn:000016D0 ; class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>> * & __cdecl std::_Rechecked<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>> *, class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>> *>(class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<clas
.text$mn:000016D0                 public ??$_Rechecked@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@PAV12@@std@@YAAAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@AAPAV10@PAV10@@Z
.text$mn:000016D0 ??$_Rechecked@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@PAV12@@std@@YAAAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@AAPAV10@PAV10@@Z proc near
.text$mn:000016D0                                         ; CODE XREF: std::_Uninitialized_move<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * c
.text$mn:000016D0
.text$mn:000016D0 arg_0           = dword ptr  8
.text$mn:000016D0 arg_4           = dword ptr  0Ch
.text$mn:000016D0
.text$mn:000016D0                 push    ebp
.text$mn:000016D1                 mov     ebp, esp
.text$mn:000016D3                 mov     eax, [ebp+arg_0]
.text$mn:000016D6                 mov     ecx, [ebp+arg_4]
.text$mn:000016D9                 mov     [eax], ecx
.text$mn:000016DB                 mov     eax, [ebp+arg_0]
.text$mn:000016DE                 pop     ebp
.text$mn:000016DF                 retn
.text$mn:000016DF ??$_Rechecked@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@PAV12@@std@@YAAAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@AAPAV10@PAV10@@Z endp
.text$mn:000016DF
.text$mn:000016DF _text$mn        ends
.text$mn:000016DF
.text$mn:000016E0 ; ===========================================================================
.text$mn:000016E0
.text$mn:000016E0 ; Segment type: Pure code
.text$mn:000016E0 ; Segment permissions: Read/Execute
.text$mn:000016E0 _text$mn        segment para public 'CODE' use32
.text$mn:000016E0                 assume cs:_text$mn
.text$mn:000016E0                 ;org 16E0h
.text$mn:000016E0 ; COMDAT (pick any)
.text$mn:000016E0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000016E0
.text$mn:000016E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000016E0
.text$mn:000016E0 ; Attributes: bp-based frame
.text$mn:000016E0
.text$mn:000016E0 ; protected: class ScintillaEditView * * __thiscall std::vector<class ScintillaEditView *, class std::allocator<class ScintillaEditView *>>::_Umove<class ScintillaEditView * *>(class ScintillaEditView * *, class ScintillaEditView * *, class ScintillaEditView * *)
.text$mn:000016E0                 public ??$_Umove@PAPAVScintillaEditView@@@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@IAEPAPAVScintillaEditView@@PAPAV2@00@Z
.text$mn:000016E0 ??$_Umove@PAPAVScintillaEditView@@@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@IAEPAPAVScintillaEditView@@PAPAV2@00@Z proc near
.text$mn:000016E0                                         ; CODE XREF: std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::_Reallocate(uint)+65p
.text$mn:000016E0
.text$mn:000016E0 var_8           = dword ptr -8
.text$mn:000016E0 var_1           = byte ptr -1
.text$mn:000016E0 arg_0           = dword ptr  8
.text$mn:000016E0 arg_4           = dword ptr  0Ch
.text$mn:000016E0 arg_8           = dword ptr  10h
.text$mn:000016E0
.text$mn:000016E0                 push    ebp
.text$mn:000016E1                 mov     ebp, esp
.text$mn:000016E3                 sub     esp, 8
.text$mn:000016E6                 mov     [ebp+var_8], ecx
.text$mn:000016E9                 lea     eax, [ebp+var_1]
.text$mn:000016EC                 push    eax
.text$mn:000016ED                 mov     ecx, [ebp+var_8]
.text$mn:000016F0                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVScintillaEditView@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<ScintillaEditView *,std::allocator<ScintillaEditView *>>>::_Getal(void)
.text$mn:000016F5                 lea     ecx, [ebp+var_1]
.text$mn:000016F8                 push    ecx
.text$mn:000016F9                 mov     edx, [ebp+arg_8]
.text$mn:000016FC                 push    edx
.text$mn:000016FD                 mov     eax, [ebp+arg_4]
.text$mn:00001700                 push    eax
.text$mn:00001701                 mov     ecx, [ebp+arg_0]
.text$mn:00001704                 push    ecx
.text$mn:00001705                 call    ??$_Uninitialized_move@PAPAVScintillaEditView@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVScintillaEditView@@@std@@@std@@@std@@YAPAPAVScintillaEditView@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVScintillaEditView@@@std@@@0@@Z ; std::_Uninitialized_move<ScintillaEditView * *,ScintillaEditView * *,std::_Wrap_alloc<std::allocator<ScintillaEditView *>>>(ScintillaEditView * *,ScintillaEditView * *,ScintillaEditView * *,std::_Wrap_alloc<std::allocator<ScintillaEditView *>> &)
.text$mn:0000170A                 add     esp, 10h
.text$mn:0000170D                 mov     esp, ebp
.text$mn:0000170F                 pop     ebp
.text$mn:00001710                 retn    0Ch
.text$mn:00001710 ??$_Umove@PAPAVScintillaEditView@@@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@IAEPAPAVScintillaEditView@@PAPAV2@00@Z endp
.text$mn:00001710
.text$mn:00001710 ; ---------------------------------------------------------------------------
.text$mn:00001713                 align 4
.text$mn:00001713 _text$mn        ends
.text$mn:00001713
.text$mn:00001714 ; ===========================================================================
.text$mn:00001714
.text$mn:00001714 ; Segment type: Pure code
.text$mn:00001714 ; Segment permissions: Read/Execute
.text$mn:00001714 _text$mn        segment para public 'CODE' use32
.text$mn:00001714                 assume cs:_text$mn
.text$mn:00001714                 ;org 1714h
.text$mn:00001714 ; COMDAT (pick any)
.text$mn:00001714                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001714
.text$mn:00001714 ; =============== S U B R O U T I N E =======================================
.text$mn:00001714
.text$mn:00001714 ; Attributes: bp-based frame
.text$mn:00001714
.text$mn:00001714 ; protected: class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>> * __thiscall std::vector<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>, struct std::_Wrap_alloc<class std::allocator<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>>>>::_Umove<class std::_List_unchecked_iterator<class std::_Li
.text$mn:00001714                 public ??$_Umove@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAEPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@PAV21@00@Z
.text$mn:00001714 ??$_Umove@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAEPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@PAV21@00@Z proc near
.text$mn:00001714                                         ; CODE XREF: ?_Insert_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CB
.text$mn:00001714                                         ; ?_Insert_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@s ...
.text$mn:00001714
.text$mn:00001714 var_8           = dword ptr -8
.text$mn:00001714 var_1           = byte ptr -1
.text$mn:00001714 arg_0           = dword ptr  8
.text$mn:00001714 arg_4           = dword ptr  0Ch
.text$mn:00001714 arg_8           = dword ptr  10h
.text$mn:00001714
.text$mn:00001714                 push    ebp
.text$mn:00001715                 mov     ebp, esp
.text$mn:00001717                 sub     esp, 8
.text$mn:0000171A                 mov     [ebp+var_8], ecx
.text$mn:0000171D                 lea     eax, [ebp+var_1]
.text$mn:00001720                 push    eax
.text$mn:00001721                 mov     ecx, [ebp+var_8]
.text$mn:00001724                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>>::_Getal(void)
.text$mn:00001729                 lea     ecx, [ebp+var_1]
.text$mn:0000172C                 push    ecx
.text$mn:0000172D                 mov     edx, [ebp+arg_8]
.text$mn:00001730                 push    edx
.text$mn:00001731                 mov     eax, [ebp+arg_4]
.text$mn:00001734                 push    eax
.text$mn:00001735                 mov     ecx, [ebp+arg_0]
.text$mn:00001738                 push    ecx
.text$mn:00001739                 call    ??$_Uninitialized_move@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@PAV12@U?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@PAV10@00AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std ; std::_Uninitialized_move<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>> &)
.text$mn:0000173E                 add     esp, 10h
.text$mn:00001741                 mov     esp, ebp
.text$mn:00001743                 pop     ebp
.text$mn:00001744                 retn    0Ch
.text$mn:00001744 ??$_Umove@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAEPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@PAV21@00@Z endp
.text$mn:00001744
.text$mn:00001744 ; ---------------------------------------------------------------------------
.text$mn:00001747                 align 4
.text$mn:00001747 _text$mn        ends
.text$mn:00001747
.text$mn:00001748 ; ===========================================================================
.text$mn:00001748
.text$mn:00001748 ; Segment type: Pure code
.text$mn:00001748 ; Segment permissions: Read/Execute
.text$mn:00001748 _text$mn        segment para public 'CODE' use32
.text$mn:00001748                 assume cs:_text$mn
.text$mn:00001748                 ;org 1748h
.text$mn:00001748 ; COMDAT (pick any)
.text$mn:00001748                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001748
.text$mn:00001748 ; =============== S U B R O U T I N E =======================================
.text$mn:00001748
.text$mn:00001748 ; Attributes: bp-based frame
.text$mn:00001748
.text$mn:00001748 ; class ScintillaEditView * * __cdecl std::_Unchecked<class ScintillaEditView * *>(class ScintillaEditView * *)
.text$mn:00001748                 public ??$_Unchecked@PAPAVScintillaEditView@@@std@@YAPAPAVScintillaEditView@@PAPAV1@@Z
.text$mn:00001748 ??$_Unchecked@PAPAVScintillaEditView@@@std@@YAPAPAVScintillaEditView@@PAPAV1@@Z proc near
.text$mn:00001748                                         ; CODE XREF: std::_Uninitialized_move<ScintillaEditView * *,ScintillaEditView * *,std::_Wrap_alloc<std::allocator<ScintillaEditView *>>>(ScintillaEditView * *,ScintillaEditView * *,ScintillaEditView * *,std::_Wrap_alloc<std::allocator<ScintillaEditView *>> &)+Bp
.text$mn:00001748                                         ; std::_Uninitialized_move<ScintillaEditView * *,ScintillaEditView * *,std::_Wrap_alloc<std::allocator<ScintillaEditView *>>>(ScintillaEditView * *,ScintillaEditView * *,ScintillaEditView * *,std::_Wrap_alloc<std::allocator<ScintillaEditView *>> &)+18p ...
.text$mn:00001748
.text$mn:00001748 arg_0           = dword ptr  8
.text$mn:00001748
.text$mn:00001748                 push    ebp
.text$mn:00001749                 mov     ebp, esp
.text$mn:0000174B                 mov     eax, [ebp+arg_0]
.text$mn:0000174E                 pop     ebp
.text$mn:0000174F                 retn
.text$mn:0000174F ??$_Unchecked@PAPAVScintillaEditView@@@std@@YAPAPAVScintillaEditView@@PAPAV1@@Z endp
.text$mn:0000174F
.text$mn:0000174F _text$mn        ends
.text$mn:0000174F
.text$mn:00001750 ; ===========================================================================
.text$mn:00001750
.text$mn:00001750 ; Segment type: Pure code
.text$mn:00001750 ; Segment permissions: Read/Execute
.text$mn:00001750 _text$mn        segment para public 'CODE' use32
.text$mn:00001750                 assume cs:_text$mn
.text$mn:00001750                 ;org 1750h
.text$mn:00001750 ; COMDAT (pick any)
.text$mn:00001750                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001750
.text$mn:00001750 ; =============== S U B R O U T I N E =======================================
.text$mn:00001750
.text$mn:00001750 ; Attributes: bp-based frame
.text$mn:00001750
.text$mn:00001750 ; class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>> * __cdecl std::_Unchecked<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>> *>(class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>> *)
.text$mn:00001750                 public ??$_Unchecked@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@PAV10@@Z
.text$mn:00001750 ??$_Unchecked@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@PAV10@@Z proc near
.text$mn:00001750                                         ; CODE XREF: std::_Uninitialized_move<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * c
.text$mn:00001750                                         ; std::_Uninitialized_move<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::u ...
.text$mn:00001750
.text$mn:00001750 arg_0           = dword ptr  8
.text$mn:00001750
.text$mn:00001750                 push    ebp
.text$mn:00001751                 mov     ebp, esp
.text$mn:00001753                 mov     eax, [ebp+arg_0]
.text$mn:00001756                 pop     ebp
.text$mn:00001757                 retn
.text$mn:00001757 ??$_Unchecked@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@PAV10@@Z endp
.text$mn:00001757
.text$mn:00001757 _text$mn        ends
.text$mn:00001757
.text$mn:00001758 ; ===========================================================================
.text$mn:00001758
.text$mn:00001758 ; Segment type: Pure code
.text$mn:00001758 ; Segment permissions: Read/Execute
.text$mn:00001758 _text$mn        segment para public 'CODE' use32
.text$mn:00001758                 assume cs:_text$mn
.text$mn:00001758                 ;org 1758h
.text$mn:00001758 ; COMDAT (pick any)
.text$mn:00001758                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001758
.text$mn:00001758 ; =============== S U B R O U T I N E =======================================
.text$mn:00001758
.text$mn:00001758 ; Attributes: bp-based frame
.text$mn:00001758
.text$mn:00001758 ; int __cdecl std::_Uninit_fill_n<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,unsigned int,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>(void *, int, int, int)
.text$mn:00001758                 public ??$_Uninit_fill_n@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@IV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@V12@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@IPBV10@AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@0@0U_Nons
.text$mn:00001758 ??$_Uninit_fill_n@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@IV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@V12@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@IPBV10@AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_ proc near
.text$mn:00001758                                         ; CODE XREF: std::_Uninitialized_fill_n<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,uint,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,uint,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<
.text$mn:00001758
.text$mn:00001758 var_14          = dword ptr -14h
.text$mn:00001758 var_10          = dword ptr -10h
.text$mn:00001758 var_C           = dword ptr -0Ch
.text$mn:00001758 var_4           = dword ptr -4
.text$mn:00001758 arg_0           = dword ptr  8
.text$mn:00001758 arg_4           = dword ptr  0Ch
.text$mn:00001758 arg_8           = dword ptr  10h
.text$mn:00001758 arg_C           = dword ptr  14h
.text$mn:00001758
.text$mn:00001758 ; FUNCTION CHUNK AT .text$mn:000017ED SIZE 00000009 BYTES
.text$mn:00001758 ; FUNCTION CHUNK AT .text$mn:000017FD SIZE 00000012 BYTES
.text$mn:00001758
.text$mn:00001758                 push    ebp
.text$mn:00001759                 mov     ebp, esp
.text$mn:0000175B                 push    0FFFFFFFFh
.text$mn:0000175D                 push    offset __ehhandler$??$_Uninit_fill_n@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@IV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@V12@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@IPBV10@AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std
.text$mn:00001762                 mov     eax, large fs:0
.text$mn:00001768                 push    eax
.text$mn:00001769                 push    ecx
.text$mn:0000176A                 push    ecx
.text$mn:0000176B                 push    ebx
.text$mn:0000176C                 push    esi
.text$mn:0000176D                 push    edi
.text$mn:0000176E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001773                 xor     eax, ebp
.text$mn:00001775                 push    eax
.text$mn:00001776                 lea     eax, [ebp+var_C]
.text$mn:00001779                 mov     large fs:0, eax
.text$mn:0000177F                 mov     [ebp+var_10], esp
.text$mn:00001782                 mov     eax, [ebp+arg_0]
.text$mn:00001785                 mov     [ebp+var_14], eax
.text$mn:00001788                 mov     [ebp+var_4], 0
.text$mn:0000178F                 jmp     short loc_17A3
.text$mn:00001791 ; ---------------------------------------------------------------------------
.text$mn:00001791
.text$mn:00001791 loc_1791:                               ; CODE XREF: ??$_Uninit_fill_n@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@IV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@V12@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@IPBV10@AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@0@0U_N
.text$mn:00001791                 mov     ecx, [ebp+arg_4]
.text$mn:00001794                 sub     ecx, 1
.text$mn:00001797                 mov     [ebp+arg_4], ecx
.text$mn:0000179A                 mov     edx, [ebp+arg_0]
.text$mn:0000179D                 add     edx, 4
.text$mn:000017A0                 mov     [ebp+arg_0], edx
.text$mn:000017A3
.text$mn:000017A3 loc_17A3:                               ; CODE XREF: ??$_Uninit_fill_n@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@IV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@V12@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@IPBV10@AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@0@0U_N
.text$mn:000017A3                 cmp     [ebp+arg_4], 0
.text$mn:000017A7                 jbe     short loc_17BB
.text$mn:000017A9                 mov     eax, [ebp+arg_8]
.text$mn:000017AC                 push    eax             ; int
.text$mn:000017AD                 mov     ecx, [ebp+arg_0]
.text$mn:000017B0                 push    ecx             ; void *
.text$mn:000017B1                 mov     ecx, [ebp+arg_C]
.text$mn:000017B4                 call    ??$construct@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@ABV12@@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@ABV21@@Z ; std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::construct<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const &>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const &)
.text$mn:000017B9                 jmp     short loc_1791
.text$mn:000017BB ; ---------------------------------------------------------------------------
.text$mn:000017BB
.text$mn:000017BB loc_17BB:                               ; CODE XREF: ??$_Uninit_fill_n@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@IV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@V12@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@IPBV10@AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@0@0U_N
.text$mn:000017BB                 jmp     short loc_17ED
.text$mn:000017BB ??$_Uninit_fill_n@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@IV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@V12@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@IPBV10@AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@0@0U_Nonscalar_p
.text$mn:000017BB
.text$mn:000017BD
.text$mn:000017BD ; =============== S U B R O U T I N E =======================================
.text$mn:000017BD
.text$mn:000017BD ; Attributes: noreturn
.text$mn:000017BD
.text$mn:000017BD __catch$??$_Uninit_fill_n@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@IV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@V12@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@IPBV10@AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@0@0U_Nonscalar_ptr_i proc near
.text$mn:000017BD                                         ; DATA XREF: .xdata$x:0000ACA4o
.text$mn:000017BD                 jmp     short loc_17C8
.text$mn:000017BF ; ---------------------------------------------------------------------------
.text$mn:000017BF
.text$mn:000017BF loc_17BF:                               ; CODE XREF: __catch$??$_Uninit_fill_n@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@IV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@V12@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@IPBV10@AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@
.text$mn:000017BF                 mov     edx, [ebp-14h]
.text$mn:000017C2                 add     edx, 4
.text$mn:000017C5                 mov     [ebp-14h], edx
.text$mn:000017C8
.text$mn:000017C8 loc_17C8:                               ; CODE XREF: __catch$??$_Uninit_fill_n@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@IV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@V12@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@IPBV10@AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@
.text$mn:000017C8                 mov     eax, [ebp-14h]
.text$mn:000017CB                 cmp     eax, [ebp+8]
.text$mn:000017CE                 jz      short loc_17DE
.text$mn:000017D0                 mov     ecx, [ebp-14h]
.text$mn:000017D3                 push    ecx
.text$mn:000017D4                 mov     ecx, [ebp+14h]
.text$mn:000017D7                 call    ??$destroy@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@@Z ; std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::destroy<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *)
.text$mn:000017DC                 jmp     short loc_17BF
.text$mn:000017DE ; ---------------------------------------------------------------------------
.text$mn:000017DE
.text$mn:000017DE loc_17DE:                               ; CODE XREF: __catch$??$_Uninit_fill_n@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@IV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@V12@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@IPBV10@AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@
.text$mn:000017DE                 push    0
.text$mn:000017E0                 push    0
.text$mn:000017E2                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:000017E2 __catch$??$_Uninit_fill_n@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@IV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@V12@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@IPBV10@AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@0@0U_Non
.text$mn:000017E2
.text$mn:000017E7 ; ---------------------------------------------------------------------------
.text$mn:000017E7                 mov     eax, offset $LN13
.text$mn:000017EC                 retn
.text$mn:000017ED ; ---------------------------------------------------------------------------
.text$mn:000017ED ; START OF FUNCTION CHUNK FOR ??$_Uninit_fill_n@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@IV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@V12@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@IPBV10@AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_
.text$mn:000017ED
.text$mn:000017ED loc_17ED:                               ; CODE XREF: ??$_Uninit_fill_n@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@IV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@V12@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@IPBV10@AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@0@0U_N
.text$mn:000017ED                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000017F4                 jmp     short loc_17FD
.text$mn:000017F4 ; END OF FUNCTION CHUNK FOR ??$_Uninit_fill_n@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@IV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@V12@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@IPBV10@AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_
.text$mn:000017F6
.text$mn:000017F6 ; =============== S U B R O U T I N E =======================================
.text$mn:000017F6
.text$mn:000017F6
.text$mn:000017F6 $LN13           proc near               ; DATA XREF: .text$mn:000017E7o
.text$mn:000017F6                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:000017F6 $LN13           endp ; sp-analysis failed
.text$mn:000017F6
.text$mn:000017FD ; START OF FUNCTION CHUNK FOR ??$_Uninit_fill_n@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@IV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@V12@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@IPBV10@AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_
.text$mn:000017FD
.text$mn:000017FD loc_17FD:                               ; CODE XREF: ??$_Uninit_fill_n@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@IV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@V12@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@IPBV10@AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@0@0U_N
.text$mn:000017FD                 mov     ecx, [ebp+var_C]
.text$mn:00001800                 mov     large fs:0, ecx
.text$mn:00001807                 pop     ecx
.text$mn:00001808                 pop     edi
.text$mn:00001809                 pop     esi
.text$mn:0000180A                 pop     ebx
.text$mn:0000180B                 mov     esp, ebp
.text$mn:0000180D                 pop     ebp
.text$mn:0000180E                 retn
.text$mn:0000180E ; END OF FUNCTION CHUNK FOR ??$_Uninit_fill_n@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@IV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@V12@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@IPBV10@AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_
.text$mn:0000180E ; ---------------------------------------------------------------------------
.text$mn:0000180F                 align 10h
.text$mn:0000180F _text$mn        ends
.text$mn:0000180F
.text$x:00001810 ; ===========================================================================
.text$x:00001810
.text$x:00001810 ; Segment type: Pure code
.text$x:00001810 ; Segment permissions: Read/Execute
.text$x:00001810 _text$x         segment para public 'CODE' use32
.text$x:00001810                 assume cs:_text$x
.text$x:00001810                 ;org 1810h
.text$x:00001810 ; COMDAT (pick associative to section at 1758)
.text$x:00001810                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00001810
.text$x:00001810 ; =============== S U B R O U T I N E =======================================
.text$x:00001810
.text$x:00001810
.text$x:00001810 __ehhandler$??$_Uninit_fill_n@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@IV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@V12@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@IPBV10@AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@0@0U_Nonscalar_p proc near
.text$x:00001810                                         ; DATA XREF: ??$_Uninit_fill_n@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@IV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@V12@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@IPBV10@AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@0@0U_N
.text$x:00001810
.text$x:00001810 arg_4           = dword ptr  8
.text$x:00001810
.text$x:00001810                 mov     edx, [esp+arg_4]
.text$x:00001814                 lea     eax, [edx+0Ch]
.text$x:00001817                 mov     ecx, [edx-18h]
.text$x:0000181A                 xor     ecx, eax
.text$x:0000181C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001821                 mov     eax, offset __ehfuncinfo$??$_Uninit_fill_n@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@IV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@V12@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@IPBV10@AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std
.text$x:00001826                 jmp     ___CxxFrameHandler3
.text$x:00001826 __ehhandler$??$_Uninit_fill_n@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@IV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@V12@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@IPBV10@AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@0@0U
.text$x:00001826
.text$x:00001826 ; ---------------------------------------------------------------------------
.text$x:0000182B                 align 4
.text$x:0000182B _text$x         ends
.text$x:0000182B
.text$mn:0000182C ; ===========================================================================
.text$mn:0000182C
.text$mn:0000182C ; Segment type: Pure code
.text$mn:0000182C ; Segment permissions: Read/Execute
.text$mn:0000182C _text$mn        segment para public 'CODE' use32
.text$mn:0000182C                 assume cs:_text$mn
.text$mn:0000182C                 ;org 182Ch
.text$mn:0000182C ; COMDAT (pick any)
.text$mn:0000182C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000182C
.text$mn:0000182C ; =============== S U B R O U T I N E =======================================
.text$mn:0000182C
.text$mn:0000182C ; Attributes: bp-based frame
.text$mn:0000182C
.text$mn:0000182C ; int __cdecl std::_Uninit_move<ScintillaEditView * *,ScintillaEditView * *,std::_Wrap_alloc<std::allocator<ScintillaEditView *>>>(void *Src, int, void *Dst, int)
.text$mn:0000182C                 public ??$_Uninit_move@PAPAVScintillaEditView@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVScintillaEditView@@@std@@@std@@@std@@YAPAPAVScintillaEditView@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVScintillaEditView@@@std@@@0@@Z
.text$mn:0000182C ??$_Uninit_move@PAPAVScintillaEditView@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVScintillaEditView@@@std@@@std@@@std@@YAPAPAVScintillaEditView@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVScintillaEditView@@@std@@@0@@Z proc near
.text$mn:0000182C                                         ; CODE XREF: std::_Uninitialized_move<ScintillaEditView * *,ScintillaEditView * *,std::_Wrap_alloc<std::allocator<ScintillaEditView *>>>(ScintillaEditView * *,ScintillaEditView * *,ScintillaEditView * *,std::_Wrap_alloc<std::allocator<ScintillaEditView *>> &)+2Ep
.text$mn:0000182C
.text$mn:0000182C var_1           = byte ptr -1
.text$mn:0000182C Src             = dword ptr  8
.text$mn:0000182C arg_4           = dword ptr  0Ch
.text$mn:0000182C Dst             = dword ptr  10h
.text$mn:0000182C arg_C           = dword ptr  14h
.text$mn:0000182C
.text$mn:0000182C                 push    ebp
.text$mn:0000182D                 mov     ebp, esp
.text$mn:0000182F                 push    ecx
.text$mn:00001830                 mov     eax, [ebp+Dst]
.text$mn:00001833                 push    eax
.text$mn:00001834                 mov     ecx, [ebp+Src]
.text$mn:00001837                 push    ecx
.text$mn:00001838                 call    ??$_Ptr_cat@PAVScintillaEditView@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVScintillaEditView@@0@Z ; std::_Ptr_cat<ScintillaEditView *,ScintillaEditView *>(ScintillaEditView * *,ScintillaEditView * *)
.text$mn:0000183D                 add     esp, 8
.text$mn:00001840                 mov     [ebp+var_1], al
.text$mn:00001843                 movzx   edx, [ebp+var_1]
.text$mn:00001847                 push    edx
.text$mn:00001848                 mov     eax, [ebp+Src]
.text$mn:0000184B                 push    eax
.text$mn:0000184C                 call    ??$_Val_type@PAPAVScintillaEditView@@@std@@YAPAPAVScintillaEditView@@PAPAV1@@Z ; std::_Val_type<ScintillaEditView * *>(ScintillaEditView * *)
.text$mn:00001851                 add     esp, 4
.text$mn:00001854                 push    eax
.text$mn:00001855                 mov     ecx, [ebp+arg_C]
.text$mn:00001858                 push    ecx
.text$mn:00001859                 mov     edx, [ebp+Dst]
.text$mn:0000185C                 push    edx             ; Dst
.text$mn:0000185D                 mov     eax, [ebp+arg_4]
.text$mn:00001860                 push    eax             ; int
.text$mn:00001861                 mov     ecx, [ebp+Src]
.text$mn:00001864                 push    ecx             ; Src
.text$mn:00001865                 call    ??$_Uninit_move@PAVScintillaEditView@@PAV1@PAV1@@std@@YAPAPAVScintillaEditView@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVScintillaEditView@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<ScintillaEditView *,ScintillaEditView *,ScintillaEditView *>(ScintillaEditView * *,ScintillaEditView * *,ScintillaEditView * *,std::_Wrap_alloc<std::allocator<ScintillaEditView *>> &,ScintillaEditView * *,std::_Scalar_ptr_iterator_tag)
.text$mn:0000186A                 add     esp, 18h
.text$mn:0000186D                 mov     esp, ebp
.text$mn:0000186F                 pop     ebp
.text$mn:00001870                 retn
.text$mn:00001870 ??$_Uninit_move@PAPAVScintillaEditView@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVScintillaEditView@@@std@@@std@@@std@@YAPAPAVScintillaEditView@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVScintillaEditView@@@std@@@0@@Z endp
.text$mn:00001870
.text$mn:00001870 ; ---------------------------------------------------------------------------
.text$mn:00001871                 align 4
.text$mn:00001871 _text$mn        ends
.text$mn:00001871
.text$mn:00001874 ; ===========================================================================
.text$mn:00001874
.text$mn:00001874 ; Segment type: Pure code
.text$mn:00001874 ; Segment permissions: Read/Execute
.text$mn:00001874 _text$mn        segment para public 'CODE' use32
.text$mn:00001874                 assume cs:_text$mn
.text$mn:00001874                 ;org 1874h
.text$mn:00001874 ; COMDAT (pick any)
.text$mn:00001874                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001874
.text$mn:00001874 ; =============== S U B R O U T I N E =======================================
.text$mn:00001874
.text$mn:00001874 ; Attributes: bp-based frame
.text$mn:00001874
.text$mn:00001874 ; int __cdecl std::_Uninit_move<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>>(int, int, void *, int)
.text$mn:00001874                 public ??$_Uninit_move@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@PAV12@U?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@PAV10@00AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@
.text$mn:00001874 ??$_Uninit_move@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@PAV12@U?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@PAV10@00AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@0@@Z proc near
.text$mn:00001874                                         ; CODE XREF: std::_Uninitialized_move<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * c
.text$mn:00001874
.text$mn:00001874 var_1           = byte ptr -1
.text$mn:00001874 arg_0           = dword ptr  8
.text$mn:00001874 arg_4           = dword ptr  0Ch
.text$mn:00001874 arg_8           = dword ptr  10h
.text$mn:00001874 arg_C           = dword ptr  14h
.text$mn:00001874
.text$mn:00001874                 push    ebp
.text$mn:00001875                 mov     ebp, esp
.text$mn:00001877                 push    ecx
.text$mn:00001878                 mov     eax, [ebp+arg_8]
.text$mn:0000187B                 push    eax
.text$mn:0000187C                 mov     ecx, [ebp+arg_0]
.text$mn:0000187F                 push    ecx
.text$mn:00001880                 call    ??$_Ptr_cat@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@0@Z ; std::_Ptr_cat<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *)
.text$mn:00001885                 add     esp, 8
.text$mn:00001888                 mov     [ebp+var_1], al
.text$mn:0000188B                 movzx   edx, [ebp+var_1]
.text$mn:0000188F                 push    edx
.text$mn:00001890                 mov     eax, [ebp+arg_0]
.text$mn:00001893                 push    eax
.text$mn:00001894                 call    ??$_Val_type@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@PAV10@@Z ; std::_Val_type<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *)
.text$mn:00001899                 add     esp, 4
.text$mn:0000189C                 push    eax
.text$mn:0000189D                 mov     ecx, [ebp+arg_C]
.text$mn:000018A0                 push    ecx             ; int
.text$mn:000018A1                 mov     edx, [ebp+arg_8]
.text$mn:000018A4                 push    edx             ; void *
.text$mn:000018A5                 mov     eax, [ebp+arg_4]
.text$mn:000018A8                 push    eax             ; int
.text$mn:000018A9                 mov     ecx, [ebp+arg_0]
.text$mn:000018AC                 push    ecx             ; int
.text$mn:000018AD                 call    ??$_Uninit_move@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@V12@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@PAV10@00AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@0@0
.text$mn:000018B2                 add     esp, 18h
.text$mn:000018B5                 mov     esp, ebp
.text$mn:000018B7                 pop     ebp
.text$mn:000018B8                 retn
.text$mn:000018B8 ??$_Uninit_move@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@PAV12@U?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@PAV10@00AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@
.text$mn:000018B8
.text$mn:000018B8 ; ---------------------------------------------------------------------------
.text$mn:000018B9                 align 4
.text$mn:000018B9 _text$mn        ends
.text$mn:000018B9
.text$mn:000018BC ; ===========================================================================
.text$mn:000018BC
.text$mn:000018BC ; Segment type: Pure code
.text$mn:000018BC ; Segment permissions: Read/Execute
.text$mn:000018BC _text$mn        segment para public 'CODE' use32
.text$mn:000018BC                 assume cs:_text$mn
.text$mn:000018BC                 ;org 18BCh
.text$mn:000018BC ; COMDAT (pick any)
.text$mn:000018BC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000018BC
.text$mn:000018BC ; =============== S U B R O U T I N E =======================================
.text$mn:000018BC
.text$mn:000018BC ; Attributes: bp-based frame
.text$mn:000018BC
.text$mn:000018BC ; int __cdecl std::_Uninit_move<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>(int, int, void *, int)
.text$mn:000018BC                 public ??$_Uninit_move@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@V12@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@PAV10@00AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@0@0U_Nonsc
.text$mn:000018BC ??$_Uninit_move@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@V12@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@PAV10@00AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_t proc near
.text$mn:000018BC                                         ; CODE XREF: std::_Uninit_move<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,st
.text$mn:000018BC
.text$mn:000018BC var_14          = dword ptr -14h
.text$mn:000018BC var_10          = dword ptr -10h
.text$mn:000018BC var_C           = dword ptr -0Ch
.text$mn:000018BC var_4           = dword ptr -4
.text$mn:000018BC arg_0           = dword ptr  8
.text$mn:000018BC arg_4           = dword ptr  0Ch
.text$mn:000018BC arg_8           = dword ptr  10h
.text$mn:000018BC arg_C           = dword ptr  14h
.text$mn:000018BC
.text$mn:000018BC ; FUNCTION CHUNK AT .text$mn:00001983 SIZE 00000009 BYTES
.text$mn:000018BC ; FUNCTION CHUNK AT .text$mn:00001993 SIZE 00000015 BYTES
.text$mn:000018BC
.text$mn:000018BC                 push    ebp
.text$mn:000018BD                 mov     ebp, esp
.text$mn:000018BF                 push    0FFFFFFFFh
.text$mn:000018C1                 push    offset __ehhandler$??$_Uninit_move@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@V12@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@PAV10@00AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@
.text$mn:000018C6                 mov     eax, large fs:0
.text$mn:000018CC                 push    eax
.text$mn:000018CD                 push    ecx
.text$mn:000018CE                 push    ecx
.text$mn:000018CF                 push    ebx
.text$mn:000018D0                 push    esi
.text$mn:000018D1                 push    edi
.text$mn:000018D2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000018D7                 xor     eax, ebp
.text$mn:000018D9                 push    eax
.text$mn:000018DA                 lea     eax, [ebp+var_C]
.text$mn:000018DD                 mov     large fs:0, eax
.text$mn:000018E3                 mov     [ebp+var_10], esp
.text$mn:000018E6                 push    1B6h            ; unsigned int
.text$mn:000018EB                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000018F0                 mov     eax, [ebp+arg_4]
.text$mn:000018F3                 push    eax             ; int
.text$mn:000018F4                 mov     ecx, [ebp+arg_0]
.text$mn:000018F7                 push    ecx             ; int
.text$mn:000018F8                 call    ??$_Debug_range@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@0PB_WI@Z ; std::_Debug_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,wchar_t const *,uint)
.text$mn:000018FD                 add     esp, 10h
.text$mn:00001900                 push    1B7h            ; unsigned int
.text$mn:00001905                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000190A                 mov     edx, [ebp+arg_8]
.text$mn:0000190D                 push    edx             ; int
.text$mn:0000190E                 call    ??$_Debug_pointer@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@PB_WI@Z ; std::_Debug_pointer<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,wchar_t const *,uint)
.text$mn:00001913                 add     esp, 0Ch
.text$mn:00001916                 mov     eax, [ebp+arg_8]
.text$mn:00001919                 mov     [ebp+var_14], eax
.text$mn:0000191C                 mov     [ebp+var_4], 0
.text$mn:00001923                 jmp     short loc_1937
.text$mn:00001925 ; ---------------------------------------------------------------------------
.text$mn:00001925
.text$mn:00001925 loc_1925:                               ; CODE XREF: ??$_Uninit_move@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@V12@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@PAV10@00AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@0@0U_No
.text$mn:00001925                 mov     ecx, [ebp+arg_8]
.text$mn:00001928                 add     ecx, 4
.text$mn:0000192B                 mov     [ebp+arg_8], ecx
.text$mn:0000192E                 mov     edx, [ebp+arg_0]
.text$mn:00001931                 add     edx, 4
.text$mn:00001934                 mov     [ebp+arg_0], edx
.text$mn:00001937
.text$mn:00001937 loc_1937:                               ; CODE XREF: ??$_Uninit_move@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@V12@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@PAV10@00AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@0@0U_No
.text$mn:00001937                 mov     eax, [ebp+arg_0]
.text$mn:0000193A                 cmp     eax, [ebp+arg_4]
.text$mn:0000193D                 jz      short loc_1951
.text$mn:0000193F                 mov     ecx, [ebp+arg_0]
.text$mn:00001942                 push    ecx             ; int
.text$mn:00001943                 mov     edx, [ebp+arg_8]
.text$mn:00001946                 push    edx             ; void *
.text$mn:00001947                 mov     ecx, [ebp+arg_C]
.text$mn:0000194A                 call    ??$construct@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@V12@@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@$$QAV21@@Z ; std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::construct<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> &&)
.text$mn:0000194F                 jmp     short loc_1925
.text$mn:00001951 ; ---------------------------------------------------------------------------
.text$mn:00001951
.text$mn:00001951 loc_1951:                               ; CODE XREF: ??$_Uninit_move@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@V12@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@PAV10@00AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@0@0U_No
.text$mn:00001951                 jmp     short loc_1983
.text$mn:00001951 ??$_Uninit_move@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@V12@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@PAV10@00AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@0@0U_Nonscalar_pt
.text$mn:00001951
.text$mn:00001953
.text$mn:00001953 ; =============== S U B R O U T I N E =======================================
.text$mn:00001953
.text$mn:00001953 ; Attributes: noreturn
.text$mn:00001953
.text$mn:00001953 __catch$??$_Uninit_move@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@V12@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@PAV10@00AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@0@0U_Nonscalar_ptr_it proc near
.text$mn:00001953                                         ; DATA XREF: .xdata$x:0000AD80o
.text$mn:00001953                 jmp     short loc_195E
.text$mn:00001955 ; ---------------------------------------------------------------------------
.text$mn:00001955
.text$mn:00001955 loc_1955:                               ; CODE XREF: __catch$??$_Uninit_move@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@V12@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@PAV10@00AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@
.text$mn:00001955                 mov     eax, [ebp-14h]
.text$mn:00001958                 add     eax, 4
.text$mn:0000195B                 mov     [ebp-14h], eax
.text$mn:0000195E
.text$mn:0000195E loc_195E:                               ; CODE XREF: __catch$??$_Uninit_move@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@V12@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@PAV10@00AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@
.text$mn:0000195E                 mov     ecx, [ebp-14h]
.text$mn:00001961                 cmp     ecx, [ebp+10h]
.text$mn:00001964                 jz      short loc_1974
.text$mn:00001966                 mov     edx, [ebp-14h]
.text$mn:00001969                 push    edx
.text$mn:0000196A                 mov     ecx, [ebp+14h]
.text$mn:0000196D                 call    ??$destroy@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@@Z ; std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::destroy<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *)
.text$mn:00001972                 jmp     short loc_1955
.text$mn:00001974 ; ---------------------------------------------------------------------------
.text$mn:00001974
.text$mn:00001974 loc_1974:                               ; CODE XREF: __catch$??$_Uninit_move@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@V12@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@PAV10@00AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@
.text$mn:00001974                 push    0
.text$mn:00001976                 push    0
.text$mn:00001978                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00001978 __catch$??$_Uninit_move@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@V12@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@PAV10@00AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@0@0U_Nons
.text$mn:00001978
.text$mn:0000197D ; ---------------------------------------------------------------------------
.text$mn:0000197D                 mov     eax, offset $LN13_0
.text$mn:00001982                 retn
.text$mn:00001983 ; ---------------------------------------------------------------------------
.text$mn:00001983 ; START OF FUNCTION CHUNK FOR ??$_Uninit_move@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@V12@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@PAV10@00AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_t
.text$mn:00001983
.text$mn:00001983 loc_1983:                               ; CODE XREF: ??$_Uninit_move@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@V12@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@PAV10@00AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@0@0U_No
.text$mn:00001983                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000198A                 jmp     short loc_1993
.text$mn:0000198A ; END OF FUNCTION CHUNK FOR ??$_Uninit_move@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@V12@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@PAV10@00AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_t
.text$mn:0000198C
.text$mn:0000198C ; =============== S U B R O U T I N E =======================================
.text$mn:0000198C
.text$mn:0000198C
.text$mn:0000198C $LN13_0         proc near               ; DATA XREF: .text$mn:0000197Do
.text$mn:0000198C                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:0000198C $LN13_0         endp ; sp-analysis failed
.text$mn:0000198C
.text$mn:00001993 ; START OF FUNCTION CHUNK FOR ??$_Uninit_move@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@V12@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@PAV10@00AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_t
.text$mn:00001993
.text$mn:00001993 loc_1993:                               ; CODE XREF: ??$_Uninit_move@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@V12@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@PAV10@00AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@0@0U_No
.text$mn:00001993                 mov     eax, [ebp+arg_8]
.text$mn:00001996                 mov     ecx, [ebp+var_C]
.text$mn:00001999                 mov     large fs:0, ecx
.text$mn:000019A0                 pop     ecx
.text$mn:000019A1                 pop     edi
.text$mn:000019A2                 pop     esi
.text$mn:000019A3                 pop     ebx
.text$mn:000019A4                 mov     esp, ebp
.text$mn:000019A6                 pop     ebp
.text$mn:000019A7                 retn
.text$mn:000019A7 ; END OF FUNCTION CHUNK FOR ??$_Uninit_move@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@V12@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@PAV10@00AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_t
.text$mn:000019A7 _text$mn        ends
.text$mn:000019A7
.text$x:000019A8 ; ===========================================================================
.text$x:000019A8
.text$x:000019A8 ; Segment type: Pure code
.text$x:000019A8 ; Segment permissions: Read/Execute
.text$x:000019A8 _text$x         segment para public 'CODE' use32
.text$x:000019A8                 assume cs:_text$x
.text$x:000019A8                 ;org 19A8h
.text$x:000019A8 ; COMDAT (pick associative to section at 18BC)
.text$x:000019A8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000019A8
.text$x:000019A8 ; =============== S U B R O U T I N E =======================================
.text$x:000019A8
.text$x:000019A8
.text$x:000019A8 __ehhandler$??$_Uninit_move@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@V12@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@PAV10@00AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@0@0U_Nonscalar_pt proc near
.text$x:000019A8                                         ; DATA XREF: ??$_Uninit_move@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@V12@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@PAV10@00AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@0@0U_No
.text$x:000019A8
.text$x:000019A8 arg_4           = dword ptr  8
.text$x:000019A8
.text$x:000019A8                 mov     edx, [esp+arg_4]
.text$x:000019AC                 lea     eax, [edx+0Ch]
.text$x:000019AF                 mov     ecx, [edx-18h]
.text$x:000019B2                 xor     ecx, eax
.text$x:000019B4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000019B9                 mov     eax, offset __ehfuncinfo$??$_Uninit_move@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@V12@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@PAV10@00AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@
.text$x:000019BE                 jmp     ___CxxFrameHandler3
.text$x:000019BE __ehhandler$??$_Uninit_move@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@V12@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@PAV10@00AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@0@0U_
.text$x:000019BE
.text$x:000019BE ; ---------------------------------------------------------------------------
.text$x:000019C3                 align 4
.text$x:000019C3 _text$x         ends
.text$x:000019C3
.text$mn:000019C4 ; ===========================================================================
.text$mn:000019C4
.text$mn:000019C4 ; Segment type: Pure code
.text$mn:000019C4 ; Segment permissions: Read/Execute
.text$mn:000019C4 _text$mn        segment para public 'CODE' use32
.text$mn:000019C4                 assume cs:_text$mn
.text$mn:000019C4                 ;org 19C4h
.text$mn:000019C4 ; COMDAT (pick any)
.text$mn:000019C4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000019C4
.text$mn:000019C4 ; =============== S U B R O U T I N E =======================================
.text$mn:000019C4
.text$mn:000019C4 ; Attributes: bp-based frame
.text$mn:000019C4
.text$mn:000019C4 ; int __cdecl std::_Uninit_move<ScintillaEditView *,ScintillaEditView *,ScintillaEditView *>(void *Src, int, void *Dst)
.text$mn:000019C4                 public ??$_Uninit_move@PAVScintillaEditView@@PAV1@PAV1@@std@@YAPAPAVScintillaEditView@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVScintillaEditView@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
.text$mn:000019C4 ??$_Uninit_move@PAVScintillaEditView@@PAV1@PAV1@@std@@YAPAPAVScintillaEditView@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVScintillaEditView@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z proc near
.text$mn:000019C4                                         ; CODE XREF: std::_Uninit_move<ScintillaEditView * *,ScintillaEditView * *,std::_Wrap_alloc<std::allocator<ScintillaEditView *>>>(ScintillaEditView * *,ScintillaEditView * *,ScintillaEditView * *,std::_Wrap_alloc<std::allocator<ScintillaEditView *>> &)+39p
.text$mn:000019C4
.text$mn:000019C4 var_4           = dword ptr -4
.text$mn:000019C4 Src             = dword ptr  8
.text$mn:000019C4 arg_4           = dword ptr  0Ch
.text$mn:000019C4 Dst             = dword ptr  10h
.text$mn:000019C4
.text$mn:000019C4                 push    ebp
.text$mn:000019C5                 mov     ebp, esp
.text$mn:000019C7                 push    ecx
.text$mn:000019C8                 push    1D6h            ; unsigned int
.text$mn:000019CD                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000019D2                 mov     eax, [ebp+arg_4]
.text$mn:000019D5                 push    eax             ; int
.text$mn:000019D6                 mov     ecx, [ebp+Src]
.text$mn:000019D9                 push    ecx             ; int
.text$mn:000019DA                 call    ??$_Debug_range@PAPAVScintillaEditView@@@std@@YAXPAPAVScintillaEditView@@0PB_WI@Z ; std::_Debug_range<ScintillaEditView * *>(ScintillaEditView * *,ScintillaEditView * *,wchar_t const *,uint)
.text$mn:000019DF                 add     esp, 10h
.text$mn:000019E2                 push    1D7h            ; unsigned int
.text$mn:000019E7                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000019EC                 mov     edx, [ebp+Dst]
.text$mn:000019EF                 push    edx             ; int
.text$mn:000019F0                 call    ??$_Debug_pointer@PAVScintillaEditView@@@std@@YAXPAPAVScintillaEditView@@PB_WI@Z ; std::_Debug_pointer<ScintillaEditView *>(ScintillaEditView * *,wchar_t const *,uint)
.text$mn:000019F5                 add     esp, 0Ch
.text$mn:000019F8                 mov     eax, [ebp+arg_4]
.text$mn:000019FB                 sub     eax, [ebp+Src]
.text$mn:000019FE                 sar     eax, 2
.text$mn:00001A01                 mov     [ebp+var_4], eax
.text$mn:00001A04                 mov     ecx, [ebp+var_4]
.text$mn:00001A07                 shl     ecx, 2
.text$mn:00001A0A                 push    ecx             ; Size
.text$mn:00001A0B                 mov     edx, [ebp+Src]
.text$mn:00001A0E                 push    edx             ; Src
.text$mn:00001A0F                 mov     eax, [ebp+Dst]
.text$mn:00001A12                 push    eax             ; Dst
.text$mn:00001A13                 call    _memmove
.text$mn:00001A18                 add     esp, 0Ch
.text$mn:00001A1B                 mov     ecx, [ebp+var_4]
.text$mn:00001A1E                 lea     eax, [eax+ecx*4]
.text$mn:00001A21                 mov     esp, ebp
.text$mn:00001A23                 pop     ebp
.text$mn:00001A24                 retn
.text$mn:00001A24 ??$_Uninit_move@PAVScintillaEditView@@PAV1@PAV1@@std@@YAPAPAVScintillaEditView@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVScintillaEditView@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z endp
.text$mn:00001A24
.text$mn:00001A24 ; ---------------------------------------------------------------------------
.text$mn:00001A25                 align 4
.text$mn:00001A25 _text$mn        ends
.text$mn:00001A25
.text$mn:00001A28 ; ===========================================================================
.text$mn:00001A28
.text$mn:00001A28 ; Segment type: Pure code
.text$mn:00001A28 ; Segment permissions: Read/Execute
.text$mn:00001A28 _text$mn        segment para public 'CODE' use32
.text$mn:00001A28                 assume cs:_text$mn
.text$mn:00001A28                 ;org 1A28h
.text$mn:00001A28 ; COMDAT (pick any)
.text$mn:00001A28                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001A28
.text$mn:00001A28 ; =============== S U B R O U T I N E =======================================
.text$mn:00001A28
.text$mn:00001A28 ; Attributes: bp-based frame
.text$mn:00001A28
.text$mn:00001A28 ; int __cdecl std::_Uninitialized_fill_n<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,unsigned int,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>>(void *, int, int, int)
.text$mn:00001A28                 public ??$_Uninitialized_fill_n@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@IV12@U?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@IPBV10@AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std
.text$mn:00001A28 ??$_Uninitialized_fill_n@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@IV12@U?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@IPBV10@AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@0@@Z proc near
.text$mn:00001A28                                         ; CODE XREF: std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::_Ufill(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,uint,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const *)+25p
.text$mn:00001A28
.text$mn:00001A28 var_1           = byte ptr -1
.text$mn:00001A28 arg_0           = dword ptr  8
.text$mn:00001A28 arg_4           = dword ptr  0Ch
.text$mn:00001A28 arg_8           = dword ptr  10h
.text$mn:00001A28 arg_C           = dword ptr  14h
.text$mn:00001A28
.text$mn:00001A28                 push    ebp
.text$mn:00001A29                 mov     ebp, esp
.text$mn:00001A2B                 push    ecx
.text$mn:00001A2C                 mov     eax, [ebp+arg_0]
.text$mn:00001A2F                 push    eax
.text$mn:00001A30                 mov     ecx, [ebp+arg_0]
.text$mn:00001A33                 push    ecx
.text$mn:00001A34                 call    ??$_Ptr_cat@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@0@Z ; std::_Ptr_cat<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *)
.text$mn:00001A39                 add     esp, 8
.text$mn:00001A3C                 mov     [ebp+var_1], al
.text$mn:00001A3F                 movzx   edx, [ebp+var_1]
.text$mn:00001A43                 push    edx
.text$mn:00001A44                 mov     eax, [ebp+arg_0]
.text$mn:00001A47                 push    eax
.text$mn:00001A48                 call    ??$_Val_type@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@PAV10@@Z ; std::_Val_type<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *)
.text$mn:00001A4D                 add     esp, 4
.text$mn:00001A50                 push    eax
.text$mn:00001A51                 mov     ecx, [ebp+arg_C]
.text$mn:00001A54                 push    ecx             ; int
.text$mn:00001A55                 mov     edx, [ebp+arg_8]
.text$mn:00001A58                 push    edx             ; int
.text$mn:00001A59                 mov     eax, [ebp+arg_4]
.text$mn:00001A5C                 push    eax             ; int
.text$mn:00001A5D                 mov     ecx, [ebp+arg_0]
.text$mn:00001A60                 push    ecx             ; void *
.text$mn:00001A61                 call    ??$_Uninit_fill_n@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@IV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@V12@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@IPBV10@AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@0@
.text$mn:00001A66                 add     esp, 18h
.text$mn:00001A69                 mov     esp, ebp
.text$mn:00001A6B                 pop     ebp
.text$mn:00001A6C                 retn
.text$mn:00001A6C ??$_Uninitialized_fill_n@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@IV12@U?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@IPBV10@AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@
.text$mn:00001A6C
.text$mn:00001A6C ; ---------------------------------------------------------------------------
.text$mn:00001A6D                 align 10h
.text$mn:00001A6D _text$mn        ends
.text$mn:00001A6D
.text$mn:00001A70 ; ===========================================================================
.text$mn:00001A70
.text$mn:00001A70 ; Segment type: Pure code
.text$mn:00001A70 ; Segment permissions: Read/Execute
.text$mn:00001A70 _text$mn        segment para public 'CODE' use32
.text$mn:00001A70                 assume cs:_text$mn
.text$mn:00001A70                 ;org 1A70h
.text$mn:00001A70 ; COMDAT (pick any)
.text$mn:00001A70                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001A70
.text$mn:00001A70 ; =============== S U B R O U T I N E =======================================
.text$mn:00001A70
.text$mn:00001A70 ; Attributes: bp-based frame
.text$mn:00001A70
.text$mn:00001A70 ; class ScintillaEditView * * __cdecl std::_Uninitialized_move<class ScintillaEditView * *, class ScintillaEditView * *, struct std::_Wrap_alloc<class std::allocator<class ScintillaEditView *>>>(class ScintillaEditView * *, class ScintillaEditView * *, class ScintillaEditView * *, struct std::_Wrap_alloc<class std::allocator<class ScintillaEditView *>> &)
.text$mn:00001A70                 public ??$_Uninitialized_move@PAPAVScintillaEditView@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVScintillaEditView@@@std@@@std@@@std@@YAPAPAVScintillaEditView@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVScintillaEditView@@@std@@@0@@Z
.text$mn:00001A70 ??$_Uninitialized_move@PAPAVScintillaEditView@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVScintillaEditView@@@std@@@std@@@std@@YAPAPAVScintillaEditView@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVScintillaEditView@@@std@@@0@@Z proc near
.text$mn:00001A70                                         ; CODE XREF: std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::_Umove<ScintillaEditView * *>(ScintillaEditView * *,ScintillaEditView * *,ScintillaEditView * *)+25p
.text$mn:00001A70
.text$mn:00001A70 arg_0           = dword ptr  8
.text$mn:00001A70 arg_4           = dword ptr  0Ch
.text$mn:00001A70 arg_8           = dword ptr  10h
.text$mn:00001A70 arg_C           = dword ptr  14h
.text$mn:00001A70
.text$mn:00001A70                 push    ebp
.text$mn:00001A71                 mov     ebp, esp
.text$mn:00001A73                 mov     eax, [ebp+arg_C]
.text$mn:00001A76                 push    eax             ; int
.text$mn:00001A77                 mov     ecx, [ebp+arg_8]
.text$mn:00001A7A                 push    ecx
.text$mn:00001A7B                 call    ??$_Unchecked@PAPAVScintillaEditView@@@std@@YAPAPAVScintillaEditView@@PAPAV1@@Z ; std::_Unchecked<ScintillaEditView * *>(ScintillaEditView * *)
.text$mn:00001A80                 add     esp, 4
.text$mn:00001A83                 push    eax             ; Dst
.text$mn:00001A84                 mov     edx, [ebp+arg_4]
.text$mn:00001A87                 push    edx
.text$mn:00001A88                 call    ??$_Unchecked@PAPAVScintillaEditView@@@std@@YAPAPAVScintillaEditView@@PAPAV1@@Z ; std::_Unchecked<ScintillaEditView * *>(ScintillaEditView * *)
.text$mn:00001A8D                 add     esp, 4
.text$mn:00001A90                 push    eax             ; int
.text$mn:00001A91                 mov     eax, [ebp+arg_0]
.text$mn:00001A94                 push    eax
.text$mn:00001A95                 call    ??$_Unchecked@PAPAVScintillaEditView@@@std@@YAPAPAVScintillaEditView@@PAPAV1@@Z ; std::_Unchecked<ScintillaEditView * *>(ScintillaEditView * *)
.text$mn:00001A9A                 add     esp, 4
.text$mn:00001A9D                 push    eax             ; Src
.text$mn:00001A9E                 call    ??$_Uninit_move@PAPAVScintillaEditView@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVScintillaEditView@@@std@@@std@@@std@@YAPAPAVScintillaEditView@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVScintillaEditView@@@std@@@0@@Z ; std::_Uninit_move<ScintillaEditView * *,ScintillaEditView * *,std::_Wrap_alloc<std::allocator<ScintillaEditView *>>>(ScintillaEditView * *,ScintillaEditView * *,ScintillaEditView * *,std::_Wrap_alloc<std::allocator<ScintillaEditView *>> &)
.text$mn:00001AA3                 add     esp, 10h
.text$mn:00001AA6                 push    eax
.text$mn:00001AA7                 lea     ecx, [ebp+arg_8]
.text$mn:00001AAA                 push    ecx
.text$mn:00001AAB                 call    ??$_Rechecked@PAPAVScintillaEditView@@PAPAV1@@std@@YAAAPAPAVScintillaEditView@@AAPAPAV1@PAPAV1@@Z ; std::_Rechecked<ScintillaEditView * *,ScintillaEditView * *>(ScintillaEditView * * &,ScintillaEditView * *)
.text$mn:00001AB0                 add     esp, 8
.text$mn:00001AB3                 mov     eax, [eax]
.text$mn:00001AB5                 pop     ebp
.text$mn:00001AB6                 retn
.text$mn:00001AB6 ??$_Uninitialized_move@PAPAVScintillaEditView@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVScintillaEditView@@@std@@@std@@@std@@YAPAPAVScintillaEditView@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVScintillaEditView@@@std@@@0@@Z endp
.text$mn:00001AB6
.text$mn:00001AB6 ; ---------------------------------------------------------------------------
.text$mn:00001AB7                 align 4
.text$mn:00001AB7 _text$mn        ends
.text$mn:00001AB7
.text$mn:00001AB8 ; ===========================================================================
.text$mn:00001AB8
.text$mn:00001AB8 ; Segment type: Pure code
.text$mn:00001AB8 ; Segment permissions: Read/Execute
.text$mn:00001AB8 _text$mn        segment para public 'CODE' use32
.text$mn:00001AB8                 assume cs:_text$mn
.text$mn:00001AB8                 ;org 1AB8h
.text$mn:00001AB8 ; COMDAT (pick any)
.text$mn:00001AB8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001AB8
.text$mn:00001AB8 ; =============== S U B R O U T I N E =======================================
.text$mn:00001AB8
.text$mn:00001AB8 ; Attributes: bp-based frame
.text$mn:00001AB8
.text$mn:00001AB8 ; class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>> * __cdecl std::_Uninitialized_move<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>> *, class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>> *, struct std::_Wrap_alloc<struct std::_Wrap_alloc<class std::allocator<class std::_List_unchecked_iterat
.text$mn:00001AB8                 public ??$_Uninitialized_move@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@PAV12@U?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@PAV10@00AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@
.text$mn:00001AB8 ??$_Uninitialized_move@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@PAV12@U?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@PAV10@00AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@0@@Z proc near
.text$mn:00001AB8                                         ; CODE XREF: std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::_Umove<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<
.text$mn:00001AB8
.text$mn:00001AB8 arg_0           = dword ptr  8
.text$mn:00001AB8 arg_4           = dword ptr  0Ch
.text$mn:00001AB8 arg_8           = dword ptr  10h
.text$mn:00001AB8 arg_C           = dword ptr  14h
.text$mn:00001AB8
.text$mn:00001AB8                 push    ebp
.text$mn:00001AB9                 mov     ebp, esp
.text$mn:00001ABB                 mov     eax, [ebp+arg_C]
.text$mn:00001ABE                 push    eax             ; int
.text$mn:00001ABF                 mov     ecx, [ebp+arg_8]
.text$mn:00001AC2                 push    ecx
.text$mn:00001AC3                 call    ??$_Unchecked@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@PAV10@@Z ; std::_Unchecked<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *)
.text$mn:00001AC8                 add     esp, 4
.text$mn:00001ACB                 push    eax             ; void *
.text$mn:00001ACC                 mov     edx, [ebp+arg_4]
.text$mn:00001ACF                 push    edx
.text$mn:00001AD0                 call    ??$_Unchecked@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@PAV10@@Z ; std::_Unchecked<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *)
.text$mn:00001AD5                 add     esp, 4
.text$mn:00001AD8                 push    eax             ; int
.text$mn:00001AD9                 mov     eax, [ebp+arg_0]
.text$mn:00001ADC                 push    eax
.text$mn:00001ADD                 call    ??$_Unchecked@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@PAV10@@Z ; std::_Unchecked<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *)
.text$mn:00001AE2                 add     esp, 4
.text$mn:00001AE5                 push    eax             ; int
.text$mn:00001AE6                 call    ??$_Uninit_move@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@PAV12@U?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@PAV10@00AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@ ; std::_Uninit_move<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>> &)
.text$mn:00001AEB                 add     esp, 10h
.text$mn:00001AEE                 push    eax
.text$mn:00001AEF                 lea     ecx, [ebp+arg_8]
.text$mn:00001AF2                 push    ecx
.text$mn:00001AF3                 call    ??$_Rechecked@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@PAV12@@std@@YAAAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@AAPAV10@PAV10@@Z ; std::_Rechecked<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> * &,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *)
.text$mn:00001AF8                 add     esp, 8
.text$mn:00001AFB                 mov     eax, [eax]
.text$mn:00001AFD                 pop     ebp
.text$mn:00001AFE                 retn
.text$mn:00001AFE ??$_Uninitialized_move@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@PAV12@U?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@PAV10@00AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@
.text$mn:00001AFE
.text$mn:00001AFE ; ---------------------------------------------------------------------------
.text$mn:00001AFF                 align 10h
.text$mn:00001AFF _text$mn        ends
.text$mn:00001AFF
.text$mn:00001B00 ; ===========================================================================
.text$mn:00001B00
.text$mn:00001B00 ; Segment type: Pure code
.text$mn:00001B00 ; Segment permissions: Read/Execute
.text$mn:00001B00 _text$mn        segment para public 'CODE' use32
.text$mn:00001B00                 assume cs:_text$mn
.text$mn:00001B00                 ;org 1B00h
.text$mn:00001B00 ; COMDAT (pick any)
.text$mn:00001B00                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001B00
.text$mn:00001B00 ; =============== S U B R O U T I N E =======================================
.text$mn:00001B00
.text$mn:00001B00 ; Attributes: bp-based frame
.text$mn:00001B00
.text$mn:00001B00 ; class ScintillaEditView * * __cdecl std::_Val_type<class ScintillaEditView * *>(class ScintillaEditView * *)
.text$mn:00001B00                 public ??$_Val_type@PAPAVScintillaEditView@@@std@@YAPAPAVScintillaEditView@@PAPAV1@@Z
.text$mn:00001B00 ??$_Val_type@PAPAVScintillaEditView@@@std@@YAPAPAVScintillaEditView@@PAPAV1@@Z proc near
.text$mn:00001B00                                         ; CODE XREF: std::_Uninit_move<ScintillaEditView * *,ScintillaEditView * *,std::_Wrap_alloc<std::allocator<ScintillaEditView *>>>(ScintillaEditView * *,ScintillaEditView * *,ScintillaEditView * *,std::_Wrap_alloc<std::allocator<ScintillaEditView *>> &)+20p
.text$mn:00001B00                 push    ebp
.text$mn:00001B01                 mov     ebp, esp
.text$mn:00001B03                 xor     eax, eax
.text$mn:00001B05                 pop     ebp
.text$mn:00001B06                 retn
.text$mn:00001B06 ??$_Val_type@PAPAVScintillaEditView@@@std@@YAPAPAVScintillaEditView@@PAPAV1@@Z endp
.text$mn:00001B06
.text$mn:00001B06 ; ---------------------------------------------------------------------------
.text$mn:00001B07                 align 4
.text$mn:00001B07 _text$mn        ends
.text$mn:00001B07
.text$mn:00001B08 ; ===========================================================================
.text$mn:00001B08
.text$mn:00001B08 ; Segment type: Pure code
.text$mn:00001B08 ; Segment permissions: Read/Execute
.text$mn:00001B08 _text$mn        segment para public 'CODE' use32
.text$mn:00001B08                 assume cs:_text$mn
.text$mn:00001B08                 ;org 1B08h
.text$mn:00001B08 ; COMDAT (pick any)
.text$mn:00001B08                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001B08
.text$mn:00001B08 ; =============== S U B R O U T I N E =======================================
.text$mn:00001B08
.text$mn:00001B08 ; Attributes: bp-based frame
.text$mn:00001B08
.text$mn:00001B08 ; class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>> * __cdecl std::_Val_type<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>> *>(class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>> *)
.text$mn:00001B08                 public ??$_Val_type@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@PAV10@@Z
.text$mn:00001B08 ??$_Val_type@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@PAV10@@Z proc near
.text$mn:00001B08                                         ; CODE XREF: std::_Uninit_move<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,st
.text$mn:00001B08                                         ; std::_Uninitialized_fill_n<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,uint,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,uint,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * co
.text$mn:00001B08                 push    ebp
.text$mn:00001B09                 mov     ebp, esp
.text$mn:00001B0B                 xor     eax, eax
.text$mn:00001B0D                 pop     ebp
.text$mn:00001B0E                 retn
.text$mn:00001B0E ??$_Val_type@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@PAV10@@Z endp
.text$mn:00001B0E
.text$mn:00001B0E ; ---------------------------------------------------------------------------
.text$mn:00001B0F                 align 10h
.text$mn:00001B0F _text$mn        ends
.text$mn:00001B0F
.text$mn:00001B10 ; ===========================================================================
.text$mn:00001B10
.text$mn:00001B10 ; Segment type: Pure code
.text$mn:00001B10 ; Segment permissions: Read/Execute
.text$mn:00001B10 _text$mn        segment para public 'CODE' use32
.text$mn:00001B10                 assume cs:_text$mn
.text$mn:00001B10                 ;org 1B10h
.text$mn:00001B10 ; COMDAT (pick any)
.text$mn:00001B10                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001B10
.text$mn:00001B10 ; =============== S U B R O U T I N E =======================================
.text$mn:00001B10
.text$mn:00001B10 ; Attributes: bp-based frame
.text$mn:00001B10
.text$mn:00001B10 ; class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>> const * __cdecl std::addressof<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>> const>(class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>> const &)
.text$mn:00001B10                 public ??$addressof@$$CBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@YAPBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@ABV10@@Z
.text$mn:00001B10 ??$addressof@$$CBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@YAPBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@ABV10@@Z proc near
.text$mn:00001B10                                         ; CODE XREF: ?_Insert_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CB
.text$mn:00001B10
.text$mn:00001B10 arg_0           = dword ptr  8
.text$mn:00001B10
.text$mn:00001B10                 push    ebp
.text$mn:00001B11                 mov     ebp, esp
.text$mn:00001B13                 mov     eax, [ebp+arg_0]
.text$mn:00001B16                 pop     ebp
.text$mn:00001B17                 retn
.text$mn:00001B17 ??$addressof@$$CBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@YAPBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@ABV10@@Z endp
.text$mn:00001B17
.text$mn:00001B17 _text$mn        ends
.text$mn:00001B17
.text$mn:00001B18 ; ===========================================================================
.text$mn:00001B18
.text$mn:00001B18 ; Segment type: Pure code
.text$mn:00001B18 ; Segment permissions: Read/Execute
.text$mn:00001B18 _text$mn        segment para public 'CODE' use32
.text$mn:00001B18                 assume cs:_text$mn
.text$mn:00001B18                 ;org 1B18h
.text$mn:00001B18 ; COMDAT (pick any)
.text$mn:00001B18                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001B18
.text$mn:00001B18 ; =============== S U B R O U T I N E =======================================
.text$mn:00001B18
.text$mn:00001B18 ; Attributes: bp-based frame
.text$mn:00001B18
.text$mn:00001B18 ; char * __cdecl std::addressof<char>(char &)
.text$mn:00001B18                 public ??$addressof@D@std@@YAPADAAD@Z
.text$mn:00001B18 ??$addressof@D@std@@YAPADAAD@Z proc near
.text$mn:00001B18                                         ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+19p
.text$mn:00001B18                                         ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)+19p ...
.text$mn:00001B18
.text$mn:00001B18 arg_0           = dword ptr  8
.text$mn:00001B18
.text$mn:00001B18                 push    ebp
.text$mn:00001B19                 mov     ebp, esp
.text$mn:00001B1B                 mov     eax, [ebp+arg_0]
.text$mn:00001B1E                 pop     ebp
.text$mn:00001B1F                 retn
.text$mn:00001B1F ??$addressof@D@std@@YAPADAAD@Z endp
.text$mn:00001B1F
.text$mn:00001B1F _text$mn        ends
.text$mn:00001B1F
.text$mn:00001B20 ; ===========================================================================
.text$mn:00001B20
.text$mn:00001B20 ; Segment type: Pure code
.text$mn:00001B20 ; Segment permissions: Read/Execute
.text$mn:00001B20 _text$mn        segment para public 'CODE' use32
.text$mn:00001B20                 assume cs:_text$mn
.text$mn:00001B20                 ;org 1B20h
.text$mn:00001B20 ; COMDAT (pick any)
.text$mn:00001B20                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001B20
.text$mn:00001B20 ; =============== S U B R O U T I N E =======================================
.text$mn:00001B20
.text$mn:00001B20 ; Attributes: bp-based frame
.text$mn:00001B20
.text$mn:00001B20 ; struct std::_List_node<struct std::pair<int const, struct Style>, void *> * * __cdecl std::addressof<struct std::_List_node<struct std::pair<int const, struct Style>, void *> *>(struct std::_List_node<struct std::pair<int const, struct Style>, void *> * &)
.text$mn:00001B20                 public ??$addressof@PAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@std@@@std@@YAPAPAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@0@AAPAU10@@Z
.text$mn:00001B20 ??$addressof@PAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@std@@@std@@YAPAPAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@0@AAPAU10@@Z proc near
.text$mn:00001B20                                         ; CODE XREF: std::_List_alloc<0,std::_List_base_types<std::pair<int const,Style>,std::allocator<std::pair<int const,Style>>>>::_Freeheadnode(std::_List_node<std::pair<int const,Style>,void *> *)+16p
.text$mn:00001B20                                         ; std::_List_alloc<0,std::_List_base_types<std::pair<int const,Style>,std::allocator<std::pair<int const,Style>>>>::_Freeheadnode(std::_List_node<std::pair<int const,Style>,void *> *)+3Fp ...
.text$mn:00001B20
.text$mn:00001B20 arg_0           = dword ptr  8
.text$mn:00001B20
.text$mn:00001B20                 push    ebp
.text$mn:00001B21                 mov     ebp, esp
.text$mn:00001B23                 mov     eax, [ebp+arg_0]
.text$mn:00001B26                 pop     ebp
.text$mn:00001B27                 retn
.text$mn:00001B27 ??$addressof@PAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@std@@@std@@YAPAPAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@0@AAPAU10@@Z endp
.text$mn:00001B27
.text$mn:00001B27 _text$mn        ends
.text$mn:00001B27
.text$mn:00001B28 ; ===========================================================================
.text$mn:00001B28
.text$mn:00001B28 ; Segment type: Pure code
.text$mn:00001B28 ; Segment permissions: Read/Execute
.text$mn:00001B28 _text$mn        segment para public 'CODE' use32
.text$mn:00001B28                 assume cs:_text$mn
.text$mn:00001B28                 ;org 1B28h
.text$mn:00001B28 ; COMDAT (pick any)
.text$mn:00001B28                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001B28
.text$mn:00001B28 ; =============== S U B R O U T I N E =======================================
.text$mn:00001B28
.text$mn:00001B28 ; Attributes: bp-based frame
.text$mn:00001B28
.text$mn:00001B28 ; struct std::_List_node<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>, void *> * * __cdecl std::addressof<struct std::_List_node<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>, void *> *>(struct std::_List_node<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>, void *> * &)
.text$mn:00001B28                 public ??$addressof@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@YAPAPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@0@AAPAU10@@Z
.text$mn:00001B28 ??$addressof@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@YAPAPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@0@AAPAU10@@Z proc near
.text$mn:00001B28                                         ; CODE XREF: std::_List_alloc<0,std::_List_base_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::_Buynode0(std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *,std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *)+71p
.text$mn:00001B28                                         ; std::_List_alloc<0,std::_List_base_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::_Buynode0(std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *,std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *)+9Ep ...
.text$mn:00001B28
.text$mn:00001B28 arg_0           = dword ptr  8
.text$mn:00001B28
.text$mn:00001B28                 push    ebp
.text$mn:00001B29                 mov     ebp, esp
.text$mn:00001B2B                 mov     eax, [ebp+arg_0]
.text$mn:00001B2E                 pop     ebp
.text$mn:00001B2F                 retn
.text$mn:00001B2F ??$addressof@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@YAPAPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@0@AAPAU10@@Z endp
.text$mn:00001B2F
.text$mn:00001B2F _text$mn        ends
.text$mn:00001B2F
.text$mn:00001B30 ; ===========================================================================
.text$mn:00001B30
.text$mn:00001B30 ; Segment type: Pure code
.text$mn:00001B30 ; Segment permissions: Read/Execute
.text$mn:00001B30 _text$mn        segment para public 'CODE' use32
.text$mn:00001B30                 assume cs:_text$mn
.text$mn:00001B30                 ;org 1B30h
.text$mn:00001B30 ; COMDAT (pick any)
.text$mn:00001B30                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001B30
.text$mn:00001B30 ; =============== S U B R O U T I N E =======================================
.text$mn:00001B30
.text$mn:00001B30 ; Attributes: bp-based frame
.text$mn:00001B30
.text$mn:00001B30 ; class ScintillaEditView * const * __cdecl std::addressof<class ScintillaEditView * const>(class ScintillaEditView * const &)
.text$mn:00001B30                 public ??$addressof@QAVScintillaEditView@@@std@@YAPBQAVScintillaEditView@@ABQAV1@@Z
.text$mn:00001B30 ??$addressof@QAVScintillaEditView@@@std@@YAPBQAVScintillaEditView@@ABQAV1@@Z proc near
.text$mn:00001B30                                         ; CODE XREF: std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::push_back(ScintillaEditView * const &)+Dp
.text$mn:00001B30                                         ; std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::push_back(ScintillaEditView * const &)+29p
.text$mn:00001B30
.text$mn:00001B30 arg_0           = dword ptr  8
.text$mn:00001B30
.text$mn:00001B30                 push    ebp
.text$mn:00001B31                 mov     ebp, esp
.text$mn:00001B33                 mov     eax, [ebp+arg_0]
.text$mn:00001B36                 pop     ebp
.text$mn:00001B37                 retn
.text$mn:00001B37 ??$addressof@QAVScintillaEditView@@@std@@YAPBQAVScintillaEditView@@ABQAV1@@Z endp
.text$mn:00001B37
.text$mn:00001B37 _text$mn        ends
.text$mn:00001B37
.text$mn:00001B38 ; ===========================================================================
.text$mn:00001B38
.text$mn:00001B38 ; Segment type: Pure code
.text$mn:00001B38 ; Segment permissions: Read/Execute
.text$mn:00001B38 _text$mn        segment para public 'CODE' use32
.text$mn:00001B38                 assume cs:_text$mn
.text$mn:00001B38                 ;org 1B38h
.text$mn:00001B38 ; COMDAT (pick any)
.text$mn:00001B38                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001B38
.text$mn:00001B38 ; =============== S U B R O U T I N E =======================================
.text$mn:00001B38
.text$mn:00001B38 ; Attributes: bp-based frame
.text$mn:00001B38
.text$mn:00001B38 ; struct std::pair<int const, struct Style> * __cdecl std::addressof<struct std::pair<int const, struct Style>>(struct std::pair<int const, struct Style> &)
.text$mn:00001B38                 public ??$addressof@U?$pair@$$CBHUStyle@@@std@@@std@@YAPAU?$pair@$$CBHUStyle@@@0@AAU10@@Z
.text$mn:00001B38 ??$addressof@U?$pair@$$CBHUStyle@@@std@@@std@@YAPAU?$pair@$$CBHUStyle@@@0@AAU10@@Z proc near
.text$mn:00001B38                                         ; CODE XREF: std::_List_buy<std::pair<int const,Style>,std::allocator<std::pair<int const,Style>>>::_Freenode(std::_List_node<std::pair<int const,Style>,void *> *)+68p
.text$mn:00001B38                                         ; std::pointer_traits<std::pair<int const,Style> *>::pointer_to(std::pair<int const,Style> &)+7p
.text$mn:00001B38
.text$mn:00001B38 arg_0           = dword ptr  8
.text$mn:00001B38
.text$mn:00001B38                 push    ebp
.text$mn:00001B39                 mov     ebp, esp
.text$mn:00001B3B                 mov     eax, [ebp+arg_0]
.text$mn:00001B3E                 pop     ebp
.text$mn:00001B3F                 retn
.text$mn:00001B3F ??$addressof@U?$pair@$$CBHUStyle@@@std@@@std@@YAPAU?$pair@$$CBHUStyle@@@0@AAU10@@Z endp
.text$mn:00001B3F
.text$mn:00001B3F _text$mn        ends
.text$mn:00001B3F
.text$mn:00001B40 ; ===========================================================================
.text$mn:00001B40
.text$mn:00001B40 ; Segment type: Pure code
.text$mn:00001B40 ; Segment permissions: Read/Execute
.text$mn:00001B40 _text$mn        segment para public 'CODE' use32
.text$mn:00001B40                 assume cs:_text$mn
.text$mn:00001B40                 ;org 1B40h
.text$mn:00001B40 ; COMDAT (pick any)
.text$mn:00001B40                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001B40
.text$mn:00001B40 ; =============== S U B R O U T I N E =======================================
.text$mn:00001B40
.text$mn:00001B40 ; Attributes: bp-based frame
.text$mn:00001B40
.text$mn:00001B40 ; struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *> * __cdecl std::addressof<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>(struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *> &)
.text$mn:00001B40                 public ??$addressof@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@YAPAU?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@0@AAU10@@Z
.text$mn:00001B40 ??$addressof@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@YAPAU?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@0@AAU10@@Z proc near
.text$mn:00001B40                                         ; CODE XREF: std::_List_buy<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>::_Freenode(std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *)+68p
.text$mn:00001B40                                         ; std::pointer_traits<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *> *>::pointer_to(std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *> &)+7p
.text$mn:00001B40
.text$mn:00001B40 arg_0           = dword ptr  8
.text$mn:00001B40
.text$mn:00001B40                 push    ebp
.text$mn:00001B41                 mov     ebp, esp
.text$mn:00001B43                 mov     eax, [ebp+arg_0]
.text$mn:00001B46                 pop     ebp
.text$mn:00001B47                 retn
.text$mn:00001B47 ??$addressof@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@YAPAU?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@0@AAU10@@Z endp
.text$mn:00001B47
.text$mn:00001B47 _text$mn        ends
.text$mn:00001B47
.text$mn:00001B48 ; ===========================================================================
.text$mn:00001B48
.text$mn:00001B48 ; Segment type: Pure code
.text$mn:00001B48 ; Segment permissions: Read/Execute
.text$mn:00001B48 _text$mn        segment para public 'CODE' use32
.text$mn:00001B48                 assume cs:_text$mn
.text$mn:00001B48                 ;org 1B48h
.text$mn:00001B48 ; COMDAT (pick any)
.text$mn:00001B48                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001B48
.text$mn:00001B48 ; =============== S U B R O U T I N E =======================================
.text$mn:00001B48
.text$mn:00001B48 ; Attributes: bp-based frame
.text$mn:00001B48
.text$mn:00001B48 ; class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>> * __cdecl std::addressof<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>>(class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>> &)
.text$mn:00001B48                 public ??$addressof@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@AAV10@@Z
.text$mn:00001B48 ??$addressof@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@AAV10@@Z proc near
.text$mn:00001B48                                         ; CODE XREF: ?_Insert_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CB
.text$mn:00001B48
.text$mn:00001B48 arg_0           = dword ptr  8
.text$mn:00001B48
.text$mn:00001B48                 push    ebp
.text$mn:00001B49                 mov     ebp, esp
.text$mn:00001B4B                 mov     eax, [ebp+arg_0]
.text$mn:00001B4E                 pop     ebp
.text$mn:00001B4F                 retn
.text$mn:00001B4F ??$addressof@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@AAV10@@Z endp
.text$mn:00001B4F
.text$mn:00001B4F _text$mn        ends
.text$mn:00001B4F
.text$mn:00001B50 ; ===========================================================================
.text$mn:00001B50
.text$mn:00001B50 ; Segment type: Pure code
.text$mn:00001B50 ; Segment permissions: Read/Execute
.text$mn:00001B50 _text$mn        segment para public 'CODE' use32
.text$mn:00001B50                 assume cs:_text$mn
.text$mn:00001B50                 ;org 1B50h
.text$mn:00001B50 ; COMDAT (pick any)
.text$mn:00001B50                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001B50
.text$mn:00001B50 ; =============== S U B R O U T I N E =======================================
.text$mn:00001B50
.text$mn:00001B50 ; Attributes: bp-based frame
.text$mn:00001B50
.text$mn:00001B50 ; wchar_t * __cdecl std::addressof<wchar_t>(wchar_t &)
.text$mn:00001B50                 public ??$addressof@_W@std@@YAPA_WAA_W@Z
.text$mn:00001B50 ??$addressof@_W@std@@YAPA_WAA_W@Z proc near
.text$mn:00001B50                                         ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+19p
.text$mn:00001B50                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+4Dp
.text$mn:00001B50
.text$mn:00001B50 arg_0           = dword ptr  8
.text$mn:00001B50
.text$mn:00001B50                 push    ebp
.text$mn:00001B51                 mov     ebp, esp
.text$mn:00001B53                 mov     eax, [ebp+arg_0]
.text$mn:00001B56                 pop     ebp
.text$mn:00001B57                 retn
.text$mn:00001B57 ??$addressof@_W@std@@YAPA_WAA_W@Z endp
.text$mn:00001B57
.text$mn:00001B57 _text$mn        ends
.text$mn:00001B57
.text$mn:00001B58 ; ===========================================================================
.text$mn:00001B58
.text$mn:00001B58 ; Segment type: Pure code
.text$mn:00001B58 ; Segment permissions: Read/Execute
.text$mn:00001B58 _text$mn        segment para public 'CODE' use32
.text$mn:00001B58                 assume cs:_text$mn
.text$mn:00001B58                 ;org 1B58h
.text$mn:00001B58 ; COMDAT (pick any)
.text$mn:00001B58                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001B58
.text$mn:00001B58 ; =============== S U B R O U T I N E =======================================
.text$mn:00001B58
.text$mn:00001B58 ; Attributes: bp-based frame
.text$mn:00001B58
.text$mn:00001B58 ; int __stdcall std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(void *, int)
.text$mn:00001B58                 public ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
.text$mn:00001B58 ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z proc near
.text$mn:00001B58                                         ; CODE XREF: $LN19+4Bp
.text$mn:00001B58
.text$mn:00001B58 var_4           = dword ptr -4
.text$mn:00001B58 arg_0           = dword ptr  8
.text$mn:00001B58 arg_4           = dword ptr  0Ch
.text$mn:00001B58
.text$mn:00001B58                 push    ebp
.text$mn:00001B59                 mov     ebp, esp
.text$mn:00001B5B                 push    ecx
.text$mn:00001B5C                 mov     [ebp+var_4], ecx
.text$mn:00001B5F                 mov     eax, [ebp+arg_4]
.text$mn:00001B62                 push    eax
.text$mn:00001B63                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:00001B68                 add     esp, 4
.text$mn:00001B6B                 push    eax             ; int
.text$mn:00001B6C                 mov     ecx, [ebp+arg_0]
.text$mn:00001B6F                 push    ecx             ; void *
.text$mn:00001B70                 mov     edx, [ebp+var_4]
.text$mn:00001B73                 push    edx             ; int
.text$mn:00001B74                 call    ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(std::allocator<char> &,char * *,char * &)
.text$mn:00001B79                 add     esp, 0Ch
.text$mn:00001B7C                 mov     esp, ebp
.text$mn:00001B7E                 pop     ebp
.text$mn:00001B7F                 retn    8
.text$mn:00001B7F ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z endp
.text$mn:00001B7F
.text$mn:00001B7F ; ---------------------------------------------------------------------------
.text$mn:00001B82                 align 4
.text$mn:00001B82 _text$mn        ends
.text$mn:00001B82
.text$mn:00001B84 ; ===========================================================================
.text$mn:00001B84
.text$mn:00001B84 ; Segment type: Pure code
.text$mn:00001B84 ; Segment permissions: Read/Execute
.text$mn:00001B84 _text$mn        segment para public 'CODE' use32
.text$mn:00001B84                 assume cs:_text$mn
.text$mn:00001B84                 ;org 1B84h
.text$mn:00001B84 ; COMDAT (pick any)
.text$mn:00001B84                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001B84
.text$mn:00001B84 ; =============== S U B R O U T I N E =======================================
.text$mn:00001B84
.text$mn:00001B84 ; Attributes: bp-based frame
.text$mn:00001B84
.text$mn:00001B84 ; int __stdcall std::allocator<char>::construct<char *,char * &>(void *, int)
.text$mn:00001B84                 public ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$mn:00001B84 ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
.text$mn:00001B84                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(std::allocator<char> &,char * *,char * &)+17p
.text$mn:00001B84
.text$mn:00001B84 var_1C          = dword ptr -1Ch
.text$mn:00001B84 var_18          = dword ptr -18h
.text$mn:00001B84 var_14          = dword ptr -14h
.text$mn:00001B84 var_10          = dword ptr -10h
.text$mn:00001B84 var_C           = dword ptr -0Ch
.text$mn:00001B84 var_4           = dword ptr -4
.text$mn:00001B84 arg_0           = dword ptr  8
.text$mn:00001B84 arg_4           = dword ptr  0Ch
.text$mn:00001B84
.text$mn:00001B84                 push    ebp
.text$mn:00001B85                 mov     ebp, esp
.text$mn:00001B87                 push    0FFFFFFFFh
.text$mn:00001B89                 push    offset __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$mn:00001B8E                 mov     eax, large fs:0
.text$mn:00001B94                 push    eax
.text$mn:00001B95                 sub     esp, 10h
.text$mn:00001B98                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001B9D                 xor     eax, ebp
.text$mn:00001B9F                 push    eax
.text$mn:00001BA0                 lea     eax, [ebp+var_C]
.text$mn:00001BA3                 mov     large fs:0, eax
.text$mn:00001BA9                 mov     [ebp+var_18], ecx
.text$mn:00001BAC                 mov     eax, [ebp+arg_0]
.text$mn:00001BAF                 push    eax             ; void *
.text$mn:00001BB0                 push    4               ; unsigned int
.text$mn:00001BB2                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00001BB7                 add     esp, 8
.text$mn:00001BBA                 mov     [ebp+var_10], eax
.text$mn:00001BBD                 mov     [ebp+var_4], 0
.text$mn:00001BC4                 cmp     [ebp+var_10], 0
.text$mn:00001BC8                 jz      short loc_1BE5
.text$mn:00001BCA                 mov     ecx, [ebp+arg_4]
.text$mn:00001BCD                 push    ecx
.text$mn:00001BCE                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:00001BD3                 add     esp, 4
.text$mn:00001BD6                 mov     edx, [ebp+var_10]
.text$mn:00001BD9                 mov     eax, [eax]
.text$mn:00001BDB                 mov     [edx], eax
.text$mn:00001BDD                 mov     ecx, [ebp+var_10]
.text$mn:00001BE0                 mov     [ebp+var_14], ecx
.text$mn:00001BE3                 jmp     short loc_1BEC
.text$mn:00001BE5 ; ---------------------------------------------------------------------------
.text$mn:00001BE5
.text$mn:00001BE5 loc_1BE5:                               ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+44j
.text$mn:00001BE5                 mov     [ebp+var_14], 0
.text$mn:00001BEC
.text$mn:00001BEC loc_1BEC:                               ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+5Fj
.text$mn:00001BEC                 mov     edx, [ebp+var_14]
.text$mn:00001BEF                 mov     [ebp+var_1C], edx
.text$mn:00001BF2                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001BF9                 mov     ecx, [ebp+var_C]
.text$mn:00001BFC                 mov     large fs:0, ecx
.text$mn:00001C03                 pop     ecx
.text$mn:00001C04                 mov     esp, ebp
.text$mn:00001C06                 pop     ebp
.text$mn:00001C07                 retn    8
.text$mn:00001C07 ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp
.text$mn:00001C07
.text$mn:00001C07 ; ---------------------------------------------------------------------------
.text$mn:00001C0A                 align 4
.text$mn:00001C0A _text$mn        ends
.text$mn:00001C0A
.text$x:00001C0C ; ===========================================================================
.text$x:00001C0C
.text$x:00001C0C ; Segment type: Pure code
.text$x:00001C0C ; Segment permissions: Read/Execute
.text$x:00001C0C _text$x         segment para public 'CODE' use32
.text$x:00001C0C                 assume cs:_text$x
.text$x:00001C0C                 ;org 1C0Ch
.text$x:00001C0C ; COMDAT (pick associative to section at 1B84)
.text$x:00001C0C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00001C0C
.text$x:00001C0C ; =============== S U B R O U T I N E =======================================
.text$x:00001C0C
.text$x:00001C0C
.text$x:00001C0C __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 proc near
.text$x:00001C0C                                         ; DATA XREF: .xdata$x:0000AD20o
.text$x:00001C0C                 mov     eax, [ebp+8]
.text$x:00001C0F                 push    eax
.text$x:00001C10                 mov     eax, [ebp-10h]
.text$x:00001C13                 push    eax             ; void *
.text$x:00001C14                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00001C19                 add     esp, 8
.text$x:00001C1C                 retn
.text$x:00001C1C __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 endp
.text$x:00001C1C
.text$x:00001C1D
.text$x:00001C1D ; =============== S U B R O U T I N E =======================================
.text$x:00001C1D
.text$x:00001C1D
.text$x:00001C1D __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
.text$x:00001C1D                                         ; DATA XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+5o
.text$x:00001C1D
.text$x:00001C1D arg_4           = dword ptr  8
.text$x:00001C1D
.text$x:00001C1D                 mov     edx, [esp+arg_4]
.text$x:00001C21                 lea     eax, [edx+0Ch]
.text$x:00001C24                 mov     ecx, [edx-14h]
.text$x:00001C27                 xor     ecx, eax
.text$x:00001C29                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001C2E                 mov     eax, offset __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$x:00001C33                 jmp     ___CxxFrameHandler3
.text$x:00001C33 __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp
.text$x:00001C33
.text$x:00001C33 _text$x         ends
.text$x:00001C33
.text$mn:00001C38 ; ===========================================================================
.text$mn:00001C38
.text$mn:00001C38 ; Segment type: Pure code
.text$mn:00001C38 ; Segment permissions: Read/Execute
.text$mn:00001C38 _text$mn        segment para public 'CODE' use32
.text$mn:00001C38                 assume cs:_text$mn
.text$mn:00001C38                 ;org 1C38h
.text$mn:00001C38 ; COMDAT (pick any)
.text$mn:00001C38                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001C38
.text$mn:00001C38 ; =============== S U B R O U T I N E =======================================
.text$mn:00001C38
.text$mn:00001C38 ; Attributes: bp-based frame
.text$mn:00001C38
.text$mn:00001C38 ; int __cdecl std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(int, void *, int)
.text$mn:00001C38                 public ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
.text$mn:00001C38 ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z proc near
.text$mn:00001C38                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)+1Cp
.text$mn:00001C38
.text$mn:00001C38 arg_0           = dword ptr  8
.text$mn:00001C38 arg_4           = dword ptr  0Ch
.text$mn:00001C38 arg_8           = dword ptr  10h
.text$mn:00001C38
.text$mn:00001C38                 push    ebp
.text$mn:00001C39                 mov     ebp, esp
.text$mn:00001C3B                 mov     eax, [ebp+arg_8]
.text$mn:00001C3E                 push    eax
.text$mn:00001C3F                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:00001C44                 add     esp, 4
.text$mn:00001C47                 push    eax             ; int
.text$mn:00001C48                 mov     ecx, [ebp+arg_4]
.text$mn:00001C4B                 push    ecx             ; void *
.text$mn:00001C4C                 mov     ecx, [ebp+arg_0]
.text$mn:00001C4F                 call    ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)
.text$mn:00001C54                 pop     ebp
.text$mn:00001C55                 retn
.text$mn:00001C55 ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z endp
.text$mn:00001C55
.text$mn:00001C55 ; ---------------------------------------------------------------------------
.text$mn:00001C56                 align 4
.text$mn:00001C56 _text$mn        ends
.text$mn:00001C56
.text$mn:00001C58 ; ===========================================================================
.text$mn:00001C58
.text$mn:00001C58 ; Segment type: Pure code
.text$mn:00001C58 ; Segment permissions: Read/Execute
.text$mn:00001C58 _text$mn        segment para public 'CODE' use32
.text$mn:00001C58                 assume cs:_text$mn
.text$mn:00001C58                 ;org 1C58h
.text$mn:00001C58 ; COMDAT (pick any)
.text$mn:00001C58                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001C58
.text$mn:00001C58 ; =============== S U B R O U T I N E =======================================
.text$mn:00001C58
.text$mn:00001C58 ; Attributes: bp-based frame
.text$mn:00001C58
.text$mn:00001C58 ; int __stdcall std::_Wrap_alloc<std::allocator<std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *>>>::construct<std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *,std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> * &>(void *, int)
.text$mn:00001C58                 public ??$construct@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@1@AAPAU21@@Z
.text$mn:00001C58 ??$construct@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@1@AAPAU21@@Z proc near
.text$mn:00001C58                                         ; CODE XREF: std::_List_alloc<0,std::_List_base_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::_Buynode0(std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *,std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *)+88p
.text$mn:00001C58                                         ; std::_List_alloc<0,std::_List_base_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::_Buynode0(std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *,std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *)+B5p
.text$mn:00001C58
.text$mn:00001C58 var_4           = dword ptr -4
.text$mn:00001C58 arg_0           = dword ptr  8
.text$mn:00001C58 arg_4           = dword ptr  0Ch
.text$mn:00001C58
.text$mn:00001C58                 push    ebp
.text$mn:00001C59                 mov     ebp, esp
.text$mn:00001C5B                 push    ecx
.text$mn:00001C5C                 mov     [ebp+var_4], ecx
.text$mn:00001C5F                 mov     eax, [ebp+arg_4]
.text$mn:00001C62                 push    eax
.text$mn:00001C63                 call    ??$forward@AAPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@YAAAPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@0@AAPAU10@@Z ; std::forward<std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> * &>(std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> * &)
.text$mn:00001C68                 add     esp, 4
.text$mn:00001C6B                 push    eax             ; int
.text$mn:00001C6C                 mov     ecx, [ebp+arg_0]
.text$mn:00001C6F                 push    ecx             ; void *
.text$mn:00001C70                 mov     edx, [ebp+var_4]
.text$mn:00001C73                 push    edx             ; int
.text$mn:00001C74                 call    ??$construct@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@1@PAPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@1@AAPAU31@@Z ; std::allocator_traits<std::allocator<std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *>>>::construct<std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *,std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> * &>(std::allocator<std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *>> &,std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> * *,std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> * &)
.text$mn:00001C79                 add     esp, 0Ch
.text$mn:00001C7C                 mov     esp, ebp
.text$mn:00001C7E                 pop     ebp
.text$mn:00001C7F                 retn    8
.text$mn:00001C7F ??$construct@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@1@AAPAU21@@Z endp
.text$mn:00001C7F
.text$mn:00001C7F ; ---------------------------------------------------------------------------
.text$mn:00001C82                 align 4
.text$mn:00001C82 _text$mn        ends
.text$mn:00001C82
.text$mn:00001C84 ; ===========================================================================
.text$mn:00001C84
.text$mn:00001C84 ; Segment type: Pure code
.text$mn:00001C84 ; Segment permissions: Read/Execute
.text$mn:00001C84 _text$mn        segment para public 'CODE' use32
.text$mn:00001C84                 assume cs:_text$mn
.text$mn:00001C84                 ;org 1C84h
.text$mn:00001C84 ; COMDAT (pick any)
.text$mn:00001C84                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001C84
.text$mn:00001C84 ; =============== S U B R O U T I N E =======================================
.text$mn:00001C84
.text$mn:00001C84 ; Attributes: bp-based frame
.text$mn:00001C84
.text$mn:00001C84 ; int __stdcall std::allocator<std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *>>::construct<std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *,std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> * &>(void *, int)
.text$mn:00001C84                 public ??$construct@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@AAPAU12@@?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@QAEXPAPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@1@AAPAU21@@Z
.text$mn:00001C84 ??$construct@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@AAPAU12@@?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@QAEXPAPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@1@AAPAU21@@Z proc near
.text$mn:00001C84                                         ; CODE XREF: std::allocator_traits<std::allocator<std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *>>>::construct<std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *,std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> * &>(std::allocator<std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *>> &,std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> * *,std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pai
.text$mn:00001C84
.text$mn:00001C84 var_1C          = dword ptr -1Ch
.text$mn:00001C84 var_18          = dword ptr -18h
.text$mn:00001C84 var_14          = dword ptr -14h
.text$mn:00001C84 var_10          = dword ptr -10h
.text$mn:00001C84 var_C           = dword ptr -0Ch
.text$mn:00001C84 var_4           = dword ptr -4
.text$mn:00001C84 arg_0           = dword ptr  8
.text$mn:00001C84 arg_4           = dword ptr  0Ch
.text$mn:00001C84
.text$mn:00001C84                 push    ebp
.text$mn:00001C85                 mov     ebp, esp
.text$mn:00001C87                 push    0FFFFFFFFh
.text$mn:00001C89                 push    offset __ehhandler$??$construct@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@AAPAU12@@?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@QAEXPAPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@1@AAPAU21@@Z
.text$mn:00001C8E                 mov     eax, large fs:0
.text$mn:00001C94                 push    eax
.text$mn:00001C95                 sub     esp, 10h
.text$mn:00001C98                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001C9D                 xor     eax, ebp
.text$mn:00001C9F                 push    eax
.text$mn:00001CA0                 lea     eax, [ebp+var_C]
.text$mn:00001CA3                 mov     large fs:0, eax
.text$mn:00001CA9                 mov     [ebp+var_18], ecx
.text$mn:00001CAC                 mov     eax, [ebp+arg_0]
.text$mn:00001CAF                 push    eax             ; void *
.text$mn:00001CB0                 push    4               ; unsigned int
.text$mn:00001CB2                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00001CB7                 add     esp, 8
.text$mn:00001CBA                 mov     [ebp+var_10], eax
.text$mn:00001CBD                 mov     [ebp+var_4], 0
.text$mn:00001CC4                 cmp     [ebp+var_10], 0
.text$mn:00001CC8                 jz      short loc_1CE5
.text$mn:00001CCA                 mov     ecx, [ebp+arg_4]
.text$mn:00001CCD                 push    ecx
.text$mn:00001CCE                 call    ??$forward@AAPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@YAAAPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@0@AAPAU10@@Z ; std::forward<std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> * &>(std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> * &)
.text$mn:00001CD3                 add     esp, 4
.text$mn:00001CD6                 mov     edx, [ebp+var_10]
.text$mn:00001CD9                 mov     eax, [eax]
.text$mn:00001CDB                 mov     [edx], eax
.text$mn:00001CDD                 mov     ecx, [ebp+var_10]
.text$mn:00001CE0                 mov     [ebp+var_14], ecx
.text$mn:00001CE3                 jmp     short loc_1CEC
.text$mn:00001CE5 ; ---------------------------------------------------------------------------
.text$mn:00001CE5
.text$mn:00001CE5 loc_1CE5:                               ; CODE XREF: std::allocator<std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *>>::construct<std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *,std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> * &>(std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> * *,std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> * &)+44j
.text$mn:00001CE5                 mov     [ebp+var_14], 0
.text$mn:00001CEC
.text$mn:00001CEC loc_1CEC:                               ; CODE XREF: std::allocator<std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *>>::construct<std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *,std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> * &>(std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> * *,std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> * &)+5Fj
.text$mn:00001CEC                 mov     edx, [ebp+var_14]
.text$mn:00001CEF                 mov     [ebp+var_1C], edx
.text$mn:00001CF2                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001CF9                 mov     ecx, [ebp+var_C]
.text$mn:00001CFC                 mov     large fs:0, ecx
.text$mn:00001D03                 pop     ecx
.text$mn:00001D04                 mov     esp, ebp
.text$mn:00001D06                 pop     ebp
.text$mn:00001D07                 retn    8
.text$mn:00001D07 ??$construct@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@AAPAU12@@?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@QAEXPAPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@1@AAPAU21@@Z endp
.text$mn:00001D07
.text$mn:00001D07 ; ---------------------------------------------------------------------------
.text$mn:00001D0A                 align 4
.text$mn:00001D0A _text$mn        ends
.text$mn:00001D0A
.text$x:00001D0C ; ===========================================================================
.text$x:00001D0C
.text$x:00001D0C ; Segment type: Pure code
.text$x:00001D0C ; Segment permissions: Read/Execute
.text$x:00001D0C _text$x         segment para public 'CODE' use32
.text$x:00001D0C                 assume cs:_text$x
.text$x:00001D0C                 ;org 1D0Ch
.text$x:00001D0C ; COMDAT (pick associative to section at 1C84)
.text$x:00001D0C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00001D0C
.text$x:00001D0C ; =============== S U B R O U T I N E =======================================
.text$x:00001D0C
.text$x:00001D0C
.text$x:00001D0C __unwindfunclet$??$construct@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@AAPAU12@@?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@QAEXPAPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@1@AAPAU21@@Z$0 proc near
.text$x:00001D0C                                         ; DATA XREF: .xdata$x:0000AD4Co
.text$x:00001D0C                 mov     eax, [ebp+8]
.text$x:00001D0F                 push    eax
.text$x:00001D10                 mov     eax, [ebp-10h]
.text$x:00001D13                 push    eax             ; void *
.text$x:00001D14                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00001D19                 add     esp, 8
.text$x:00001D1C                 retn
.text$x:00001D1C __unwindfunclet$??$construct@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@AAPAU12@@?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@QAEXPAPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@1@AAPAU21@@Z$0 endp
.text$x:00001D1C
.text$x:00001D1D
.text$x:00001D1D ; =============== S U B R O U T I N E =======================================
.text$x:00001D1D
.text$x:00001D1D
.text$x:00001D1D __ehhandler$??$construct@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@AAPAU12@@?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@QAEXPAPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@1@AAPAU21@@Z proc near
.text$x:00001D1D                                         ; DATA XREF: std::allocator<std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *>>::construct<std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *,std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> * &>(std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> * *,std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> * &)+5o
.text$x:00001D1D
.text$x:00001D1D arg_4           = dword ptr  8
.text$x:00001D1D
.text$x:00001D1D                 mov     edx, [esp+arg_4]
.text$x:00001D21                 lea     eax, [edx+0Ch]
.text$x:00001D24                 mov     ecx, [edx-14h]
.text$x:00001D27                 xor     ecx, eax
.text$x:00001D29                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001D2E                 mov     eax, offset __ehfuncinfo$??$construct@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@AAPAU12@@?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@QAEXPAPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@1@AAPAU21@@Z
.text$x:00001D33                 jmp     ___CxxFrameHandler3
.text$x:00001D33 __ehhandler$??$construct@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@AAPAU12@@?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@QAEXPAPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@1@AAPAU21@@Z endp
.text$x:00001D33
.text$x:00001D33 _text$x         ends
.text$x:00001D33
.text$mn:00001D38 ; ===========================================================================
.text$mn:00001D38
.text$mn:00001D38 ; Segment type: Pure code
.text$mn:00001D38 ; Segment permissions: Read/Execute
.text$mn:00001D38 _text$mn        segment para public 'CODE' use32
.text$mn:00001D38                 assume cs:_text$mn
.text$mn:00001D38                 ;org 1D38h
.text$mn:00001D38 ; COMDAT (pick any)
.text$mn:00001D38                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001D38
.text$mn:00001D38 ; =============== S U B R O U T I N E =======================================
.text$mn:00001D38
.text$mn:00001D38 ; Attributes: bp-based frame
.text$mn:00001D38
.text$mn:00001D38 ; int __cdecl std::allocator_traits<std::allocator<std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *>>>::construct<std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *,std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> * &>(int, void *, int)
.text$mn:00001D38                 public ??$construct@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@1@PAPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@1@AAPAU31@@Z
.text$mn:00001D38 ??$construct@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@1@PAPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@1@AAPAU31@@Z proc near
.text$mn:00001D38                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *>>>::construct<std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *,std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> * &>(std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> * *,std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> * &)+1Cp
.text$mn:00001D38
.text$mn:00001D38 arg_0           = dword ptr  8
.text$mn:00001D38 arg_4           = dword ptr  0Ch
.text$mn:00001D38 arg_8           = dword ptr  10h
.text$mn:00001D38
.text$mn:00001D38                 push    ebp
.text$mn:00001D39                 mov     ebp, esp
.text$mn:00001D3B                 mov     eax, [ebp+arg_8]
.text$mn:00001D3E                 push    eax
.text$mn:00001D3F                 call    ??$forward@AAPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@YAAAPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@0@AAPAU10@@Z ; std::forward<std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> * &>(std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> * &)
.text$mn:00001D44                 add     esp, 4
.text$mn:00001D47                 push    eax             ; int
.text$mn:00001D48                 mov     ecx, [ebp+arg_4]
.text$mn:00001D4B                 push    ecx             ; void *
.text$mn:00001D4C                 mov     ecx, [ebp+arg_0]
.text$mn:00001D4F                 call    ??$construct@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@AAPAU12@@?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@QAEXPAPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@1@AAPAU21@@Z ; std::allocator<std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *>>::construct<std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *,std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> * &>(std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> * *,std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> * &)
.text$mn:00001D54                 pop     ebp
.text$mn:00001D55                 retn
.text$mn:00001D55 ??$construct@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@1@PAPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@1@AAPAU31@@Z endp
.text$mn:00001D55
.text$mn:00001D55 ; ---------------------------------------------------------------------------
.text$mn:00001D56                 align 4
.text$mn:00001D56 _text$mn        ends
.text$mn:00001D56
.text$mn:00001D58 ; ===========================================================================
.text$mn:00001D58
.text$mn:00001D58 ; Segment type: Pure code
.text$mn:00001D58 ; Segment permissions: Read/Execute
.text$mn:00001D58 _text$mn        segment para public 'CODE' use32
.text$mn:00001D58                 assume cs:_text$mn
.text$mn:00001D58                 ;org 1D58h
.text$mn:00001D58 ; COMDAT (pick any)
.text$mn:00001D58                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001D58
.text$mn:00001D58 ; =============== S U B R O U T I N E =======================================
.text$mn:00001D58
.text$mn:00001D58 ; Attributes: bp-based frame
.text$mn:00001D58
.text$mn:00001D58 ; int __stdcall std::_Wrap_alloc<std::allocator<ScintillaEditView *>>::construct<ScintillaEditView *,ScintillaEditView * &>(void *, int)
.text$mn:00001D58                 public ??$construct@PAVScintillaEditView@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVScintillaEditView@@@std@@@std@@QAEXPAPAVScintillaEditView@@AAPAV2@@Z
.text$mn:00001D58 ??$construct@PAVScintillaEditView@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVScintillaEditView@@@std@@@std@@QAEXPAPAVScintillaEditView@@AAPAV2@@Z proc near
.text$mn:00001D58                                         ; CODE XREF: std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::push_back(ScintillaEditView * const &)+8Dp
.text$mn:00001D58
.text$mn:00001D58 var_4           = dword ptr -4
.text$mn:00001D58 arg_0           = dword ptr  8
.text$mn:00001D58 arg_4           = dword ptr  0Ch
.text$mn:00001D58
.text$mn:00001D58                 push    ebp
.text$mn:00001D59                 mov     ebp, esp
.text$mn:00001D5B                 push    ecx
.text$mn:00001D5C                 mov     [ebp+var_4], ecx
.text$mn:00001D5F                 mov     eax, [ebp+arg_4]
.text$mn:00001D62                 push    eax
.text$mn:00001D63                 call    ??$forward@AAPAVScintillaEditView@@@std@@YAAAPAVScintillaEditView@@AAPAV1@@Z ; std::forward<ScintillaEditView * &>(ScintillaEditView * &)
.text$mn:00001D68                 add     esp, 4
.text$mn:00001D6B                 push    eax             ; int
.text$mn:00001D6C                 mov     ecx, [ebp+arg_0]
.text$mn:00001D6F                 push    ecx             ; void *
.text$mn:00001D70                 mov     edx, [ebp+var_4]
.text$mn:00001D73                 push    edx             ; int
.text$mn:00001D74                 call    ??$construct@PAVScintillaEditView@@AAPAV1@@?$allocator_traits@V?$allocator@PAVScintillaEditView@@@std@@@std@@SAXAAV?$allocator@PAVScintillaEditView@@@1@PAPAVScintillaEditView@@AAPAV3@@Z ; std::allocator_traits<std::allocator<ScintillaEditView *>>::construct<ScintillaEditView *,ScintillaEditView * &>(std::allocator<ScintillaEditView *> &,ScintillaEditView * *,ScintillaEditView * &)
.text$mn:00001D79                 add     esp, 0Ch
.text$mn:00001D7C                 mov     esp, ebp
.text$mn:00001D7E                 pop     ebp
.text$mn:00001D7F                 retn    8
.text$mn:00001D7F ??$construct@PAVScintillaEditView@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVScintillaEditView@@@std@@@std@@QAEXPAPAVScintillaEditView@@AAPAV2@@Z endp
.text$mn:00001D7F
.text$mn:00001D7F ; ---------------------------------------------------------------------------
.text$mn:00001D82                 align 4
.text$mn:00001D82 _text$mn        ends
.text$mn:00001D82
.text$mn:00001D84 ; ===========================================================================
.text$mn:00001D84
.text$mn:00001D84 ; Segment type: Pure code
.text$mn:00001D84 ; Segment permissions: Read/Execute
.text$mn:00001D84 _text$mn        segment para public 'CODE' use32
.text$mn:00001D84                 assume cs:_text$mn
.text$mn:00001D84                 ;org 1D84h
.text$mn:00001D84 ; COMDAT (pick any)
.text$mn:00001D84                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001D84
.text$mn:00001D84 ; =============== S U B R O U T I N E =======================================
.text$mn:00001D84
.text$mn:00001D84 ; Attributes: bp-based frame
.text$mn:00001D84
.text$mn:00001D84 ; int __stdcall std::allocator<ScintillaEditView *>::construct<ScintillaEditView *,ScintillaEditView * &>(void *, int)
.text$mn:00001D84                 public ??$construct@PAVScintillaEditView@@AAPAV1@@?$allocator@PAVScintillaEditView@@@std@@QAEXPAPAVScintillaEditView@@AAPAV2@@Z
.text$mn:00001D84 ??$construct@PAVScintillaEditView@@AAPAV1@@?$allocator@PAVScintillaEditView@@@std@@QAEXPAPAVScintillaEditView@@AAPAV2@@Z proc near
.text$mn:00001D84                                         ; CODE XREF: std::allocator_traits<std::allocator<ScintillaEditView *>>::construct<ScintillaEditView *,ScintillaEditView * &>(std::allocator<ScintillaEditView *> &,ScintillaEditView * *,ScintillaEditView * &)+17p
.text$mn:00001D84
.text$mn:00001D84 var_1C          = dword ptr -1Ch
.text$mn:00001D84 var_18          = dword ptr -18h
.text$mn:00001D84 var_14          = dword ptr -14h
.text$mn:00001D84 var_10          = dword ptr -10h
.text$mn:00001D84 var_C           = dword ptr -0Ch
.text$mn:00001D84 var_4           = dword ptr -4
.text$mn:00001D84 arg_0           = dword ptr  8
.text$mn:00001D84 arg_4           = dword ptr  0Ch
.text$mn:00001D84
.text$mn:00001D84                 push    ebp
.text$mn:00001D85                 mov     ebp, esp
.text$mn:00001D87                 push    0FFFFFFFFh
.text$mn:00001D89                 push    offset __ehhandler$??$construct@PAVScintillaEditView@@AAPAV1@@?$allocator@PAVScintillaEditView@@@std@@QAEXPAPAVScintillaEditView@@AAPAV2@@Z
.text$mn:00001D8E                 mov     eax, large fs:0
.text$mn:00001D94                 push    eax
.text$mn:00001D95                 sub     esp, 10h
.text$mn:00001D98                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001D9D                 xor     eax, ebp
.text$mn:00001D9F                 push    eax
.text$mn:00001DA0                 lea     eax, [ebp+var_C]
.text$mn:00001DA3                 mov     large fs:0, eax
.text$mn:00001DA9                 mov     [ebp+var_18], ecx
.text$mn:00001DAC                 mov     eax, [ebp+arg_0]
.text$mn:00001DAF                 push    eax             ; void *
.text$mn:00001DB0                 push    4               ; unsigned int
.text$mn:00001DB2                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00001DB7                 add     esp, 8
.text$mn:00001DBA                 mov     [ebp+var_10], eax
.text$mn:00001DBD                 mov     [ebp+var_4], 0
.text$mn:00001DC4                 cmp     [ebp+var_10], 0
.text$mn:00001DC8                 jz      short loc_1DE5
.text$mn:00001DCA                 mov     ecx, [ebp+arg_4]
.text$mn:00001DCD                 push    ecx
.text$mn:00001DCE                 call    ??$forward@AAPAVScintillaEditView@@@std@@YAAAPAVScintillaEditView@@AAPAV1@@Z ; std::forward<ScintillaEditView * &>(ScintillaEditView * &)
.text$mn:00001DD3                 add     esp, 4
.text$mn:00001DD6                 mov     edx, [ebp+var_10]
.text$mn:00001DD9                 mov     eax, [eax]
.text$mn:00001DDB                 mov     [edx], eax
.text$mn:00001DDD                 mov     ecx, [ebp+var_10]
.text$mn:00001DE0                 mov     [ebp+var_14], ecx
.text$mn:00001DE3                 jmp     short loc_1DEC
.text$mn:00001DE5 ; ---------------------------------------------------------------------------
.text$mn:00001DE5
.text$mn:00001DE5 loc_1DE5:                               ; CODE XREF: std::allocator<ScintillaEditView *>::construct<ScintillaEditView *,ScintillaEditView * &>(ScintillaEditView * *,ScintillaEditView * &)+44j
.text$mn:00001DE5                 mov     [ebp+var_14], 0
.text$mn:00001DEC
.text$mn:00001DEC loc_1DEC:                               ; CODE XREF: std::allocator<ScintillaEditView *>::construct<ScintillaEditView *,ScintillaEditView * &>(ScintillaEditView * *,ScintillaEditView * &)+5Fj
.text$mn:00001DEC                 mov     edx, [ebp+var_14]
.text$mn:00001DEF                 mov     [ebp+var_1C], edx
.text$mn:00001DF2                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001DF9                 mov     ecx, [ebp+var_C]
.text$mn:00001DFC                 mov     large fs:0, ecx
.text$mn:00001E03                 pop     ecx
.text$mn:00001E04                 mov     esp, ebp
.text$mn:00001E06                 pop     ebp
.text$mn:00001E07                 retn    8
.text$mn:00001E07 ??$construct@PAVScintillaEditView@@AAPAV1@@?$allocator@PAVScintillaEditView@@@std@@QAEXPAPAVScintillaEditView@@AAPAV2@@Z endp
.text$mn:00001E07
.text$mn:00001E07 ; ---------------------------------------------------------------------------
.text$mn:00001E0A                 align 4
.text$mn:00001E0A _text$mn        ends
.text$mn:00001E0A
.text$x:00001E0C ; ===========================================================================
.text$x:00001E0C
.text$x:00001E0C ; Segment type: Pure code
.text$x:00001E0C ; Segment permissions: Read/Execute
.text$x:00001E0C _text$x         segment para public 'CODE' use32
.text$x:00001E0C                 assume cs:_text$x
.text$x:00001E0C                 ;org 1E0Ch
.text$x:00001E0C ; COMDAT (pick associative to section at 1D84)
.text$x:00001E0C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00001E0C
.text$x:00001E0C ; =============== S U B R O U T I N E =======================================
.text$x:00001E0C
.text$x:00001E0C
.text$x:00001E0C __unwindfunclet$??$construct@PAVScintillaEditView@@AAPAV1@@?$allocator@PAVScintillaEditView@@@std@@QAEXPAPAVScintillaEditView@@AAPAV2@@Z$0 proc near
.text$x:00001E0C                                         ; DATA XREF: .xdata$x:0000ACF4o
.text$x:00001E0C                 mov     eax, [ebp+8]
.text$x:00001E0F                 push    eax
.text$x:00001E10                 mov     eax, [ebp-10h]
.text$x:00001E13                 push    eax             ; void *
.text$x:00001E14                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00001E19                 add     esp, 8
.text$x:00001E1C                 retn
.text$x:00001E1C __unwindfunclet$??$construct@PAVScintillaEditView@@AAPAV1@@?$allocator@PAVScintillaEditView@@@std@@QAEXPAPAVScintillaEditView@@AAPAV2@@Z$0 endp
.text$x:00001E1C
.text$x:00001E1D
.text$x:00001E1D ; =============== S U B R O U T I N E =======================================
.text$x:00001E1D
.text$x:00001E1D
.text$x:00001E1D __ehhandler$??$construct@PAVScintillaEditView@@AAPAV1@@?$allocator@PAVScintillaEditView@@@std@@QAEXPAPAVScintillaEditView@@AAPAV2@@Z proc near
.text$x:00001E1D                                         ; DATA XREF: std::allocator<ScintillaEditView *>::construct<ScintillaEditView *,ScintillaEditView * &>(ScintillaEditView * *,ScintillaEditView * &)+5o
.text$x:00001E1D
.text$x:00001E1D arg_4           = dword ptr  8
.text$x:00001E1D
.text$x:00001E1D                 mov     edx, [esp+arg_4]
.text$x:00001E21                 lea     eax, [edx+0Ch]
.text$x:00001E24                 mov     ecx, [edx-14h]
.text$x:00001E27                 xor     ecx, eax
.text$x:00001E29                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001E2E                 mov     eax, offset __ehfuncinfo$??$construct@PAVScintillaEditView@@AAPAV1@@?$allocator@PAVScintillaEditView@@@std@@QAEXPAPAVScintillaEditView@@AAPAV2@@Z
.text$x:00001E33                 jmp     ___CxxFrameHandler3
.text$x:00001E33 __ehhandler$??$construct@PAVScintillaEditView@@AAPAV1@@?$allocator@PAVScintillaEditView@@@std@@QAEXPAPAVScintillaEditView@@AAPAV2@@Z endp
.text$x:00001E33
.text$x:00001E33 _text$x         ends
.text$x:00001E33
.text$mn:00001E38 ; ===========================================================================
.text$mn:00001E38
.text$mn:00001E38 ; Segment type: Pure code
.text$mn:00001E38 ; Segment permissions: Read/Execute
.text$mn:00001E38 _text$mn        segment para public 'CODE' use32
.text$mn:00001E38                 assume cs:_text$mn
.text$mn:00001E38                 ;org 1E38h
.text$mn:00001E38 ; COMDAT (pick any)
.text$mn:00001E38                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001E38
.text$mn:00001E38 ; =============== S U B R O U T I N E =======================================
.text$mn:00001E38
.text$mn:00001E38 ; Attributes: bp-based frame
.text$mn:00001E38
.text$mn:00001E38 ; int __cdecl std::allocator_traits<std::allocator<ScintillaEditView *>>::construct<ScintillaEditView *,ScintillaEditView * &>(int, void *, int)
.text$mn:00001E38                 public ??$construct@PAVScintillaEditView@@AAPAV1@@?$allocator_traits@V?$allocator@PAVScintillaEditView@@@std@@@std@@SAXAAV?$allocator@PAVScintillaEditView@@@1@PAPAVScintillaEditView@@AAPAV3@@Z
.text$mn:00001E38 ??$construct@PAVScintillaEditView@@AAPAV1@@?$allocator_traits@V?$allocator@PAVScintillaEditView@@@std@@@std@@SAXAAV?$allocator@PAVScintillaEditView@@@1@PAPAVScintillaEditView@@AAPAV3@@Z proc near
.text$mn:00001E38                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<ScintillaEditView *>>::construct<ScintillaEditView *,ScintillaEditView * &>(ScintillaEditView * *,ScintillaEditView * &)+1Cp
.text$mn:00001E38
.text$mn:00001E38 arg_0           = dword ptr  8
.text$mn:00001E38 arg_4           = dword ptr  0Ch
.text$mn:00001E38 arg_8           = dword ptr  10h
.text$mn:00001E38
.text$mn:00001E38                 push    ebp
.text$mn:00001E39                 mov     ebp, esp
.text$mn:00001E3B                 mov     eax, [ebp+arg_8]
.text$mn:00001E3E                 push    eax
.text$mn:00001E3F                 call    ??$forward@AAPAVScintillaEditView@@@std@@YAAAPAVScintillaEditView@@AAPAV1@@Z ; std::forward<ScintillaEditView * &>(ScintillaEditView * &)
.text$mn:00001E44                 add     esp, 4
.text$mn:00001E47                 push    eax             ; int
.text$mn:00001E48                 mov     ecx, [ebp+arg_4]
.text$mn:00001E4B                 push    ecx             ; void *
.text$mn:00001E4C                 mov     ecx, [ebp+arg_0]
.text$mn:00001E4F                 call    ??$construct@PAVScintillaEditView@@AAPAV1@@?$allocator@PAVScintillaEditView@@@std@@QAEXPAPAVScintillaEditView@@AAPAV2@@Z ; std::allocator<ScintillaEditView *>::construct<ScintillaEditView *,ScintillaEditView * &>(ScintillaEditView * *,ScintillaEditView * &)
.text$mn:00001E54                 pop     ebp
.text$mn:00001E55                 retn
.text$mn:00001E55 ??$construct@PAVScintillaEditView@@AAPAV1@@?$allocator_traits@V?$allocator@PAVScintillaEditView@@@std@@@std@@SAXAAV?$allocator@PAVScintillaEditView@@@1@PAPAVScintillaEditView@@AAPAV3@@Z endp
.text$mn:00001E55
.text$mn:00001E55 ; ---------------------------------------------------------------------------
.text$mn:00001E56                 align 4
.text$mn:00001E56 _text$mn        ends
.text$mn:00001E56
.text$mn:00001E58 ; ===========================================================================
.text$mn:00001E58
.text$mn:00001E58 ; Segment type: Pure code
.text$mn:00001E58 ; Segment permissions: Read/Execute
.text$mn:00001E58 _text$mn        segment para public 'CODE' use32
.text$mn:00001E58                 assume cs:_text$mn
.text$mn:00001E58                 ;org 1E58h
.text$mn:00001E58 ; COMDAT (pick any)
.text$mn:00001E58                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001E58
.text$mn:00001E58 ; =============== S U B R O U T I N E =======================================
.text$mn:00001E58
.text$mn:00001E58 ; Attributes: bp-based frame
.text$mn:00001E58
.text$mn:00001E58 ; int __stdcall std::_Wrap_alloc<std::allocator<ScintillaEditView *>>::construct<ScintillaEditView *,ScintillaEditView * const &>(void *, int)
.text$mn:00001E58                 public ??$construct@PAVScintillaEditView@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVScintillaEditView@@@std@@@std@@QAEXPAPAVScintillaEditView@@ABQAV2@@Z
.text$mn:00001E58 ??$construct@PAVScintillaEditView@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVScintillaEditView@@@std@@@std@@QAEXPAPAVScintillaEditView@@ABQAV2@@Z proc near
.text$mn:00001E58                                         ; CODE XREF: std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::push_back(ScintillaEditView * const &)+EAp
.text$mn:00001E58
.text$mn:00001E58 var_4           = dword ptr -4
.text$mn:00001E58 arg_0           = dword ptr  8
.text$mn:00001E58 arg_4           = dword ptr  0Ch
.text$mn:00001E58
.text$mn:00001E58                 push    ebp
.text$mn:00001E59                 mov     ebp, esp
.text$mn:00001E5B                 push    ecx
.text$mn:00001E5C                 mov     [ebp+var_4], ecx
.text$mn:00001E5F                 mov     eax, [ebp+arg_4]
.text$mn:00001E62                 push    eax
.text$mn:00001E63                 call    ??$forward@ABQAVScintillaEditView@@@std@@YAABQAVScintillaEditView@@ABQAV1@@Z ; std::forward<ScintillaEditView * const &>(ScintillaEditView * const &)
.text$mn:00001E68                 add     esp, 4
.text$mn:00001E6B                 push    eax             ; int
.text$mn:00001E6C                 mov     ecx, [ebp+arg_0]
.text$mn:00001E6F                 push    ecx             ; void *
.text$mn:00001E70                 mov     edx, [ebp+var_4]
.text$mn:00001E73                 push    edx             ; int
.text$mn:00001E74                 call    ??$construct@PAVScintillaEditView@@ABQAV1@@?$allocator_traits@V?$allocator@PAVScintillaEditView@@@std@@@std@@SAXAAV?$allocator@PAVScintillaEditView@@@1@PAPAVScintillaEditView@@ABQAV3@@Z ; std::allocator_traits<std::allocator<ScintillaEditView *>>::construct<ScintillaEditView *,ScintillaEditView * const &>(std::allocator<ScintillaEditView *> &,ScintillaEditView * *,ScintillaEditView * const &)
.text$mn:00001E79                 add     esp, 0Ch
.text$mn:00001E7C                 mov     esp, ebp
.text$mn:00001E7E                 pop     ebp
.text$mn:00001E7F                 retn    8
.text$mn:00001E7F ??$construct@PAVScintillaEditView@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVScintillaEditView@@@std@@@std@@QAEXPAPAVScintillaEditView@@ABQAV2@@Z endp
.text$mn:00001E7F
.text$mn:00001E7F ; ---------------------------------------------------------------------------
.text$mn:00001E82                 align 4
.text$mn:00001E82 _text$mn        ends
.text$mn:00001E82
.text$mn:00001E84 ; ===========================================================================
.text$mn:00001E84
.text$mn:00001E84 ; Segment type: Pure code
.text$mn:00001E84 ; Segment permissions: Read/Execute
.text$mn:00001E84 _text$mn        segment para public 'CODE' use32
.text$mn:00001E84                 assume cs:_text$mn
.text$mn:00001E84                 ;org 1E84h
.text$mn:00001E84 ; COMDAT (pick any)
.text$mn:00001E84                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001E84
.text$mn:00001E84 ; =============== S U B R O U T I N E =======================================
.text$mn:00001E84
.text$mn:00001E84 ; Attributes: bp-based frame
.text$mn:00001E84
.text$mn:00001E84 ; int __cdecl std::allocator_traits<std::allocator<ScintillaEditView *>>::construct<ScintillaEditView *,ScintillaEditView * const &>(int, void *, int)
.text$mn:00001E84                 public ??$construct@PAVScintillaEditView@@ABQAV1@@?$allocator_traits@V?$allocator@PAVScintillaEditView@@@std@@@std@@SAXAAV?$allocator@PAVScintillaEditView@@@1@PAPAVScintillaEditView@@ABQAV3@@Z
.text$mn:00001E84 ??$construct@PAVScintillaEditView@@ABQAV1@@?$allocator_traits@V?$allocator@PAVScintillaEditView@@@std@@@std@@SAXAAV?$allocator@PAVScintillaEditView@@@1@PAPAVScintillaEditView@@ABQAV3@@Z proc near
.text$mn:00001E84                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<ScintillaEditView *>>::construct<ScintillaEditView *,ScintillaEditView * const &>(ScintillaEditView * *,ScintillaEditView * const &)+1Cp
.text$mn:00001E84
.text$mn:00001E84 arg_0           = dword ptr  8
.text$mn:00001E84 arg_4           = dword ptr  0Ch
.text$mn:00001E84 arg_8           = dword ptr  10h
.text$mn:00001E84
.text$mn:00001E84                 push    ebp
.text$mn:00001E85                 mov     ebp, esp
.text$mn:00001E87                 mov     eax, [ebp+arg_8]
.text$mn:00001E8A                 push    eax
.text$mn:00001E8B                 call    ??$forward@ABQAVScintillaEditView@@@std@@YAABQAVScintillaEditView@@ABQAV1@@Z ; std::forward<ScintillaEditView * const &>(ScintillaEditView * const &)
.text$mn:00001E90                 add     esp, 4
.text$mn:00001E93                 push    eax             ; int
.text$mn:00001E94                 mov     ecx, [ebp+arg_4]
.text$mn:00001E97                 push    ecx             ; void *
.text$mn:00001E98                 mov     ecx, [ebp+arg_0]
.text$mn:00001E9B                 call    ?construct@?$allocator@PAVScintillaEditView@@@std@@QAEXPAPAVScintillaEditView@@ABQAV3@@Z ; std::allocator<ScintillaEditView *>::construct(ScintillaEditView * *,ScintillaEditView * const &)
.text$mn:00001EA0                 pop     ebp
.text$mn:00001EA1                 retn
.text$mn:00001EA1 ??$construct@PAVScintillaEditView@@ABQAV1@@?$allocator_traits@V?$allocator@PAVScintillaEditView@@@std@@@std@@SAXAAV?$allocator@PAVScintillaEditView@@@1@PAPAVScintillaEditView@@ABQAV3@@Z endp
.text$mn:00001EA1
.text$mn:00001EA1 ; ---------------------------------------------------------------------------
.text$mn:00001EA2                 align 4
.text$mn:00001EA2 _text$mn        ends
.text$mn:00001EA2
.text$mn:00001EA4 ; ===========================================================================
.text$mn:00001EA4
.text$mn:00001EA4 ; Segment type: Pure code
.text$mn:00001EA4 ; Segment permissions: Read/Execute
.text$mn:00001EA4 _text$mn        segment para public 'CODE' use32
.text$mn:00001EA4                 assume cs:_text$mn
.text$mn:00001EA4                 ;org 1EA4h
.text$mn:00001EA4 ; COMDAT (pick any)
.text$mn:00001EA4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001EA4
.text$mn:00001EA4 ; =============== S U B R O U T I N E =======================================
.text$mn:00001EA4
.text$mn:00001EA4 ; Attributes: bp-based frame
.text$mn:00001EA4
.text$mn:00001EA4 ; int __stdcall std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_Container_proxy>>>::construct<std::_Container_proxy,std::_Container_proxy>(void *, int)
.text$mn:00001EA4                 public ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:00001EA4 ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$mn:00001EA4                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>>::_Alloc_proxy(void)+32p
.text$mn:00001EA4
.text$mn:00001EA4 var_4           = dword ptr -4
.text$mn:00001EA4 arg_0           = dword ptr  8
.text$mn:00001EA4 arg_4           = dword ptr  0Ch
.text$mn:00001EA4
.text$mn:00001EA4                 push    ebp
.text$mn:00001EA5                 mov     ebp, esp
.text$mn:00001EA7                 push    ecx
.text$mn:00001EA8                 mov     [ebp+var_4], ecx
.text$mn:00001EAB                 mov     eax, [ebp+arg_4]
.text$mn:00001EAE                 push    eax
.text$mn:00001EAF                 call    ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>(std::_Container_proxy &)
.text$mn:00001EB4                 add     esp, 4
.text$mn:00001EB7                 push    eax             ; int
.text$mn:00001EB8                 mov     ecx, [ebp+arg_0]
.text$mn:00001EBB                 push    ecx             ; void *
.text$mn:00001EBC                 mov     edx, [ebp+var_4]
.text$mn:00001EBF                 push    edx             ; int
.text$mn:00001EC0                 call    ??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@U?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@@std@@SAXAAU?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z ; std::allocator_traits<std::_Wrap_alloc<std::allocator<std::_Container_proxy>>>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Wrap_alloc<std::allocator<std::_Container_proxy>> &,std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:00001EC5                 add     esp, 0Ch
.text$mn:00001EC8                 mov     esp, ebp
.text$mn:00001ECA                 pop     ebp
.text$mn:00001ECB                 retn    8
.text$mn:00001ECB ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$mn:00001ECB
.text$mn:00001ECB ; ---------------------------------------------------------------------------
.text$mn:00001ECE                 align 10h
.text$mn:00001ECE _text$mn        ends
.text$mn:00001ECE
.text$mn:00001ED0 ; ===========================================================================
.text$mn:00001ED0
.text$mn:00001ED0 ; Segment type: Pure code
.text$mn:00001ED0 ; Segment permissions: Read/Execute
.text$mn:00001ED0 _text$mn        segment para public 'CODE' use32
.text$mn:00001ED0                 assume cs:_text$mn
.text$mn:00001ED0                 ;org 1ED0h
.text$mn:00001ED0 ; COMDAT (pick any)
.text$mn:00001ED0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001ED0
.text$mn:00001ED0 ; =============== S U B R O U T I N E =======================================
.text$mn:00001ED0
.text$mn:00001ED0 ; Attributes: bp-based frame
.text$mn:00001ED0
.text$mn:00001ED0 ; int __stdcall std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(void *, int)
.text$mn:00001ED0                 public ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:00001ED0 ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$mn:00001ED0                                         ; CODE XREF: std::_Alloc_construct::_Fn<std::_Wrap_alloc<std::allocator<std::_Container_proxy>>,std::_Container_proxy,std::_Container_proxy>(int,std::_Wrap_alloc<std::allocator<std::_Container_proxy>> &,std::_Container_proxy *,std::_Container_proxy &&)+17p
.text$mn:00001ED0                                         ; std::_List_alloc<0,std::_List_base_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::_Alloc_proxy(void)+32p
.text$mn:00001ED0
.text$mn:00001ED0 var_4           = dword ptr -4
.text$mn:00001ED0 arg_0           = dword ptr  8
.text$mn:00001ED0 arg_4           = dword ptr  0Ch
.text$mn:00001ED0
.text$mn:00001ED0                 push    ebp
.text$mn:00001ED1                 mov     ebp, esp
.text$mn:00001ED3                 push    ecx
.text$mn:00001ED4                 mov     [ebp+var_4], ecx
.text$mn:00001ED7                 mov     eax, [ebp+arg_4]
.text$mn:00001EDA                 push    eax
.text$mn:00001EDB                 call    ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>(std::_Container_proxy &)
.text$mn:00001EE0                 add     esp, 4
.text$mn:00001EE3                 push    eax             ; int
.text$mn:00001EE4                 mov     ecx, [ebp+arg_0]
.text$mn:00001EE7                 push    ecx             ; void *
.text$mn:00001EE8                 mov     edx, [ebp+var_4]
.text$mn:00001EEB                 push    edx             ; int
.text$mn:00001EEC                 call    ??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z ; std::allocator_traits<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(std::allocator<std::_Container_proxy> &,std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:00001EF1                 add     esp, 0Ch
.text$mn:00001EF4                 mov     esp, ebp
.text$mn:00001EF6                 pop     ebp
.text$mn:00001EF7                 retn    8
.text$mn:00001EF7 ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$mn:00001EF7
.text$mn:00001EF7 ; ---------------------------------------------------------------------------
.text$mn:00001EFA                 align 4
.text$mn:00001EFA _text$mn        ends
.text$mn:00001EFA
.text$mn:00001EFC ; ===========================================================================
.text$mn:00001EFC
.text$mn:00001EFC ; Segment type: Pure code
.text$mn:00001EFC ; Segment permissions: Read/Execute
.text$mn:00001EFC _text$mn        segment para public 'CODE' use32
.text$mn:00001EFC                 assume cs:_text$mn
.text$mn:00001EFC                 ;org 1EFCh
.text$mn:00001EFC ; COMDAT (pick any)
.text$mn:00001EFC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001EFC
.text$mn:00001EFC ; =============== S U B R O U T I N E =======================================
.text$mn:00001EFC
.text$mn:00001EFC ; Attributes: bp-based frame
.text$mn:00001EFC
.text$mn:00001EFC ; int __stdcall std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(void *, int)
.text$mn:00001EFC                 public ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:00001EFC ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$mn:00001EFC                                         ; CODE XREF: std::allocator_traits<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(std::allocator<std::_Container_proxy> &,std::_Container_proxy *,std::_Container_proxy &&)+17p
.text$mn:00001EFC                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+32p
.text$mn:00001EFC
.text$mn:00001EFC var_1C          = dword ptr -1Ch
.text$mn:00001EFC var_18          = dword ptr -18h
.text$mn:00001EFC var_14          = dword ptr -14h
.text$mn:00001EFC var_10          = dword ptr -10h
.text$mn:00001EFC var_C           = dword ptr -0Ch
.text$mn:00001EFC var_4           = dword ptr -4
.text$mn:00001EFC arg_0           = dword ptr  8
.text$mn:00001EFC arg_4           = dword ptr  0Ch
.text$mn:00001EFC
.text$mn:00001EFC                 push    ebp
.text$mn:00001EFD                 mov     ebp, esp
.text$mn:00001EFF                 push    0FFFFFFFFh
.text$mn:00001F01                 push    offset __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:00001F06                 mov     eax, large fs:0
.text$mn:00001F0C                 push    eax
.text$mn:00001F0D                 sub     esp, 10h
.text$mn:00001F10                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001F15                 xor     eax, ebp
.text$mn:00001F17                 push    eax
.text$mn:00001F18                 lea     eax, [ebp+var_C]
.text$mn:00001F1B                 mov     large fs:0, eax
.text$mn:00001F21                 mov     [ebp+var_18], ecx
.text$mn:00001F24                 mov     eax, [ebp+arg_0]
.text$mn:00001F27                 push    eax             ; void *
.text$mn:00001F28                 push    8               ; unsigned int
.text$mn:00001F2A                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00001F2F                 add     esp, 8
.text$mn:00001F32                 mov     [ebp+var_10], eax
.text$mn:00001F35                 mov     [ebp+var_4], 0
.text$mn:00001F3C                 cmp     [ebp+var_10], 0
.text$mn:00001F40                 jz      short loc_1F63
.text$mn:00001F42                 mov     ecx, [ebp+arg_4]
.text$mn:00001F45                 push    ecx
.text$mn:00001F46                 call    ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>(std::_Container_proxy &)
.text$mn:00001F4B                 add     esp, 4
.text$mn:00001F4E                 mov     edx, [eax]
.text$mn:00001F50                 mov     eax, [eax+4]
.text$mn:00001F53                 mov     ecx, [ebp+var_10]
.text$mn:00001F56                 mov     [ecx], edx
.text$mn:00001F58                 mov     [ecx+4], eax
.text$mn:00001F5B                 mov     edx, [ebp+var_10]
.text$mn:00001F5E                 mov     [ebp+var_14], edx
.text$mn:00001F61                 jmp     short loc_1F6A
.text$mn:00001F63 ; ---------------------------------------------------------------------------
.text$mn:00001F63
.text$mn:00001F63 loc_1F63:                               ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+44j
.text$mn:00001F63                 mov     [ebp+var_14], 0
.text$mn:00001F6A
.text$mn:00001F6A loc_1F6A:                               ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+65j
.text$mn:00001F6A                 mov     eax, [ebp+var_14]
.text$mn:00001F6D                 mov     [ebp+var_1C], eax
.text$mn:00001F70                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001F77                 mov     ecx, [ebp+var_C]
.text$mn:00001F7A                 mov     large fs:0, ecx
.text$mn:00001F81                 pop     ecx
.text$mn:00001F82                 mov     esp, ebp
.text$mn:00001F84                 pop     ebp
.text$mn:00001F85                 retn    8
.text$mn:00001F85 ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$mn:00001F85
.text$mn:00001F85 _text$mn        ends
.text$mn:00001F85
.text$x:00001F88 ; ===========================================================================
.text$x:00001F88
.text$x:00001F88 ; Segment type: Pure code
.text$x:00001F88 ; Segment permissions: Read/Execute
.text$x:00001F88 _text$x         segment para public 'CODE' use32
.text$x:00001F88                 assume cs:_text$x
.text$x:00001F88                 ;org 1F88h
.text$x:00001F88 ; COMDAT (pick associative to section at 1EFC)
.text$x:00001F88                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00001F88
.text$x:00001F88 ; =============== S U B R O U T I N E =======================================
.text$x:00001F88
.text$x:00001F88
.text$x:00001F88 __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 proc near
.text$x:00001F88                                         ; DATA XREF: .xdata$x:0000AAB0o
.text$x:00001F88                 mov     eax, [ebp+8]
.text$x:00001F8B                 push    eax
.text$x:00001F8C                 mov     eax, [ebp-10h]
.text$x:00001F8F                 push    eax             ; void *
.text$x:00001F90                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00001F95                 add     esp, 8
.text$x:00001F98                 retn
.text$x:00001F98 __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 endp
.text$x:00001F98
.text$x:00001F99
.text$x:00001F99 ; =============== S U B R O U T I N E =======================================
.text$x:00001F99
.text$x:00001F99
.text$x:00001F99 __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$x:00001F99                                         ; DATA XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+5o
.text$x:00001F99
.text$x:00001F99 arg_4           = dword ptr  8
.text$x:00001F99
.text$x:00001F99                 mov     edx, [esp+arg_4]
.text$x:00001F9D                 lea     eax, [edx+0Ch]
.text$x:00001FA0                 mov     ecx, [edx-14h]
.text$x:00001FA3                 xor     ecx, eax
.text$x:00001FA5                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001FAA                 mov     eax, offset __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$x:00001FAF                 jmp     ___CxxFrameHandler3
.text$x:00001FAF __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$x:00001FAF
.text$x:00001FAF _text$x         ends
.text$x:00001FAF
.text$mn:00001FB4 ; ===========================================================================
.text$mn:00001FB4
.text$mn:00001FB4 ; Segment type: Pure code
.text$mn:00001FB4 ; Segment permissions: Read/Execute
.text$mn:00001FB4 _text$mn        segment para public 'CODE' use32
.text$mn:00001FB4                 assume cs:_text$mn
.text$mn:00001FB4                 ;org 1FB4h
.text$mn:00001FB4 ; COMDAT (pick any)
.text$mn:00001FB4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001FB4
.text$mn:00001FB4 ; =============== S U B R O U T I N E =======================================
.text$mn:00001FB4
.text$mn:00001FB4 ; Attributes: bp-based frame
.text$mn:00001FB4
.text$mn:00001FB4 ; int __cdecl std::allocator_traits<std::_Wrap_alloc<std::allocator<std::_Container_proxy>>>::construct<std::_Container_proxy,std::_Container_proxy>(int, void *, int)
.text$mn:00001FB4                 public ??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@U?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@@std@@SAXAAU?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z
.text$mn:00001FB4 ??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@U?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@@std@@SAXAAU?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z proc near
.text$mn:00001FB4                                         ; CODE XREF: std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_Container_proxy>>>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+1Cp
.text$mn:00001FB4
.text$mn:00001FB4 arg_0           = dword ptr  8
.text$mn:00001FB4 arg_4           = dword ptr  0Ch
.text$mn:00001FB4 arg_8           = dword ptr  10h
.text$mn:00001FB4
.text$mn:00001FB4                 push    ebp
.text$mn:00001FB5                 mov     ebp, esp
.text$mn:00001FB7                 mov     eax, [ebp+arg_8]
.text$mn:00001FBA                 push    eax
.text$mn:00001FBB                 call    ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>(std::_Container_proxy &)
.text$mn:00001FC0                 add     esp, 4
.text$mn:00001FC3                 push    eax             ; int
.text$mn:00001FC4                 mov     ecx, [ebp+arg_4]
.text$mn:00001FC7                 push    ecx             ; void *
.text$mn:00001FC8                 mov     edx, [ebp+arg_0]
.text$mn:00001FCB                 push    edx             ; int
.text$mn:00001FCC                 push    0               ; int
.text$mn:00001FCE                 call    ??$_Fn@U?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@U_Container_proxy@2@U32@@_Alloc_construct@std@@SAXHAAU?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z ; std::_Alloc_construct::_Fn<std::_Wrap_alloc<std::allocator<std::_Container_proxy>>,std::_Container_proxy,std::_Container_proxy>(int,std::_Wrap_alloc<std::allocator<std::_Container_proxy>> &,std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:00001FD3                 add     esp, 10h
.text$mn:00001FD6                 pop     ebp
.text$mn:00001FD7                 retn
.text$mn:00001FD7 ??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@U?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@@std@@SAXAAU?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z endp
.text$mn:00001FD7
.text$mn:00001FD7 _text$mn        ends
.text$mn:00001FD7
.text$mn:00001FD8 ; ===========================================================================
.text$mn:00001FD8
.text$mn:00001FD8 ; Segment type: Pure code
.text$mn:00001FD8 ; Segment permissions: Read/Execute
.text$mn:00001FD8 _text$mn        segment para public 'CODE' use32
.text$mn:00001FD8                 assume cs:_text$mn
.text$mn:00001FD8                 ;org 1FD8h
.text$mn:00001FD8 ; COMDAT (pick any)
.text$mn:00001FD8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001FD8
.text$mn:00001FD8 ; =============== S U B R O U T I N E =======================================
.text$mn:00001FD8
.text$mn:00001FD8 ; Attributes: bp-based frame
.text$mn:00001FD8
.text$mn:00001FD8 ; int __cdecl std::allocator_traits<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(int, void *, int)
.text$mn:00001FD8                 public ??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z
.text$mn:00001FD8 ??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z proc near
.text$mn:00001FD8                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+1Cp
.text$mn:00001FD8
.text$mn:00001FD8 arg_0           = dword ptr  8
.text$mn:00001FD8 arg_4           = dword ptr  0Ch
.text$mn:00001FD8 arg_8           = dword ptr  10h
.text$mn:00001FD8
.text$mn:00001FD8                 push    ebp
.text$mn:00001FD9                 mov     ebp, esp
.text$mn:00001FDB                 mov     eax, [ebp+arg_8]
.text$mn:00001FDE                 push    eax
.text$mn:00001FDF                 call    ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>(std::_Container_proxy &)
.text$mn:00001FE4                 add     esp, 4
.text$mn:00001FE7                 push    eax             ; int
.text$mn:00001FE8                 mov     ecx, [ebp+arg_4]
.text$mn:00001FEB                 push    ecx             ; void *
.text$mn:00001FEC                 mov     ecx, [ebp+arg_0]
.text$mn:00001FEF                 call    ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:00001FF4                 pop     ebp
.text$mn:00001FF5                 retn
.text$mn:00001FF5 ??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z endp
.text$mn:00001FF5
.text$mn:00001FF5 ; ---------------------------------------------------------------------------
.text$mn:00001FF6                 align 4
.text$mn:00001FF6 _text$mn        ends
.text$mn:00001FF6
.text$mn:00001FF8 ; ===========================================================================
.text$mn:00001FF8
.text$mn:00001FF8 ; Segment type: Pure code
.text$mn:00001FF8 ; Segment permissions: Read/Execute
.text$mn:00001FF8 _text$mn        segment para public 'CODE' use32
.text$mn:00001FF8                 assume cs:_text$mn
.text$mn:00001FF8                 ;org 1FF8h
.text$mn:00001FF8 ; COMDAT (pick any)
.text$mn:00001FF8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001FF8
.text$mn:00001FF8 ; =============== S U B R O U T I N E =======================================
.text$mn:00001FF8
.text$mn:00001FF8 ; Attributes: bp-based frame
.text$mn:00001FF8
.text$mn:00001FF8 ; int __stdcall std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::construct<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const &>(void *, int)
.text$mn:00001FF8                 public ??$construct@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@ABV12@@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@ABV21@@Z
.text$mn:00001FF8 ??$construct@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@ABV12@@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@ABV21@@Z proc near
.text$mn:00001FF8                                         ; CODE XREF: ??$_Uninit_fill_n@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@IV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@V12@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@IPBV10@AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@0@0U_N
.text$mn:00001FF8
.text$mn:00001FF8 var_4           = dword ptr -4
.text$mn:00001FF8 arg_0           = dword ptr  8
.text$mn:00001FF8 arg_4           = dword ptr  0Ch
.text$mn:00001FF8
.text$mn:00001FF8                 push    ebp
.text$mn:00001FF9                 mov     ebp, esp
.text$mn:00001FFB                 push    ecx
.text$mn:00001FFC                 mov     [ebp+var_4], ecx
.text$mn:00001FFF                 mov     eax, [ebp+arg_4]
.text$mn:00002002                 push    eax
.text$mn:00002003                 call    ??$forward@ABV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@YAABV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@ABV10@@Z ; std::forward<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const &>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const &)
.text$mn:00002008                 add     esp, 4
.text$mn:0000200B                 push    eax             ; int
.text$mn:0000200C                 mov     ecx, [ebp+arg_0]
.text$mn:0000200F                 push    ecx             ; void *
.text$mn:00002010                 mov     edx, [ebp+var_4]
.text$mn:00002013                 push    edx             ; int
.text$mn:00002014                 call    ??$construct@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@ABV12@@?$allocator_traits@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SAXAAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@1@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@ABV31@@Z ; std::allocator_traits<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::construct<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const &>(std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>> &,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const &)
.text$mn:00002019                 add     esp, 0Ch
.text$mn:0000201C                 mov     esp, ebp
.text$mn:0000201E                 pop     ebp
.text$mn:0000201F                 retn    8
.text$mn:0000201F ??$construct@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@ABV12@@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@ABV21@@Z endp
.text$mn:0000201F
.text$mn:0000201F ; ---------------------------------------------------------------------------
.text$mn:00002022                 align 4
.text$mn:00002022 _text$mn        ends
.text$mn:00002022
.text$mn:00002024 ; ===========================================================================
.text$mn:00002024
.text$mn:00002024 ; Segment type: Pure code
.text$mn:00002024 ; Segment permissions: Read/Execute
.text$mn:00002024 _text$mn        segment para public 'CODE' use32
.text$mn:00002024                 assume cs:_text$mn
.text$mn:00002024                 ;org 2024h
.text$mn:00002024 ; COMDAT (pick any)
.text$mn:00002024                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002024
.text$mn:00002024 ; =============== S U B R O U T I N E =======================================
.text$mn:00002024
.text$mn:00002024 ; Attributes: bp-based frame
.text$mn:00002024
.text$mn:00002024 ; int __stdcall std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>::construct<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const &>(void *, int)
.text$mn:00002024                 public ??$construct@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@ABV12@@?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@ABV21@@Z
.text$mn:00002024 ??$construct@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@ABV12@@?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@ABV21@@Z proc near
.text$mn:00002024                                         ; CODE XREF: std::_Alloc_construct::_Fn<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const &>(int,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>> &,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_
.text$mn:00002024
.text$mn:00002024 var_4           = dword ptr -4
.text$mn:00002024 arg_0           = dword ptr  8
.text$mn:00002024 arg_4           = dword ptr  0Ch
.text$mn:00002024
.text$mn:00002024                 push    ebp
.text$mn:00002025                 mov     ebp, esp
.text$mn:00002027                 push    ecx
.text$mn:00002028                 mov     [ebp+var_4], ecx
.text$mn:0000202B                 mov     eax, [ebp+arg_4]
.text$mn:0000202E                 push    eax
.text$mn:0000202F                 call    ??$forward@ABV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@YAABV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@ABV10@@Z ; std::forward<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const &>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const &)
.text$mn:00002034                 add     esp, 4
.text$mn:00002037                 push    eax             ; int
.text$mn:00002038                 mov     ecx, [ebp+arg_0]
.text$mn:0000203B                 push    ecx             ; void *
.text$mn:0000203C                 mov     edx, [ebp+var_4]
.text$mn:0000203F                 push    edx             ; int
.text$mn:00002040                 call    ??$construct@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@ABV12@@?$allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SAXAAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@1@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@ABV31@@Z ; std::allocator_traits<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>::construct<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const &>(std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>> &,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const &)
.text$mn:00002045                 add     esp, 0Ch
.text$mn:00002048                 mov     esp, ebp
.text$mn:0000204A                 pop     ebp
.text$mn:0000204B                 retn    8
.text$mn:0000204B ??$construct@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@ABV12@@?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@ABV21@@Z endp
.text$mn:0000204B
.text$mn:0000204B ; ---------------------------------------------------------------------------
.text$mn:0000204E                 align 10h
.text$mn:0000204E _text$mn        ends
.text$mn:0000204E
.text$mn:00002050 ; ===========================================================================
.text$mn:00002050
.text$mn:00002050 ; Segment type: Pure code
.text$mn:00002050 ; Segment permissions: Read/Execute
.text$mn:00002050 _text$mn        segment para public 'CODE' use32
.text$mn:00002050                 assume cs:_text$mn
.text$mn:00002050                 ;org 2050h
.text$mn:00002050 ; COMDAT (pick any)
.text$mn:00002050                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002050
.text$mn:00002050 ; =============== S U B R O U T I N E =======================================
.text$mn:00002050
.text$mn:00002050 ; Attributes: bp-based frame
.text$mn:00002050
.text$mn:00002050 ; int __cdecl std::allocator_traits<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::construct<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const &>(int, void *, int)
.text$mn:00002050                 public ??$construct@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@ABV12@@?$allocator_traits@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SAXAAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@1@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@ABV31@@Z
.text$mn:00002050 ??$construct@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@ABV12@@?$allocator_traits@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SAXAAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@1@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@ABV31@@Z proc near
.text$mn:00002050                                         ; CODE XREF: std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::construct<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const &>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::
.text$mn:00002050
.text$mn:00002050 arg_0           = dword ptr  8
.text$mn:00002050 arg_4           = dword ptr  0Ch
.text$mn:00002050 arg_8           = dword ptr  10h
.text$mn:00002050
.text$mn:00002050                 push    ebp
.text$mn:00002051                 mov     ebp, esp
.text$mn:00002053                 mov     eax, [ebp+arg_8]
.text$mn:00002056                 push    eax
.text$mn:00002057                 call    ??$forward@ABV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@YAABV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@ABV10@@Z ; std::forward<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const &>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const &)
.text$mn:0000205C                 add     esp, 4
.text$mn:0000205F                 push    eax             ; int
.text$mn:00002060                 mov     ecx, [ebp+arg_4]
.text$mn:00002063                 push    ecx             ; void *
.text$mn:00002064                 mov     edx, [ebp+arg_0]
.text$mn:00002067                 push    edx             ; int
.text$mn:00002068                 push    0               ; int
.text$mn:0000206A                 call    ??$_Fn@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@ABV32@@_Alloc_construct@std@@SAXHAAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@1@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@ABV31@@Z ; std::_Alloc_construct::_Fn<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const &>(int,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>> &,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const &)
.text$mn:0000206F                 add     esp, 10h
.text$mn:00002072                 pop     ebp
.text$mn:00002073                 retn
.text$mn:00002073 ??$construct@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@ABV12@@?$allocator_traits@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SAXAAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@1@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@ABV31@@Z endp
.text$mn:00002073
.text$mn:00002073 _text$mn        ends
.text$mn:00002073
.text$mn:00002074 ; ===========================================================================
.text$mn:00002074
.text$mn:00002074 ; Segment type: Pure code
.text$mn:00002074 ; Segment permissions: Read/Execute
.text$mn:00002074 _text$mn        segment para public 'CODE' use32
.text$mn:00002074                 assume cs:_text$mn
.text$mn:00002074                 ;org 2074h
.text$mn:00002074 ; COMDAT (pick any)
.text$mn:00002074                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002074
.text$mn:00002074 ; =============== S U B R O U T I N E =======================================
.text$mn:00002074
.text$mn:00002074 ; Attributes: bp-based frame
.text$mn:00002074
.text$mn:00002074 ; int __cdecl std::allocator_traits<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>::construct<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const &>(int, void *, int)
.text$mn:00002074                 public ??$construct@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@ABV12@@?$allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SAXAAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@1@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@ABV31@@Z
.text$mn:00002074 ??$construct@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@ABV12@@?$allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SAXAAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@1@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@ABV31@@Z proc near
.text$mn:00002074                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>::construct<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const &>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,
.text$mn:00002074
.text$mn:00002074 arg_0           = dword ptr  8
.text$mn:00002074 arg_4           = dword ptr  0Ch
.text$mn:00002074 arg_8           = dword ptr  10h
.text$mn:00002074
.text$mn:00002074                 push    ebp
.text$mn:00002075                 mov     ebp, esp
.text$mn:00002077                 mov     eax, [ebp+arg_8]
.text$mn:0000207A                 push    eax
.text$mn:0000207B                 call    ??$forward@ABV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@YAABV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@ABV10@@Z ; std::forward<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const &>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const &)
.text$mn:00002080                 add     esp, 4
.text$mn:00002083                 push    eax             ; int
.text$mn:00002084                 mov     ecx, [ebp+arg_4]
.text$mn:00002087                 push    ecx             ; void *
.text$mn:00002088                 mov     ecx, [ebp+arg_0]
.text$mn:0000208B                 call    ?construct@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@ABV32@@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>::construct(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const &)
.text$mn:00002090                 pop     ebp
.text$mn:00002091                 retn
.text$mn:00002091 ??$construct@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@ABV12@@?$allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SAXAAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@1@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@ABV31@@Z endp
.text$mn:00002091
.text$mn:00002091 ; ---------------------------------------------------------------------------
.text$mn:00002092                 align 4
.text$mn:00002092 _text$mn        ends
.text$mn:00002092
.text$mn:00002094 ; ===========================================================================
.text$mn:00002094
.text$mn:00002094 ; Segment type: Pure code
.text$mn:00002094 ; Segment permissions: Read/Execute
.text$mn:00002094 _text$mn        segment para public 'CODE' use32
.text$mn:00002094                 assume cs:_text$mn
.text$mn:00002094                 ;org 2094h
.text$mn:00002094 ; COMDAT (pick any)
.text$mn:00002094                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002094
.text$mn:00002094 ; =============== S U B R O U T I N E =======================================
.text$mn:00002094
.text$mn:00002094 ; Attributes: bp-based frame
.text$mn:00002094
.text$mn:00002094 ; int __stdcall std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::construct<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>(void *, int)
.text$mn:00002094                 public ??$construct@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@V12@@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@$$QAV21@@Z
.text$mn:00002094 ??$construct@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@V12@@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@$$QAV21@@Z proc near
.text$mn:00002094                                         ; CODE XREF: ??$_Uninit_move@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@V12@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@PAV10@00AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@0@0U_No
.text$mn:00002094
.text$mn:00002094 var_4           = dword ptr -4
.text$mn:00002094 arg_0           = dword ptr  8
.text$mn:00002094 arg_4           = dword ptr  0Ch
.text$mn:00002094
.text$mn:00002094                 push    ebp
.text$mn:00002095                 mov     ebp, esp
.text$mn:00002097                 push    ecx
.text$mn:00002098                 mov     [ebp+var_4], ecx
.text$mn:0000209B                 mov     eax, [ebp+arg_4]
.text$mn:0000209E                 push    eax
.text$mn:0000209F                 call    ??$forward@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@YA$$QAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@AAV10@@Z ; std::forward<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> &)
.text$mn:000020A4                 add     esp, 4
.text$mn:000020A7                 push    eax             ; int
.text$mn:000020A8                 mov     ecx, [ebp+arg_0]
.text$mn:000020AB                 push    ecx             ; void *
.text$mn:000020AC                 mov     edx, [ebp+var_4]
.text$mn:000020AF                 push    edx             ; int
.text$mn:000020B0                 call    ??$construct@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@V12@@?$allocator_traits@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SAXAAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@1@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@$$QAV31@@Z ; std::allocator_traits<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::construct<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>(std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>> &,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> &&)
.text$mn:000020B5                 add     esp, 0Ch
.text$mn:000020B8                 mov     esp, ebp
.text$mn:000020BA                 pop     ebp
.text$mn:000020BB                 retn    8
.text$mn:000020BB ??$construct@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@V12@@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@$$QAV21@@Z endp
.text$mn:000020BB
.text$mn:000020BB ; ---------------------------------------------------------------------------
.text$mn:000020BE                 align 10h
.text$mn:000020BE _text$mn        ends
.text$mn:000020BE
.text$mn:000020C0 ; ===========================================================================
.text$mn:000020C0
.text$mn:000020C0 ; Segment type: Pure code
.text$mn:000020C0 ; Segment permissions: Read/Execute
.text$mn:000020C0 _text$mn        segment para public 'CODE' use32
.text$mn:000020C0                 assume cs:_text$mn
.text$mn:000020C0                 ;org 20C0h
.text$mn:000020C0 ; COMDAT (pick any)
.text$mn:000020C0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000020C0
.text$mn:000020C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000020C0
.text$mn:000020C0 ; Attributes: bp-based frame
.text$mn:000020C0
.text$mn:000020C0 ; int __stdcall std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>::construct<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>(void *, int)
.text$mn:000020C0                 public ??$construct@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@V12@@?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@$$QAV21@@Z
.text$mn:000020C0 ??$construct@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@V12@@?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@$$QAV21@@Z proc near
.text$mn:000020C0                                         ; CODE XREF: std::_Alloc_construct::_Fn<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>(int,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>> &,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<st
.text$mn:000020C0
.text$mn:000020C0 var_4           = dword ptr -4
.text$mn:000020C0 arg_0           = dword ptr  8
.text$mn:000020C0 arg_4           = dword ptr  0Ch
.text$mn:000020C0
.text$mn:000020C0                 push    ebp
.text$mn:000020C1                 mov     ebp, esp
.text$mn:000020C3                 push    ecx
.text$mn:000020C4                 mov     [ebp+var_4], ecx
.text$mn:000020C7                 mov     eax, [ebp+arg_4]
.text$mn:000020CA                 push    eax
.text$mn:000020CB                 call    ??$forward@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@YA$$QAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@AAV10@@Z ; std::forward<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> &)
.text$mn:000020D0                 add     esp, 4
.text$mn:000020D3                 push    eax             ; int
.text$mn:000020D4                 mov     ecx, [ebp+arg_0]
.text$mn:000020D7                 push    ecx             ; void *
.text$mn:000020D8                 mov     edx, [ebp+var_4]
.text$mn:000020DB                 push    edx             ; int
.text$mn:000020DC                 call    ??$construct@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@V12@@?$allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SAXAAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@1@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@$$QAV31@@Z ; std::allocator_traits<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>::construct<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>(std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>> &,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> &&)
.text$mn:000020E1                 add     esp, 0Ch
.text$mn:000020E4                 mov     esp, ebp
.text$mn:000020E6                 pop     ebp
.text$mn:000020E7                 retn    8
.text$mn:000020E7 ??$construct@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@V12@@?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@$$QAV21@@Z endp
.text$mn:000020E7
.text$mn:000020E7 ; ---------------------------------------------------------------------------
.text$mn:000020EA                 align 4
.text$mn:000020EA _text$mn        ends
.text$mn:000020EA
.text$mn:000020EC ; ===========================================================================
.text$mn:000020EC
.text$mn:000020EC ; Segment type: Pure code
.text$mn:000020EC ; Segment permissions: Read/Execute
.text$mn:000020EC _text$mn        segment para public 'CODE' use32
.text$mn:000020EC                 assume cs:_text$mn
.text$mn:000020EC                 ;org 20ECh
.text$mn:000020EC ; COMDAT (pick any)
.text$mn:000020EC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000020EC
.text$mn:000020EC ; =============== S U B R O U T I N E =======================================
.text$mn:000020EC
.text$mn:000020EC ; Attributes: bp-based frame
.text$mn:000020EC
.text$mn:000020EC ; int __stdcall std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>::construct<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>(void *, int)
.text$mn:000020EC                 public ??$construct@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@V12@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@$$QAV21@@Z
.text$mn:000020EC ??$construct@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@V12@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@$$QAV21@@Z proc near
.text$mn:000020EC                                         ; CODE XREF: std::allocator_traits<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>::construct<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>(std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>> &,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unord
.text$mn:000020EC
.text$mn:000020EC var_1C          = dword ptr -1Ch
.text$mn:000020EC var_18          = dword ptr -18h
.text$mn:000020EC var_14          = dword ptr -14h
.text$mn:000020EC var_10          = dword ptr -10h
.text$mn:000020EC var_C           = dword ptr -0Ch
.text$mn:000020EC var_4           = dword ptr -4
.text$mn:000020EC arg_0           = dword ptr  8
.text$mn:000020EC arg_4           = dword ptr  0Ch
.text$mn:000020EC
.text$mn:000020EC                 push    ebp
.text$mn:000020ED                 mov     ebp, esp
.text$mn:000020EF                 push    0FFFFFFFFh
.text$mn:000020F1                 push    offset __ehhandler$??$construct@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@V12@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@$$QAV21@@Z
.text$mn:000020F6                 mov     eax, large fs:0
.text$mn:000020FC                 push    eax
.text$mn:000020FD                 sub     esp, 10h
.text$mn:00002100                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002105                 xor     eax, ebp
.text$mn:00002107                 push    eax
.text$mn:00002108                 lea     eax, [ebp+var_C]
.text$mn:0000210B                 mov     large fs:0, eax
.text$mn:00002111                 mov     [ebp+var_18], ecx
.text$mn:00002114                 mov     eax, [ebp+arg_0]
.text$mn:00002117                 push    eax             ; void *
.text$mn:00002118                 push    4               ; unsigned int
.text$mn:0000211A                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:0000211F                 add     esp, 8
.text$mn:00002122                 mov     [ebp+var_10], eax
.text$mn:00002125                 mov     [ebp+var_4], 0
.text$mn:0000212C                 cmp     [ebp+var_10], 0
.text$mn:00002130                 jz      short loc_214D
.text$mn:00002132                 mov     ecx, [ebp+arg_4]
.text$mn:00002135                 push    ecx
.text$mn:00002136                 call    ??$forward@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@YA$$QAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@AAV10@@Z ; std::forward<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> &)
.text$mn:0000213B                 add     esp, 4
.text$mn:0000213E                 mov     edx, [eax]
.text$mn:00002140                 mov     eax, [ebp+var_10]
.text$mn:00002143                 mov     [eax], edx
.text$mn:00002145                 mov     ecx, [ebp+var_10]
.text$mn:00002148                 mov     [ebp+var_14], ecx
.text$mn:0000214B                 jmp     short loc_2154
.text$mn:0000214D ; ---------------------------------------------------------------------------
.text$mn:0000214D
.text$mn:0000214D loc_214D:                               ; CODE XREF: std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>::construct<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::
.text$mn:0000214D                 mov     [ebp+var_14], 0
.text$mn:00002154
.text$mn:00002154 loc_2154:                               ; CODE XREF: std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>::construct<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::
.text$mn:00002154                 mov     edx, [ebp+var_14]
.text$mn:00002157                 mov     [ebp+var_1C], edx
.text$mn:0000215A                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002161                 mov     ecx, [ebp+var_C]
.text$mn:00002164                 mov     large fs:0, ecx
.text$mn:0000216B                 pop     ecx
.text$mn:0000216C                 mov     esp, ebp
.text$mn:0000216E                 pop     ebp
.text$mn:0000216F                 retn    8
.text$mn:0000216F ??$construct@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@V12@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@$$QAV21@@Z endp
.text$mn:0000216F
.text$mn:0000216F ; ---------------------------------------------------------------------------
.text$mn:00002172                 align 4
.text$mn:00002172 _text$mn        ends
.text$mn:00002172
.text$x:00002174 ; ===========================================================================
.text$x:00002174
.text$x:00002174 ; Segment type: Pure code
.text$x:00002174 ; Segment permissions: Read/Execute
.text$x:00002174 _text$x         segment para public 'CODE' use32
.text$x:00002174                 assume cs:_text$x
.text$x:00002174                 ;org 2174h
.text$x:00002174 ; COMDAT (pick associative to section at 20EC)
.text$x:00002174                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00002174
.text$x:00002174 ; =============== S U B R O U T I N E =======================================
.text$x:00002174
.text$x:00002174
.text$x:00002174 __unwindfunclet$??$construct@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@V12@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@$$QAV21@@Z$0 proc near
.text$x:00002174                                         ; DATA XREF: .xdata$x:0000ADD0o
.text$x:00002174                 mov     eax, [ebp+8]
.text$x:00002177                 push    eax
.text$x:00002178                 mov     eax, [ebp-10h]
.text$x:0000217B                 push    eax             ; void *
.text$x:0000217C                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00002181                 add     esp, 8
.text$x:00002184                 retn
.text$x:00002184 __unwindfunclet$??$construct@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@V12@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@$$QAV21@@Z$0 endp
.text$x:00002184
.text$x:00002185
.text$x:00002185 ; =============== S U B R O U T I N E =======================================
.text$x:00002185
.text$x:00002185
.text$x:00002185 __ehhandler$??$construct@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@V12@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@$$QAV21@@Z proc near
.text$x:00002185                                         ; DATA XREF: std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>::construct<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::
.text$x:00002185
.text$x:00002185 arg_4           = dword ptr  8
.text$x:00002185
.text$x:00002185                 mov     edx, [esp+arg_4]
.text$x:00002189                 lea     eax, [edx+0Ch]
.text$x:0000218C                 mov     ecx, [edx-14h]
.text$x:0000218F                 xor     ecx, eax
.text$x:00002191                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002196                 mov     eax, offset __ehfuncinfo$??$construct@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@V12@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@$$QAV21@@Z
.text$x:0000219B                 jmp     ___CxxFrameHandler3
.text$x:0000219B __ehhandler$??$construct@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@V12@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@$$QAV21@@Z endp
.text$x:0000219B
.text$x:0000219B _text$x         ends
.text$x:0000219B
.text$mn:000021A0 ; ===========================================================================
.text$mn:000021A0
.text$mn:000021A0 ; Segment type: Pure code
.text$mn:000021A0 ; Segment permissions: Read/Execute
.text$mn:000021A0 _text$mn        segment para public 'CODE' use32
.text$mn:000021A0                 assume cs:_text$mn
.text$mn:000021A0                 ;org 21A0h
.text$mn:000021A0 ; COMDAT (pick any)
.text$mn:000021A0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000021A0
.text$mn:000021A0 ; =============== S U B R O U T I N E =======================================
.text$mn:000021A0
.text$mn:000021A0 ; Attributes: bp-based frame
.text$mn:000021A0
.text$mn:000021A0 ; int __cdecl std::allocator_traits<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::construct<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>(int, void *, int)
.text$mn:000021A0                 public ??$construct@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@V12@@?$allocator_traits@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SAXAAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@1@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@$$QAV31@@Z
.text$mn:000021A0 ??$construct@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@V12@@?$allocator_traits@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SAXAAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@1@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@$$QAV31@@Z proc near
.text$mn:000021A0                                         ; CODE XREF: std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::construct<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordere
.text$mn:000021A0
.text$mn:000021A0 arg_0           = dword ptr  8
.text$mn:000021A0 arg_4           = dword ptr  0Ch
.text$mn:000021A0 arg_8           = dword ptr  10h
.text$mn:000021A0
.text$mn:000021A0                 push    ebp
.text$mn:000021A1                 mov     ebp, esp
.text$mn:000021A3                 mov     eax, [ebp+arg_8]
.text$mn:000021A6                 push    eax
.text$mn:000021A7                 call    ??$forward@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@YA$$QAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@AAV10@@Z ; std::forward<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> &)
.text$mn:000021AC                 add     esp, 4
.text$mn:000021AF                 push    eax             ; int
.text$mn:000021B0                 mov     ecx, [ebp+arg_4]
.text$mn:000021B3                 push    ecx             ; void *
.text$mn:000021B4                 mov     edx, [ebp+arg_0]
.text$mn:000021B7                 push    edx             ; int
.text$mn:000021B8                 push    0               ; int
.text$mn:000021BA                 call    ??$_Fn@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@V32@@_Alloc_construct@std@@SAXHAAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@1@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@$$QAV31@@Z ; std::_Alloc_construct::_Fn<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>(int,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>> &,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> &&)
.text$mn:000021BF                 add     esp, 10h
.text$mn:000021C2                 pop     ebp
.text$mn:000021C3                 retn
.text$mn:000021C3 ??$construct@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@V12@@?$allocator_traits@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SAXAAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@1@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@$$QAV31@@Z endp
.text$mn:000021C3
.text$mn:000021C3 _text$mn        ends
.text$mn:000021C3
.text$mn:000021C4 ; ===========================================================================
.text$mn:000021C4
.text$mn:000021C4 ; Segment type: Pure code
.text$mn:000021C4 ; Segment permissions: Read/Execute
.text$mn:000021C4 _text$mn        segment para public 'CODE' use32
.text$mn:000021C4                 assume cs:_text$mn
.text$mn:000021C4                 ;org 21C4h
.text$mn:000021C4 ; COMDAT (pick any)
.text$mn:000021C4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000021C4
.text$mn:000021C4 ; =============== S U B R O U T I N E =======================================
.text$mn:000021C4
.text$mn:000021C4 ; Attributes: bp-based frame
.text$mn:000021C4
.text$mn:000021C4 ; int __cdecl std::allocator_traits<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>::construct<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>(int, void *, int)
.text$mn:000021C4                 public ??$construct@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@V12@@?$allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SAXAAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@1@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@$$QAV31@@Z
.text$mn:000021C4 ??$construct@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@V12@@?$allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SAXAAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@1@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@$$QAV31@@Z proc near
.text$mn:000021C4                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>::construct<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,st
.text$mn:000021C4
.text$mn:000021C4 arg_0           = dword ptr  8
.text$mn:000021C4 arg_4           = dword ptr  0Ch
.text$mn:000021C4 arg_8           = dword ptr  10h
.text$mn:000021C4
.text$mn:000021C4                 push    ebp
.text$mn:000021C5                 mov     ebp, esp
.text$mn:000021C7                 mov     eax, [ebp+arg_8]
.text$mn:000021CA                 push    eax
.text$mn:000021CB                 call    ??$forward@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@YA$$QAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@AAV10@@Z ; std::forward<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> &)
.text$mn:000021D0                 add     esp, 4
.text$mn:000021D3                 push    eax             ; int
.text$mn:000021D4                 mov     ecx, [ebp+arg_4]
.text$mn:000021D7                 push    ecx             ; void *
.text$mn:000021D8                 mov     ecx, [ebp+arg_0]
.text$mn:000021DB                 call    ??$construct@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@V12@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@$$QAV21@@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>::construct<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> &&)
.text$mn:000021E0                 pop     ebp
.text$mn:000021E1                 retn
.text$mn:000021E1 ??$construct@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@V12@@?$allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SAXAAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@1@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@$$QAV31@@Z endp
.text$mn:000021E1
.text$mn:000021E1 ; ---------------------------------------------------------------------------
.text$mn:000021E2                 align 4
.text$mn:000021E2 _text$mn        ends
.text$mn:000021E2
.text$mn:000021E4 ; ===========================================================================
.text$mn:000021E4
.text$mn:000021E4 ; Segment type: Pure code
.text$mn:000021E4 ; Segment permissions: Read/Execute
.text$mn:000021E4 _text$mn        segment para public 'CODE' use32
.text$mn:000021E4                 assume cs:_text$mn
.text$mn:000021E4                 ;org 21E4h
.text$mn:000021E4 ; COMDAT (pick any)
.text$mn:000021E4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000021E4
.text$mn:000021E4 ; =============== S U B R O U T I N E =======================================
.text$mn:000021E4
.text$mn:000021E4 ; Attributes: bp-based frame
.text$mn:000021E4
.text$mn:000021E4 ; public: void __thiscall std::_Wrap_alloc<class std::allocator<char>>::destroy<char *>(char * *)
.text$mn:000021E4                 public ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
.text$mn:000021E4 ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z proc near
.text$mn:000021E4                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+3Ap
.text$mn:000021E4
.text$mn:000021E4 var_4           = dword ptr -4
.text$mn:000021E4 arg_0           = dword ptr  8
.text$mn:000021E4
.text$mn:000021E4                 push    ebp
.text$mn:000021E5                 mov     ebp, esp
.text$mn:000021E7                 push    ecx
.text$mn:000021E8                 mov     [ebp+var_4], ecx
.text$mn:000021EB                 mov     eax, [ebp+arg_0]
.text$mn:000021EE                 push    eax
.text$mn:000021EF                 mov     ecx, [ebp+var_4]
.text$mn:000021F2                 push    ecx
.text$mn:000021F3                 call    ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char * *)
.text$mn:000021F8                 add     esp, 8
.text$mn:000021FB                 mov     esp, ebp
.text$mn:000021FD                 pop     ebp
.text$mn:000021FE                 retn    4
.text$mn:000021FE ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z endp
.text$mn:000021FE
.text$mn:000021FE ; ---------------------------------------------------------------------------
.text$mn:00002201                 align 4
.text$mn:00002201 _text$mn        ends
.text$mn:00002201
.text$mn:00002204 ; ===========================================================================
.text$mn:00002204
.text$mn:00002204 ; Segment type: Pure code
.text$mn:00002204 ; Segment permissions: Read/Execute
.text$mn:00002204 _text$mn        segment para public 'CODE' use32
.text$mn:00002204                 assume cs:_text$mn
.text$mn:00002204                 ;org 2204h
.text$mn:00002204 ; COMDAT (pick any)
.text$mn:00002204                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002204
.text$mn:00002204 ; =============== S U B R O U T I N E =======================================
.text$mn:00002204
.text$mn:00002204 ; Attributes: bp-based frame
.text$mn:00002204
.text$mn:00002204 ; public: void __thiscall std::allocator<char>::destroy<char *>(char * *)
.text$mn:00002204                 public ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
.text$mn:00002204 ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z proc near
.text$mn:00002204                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char * *)+Ap
.text$mn:00002204
.text$mn:00002204 var_4           = dword ptr -4
.text$mn:00002204
.text$mn:00002204                 push    ebp
.text$mn:00002205                 mov     ebp, esp
.text$mn:00002207                 push    ecx
.text$mn:00002208                 mov     [ebp+var_4], ecx
.text$mn:0000220B                 mov     esp, ebp
.text$mn:0000220D                 pop     ebp
.text$mn:0000220E                 retn    4
.text$mn:0000220E ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z endp
.text$mn:0000220E
.text$mn:0000220E ; ---------------------------------------------------------------------------
.text$mn:00002211                 align 4
.text$mn:00002211 _text$mn        ends
.text$mn:00002211
.text$mn:00002214 ; ===========================================================================
.text$mn:00002214
.text$mn:00002214 ; Segment type: Pure code
.text$mn:00002214 ; Segment permissions: Read/Execute
.text$mn:00002214 _text$mn        segment para public 'CODE' use32
.text$mn:00002214                 assume cs:_text$mn
.text$mn:00002214                 ;org 2214h
.text$mn:00002214 ; COMDAT (pick any)
.text$mn:00002214                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002214
.text$mn:00002214 ; =============== S U B R O U T I N E =======================================
.text$mn:00002214
.text$mn:00002214 ; Attributes: bp-based frame
.text$mn:00002214
.text$mn:00002214 ; public: static void __cdecl std::allocator_traits<class std::allocator<char>>::destroy<char *>(class std::allocator<char> &, char * *)
.text$mn:00002214                 public ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
.text$mn:00002214 ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z proc near
.text$mn:00002214                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)+Fp
.text$mn:00002214
.text$mn:00002214 arg_0           = dword ptr  8
.text$mn:00002214 arg_4           = dword ptr  0Ch
.text$mn:00002214
.text$mn:00002214                 push    ebp
.text$mn:00002215                 mov     ebp, esp
.text$mn:00002217                 mov     eax, [ebp+arg_4]
.text$mn:0000221A                 push    eax
.text$mn:0000221B                 mov     ecx, [ebp+arg_0]
.text$mn:0000221E                 call    ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ; std::allocator<char>::destroy<char *>(char * *)
.text$mn:00002223                 pop     ebp
.text$mn:00002224                 retn
.text$mn:00002224 ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z endp
.text$mn:00002224
.text$mn:00002224 ; ---------------------------------------------------------------------------
.text$mn:00002225                 align 4
.text$mn:00002225 _text$mn        ends
.text$mn:00002225
.text$mn:00002228 ; ===========================================================================
.text$mn:00002228
.text$mn:00002228 ; Segment type: Pure code
.text$mn:00002228 ; Segment permissions: Read/Execute
.text$mn:00002228 _text$mn        segment para public 'CODE' use32
.text$mn:00002228                 assume cs:_text$mn
.text$mn:00002228                 ;org 2228h
.text$mn:00002228 ; COMDAT (pick any)
.text$mn:00002228                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002228
.text$mn:00002228 ; =============== S U B R O U T I N E =======================================
.text$mn:00002228
.text$mn:00002228 ; Attributes: bp-based frame
.text$mn:00002228
.text$mn:00002228 ; public: void __thiscall std::_Wrap_alloc<class std::allocator<struct std::_List_node<struct std::pair<int const, struct Style>, void *>>>::destroy<struct std::_List_node<struct std::pair<int const, struct Style>, void *> *>(struct std::_List_node<struct std::pair<int const, struct Style>, void *> * *)
.text$mn:00002228                 public ??$destroy@PAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@1@@Z
.text$mn:00002228 ??$destroy@PAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@1@@Z proc near
.text$mn:00002228                                         ; CODE XREF: std::_List_alloc<0,std::_List_base_types<std::pair<int const,Style>,std::allocator<std::pair<int const,Style>>>>::_Freeheadnode(std::_List_node<std::pair<int const,Style>,void *> *)+2Dp
.text$mn:00002228                                         ; std::_List_alloc<0,std::_List_base_types<std::pair<int const,Style>,std::allocator<std::pair<int const,Style>>>>::_Freeheadnode(std::_List_node<std::pair<int const,Style>,void *> *)+56p ...
.text$mn:00002228
.text$mn:00002228 var_4           = dword ptr -4
.text$mn:00002228 arg_0           = dword ptr  8
.text$mn:00002228
.text$mn:00002228                 push    ebp
.text$mn:00002229                 mov     ebp, esp
.text$mn:0000222B                 push    ecx
.text$mn:0000222C                 mov     [ebp+var_4], ecx
.text$mn:0000222F                 mov     eax, [ebp+arg_0]
.text$mn:00002232                 push    eax
.text$mn:00002233                 mov     ecx, [ebp+var_4]
.text$mn:00002236                 push    ecx
.text$mn:00002237                 call    ??$destroy@PAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@std@@@1@PAPAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@1@@Z ; std::allocator_traits<std::allocator<std::_List_node<std::pair<int const,Style>,void *>>>::destroy<std::_List_node<std::pair<int const,Style>,void *> *>(std::allocator<std::_List_node<std::pair<int const,Style>,void *>> &,std::_List_node<std::pair<int const,Style>,void *> * *)
.text$mn:0000223C                 add     esp, 8
.text$mn:0000223F                 mov     esp, ebp
.text$mn:00002241                 pop     ebp
.text$mn:00002242                 retn    4
.text$mn:00002242 ??$destroy@PAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@1@@Z endp
.text$mn:00002242
.text$mn:00002242 ; ---------------------------------------------------------------------------
.text$mn:00002245                 align 4
.text$mn:00002245 _text$mn        ends
.text$mn:00002245
.text$mn:00002248 ; ===========================================================================
.text$mn:00002248
.text$mn:00002248 ; Segment type: Pure code
.text$mn:00002248 ; Segment permissions: Read/Execute
.text$mn:00002248 _text$mn        segment para public 'CODE' use32
.text$mn:00002248                 assume cs:_text$mn
.text$mn:00002248                 ;org 2248h
.text$mn:00002248 ; COMDAT (pick any)
.text$mn:00002248                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002248
.text$mn:00002248 ; =============== S U B R O U T I N E =======================================
.text$mn:00002248
.text$mn:00002248 ; Attributes: bp-based frame
.text$mn:00002248
.text$mn:00002248 ; public: void __thiscall std::allocator<struct std::_List_node<struct std::pair<int const, struct Style>, void *>>::destroy<struct std::_List_node<struct std::pair<int const, struct Style>, void *> *>(struct std::_List_node<struct std::pair<int const, struct Style>, void *> * *)
.text$mn:00002248                 public ??$destroy@PAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@std@@@?$allocator@U?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@std@@@std@@QAEXPAPAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@1@@Z
.text$mn:00002248 ??$destroy@PAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@std@@@?$allocator@U?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@std@@@std@@QAEXPAPAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@1@@Z proc near
.text$mn:00002248                                         ; CODE XREF: std::allocator_traits<std::allocator<std::_List_node<std::pair<int const,Style>,void *>>>::destroy<std::_List_node<std::pair<int const,Style>,void *> *>(std::allocator<std::_List_node<std::pair<int const,Style>,void *>> &,std::_List_node<std::pair<int const,Style>,void *> * *)+Ap
.text$mn:00002248
.text$mn:00002248 var_4           = dword ptr -4
.text$mn:00002248
.text$mn:00002248                 push    ebp
.text$mn:00002249                 mov     ebp, esp
.text$mn:0000224B                 push    ecx
.text$mn:0000224C                 mov     [ebp+var_4], ecx
.text$mn:0000224F                 mov     esp, ebp
.text$mn:00002251                 pop     ebp
.text$mn:00002252                 retn    4
.text$mn:00002252 ??$destroy@PAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@std@@@?$allocator@U?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@std@@@std@@QAEXPAPAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@1@@Z endp
.text$mn:00002252
.text$mn:00002252 ; ---------------------------------------------------------------------------
.text$mn:00002255                 align 4
.text$mn:00002255 _text$mn        ends
.text$mn:00002255
.text$mn:00002258 ; ===========================================================================
.text$mn:00002258
.text$mn:00002258 ; Segment type: Pure code
.text$mn:00002258 ; Segment permissions: Read/Execute
.text$mn:00002258 _text$mn        segment para public 'CODE' use32
.text$mn:00002258                 assume cs:_text$mn
.text$mn:00002258                 ;org 2258h
.text$mn:00002258 ; COMDAT (pick any)
.text$mn:00002258                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002258
.text$mn:00002258 ; =============== S U B R O U T I N E =======================================
.text$mn:00002258
.text$mn:00002258 ; Attributes: bp-based frame
.text$mn:00002258
.text$mn:00002258 ; public: static void __cdecl std::allocator_traits<class std::allocator<struct std::_List_node<struct std::pair<int const, struct Style>, void *>>>::destroy<struct std::_List_node<struct std::pair<int const, struct Style>, void *> *>(class std::allocator<struct std::_List_node<struct std::pair<int const, struct Style>, void *>> &, struct std::_List_node<struct std::pair<int const, struct Style>, void *> * *)
.text$mn:00002258                 public ??$destroy@PAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@std@@@1@PAPAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@1@@Z
.text$mn:00002258 ??$destroy@PAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@std@@@1@PAPAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@1@@Z proc near
.text$mn:00002258                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::_List_node<std::pair<int const,Style>,void *>>>::destroy<std::_List_node<std::pair<int const,Style>,void *> *>(std::_List_node<std::pair<int const,Style>,void *> * *)+Fp
.text$mn:00002258
.text$mn:00002258 arg_0           = dword ptr  8
.text$mn:00002258 arg_4           = dword ptr  0Ch
.text$mn:00002258
.text$mn:00002258                 push    ebp
.text$mn:00002259                 mov     ebp, esp
.text$mn:0000225B                 mov     eax, [ebp+arg_4]
.text$mn:0000225E                 push    eax
.text$mn:0000225F                 mov     ecx, [ebp+arg_0]
.text$mn:00002262                 call    ??$destroy@PAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@std@@@?$allocator@U?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@std@@@std@@QAEXPAPAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@1@@Z ; std::allocator<std::_List_node<std::pair<int const,Style>,void *>>::destroy<std::_List_node<std::pair<int const,Style>,void *> *>(std::_List_node<std::pair<int const,Style>,void *> * *)
.text$mn:00002267                 pop     ebp
.text$mn:00002268                 retn
.text$mn:00002268 ??$destroy@PAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@std@@@1@PAPAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@1@@Z endp
.text$mn:00002268
.text$mn:00002268 ; ---------------------------------------------------------------------------
.text$mn:00002269                 align 4
.text$mn:00002269 _text$mn        ends
.text$mn:00002269
.text$mn:0000226C ; ===========================================================================
.text$mn:0000226C
.text$mn:0000226C ; Segment type: Pure code
.text$mn:0000226C ; Segment permissions: Read/Execute
.text$mn:0000226C _text$mn        segment para public 'CODE' use32
.text$mn:0000226C                 assume cs:_text$mn
.text$mn:0000226C                 ;org 226Ch
.text$mn:0000226C ; COMDAT (pick any)
.text$mn:0000226C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000226C
.text$mn:0000226C ; =============== S U B R O U T I N E =======================================
.text$mn:0000226C
.text$mn:0000226C ; Attributes: bp-based frame
.text$mn:0000226C
.text$mn:0000226C ; public: void __thiscall std::_Wrap_alloc<class std::allocator<struct std::_List_node<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>, void *>>>::destroy<struct std::_List_node<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>, void *> *>(struct std::_List_node<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>, void *> * *)
.text$mn:0000226C                 public ??$destroy@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@1@@Z
.text$mn:0000226C ??$destroy@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@1@@Z proc near
.text$mn:0000226C                                         ; CODE XREF: std::_List_alloc<0,std::_List_base_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::_Freeheadnode(std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *)+2Dp
.text$mn:0000226C                                         ; std::_List_alloc<0,std::_List_base_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::_Freeheadnode(std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *)+56p ...
.text$mn:0000226C
.text$mn:0000226C var_4           = dword ptr -4
.text$mn:0000226C arg_0           = dword ptr  8
.text$mn:0000226C
.text$mn:0000226C                 push    ebp
.text$mn:0000226D                 mov     ebp, esp
.text$mn:0000226F                 push    ecx
.text$mn:00002270                 mov     [ebp+var_4], ecx
.text$mn:00002273                 mov     eax, [ebp+arg_0]
.text$mn:00002276                 push    eax
.text$mn:00002277                 mov     ecx, [ebp+var_4]
.text$mn:0000227A                 push    ecx
.text$mn:0000227B                 call    ??$destroy@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@1@PAPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@1@@Z ; std::allocator_traits<std::allocator<std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *>>>::destroy<std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *>(std::allocator<std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *>> &,std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> * *)
.text$mn:00002280                 add     esp, 8
.text$mn:00002283                 mov     esp, ebp
.text$mn:00002285                 pop     ebp
.text$mn:00002286                 retn    4
.text$mn:00002286 ??$destroy@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@1@@Z endp
.text$mn:00002286
.text$mn:00002286 ; ---------------------------------------------------------------------------
.text$mn:00002289                 align 4
.text$mn:00002289 _text$mn        ends
.text$mn:00002289
.text$mn:0000228C ; ===========================================================================
.text$mn:0000228C
.text$mn:0000228C ; Segment type: Pure code
.text$mn:0000228C ; Segment permissions: Read/Execute
.text$mn:0000228C _text$mn        segment para public 'CODE' use32
.text$mn:0000228C                 assume cs:_text$mn
.text$mn:0000228C                 ;org 228Ch
.text$mn:0000228C ; COMDAT (pick any)
.text$mn:0000228C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000228C
.text$mn:0000228C ; =============== S U B R O U T I N E =======================================
.text$mn:0000228C
.text$mn:0000228C ; Attributes: bp-based frame
.text$mn:0000228C
.text$mn:0000228C ; public: void __thiscall std::allocator<struct std::_List_node<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>, void *>>::destroy<struct std::_List_node<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>, void *> *>(struct std::_List_node<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>, void *> * *)
.text$mn:0000228C                 public ??$destroy@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@QAEXPAPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@1@@Z
.text$mn:0000228C ??$destroy@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@QAEXPAPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@1@@Z proc near
.text$mn:0000228C                                         ; CODE XREF: std::allocator_traits<std::allocator<std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *>>>::destroy<std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *>(std::allocator<std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *>> &,std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> * *)+Ap
.text$mn:0000228C
.text$mn:0000228C var_4           = dword ptr -4
.text$mn:0000228C
.text$mn:0000228C                 push    ebp
.text$mn:0000228D                 mov     ebp, esp
.text$mn:0000228F                 push    ecx
.text$mn:00002290                 mov     [ebp+var_4], ecx
.text$mn:00002293                 mov     esp, ebp
.text$mn:00002295                 pop     ebp
.text$mn:00002296                 retn    4
.text$mn:00002296 ??$destroy@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@QAEXPAPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@1@@Z endp
.text$mn:00002296
.text$mn:00002296 ; ---------------------------------------------------------------------------
.text$mn:00002299                 align 4
.text$mn:00002299 _text$mn        ends
.text$mn:00002299
.text$mn:0000229C ; ===========================================================================
.text$mn:0000229C
.text$mn:0000229C ; Segment type: Pure code
.text$mn:0000229C ; Segment permissions: Read/Execute
.text$mn:0000229C _text$mn        segment para public 'CODE' use32
.text$mn:0000229C                 assume cs:_text$mn
.text$mn:0000229C                 ;org 229Ch
.text$mn:0000229C ; COMDAT (pick any)
.text$mn:0000229C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000229C
.text$mn:0000229C ; =============== S U B R O U T I N E =======================================
.text$mn:0000229C
.text$mn:0000229C ; Attributes: bp-based frame
.text$mn:0000229C
.text$mn:0000229C ; public: static void __cdecl std::allocator_traits<class std::allocator<struct std::_List_node<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>, void *>>>::destroy<struct std::_List_node<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>, void *> *>(class std::allocator<struct std::_List_node<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>, void *>> &, struct std::_List_node<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struc
.text$mn:0000229C                 public ??$destroy@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@1@PAPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@1@@Z
.text$mn:0000229C ??$destroy@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@1@PAPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@1@@Z proc near
.text$mn:0000229C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *>>>::destroy<std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *>(std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> * *)+Fp
.text$mn:0000229C
.text$mn:0000229C arg_0           = dword ptr  8
.text$mn:0000229C arg_4           = dword ptr  0Ch
.text$mn:0000229C
.text$mn:0000229C                 push    ebp
.text$mn:0000229D                 mov     ebp, esp
.text$mn:0000229F                 mov     eax, [ebp+arg_4]
.text$mn:000022A2                 push    eax
.text$mn:000022A3                 mov     ecx, [ebp+arg_0]
.text$mn:000022A6                 call    ??$destroy@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@QAEXPAPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@1@@Z ; std::allocator<std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *>>::destroy<std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *>(std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> * *)
.text$mn:000022AB                 pop     ebp
.text$mn:000022AC                 retn
.text$mn:000022AC ??$destroy@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@1@PAPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@1@@Z endp
.text$mn:000022AC
.text$mn:000022AC ; ---------------------------------------------------------------------------
.text$mn:000022AD                 align 10h
.text$mn:000022AD _text$mn        ends
.text$mn:000022AD
.text$mn:000022B0 ; ===========================================================================
.text$mn:000022B0
.text$mn:000022B0 ; Segment type: Pure code
.text$mn:000022B0 ; Segment permissions: Read/Execute
.text$mn:000022B0 _text$mn        segment para public 'CODE' use32
.text$mn:000022B0                 assume cs:_text$mn
.text$mn:000022B0                 ;org 22B0h
.text$mn:000022B0 ; COMDAT (pick any)
.text$mn:000022B0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000022B0
.text$mn:000022B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000022B0
.text$mn:000022B0 ; Attributes: bp-based frame
.text$mn:000022B0
.text$mn:000022B0 ; public: void __thiscall std::_Wrap_alloc<class std::allocator<wchar_t>>::destroy<wchar_t *>(wchar_t * *)
.text$mn:000022B0                 public ??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z
.text$mn:000022B0 ??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z proc near
.text$mn:000022B0                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+3Ap
.text$mn:000022B0
.text$mn:000022B0 var_4           = dword ptr -4
.text$mn:000022B0 arg_0           = dword ptr  8
.text$mn:000022B0
.text$mn:000022B0                 push    ebp
.text$mn:000022B1                 mov     ebp, esp
.text$mn:000022B3                 push    ecx
.text$mn:000022B4                 mov     [ebp+var_4], ecx
.text$mn:000022B7                 mov     eax, [ebp+arg_0]
.text$mn:000022BA                 push    eax
.text$mn:000022BB                 mov     ecx, [ebp+var_4]
.text$mn:000022BE                 push    ecx
.text$mn:000022BF                 call    ??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z ; std::allocator_traits<std::allocator<wchar_t>>::destroy<wchar_t *>(std::allocator<wchar_t> &,wchar_t * *)
.text$mn:000022C4                 add     esp, 8
.text$mn:000022C7                 mov     esp, ebp
.text$mn:000022C9                 pop     ebp
.text$mn:000022CA                 retn    4
.text$mn:000022CA ??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z endp
.text$mn:000022CA
.text$mn:000022CA ; ---------------------------------------------------------------------------
.text$mn:000022CD                 align 10h
.text$mn:000022CD _text$mn        ends
.text$mn:000022CD
.text$mn:000022D0 ; ===========================================================================
.text$mn:000022D0
.text$mn:000022D0 ; Segment type: Pure code
.text$mn:000022D0 ; Segment permissions: Read/Execute
.text$mn:000022D0 _text$mn        segment para public 'CODE' use32
.text$mn:000022D0                 assume cs:_text$mn
.text$mn:000022D0                 ;org 22D0h
.text$mn:000022D0 ; COMDAT (pick any)
.text$mn:000022D0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000022D0
.text$mn:000022D0 ; =============== S U B R O U T I N E =======================================
.text$mn:000022D0
.text$mn:000022D0 ; Attributes: bp-based frame
.text$mn:000022D0
.text$mn:000022D0 ; public: void __thiscall std::allocator<wchar_t>::destroy<wchar_t *>(wchar_t * *)
.text$mn:000022D0                 public ??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z
.text$mn:000022D0 ??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z proc near
.text$mn:000022D0                                         ; CODE XREF: std::allocator_traits<std::allocator<wchar_t>>::destroy<wchar_t *>(std::allocator<wchar_t> &,wchar_t * *)+Ap
.text$mn:000022D0
.text$mn:000022D0 var_4           = dword ptr -4
.text$mn:000022D0
.text$mn:000022D0                 push    ebp
.text$mn:000022D1                 mov     ebp, esp
.text$mn:000022D3                 push    ecx
.text$mn:000022D4                 mov     [ebp+var_4], ecx
.text$mn:000022D7                 mov     esp, ebp
.text$mn:000022D9                 pop     ebp
.text$mn:000022DA                 retn    4
.text$mn:000022DA ??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z endp
.text$mn:000022DA
.text$mn:000022DA ; ---------------------------------------------------------------------------
.text$mn:000022DD                 align 10h
.text$mn:000022DD _text$mn        ends
.text$mn:000022DD
.text$mn:000022E0 ; ===========================================================================
.text$mn:000022E0
.text$mn:000022E0 ; Segment type: Pure code
.text$mn:000022E0 ; Segment permissions: Read/Execute
.text$mn:000022E0 _text$mn        segment para public 'CODE' use32
.text$mn:000022E0                 assume cs:_text$mn
.text$mn:000022E0                 ;org 22E0h
.text$mn:000022E0 ; COMDAT (pick any)
.text$mn:000022E0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000022E0
.text$mn:000022E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000022E0
.text$mn:000022E0 ; Attributes: bp-based frame
.text$mn:000022E0
.text$mn:000022E0 ; public: static void __cdecl std::allocator_traits<class std::allocator<wchar_t>>::destroy<wchar_t *>(class std::allocator<wchar_t> &, wchar_t * *)
.text$mn:000022E0                 public ??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z
.text$mn:000022E0 ??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z proc near
.text$mn:000022E0                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::destroy<wchar_t *>(wchar_t * *)+Fp
.text$mn:000022E0
.text$mn:000022E0 arg_0           = dword ptr  8
.text$mn:000022E0 arg_4           = dword ptr  0Ch
.text$mn:000022E0
.text$mn:000022E0                 push    ebp
.text$mn:000022E1                 mov     ebp, esp
.text$mn:000022E3                 mov     eax, [ebp+arg_4]
.text$mn:000022E6                 push    eax
.text$mn:000022E7                 mov     ecx, [ebp+arg_0]
.text$mn:000022EA                 call    ??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z ; std::allocator<wchar_t>::destroy<wchar_t *>(wchar_t * *)
.text$mn:000022EF                 pop     ebp
.text$mn:000022F0                 retn
.text$mn:000022F0 ??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z endp
.text$mn:000022F0
.text$mn:000022F0 ; ---------------------------------------------------------------------------
.text$mn:000022F1                 align 4
.text$mn:000022F1 _text$mn        ends
.text$mn:000022F1
.text$mn:000022F4 ; ===========================================================================
.text$mn:000022F4
.text$mn:000022F4 ; Segment type: Pure code
.text$mn:000022F4 ; Segment permissions: Read/Execute
.text$mn:000022F4 _text$mn        segment para public 'CODE' use32
.text$mn:000022F4                 assume cs:_text$mn
.text$mn:000022F4                 ;org 22F4h
.text$mn:000022F4 ; COMDAT (pick any)
.text$mn:000022F4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000022F4
.text$mn:000022F4 ; =============== S U B R O U T I N E =======================================
.text$mn:000022F4
.text$mn:000022F4 ; Attributes: bp-based frame
.text$mn:000022F4
.text$mn:000022F4 ; public: void __thiscall std::_Wrap_alloc<class std::allocator<struct std::_List_node<struct std::pair<int const, struct Style>, void *>>>::destroy<struct std::pair<int const, struct Style>>(struct std::pair<int const, struct Style> *)
.text$mn:000022F4                 public ??$destroy@U?$pair@$$CBHUStyle@@@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBHUStyle@@@1@@Z
.text$mn:000022F4 ??$destroy@U?$pair@$$CBHUStyle@@@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBHUStyle@@@1@@Z proc near
.text$mn:000022F4                                         ; CODE XREF: std::_List_buy<std::pair<int const,Style>,std::allocator<std::pair<int const,Style>>>::_Freenode(std::_List_node<std::pair<int const,Style>,void *> *)+7Fp
.text$mn:000022F4
.text$mn:000022F4 var_4           = dword ptr -4
.text$mn:000022F4 arg_0           = dword ptr  8
.text$mn:000022F4
.text$mn:000022F4                 push    ebp
.text$mn:000022F5                 mov     ebp, esp
.text$mn:000022F7                 push    ecx
.text$mn:000022F8                 mov     [ebp+var_4], ecx
.text$mn:000022FB                 mov     eax, [ebp+arg_0]
.text$mn:000022FE                 push    eax
.text$mn:000022FF                 mov     ecx, [ebp+var_4]
.text$mn:00002302                 push    ecx
.text$mn:00002303                 call    ??$destroy@U?$pair@$$CBHUStyle@@@std@@@?$allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@std@@@1@PAU?$pair@$$CBHUStyle@@@1@@Z ; std::allocator_traits<std::allocator<std::_List_node<std::pair<int const,Style>,void *>>>::destroy<std::pair<int const,Style>>(std::allocator<std::_List_node<std::pair<int const,Style>,void *>> &,std::pair<int const,Style> *)
.text$mn:00002308                 add     esp, 8
.text$mn:0000230B                 mov     esp, ebp
.text$mn:0000230D                 pop     ebp
.text$mn:0000230E                 retn    4
.text$mn:0000230E ??$destroy@U?$pair@$$CBHUStyle@@@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBHUStyle@@@1@@Z endp
.text$mn:0000230E
.text$mn:0000230E ; ---------------------------------------------------------------------------
.text$mn:00002311                 align 4
.text$mn:00002311 _text$mn        ends
.text$mn:00002311
.text$mn:00002314 ; ===========================================================================
.text$mn:00002314
.text$mn:00002314 ; Segment type: Pure code
.text$mn:00002314 ; Segment permissions: Read/Execute
.text$mn:00002314 _text$mn        segment para public 'CODE' use32
.text$mn:00002314                 assume cs:_text$mn
.text$mn:00002314                 ;org 2314h
.text$mn:00002314 ; COMDAT (pick any)
.text$mn:00002314                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002314
.text$mn:00002314 ; =============== S U B R O U T I N E =======================================
.text$mn:00002314
.text$mn:00002314 ; Attributes: bp-based frame
.text$mn:00002314
.text$mn:00002314 ; public: void __thiscall std::allocator<struct std::_List_node<struct std::pair<int const, struct Style>, void *>>::destroy<struct std::pair<int const, struct Style>>(struct std::pair<int const, struct Style> *)
.text$mn:00002314                 public ??$destroy@U?$pair@$$CBHUStyle@@@std@@@?$allocator@U?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBHUStyle@@@1@@Z
.text$mn:00002314 ??$destroy@U?$pair@$$CBHUStyle@@@std@@@?$allocator@U?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBHUStyle@@@1@@Z proc near
.text$mn:00002314                                         ; CODE XREF: std::allocator_traits<std::allocator<std::_List_node<std::pair<int const,Style>,void *>>>::destroy<std::pair<int const,Style>>(std::allocator<std::_List_node<std::pair<int const,Style>,void *>> &,std::pair<int const,Style> *)+Ap
.text$mn:00002314
.text$mn:00002314 var_4           = dword ptr -4
.text$mn:00002314 arg_0           = dword ptr  8
.text$mn:00002314
.text$mn:00002314                 push    ebp
.text$mn:00002315                 mov     ebp, esp
.text$mn:00002317                 push    ecx
.text$mn:00002318                 mov     [ebp+var_4], ecx
.text$mn:0000231B                 push    0
.text$mn:0000231D                 mov     ecx, [ebp+arg_0]
.text$mn:00002320                 call    ??_G?$pair@$$CBHUStyle@@@std@@QAEPAXI@Z ; std::pair<int const,Style>::`scalar deleting destructor'(uint)
.text$mn:00002325                 mov     esp, ebp
.text$mn:00002327                 pop     ebp
.text$mn:00002328                 retn    4
.text$mn:00002328 ??$destroy@U?$pair@$$CBHUStyle@@@std@@@?$allocator@U?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBHUStyle@@@1@@Z endp
.text$mn:00002328
.text$mn:00002328 ; ---------------------------------------------------------------------------
.text$mn:0000232B                 align 4
.text$mn:0000232B _text$mn        ends
.text$mn:0000232B
.text$mn:0000232C ; ===========================================================================
.text$mn:0000232C
.text$mn:0000232C ; Segment type: Pure code
.text$mn:0000232C ; Segment permissions: Read/Execute
.text$mn:0000232C _text$mn        segment para public 'CODE' use32
.text$mn:0000232C                 assume cs:_text$mn
.text$mn:0000232C                 ;org 232Ch
.text$mn:0000232C ; COMDAT (pick any)
.text$mn:0000232C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000232C
.text$mn:0000232C ; =============== S U B R O U T I N E =======================================
.text$mn:0000232C
.text$mn:0000232C ; Attributes: bp-based frame
.text$mn:0000232C
.text$mn:0000232C ; public: static void __cdecl std::allocator_traits<class std::allocator<struct std::_List_node<struct std::pair<int const, struct Style>, void *>>>::destroy<struct std::pair<int const, struct Style>>(class std::allocator<struct std::_List_node<struct std::pair<int const, struct Style>, void *>> &, struct std::pair<int const, struct Style> *)
.text$mn:0000232C                 public ??$destroy@U?$pair@$$CBHUStyle@@@std@@@?$allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@std@@@1@PAU?$pair@$$CBHUStyle@@@1@@Z
.text$mn:0000232C ??$destroy@U?$pair@$$CBHUStyle@@@std@@@?$allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@std@@@1@PAU?$pair@$$CBHUStyle@@@1@@Z proc near
.text$mn:0000232C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::_List_node<std::pair<int const,Style>,void *>>>::destroy<std::pair<int const,Style>>(std::pair<int const,Style> *)+Fp
.text$mn:0000232C
.text$mn:0000232C arg_0           = dword ptr  8
.text$mn:0000232C arg_4           = dword ptr  0Ch
.text$mn:0000232C
.text$mn:0000232C                 push    ebp
.text$mn:0000232D                 mov     ebp, esp
.text$mn:0000232F                 mov     eax, [ebp+arg_4]
.text$mn:00002332                 push    eax
.text$mn:00002333                 mov     ecx, [ebp+arg_0]
.text$mn:00002336                 call    ??$destroy@U?$pair@$$CBHUStyle@@@std@@@?$allocator@U?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBHUStyle@@@1@@Z ; std::allocator<std::_List_node<std::pair<int const,Style>,void *>>::destroy<std::pair<int const,Style>>(std::pair<int const,Style> *)
.text$mn:0000233B                 pop     ebp
.text$mn:0000233C                 retn
.text$mn:0000233C ??$destroy@U?$pair@$$CBHUStyle@@@std@@@?$allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@std@@@1@PAU?$pair@$$CBHUStyle@@@1@@Z endp
.text$mn:0000233C
.text$mn:0000233C ; ---------------------------------------------------------------------------
.text$mn:0000233D                 align 10h
.text$mn:0000233D _text$mn        ends
.text$mn:0000233D
.text$mn:00002340 ; ===========================================================================
.text$mn:00002340
.text$mn:00002340 ; Segment type: Pure code
.text$mn:00002340 ; Segment permissions: Read/Execute
.text$mn:00002340 _text$mn        segment para public 'CODE' use32
.text$mn:00002340                 assume cs:_text$mn
.text$mn:00002340                 ;org 2340h
.text$mn:00002340 ; COMDAT (pick any)
.text$mn:00002340                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002340
.text$mn:00002340 ; =============== S U B R O U T I N E =======================================
.text$mn:00002340
.text$mn:00002340 ; Attributes: bp-based frame
.text$mn:00002340
.text$mn:00002340 ; public: void __thiscall std::_Wrap_alloc<class std::allocator<struct std::_List_node<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>, void *>>>::destroy<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>(struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *> *)
.text$mn:00002340                 public ??$destroy@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@1@@Z
.text$mn:00002340 ??$destroy@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@1@@Z proc near
.text$mn:00002340                                         ; CODE XREF: std::_List_buy<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>::_Freenode(std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *)+7Fp
.text$mn:00002340
.text$mn:00002340 var_4           = dword ptr -4
.text$mn:00002340 arg_0           = dword ptr  8
.text$mn:00002340
.text$mn:00002340                 push    ebp
.text$mn:00002341                 mov     ebp, esp
.text$mn:00002343                 push    ecx
.text$mn:00002344                 mov     [ebp+var_4], ecx
.text$mn:00002347                 mov     eax, [ebp+arg_0]
.text$mn:0000234A                 push    eax
.text$mn:0000234B                 mov     ecx, [ebp+var_4]
.text$mn:0000234E                 push    ecx
.text$mn:0000234F                 call    ??$destroy@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@?$allocator_traits@V?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@1@PAU?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@1@@Z ; std::allocator_traits<std::allocator<std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *>>>::destroy<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>(std::allocator<std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *>> &,std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *> *)
.text$mn:00002354                 add     esp, 8
.text$mn:00002357                 mov     esp, ebp
.text$mn:00002359                 pop     ebp
.text$mn:0000235A                 retn    4
.text$mn:0000235A ??$destroy@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@1@@Z endp
.text$mn:0000235A
.text$mn:0000235A ; ---------------------------------------------------------------------------
.text$mn:0000235D                 align 10h
.text$mn:0000235D _text$mn        ends
.text$mn:0000235D
.text$mn:00002360 ; ===========================================================================
.text$mn:00002360
.text$mn:00002360 ; Segment type: Pure code
.text$mn:00002360 ; Segment permissions: Read/Execute
.text$mn:00002360 _text$mn        segment para public 'CODE' use32
.text$mn:00002360                 assume cs:_text$mn
.text$mn:00002360                 ;org 2360h
.text$mn:00002360 ; COMDAT (pick any)
.text$mn:00002360                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002360
.text$mn:00002360 ; =============== S U B R O U T I N E =======================================
.text$mn:00002360
.text$mn:00002360 ; Attributes: bp-based frame
.text$mn:00002360
.text$mn:00002360 ; public: void __thiscall std::allocator<struct std::_List_node<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>, void *>>::destroy<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>(struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *> *)
.text$mn:00002360                 public ??$destroy@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@QAEXPAU?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@1@@Z
.text$mn:00002360 ??$destroy@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@QAEXPAU?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@1@@Z proc near
.text$mn:00002360                                         ; CODE XREF: std::allocator_traits<std::allocator<std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *>>>::destroy<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>(std::allocator<std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *>> &,std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *> *)+Ap
.text$mn:00002360
.text$mn:00002360 var_4           = dword ptr -4
.text$mn:00002360
.text$mn:00002360                 push    ebp
.text$mn:00002361                 mov     ebp, esp
.text$mn:00002363                 push    ecx
.text$mn:00002364                 mov     [ebp+var_4], ecx
.text$mn:00002367                 mov     esp, ebp
.text$mn:00002369                 pop     ebp
.text$mn:0000236A                 retn    4
.text$mn:0000236A ??$destroy@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@QAEXPAU?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@1@@Z endp
.text$mn:0000236A
.text$mn:0000236A ; ---------------------------------------------------------------------------
.text$mn:0000236D                 align 10h
.text$mn:0000236D _text$mn        ends
.text$mn:0000236D
.text$mn:00002370 ; ===========================================================================
.text$mn:00002370
.text$mn:00002370 ; Segment type: Pure code
.text$mn:00002370 ; Segment permissions: Read/Execute
.text$mn:00002370 _text$mn        segment para public 'CODE' use32
.text$mn:00002370                 assume cs:_text$mn
.text$mn:00002370                 ;org 2370h
.text$mn:00002370 ; COMDAT (pick any)
.text$mn:00002370                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002370
.text$mn:00002370 ; =============== S U B R O U T I N E =======================================
.text$mn:00002370
.text$mn:00002370 ; Attributes: bp-based frame
.text$mn:00002370
.text$mn:00002370 ; public: static void __cdecl std::allocator_traits<class std::allocator<struct std::_List_node<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>, void *>>>::destroy<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>(class std::allocator<struct std::_List_node<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>, void *>> &, struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *> *)
.text$mn:00002370                 public ??$destroy@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@?$allocator_traits@V?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@1@PAU?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@1@@Z
.text$mn:00002370 ??$destroy@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@?$allocator_traits@V?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@1@PAU?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@1@@Z proc near
.text$mn:00002370                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *>>>::destroy<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>(std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *> *)+Fp
.text$mn:00002370
.text$mn:00002370 arg_0           = dword ptr  8
.text$mn:00002370 arg_4           = dword ptr  0Ch
.text$mn:00002370
.text$mn:00002370                 push    ebp
.text$mn:00002371                 mov     ebp, esp
.text$mn:00002373                 mov     eax, [ebp+arg_4]
.text$mn:00002376                 push    eax
.text$mn:00002377                 mov     ecx, [ebp+arg_0]
.text$mn:0000237A                 call    ??$destroy@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@QAEXPAU?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@1@@Z ; std::allocator<std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *>>::destroy<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>(std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *> *)
.text$mn:0000237F                 pop     ebp
.text$mn:00002380                 retn
.text$mn:00002380 ??$destroy@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@?$allocator_traits@V?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@1@PAU?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@1@@Z endp
.text$mn:00002380
.text$mn:00002380 ; ---------------------------------------------------------------------------
.text$mn:00002381                 align 4
.text$mn:00002381 _text$mn        ends
.text$mn:00002381
.text$mn:00002384 ; ===========================================================================
.text$mn:00002384
.text$mn:00002384 ; Segment type: Pure code
.text$mn:00002384 ; Segment permissions: Read/Execute
.text$mn:00002384 _text$mn        segment para public 'CODE' use32
.text$mn:00002384                 assume cs:_text$mn
.text$mn:00002384                 ;org 2384h
.text$mn:00002384 ; COMDAT (pick any)
.text$mn:00002384                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002384
.text$mn:00002384 ; =============== S U B R O U T I N E =======================================
.text$mn:00002384
.text$mn:00002384 ; Attributes: bp-based frame
.text$mn:00002384
.text$mn:00002384 ; public: void __thiscall std::_Wrap_alloc<struct std::_Wrap_alloc<class std::allocator<struct std::_Container_proxy>>>::destroy<struct std::_Container_proxy>(struct std::_Container_proxy *)
.text$mn:00002384                 public ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z
.text$mn:00002384 ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z proc near
.text$mn:00002384                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>>>>>::_Free_proxy(void)+22p
.text$mn:00002384                                         ; std::_Vector_alloc<0,std::_Vec_base_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>>::_Free_proxy(void)+22p
.text$mn:00002384
.text$mn:00002384 var_4           = dword ptr -4
.text$mn:00002384 arg_0           = dword ptr  8
.text$mn:00002384
.text$mn:00002384                 push    ebp
.text$mn:00002385                 mov     ebp, esp
.text$mn:00002387                 push    ecx
.text$mn:00002388                 mov     [ebp+var_4], ecx
.text$mn:0000238B                 mov     eax, [ebp+arg_0]
.text$mn:0000238E                 push    eax
.text$mn:0000238F                 mov     ecx, [ebp+var_4]
.text$mn:00002392                 push    ecx
.text$mn:00002393                 call    ??$destroy@U_Container_proxy@std@@@?$allocator_traits@U?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@@std@@SAXAAU?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@1@PAU_Container_proxy@1@@Z ; std::allocator_traits<std::_Wrap_alloc<std::allocator<std::_Container_proxy>>>::destroy<std::_Container_proxy>(std::_Wrap_alloc<std::allocator<std::_Container_proxy>> &,std::_Container_proxy *)
.text$mn:00002398                 add     esp, 8
.text$mn:0000239B                 mov     esp, ebp
.text$mn:0000239D                 pop     ebp
.text$mn:0000239E                 retn    4
.text$mn:0000239E ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z endp
.text$mn:0000239E
.text$mn:0000239E ; ---------------------------------------------------------------------------
.text$mn:000023A1                 align 4
.text$mn:000023A1 _text$mn        ends
.text$mn:000023A1
.text$mn:000023A4 ; ===========================================================================
.text$mn:000023A4
.text$mn:000023A4 ; Segment type: Pure code
.text$mn:000023A4 ; Segment permissions: Read/Execute
.text$mn:000023A4 _text$mn        segment para public 'CODE' use32
.text$mn:000023A4                 assume cs:_text$mn
.text$mn:000023A4                 ;org 23A4h
.text$mn:000023A4 ; COMDAT (pick any)
.text$mn:000023A4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000023A4
.text$mn:000023A4 ; =============== S U B R O U T I N E =======================================
.text$mn:000023A4
.text$mn:000023A4 ; Attributes: bp-based frame
.text$mn:000023A4
.text$mn:000023A4 ; public: void __thiscall std::_Wrap_alloc<class std::allocator<struct std::_Container_proxy>>::destroy<struct std::_Container_proxy>(struct std::_Container_proxy *)
.text$mn:000023A4                 public ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z
.text$mn:000023A4 ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z proc near
.text$mn:000023A4                                         ; CODE XREF: std::_Alloc_destroy::_Fn<std::_Wrap_alloc<std::allocator<std::_Container_proxy>>,std::_Container_proxy>(int,std::_Wrap_alloc<std::allocator<std::_Container_proxy>> &,std::_Container_proxy *)+Ap
.text$mn:000023A4                                         ; std::_List_alloc<0,std::_List_base_types<std::pair<int const,Style>,std::allocator<std::pair<int const,Style>>>>::_Free_proxy(void)+22p ...
.text$mn:000023A4
.text$mn:000023A4 var_4           = dword ptr -4
.text$mn:000023A4 arg_0           = dword ptr  8
.text$mn:000023A4
.text$mn:000023A4                 push    ebp
.text$mn:000023A5                 mov     ebp, esp
.text$mn:000023A7                 push    ecx
.text$mn:000023A8                 mov     [ebp+var_4], ecx
.text$mn:000023AB                 mov     eax, [ebp+arg_0]
.text$mn:000023AE                 push    eax
.text$mn:000023AF                 mov     ecx, [ebp+var_4]
.text$mn:000023B2                 push    ecx
.text$mn:000023B3                 call    ??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z ; std::allocator_traits<std::allocator<std::_Container_proxy>>::destroy<std::_Container_proxy>(std::allocator<std::_Container_proxy> &,std::_Container_proxy *)
.text$mn:000023B8                 add     esp, 8
.text$mn:000023BB                 mov     esp, ebp
.text$mn:000023BD                 pop     ebp
.text$mn:000023BE                 retn    4
.text$mn:000023BE ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z endp
.text$mn:000023BE
.text$mn:000023BE ; ---------------------------------------------------------------------------
.text$mn:000023C1                 align 4
.text$mn:000023C1 _text$mn        ends
.text$mn:000023C1
.text$mn:000023C4 ; ===========================================================================
.text$mn:000023C4
.text$mn:000023C4 ; Segment type: Pure code
.text$mn:000023C4 ; Segment permissions: Read/Execute
.text$mn:000023C4 _text$mn        segment para public 'CODE' use32
.text$mn:000023C4                 assume cs:_text$mn
.text$mn:000023C4                 ;org 23C4h
.text$mn:000023C4 ; COMDAT (pick any)
.text$mn:000023C4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000023C4
.text$mn:000023C4 ; =============== S U B R O U T I N E =======================================
.text$mn:000023C4
.text$mn:000023C4 ; Attributes: bp-based frame
.text$mn:000023C4
.text$mn:000023C4 ; public: void __thiscall std::allocator<struct std::_Container_proxy>::destroy<struct std::_Container_proxy>(struct std::_Container_proxy *)
.text$mn:000023C4                 public ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z
.text$mn:000023C4 ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z proc near
.text$mn:000023C4                                         ; CODE XREF: std::allocator_traits<std::allocator<std::_Container_proxy>>::destroy<std::_Container_proxy>(std::allocator<std::_Container_proxy> &,std::_Container_proxy *)+Ap
.text$mn:000023C4                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+22p ...
.text$mn:000023C4
.text$mn:000023C4 var_4           = dword ptr -4
.text$mn:000023C4
.text$mn:000023C4                 push    ebp
.text$mn:000023C5                 mov     ebp, esp
.text$mn:000023C7                 push    ecx
.text$mn:000023C8                 mov     [ebp+var_4], ecx
.text$mn:000023CB                 mov     esp, ebp
.text$mn:000023CD                 pop     ebp
.text$mn:000023CE                 retn    4
.text$mn:000023CE ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z endp
.text$mn:000023CE
.text$mn:000023CE ; ---------------------------------------------------------------------------
.text$mn:000023D1                 align 4
.text$mn:000023D1 _text$mn        ends
.text$mn:000023D1
.text$mn:000023D4 ; ===========================================================================
.text$mn:000023D4
.text$mn:000023D4 ; Segment type: Pure code
.text$mn:000023D4 ; Segment permissions: Read/Execute
.text$mn:000023D4 _text$mn        segment para public 'CODE' use32
.text$mn:000023D4                 assume cs:_text$mn
.text$mn:000023D4                 ;org 23D4h
.text$mn:000023D4 ; COMDAT (pick any)
.text$mn:000023D4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000023D4
.text$mn:000023D4 ; =============== S U B R O U T I N E =======================================
.text$mn:000023D4
.text$mn:000023D4 ; Attributes: bp-based frame
.text$mn:000023D4
.text$mn:000023D4 ; public: static void __cdecl std::allocator_traits<struct std::_Wrap_alloc<class std::allocator<struct std::_Container_proxy>>>::destroy<struct std::_Container_proxy>(struct std::_Wrap_alloc<class std::allocator<struct std::_Container_proxy>> &, struct std::_Container_proxy *)
.text$mn:000023D4                 public ??$destroy@U_Container_proxy@std@@@?$allocator_traits@U?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@@std@@SAXAAU?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@1@PAU_Container_proxy@1@@Z
.text$mn:000023D4 ??$destroy@U_Container_proxy@std@@@?$allocator_traits@U?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@@std@@SAXAAU?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@1@PAU_Container_proxy@1@@Z proc near
.text$mn:000023D4                                         ; CODE XREF: std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_Container_proxy>>>::destroy<std::_Container_proxy>(std::_Container_proxy *)+Fp
.text$mn:000023D4
.text$mn:000023D4 arg_0           = dword ptr  8
.text$mn:000023D4 arg_4           = dword ptr  0Ch
.text$mn:000023D4
.text$mn:000023D4                 push    ebp
.text$mn:000023D5                 mov     ebp, esp
.text$mn:000023D7                 mov     eax, [ebp+arg_4]
.text$mn:000023DA                 push    eax
.text$mn:000023DB                 mov     ecx, [ebp+arg_0]
.text$mn:000023DE                 push    ecx
.text$mn:000023DF                 push    0
.text$mn:000023E1                 call    ??$_Fn@U?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@U_Container_proxy@2@@_Alloc_destroy@std@@SAXHAAU?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@1@PAU_Container_proxy@1@@Z ; std::_Alloc_destroy::_Fn<std::_Wrap_alloc<std::allocator<std::_Container_proxy>>,std::_Container_proxy>(int,std::_Wrap_alloc<std::allocator<std::_Container_proxy>> &,std::_Container_proxy *)
.text$mn:000023E6                 add     esp, 0Ch
.text$mn:000023E9                 pop     ebp
.text$mn:000023EA                 retn
.text$mn:000023EA ??$destroy@U_Container_proxy@std@@@?$allocator_traits@U?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@@std@@SAXAAU?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@1@PAU_Container_proxy@1@@Z endp
.text$mn:000023EA
.text$mn:000023EA ; ---------------------------------------------------------------------------
.text$mn:000023EB                 align 4
.text$mn:000023EB _text$mn        ends
.text$mn:000023EB
.text$mn:000023EC ; ===========================================================================
.text$mn:000023EC
.text$mn:000023EC ; Segment type: Pure code
.text$mn:000023EC ; Segment permissions: Read/Execute
.text$mn:000023EC _text$mn        segment para public 'CODE' use32
.text$mn:000023EC                 assume cs:_text$mn
.text$mn:000023EC                 ;org 23ECh
.text$mn:000023EC ; COMDAT (pick any)
.text$mn:000023EC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000023EC
.text$mn:000023EC ; =============== S U B R O U T I N E =======================================
.text$mn:000023EC
.text$mn:000023EC ; Attributes: bp-based frame
.text$mn:000023EC
.text$mn:000023EC ; public: static void __cdecl std::allocator_traits<class std::allocator<struct std::_Container_proxy>>::destroy<struct std::_Container_proxy>(class std::allocator<struct std::_Container_proxy> &, struct std::_Container_proxy *)
.text$mn:000023EC                 public ??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z
.text$mn:000023EC ??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z proc near
.text$mn:000023EC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::destroy<std::_Container_proxy>(std::_Container_proxy *)+Fp
.text$mn:000023EC
.text$mn:000023EC arg_0           = dword ptr  8
.text$mn:000023EC arg_4           = dword ptr  0Ch
.text$mn:000023EC
.text$mn:000023EC                 push    ebp
.text$mn:000023ED                 mov     ebp, esp
.text$mn:000023EF                 mov     eax, [ebp+arg_4]
.text$mn:000023F2                 push    eax
.text$mn:000023F3                 mov     ecx, [ebp+arg_0]
.text$mn:000023F6                 call    ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:000023FB                 pop     ebp
.text$mn:000023FC                 retn
.text$mn:000023FC ??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z endp
.text$mn:000023FC
.text$mn:000023FC ; ---------------------------------------------------------------------------
.text$mn:000023FD                 align 10h
.text$mn:000023FD _text$mn        ends
.text$mn:000023FD
.text$mn:00002400 ; ===========================================================================
.text$mn:00002400
.text$mn:00002400 ; Segment type: Pure code
.text$mn:00002400 ; Segment permissions: Read/Execute
.text$mn:00002400 _text$mn        segment para public 'CODE' use32
.text$mn:00002400                 assume cs:_text$mn
.text$mn:00002400                 ;org 2400h
.text$mn:00002400 ; COMDAT (pick any)
.text$mn:00002400                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002400
.text$mn:00002400 ; =============== S U B R O U T I N E =======================================
.text$mn:00002400
.text$mn:00002400 ; Attributes: bp-based frame
.text$mn:00002400
.text$mn:00002400 ; public: void __thiscall std::_Wrap_alloc<struct std::_Wrap_alloc<class std::allocator<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<int const, struct Style>>>>>>>::destroy<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<int const, struct Style>>>>>(class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<int const, struct Style>>>> *)
.text$mn:00002400                 public ??$destroy@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@1@@Z
.text$mn:00002400 ??$destroy@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@1@@Z proc near
.text$mn:00002400                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>>>>>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>> *,std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>>>> &,std::_Nonscalar_ptr_iterator_tag)+1Dp
.text$mn:00002400
.text$mn:00002400 var_4           = dword ptr -4
.text$mn:00002400 arg_0           = dword ptr  8
.text$mn:00002400
.text$mn:00002400                 push    ebp
.text$mn:00002401                 mov     ebp, esp
.text$mn:00002403                 push    ecx
.text$mn:00002404                 mov     [ebp+var_4], ecx
.text$mn:00002407                 mov     eax, [ebp+arg_0]
.text$mn:0000240A                 push    eax
.text$mn:0000240B                 mov     ecx, [ebp+var_4]
.text$mn:0000240E                 push    ecx
.text$mn:0000240F                 call    ??$destroy@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@?$allocator_traits@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SAXAAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@1@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@1@@Z ; std::allocator_traits<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>>>>::destroy<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>>(std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>>> &,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>> *)
.text$mn:00002414                 add     esp, 8
.text$mn:00002417                 mov     esp, ebp
.text$mn:00002419                 pop     ebp
.text$mn:0000241A                 retn    4
.text$mn:0000241A ??$destroy@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@1@@Z endp
.text$mn:0000241A
.text$mn:0000241A ; ---------------------------------------------------------------------------
.text$mn:0000241D                 align 10h
.text$mn:0000241D _text$mn        ends
.text$mn:0000241D
.text$mn:00002420 ; ===========================================================================
.text$mn:00002420
.text$mn:00002420 ; Segment type: Pure code
.text$mn:00002420 ; Segment permissions: Read/Execute
.text$mn:00002420 _text$mn        segment para public 'CODE' use32
.text$mn:00002420                 assume cs:_text$mn
.text$mn:00002420                 ;org 2420h
.text$mn:00002420 ; COMDAT (pick any)
.text$mn:00002420                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002420
.text$mn:00002420 ; =============== S U B R O U T I N E =======================================
.text$mn:00002420
.text$mn:00002420 ; Attributes: bp-based frame
.text$mn:00002420
.text$mn:00002420 ; public: void __thiscall std::_Wrap_alloc<class std::allocator<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<int const, struct Style>>>>>>::destroy<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<int const, struct Style>>>>>(class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<int const, struct Style>>>> *)
.text$mn:00002420                 public ??$destroy@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@1@@Z
.text$mn:00002420 ??$destroy@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@1@@Z proc near
.text$mn:00002420                                         ; CODE XREF: std::_Alloc_destroy::_Fn<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>>>,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>>(int,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>>> &,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>> *)+Ap
.text$mn:00002420
.text$mn:00002420 var_4           = dword ptr -4
.text$mn:00002420 arg_0           = dword ptr  8
.text$mn:00002420
.text$mn:00002420                 push    ebp
.text$mn:00002421                 mov     ebp, esp
.text$mn:00002423                 push    ecx
.text$mn:00002424                 mov     [ebp+var_4], ecx
.text$mn:00002427                 mov     eax, [ebp+arg_0]
.text$mn:0000242A                 push    eax
.text$mn:0000242B                 mov     ecx, [ebp+var_4]
.text$mn:0000242E                 push    ecx
.text$mn:0000242F                 call    ??$destroy@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@?$allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@std@@SAXAAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@1@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@1@@Z ; std::allocator_traits<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>>>::destroy<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>>(std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>> &,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>> *)
.text$mn:00002434                 add     esp, 8
.text$mn:00002437                 mov     esp, ebp
.text$mn:00002439                 pop     ebp
.text$mn:0000243A                 retn    4
.text$mn:0000243A ??$destroy@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@1@@Z endp
.text$mn:0000243A
.text$mn:0000243A ; ---------------------------------------------------------------------------
.text$mn:0000243D                 align 10h
.text$mn:0000243D _text$mn        ends
.text$mn:0000243D
.text$mn:00002440 ; ===========================================================================
.text$mn:00002440
.text$mn:00002440 ; Segment type: Pure code
.text$mn:00002440 ; Segment permissions: Read/Execute
.text$mn:00002440 _text$mn        segment para public 'CODE' use32
.text$mn:00002440                 assume cs:_text$mn
.text$mn:00002440                 ;org 2440h
.text$mn:00002440 ; COMDAT (pick any)
.text$mn:00002440                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002440
.text$mn:00002440 ; =============== S U B R O U T I N E =======================================
.text$mn:00002440
.text$mn:00002440 ; Attributes: bp-based frame
.text$mn:00002440
.text$mn:00002440 ; public: void __thiscall std::allocator<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<int const, struct Style>>>>>::destroy<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<int const, struct Style>>>>>(class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<int const, struct Style>>>> *)
.text$mn:00002440                 public ??$destroy@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@1@@Z
.text$mn:00002440 ??$destroy@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@1@@Z proc near
.text$mn:00002440                                         ; CODE XREF: std::allocator_traits<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>>>::destroy<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>>(std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>> &,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>> *)+Ap
.text$mn:00002440
.text$mn:00002440 var_4           = dword ptr -4
.text$mn:00002440
.text$mn:00002440                 push    ebp
.text$mn:00002441                 mov     ebp, esp
.text$mn:00002443                 push    ecx
.text$mn:00002444                 mov     [ebp+var_4], ecx
.text$mn:00002447                 mov     esp, ebp
.text$mn:00002449                 pop     ebp
.text$mn:0000244A                 retn    4
.text$mn:0000244A ??$destroy@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@1@@Z endp
.text$mn:0000244A
.text$mn:0000244A ; ---------------------------------------------------------------------------
.text$mn:0000244D                 align 10h
.text$mn:0000244D _text$mn        ends
.text$mn:0000244D
.text$mn:00002450 ; ===========================================================================
.text$mn:00002450
.text$mn:00002450 ; Segment type: Pure code
.text$mn:00002450 ; Segment permissions: Read/Execute
.text$mn:00002450 _text$mn        segment para public 'CODE' use32
.text$mn:00002450                 assume cs:_text$mn
.text$mn:00002450                 ;org 2450h
.text$mn:00002450 ; COMDAT (pick any)
.text$mn:00002450                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002450
.text$mn:00002450 ; =============== S U B R O U T I N E =======================================
.text$mn:00002450
.text$mn:00002450 ; Attributes: bp-based frame
.text$mn:00002450
.text$mn:00002450 ; public: static void __cdecl std::allocator_traits<struct std::_Wrap_alloc<class std::allocator<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<int const, struct Style>>>>>>>::destroy<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<int const, struct Style>>>>>(struct std::_Wrap_alloc<class std::allocator<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<int const, struct Style>>>>>> &, class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<int const, struct Style>>>> *)
.text$mn:00002450                 public ??$destroy@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@?$allocator_traits@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SAXAAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@1@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@1@@Z
.text$mn:00002450 ??$destroy@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@?$allocator_traits@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SAXAAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@1@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@1@@Z proc near
.text$mn:00002450                                         ; CODE XREF: std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>>>>::destroy<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>> *)+Fp
.text$mn:00002450
.text$mn:00002450 arg_0           = dword ptr  8
.text$mn:00002450 arg_4           = dword ptr  0Ch
.text$mn:00002450
.text$mn:00002450                 push    ebp
.text$mn:00002451                 mov     ebp, esp
.text$mn:00002453                 mov     eax, [ebp+arg_4]
.text$mn:00002456                 push    eax
.text$mn:00002457                 mov     ecx, [ebp+arg_0]
.text$mn:0000245A                 push    ecx
.text$mn:0000245B                 push    0
.text$mn:0000245D                 call    ??$_Fn@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@2@@_Alloc_destroy@std@@SAXHAAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@1@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@1@@Z ; std::_Alloc_destroy::_Fn<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>>>,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>>(int,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>>> &,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>> *)
.text$mn:00002462                 add     esp, 0Ch
.text$mn:00002465                 pop     ebp
.text$mn:00002466                 retn
.text$mn:00002466 ??$destroy@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@?$allocator_traits@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SAXAAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@1@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@1@@Z endp
.text$mn:00002466
.text$mn:00002466 ; ---------------------------------------------------------------------------
.text$mn:00002467                 align 4
.text$mn:00002467 _text$mn        ends
.text$mn:00002467
.text$mn:00002468 ; ===========================================================================
.text$mn:00002468
.text$mn:00002468 ; Segment type: Pure code
.text$mn:00002468 ; Segment permissions: Read/Execute
.text$mn:00002468 _text$mn        segment para public 'CODE' use32
.text$mn:00002468                 assume cs:_text$mn
.text$mn:00002468                 ;org 2468h
.text$mn:00002468 ; COMDAT (pick any)
.text$mn:00002468                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002468
.text$mn:00002468 ; =============== S U B R O U T I N E =======================================
.text$mn:00002468
.text$mn:00002468 ; Attributes: bp-based frame
.text$mn:00002468
.text$mn:00002468 ; public: static void __cdecl std::allocator_traits<class std::allocator<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<int const, struct Style>>>>>>::destroy<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<int const, struct Style>>>>>(class std::allocator<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<int const, struct Style>>>>> &, class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<int const, struct Style>>>> *)
.text$mn:00002468                 public ??$destroy@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@?$allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@std@@SAXAAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@1@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@1@@Z
.text$mn:00002468 ??$destroy@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@?$allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@std@@SAXAAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@1@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@1@@Z proc near
.text$mn:00002468                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>>>::destroy<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>> *)+Fp
.text$mn:00002468
.text$mn:00002468 arg_0           = dword ptr  8
.text$mn:00002468 arg_4           = dword ptr  0Ch
.text$mn:00002468
.text$mn:00002468                 push    ebp
.text$mn:00002469                 mov     ebp, esp
.text$mn:0000246B                 mov     eax, [ebp+arg_4]
.text$mn:0000246E                 push    eax
.text$mn:0000246F                 mov     ecx, [ebp+arg_0]
.text$mn:00002472                 call    ??$destroy@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@1@@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>>::destroy<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>> *)
.text$mn:00002477                 pop     ebp
.text$mn:00002478                 retn
.text$mn:00002478 ??$destroy@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@?$allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@std@@SAXAAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@1@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@1@@Z endp
.text$mn:00002478
.text$mn:00002478 ; ---------------------------------------------------------------------------
.text$mn:00002479                 align 4
.text$mn:00002479 _text$mn        ends
.text$mn:00002479
.text$mn:0000247C ; ===========================================================================
.text$mn:0000247C
.text$mn:0000247C ; Segment type: Pure code
.text$mn:0000247C ; Segment permissions: Read/Execute
.text$mn:0000247C _text$mn        segment para public 'CODE' use32
.text$mn:0000247C                 assume cs:_text$mn
.text$mn:0000247C                 ;org 247Ch
.text$mn:0000247C ; COMDAT (pick any)
.text$mn:0000247C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000247C
.text$mn:0000247C ; =============== S U B R O U T I N E =======================================
.text$mn:0000247C
.text$mn:0000247C ; Attributes: bp-based frame
.text$mn:0000247C
.text$mn:0000247C ; public: void __thiscall std::_Wrap_alloc<struct std::_Wrap_alloc<class std::allocator<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>>>>::destroy<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>>(class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>> *)
.text$mn:0000247C                 public ??$destroy@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@@Z
.text$mn:0000247C ??$destroy@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@@Z proc near
.text$mn:0000247C                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>> &,std::_Nonscalar_ptr_iterator_tag)+1Dp
.text$mn:0000247C                                         ; __catch$??$_Uninit_fill_n@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@IV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@V12@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@IPBV10@AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@0@0U_Nons ...
.text$mn:0000247C
.text$mn:0000247C var_4           = dword ptr -4
.text$mn:0000247C arg_0           = dword ptr  8
.text$mn:0000247C
.text$mn:0000247C                 push    ebp
.text$mn:0000247D                 mov     ebp, esp
.text$mn:0000247F                 push    ecx
.text$mn:00002480                 mov     [ebp+var_4], ecx
.text$mn:00002483                 mov     eax, [ebp+arg_0]
.text$mn:00002486                 push    eax
.text$mn:00002487                 mov     ecx, [ebp+var_4]
.text$mn:0000248A                 push    ecx
.text$mn:0000248B                 call    ??$destroy@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@?$allocator_traits@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SAXAAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@1@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@@Z ; std::allocator_traits<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::destroy<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>(std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>> &,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *)
.text$mn:00002490                 add     esp, 8
.text$mn:00002493                 mov     esp, ebp
.text$mn:00002495                 pop     ebp
.text$mn:00002496                 retn    4
.text$mn:00002496 ??$destroy@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@@Z endp
.text$mn:00002496
.text$mn:00002496 ; ---------------------------------------------------------------------------
.text$mn:00002499                 align 4
.text$mn:00002499 _text$mn        ends
.text$mn:00002499
.text$mn:0000249C ; ===========================================================================
.text$mn:0000249C
.text$mn:0000249C ; Segment type: Pure code
.text$mn:0000249C ; Segment permissions: Read/Execute
.text$mn:0000249C _text$mn        segment para public 'CODE' use32
.text$mn:0000249C                 assume cs:_text$mn
.text$mn:0000249C                 ;org 249Ch
.text$mn:0000249C ; COMDAT (pick any)
.text$mn:0000249C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000249C
.text$mn:0000249C ; =============== S U B R O U T I N E =======================================
.text$mn:0000249C
.text$mn:0000249C ; Attributes: bp-based frame
.text$mn:0000249C
.text$mn:0000249C ; public: void __thiscall std::_Wrap_alloc<class std::allocator<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>>>::destroy<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>>(class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>> *)
.text$mn:0000249C                 public ??$destroy@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@@Z
.text$mn:0000249C ??$destroy@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@@Z proc near
.text$mn:0000249C                                         ; CODE XREF: std::_Alloc_destroy::_Fn<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>(int,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>> &,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *)+Ap
.text$mn:0000249C
.text$mn:0000249C var_4           = dword ptr -4
.text$mn:0000249C arg_0           = dword ptr  8
.text$mn:0000249C
.text$mn:0000249C                 push    ebp
.text$mn:0000249D                 mov     ebp, esp
.text$mn:0000249F                 push    ecx
.text$mn:000024A0                 mov     [ebp+var_4], ecx
.text$mn:000024A3                 mov     eax, [ebp+arg_0]
.text$mn:000024A6                 push    eax
.text$mn:000024A7                 mov     ecx, [ebp+var_4]
.text$mn:000024AA                 push    ecx
.text$mn:000024AB                 call    ??$destroy@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@?$allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SAXAAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@1@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@@Z ; std::allocator_traits<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>::destroy<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>(std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>> &,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *)
.text$mn:000024B0                 add     esp, 8
.text$mn:000024B3                 mov     esp, ebp
.text$mn:000024B5                 pop     ebp
.text$mn:000024B6                 retn    4
.text$mn:000024B6 ??$destroy@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@@Z endp
.text$mn:000024B6
.text$mn:000024B6 ; ---------------------------------------------------------------------------
.text$mn:000024B9                 align 4
.text$mn:000024B9 _text$mn        ends
.text$mn:000024B9
.text$mn:000024BC ; ===========================================================================
.text$mn:000024BC
.text$mn:000024BC ; Segment type: Pure code
.text$mn:000024BC ; Segment permissions: Read/Execute
.text$mn:000024BC _text$mn        segment para public 'CODE' use32
.text$mn:000024BC                 assume cs:_text$mn
.text$mn:000024BC                 ;org 24BCh
.text$mn:000024BC ; COMDAT (pick any)
.text$mn:000024BC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000024BC
.text$mn:000024BC ; =============== S U B R O U T I N E =======================================
.text$mn:000024BC
.text$mn:000024BC ; Attributes: bp-based frame
.text$mn:000024BC
.text$mn:000024BC ; public: void __thiscall std::allocator<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>>::destroy<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>>(class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>> *)
.text$mn:000024BC                 public ??$destroy@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@@Z
.text$mn:000024BC ??$destroy@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@@Z proc near
.text$mn:000024BC                                         ; CODE XREF: std::allocator_traits<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>::destroy<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>(std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>> &,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *)+Ap
.text$mn:000024BC
.text$mn:000024BC var_4           = dword ptr -4
.text$mn:000024BC
.text$mn:000024BC                 push    ebp
.text$mn:000024BD                 mov     ebp, esp
.text$mn:000024BF                 push    ecx
.text$mn:000024C0                 mov     [ebp+var_4], ecx
.text$mn:000024C3                 mov     esp, ebp
.text$mn:000024C5                 pop     ebp
.text$mn:000024C6                 retn    4
.text$mn:000024C6 ??$destroy@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@@Z endp
.text$mn:000024C6
.text$mn:000024C6 ; ---------------------------------------------------------------------------
.text$mn:000024C9                 align 4
.text$mn:000024C9 _text$mn        ends
.text$mn:000024C9
.text$mn:000024CC ; ===========================================================================
.text$mn:000024CC
.text$mn:000024CC ; Segment type: Pure code
.text$mn:000024CC ; Segment permissions: Read/Execute
.text$mn:000024CC _text$mn        segment para public 'CODE' use32
.text$mn:000024CC                 assume cs:_text$mn
.text$mn:000024CC                 ;org 24CCh
.text$mn:000024CC ; COMDAT (pick any)
.text$mn:000024CC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000024CC
.text$mn:000024CC ; =============== S U B R O U T I N E =======================================
.text$mn:000024CC
.text$mn:000024CC ; Attributes: bp-based frame
.text$mn:000024CC
.text$mn:000024CC ; public: static void __cdecl std::allocator_traits<struct std::_Wrap_alloc<class std::allocator<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>>>>::destroy<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>>(struct std::_Wrap_alloc<class std::allocator<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style
.text$mn:000024CC                 public ??$destroy@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@?$allocator_traits@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SAXAAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@1@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@@Z
.text$mn:000024CC ??$destroy@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@?$allocator_traits@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SAXAAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@1@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@@Z proc near
.text$mn:000024CC                                         ; CODE XREF: std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::destroy<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *)+Fp
.text$mn:000024CC
.text$mn:000024CC arg_0           = dword ptr  8
.text$mn:000024CC arg_4           = dword ptr  0Ch
.text$mn:000024CC
.text$mn:000024CC                 push    ebp
.text$mn:000024CD                 mov     ebp, esp
.text$mn:000024CF                 mov     eax, [ebp+arg_4]
.text$mn:000024D2                 push    eax
.text$mn:000024D3                 mov     ecx, [ebp+arg_0]
.text$mn:000024D6                 push    ecx
.text$mn:000024D7                 push    0
.text$mn:000024D9                 call    ??$_Fn@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@@_Alloc_destroy@std@@SAXHAAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@1@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@@Z ; std::_Alloc_destroy::_Fn<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>(int,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>> &,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *)
.text$mn:000024DE                 add     esp, 0Ch
.text$mn:000024E1                 pop     ebp
.text$mn:000024E2                 retn
.text$mn:000024E2 ??$destroy@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@?$allocator_traits@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SAXAAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@1@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@@Z endp
.text$mn:000024E2
.text$mn:000024E2 ; ---------------------------------------------------------------------------
.text$mn:000024E3                 align 4
.text$mn:000024E3 _text$mn        ends
.text$mn:000024E3
.text$mn:000024E4 ; ===========================================================================
.text$mn:000024E4
.text$mn:000024E4 ; Segment type: Pure code
.text$mn:000024E4 ; Segment permissions: Read/Execute
.text$mn:000024E4 _text$mn        segment para public 'CODE' use32
.text$mn:000024E4                 assume cs:_text$mn
.text$mn:000024E4                 ;org 24E4h
.text$mn:000024E4 ; COMDAT (pick any)
.text$mn:000024E4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000024E4
.text$mn:000024E4 ; =============== S U B R O U T I N E =======================================
.text$mn:000024E4
.text$mn:000024E4 ; Attributes: bp-based frame
.text$mn:000024E4
.text$mn:000024E4 ; public: static void __cdecl std::allocator_traits<class std::allocator<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>>>::destroy<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>>(class std::allocator<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>> &, class std::_List_unchecked_iterator
.text$mn:000024E4                 public ??$destroy@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@?$allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SAXAAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@1@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@@Z
.text$mn:000024E4 ??$destroy@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@?$allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SAXAAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@1@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@@Z proc near
.text$mn:000024E4                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>::destroy<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *)+Fp
.text$mn:000024E4
.text$mn:000024E4 arg_0           = dword ptr  8
.text$mn:000024E4 arg_4           = dword ptr  0Ch
.text$mn:000024E4
.text$mn:000024E4                 push    ebp
.text$mn:000024E5                 mov     ebp, esp
.text$mn:000024E7                 mov     eax, [ebp+arg_4]
.text$mn:000024EA                 push    eax
.text$mn:000024EB                 mov     ecx, [ebp+arg_0]
.text$mn:000024EE                 call    ??$destroy@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>::destroy<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *)
.text$mn:000024F3                 pop     ebp
.text$mn:000024F4                 retn
.text$mn:000024F4 ??$destroy@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@?$allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SAXAAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@1@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@@Z endp
.text$mn:000024F4
.text$mn:000024F4 ; ---------------------------------------------------------------------------
.text$mn:000024F5                 align 4
.text$mn:000024F5 _text$mn        ends
.text$mn:000024F5
.text$mn:000024F8 ; ===========================================================================
.text$mn:000024F8
.text$mn:000024F8 ; Segment type: Pure code
.text$mn:000024F8 ; Segment permissions: Read/Execute
.text$mn:000024F8 _text$mn        segment para public 'CODE' use32
.text$mn:000024F8                 assume cs:_text$mn
.text$mn:000024F8                 ;org 24F8h
.text$mn:000024F8 ; COMDAT (pick any)
.text$mn:000024F8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000024F8
.text$mn:000024F8 ; =============== S U B R O U T I N E =======================================
.text$mn:000024F8
.text$mn:000024F8 ; Attributes: bp-based frame
.text$mn:000024F8
.text$mn:000024F8 ; void __cdecl std::fill<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>> *, class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>>(class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>> *, class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Bu
.text$mn:000024F8                 public ??$fill@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@0ABV10@@Z
.text$mn:000024F8 ??$fill@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@0ABV10@@Z proc near
.text$mn:000024F8                                         ; CODE XREF: ?_Insert_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CB
.text$mn:000024F8                                         ; ?_Insert_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@s
.text$mn:000024F8
.text$mn:000024F8 arg_0           = dword ptr  8
.text$mn:000024F8 arg_4           = dword ptr  0Ch
.text$mn:000024F8 arg_8           = dword ptr  10h
.text$mn:000024F8
.text$mn:000024F8                 push    ebp
.text$mn:000024F9                 mov     ebp, esp
.text$mn:000024FB                 push    0A3Eh           ; unsigned int
.text$mn:00002500                 push    offset ??_C@_1JA@EADLBAJ@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00002505                 mov     eax, [ebp+arg_4]
.text$mn:00002508                 push    eax             ; int
.text$mn:00002509                 mov     ecx, [ebp+arg_0]
.text$mn:0000250C                 push    ecx             ; int
.text$mn:0000250D                 call    ??$_Debug_range@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@0PB_WI@Z ; std::_Debug_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,wchar_t const *,uint)
.text$mn:00002512                 add     esp, 10h
.text$mn:00002515                 mov     edx, [ebp+arg_8]
.text$mn:00002518                 push    edx
.text$mn:00002519                 mov     eax, [ebp+arg_4]
.text$mn:0000251C                 push    eax
.text$mn:0000251D                 call    ??$_Unchecked@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@PAV10@@Z ; std::_Unchecked<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *)
.text$mn:00002522                 add     esp, 4
.text$mn:00002525                 push    eax
.text$mn:00002526                 mov     ecx, [ebp+arg_0]
.text$mn:00002529                 push    ecx
.text$mn:0000252A                 call    ??$_Unchecked@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@PAV10@@Z ; std::_Unchecked<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *)
.text$mn:0000252F                 add     esp, 4
.text$mn:00002532                 push    eax
.text$mn:00002533                 call    ??$_Fill@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@0ABV10@@Z ; std::_Fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const &)
.text$mn:00002538                 add     esp, 0Ch
.text$mn:0000253B                 pop     ebp
.text$mn:0000253C                 retn
.text$mn:0000253C ??$fill@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@0ABV10@@Z endp
.text$mn:0000253C
.text$mn:0000253C ; ---------------------------------------------------------------------------
.text$mn:0000253D                 align 10h
.text$mn:0000253D _text$mn        ends
.text$mn:0000253D
.text$mn:00002540 ; ===========================================================================
.text$mn:00002540
.text$mn:00002540 ; Segment type: Pure code
.text$mn:00002540 ; Segment permissions: Read/Execute
.text$mn:00002540 _text$mn        segment para public 'CODE' use32
.text$mn:00002540                 assume cs:_text$mn
.text$mn:00002540                 ;org 2540h
.text$mn:00002540 ; COMDAT (pick any)
.text$mn:00002540                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002540
.text$mn:00002540 ; =============== S U B R O U T I N E =======================================
.text$mn:00002540
.text$mn:00002540 ; Attributes: bp-based frame
.text$mn:00002540
.text$mn:00002540 ; char * & __cdecl std::forward<char * &>(char * &)
.text$mn:00002540                 public ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
.text$mn:00002540 ??$forward@AAPAD@std@@YAAAPADAAPAD@Z proc near
.text$mn:00002540                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)+Bp
.text$mn:00002540                                         ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)+4Ap ...
.text$mn:00002540
.text$mn:00002540 arg_0           = dword ptr  8
.text$mn:00002540
.text$mn:00002540                 push    ebp
.text$mn:00002541                 mov     ebp, esp
.text$mn:00002543                 mov     eax, [ebp+arg_0]
.text$mn:00002546                 pop     ebp
.text$mn:00002547                 retn
.text$mn:00002547 ??$forward@AAPAD@std@@YAAAPADAAPAD@Z endp
.text$mn:00002547
.text$mn:00002547 _text$mn        ends
.text$mn:00002547
.text$mn:00002548 ; ===========================================================================
.text$mn:00002548
.text$mn:00002548 ; Segment type: Pure code
.text$mn:00002548 ; Segment permissions: Read/Execute
.text$mn:00002548 _text$mn        segment para public 'CODE' use32
.text$mn:00002548                 assume cs:_text$mn
.text$mn:00002548                 ;org 2548h
.text$mn:00002548 ; COMDAT (pick any)
.text$mn:00002548                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002548
.text$mn:00002548 ; =============== S U B R O U T I N E =======================================
.text$mn:00002548
.text$mn:00002548 ; Attributes: bp-based frame
.text$mn:00002548
.text$mn:00002548 ; struct std::_List_node<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>, void *> * & __cdecl std::forward<struct std::_List_node<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>, void *> * &>(struct std::_List_node<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>, void *> * &)
.text$mn:00002548                 public ??$forward@AAPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@YAAAPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@0@AAPAU10@@Z
.text$mn:00002548 ??$forward@AAPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@YAAAPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@0@AAPAU10@@Z proc near
.text$mn:00002548                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *>>>::construct<std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *,std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> * &>(std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> * *,std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> * &)+Bp
.text$mn:00002548                                         ; std::allocator<std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *>>::construct<std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *,std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> * &>(std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> * *,std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> * &)+4Ap ...
.text$mn:00002548
.text$mn:00002548 arg_0           = dword ptr  8
.text$mn:00002548
.text$mn:00002548                 push    ebp
.text$mn:00002549                 mov     ebp, esp
.text$mn:0000254B                 mov     eax, [ebp+arg_0]
.text$mn:0000254E                 pop     ebp
.text$mn:0000254F                 retn
.text$mn:0000254F ??$forward@AAPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@YAAAPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@0@AAPAU10@@Z endp
.text$mn:0000254F
.text$mn:0000254F _text$mn        ends
.text$mn:0000254F
.text$mn:00002550 ; ===========================================================================
.text$mn:00002550
.text$mn:00002550 ; Segment type: Pure code
.text$mn:00002550 ; Segment permissions: Read/Execute
.text$mn:00002550 _text$mn        segment para public 'CODE' use32
.text$mn:00002550                 assume cs:_text$mn
.text$mn:00002550                 ;org 2550h
.text$mn:00002550 ; COMDAT (pick any)
.text$mn:00002550                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002550
.text$mn:00002550 ; =============== S U B R O U T I N E =======================================
.text$mn:00002550
.text$mn:00002550 ; Attributes: bp-based frame
.text$mn:00002550
.text$mn:00002550 ; class ScintillaEditView * & __cdecl std::forward<class ScintillaEditView * &>(class ScintillaEditView * &)
.text$mn:00002550                 public ??$forward@AAPAVScintillaEditView@@@std@@YAAAPAVScintillaEditView@@AAPAV1@@Z
.text$mn:00002550 ??$forward@AAPAVScintillaEditView@@@std@@YAAAPAVScintillaEditView@@AAPAV1@@Z proc near
.text$mn:00002550                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<ScintillaEditView *>>::construct<ScintillaEditView *,ScintillaEditView * &>(ScintillaEditView * *,ScintillaEditView * &)+Bp
.text$mn:00002550                                         ; std::allocator<ScintillaEditView *>::construct<ScintillaEditView *,ScintillaEditView * &>(ScintillaEditView * *,ScintillaEditView * &)+4Ap ...
.text$mn:00002550
.text$mn:00002550 arg_0           = dword ptr  8
.text$mn:00002550
.text$mn:00002550                 push    ebp
.text$mn:00002551                 mov     ebp, esp
.text$mn:00002553                 mov     eax, [ebp+arg_0]
.text$mn:00002556                 pop     ebp
.text$mn:00002557                 retn
.text$mn:00002557 ??$forward@AAPAVScintillaEditView@@@std@@YAAAPAVScintillaEditView@@AAPAV1@@Z endp
.text$mn:00002557
.text$mn:00002557 _text$mn        ends
.text$mn:00002557
.text$mn:00002558 ; ===========================================================================
.text$mn:00002558
.text$mn:00002558 ; Segment type: Pure code
.text$mn:00002558 ; Segment permissions: Read/Execute
.text$mn:00002558 _text$mn        segment para public 'CODE' use32
.text$mn:00002558                 assume cs:_text$mn
.text$mn:00002558                 ;org 2558h
.text$mn:00002558 ; COMDAT (pick any)
.text$mn:00002558                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002558
.text$mn:00002558 ; =============== S U B R O U T I N E =======================================
.text$mn:00002558
.text$mn:00002558 ; Attributes: bp-based frame
.text$mn:00002558
.text$mn:00002558 ; class ScintillaEditView * const & __cdecl std::forward<class ScintillaEditView * const &>(class ScintillaEditView * const &)
.text$mn:00002558                 public ??$forward@ABQAVScintillaEditView@@@std@@YAABQAVScintillaEditView@@ABQAV1@@Z
.text$mn:00002558 ??$forward@ABQAVScintillaEditView@@@std@@YAABQAVScintillaEditView@@ABQAV1@@Z proc near
.text$mn:00002558                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<ScintillaEditView *>>::construct<ScintillaEditView *,ScintillaEditView * const &>(ScintillaEditView * *,ScintillaEditView * const &)+Bp
.text$mn:00002558                                         ; std::allocator_traits<std::allocator<ScintillaEditView *>>::construct<ScintillaEditView *,ScintillaEditView * const &>(std::allocator<ScintillaEditView *> &,ScintillaEditView * *,ScintillaEditView * const &)+7p
.text$mn:00002558
.text$mn:00002558 arg_0           = dword ptr  8
.text$mn:00002558
.text$mn:00002558                 push    ebp
.text$mn:00002559                 mov     ebp, esp
.text$mn:0000255B                 mov     eax, [ebp+arg_0]
.text$mn:0000255E                 pop     ebp
.text$mn:0000255F                 retn
.text$mn:0000255F ??$forward@ABQAVScintillaEditView@@@std@@YAABQAVScintillaEditView@@ABQAV1@@Z endp
.text$mn:0000255F
.text$mn:0000255F _text$mn        ends
.text$mn:0000255F
.text$mn:00002560 ; ===========================================================================
.text$mn:00002560
.text$mn:00002560 ; Segment type: Pure code
.text$mn:00002560 ; Segment permissions: Read/Execute
.text$mn:00002560 _text$mn        segment para public 'CODE' use32
.text$mn:00002560                 assume cs:_text$mn
.text$mn:00002560                 ;org 2560h
.text$mn:00002560 ; COMDAT (pick any)
.text$mn:00002560                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002560
.text$mn:00002560 ; =============== S U B R O U T I N E =======================================
.text$mn:00002560
.text$mn:00002560 ; Attributes: bp-based frame
.text$mn:00002560
.text$mn:00002560 ; class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>> const & __cdecl std::forward<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>> const &>(class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>> const &)
.text$mn:00002560                 public ??$forward@ABV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@YAABV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@ABV10@@Z
.text$mn:00002560 ??$forward@ABV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@YAABV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@ABV10@@Z proc near
.text$mn:00002560                                         ; CODE XREF: std::_Alloc_construct::_Fn<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const &>(int,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>> &,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_
.text$mn:00002560                                         ; std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::construct<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const &>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_m ...
.text$mn:00002560
.text$mn:00002560 arg_0           = dword ptr  8
.text$mn:00002560
.text$mn:00002560                 push    ebp
.text$mn:00002561                 mov     ebp, esp
.text$mn:00002563                 mov     eax, [ebp+arg_0]
.text$mn:00002566                 pop     ebp
.text$mn:00002567                 retn
.text$mn:00002567 ??$forward@ABV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@YAABV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@ABV10@@Z endp
.text$mn:00002567
.text$mn:00002567 _text$mn        ends
.text$mn:00002567
.text$mn:00002568 ; ===========================================================================
.text$mn:00002568
.text$mn:00002568 ; Segment type: Pure code
.text$mn:00002568 ; Segment permissions: Read/Execute
.text$mn:00002568 _text$mn        segment para public 'CODE' use32
.text$mn:00002568                 assume cs:_text$mn
.text$mn:00002568                 ;org 2568h
.text$mn:00002568 ; COMDAT (pick any)
.text$mn:00002568                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002568
.text$mn:00002568 ; =============== S U B R O U T I N E =======================================
.text$mn:00002568
.text$mn:00002568 ; Attributes: bp-based frame
.text$mn:00002568
.text$mn:00002568 ; struct std::_Container_proxy && __cdecl std::forward<struct std::_Container_proxy>(struct std::_Container_proxy &)
.text$mn:00002568                 public ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z
.text$mn:00002568 ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z proc near
.text$mn:00002568                                         ; CODE XREF: std::_Alloc_construct::_Fn<std::_Wrap_alloc<std::allocator<std::_Container_proxy>>,std::_Container_proxy,std::_Container_proxy>(int,std::_Wrap_alloc<std::allocator<std::_Container_proxy>> &,std::_Container_proxy *,std::_Container_proxy &&)+7p
.text$mn:00002568                                         ; std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_Container_proxy>>>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+Bp ...
.text$mn:00002568
.text$mn:00002568 arg_0           = dword ptr  8
.text$mn:00002568
.text$mn:00002568                 push    ebp
.text$mn:00002569                 mov     ebp, esp
.text$mn:0000256B                 mov     eax, [ebp+arg_0]
.text$mn:0000256E                 pop     ebp
.text$mn:0000256F                 retn
.text$mn:0000256F ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z endp
.text$mn:0000256F
.text$mn:0000256F _text$mn        ends
.text$mn:0000256F
.text$mn:00002570 ; ===========================================================================
.text$mn:00002570
.text$mn:00002570 ; Segment type: Pure code
.text$mn:00002570 ; Segment permissions: Read/Execute
.text$mn:00002570 _text$mn        segment para public 'CODE' use32
.text$mn:00002570                 assume cs:_text$mn
.text$mn:00002570                 ;org 2570h
.text$mn:00002570 ; COMDAT (pick any)
.text$mn:00002570                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002570
.text$mn:00002570 ; =============== S U B R O U T I N E =======================================
.text$mn:00002570
.text$mn:00002570 ; Attributes: bp-based frame
.text$mn:00002570
.text$mn:00002570 ; class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>> && __cdecl std::forward<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>>(class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>> &)
.text$mn:00002570                 public ??$forward@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@YA$$QAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@AAV10@@Z
.text$mn:00002570 ??$forward@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@YA$$QAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@AAV10@@Z proc near
.text$mn:00002570                                         ; CODE XREF: std::_Alloc_construct::_Fn<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>(int,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>> &,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<st
.text$mn:00002570                                         ; std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::construct<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,S ...
.text$mn:00002570
.text$mn:00002570 arg_0           = dword ptr  8
.text$mn:00002570
.text$mn:00002570                 push    ebp
.text$mn:00002571                 mov     ebp, esp
.text$mn:00002573                 mov     eax, [ebp+arg_0]
.text$mn:00002576                 pop     ebp
.text$mn:00002577                 retn
.text$mn:00002577 ??$forward@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@YA$$QAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@AAV10@@Z endp
.text$mn:00002577
.text$mn:00002577 _text$mn        ends
.text$mn:00002577
.text$mn:00002578 ; ===========================================================================
.text$mn:00002578
.text$mn:00002578 ; Segment type: Pure code
.text$mn:00002578 ; Segment permissions: Read/Execute
.text$mn:00002578 _text$mn        segment para public 'CODE' use32
.text$mn:00002578                 assume cs:_text$mn
.text$mn:00002578                 ;org 2578h
.text$mn:00002578 ; COMDAT (pick any)
.text$mn:00002578                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002578
.text$mn:00002578 ; =============== S U B R O U T I N E =======================================
.text$mn:00002578
.text$mn:00002578 ; Attributes: bp-based frame
.text$mn:00002578
.text$mn:00002578 ; public: __thiscall std::_Hash<class std::_Umap_traits<class Buffer *, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *, class std::_Uhash_compare<class Buffer *, struct std::hash<class Buffer *>, struct std::equal_to<class Buffer *>>, class std::allocator<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>, 0>>::_Hash<class std::_Umap_traits<class Buffer *, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *, class std::_Uhash_compare<class Buffer *, struct std::hash<class Buffer *>, struct std::equal_to<class Buffer *>>, class std::allocator<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash
.text$mn:00002578                 public ??0?$_Hash@V?$_Umap_traits@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@V?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@$0A@@std@@@std@@QAE@ABV?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@1@ABV?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@1@@Z
.text$mn:00002578 ??0?$_Hash@V?$_Umap_traits@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@V?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@$0A@@std@@@std@@QAE@ABV?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@1@ABV?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@1@@Z proc near
.text$mn:00002578                                         ; CODE XREF: std::unordered_map<Buffer *,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *,std::hash<Buffer *>,std::equal_to<Buffer *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>::unordered_map<Buffer *,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *,std::hash<Buffer *>,std::equal_to<Buffer *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>(void)+47p
.text$mn:00002578
.text$mn:00002578 var_14          = dword ptr -14h
.text$mn:00002578 var_D           = byte ptr -0Dh
.text$mn:00002578 var_C           = dword ptr -0Ch
.text$mn:00002578 var_4           = dword ptr -4
.text$mn:00002578 arg_0           = dword ptr  8
.text$mn:00002578 arg_4           = dword ptr  0Ch
.text$mn:00002578
.text$mn:00002578                 push    ebp
.text$mn:00002579                 mov     ebp, esp
.text$mn:0000257B                 push    0FFFFFFFFh
.text$mn:0000257D                 push    offset __ehhandler$??0?$_Hash@V?$_Umap_traits@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@V?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@$0A@@std@@@std@@QAE@ABV?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@1@ABV?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@1@@Z
.text$mn:00002582                 mov     eax, large fs:0
.text$mn:00002588                 push    eax
.text$mn:00002589                 sub     esp, 8
.text$mn:0000258C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002591                 xor     eax, ebp
.text$mn:00002593                 push    eax
.text$mn:00002594                 lea     eax, [ebp+var_C]
.text$mn:00002597                 mov     large fs:0, eax
.text$mn:0000259D                 mov     [ebp+var_14], ecx
.text$mn:000025A0                 mov     eax, [ebp+arg_0]
.text$mn:000025A3                 push    eax
.text$mn:000025A4                 mov     ecx, [ebp+var_14]
.text$mn:000025A7                 call    ??0?$_Umap_traits@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@V?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@$0A@@std@@QAE@ABV?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@1@@Z ; std::_Umap_traits<Buffer *,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *,std::_Uhash_compare<Buffer *,std::hash<Buffer *>,std::equal_to<Buffer *>>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>,0>::_Umap_traits<Buffer *,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *,std::_Uhash_compare<Buffer *,std::hash<Buffer *>,std::equal_to<Buffer *>>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>,0>(std::_Uhash_compare<Buffer *,std::hash<Buffer *>,std::equal_to<Buffer *>> const &)
.text$mn:000025AC                 mov     ecx, [ebp+arg_4]
.text$mn:000025AF                 push    ecx
.text$mn:000025B0                 mov     ecx, [ebp+var_14]
.text$mn:000025B3                 call    ??0?$list@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@1@@Z ; std::list<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>::list<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>(std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>> const &)
.text$mn:000025B8                 mov     [ebp+var_4], 0
.text$mn:000025BF                 mov     edx, [ebp+arg_4]
.text$mn:000025C2                 push    edx
.text$mn:000025C3                 lea     ecx, [ebp+var_D]
.text$mn:000025C6                 call    ??$?0V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@1@@Z ; std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>(std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>> const &)
.text$mn:000025CB                 lea     eax, [ebp+var_D]
.text$mn:000025CE                 push    eax
.text$mn:000025CF                 mov     ecx, [ebp+var_14]
.text$mn:000025D2                 add     ecx, 0Ch
.text$mn:000025D5                 call    ??0?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAE@ABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@1@@Z ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>(std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>> const &)
.text$mn:000025DA                 mov     byte ptr [ebp+var_4], 1
.text$mn:000025DE                 mov     ecx, [ebp+var_14]
.text$mn:000025E1                 movss   xmm0, ds:__real@3f800000
.text$mn:000025E9                 movss   dword ptr [ecx+24h], xmm0
.text$mn:000025EE                 push    8
.text$mn:000025F0                 mov     ecx, [ebp+var_14]
.text$mn:000025F3                 call    ?_Init@?$_Hash@V?$_Umap_traits@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@V?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@$0A@@std@@@std@@IAEXI@Z ; std::_Hash<std::_Umap_traits<Buffer *,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *,std::_Uhash_compare<Buffer *,std::hash<Buffer *>,std::equal_to<Buffer *>>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>,0>>::_Init(uint)
.text$mn:000025F8                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000025FF                 mov     eax, [ebp+var_14]
.text$mn:00002602                 mov     ecx, [ebp+var_C]
.text$mn:00002605                 mov     large fs:0, ecx
.text$mn:0000260C                 pop     ecx
.text$mn:0000260D                 mov     esp, ebp
.text$mn:0000260F                 pop     ebp
.text$mn:00002610                 retn    8
.text$mn:00002610 ??0?$_Hash@V?$_Umap_traits@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@V?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@$0A@@std@@@std@@QAE@ABV?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@1@ABV?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@1@@Z endp
.text$mn:00002610
.text$mn:00002610 ; ---------------------------------------------------------------------------
.text$mn:00002613                 align 4
.text$mn:00002613 _text$mn        ends
.text$mn:00002613
.text$x:00002614 ; ===========================================================================
.text$x:00002614
.text$x:00002614 ; Segment type: Pure code
.text$x:00002614 ; Segment permissions: Read/Execute
.text$x:00002614 _text$x         segment para public 'CODE' use32
.text$x:00002614                 assume cs:_text$x
.text$x:00002614                 ;org 2614h
.text$x:00002614 ; COMDAT (pick associative to section at 2578)
.text$x:00002614                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00002614
.text$x:00002614 ; =============== S U B R O U T I N E =======================================
.text$x:00002614
.text$x:00002614
.text$x:00002614 __unwindfunclet$??0?$_Hash@V?$_Umap_traits@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@V?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@$0A@@std@@@std@@QAE@ABV?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@1@ABV?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@1@@Z$0 proc near
.text$x:00002614                                         ; DATA XREF: .xdata$x:0000A008o
.text$x:00002614                 mov     ecx, [ebp-14h]
.text$x:00002617                 jmp     ??1?$list@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAE@XZ ; std::list<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>::~list<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>(void)
.text$x:00002617 __unwindfunclet$??0?$_Hash@V?$_Umap_traits@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@V?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@$0A@@std@@@std@@QAE@ABV?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@1@ABV?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@1@@Z$0 endp
.text$x:00002617
.text$x:0000261C
.text$x:0000261C ; =============== S U B R O U T I N E =======================================
.text$x:0000261C
.text$x:0000261C
.text$x:0000261C __unwindfunclet$??0?$_Hash@V?$_Umap_traits@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@V?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@$0A@@std@@@std@@QAE@ABV?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@1@ABV?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@1@@Z$1 proc near
.text$x:0000261C                                         ; DATA XREF: .xdata$x:0000A010o
.text$x:0000261C                 mov     ecx, [ebp-14h]
.text$x:0000261F                 add     ecx, 0Ch
.text$x:00002622                 jmp     ??1?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAE@XZ ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::~vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>(void)
.text$x:00002622 __unwindfunclet$??0?$_Hash@V?$_Umap_traits@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@V?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@$0A@@std@@@std@@QAE@ABV?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@1@ABV?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@1@@Z$1 endp
.text$x:00002622
.text$x:00002627
.text$x:00002627 ; =============== S U B R O U T I N E =======================================
.text$x:00002627
.text$x:00002627
.text$x:00002627 __ehhandler$??0?$_Hash@V?$_Umap_traits@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@V?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@$0A@@std@@@std@@QAE@ABV?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@1@ABV?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@1@@Z proc near
.text$x:00002627                                         ; DATA XREF: std::_Hash<std::_Umap_traits<Buffer *,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *,std::_Uhash_compare<Buffer *,std::hash<Buffer *>,std::equal_to<Buffer *>>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>,0>>::_Hash<std::_Umap_traits<Buffer *,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *,std::_Uhash_compare<Buffer *,std::hash<Buffer *>,std::equal_to<Buffer *>>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>,0>>(std::_Uhash_compare<Buffer *,std::hash<Buffer *>,std::equal_to<Buffer *>> const &,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>> const &)+5o
.text$x:00002627
.text$x:00002627 arg_4           = dword ptr  8
.text$x:00002627
.text$x:00002627                 mov     edx, [esp+arg_4]
.text$x:0000262B                 lea     eax, [edx+0Ch]
.text$x:0000262E                 mov     ecx, [edx-0Ch]
.text$x:00002631                 xor     ecx, eax
.text$x:00002633                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002638                 mov     eax, offset __ehfuncinfo$??0?$_Hash@V?$_Umap_traits@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@V?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@$0A@@std@@@std@@QAE@ABV?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@1@ABV?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@1@@Z
.text$x:0000263D                 jmp     ___CxxFrameHandler3
.text$x:0000263D __ehhandler$??0?$_Hash@V?$_Umap_traits@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@V?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@$0A@@std@@@std@@QAE@ABV?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@1@ABV?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@1@@Z endp
.text$x:0000263D
.text$x:0000263D ; ---------------------------------------------------------------------------
.text$x:00002642                 align 4
.text$x:00002642 _text$x         ends
.text$x:00002642
.text$mn:00002644 ; ===========================================================================
.text$mn:00002644
.text$mn:00002644 ; Segment type: Pure code
.text$mn:00002644 ; Segment permissions: Read/Execute
.text$mn:00002644 _text$mn        segment para public 'CODE' use32
.text$mn:00002644                 assume cs:_text$mn
.text$mn:00002644                 ;org 2644h
.text$mn:00002644 ; COMDAT (pick any)
.text$mn:00002644                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002644
.text$mn:00002644 ; =============== S U B R O U T I N E =======================================
.text$mn:00002644
.text$mn:00002644 ; Attributes: bp-based frame
.text$mn:00002644
.text$mn:00002644 ; public: __thiscall std::_Hash_oper1<0, struct std::hash<class Buffer *>>::_Hash_oper1<0, struct std::hash<class Buffer *>>(struct std::hash<class Buffer *>)
.text$mn:00002644                 public ??0?$_Hash_oper1@$0A@U?$hash@PAVBuffer@@@std@@@std@@QAE@U?$hash@PAVBuffer@@@1@@Z
.text$mn:00002644 ??0?$_Hash_oper1@$0A@U?$hash@PAVBuffer@@@std@@@std@@QAE@U?$hash@PAVBuffer@@@1@@Z proc near
.text$mn:00002644                                         ; CODE XREF: std::_Hash_oper2<0,std::hash<Buffer *>,std::equal_to<Buffer *>>::_Hash_oper2<0,std::hash<Buffer *>,std::equal_to<Buffer *>>(std::hash<Buffer *>,std::equal_to<Buffer *>)+Fp
.text$mn:00002644
.text$mn:00002644 var_4           = dword ptr -4
.text$mn:00002644
.text$mn:00002644                 push    ebp
.text$mn:00002645                 mov     ebp, esp
.text$mn:00002647                 push    ecx
.text$mn:00002648                 mov     [ebp+var_4], ecx
.text$mn:0000264B                 mov     eax, [ebp+var_4]
.text$mn:0000264E                 mov     esp, ebp
.text$mn:00002650                 pop     ebp
.text$mn:00002651                 retn    4
.text$mn:00002651 ??0?$_Hash_oper1@$0A@U?$hash@PAVBuffer@@@std@@@std@@QAE@U?$hash@PAVBuffer@@@1@@Z endp
.text$mn:00002651
.text$mn:00002651 _text$mn        ends
.text$mn:00002651
.text$mn:00002654 ; ===========================================================================
.text$mn:00002654
.text$mn:00002654 ; Segment type: Pure code
.text$mn:00002654 ; Segment permissions: Read/Execute
.text$mn:00002654 _text$mn        segment para public 'CODE' use32
.text$mn:00002654                 assume cs:_text$mn
.text$mn:00002654                 ;org 2654h
.text$mn:00002654 ; COMDAT (pick any)
.text$mn:00002654                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002654
.text$mn:00002654 ; =============== S U B R O U T I N E =======================================
.text$mn:00002654
.text$mn:00002654 ; Attributes: bp-based frame
.text$mn:00002654
.text$mn:00002654 ; public: __thiscall std::_Hash_oper2<0, struct std::hash<class Buffer *>, struct std::equal_to<class Buffer *>>::_Hash_oper2<0, struct std::hash<class Buffer *>, struct std::equal_to<class Buffer *>>(struct std::hash<class Buffer *>, struct std::equal_to<class Buffer *>)
.text$mn:00002654                 public ??0?$_Hash_oper2@$0A@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@2@@std@@QAE@U?$hash@PAVBuffer@@@1@U?$equal_to@PAVBuffer@@@1@@Z
.text$mn:00002654 ??0?$_Hash_oper2@$0A@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@2@@std@@QAE@U?$hash@PAVBuffer@@@1@U?$equal_to@PAVBuffer@@@1@@Z proc near
.text$mn:00002654                                         ; CODE XREF: std::_Uhash_compare<Buffer *,std::hash<Buffer *>,std::equal_to<Buffer *>>::_Uhash_compare<Buffer *,std::hash<Buffer *>,std::equal_to<Buffer *>>(std::hash<Buffer *>,std::equal_to<Buffer *>)+14p
.text$mn:00002654
.text$mn:00002654 var_4           = dword ptr -4
.text$mn:00002654 arg_0           = byte ptr  8
.text$mn:00002654
.text$mn:00002654                 push    ebp
.text$mn:00002655                 mov     ebp, esp
.text$mn:00002657                 push    ecx
.text$mn:00002658                 mov     [ebp+var_4], ecx
.text$mn:0000265B                 movzx   eax, [ebp+arg_0]
.text$mn:0000265F                 push    eax
.text$mn:00002660                 mov     ecx, [ebp+var_4]
.text$mn:00002663                 call    ??0?$_Hash_oper1@$0A@U?$hash@PAVBuffer@@@std@@@std@@QAE@U?$hash@PAVBuffer@@@1@@Z ; std::_Hash_oper1<0,std::hash<Buffer *>>::_Hash_oper1<0,std::hash<Buffer *>>(std::hash<Buffer *>)
.text$mn:00002668                 mov     eax, [ebp+var_4]
.text$mn:0000266B                 mov     esp, ebp
.text$mn:0000266D                 pop     ebp
.text$mn:0000266E                 retn    8
.text$mn:0000266E ??0?$_Hash_oper2@$0A@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@2@@std@@QAE@U?$hash@PAVBuffer@@@1@U?$equal_to@PAVBuffer@@@1@@Z endp
.text$mn:0000266E
.text$mn:0000266E ; ---------------------------------------------------------------------------
.text$mn:00002671                 align 4
.text$mn:00002671 _text$mn        ends
.text$mn:00002671
.text$mn:00002674 ; ===========================================================================
.text$mn:00002674
.text$mn:00002674 ; Segment type: Pure code
.text$mn:00002674 ; Segment permissions: Read/Execute
.text$mn:00002674 _text$mn        segment para public 'CODE' use32
.text$mn:00002674                 assume cs:_text$mn
.text$mn:00002674                 ;org 2674h
.text$mn:00002674 ; COMDAT (pick any)
.text$mn:00002674                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002674
.text$mn:00002674 ; =============== S U B R O U T I N E =======================================
.text$mn:00002674
.text$mn:00002674 ; Attributes: bp-based frame
.text$mn:00002674
.text$mn:00002674 ; public: __thiscall std::_Iterator012<struct std::bidirectional_iterator_tag, struct std::pair<int const, struct Style>, int, struct std::pair<int const, struct Style> const *, struct std::pair<int const, struct Style> const &, struct std::_Iterator_base12>::_Iterator012<struct std::bidirectional_iterator_tag, struct std::pair<int const, struct Style>, int, struct std::pair<int const, struct Style> const *, struct std::pair<int const, struct Style> const &, struct std::_Iterator_base12>(void)
.text$mn:00002674                 public ??0?$_Iterator012@Ubidirectional_iterator_tag@std@@U?$pair@$$CBHUStyle@@@2@HPBU32@ABU32@U_Iterator_base12@2@@std@@QAE@XZ
.text$mn:00002674 ??0?$_Iterator012@Ubidirectional_iterator_tag@std@@U?$pair@$$CBHUStyle@@@2@HPBU32@ABU32@U_Iterator_base12@2@@std@@QAE@XZ proc near
.text$mn:00002674                                         ; CODE XREF: std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>,std::_Iterator_base12>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>,std::_Iterator_base12>(std::_List_node<std::pair<int const,Style>,void *> *,std::_List_val<std::_List_simple_types<std::pair<int const,Style>>> const *)+29p
.text$mn:00002674
.text$mn:00002674 var_10          = dword ptr -10h
.text$mn:00002674 var_C           = dword ptr -0Ch
.text$mn:00002674 var_4           = dword ptr -4
.text$mn:00002674
.text$mn:00002674                 push    ebp
.text$mn:00002675                 mov     ebp, esp
.text$mn:00002677                 push    0FFFFFFFFh
.text$mn:00002679                 push    offset __ehhandler$??0?$_Iterator012@Ubidirectional_iterator_tag@std@@U?$pair@$$CBHUStyle@@@2@HPBU32@ABU32@U_Iterator_base12@2@@std@@QAE@XZ
.text$mn:0000267E                 mov     eax, large fs:0
.text$mn:00002684                 push    eax
.text$mn:00002685                 push    ecx
.text$mn:00002686                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000268B                 xor     eax, ebp
.text$mn:0000268D                 push    eax
.text$mn:0000268E                 lea     eax, [ebp+var_C]
.text$mn:00002691                 mov     large fs:0, eax
.text$mn:00002697                 mov     [ebp+var_10], ecx
.text$mn:0000269A                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000269D                 call    ??0_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::_Iterator_base12(void)
.text$mn:000026A2                 mov     [ebp+var_4], 0
.text$mn:000026A9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000026B0                 mov     eax, [ebp+var_10]
.text$mn:000026B3                 mov     ecx, [ebp+var_C]
.text$mn:000026B6                 mov     large fs:0, ecx
.text$mn:000026BD                 pop     ecx
.text$mn:000026BE                 mov     esp, ebp
.text$mn:000026C0                 pop     ebp
.text$mn:000026C1                 retn
.text$mn:000026C1 ??0?$_Iterator012@Ubidirectional_iterator_tag@std@@U?$pair@$$CBHUStyle@@@2@HPBU32@ABU32@U_Iterator_base12@2@@std@@QAE@XZ endp
.text$mn:000026C1
.text$mn:000026C1 ; ---------------------------------------------------------------------------
.text$mn:000026C2                 align 4
.text$mn:000026C2 _text$mn        ends
.text$mn:000026C2
.text$x:000026C4 ; ===========================================================================
.text$x:000026C4
.text$x:000026C4 ; Segment type: Pure code
.text$x:000026C4 ; Segment permissions: Read/Execute
.text$x:000026C4 _text$x         segment para public 'CODE' use32
.text$x:000026C4                 assume cs:_text$x
.text$x:000026C4                 ;org 26C4h
.text$x:000026C4 ; COMDAT (pick associative to section at 2674)
.text$x:000026C4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000026C4
.text$x:000026C4 ; =============== S U B R O U T I N E =======================================
.text$x:000026C4
.text$x:000026C4
.text$x:000026C4 __unwindfunclet$??0?$_Iterator012@Ubidirectional_iterator_tag@std@@U?$pair@$$CBHUStyle@@@2@HPBU32@ABU32@U_Iterator_base12@2@@std@@QAE@XZ$0 proc near
.text$x:000026C4                                         ; DATA XREF: .xdata$x:0000A764o
.text$x:000026C4                 mov     ecx, [ebp-10h]  ; this
.text$x:000026C7                 jmp     ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$x:000026C7 __unwindfunclet$??0?$_Iterator012@Ubidirectional_iterator_tag@std@@U?$pair@$$CBHUStyle@@@2@HPBU32@ABU32@U_Iterator_base12@2@@std@@QAE@XZ$0 endp
.text$x:000026C7
.text$x:000026CC
.text$x:000026CC ; =============== S U B R O U T I N E =======================================
.text$x:000026CC
.text$x:000026CC
.text$x:000026CC __ehhandler$??0?$_Iterator012@Ubidirectional_iterator_tag@std@@U?$pair@$$CBHUStyle@@@2@HPBU32@ABU32@U_Iterator_base12@2@@std@@QAE@XZ proc near
.text$x:000026CC                                         ; DATA XREF: std::_Iterator012<std::bidirectional_iterator_tag,std::pair<int const,Style>,int,std::pair<int const,Style> const *,std::pair<int const,Style> const &,std::_Iterator_base12>::_Iterator012<std::bidirectional_iterator_tag,std::pair<int const,Style>,int,std::pair<int const,Style> const *,std::pair<int const,Style> const &,std::_Iterator_base12>(void)+5o
.text$x:000026CC
.text$x:000026CC arg_4           = dword ptr  8
.text$x:000026CC
.text$x:000026CC                 mov     edx, [esp+arg_4]
.text$x:000026D0                 lea     eax, [edx+0Ch]
.text$x:000026D3                 mov     ecx, [edx-8]
.text$x:000026D6                 xor     ecx, eax
.text$x:000026D8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000026DD                 mov     eax, offset __ehfuncinfo$??0?$_Iterator012@Ubidirectional_iterator_tag@std@@U?$pair@$$CBHUStyle@@@2@HPBU32@ABU32@U_Iterator_base12@2@@std@@QAE@XZ
.text$x:000026E2                 jmp     ___CxxFrameHandler3
.text$x:000026E2 __ehhandler$??0?$_Iterator012@Ubidirectional_iterator_tag@std@@U?$pair@$$CBHUStyle@@@2@HPBU32@ABU32@U_Iterator_base12@2@@std@@QAE@XZ endp
.text$x:000026E2
.text$x:000026E2 ; ---------------------------------------------------------------------------
.text$x:000026E7                 align 4
.text$x:000026E7 _text$x         ends
.text$x:000026E7
.text$mn:000026E8 ; ===========================================================================
.text$mn:000026E8
.text$mn:000026E8 ; Segment type: Pure code
.text$mn:000026E8 ; Segment permissions: Read/Execute
.text$mn:000026E8 _text$mn        segment para public 'CODE' use32
.text$mn:000026E8                 assume cs:_text$mn
.text$mn:000026E8                 ;org 26E8h
.text$mn:000026E8 ; COMDAT (pick any)
.text$mn:000026E8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000026E8
.text$mn:000026E8 ; =============== S U B R O U T I N E =======================================
.text$mn:000026E8
.text$mn:000026E8 ; Attributes: bp-based frame
.text$mn:000026E8
.text$mn:000026E8 ; public: __thiscall std::_Iterator012<struct std::bidirectional_iterator_tag, struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>, int, struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *> const *, struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *> const &, struct std::_Iterator_base12>::_Iterator012<struct std::bidirectional_iterator_tag, struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>, int, struct std::pair<class B
.text$mn:000026E8                 public ??0?$_Iterator012@Ubidirectional_iterator_tag@std@@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@2@HPBU32@ABU32@U_Iterator_base12@2@@std@@QAE@XZ
.text$mn:000026E8 ??0?$_Iterator012@Ubidirectional_iterator_tag@std@@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@2@HPBU32@ABU32@U_Iterator_base12@2@@std@@QAE@XZ proc near
.text$mn:000026E8                                         ; CODE XREF: std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>,std::_Iterator_base12>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>,std::_Iterator_base12>(std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *,std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>> const *)+29p
.text$mn:000026E8
.text$mn:000026E8 var_10          = dword ptr -10h
.text$mn:000026E8 var_C           = dword ptr -0Ch
.text$mn:000026E8 var_4           = dword ptr -4
.text$mn:000026E8
.text$mn:000026E8                 push    ebp
.text$mn:000026E9                 mov     ebp, esp
.text$mn:000026EB                 push    0FFFFFFFFh
.text$mn:000026ED                 push    offset __ehhandler$??0?$_Iterator012@Ubidirectional_iterator_tag@std@@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@2@HPBU32@ABU32@U_Iterator_base12@2@@std@@QAE@XZ
.text$mn:000026F2                 mov     eax, large fs:0
.text$mn:000026F8                 push    eax
.text$mn:000026F9                 push    ecx
.text$mn:000026FA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000026FF                 xor     eax, ebp
.text$mn:00002701                 push    eax
.text$mn:00002702                 lea     eax, [ebp+var_C]
.text$mn:00002705                 mov     large fs:0, eax
.text$mn:0000270B                 mov     [ebp+var_10], ecx
.text$mn:0000270E                 mov     ecx, [ebp+var_10] ; this
.text$mn:00002711                 call    ??0_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::_Iterator_base12(void)
.text$mn:00002716                 mov     [ebp+var_4], 0
.text$mn:0000271D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002724                 mov     eax, [ebp+var_10]
.text$mn:00002727                 mov     ecx, [ebp+var_C]
.text$mn:0000272A                 mov     large fs:0, ecx
.text$mn:00002731                 pop     ecx
.text$mn:00002732                 mov     esp, ebp
.text$mn:00002734                 pop     ebp
.text$mn:00002735                 retn
.text$mn:00002735 ??0?$_Iterator012@Ubidirectional_iterator_tag@std@@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@2@HPBU32@ABU32@U_Iterator_base12@2@@std@@QAE@XZ endp
.text$mn:00002735
.text$mn:00002735 ; ---------------------------------------------------------------------------
.text$mn:00002736                 align 4
.text$mn:00002736 _text$mn        ends
.text$mn:00002736
.text$x:00002738 ; ===========================================================================
.text$x:00002738
.text$x:00002738 ; Segment type: Pure code
.text$x:00002738 ; Segment permissions: Read/Execute
.text$x:00002738 _text$x         segment para public 'CODE' use32
.text$x:00002738                 assume cs:_text$x
.text$x:00002738                 ;org 2738h
.text$x:00002738 ; COMDAT (pick associative to section at 26E8)
.text$x:00002738                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00002738
.text$x:00002738 ; =============== S U B R O U T I N E =======================================
.text$x:00002738
.text$x:00002738
.text$x:00002738 __unwindfunclet$??0?$_Iterator012@Ubidirectional_iterator_tag@std@@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@2@HPBU32@ABU32@U_Iterator_base12@2@@std@@QAE@XZ$0 proc near
.text$x:00002738                                         ; DATA XREF: .xdata$x:0000A394o
.text$x:00002738                 mov     ecx, [ebp-10h]  ; this
.text$x:0000273B                 jmp     ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$x:0000273B __unwindfunclet$??0?$_Iterator012@Ubidirectional_iterator_tag@std@@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@2@HPBU32@ABU32@U_Iterator_base12@2@@std@@QAE@XZ$0 endp
.text$x:0000273B
.text$x:00002740
.text$x:00002740 ; =============== S U B R O U T I N E =======================================
.text$x:00002740
.text$x:00002740
.text$x:00002740 __ehhandler$??0?$_Iterator012@Ubidirectional_iterator_tag@std@@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@2@HPBU32@ABU32@U_Iterator_base12@2@@std@@QAE@XZ proc near
.text$x:00002740                                         ; DATA XREF: std::_Iterator012<std::bidirectional_iterator_tag,std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,int,std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *> const *,std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *> const &,std::_Iterator_base12>::_Iterator012<std::bidirectional_iterator_tag,std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,int,std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *> const *,std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *> const &,std::_Iterator_base12>(void)+5o
.text$x:00002740
.text$x:00002740 arg_4           = dword ptr  8
.text$x:00002740
.text$x:00002740                 mov     edx, [esp+arg_4]
.text$x:00002744                 lea     eax, [edx+0Ch]
.text$x:00002747                 mov     ecx, [edx-8]
.text$x:0000274A                 xor     ecx, eax
.text$x:0000274C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002751                 mov     eax, offset __ehfuncinfo$??0?$_Iterator012@Ubidirectional_iterator_tag@std@@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@2@HPBU32@ABU32@U_Iterator_base12@2@@std@@QAE@XZ
.text$x:00002756                 jmp     ___CxxFrameHandler3
.text$x:00002756 __ehhandler$??0?$_Iterator012@Ubidirectional_iterator_tag@std@@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@2@HPBU32@ABU32@U_Iterator_base12@2@@std@@QAE@XZ endp
.text$x:00002756
.text$x:00002756 ; ---------------------------------------------------------------------------
.text$x:0000275B                 align 4
.text$x:0000275B _text$x         ends
.text$x:0000275B
.text$mn:0000275C ; ===========================================================================
.text$mn:0000275C
.text$mn:0000275C ; Segment type: Pure code
.text$mn:0000275C ; Segment permissions: Read/Execute
.text$mn:0000275C _text$mn        segment para public 'CODE' use32
.text$mn:0000275C                 assume cs:_text$mn
.text$mn:0000275C                 ;org 275Ch
.text$mn:0000275C ; COMDAT (pick any)
.text$mn:0000275C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000275C
.text$mn:0000275C ; =============== S U B R O U T I N E =======================================
.text$mn:0000275C
.text$mn:0000275C ; Attributes: bp-based frame
.text$mn:0000275C
.text$mn:0000275C ; int __stdcall std::_Iterator012<std::random_access_iterator_tag,ScintillaEditView *,int,ScintillaEditView * const *,ScintillaEditView * const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,ScintillaEditView *,int,ScintillaEditView * const *,ScintillaEditView * const &,std::_Iterator_base12>(struct std::_Iterator_base12 *)
.text$mn:0000275C                 public ??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVScintillaEditView@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z
.text$mn:0000275C ??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVScintillaEditView@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z proc near
.text$mn:0000275C                                         ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>> const &)+2Dp
.text$mn:0000275C
.text$mn:0000275C var_10          = dword ptr -10h
.text$mn:0000275C var_C           = dword ptr -0Ch
.text$mn:0000275C var_4           = dword ptr -4
.text$mn:0000275C arg_0           = dword ptr  8
.text$mn:0000275C
.text$mn:0000275C                 push    ebp
.text$mn:0000275D                 mov     ebp, esp
.text$mn:0000275F                 push    0FFFFFFFFh
.text$mn:00002761                 push    offset __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVScintillaEditView@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z
.text$mn:00002766                 mov     eax, large fs:0
.text$mn:0000276C                 push    eax
.text$mn:0000276D                 push    ecx
.text$mn:0000276E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002773                 xor     eax, ebp
.text$mn:00002775                 push    eax
.text$mn:00002776                 lea     eax, [ebp+var_C]
.text$mn:00002779                 mov     large fs:0, eax
.text$mn:0000277F                 mov     [ebp+var_10], ecx
.text$mn:00002782                 mov     eax, [ebp+arg_0]
.text$mn:00002785                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00002786                 mov     ecx, [ebp+var_10] ; this
.text$mn:00002789                 call    ??0_Iterator_base12@std@@QAE@ABU01@@Z ; std::_Iterator_base12::_Iterator_base12(std::_Iterator_base12 const &)
.text$mn:0000278E                 mov     [ebp+var_4], 0
.text$mn:00002795                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000279C                 mov     eax, [ebp+var_10]
.text$mn:0000279F                 mov     ecx, [ebp+var_C]
.text$mn:000027A2                 mov     large fs:0, ecx
.text$mn:000027A9                 pop     ecx
.text$mn:000027AA                 mov     esp, ebp
.text$mn:000027AC                 pop     ebp
.text$mn:000027AD                 retn    4
.text$mn:000027AD ??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVScintillaEditView@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z endp
.text$mn:000027AD
.text$mn:000027AD _text$mn        ends
.text$mn:000027AD
.text$x:000027B0 ; ===========================================================================
.text$x:000027B0
.text$x:000027B0 ; Segment type: Pure code
.text$x:000027B0 ; Segment permissions: Read/Execute
.text$x:000027B0 _text$x         segment para public 'CODE' use32
.text$x:000027B0                 assume cs:_text$x
.text$x:000027B0                 ;org 27B0h
.text$x:000027B0 ; COMDAT (pick associative to section at 275C)
.text$x:000027B0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000027B0
.text$x:000027B0 ; =============== S U B R O U T I N E =======================================
.text$x:000027B0
.text$x:000027B0
.text$x:000027B0 __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVScintillaEditView@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z$0 proc near
.text$x:000027B0                                         ; DATA XREF: .xdata$x:0000A948o
.text$x:000027B0                 mov     ecx, [ebp-10h]  ; this
.text$x:000027B3                 jmp     ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$x:000027B3 __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVScintillaEditView@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z$0 endp
.text$x:000027B3
.text$x:000027B8
.text$x:000027B8 ; =============== S U B R O U T I N E =======================================
.text$x:000027B8
.text$x:000027B8
.text$x:000027B8 __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVScintillaEditView@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z proc near
.text$x:000027B8                                         ; DATA XREF: std::_Iterator012<std::random_access_iterator_tag,ScintillaEditView *,int,ScintillaEditView * const *,ScintillaEditView * const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,ScintillaEditView *,int,ScintillaEditView * const *,ScintillaEditView * const &,std::_Iterator_base12>(std::_Iterator012<std::random_access_iterator_tag,ScintillaEditView *,int,ScintillaEditView * const *,ScintillaEditView * const &,std::_Iterator_base12> const &)+5o
.text$x:000027B8
.text$x:000027B8 arg_4           = dword ptr  8
.text$x:000027B8
.text$x:000027B8                 mov     edx, [esp+arg_4]
.text$x:000027BC                 lea     eax, [edx+0Ch]
.text$x:000027BF                 mov     ecx, [edx-8]
.text$x:000027C2                 xor     ecx, eax
.text$x:000027C4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000027C9                 mov     eax, offset __ehfuncinfo$??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVScintillaEditView@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z
.text$x:000027CE                 jmp     ___CxxFrameHandler3
.text$x:000027CE __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVScintillaEditView@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z endp
.text$x:000027CE
.text$x:000027CE ; ---------------------------------------------------------------------------
.text$x:000027D3                 align 4
.text$x:000027D3 _text$x         ends
.text$x:000027D3
.text$mn:000027D4 ; ===========================================================================
.text$mn:000027D4
.text$mn:000027D4 ; Segment type: Pure code
.text$mn:000027D4 ; Segment permissions: Read/Execute
.text$mn:000027D4 _text$mn        segment para public 'CODE' use32
.text$mn:000027D4                 assume cs:_text$mn
.text$mn:000027D4                 ;org 27D4h
.text$mn:000027D4 ; COMDAT (pick any)
.text$mn:000027D4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000027D4
.text$mn:000027D4 ; =============== S U B R O U T I N E =======================================
.text$mn:000027D4
.text$mn:000027D4 ; Attributes: bp-based frame
.text$mn:000027D4
.text$mn:000027D4 ; public: __thiscall std::_Iterator012<struct std::random_access_iterator_tag, class ScintillaEditView *, int, class ScintillaEditView * const *, class ScintillaEditView * const &, struct std::_Iterator_base12>::_Iterator012<struct std::random_access_iterator_tag, class ScintillaEditView *, int, class ScintillaEditView * const *, class ScintillaEditView * const &, struct std::_Iterator_base12>(void)
.text$mn:000027D4                 public ??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVScintillaEditView@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ
.text$mn:000027D4 ??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVScintillaEditView@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ proc near
.text$mn:000027D4                                         ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>(ScintillaEditView * *,std::_Container_base12 const *)+29p
.text$mn:000027D4
.text$mn:000027D4 var_10          = dword ptr -10h
.text$mn:000027D4 var_C           = dword ptr -0Ch
.text$mn:000027D4 var_4           = dword ptr -4
.text$mn:000027D4
.text$mn:000027D4                 push    ebp
.text$mn:000027D5                 mov     ebp, esp
.text$mn:000027D7                 push    0FFFFFFFFh
.text$mn:000027D9                 push    offset __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVScintillaEditView@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ
.text$mn:000027DE                 mov     eax, large fs:0
.text$mn:000027E4                 push    eax
.text$mn:000027E5                 push    ecx
.text$mn:000027E6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000027EB                 xor     eax, ebp
.text$mn:000027ED                 push    eax
.text$mn:000027EE                 lea     eax, [ebp+var_C]
.text$mn:000027F1                 mov     large fs:0, eax
.text$mn:000027F7                 mov     [ebp+var_10], ecx
.text$mn:000027FA                 mov     ecx, [ebp+var_10] ; this
.text$mn:000027FD                 call    ??0_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::_Iterator_base12(void)
.text$mn:00002802                 mov     [ebp+var_4], 0
.text$mn:00002809                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002810                 mov     eax, [ebp+var_10]
.text$mn:00002813                 mov     ecx, [ebp+var_C]
.text$mn:00002816                 mov     large fs:0, ecx
.text$mn:0000281D                 pop     ecx
.text$mn:0000281E                 mov     esp, ebp
.text$mn:00002820                 pop     ebp
.text$mn:00002821                 retn
.text$mn:00002821 ??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVScintillaEditView@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ endp
.text$mn:00002821
.text$mn:00002821 ; ---------------------------------------------------------------------------
.text$mn:00002822                 align 4
.text$mn:00002822 _text$mn        ends
.text$mn:00002822
.text$x:00002824 ; ===========================================================================
.text$x:00002824
.text$x:00002824 ; Segment type: Pure code
.text$x:00002824 ; Segment permissions: Read/Execute
.text$x:00002824 _text$x         segment para public 'CODE' use32
.text$x:00002824                 assume cs:_text$x
.text$x:00002824                 ;org 2824h
.text$x:00002824 ; COMDAT (pick associative to section at 27D4)
.text$x:00002824                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00002824
.text$x:00002824 ; =============== S U B R O U T I N E =======================================
.text$x:00002824
.text$x:00002824
.text$x:00002824 __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVScintillaEditView@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ$0 proc near
.text$x:00002824                                         ; DATA XREF: .xdata$x:0000A8F0o
.text$x:00002824                 mov     ecx, [ebp-10h]  ; this
.text$x:00002827                 jmp     ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$x:00002827 __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVScintillaEditView@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ$0 endp
.text$x:00002827
.text$x:0000282C
.text$x:0000282C ; =============== S U B R O U T I N E =======================================
.text$x:0000282C
.text$x:0000282C
.text$x:0000282C __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVScintillaEditView@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ proc near
.text$x:0000282C                                         ; DATA XREF: std::_Iterator012<std::random_access_iterator_tag,ScintillaEditView *,int,ScintillaEditView * const *,ScintillaEditView * const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,ScintillaEditView *,int,ScintillaEditView * const *,ScintillaEditView * const &,std::_Iterator_base12>(void)+5o
.text$x:0000282C
.text$x:0000282C arg_4           = dword ptr  8
.text$x:0000282C
.text$x:0000282C                 mov     edx, [esp+arg_4]
.text$x:00002830                 lea     eax, [edx+0Ch]
.text$x:00002833                 mov     ecx, [edx-8]
.text$x:00002836                 xor     ecx, eax
.text$x:00002838                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000283D                 mov     eax, offset __ehfuncinfo$??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVScintillaEditView@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ
.text$x:00002842                 jmp     ___CxxFrameHandler3
.text$x:00002842 __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVScintillaEditView@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ endp
.text$x:00002842
.text$x:00002842 ; ---------------------------------------------------------------------------
.text$x:00002847                 align 4
.text$x:00002847 _text$x         ends
.text$x:00002847
.text$mn:00002848 ; ===========================================================================
.text$mn:00002848
.text$mn:00002848 ; Segment type: Pure code
.text$mn:00002848 ; Segment permissions: Read/Execute
.text$mn:00002848 _text$mn        segment para public 'CODE' use32
.text$mn:00002848                 assume cs:_text$mn
.text$mn:00002848                 ;org 2848h
.text$mn:00002848 ; COMDAT (pick any)
.text$mn:00002848                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002848
.text$mn:00002848 ; =============== S U B R O U T I N E =======================================
.text$mn:00002848
.text$mn:00002848 ; Attributes: bp-based frame
.text$mn:00002848
.text$mn:00002848 ; int __stdcall std::_Iterator012<std::random_access_iterator_tag,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,int,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,int,std::_List_unchecked_iterator<std:
.text$mn:00002848                 public ??0?$_Iterator012@Urandom_access_iterator_tag@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@HPBV32@ABV32@U_Iterator_base12@2@@std@@QAE@ABU01@@Z
.text$mn:00002848 ??0?$_Iterator012@Urandom_access_iterator_tag@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@HPBV32@ABV32@U_Iterator_base12@2@@std@@QAE@ABU01@@Z proc near
.text$mn:00002848                                         ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>> const &)+2Dp
.text$mn:00002848
.text$mn:00002848 var_10          = dword ptr -10h
.text$mn:00002848 var_C           = dword ptr -0Ch
.text$mn:00002848 var_4           = dword ptr -4
.text$mn:00002848 arg_0           = dword ptr  8
.text$mn:00002848
.text$mn:00002848                 push    ebp
.text$mn:00002849                 mov     ebp, esp
.text$mn:0000284B                 push    0FFFFFFFFh
.text$mn:0000284D                 push    offset __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@HPBV32@ABV32@U_Iterator_base12@2@@std@@QAE@ABU01@@Z
.text$mn:00002852                 mov     eax, large fs:0
.text$mn:00002858                 push    eax
.text$mn:00002859                 push    ecx
.text$mn:0000285A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000285F                 xor     eax, ebp
.text$mn:00002861                 push    eax
.text$mn:00002862                 lea     eax, [ebp+var_C]
.text$mn:00002865                 mov     large fs:0, eax
.text$mn:0000286B                 mov     [ebp+var_10], ecx
.text$mn:0000286E                 mov     eax, [ebp+arg_0]
.text$mn:00002871                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00002872                 mov     ecx, [ebp+var_10] ; this
.text$mn:00002875                 call    ??0_Iterator_base12@std@@QAE@ABU01@@Z ; std::_Iterator_base12::_Iterator_base12(std::_Iterator_base12 const &)
.text$mn:0000287A                 mov     [ebp+var_4], 0
.text$mn:00002881                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002888                 mov     eax, [ebp+var_10]
.text$mn:0000288B                 mov     ecx, [ebp+var_C]
.text$mn:0000288E                 mov     large fs:0, ecx
.text$mn:00002895                 pop     ecx
.text$mn:00002896                 mov     esp, ebp
.text$mn:00002898                 pop     ebp
.text$mn:00002899                 retn    4
.text$mn:00002899 ??0?$_Iterator012@Urandom_access_iterator_tag@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@HPBV32@ABV32@U_Iterator_base12@2@@std@@QAE@ABU01@@Z endp
.text$mn:00002899
.text$mn:00002899 _text$mn        ends
.text$mn:00002899
.text$x:0000289C ; ===========================================================================
.text$x:0000289C
.text$x:0000289C ; Segment type: Pure code
.text$x:0000289C ; Segment permissions: Read/Execute
.text$x:0000289C _text$x         segment para public 'CODE' use32
.text$x:0000289C                 assume cs:_text$x
.text$x:0000289C                 ;org 289Ch
.text$x:0000289C ; COMDAT (pick associative to section at 2848)
.text$x:0000289C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000289C
.text$x:0000289C ; =============== S U B R O U T I N E =======================================
.text$x:0000289C
.text$x:0000289C
.text$x:0000289C __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@HPBV32@ABV32@U_Iterator_base12@2@@std@@QAE@ABU01@@Z$0 proc near
.text$x:0000289C                                         ; DATA XREF: .xdata$x:0000AB34o
.text$x:0000289C                 mov     ecx, [ebp-10h]  ; this
.text$x:0000289F                 jmp     ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$x:0000289F __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@HPBV32@ABV32@U_Iterator_base12@2@@std@@QAE@ABU01@@Z$0 endp
.text$x:0000289F
.text$x:000028A4
.text$x:000028A4 ; =============== S U B R O U T I N E =======================================
.text$x:000028A4
.text$x:000028A4
.text$x:000028A4 __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@HPBV32@ABV32@U_Iterator_base12@2@@std@@QAE@ABU01@@Z proc near
.text$x:000028A4                                         ; DATA XREF: std::_Iterator012<std::random_access_iterator_tag,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,int,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,int,std::_List_unchecked_iterator<
.text$x:000028A4
.text$x:000028A4 arg_4           = dword ptr  8
.text$x:000028A4
.text$x:000028A4                 mov     edx, [esp+arg_4]
.text$x:000028A8                 lea     eax, [edx+0Ch]
.text$x:000028AB                 mov     ecx, [edx-8]
.text$x:000028AE                 xor     ecx, eax
.text$x:000028B0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000028B5                 mov     eax, offset __ehfuncinfo$??0?$_Iterator012@Urandom_access_iterator_tag@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@HPBV32@ABV32@U_Iterator_base12@2@@std@@QAE@ABU01@@Z
.text$x:000028BA                 jmp     ___CxxFrameHandler3
.text$x:000028BA __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@HPBV32@ABV32@U_Iterator_base12@2@@std@@QAE@ABU01@@Z endp
.text$x:000028BA
.text$x:000028BA ; ---------------------------------------------------------------------------
.text$x:000028BF                 align 10h
.text$x:000028BF _text$x         ends
.text$x:000028BF
.text$mn:000028C0 ; ===========================================================================
.text$mn:000028C0
.text$mn:000028C0 ; Segment type: Pure code
.text$mn:000028C0 ; Segment permissions: Read/Execute
.text$mn:000028C0 _text$mn        segment para public 'CODE' use32
.text$mn:000028C0                 assume cs:_text$mn
.text$mn:000028C0                 ;org 28C0h
.text$mn:000028C0 ; COMDAT (pick any)
.text$mn:000028C0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000028C0
.text$mn:000028C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000028C0
.text$mn:000028C0 ; Attributes: bp-based frame
.text$mn:000028C0
.text$mn:000028C0 ; public: __thiscall std::_Iterator012<struct std::random_access_iterator_tag, class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>, int, class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>> const *, class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>> const &, struct std::_Iterator_base12>::_Iterator01
.text$mn:000028C0                 public ??0?$_Iterator012@Urandom_access_iterator_tag@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@HPBV32@ABV32@U_Iterator_base12@2@@std@@QAE@XZ
.text$mn:000028C0 ??0?$_Iterator012@Urandom_access_iterator_tag@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@HPBV32@ABV32@U_Iterator_base12@2@@std@@QAE@XZ proc near
.text$mn:000028C0                                         ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_Container_base12 const *)+29p
.text$mn:000028C0
.text$mn:000028C0 var_10          = dword ptr -10h
.text$mn:000028C0 var_C           = dword ptr -0Ch
.text$mn:000028C0 var_4           = dword ptr -4
.text$mn:000028C0
.text$mn:000028C0                 push    ebp
.text$mn:000028C1                 mov     ebp, esp
.text$mn:000028C3                 push    0FFFFFFFFh
.text$mn:000028C5                 push    offset __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@HPBV32@ABV32@U_Iterator_base12@2@@std@@QAE@XZ
.text$mn:000028CA                 mov     eax, large fs:0
.text$mn:000028D0                 push    eax
.text$mn:000028D1                 push    ecx
.text$mn:000028D2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000028D7                 xor     eax, ebp
.text$mn:000028D9                 push    eax
.text$mn:000028DA                 lea     eax, [ebp+var_C]
.text$mn:000028DD                 mov     large fs:0, eax
.text$mn:000028E3                 mov     [ebp+var_10], ecx
.text$mn:000028E6                 mov     ecx, [ebp+var_10] ; this
.text$mn:000028E9                 call    ??0_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::_Iterator_base12(void)
.text$mn:000028EE                 mov     [ebp+var_4], 0
.text$mn:000028F5                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000028FC                 mov     eax, [ebp+var_10]
.text$mn:000028FF                 mov     ecx, [ebp+var_C]
.text$mn:00002902                 mov     large fs:0, ecx
.text$mn:00002909                 pop     ecx
.text$mn:0000290A                 mov     esp, ebp
.text$mn:0000290C                 pop     ebp
.text$mn:0000290D                 retn
.text$mn:0000290D ??0?$_Iterator012@Urandom_access_iterator_tag@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@HPBV32@ABV32@U_Iterator_base12@2@@std@@QAE@XZ endp
.text$mn:0000290D
.text$mn:0000290D ; ---------------------------------------------------------------------------
.text$mn:0000290E                 align 10h
.text$mn:0000290E _text$mn        ends
.text$mn:0000290E
.text$x:00002910 ; ===========================================================================
.text$x:00002910
.text$x:00002910 ; Segment type: Pure code
.text$x:00002910 ; Segment permissions: Read/Execute
.text$x:00002910 _text$x         segment para public 'CODE' use32
.text$x:00002910                 assume cs:_text$x
.text$x:00002910                 ;org 2910h
.text$x:00002910 ; COMDAT (pick associative to section at 28C0)
.text$x:00002910                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00002910
.text$x:00002910 ; =============== S U B R O U T I N E =======================================
.text$x:00002910
.text$x:00002910
.text$x:00002910 __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@HPBV32@ABV32@U_Iterator_base12@2@@std@@QAE@XZ$0 proc near
.text$x:00002910                                         ; DATA XREF: .xdata$x:0000AADCo
.text$x:00002910                 mov     ecx, [ebp-10h]  ; this
.text$x:00002913                 jmp     ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$x:00002913 __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@HPBV32@ABV32@U_Iterator_base12@2@@std@@QAE@XZ$0 endp
.text$x:00002913
.text$x:00002918
.text$x:00002918 ; =============== S U B R O U T I N E =======================================
.text$x:00002918
.text$x:00002918
.text$x:00002918 __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@HPBV32@ABV32@U_Iterator_base12@2@@std@@QAE@XZ proc near
.text$x:00002918                                         ; DATA XREF: std::_Iterator012<std::random_access_iterator_tag,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,int,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,int,std::_List_unchecked_iterator<
.text$x:00002918
.text$x:00002918 arg_4           = dword ptr  8
.text$x:00002918
.text$x:00002918                 mov     edx, [esp+arg_4]
.text$x:0000291C                 lea     eax, [edx+0Ch]
.text$x:0000291F                 mov     ecx, [edx-8]
.text$x:00002922                 xor     ecx, eax
.text$x:00002924                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002929                 mov     eax, offset __ehfuncinfo$??0?$_Iterator012@Urandom_access_iterator_tag@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@HPBV32@ABV32@U_Iterator_base12@2@@std@@QAE@XZ
.text$x:0000292E                 jmp     ___CxxFrameHandler3
.text$x:0000292E __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@HPBV32@ABV32@U_Iterator_base12@2@@std@@QAE@XZ endp
.text$x:0000292E
.text$x:0000292E ; ---------------------------------------------------------------------------
.text$x:00002933                 align 4
.text$x:00002933 _text$x         ends
.text$x:00002933
.text$mn:00002934 ; ===========================================================================
.text$mn:00002934
.text$mn:00002934 ; Segment type: Pure code
.text$mn:00002934 ; Segment permissions: Read/Execute
.text$mn:00002934 _text$mn        segment para public 'CODE' use32
.text$mn:00002934                 assume cs:_text$mn
.text$mn:00002934                 ;org 2934h
.text$mn:00002934 ; COMDAT (pick any)
.text$mn:00002934                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002934
.text$mn:00002934 ; =============== S U B R O U T I N E =======================================
.text$mn:00002934
.text$mn:00002934 ; Attributes: bp-based frame
.text$mn:00002934
.text$mn:00002934 ; public: __thiscall std::_List_alloc<0, struct std::_List_base_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>, class std::allocator<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>::_List_alloc<0, struct std::_List_base_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>, class std::allocator<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>(class std::allocator<struct std::pair<class Buffer *
.text$mn:00002934                 public ??0?$_List_alloc@$0A@U?$_List_base_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@1@@Z
.text$mn:00002934 ??0?$_List_alloc@$0A@U?$_List_base_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@1@@Z proc near
.text$mn:00002934                                         ; CODE XREF: std::_List_buy<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>::_List_buy<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>(std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>> const &)+2Dp
.text$mn:00002934
.text$mn:00002934 var_14          = dword ptr -14h
.text$mn:00002934 var_10          = dword ptr -10h
.text$mn:00002934 var_C           = dword ptr -0Ch
.text$mn:00002934 var_4           = dword ptr -4
.text$mn:00002934
.text$mn:00002934 ; FUNCTION CHUNK AT .text$mn:000029AA SIZE 00000009 BYTES
.text$mn:00002934 ; FUNCTION CHUNK AT .text$mn:000029BA SIZE 0000001E BYTES
.text$mn:00002934
.text$mn:00002934                 push    ebp
.text$mn:00002935                 mov     ebp, esp
.text$mn:00002937                 push    0FFFFFFFFh
.text$mn:00002939                 push    offset __ehhandler$??0?$_List_alloc@$0A@U?$_List_base_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@1@@Z
.text$mn:0000293E                 mov     eax, large fs:0
.text$mn:00002944                 push    eax
.text$mn:00002945                 push    ecx
.text$mn:00002946                 push    ecx
.text$mn:00002947                 push    ebx
.text$mn:00002948                 push    esi
.text$mn:00002949                 push    edi
.text$mn:0000294A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000294F                 xor     eax, ebp
.text$mn:00002951                 push    eax
.text$mn:00002952                 lea     eax, [ebp+var_C]
.text$mn:00002955                 mov     large fs:0, eax
.text$mn:0000295B                 mov     [ebp+var_10], esp
.text$mn:0000295E                 mov     [ebp+var_14], ecx
.text$mn:00002961                 mov     ecx, [ebp+var_14]
.text$mn:00002964                 call    ??0?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@QAE@XZ ; std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>(void)
.text$mn:00002969                 mov     [ebp+var_4], 0
.text$mn:00002970                 mov     ecx, [ebp+var_14]
.text$mn:00002973                 call    ?_Buyheadnode@?$_List_alloc@$0A@U?$_List_base_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@@std@@QAEPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@2@XZ ; std::_List_alloc<0,std::_List_base_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::_Buyheadnode(void)
.text$mn:00002978                 mov     ecx, [ebp+var_14]
.text$mn:0000297B                 mov     [ecx+4], eax
.text$mn:0000297E                 mov     byte ptr [ebp+var_4], 1
.text$mn:00002982                 mov     ecx, [ebp+var_14]
.text$mn:00002985                 call    ?_Alloc_proxy@?$_List_alloc@$0A@U?$_List_base_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@@std@@QAEXXZ ; std::_List_alloc<0,std::_List_base_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::_Alloc_proxy(void)
.text$mn:0000298A                 jmp     short loc_29AA
.text$mn:0000298A ??0?$_List_alloc@$0A@U?$_List_base_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@1@@Z endp
.text$mn:0000298A
.text$mn:0000298C
.text$mn:0000298C ; =============== S U B R O U T I N E =======================================
.text$mn:0000298C
.text$mn:0000298C ; Attributes: noreturn
.text$mn:0000298C
.text$mn:0000298C __catch$??0?$_List_alloc@$0A@U?$_List_base_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@1@@Z$0 proc near
.text$mn:0000298C                                         ; DATA XREF: .xdata$x:00009DF8o
.text$mn:0000298C                 mov     edx, [ebp-14h]
.text$mn:0000298F                 mov     eax, [edx+4]
.text$mn:00002992                 push    eax             ; void *
.text$mn:00002993                 mov     ecx, [ebp-14h]
.text$mn:00002996                 call    ?_Freeheadnode@?$_List_alloc@$0A@U?$_List_base_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@@std@@QAEXPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@2@@Z ; std::_List_alloc<0,std::_List_base_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::_Freeheadnode(std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *)
.text$mn:0000299B                 push    0
.text$mn:0000299D                 push    0
.text$mn:0000299F                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:0000299F __catch$??0?$_List_alloc@$0A@U?$_List_base_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@1@@Z$0 endp
.text$mn:0000299F
.text$mn:000029A4 ; ---------------------------------------------------------------------------
.text$mn:000029A4                 mov     eax, offset $LN8_1
.text$mn:000029A9                 retn
.text$mn:000029AA ; ---------------------------------------------------------------------------
.text$mn:000029AA ; START OF FUNCTION CHUNK FOR ??0?$_List_alloc@$0A@U?$_List_base_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@1@@Z
.text$mn:000029AA
.text$mn:000029AA loc_29AA:                               ; CODE XREF: std::_List_alloc<0,std::_List_base_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::_List_alloc<0,std::_List_base_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>(std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>> const &)+56j
.text$mn:000029AA                 mov     [ebp+var_4], 0
.text$mn:000029B1                 jmp     short loc_29BA
.text$mn:000029B1 ; END OF FUNCTION CHUNK FOR ??0?$_List_alloc@$0A@U?$_List_base_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@1@@Z
.text$mn:000029B3
.text$mn:000029B3 ; =============== S U B R O U T I N E =======================================
.text$mn:000029B3
.text$mn:000029B3
.text$mn:000029B3 $LN8_1          proc near               ; DATA XREF: .text$mn:000029A4o
.text$mn:000029B3                 mov     dword ptr [ebp-4], 0
.text$mn:000029B3 $LN8_1          endp ; sp-analysis failed
.text$mn:000029B3
.text$mn:000029BA ; START OF FUNCTION CHUNK FOR ??0?$_List_alloc@$0A@U?$_List_base_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@1@@Z
.text$mn:000029BA
.text$mn:000029BA loc_29BA:                               ; CODE XREF: std::_List_alloc<0,std::_List_base_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::_List_alloc<0,std::_List_base_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>(std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>> const &)+7Dj
.text$mn:000029BA                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000029C1                 mov     eax, [ebp+var_14]
.text$mn:000029C4                 mov     ecx, [ebp+var_C]
.text$mn:000029C7                 mov     large fs:0, ecx
.text$mn:000029CE                 pop     ecx
.text$mn:000029CF                 pop     edi
.text$mn:000029D0                 pop     esi
.text$mn:000029D1                 pop     ebx
.text$mn:000029D2                 mov     esp, ebp
.text$mn:000029D4                 pop     ebp
.text$mn:000029D5                 retn    4
.text$mn:000029D5 ; END OF FUNCTION CHUNK FOR ??0?$_List_alloc@$0A@U?$_List_base_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@1@@Z
.text$mn:000029D5 _text$mn        ends
.text$mn:000029D5
.text$x:000029D8 ; ===========================================================================
.text$x:000029D8
.text$x:000029D8 ; Segment type: Pure code
.text$x:000029D8 ; Segment permissions: Read/Execute
.text$x:000029D8 _text$x         segment para public 'CODE' use32
.text$x:000029D8                 assume cs:_text$x
.text$x:000029D8                 ;org 29D8h
.text$x:000029D8 ; COMDAT (pick associative to section at 2934)
.text$x:000029D8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000029D8
.text$x:000029D8 ; =============== S U B R O U T I N E =======================================
.text$x:000029D8
.text$x:000029D8
.text$x:000029D8 __unwindfunclet$??0?$_List_alloc@$0A@U?$_List_base_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@1@@Z$2 proc near
.text$x:000029D8                                         ; DATA XREF: .xdata$x:00009E14o
.text$x:000029D8                 mov     ecx, [ebp-14h]
.text$x:000029DB                 jmp     ??1?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@QAE@XZ ; std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>::~_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>(void)
.text$x:000029DB __unwindfunclet$??0?$_List_alloc@$0A@U?$_List_base_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@1@@Z$2 endp
.text$x:000029DB
.text$x:000029E0
.text$x:000029E0 ; =============== S U B R O U T I N E =======================================
.text$x:000029E0
.text$x:000029E0
.text$x:000029E0 __ehhandler$??0?$_List_alloc@$0A@U?$_List_base_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@1@@Z proc near
.text$x:000029E0                                         ; DATA XREF: std::_List_alloc<0,std::_List_base_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::_List_alloc<0,std::_List_base_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>(std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>> const &)+5o
.text$x:000029E0
.text$x:000029E0 arg_4           = dword ptr  8
.text$x:000029E0
.text$x:000029E0                 mov     edx, [esp+arg_4]
.text$x:000029E4                 lea     eax, [edx+0Ch]
.text$x:000029E7                 mov     ecx, [edx-18h]
.text$x:000029EA                 xor     ecx, eax
.text$x:000029EC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000029F1                 mov     eax, offset __ehfuncinfo$??0?$_List_alloc@$0A@U?$_List_base_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@1@@Z
.text$x:000029F6                 jmp     ___CxxFrameHandler3
.text$x:000029F6 __ehhandler$??0?$_List_alloc@$0A@U?$_List_base_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@1@@Z endp
.text$x:000029F6
.text$x:000029F6 ; ---------------------------------------------------------------------------
.text$x:000029FB                 align 4
.text$x:000029FB _text$x         ends
.text$x:000029FB
.text$mn:000029FC ; ===========================================================================
.text$mn:000029FC
.text$mn:000029FC ; Segment type: Pure code
.text$mn:000029FC ; Segment permissions: Read/Execute
.text$mn:000029FC _text$mn        segment para public 'CODE' use32
.text$mn:000029FC                 assume cs:_text$mn
.text$mn:000029FC                 ;org 29FCh
.text$mn:000029FC ; COMDAT (pick any)
.text$mn:000029FC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000029FC
.text$mn:000029FC ; =============== S U B R O U T I N E =======================================
.text$mn:000029FC
.text$mn:000029FC ; Attributes: bp-based frame
.text$mn:000029FC
.text$mn:000029FC ; public: __thiscall std::_List_buy<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>, class std::allocator<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>::_List_buy<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>, class std::allocator<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>(class std::allocator<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<i
.text$mn:000029FC                 public ??0?$_List_buy@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@1@@Z
.text$mn:000029FC ??0?$_List_buy@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@1@@Z proc near
.text$mn:000029FC                                         ; CODE XREF: std::list<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>::list<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>(std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>> const &)+2Dp
.text$mn:000029FC
.text$mn:000029FC var_10          = dword ptr -10h
.text$mn:000029FC var_C           = dword ptr -0Ch
.text$mn:000029FC var_4           = dword ptr -4
.text$mn:000029FC arg_0           = dword ptr  8
.text$mn:000029FC
.text$mn:000029FC                 push    ebp
.text$mn:000029FD                 mov     ebp, esp
.text$mn:000029FF                 push    0FFFFFFFFh
.text$mn:00002A01                 push    offset __ehhandler$??0?$_List_buy@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@1@@Z
.text$mn:00002A06                 mov     eax, large fs:0
.text$mn:00002A0C                 push    eax
.text$mn:00002A0D                 push    ecx
.text$mn:00002A0E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002A13                 xor     eax, ebp
.text$mn:00002A15                 push    eax
.text$mn:00002A16                 lea     eax, [ebp+var_C]
.text$mn:00002A19                 mov     large fs:0, eax
.text$mn:00002A1F                 mov     [ebp+var_10], ecx
.text$mn:00002A22                 mov     eax, [ebp+arg_0]
.text$mn:00002A25                 push    eax
.text$mn:00002A26                 mov     ecx, [ebp+var_10]
.text$mn:00002A29                 call    ??0?$_List_alloc@$0A@U?$_List_base_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@1@@Z ; std::_List_alloc<0,std::_List_base_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::_List_alloc<0,std::_List_base_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>(std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>> const &)
.text$mn:00002A2E                 mov     [ebp+var_4], 0
.text$mn:00002A35                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002A3C                 mov     eax, [ebp+var_10]
.text$mn:00002A3F                 mov     ecx, [ebp+var_C]
.text$mn:00002A42                 mov     large fs:0, ecx
.text$mn:00002A49                 pop     ecx
.text$mn:00002A4A                 mov     esp, ebp
.text$mn:00002A4C                 pop     ebp
.text$mn:00002A4D                 retn    4
.text$mn:00002A4D ??0?$_List_buy@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@1@@Z endp
.text$mn:00002A4D
.text$mn:00002A4D _text$mn        ends
.text$mn:00002A4D
.text$x:00002A50 ; ===========================================================================
.text$x:00002A50
.text$x:00002A50 ; Segment type: Pure code
.text$x:00002A50 ; Segment permissions: Read/Execute
.text$x:00002A50 _text$x         segment para public 'CODE' use32
.text$x:00002A50                 assume cs:_text$x
.text$x:00002A50                 ;org 2A50h
.text$x:00002A50 ; COMDAT (pick associative to section at 29FC)
.text$x:00002A50                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00002A50
.text$x:00002A50 ; =============== S U B R O U T I N E =======================================
.text$x:00002A50
.text$x:00002A50
.text$x:00002A50 __unwindfunclet$??0?$_List_buy@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@1@@Z$0 proc near
.text$x:00002A50                                         ; DATA XREF: .xdata$x:00009ED4o
.text$x:00002A50                 mov     ecx, [ebp-10h]
.text$x:00002A53                 jmp     ??1?$_List_alloc@$0A@U?$_List_base_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@@std@@QAE@XZ ; std::_List_alloc<0,std::_List_base_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::~_List_alloc<0,std::_List_base_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>(void)
.text$x:00002A53 __unwindfunclet$??0?$_List_buy@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@1@@Z$0 endp
.text$x:00002A53
.text$x:00002A58
.text$x:00002A58 ; =============== S U B R O U T I N E =======================================
.text$x:00002A58
.text$x:00002A58
.text$x:00002A58 __ehhandler$??0?$_List_buy@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@1@@Z proc near
.text$x:00002A58                                         ; DATA XREF: std::_List_buy<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>::_List_buy<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>(std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>> const &)+5o
.text$x:00002A58
.text$x:00002A58 arg_4           = dword ptr  8
.text$x:00002A58
.text$x:00002A58                 mov     edx, [esp+arg_4]
.text$x:00002A5C                 lea     eax, [edx+0Ch]
.text$x:00002A5F                 mov     ecx, [edx-8]
.text$x:00002A62                 xor     ecx, eax
.text$x:00002A64                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002A69                 mov     eax, offset __ehfuncinfo$??0?$_List_buy@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@1@@Z
.text$x:00002A6E                 jmp     ___CxxFrameHandler3
.text$x:00002A6E __ehhandler$??0?$_List_buy@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@1@@Z endp
.text$x:00002A6E
.text$x:00002A6E ; ---------------------------------------------------------------------------
.text$x:00002A73                 align 4
.text$x:00002A73 _text$x         ends
.text$x:00002A73
.text$mn:00002A74 ; ===========================================================================
.text$mn:00002A74
.text$mn:00002A74 ; Segment type: Pure code
.text$mn:00002A74 ; Segment permissions: Read/Execute
.text$mn:00002A74 _text$mn        segment para public 'CODE' use32
.text$mn:00002A74                 assume cs:_text$mn
.text$mn:00002A74                 ;org 2A74h
.text$mn:00002A74 ; COMDAT (pick any)
.text$mn:00002A74                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002A74
.text$mn:00002A74 ; =============== S U B R O U T I N E =======================================
.text$mn:00002A74
.text$mn:00002A74 ; Attributes: bp-based frame
.text$mn:00002A74
.text$mn:00002A74 ; int __stdcall std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>(int, struct std::_Container_base12 *)
.text$mn:00002A74                 public ??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@1@@Z
.text$mn:00002A74 ??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@1@@Z proc near
.text$mn:00002A74                                         ; CODE XREF: std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>(std::_List_node<std::pair<int const,Style>,void *> *,std::_List_val<std::_List_simple_types<std::pair<int const,Style>>> const *)+31p
.text$mn:00002A74
.text$mn:00002A74 var_10          = dword ptr -10h
.text$mn:00002A74 var_C           = dword ptr -0Ch
.text$mn:00002A74 var_4           = dword ptr -4
.text$mn:00002A74 arg_0           = dword ptr  8
.text$mn:00002A74 arg_4           = dword ptr  0Ch
.text$mn:00002A74
.text$mn:00002A74                 push    ebp
.text$mn:00002A75                 mov     ebp, esp
.text$mn:00002A77                 push    0FFFFFFFFh
.text$mn:00002A79                 push    offset __ehhandler$??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@1@@Z
.text$mn:00002A7E                 mov     eax, large fs:0
.text$mn:00002A84                 push    eax
.text$mn:00002A85                 push    ecx
.text$mn:00002A86                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002A8B                 xor     eax, ebp
.text$mn:00002A8D                 push    eax
.text$mn:00002A8E                 lea     eax, [ebp+var_C]
.text$mn:00002A91                 mov     large fs:0, eax
.text$mn:00002A97                 mov     [ebp+var_10], ecx
.text$mn:00002A9A                 mov     eax, [ebp+arg_4]
.text$mn:00002A9D                 push    eax             ; struct std::_Container_base12 *
.text$mn:00002A9E                 mov     ecx, [ebp+arg_0]
.text$mn:00002AA1                 push    ecx             ; int
.text$mn:00002AA2                 mov     ecx, [ebp+var_10]
.text$mn:00002AA5                 call    ??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QAE@PAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@1@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>,std::_Iterator_base12>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>,std::_Iterator_base12>(std::_List_node<std::pair<int const,Style>,void *> *,std::_List_val<std::_List_simple_types<std::pair<int const,Style>>> const *)
.text$mn:00002AAA                 mov     [ebp+var_4], 0
.text$mn:00002AB1                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002AB8                 mov     eax, [ebp+var_10]
.text$mn:00002ABB                 mov     ecx, [ebp+var_C]
.text$mn:00002ABE                 mov     large fs:0, ecx
.text$mn:00002AC5                 pop     ecx
.text$mn:00002AC6                 mov     esp, ebp
.text$mn:00002AC8                 pop     ebp
.text$mn:00002AC9                 retn    8
.text$mn:00002AC9 ??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@1@@Z endp
.text$mn:00002AC9
.text$mn:00002AC9 _text$mn        ends
.text$mn:00002AC9
.text$x:00002ACC ; ===========================================================================
.text$x:00002ACC
.text$x:00002ACC ; Segment type: Pure code
.text$x:00002ACC ; Segment permissions: Read/Execute
.text$x:00002ACC _text$x         segment para public 'CODE' use32
.text$x:00002ACC                 assume cs:_text$x
.text$x:00002ACC                 ;org 2ACCh
.text$x:00002ACC ; COMDAT (pick associative to section at 2A74)
.text$x:00002ACC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00002ACC
.text$x:00002ACC ; =============== S U B R O U T I N E =======================================
.text$x:00002ACC
.text$x:00002ACC
.text$x:00002ACC __unwindfunclet$??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@1@@Z$0 proc near
.text$x:00002ACC                                         ; DATA XREF: .xdata$x:0000A814o
.text$x:00002ACC                 mov     ecx, [ebp-10h]
.text$x:00002ACF                 jmp     ??1?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QAE@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>,std::_Iterator_base12>::~_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>,std::_Iterator_base12>(void)
.text$x:00002ACF __unwindfunclet$??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@1@@Z$0 endp
.text$x:00002ACF
.text$x:00002AD4
.text$x:00002AD4 ; =============== S U B R O U T I N E =======================================
.text$x:00002AD4
.text$x:00002AD4
.text$x:00002AD4 __ehhandler$??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@1@@Z proc near
.text$x:00002AD4                                         ; DATA XREF: std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>(std::_List_node<std::pair<int const,Style>,void *> *,std::_List_val<std::_List_simple_types<std::pair<int const,Style>>> const *)+5o
.text$x:00002AD4
.text$x:00002AD4 arg_4           = dword ptr  8
.text$x:00002AD4
.text$x:00002AD4                 mov     edx, [esp+arg_4]
.text$x:00002AD8                 lea     eax, [edx+0Ch]
.text$x:00002ADB                 mov     ecx, [edx-8]
.text$x:00002ADE                 xor     ecx, eax
.text$x:00002AE0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002AE5                 mov     eax, offset __ehfuncinfo$??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@1@@Z
.text$x:00002AEA                 jmp     ___CxxFrameHandler3
.text$x:00002AEA __ehhandler$??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@1@@Z endp
.text$x:00002AEA
.text$x:00002AEA ; ---------------------------------------------------------------------------
.text$x:00002AEF                 align 10h
.text$x:00002AEF _text$x         ends
.text$x:00002AEF
.text$mn:00002AF0 ; ===========================================================================
.text$mn:00002AF0
.text$mn:00002AF0 ; Segment type: Pure code
.text$mn:00002AF0 ; Segment permissions: Read/Execute
.text$mn:00002AF0 _text$mn        segment para public 'CODE' use32
.text$mn:00002AF0                 assume cs:_text$mn
.text$mn:00002AF0                 ;org 2AF0h
.text$mn:00002AF0 ; COMDAT (pick any)
.text$mn:00002AF0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002AF0
.text$mn:00002AF0 ; =============== S U B R O U T I N E =======================================
.text$mn:00002AF0
.text$mn:00002AF0 ; Attributes: bp-based frame
.text$mn:00002AF0
.text$mn:00002AF0 ; int __stdcall std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>(int, struct std::_Container_base12 *)
.text$mn:00002AF0                 public ??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@1@@Z
.text$mn:00002AF0 ??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@1@@Z proc near
.text$mn:00002AF0                                         ; CODE XREF: std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>(std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *,std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>> const *)+31p
.text$mn:00002AF0
.text$mn:00002AF0 var_10          = dword ptr -10h
.text$mn:00002AF0 var_C           = dword ptr -0Ch
.text$mn:00002AF0 var_4           = dword ptr -4
.text$mn:00002AF0 arg_0           = dword ptr  8
.text$mn:00002AF0 arg_4           = dword ptr  0Ch
.text$mn:00002AF0
.text$mn:00002AF0                 push    ebp
.text$mn:00002AF1                 mov     ebp, esp
.text$mn:00002AF3                 push    0FFFFFFFFh
.text$mn:00002AF5                 push    offset __ehhandler$??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@1@@Z
.text$mn:00002AFA                 mov     eax, large fs:0
.text$mn:00002B00                 push    eax
.text$mn:00002B01                 push    ecx
.text$mn:00002B02                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002B07                 xor     eax, ebp
.text$mn:00002B09                 push    eax
.text$mn:00002B0A                 lea     eax, [ebp+var_C]
.text$mn:00002B0D                 mov     large fs:0, eax
.text$mn:00002B13                 mov     [ebp+var_10], ecx
.text$mn:00002B16                 mov     eax, [ebp+arg_4]
.text$mn:00002B19                 push    eax             ; struct std::_Container_base12 *
.text$mn:00002B1A                 mov     ecx, [ebp+arg_0]
.text$mn:00002B1D                 push    ecx             ; int
.text$mn:00002B1E                 mov     ecx, [ebp+var_10]
.text$mn:00002B21                 call    ??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QAE@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@1@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>,std::_Iterator_base12>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>,std::_Iterator_base12>(std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *,std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>> const *)
.text$mn:00002B26                 mov     [ebp+var_4], 0
.text$mn:00002B2D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002B34                 mov     eax, [ebp+var_10]
.text$mn:00002B37                 mov     ecx, [ebp+var_C]
.text$mn:00002B3A                 mov     large fs:0, ecx
.text$mn:00002B41                 pop     ecx
.text$mn:00002B42                 mov     esp, ebp
.text$mn:00002B44                 pop     ebp
.text$mn:00002B45                 retn    8
.text$mn:00002B45 ??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@1@@Z endp
.text$mn:00002B45
.text$mn:00002B45 _text$mn        ends
.text$mn:00002B45
.text$x:00002B48 ; ===========================================================================
.text$x:00002B48
.text$x:00002B48 ; Segment type: Pure code
.text$x:00002B48 ; Segment permissions: Read/Execute
.text$x:00002B48 _text$x         segment para public 'CODE' use32
.text$x:00002B48                 assume cs:_text$x
.text$x:00002B48                 ;org 2B48h
.text$x:00002B48 ; COMDAT (pick associative to section at 2AF0)
.text$x:00002B48                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00002B48
.text$x:00002B48 ; =============== S U B R O U T I N E =======================================
.text$x:00002B48
.text$x:00002B48
.text$x:00002B48 __unwindfunclet$??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@1@@Z$0 proc near
.text$x:00002B48                                         ; DATA XREF: .xdata$x:0000A444o
.text$x:00002B48                 mov     ecx, [ebp-10h]
.text$x:00002B4B                 jmp     ??1?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QAE@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>,std::_Iterator_base12>::~_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>,std::_Iterator_base12>(void)
.text$x:00002B4B __unwindfunclet$??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@1@@Z$0 endp
.text$x:00002B4B
.text$x:00002B50
.text$x:00002B50 ; =============== S U B R O U T I N E =======================================
.text$x:00002B50
.text$x:00002B50
.text$x:00002B50 __ehhandler$??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@1@@Z proc near
.text$x:00002B50                                         ; DATA XREF: std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>(std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *,std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>> const *)+5o
.text$x:00002B50
.text$x:00002B50 arg_4           = dword ptr  8
.text$x:00002B50
.text$x:00002B50                 mov     edx, [esp+arg_4]
.text$x:00002B54                 lea     eax, [edx+0Ch]
.text$x:00002B57                 mov     ecx, [edx-8]
.text$x:00002B5A                 xor     ecx, eax
.text$x:00002B5C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002B61                 mov     eax, offset __ehfuncinfo$??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@1@@Z
.text$x:00002B66                 jmp     ___CxxFrameHandler3
.text$x:00002B66 __ehhandler$??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@1@@Z endp
.text$x:00002B66
.text$x:00002B66 ; ---------------------------------------------------------------------------
.text$x:00002B6B                 align 4
.text$x:00002B6B _text$x         ends
.text$x:00002B6B
.text$mn:00002B6C ; ===========================================================================
.text$mn:00002B6C
.text$mn:00002B6C ; Segment type: Pure code
.text$mn:00002B6C ; Segment permissions: Read/Execute
.text$mn:00002B6C _text$mn        segment para public 'CODE' use32
.text$mn:00002B6C                 assume cs:_text$mn
.text$mn:00002B6C                 ;org 2B6Ch
.text$mn:00002B6C ; COMDAT (pick any)
.text$mn:00002B6C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002B6C
.text$mn:00002B6C ; =============== S U B R O U T I N E =======================================
.text$mn:00002B6C
.text$mn:00002B6C ; Attributes: bp-based frame
.text$mn:00002B6C
.text$mn:00002B6C ; int __stdcall std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>(int, struct std::_Container_base12 *)
.text$mn:00002B6C                 public ??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@1@@Z
.text$mn:00002B6C ??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@1@@Z proc near
.text$mn:00002B6C                                         ; CODE XREF: std::list<std::pair<int const,Style>,std::allocator<std::pair<int const,Style>>>::begin(void)+48p
.text$mn:00002B6C                                         ; std::list<std::pair<int const,Style>,std::allocator<std::pair<int const,Style>>>::end(void)+3Dp
.text$mn:00002B6C
.text$mn:00002B6C var_10          = dword ptr -10h
.text$mn:00002B6C var_C           = dword ptr -0Ch
.text$mn:00002B6C var_4           = dword ptr -4
.text$mn:00002B6C arg_0           = dword ptr  8
.text$mn:00002B6C arg_4           = dword ptr  0Ch
.text$mn:00002B6C
.text$mn:00002B6C                 push    ebp
.text$mn:00002B6D                 mov     ebp, esp
.text$mn:00002B6F                 push    0FFFFFFFFh
.text$mn:00002B71                 push    offset __ehhandler$??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@1@@Z
.text$mn:00002B76                 mov     eax, large fs:0
.text$mn:00002B7C                 push    eax
.text$mn:00002B7D                 push    ecx
.text$mn:00002B7E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002B83                 xor     eax, ebp
.text$mn:00002B85                 push    eax
.text$mn:00002B86                 lea     eax, [ebp+var_C]
.text$mn:00002B89                 mov     large fs:0, eax
.text$mn:00002B8F                 mov     [ebp+var_10], ecx
.text$mn:00002B92                 mov     eax, [ebp+arg_4]
.text$mn:00002B95                 push    eax             ; struct std::_Container_base12 *
.text$mn:00002B96                 mov     ecx, [ebp+arg_0]
.text$mn:00002B99                 push    ecx             ; int
.text$mn:00002B9A                 mov     ecx, [ebp+var_10]
.text$mn:00002B9D                 call    ??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@1@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>(std::_List_node<std::pair<int const,Style>,void *> *,std::_List_val<std::_List_simple_types<std::pair<int const,Style>>> const *)
.text$mn:00002BA2                 mov     [ebp+var_4], 0
.text$mn:00002BA9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002BB0                 mov     eax, [ebp+var_10]
.text$mn:00002BB3                 mov     ecx, [ebp+var_C]
.text$mn:00002BB6                 mov     large fs:0, ecx
.text$mn:00002BBD                 pop     ecx
.text$mn:00002BBE                 mov     esp, ebp
.text$mn:00002BC0                 pop     ebp
.text$mn:00002BC1                 retn    8
.text$mn:00002BC1 ??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@1@@Z endp
.text$mn:00002BC1
.text$mn:00002BC1 _text$mn        ends
.text$mn:00002BC1
.text$x:00002BC4 ; ===========================================================================
.text$x:00002BC4
.text$x:00002BC4 ; Segment type: Pure code
.text$x:00002BC4 ; Segment permissions: Read/Execute
.text$x:00002BC4 _text$x         segment para public 'CODE' use32
.text$x:00002BC4                 assume cs:_text$x
.text$x:00002BC4                 ;org 2BC4h
.text$x:00002BC4 ; COMDAT (pick associative to section at 2B6C)
.text$x:00002BC4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00002BC4
.text$x:00002BC4 ; =============== S U B R O U T I N E =======================================
.text$x:00002BC4
.text$x:00002BC4
.text$x:00002BC4 __unwindfunclet$??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@1@@Z$0 proc near
.text$x:00002BC4                                         ; DATA XREF: .xdata$x:0000A86Co
.text$x:00002BC4                 mov     ecx, [ebp-10h]
.text$x:00002BC7                 jmp     ??1?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>::~_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>(void)
.text$x:00002BC7 __unwindfunclet$??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@1@@Z$0 endp
.text$x:00002BC7
.text$x:00002BCC
.text$x:00002BCC ; =============== S U B R O U T I N E =======================================
.text$x:00002BCC
.text$x:00002BCC
.text$x:00002BCC __ehhandler$??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@1@@Z proc near
.text$x:00002BCC                                         ; DATA XREF: std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>(std::_List_node<std::pair<int const,Style>,void *> *,std::_List_val<std::_List_simple_types<std::pair<int const,Style>>> const *)+5o
.text$x:00002BCC
.text$x:00002BCC arg_4           = dword ptr  8
.text$x:00002BCC
.text$x:00002BCC                 mov     edx, [esp+arg_4]
.text$x:00002BD0                 lea     eax, [edx+0Ch]
.text$x:00002BD3                 mov     ecx, [edx-8]
.text$x:00002BD6                 xor     ecx, eax
.text$x:00002BD8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002BDD                 mov     eax, offset __ehfuncinfo$??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@1@@Z
.text$x:00002BE2                 jmp     ___CxxFrameHandler3
.text$x:00002BE2 __ehhandler$??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@1@@Z endp
.text$x:00002BE2
.text$x:00002BE2 ; ---------------------------------------------------------------------------
.text$x:00002BE7                 align 4
.text$x:00002BE7 _text$x         ends
.text$x:00002BE7
.text$mn:00002BE8 ; ===========================================================================
.text$mn:00002BE8
.text$mn:00002BE8 ; Segment type: Pure code
.text$mn:00002BE8 ; Segment permissions: Read/Execute
.text$mn:00002BE8 _text$mn        segment para public 'CODE' use32
.text$mn:00002BE8                 assume cs:_text$mn
.text$mn:00002BE8                 ;org 2BE8h
.text$mn:00002BE8 ; COMDAT (pick any)
.text$mn:00002BE8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002BE8
.text$mn:00002BE8 ; =============== S U B R O U T I N E =======================================
.text$mn:00002BE8
.text$mn:00002BE8 ; Attributes: bp-based frame
.text$mn:00002BE8
.text$mn:00002BE8 ; int __stdcall std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>(int, struct std::_Container_base12 *)
.text$mn:00002BE8                 public ??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@1@@Z
.text$mn:00002BE8 ??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@1@@Z proc near
.text$mn:00002BE8                                         ; CODE XREF: std::list<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>::begin(void)+48p
.text$mn:00002BE8                                         ; std::list<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>::end(void)+3Dp
.text$mn:00002BE8
.text$mn:00002BE8 var_10          = dword ptr -10h
.text$mn:00002BE8 var_C           = dword ptr -0Ch
.text$mn:00002BE8 var_4           = dword ptr -4
.text$mn:00002BE8 arg_0           = dword ptr  8
.text$mn:00002BE8 arg_4           = dword ptr  0Ch
.text$mn:00002BE8
.text$mn:00002BE8                 push    ebp
.text$mn:00002BE9                 mov     ebp, esp
.text$mn:00002BEB                 push    0FFFFFFFFh
.text$mn:00002BED                 push    offset __ehhandler$??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@1@@Z
.text$mn:00002BF2                 mov     eax, large fs:0
.text$mn:00002BF8                 push    eax
.text$mn:00002BF9                 push    ecx
.text$mn:00002BFA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002BFF                 xor     eax, ebp
.text$mn:00002C01                 push    eax
.text$mn:00002C02                 lea     eax, [ebp+var_C]
.text$mn:00002C05                 mov     large fs:0, eax
.text$mn:00002C0B                 mov     [ebp+var_10], ecx
.text$mn:00002C0E                 mov     eax, [ebp+arg_4]
.text$mn:00002C11                 push    eax             ; struct std::_Container_base12 *
.text$mn:00002C12                 mov     ecx, [ebp+arg_0]
.text$mn:00002C15                 push    ecx             ; int
.text$mn:00002C16                 mov     ecx, [ebp+var_10]
.text$mn:00002C19                 call    ??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@1@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>(std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *,std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>> const *)
.text$mn:00002C1E                 mov     [ebp+var_4], 0
.text$mn:00002C25                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002C2C                 mov     eax, [ebp+var_10]
.text$mn:00002C2F                 mov     ecx, [ebp+var_C]
.text$mn:00002C32                 mov     large fs:0, ecx
.text$mn:00002C39                 pop     ecx
.text$mn:00002C3A                 mov     esp, ebp
.text$mn:00002C3C                 pop     ebp
.text$mn:00002C3D                 retn    8
.text$mn:00002C3D ??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@1@@Z endp
.text$mn:00002C3D
.text$mn:00002C3D _text$mn        ends
.text$mn:00002C3D
.text$x:00002C40 ; ===========================================================================
.text$x:00002C40
.text$x:00002C40 ; Segment type: Pure code
.text$x:00002C40 ; Segment permissions: Read/Execute
.text$x:00002C40 _text$x         segment para public 'CODE' use32
.text$x:00002C40                 assume cs:_text$x
.text$x:00002C40                 ;org 2C40h
.text$x:00002C40 ; COMDAT (pick associative to section at 2BE8)
.text$x:00002C40                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00002C40
.text$x:00002C40 ; =============== S U B R O U T I N E =======================================
.text$x:00002C40
.text$x:00002C40
.text$x:00002C40 __unwindfunclet$??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@1@@Z$0 proc near
.text$x:00002C40                                         ; DATA XREF: .xdata$x:0000A49Co
.text$x:00002C40                 mov     ecx, [ebp-10h]
.text$x:00002C43                 jmp     ??1?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::~_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>(void)
.text$x:00002C43 __unwindfunclet$??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@1@@Z$0 endp
.text$x:00002C43
.text$x:00002C48
.text$x:00002C48 ; =============== S U B R O U T I N E =======================================
.text$x:00002C48
.text$x:00002C48
.text$x:00002C48 __ehhandler$??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@1@@Z proc near
.text$x:00002C48                                         ; DATA XREF: std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>(std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *,std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>> const *)+5o
.text$x:00002C48
.text$x:00002C48 arg_4           = dword ptr  8
.text$x:00002C48
.text$x:00002C48                 mov     edx, [esp+arg_4]
.text$x:00002C4C                 lea     eax, [edx+0Ch]
.text$x:00002C4F                 mov     ecx, [edx-8]
.text$x:00002C52                 xor     ecx, eax
.text$x:00002C54                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002C59                 mov     eax, offset __ehfuncinfo$??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@1@@Z
.text$x:00002C5E                 jmp     ___CxxFrameHandler3
.text$x:00002C5E __ehhandler$??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@1@@Z endp
.text$x:00002C5E
.text$x:00002C5E ; ---------------------------------------------------------------------------
.text$x:00002C63                 align 4
.text$x:00002C63 _text$x         ends
.text$x:00002C63
.text$mn:00002C64 ; ===========================================================================
.text$mn:00002C64
.text$mn:00002C64 ; Segment type: Pure code
.text$mn:00002C64 ; Segment permissions: Read/Execute
.text$mn:00002C64 _text$mn        segment para public 'CODE' use32
.text$mn:00002C64                 assume cs:_text$mn
.text$mn:00002C64                 ;org 2C64h
.text$mn:00002C64 ; COMDAT (pick any)
.text$mn:00002C64                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002C64
.text$mn:00002C64 ; =============== S U B R O U T I N E =======================================
.text$mn:00002C64
.text$mn:00002C64 ; Attributes: bp-based frame
.text$mn:00002C64
.text$mn:00002C64 ; int __stdcall std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>,std::_Iterator_base12>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>,std::_Iterator_base12>(int, struct std::_Container_base12 *)
.text$mn:00002C64                 public ??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QAE@PAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@1@@Z
.text$mn:00002C64 ??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QAE@PAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@1@@Z proc near
.text$mn:00002C64                                         ; CODE XREF: std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>(std::_List_node<std::pair<int const,Style>,void *> *,std::_List_val<std::_List_simple_types<std::pair<int const,Style>>> const *)+31p
.text$mn:00002C64
.text$mn:00002C64 var_10          = dword ptr -10h
.text$mn:00002C64 var_C           = dword ptr -0Ch
.text$mn:00002C64 var_4           = dword ptr -4
.text$mn:00002C64 arg_0           = dword ptr  8
.text$mn:00002C64 arg_4           = dword ptr  0Ch
.text$mn:00002C64
.text$mn:00002C64                 push    ebp
.text$mn:00002C65                 mov     ebp, esp
.text$mn:00002C67                 push    0FFFFFFFFh
.text$mn:00002C69                 push    offset __ehhandler$??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QAE@PAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@1@@Z
.text$mn:00002C6E                 mov     eax, large fs:0
.text$mn:00002C74                 push    eax
.text$mn:00002C75                 push    ecx
.text$mn:00002C76                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002C7B                 xor     eax, ebp
.text$mn:00002C7D                 push    eax
.text$mn:00002C7E                 lea     eax, [ebp+var_C]
.text$mn:00002C81                 mov     large fs:0, eax
.text$mn:00002C87                 mov     [ebp+var_10], ecx
.text$mn:00002C8A                 mov     ecx, [ebp+var_10]
.text$mn:00002C8D                 call    ??0?$_Iterator012@Ubidirectional_iterator_tag@std@@U?$pair@$$CBHUStyle@@@2@HPBU32@ABU32@U_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::bidirectional_iterator_tag,std::pair<int const,Style>,int,std::pair<int const,Style> const *,std::pair<int const,Style> const &,std::_Iterator_base12>::_Iterator012<std::bidirectional_iterator_tag,std::pair<int const,Style>,int,std::pair<int const,Style> const *,std::pair<int const,Style> const &,std::_Iterator_base12>(void)
.text$mn:00002C92                 mov     [ebp+var_4], 0
.text$mn:00002C99                 mov     eax, [ebp+var_10]
.text$mn:00002C9C                 mov     ecx, [ebp+arg_0]
.text$mn:00002C9F                 mov     [eax+8], ecx
.text$mn:00002CA2                 mov     edx, [ebp+arg_4]
.text$mn:00002CA5                 push    edx             ; struct std::_Container_base12 *
.text$mn:00002CA6                 mov     ecx, [ebp+var_10] ; this
.text$mn:00002CA9                 call    ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt(std::_Container_base12 const *)
.text$mn:00002CAE                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002CB5                 mov     eax, [ebp+var_10]
.text$mn:00002CB8                 mov     ecx, [ebp+var_C]
.text$mn:00002CBB                 mov     large fs:0, ecx
.text$mn:00002CC2                 pop     ecx
.text$mn:00002CC3                 mov     esp, ebp
.text$mn:00002CC5                 pop     ebp
.text$mn:00002CC6                 retn    8
.text$mn:00002CC6 ??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QAE@PAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@1@@Z endp
.text$mn:00002CC6
.text$mn:00002CC6 ; ---------------------------------------------------------------------------
.text$mn:00002CC9                 align 4
.text$mn:00002CC9 _text$mn        ends
.text$mn:00002CC9
.text$x:00002CCC ; ===========================================================================
.text$x:00002CCC
.text$x:00002CCC ; Segment type: Pure code
.text$x:00002CCC ; Segment permissions: Read/Execute
.text$x:00002CCC _text$x         segment para public 'CODE' use32
.text$x:00002CCC                 assume cs:_text$x
.text$x:00002CCC                 ;org 2CCCh
.text$x:00002CCC ; COMDAT (pick associative to section at 2C64)
.text$x:00002CCC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00002CCC
.text$x:00002CCC ; =============== S U B R O U T I N E =======================================
.text$x:00002CCC
.text$x:00002CCC
.text$x:00002CCC __unwindfunclet$??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QAE@PAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@1@@Z$0 proc near
.text$x:00002CCC                                         ; DATA XREF: .xdata$x:0000A7BCo
.text$x:00002CCC                 mov     ecx, [ebp-10h]
.text$x:00002CCF                 jmp     ??1?$_Iterator012@Ubidirectional_iterator_tag@std@@U?$pair@$$CBHUStyle@@@2@HPBU32@ABU32@U_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::bidirectional_iterator_tag,std::pair<int const,Style>,int,std::pair<int const,Style> const *,std::pair<int const,Style> const &,std::_Iterator_base12>::~_Iterator012<std::bidirectional_iterator_tag,std::pair<int const,Style>,int,std::pair<int const,Style> const *,std::pair<int const,Style> const &,std::_Iterator_base12>(void)
.text$x:00002CCF __unwindfunclet$??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QAE@PAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@1@@Z$0 endp
.text$x:00002CCF
.text$x:00002CD4
.text$x:00002CD4 ; =============== S U B R O U T I N E =======================================
.text$x:00002CD4
.text$x:00002CD4
.text$x:00002CD4 __ehhandler$??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QAE@PAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@1@@Z proc near
.text$x:00002CD4                                         ; DATA XREF: std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>,std::_Iterator_base12>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>,std::_Iterator_base12>(std::_List_node<std::pair<int const,Style>,void *> *,std::_List_val<std::_List_simple_types<std::pair<int const,Style>>> const *)+5o
.text$x:00002CD4
.text$x:00002CD4 arg_4           = dword ptr  8
.text$x:00002CD4
.text$x:00002CD4                 mov     edx, [esp+arg_4]
.text$x:00002CD8                 lea     eax, [edx+0Ch]
.text$x:00002CDB                 mov     ecx, [edx-8]
.text$x:00002CDE                 xor     ecx, eax
.text$x:00002CE0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002CE5                 mov     eax, offset __ehfuncinfo$??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QAE@PAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@1@@Z
.text$x:00002CEA                 jmp     ___CxxFrameHandler3
.text$x:00002CEA __ehhandler$??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QAE@PAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@1@@Z endp
.text$x:00002CEA
.text$x:00002CEA ; ---------------------------------------------------------------------------
.text$x:00002CEF                 align 10h
.text$x:00002CEF _text$x         ends
.text$x:00002CEF
.text$mn:00002CF0 ; ===========================================================================
.text$mn:00002CF0
.text$mn:00002CF0 ; Segment type: Pure code
.text$mn:00002CF0 ; Segment permissions: Read/Execute
.text$mn:00002CF0 _text$mn        segment para public 'CODE' use32
.text$mn:00002CF0                 assume cs:_text$mn
.text$mn:00002CF0                 ;org 2CF0h
.text$mn:00002CF0 ; COMDAT (pick any)
.text$mn:00002CF0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002CF0
.text$mn:00002CF0 ; =============== S U B R O U T I N E =======================================
.text$mn:00002CF0
.text$mn:00002CF0 ; Attributes: bp-based frame
.text$mn:00002CF0
.text$mn:00002CF0 ; int __stdcall std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>,std::_Iterator_base0>(int, void *)
.text$mn:00002CF0                 public ??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@1@@Z
.text$mn:00002CF0 ??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@1@@Z proc near
.text$mn:00002CF0                                         ; CODE XREF: std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>(std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *,std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>> const *)+12p
.text$mn:00002CF0
.text$mn:00002CF0 var_4           = dword ptr -4
.text$mn:00002CF0 arg_0           = dword ptr  8
.text$mn:00002CF0 arg_4           = dword ptr  0Ch
.text$mn:00002CF0
.text$mn:00002CF0                 push    ebp
.text$mn:00002CF1                 mov     ebp, esp
.text$mn:00002CF3                 push    ecx
.text$mn:00002CF4                 mov     [ebp+var_4], ecx
.text$mn:00002CF7                 mov     eax, [ebp+var_4]
.text$mn:00002CFA                 mov     ecx, [ebp+arg_0]
.text$mn:00002CFD                 mov     [eax], ecx
.text$mn:00002CFF                 mov     edx, [ebp+arg_4]
.text$mn:00002D02                 push    edx             ; void *
.text$mn:00002D03                 mov     ecx, [ebp+var_4] ; this
.text$mn:00002D06                 call    ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ; std::_Iterator_base0::_Adopt(void const *)
.text$mn:00002D0B                 mov     eax, [ebp+var_4]
.text$mn:00002D0E                 mov     esp, ebp
.text$mn:00002D10                 pop     ebp
.text$mn:00002D11                 retn    8
.text$mn:00002D11 ??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@1@@Z endp
.text$mn:00002D11
.text$mn:00002D11 _text$mn        ends
.text$mn:00002D11
.text$mn:00002D14 ; ===========================================================================
.text$mn:00002D14
.text$mn:00002D14 ; Segment type: Pure code
.text$mn:00002D14 ; Segment permissions: Read/Execute
.text$mn:00002D14 _text$mn        segment para public 'CODE' use32
.text$mn:00002D14                 assume cs:_text$mn
.text$mn:00002D14                 ;org 2D14h
.text$mn:00002D14 ; COMDAT (pick any)
.text$mn:00002D14                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002D14
.text$mn:00002D14 ; =============== S U B R O U T I N E =======================================
.text$mn:00002D14
.text$mn:00002D14 ; Attributes: bp-based frame
.text$mn:00002D14
.text$mn:00002D14 ; int __stdcall std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>,std::_Iterator_base12>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>,std::_Iterator_base12>(int, struct std::_Container_base12 *)
.text$mn:00002D14                 public ??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QAE@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@1@@Z
.text$mn:00002D14 ??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QAE@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@1@@Z proc near
.text$mn:00002D14                                         ; CODE XREF: std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>(std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *,std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>> const *)+31p
.text$mn:00002D14
.text$mn:00002D14 var_10          = dword ptr -10h
.text$mn:00002D14 var_C           = dword ptr -0Ch
.text$mn:00002D14 var_4           = dword ptr -4
.text$mn:00002D14 arg_0           = dword ptr  8
.text$mn:00002D14 arg_4           = dword ptr  0Ch
.text$mn:00002D14
.text$mn:00002D14                 push    ebp
.text$mn:00002D15                 mov     ebp, esp
.text$mn:00002D17                 push    0FFFFFFFFh
.text$mn:00002D19                 push    offset __ehhandler$??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QAE@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@1@@Z
.text$mn:00002D1E                 mov     eax, large fs:0
.text$mn:00002D24                 push    eax
.text$mn:00002D25                 push    ecx
.text$mn:00002D26                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002D2B                 xor     eax, ebp
.text$mn:00002D2D                 push    eax
.text$mn:00002D2E                 lea     eax, [ebp+var_C]
.text$mn:00002D31                 mov     large fs:0, eax
.text$mn:00002D37                 mov     [ebp+var_10], ecx
.text$mn:00002D3A                 mov     ecx, [ebp+var_10]
.text$mn:00002D3D                 call    ??0?$_Iterator012@Ubidirectional_iterator_tag@std@@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@2@HPBU32@ABU32@U_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::bidirectional_iterator_tag,std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,int,std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *> const *,std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *> const &,std::_Iterator_base12>::_Iterator012<std::bidirectional_iterator_tag,std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,int,std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *> const *,std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *> const &,std::_Iterator_base12>(void)
.text$mn:00002D42                 mov     [ebp+var_4], 0
.text$mn:00002D49                 mov     eax, [ebp+var_10]
.text$mn:00002D4C                 mov     ecx, [ebp+arg_0]
.text$mn:00002D4F                 mov     [eax+8], ecx
.text$mn:00002D52                 mov     edx, [ebp+arg_4]
.text$mn:00002D55                 push    edx             ; struct std::_Container_base12 *
.text$mn:00002D56                 mov     ecx, [ebp+var_10] ; this
.text$mn:00002D59                 call    ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt(std::_Container_base12 const *)
.text$mn:00002D5E                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002D65                 mov     eax, [ebp+var_10]
.text$mn:00002D68                 mov     ecx, [ebp+var_C]
.text$mn:00002D6B                 mov     large fs:0, ecx
.text$mn:00002D72                 pop     ecx
.text$mn:00002D73                 mov     esp, ebp
.text$mn:00002D75                 pop     ebp
.text$mn:00002D76                 retn    8
.text$mn:00002D76 ??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QAE@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@1@@Z endp
.text$mn:00002D76
.text$mn:00002D76 ; ---------------------------------------------------------------------------
.text$mn:00002D79                 align 4
.text$mn:00002D79 _text$mn        ends
.text$mn:00002D79
.text$x:00002D7C ; ===========================================================================
.text$x:00002D7C
.text$x:00002D7C ; Segment type: Pure code
.text$x:00002D7C ; Segment permissions: Read/Execute
.text$x:00002D7C _text$x         segment para public 'CODE' use32
.text$x:00002D7C                 assume cs:_text$x
.text$x:00002D7C                 ;org 2D7Ch
.text$x:00002D7C ; COMDAT (pick associative to section at 2D14)
.text$x:00002D7C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00002D7C
.text$x:00002D7C ; =============== S U B R O U T I N E =======================================
.text$x:00002D7C
.text$x:00002D7C
.text$x:00002D7C __unwindfunclet$??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QAE@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@1@@Z$0 proc near
.text$x:00002D7C                                         ; DATA XREF: .xdata$x:0000A3ECo
.text$x:00002D7C                 mov     ecx, [ebp-10h]
.text$x:00002D7F                 jmp     ??1?$_Iterator012@Ubidirectional_iterator_tag@std@@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@2@HPBU32@ABU32@U_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::bidirectional_iterator_tag,std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,int,std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *> const *,std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *> const &,std::_Iterator_base12>::~_Iterator012<std::bidirectional_iterator_tag,std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,int,std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *> const *,std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *> const &,std::_Iterator_base12>(void)
.text$x:00002D7F __unwindfunclet$??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QAE@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@1@@Z$0 endp
.text$x:00002D7F
.text$x:00002D84
.text$x:00002D84 ; =============== S U B R O U T I N E =======================================
.text$x:00002D84
.text$x:00002D84
.text$x:00002D84 __ehhandler$??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QAE@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@1@@Z proc near
.text$x:00002D84                                         ; DATA XREF: std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>,std::_Iterator_base12>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>,std::_Iterator_base12>(std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *,std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>> const *)+5o
.text$x:00002D84
.text$x:00002D84 arg_4           = dword ptr  8
.text$x:00002D84
.text$x:00002D84                 mov     edx, [esp+arg_4]
.text$x:00002D88                 lea     eax, [edx+0Ch]
.text$x:00002D8B                 mov     ecx, [edx-8]
.text$x:00002D8E                 xor     ecx, eax
.text$x:00002D90                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002D95                 mov     eax, offset __ehfuncinfo$??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QAE@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@1@@Z
.text$x:00002D9A                 jmp     ___CxxFrameHandler3
.text$x:00002D9A __ehhandler$??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QAE@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@1@@Z endp
.text$x:00002D9A
.text$x:00002D9A ; ---------------------------------------------------------------------------
.text$x:00002D9F                 align 10h
.text$x:00002D9F _text$x         ends
.text$x:00002D9F
.text$mn:00002DA0 ; ===========================================================================
.text$mn:00002DA0
.text$mn:00002DA0 ; Segment type: Pure code
.text$mn:00002DA0 ; Segment permissions: Read/Execute
.text$mn:00002DA0 _text$mn        segment para public 'CODE' use32
.text$mn:00002DA0                 assume cs:_text$mn
.text$mn:00002DA0                 ;org 2DA0h
.text$mn:00002DA0 ; COMDAT (pick any)
.text$mn:00002DA0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002DA0
.text$mn:00002DA0 ; =============== S U B R O U T I N E =======================================
.text$mn:00002DA0
.text$mn:00002DA0 ; Attributes: bp-based frame
.text$mn:00002DA0
.text$mn:00002DA0 ; int __stdcall std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>(int, void *)
.text$mn:00002DA0                 public ??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@1@@Z
.text$mn:00002DA0 ??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@1@@Z proc near
.text$mn:00002DA0                                         ; CODE XREF: std::list<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>::_Unchecked_end(void)+15p
.text$mn:00002DA0
.text$mn:00002DA0 var_4           = dword ptr -4
.text$mn:00002DA0 arg_0           = dword ptr  8
.text$mn:00002DA0 arg_4           = dword ptr  0Ch
.text$mn:00002DA0
.text$mn:00002DA0                 push    ebp
.text$mn:00002DA1                 mov     ebp, esp
.text$mn:00002DA3                 push    ecx
.text$mn:00002DA4                 mov     [ebp+var_4], ecx
.text$mn:00002DA7                 mov     eax, [ebp+arg_4]
.text$mn:00002DAA                 push    eax             ; void *
.text$mn:00002DAB                 mov     ecx, [ebp+arg_0]
.text$mn:00002DAE                 push    ecx             ; int
.text$mn:00002DAF                 mov     ecx, [ebp+var_4]
.text$mn:00002DB2                 call    ??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@1@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>,std::_Iterator_base0>(std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *,std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>> const *)
.text$mn:00002DB7                 mov     eax, [ebp+var_4]
.text$mn:00002DBA                 mov     esp, ebp
.text$mn:00002DBC                 pop     ebp
.text$mn:00002DBD                 retn    8
.text$mn:00002DBD ??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@1@@Z endp
.text$mn:00002DBD
.text$mn:00002DBD _text$mn        ends
.text$mn:00002DBD
.text$mn:00002DC0 ; ===========================================================================
.text$mn:00002DC0
.text$mn:00002DC0 ; Segment type: Pure code
.text$mn:00002DC0 ; Segment permissions: Read/Execute
.text$mn:00002DC0 _text$mn        segment para public 'CODE' use32
.text$mn:00002DC0                 assume cs:_text$mn
.text$mn:00002DC0                 ;org 2DC0h
.text$mn:00002DC0 ; COMDAT (pick any)
.text$mn:00002DC0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002DC0
.text$mn:00002DC0 ; =============== S U B R O U T I N E =======================================
.text$mn:00002DC0
.text$mn:00002DC0 ; Attributes: bp-based frame
.text$mn:00002DC0
.text$mn:00002DC0 ; public: __thiscall std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>(void)
.text$mn:00002DC0                 public ??0?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@QAE@XZ
.text$mn:00002DC0 ??0?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00002DC0                                         ; CODE XREF: std::_List_alloc<0,std::_List_base_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::_List_alloc<0,std::_List_base_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>(std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>> const &)+30p
.text$mn:00002DC0
.text$mn:00002DC0 var_10          = dword ptr -10h
.text$mn:00002DC0 var_C           = dword ptr -0Ch
.text$mn:00002DC0 var_4           = dword ptr -4
.text$mn:00002DC0
.text$mn:00002DC0                 push    ebp
.text$mn:00002DC1                 mov     ebp, esp
.text$mn:00002DC3                 push    0FFFFFFFFh
.text$mn:00002DC5                 push    offset __ehhandler$??0?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@QAE@XZ
.text$mn:00002DCA                 mov     eax, large fs:0
.text$mn:00002DD0                 push    eax
.text$mn:00002DD1                 push    ecx
.text$mn:00002DD2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002DD7                 xor     eax, ebp
.text$mn:00002DD9                 push    eax
.text$mn:00002DDA                 lea     eax, [ebp+var_C]
.text$mn:00002DDD                 mov     large fs:0, eax
.text$mn:00002DE3                 mov     [ebp+var_10], ecx
.text$mn:00002DE6                 mov     ecx, [ebp+var_10] ; this
.text$mn:00002DE9                 call    ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
.text$mn:00002DEE                 mov     [ebp+var_4], 0
.text$mn:00002DF5                 mov     eax, [ebp+var_10]
.text$mn:00002DF8                 mov     dword ptr [eax+4], 0
.text$mn:00002DFF                 mov     ecx, [ebp+var_10]
.text$mn:00002E02                 mov     dword ptr [ecx+8], 0
.text$mn:00002E09                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002E10                 mov     eax, [ebp+var_10]
.text$mn:00002E13                 mov     ecx, [ebp+var_C]
.text$mn:00002E16                 mov     large fs:0, ecx
.text$mn:00002E1D                 pop     ecx
.text$mn:00002E1E                 mov     esp, ebp
.text$mn:00002E20                 pop     ebp
.text$mn:00002E21                 retn
.text$mn:00002E21 ??0?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@QAE@XZ endp
.text$mn:00002E21
.text$mn:00002E21 ; ---------------------------------------------------------------------------
.text$mn:00002E22                 align 4
.text$mn:00002E22 _text$mn        ends
.text$mn:00002E22
.text$x:00002E24 ; ===========================================================================
.text$x:00002E24
.text$x:00002E24 ; Segment type: Pure code
.text$x:00002E24 ; Segment permissions: Read/Execute
.text$x:00002E24 _text$x         segment para public 'CODE' use32
.text$x:00002E24                 assume cs:_text$x
.text$x:00002E24                 ;org 2E24h
.text$x:00002E24 ; COMDAT (pick associative to section at 2DC0)
.text$x:00002E24                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00002E24
.text$x:00002E24 ; =============== S U B R O U T I N E =======================================
.text$x:00002E24
.text$x:00002E24
.text$x:00002E24 __unwindfunclet$??0?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00002E24                                         ; DATA XREF: .xdata$x:00009D98o
.text$x:00002E24                 mov     ecx, [ebp-10h]  ; this
.text$x:00002E27                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00002E27 __unwindfunclet$??0?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:00002E27
.text$x:00002E2C
.text$x:00002E2C ; =============== S U B R O U T I N E =======================================
.text$x:00002E2C
.text$x:00002E2C
.text$x:00002E2C __ehhandler$??0?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@QAE@XZ proc near
.text$x:00002E2C                                         ; DATA XREF: std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>(void)+5o
.text$x:00002E2C
.text$x:00002E2C arg_4           = dword ptr  8
.text$x:00002E2C
.text$x:00002E2C                 mov     edx, [esp+arg_4]
.text$x:00002E30                 lea     eax, [edx+0Ch]
.text$x:00002E33                 mov     ecx, [edx-8]
.text$x:00002E36                 xor     ecx, eax
.text$x:00002E38                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002E3D                 mov     eax, offset __ehfuncinfo$??0?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@QAE@XZ
.text$x:00002E42                 jmp     ___CxxFrameHandler3
.text$x:00002E42 __ehhandler$??0?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@QAE@XZ endp
.text$x:00002E42
.text$x:00002E42 ; ---------------------------------------------------------------------------
.text$x:00002E47                 align 4
.text$x:00002E47 _text$x         ends
.text$x:00002E47
.text$mn:00002E48 ; ===========================================================================
.text$mn:00002E48
.text$mn:00002E48 ; Segment type: Pure code
.text$mn:00002E48 ; Segment permissions: Read/Execute
.text$mn:00002E48 _text$mn        segment para public 'CODE' use32
.text$mn:00002E48                 assume cs:_text$mn
.text$mn:00002E48                 ;org 2E48h
.text$mn:00002E48 ; COMDAT (pick any)
.text$mn:00002E48                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002E48
.text$mn:00002E48 ; =============== S U B R O U T I N E =======================================
.text$mn:00002E48
.text$mn:00002E48 ; Attributes: bp-based frame
.text$mn:00002E48
.text$mn:00002E48 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>(class std::allocator<char> const &)
.text$mn:00002E48                 public ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$mn:00002E48 ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
.text$mn:00002E48                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+34p
.text$mn:00002E48
.text$mn:00002E48 var_10          = dword ptr -10h
.text$mn:00002E48 var_C           = dword ptr -0Ch
.text$mn:00002E48 var_4           = dword ptr -4
.text$mn:00002E48
.text$mn:00002E48                 push    ebp
.text$mn:00002E49                 mov     ebp, esp
.text$mn:00002E4B                 push    0FFFFFFFFh
.text$mn:00002E4D                 push    offset __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$mn:00002E52                 mov     eax, large fs:0
.text$mn:00002E58                 push    eax
.text$mn:00002E59                 push    ecx
.text$mn:00002E5A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002E5F                 xor     eax, ebp
.text$mn:00002E61                 push    eax
.text$mn:00002E62                 lea     eax, [ebp+var_C]
.text$mn:00002E65                 mov     large fs:0, eax
.text$mn:00002E6B                 mov     [ebp+var_10], ecx
.text$mn:00002E6E                 mov     ecx, [ebp+var_10]
.text$mn:00002E71                 call    ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)
.text$mn:00002E76                 mov     [ebp+var_4], 0
.text$mn:00002E7D                 mov     ecx, [ebp+var_10]
.text$mn:00002E80                 call    ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)
.text$mn:00002E85                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002E8C                 mov     eax, [ebp+var_10]
.text$mn:00002E8F                 mov     ecx, [ebp+var_C]
.text$mn:00002E92                 mov     large fs:0, ecx
.text$mn:00002E99                 pop     ecx
.text$mn:00002E9A                 mov     esp, ebp
.text$mn:00002E9C                 pop     ebp
.text$mn:00002E9D                 retn    4
.text$mn:00002E9D ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp
.text$mn:00002E9D
.text$mn:00002E9D _text$mn        ends
.text$mn:00002E9D
.text$x:00002EA0 ; ===========================================================================
.text$x:00002EA0
.text$x:00002EA0 ; Segment type: Pure code
.text$x:00002EA0 ; Segment permissions: Read/Execute
.text$x:00002EA0 _text$x         segment para public 'CODE' use32
.text$x:00002EA0                 assume cs:_text$x
.text$x:00002EA0                 ;org 2EA0h
.text$x:00002EA0 ; COMDAT (pick associative to section at 2E48)
.text$x:00002EA0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00002EA0
.text$x:00002EA0 ; =============== S U B R O U T I N E =======================================
.text$x:00002EA0
.text$x:00002EA0
.text$x:00002EA0 __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 proc near
.text$x:00002EA0                                         ; DATA XREF: .xdata$x:00009834o
.text$x:00002EA0                 mov     ecx, [ebp-10h]
.text$x:00002EA3                 jmp     ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$x:00002EA3 __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 endp
.text$x:00002EA3
.text$x:00002EA8
.text$x:00002EA8 ; =============== S U B R O U T I N E =======================================
.text$x:00002EA8
.text$x:00002EA8
.text$x:00002EA8 __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
.text$x:00002EA8                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+5o
.text$x:00002EA8
.text$x:00002EA8 arg_4           = dword ptr  8
.text$x:00002EA8
.text$x:00002EA8                 mov     edx, [esp+arg_4]
.text$x:00002EAC                 lea     eax, [edx+0Ch]
.text$x:00002EAF                 mov     ecx, [edx-8]
.text$x:00002EB2                 xor     ecx, eax
.text$x:00002EB4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002EB9                 mov     eax, offset __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$x:00002EBE                 jmp     ___CxxFrameHandler3
.text$x:00002EBE __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp
.text$x:00002EBE
.text$x:00002EBE ; ---------------------------------------------------------------------------
.text$x:00002EC3                 align 4
.text$x:00002EC3 _text$x         ends
.text$x:00002EC3
.text$mn:00002EC4 ; ===========================================================================
.text$mn:00002EC4
.text$mn:00002EC4 ; Segment type: Pure code
.text$mn:00002EC4 ; Segment permissions: Read/Execute
.text$mn:00002EC4 _text$mn        segment para public 'CODE' use32
.text$mn:00002EC4                 assume cs:_text$mn
.text$mn:00002EC4                 ;org 2EC4h
.text$mn:00002EC4 ; COMDAT (pick any)
.text$mn:00002EC4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002EC4
.text$mn:00002EC4 ; =============== S U B R O U T I N E =======================================
.text$mn:00002EC4
.text$mn:00002EC4 ; Attributes: bp-based frame
.text$mn:00002EC4
.text$mn:00002EC4 ; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::_String_val<struct std::_Simple_types<char>>(void)
.text$mn:00002EC4                 public ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00002EC4 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$mn:00002EC4                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+29p
.text$mn:00002EC4
.text$mn:00002EC4 var_10          = dword ptr -10h
.text$mn:00002EC4 var_C           = dword ptr -0Ch
.text$mn:00002EC4 var_4           = dword ptr -4
.text$mn:00002EC4
.text$mn:00002EC4                 push    ebp
.text$mn:00002EC5                 mov     ebp, esp
.text$mn:00002EC7                 push    0FFFFFFFFh
.text$mn:00002EC9                 push    offset __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00002ECE                 mov     eax, large fs:0
.text$mn:00002ED4                 push    eax
.text$mn:00002ED5                 push    ecx
.text$mn:00002ED6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002EDB                 xor     eax, ebp
.text$mn:00002EDD                 push    eax
.text$mn:00002EDE                 lea     eax, [ebp+var_C]
.text$mn:00002EE1                 mov     large fs:0, eax
.text$mn:00002EE7                 mov     [ebp+var_10], ecx
.text$mn:00002EEA                 mov     ecx, [ebp+var_10] ; this
.text$mn:00002EED                 call    ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
.text$mn:00002EF2                 mov     [ebp+var_4], 0
.text$mn:00002EF9                 mov     eax, [ebp+var_10]
.text$mn:00002EFC                 mov     dword ptr [eax+14h], 0
.text$mn:00002F03                 mov     ecx, [ebp+var_10]
.text$mn:00002F06                 mov     dword ptr [ecx+18h], 0
.text$mn:00002F0D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002F14                 mov     eax, [ebp+var_10]
.text$mn:00002F17                 mov     ecx, [ebp+var_C]
.text$mn:00002F1A                 mov     large fs:0, ecx
.text$mn:00002F21                 pop     ecx
.text$mn:00002F22                 mov     esp, ebp
.text$mn:00002F24                 pop     ebp
.text$mn:00002F25                 retn
.text$mn:00002F25 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$mn:00002F25
.text$mn:00002F25 ; ---------------------------------------------------------------------------
.text$mn:00002F26                 align 4
.text$mn:00002F26 _text$mn        ends
.text$mn:00002F26
.text$x:00002F28 ; ===========================================================================
.text$x:00002F28
.text$x:00002F28 ; Segment type: Pure code
.text$x:00002F28 ; Segment permissions: Read/Execute
.text$x:00002F28 _text$x         segment para public 'CODE' use32
.text$x:00002F28                 assume cs:_text$x
.text$x:00002F28                 ;org 2F28h
.text$x:00002F28 ; COMDAT (pick associative to section at 2EC4)
.text$x:00002F28                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00002F28
.text$x:00002F28 ; =============== S U B R O U T I N E =======================================
.text$x:00002F28
.text$x:00002F28
.text$x:00002F28 __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 proc near
.text$x:00002F28                                         ; DATA XREF: .xdata$x:000097DCo
.text$x:00002F28                 mov     ecx, [ebp-10h]  ; this
.text$x:00002F2B                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00002F2B __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 endp
.text$x:00002F2B
.text$x:00002F30
.text$x:00002F30 ; =============== S U B R O U T I N E =======================================
.text$x:00002F30
.text$x:00002F30
.text$x:00002F30 __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$x:00002F30                                         ; DATA XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+5o
.text$x:00002F30
.text$x:00002F30 arg_4           = dword ptr  8
.text$x:00002F30
.text$x:00002F30                 mov     edx, [esp+arg_4]
.text$x:00002F34                 lea     eax, [edx+0Ch]
.text$x:00002F37                 mov     ecx, [edx-8]
.text$x:00002F3A                 xor     ecx, eax
.text$x:00002F3C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002F41                 mov     eax, offset __ehfuncinfo$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$x:00002F46                 jmp     ___CxxFrameHandler3
.text$x:00002F46 __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$x:00002F46
.text$x:00002F46 ; ---------------------------------------------------------------------------
.text$x:00002F4B                 align 4
.text$x:00002F4B _text$x         ends
.text$x:00002F4B
.text$mn:00002F4C ; ===========================================================================
.text$mn:00002F4C
.text$mn:00002F4C ; Segment type: Pure code
.text$mn:00002F4C ; Segment permissions: Read/Execute
.text$mn:00002F4C _text$mn        segment para public 'CODE' use32
.text$mn:00002F4C                 assume cs:_text$mn
.text$mn:00002F4C                 ;org 2F4Ch
.text$mn:00002F4C ; COMDAT (pick any)
.text$mn:00002F4C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002F4C
.text$mn:00002F4C ; =============== S U B R O U T I N E =======================================
.text$mn:00002F4C
.text$mn:00002F4C ; Attributes: bp-based frame
.text$mn:00002F4C
.text$mn:00002F4C ; public: __thiscall std::_Uhash_compare<class Buffer *, struct std::hash<class Buffer *>, struct std::equal_to<class Buffer *>>::_Uhash_compare<class Buffer *, struct std::hash<class Buffer *>, struct std::equal_to<class Buffer *>>(struct std::hash<class Buffer *>, struct std::equal_to<class Buffer *>)
.text$mn:00002F4C                 public ??0?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@std@@QAE@U?$hash@PAVBuffer@@@1@U?$equal_to@PAVBuffer@@@1@@Z
.text$mn:00002F4C ??0?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@std@@QAE@U?$hash@PAVBuffer@@@1@U?$equal_to@PAVBuffer@@@1@@Z proc near
.text$mn:00002F4C                                         ; CODE XREF: std::unordered_map<Buffer *,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *,std::hash<Buffer *>,std::equal_to<Buffer *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>::unordered_map<Buffer *,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *,std::hash<Buffer *>,std::equal_to<Buffer *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>(void)+3Ep
.text$mn:00002F4C
.text$mn:00002F4C var_4           = dword ptr -4
.text$mn:00002F4C arg_0           = byte ptr  8
.text$mn:00002F4C arg_4           = byte ptr  0Ch
.text$mn:00002F4C
.text$mn:00002F4C                 push    ebp
.text$mn:00002F4D                 mov     ebp, esp
.text$mn:00002F4F                 push    ecx
.text$mn:00002F50                 mov     [ebp+var_4], ecx
.text$mn:00002F53                 movzx   eax, [ebp+arg_4]
.text$mn:00002F57                 push    eax
.text$mn:00002F58                 movzx   ecx, [ebp+arg_0]
.text$mn:00002F5C                 push    ecx
.text$mn:00002F5D                 mov     ecx, [ebp+var_4]
.text$mn:00002F60                 call    ??0?$_Hash_oper2@$0A@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@2@@std@@QAE@U?$hash@PAVBuffer@@@1@U?$equal_to@PAVBuffer@@@1@@Z ; std::_Hash_oper2<0,std::hash<Buffer *>,std::equal_to<Buffer *>>::_Hash_oper2<0,std::hash<Buffer *>,std::equal_to<Buffer *>>(std::hash<Buffer *>,std::equal_to<Buffer *>)
.text$mn:00002F65                 mov     eax, [ebp+var_4]
.text$mn:00002F68                 mov     esp, ebp
.text$mn:00002F6A                 pop     ebp
.text$mn:00002F6B                 retn    8
.text$mn:00002F6B ??0?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@std@@QAE@U?$hash@PAVBuffer@@@1@U?$equal_to@PAVBuffer@@@1@@Z endp
.text$mn:00002F6B
.text$mn:00002F6B ; ---------------------------------------------------------------------------
.text$mn:00002F6E                 align 10h
.text$mn:00002F6E _text$mn        ends
.text$mn:00002F6E
.text$mn:00002F70 ; ===========================================================================
.text$mn:00002F70
.text$mn:00002F70 ; Segment type: Pure code
.text$mn:00002F70 ; Segment permissions: Read/Execute
.text$mn:00002F70 _text$mn        segment para public 'CODE' use32
.text$mn:00002F70                 assume cs:_text$mn
.text$mn:00002F70                 ;org 2F70h
.text$mn:00002F70 ; COMDAT (pick any)
.text$mn:00002F70                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002F70
.text$mn:00002F70 ; =============== S U B R O U T I N E =======================================
.text$mn:00002F70
.text$mn:00002F70 ; Attributes: bp-based frame
.text$mn:00002F70
.text$mn:00002F70 ; public: __thiscall std::_Umap_traits<class Buffer *, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *, class std::_Uhash_compare<class Buffer *, struct std::hash<class Buffer *>, struct std::equal_to<class Buffer *>>, class std::allocator<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>, 0>::_Umap_traits<class Buffer *, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *, class std::_Uhash_compare<class Buffer *, struct std::hash<class Buffer *>, struct std::equal_to<class Buffer *>>, class std::allocator<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, c
.text$mn:00002F70                 public ??0?$_Umap_traits@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@V?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@$0A@@std@@QAE@ABV?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@1@@Z
.text$mn:00002F70 ??0?$_Umap_traits@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@V?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@$0A@@std@@QAE@ABV?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@1@@Z proc near
.text$mn:00002F70                                         ; CODE XREF: std::_Hash<std::_Umap_traits<Buffer *,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *,std::_Uhash_compare<Buffer *,std::hash<Buffer *>,std::equal_to<Buffer *>>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>,0>>::_Hash<std::_Umap_traits<Buffer *,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *,std::_Uhash_compare<Buffer *,std::hash<Buffer *>,std::equal_to<Buffer *>>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>,0>>(std::_Uhash_compare<Buffer *,std::hash<Buffer *>,std::equal_to<Buffer *>> const &,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>> const &)+2Fp
.text$mn:00002F70
.text$mn:00002F70 var_4           = dword ptr -4
.text$mn:00002F70
.text$mn:00002F70                 push    ebp
.text$mn:00002F71                 mov     ebp, esp
.text$mn:00002F73                 push    ecx
.text$mn:00002F74                 mov     [ebp+var_4], ecx
.text$mn:00002F77                 mov     eax, [ebp+var_4]
.text$mn:00002F7A                 mov     esp, ebp
.text$mn:00002F7C                 pop     ebp
.text$mn:00002F7D                 retn    4
.text$mn:00002F7D ??0?$_Umap_traits@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@V?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@$0A@@std@@QAE@ABV?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@1@@Z endp
.text$mn:00002F7D
.text$mn:00002F7D _text$mn        ends
.text$mn:00002F7D
.text$mn:00002F80 ; ===========================================================================
.text$mn:00002F80
.text$mn:00002F80 ; Segment type: Pure code
.text$mn:00002F80 ; Segment permissions: Read/Execute
.text$mn:00002F80 _text$mn        segment para public 'CODE' use32
.text$mn:00002F80                 assume cs:_text$mn
.text$mn:00002F80                 ;org 2F80h
.text$mn:00002F80 ; COMDAT (pick any)
.text$mn:00002F80                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002F80
.text$mn:00002F80 ; =============== S U B R O U T I N E =======================================
.text$mn:00002F80
.text$mn:00002F80 ; Attributes: bp-based frame
.text$mn:00002F80
.text$mn:00002F80                 public ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QAE@ABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@1@@Z
.text$mn:00002F80 ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QAE@ABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@1@@Z proc near
.text$mn:00002F80                                         ; CODE XREF: std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>(std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_
.text$mn:00002F80
.text$mn:00002F80 var_10          = dword ptr -10h
.text$mn:00002F80 var_C           = dword ptr -0Ch
.text$mn:00002F80 var_4           = dword ptr -4
.text$mn:00002F80
.text$mn:00002F80                 push    ebp
.text$mn:00002F81                 mov     ebp, esp
.text$mn:00002F83                 push    0FFFFFFFFh
.text$mn:00002F85                 push    offset __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QAE@ABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@1@@Z
.text$mn:00002F8A                 mov     eax, large fs:0
.text$mn:00002F90                 push    eax
.text$mn:00002F91                 push    ecx
.text$mn:00002F92                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002F97                 xor     eax, ebp
.text$mn:00002F99                 push    eax
.text$mn:00002F9A                 lea     eax, [ebp+var_C]
.text$mn:00002F9D                 mov     large fs:0, eax
.text$mn:00002FA3                 mov     [ebp+var_10], ecx
.text$mn:00002FA6                 mov     ecx, [ebp+var_10]
.text$mn:00002FA9                 call    ??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>(void)
.text$mn:00002FAE                 mov     [ebp+var_4], 0
.text$mn:00002FB5                 mov     ecx, [ebp+var_10]
.text$mn:00002FB8                 call    ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QAEXXZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>>::_Alloc_proxy(void)
.text$mn:00002FBD                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002FC4                 mov     eax, [ebp+var_10]
.text$mn:00002FC7                 mov     ecx, [ebp+var_C]
.text$mn:00002FCA                 mov     large fs:0, ecx
.text$mn:00002FD1                 pop     ecx
.text$mn:00002FD2                 mov     esp, ebp
.text$mn:00002FD4                 pop     ebp
.text$mn:00002FD5                 retn    4
.text$mn:00002FD5 ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QAE@ABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@1@@Z endp
.text$mn:00002FD5
.text$mn:00002FD5 _text$mn        ends
.text$mn:00002FD5
.text$x:00002FD8 ; ===========================================================================
.text$x:00002FD8
.text$x:00002FD8 ; Segment type: Pure code
.text$x:00002FD8 ; Segment permissions: Read/Execute
.text$x:00002FD8 _text$x         segment para public 'CODE' use32
.text$x:00002FD8                 assume cs:_text$x
.text$x:00002FD8                 ;org 2FD8h
.text$x:00002FD8 ; COMDAT (pick associative to section at 2F80)
.text$x:00002FD8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00002FD8
.text$x:00002FD8 ; =============== S U B R O U T I N E =======================================
.text$x:00002FD8
.text$x:00002FD8
.text$x:00002FD8 __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QAE@ABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@1@@Z$0 proc near
.text$x:00002FD8                                         ; DATA XREF: .xdata$x:0000A120o
.text$x:00002FD8                 mov     ecx, [ebp-10h]
.text$x:00002FDB                 jmp     ??1?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>::~_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>(void)
.text$x:00002FDB __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QAE@ABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@1@@Z$0 endp
.text$x:00002FDB
.text$x:00002FE0
.text$x:00002FE0 ; =============== S U B R O U T I N E =======================================
.text$x:00002FE0
.text$x:00002FE0
.text$x:00002FE0 __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QAE@ABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@1@@Z proc near
.text$x:00002FE0                                         ; DATA XREF: std::_Vector_alloc<0,std::_Vec_base_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>>::_Vector_alloc<0,std::_Vec_base_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>>(std::_Wrap_alloc<std:
.text$x:00002FE0
.text$x:00002FE0 arg_4           = dword ptr  8
.text$x:00002FE0
.text$x:00002FE0                 mov     edx, [esp+arg_4]
.text$x:00002FE4                 lea     eax, [edx+0Ch]
.text$x:00002FE7                 mov     ecx, [edx-8]
.text$x:00002FEA                 xor     ecx, eax
.text$x:00002FEC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002FF1                 mov     eax, offset __ehfuncinfo$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QAE@ABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@1@@Z
.text$x:00002FF6                 jmp     ___CxxFrameHandler3
.text$x:00002FF6 __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QAE@ABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@1@@Z endp
.text$x:00002FF6
.text$x:00002FF6 ; ---------------------------------------------------------------------------
.text$x:00002FFB                 align 4
.text$x:00002FFB _text$x         ends
.text$x:00002FFB
.text$mn:00002FFC ; ===========================================================================
.text$mn:00002FFC
.text$mn:00002FFC ; Segment type: Pure code
.text$mn:00002FFC ; Segment permissions: Read/Execute
.text$mn:00002FFC _text$mn        segment para public 'CODE' use32
.text$mn:00002FFC                 assume cs:_text$mn
.text$mn:00002FFC                 ;org 2FFCh
.text$mn:00002FFC ; COMDAT (pick any)
.text$mn:00002FFC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002FFC
.text$mn:00002FFC ; =============== S U B R O U T I N E =======================================
.text$mn:00002FFC
.text$mn:00002FFC ; Attributes: bp-based frame
.text$mn:00002FFC
.text$mn:00002FFC ; int __stdcall std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>(struct std::_Iterator_base12 *)
.text$mn:00002FFC                 public ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@ABV01@@Z
.text$mn:00002FFC ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@ABV01@@Z proc near
.text$mn:00002FFC                                         ; CODE XREF: ScintillaCtrls::destroyScintilla(HWND__ *)+DDp
.text$mn:00002FFC                                         ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>> const &)+2Dp ...
.text$mn:00002FFC
.text$mn:00002FFC var_10          = dword ptr -10h
.text$mn:00002FFC var_C           = dword ptr -0Ch
.text$mn:00002FFC var_4           = dword ptr -4
.text$mn:00002FFC arg_0           = dword ptr  8
.text$mn:00002FFC
.text$mn:00002FFC                 push    ebp
.text$mn:00002FFD                 mov     ebp, esp
.text$mn:00002FFF                 push    0FFFFFFFFh
.text$mn:00003001                 push    offset __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@ABV01@@Z
.text$mn:00003006                 mov     eax, large fs:0
.text$mn:0000300C                 push    eax
.text$mn:0000300D                 push    ecx
.text$mn:0000300E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003013                 xor     eax, ebp
.text$mn:00003015                 push    eax
.text$mn:00003016                 lea     eax, [ebp+var_C]
.text$mn:00003019                 mov     large fs:0, eax
.text$mn:0000301F                 mov     [ebp+var_10], ecx
.text$mn:00003022                 mov     eax, [ebp+arg_0]
.text$mn:00003025                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00003026                 mov     ecx, [ebp+var_10]
.text$mn:00003029                 call    ??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVScintillaEditView@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z ; std::_Iterator012<std::random_access_iterator_tag,ScintillaEditView *,int,ScintillaEditView * const *,ScintillaEditView * const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,ScintillaEditView *,int,ScintillaEditView * const *,ScintillaEditView * const &,std::_Iterator_base12>(std::_Iterator012<std::random_access_iterator_tag,ScintillaEditView *,int,ScintillaEditView * const *,ScintillaEditView * const &,std::_Iterator_base12> const &)
.text$mn:0000302E                 mov     [ebp+var_4], 0
.text$mn:00003035                 mov     ecx, [ebp+var_10]
.text$mn:00003038                 mov     edx, [ebp+arg_0]
.text$mn:0000303B                 mov     eax, [edx+8]
.text$mn:0000303E                 mov     [ecx+8], eax
.text$mn:00003041                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003048                 mov     eax, [ebp+var_10]
.text$mn:0000304B                 mov     ecx, [ebp+var_C]
.text$mn:0000304E                 mov     large fs:0, ecx
.text$mn:00003055                 pop     ecx
.text$mn:00003056                 mov     esp, ebp
.text$mn:00003058                 pop     ebp
.text$mn:00003059                 retn    4
.text$mn:00003059 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@ABV01@@Z endp
.text$mn:00003059
.text$mn:00003059 _text$mn        ends
.text$mn:00003059
.text$x:0000305C ; ===========================================================================
.text$x:0000305C
.text$x:0000305C ; Segment type: Pure code
.text$x:0000305C ; Segment permissions: Read/Execute
.text$x:0000305C _text$x         segment para public 'CODE' use32
.text$x:0000305C                 assume cs:_text$x
.text$x:0000305C                 ;org 305Ch
.text$x:0000305C ; COMDAT (pick associative to section at 2FFC)
.text$x:0000305C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000305C
.text$x:0000305C ; =============== S U B R O U T I N E =======================================
.text$x:0000305C
.text$x:0000305C
.text$x:0000305C __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@ABV01@@Z$0 proc near
.text$x:0000305C                                         ; DATA XREF: .xdata$x:0000A9CCo
.text$x:0000305C                 mov     ecx, [ebp-10h]
.text$x:0000305F                 jmp     ??1?$_Iterator012@Urandom_access_iterator_tag@std@@PAVScintillaEditView@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,ScintillaEditView *,int,ScintillaEditView * const *,ScintillaEditView * const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,ScintillaEditView *,int,ScintillaEditView * const *,ScintillaEditView * const &,std::_Iterator_base12>(void)
.text$x:0000305F __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@ABV01@@Z$0 endp
.text$x:0000305F
.text$x:00003064
.text$x:00003064 ; =============== S U B R O U T I N E =======================================
.text$x:00003064
.text$x:00003064
.text$x:00003064 __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@ABV01@@Z proc near
.text$x:00003064                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>> const &)+5o
.text$x:00003064
.text$x:00003064 arg_4           = dword ptr  8
.text$x:00003064
.text$x:00003064                 mov     edx, [esp+arg_4]
.text$x:00003068                 lea     eax, [edx+0Ch]
.text$x:0000306B                 mov     ecx, [edx-8]
.text$x:0000306E                 xor     ecx, eax
.text$x:00003070                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003075                 mov     eax, offset __ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@ABV01@@Z
.text$x:0000307A                 jmp     ___CxxFrameHandler3
.text$x:0000307A __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@ABV01@@Z endp
.text$x:0000307A
.text$x:0000307A ; ---------------------------------------------------------------------------
.text$x:0000307F                 align 10h
.text$x:0000307F _text$x         ends
.text$x:0000307F
.text$mn:00003080 ; ===========================================================================
.text$mn:00003080
.text$mn:00003080 ; Segment type: Pure code
.text$mn:00003080 ; Segment permissions: Read/Execute
.text$mn:00003080 _text$mn        segment para public 'CODE' use32
.text$mn:00003080                 assume cs:_text$mn
.text$mn:00003080                 ;org 3080h
.text$mn:00003080 ; COMDAT (pick any)
.text$mn:00003080                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003080
.text$mn:00003080 ; =============== S U B R O U T I N E =======================================
.text$mn:00003080
.text$mn:00003080 ; Attributes: bp-based frame
.text$mn:00003080
.text$mn:00003080 ; int __stdcall std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>(int, struct std::_Container_base12 *)
.text$mn:00003080                 public ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@PAPAVScintillaEditView@@PBU_Container_base12@1@@Z
.text$mn:00003080 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@PAPAVScintillaEditView@@PBU_Container_base12@1@@Z proc near
.text$mn:00003080                                         ; CODE XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>(ScintillaEditView * *,std::_Container_base12 const *)+31p
.text$mn:00003080
.text$mn:00003080 var_10          = dword ptr -10h
.text$mn:00003080 var_C           = dword ptr -0Ch
.text$mn:00003080 var_4           = dword ptr -4
.text$mn:00003080 arg_0           = dword ptr  8
.text$mn:00003080 arg_4           = dword ptr  0Ch
.text$mn:00003080
.text$mn:00003080                 push    ebp
.text$mn:00003081                 mov     ebp, esp
.text$mn:00003083                 push    0FFFFFFFFh
.text$mn:00003085                 push    offset __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@PAPAVScintillaEditView@@PBU_Container_base12@1@@Z
.text$mn:0000308A                 mov     eax, large fs:0
.text$mn:00003090                 push    eax
.text$mn:00003091                 push    ecx
.text$mn:00003092                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003097                 xor     eax, ebp
.text$mn:00003099                 push    eax
.text$mn:0000309A                 lea     eax, [ebp+var_C]
.text$mn:0000309D                 mov     large fs:0, eax
.text$mn:000030A3                 mov     [ebp+var_10], ecx
.text$mn:000030A6                 mov     ecx, [ebp+var_10]
.text$mn:000030A9                 call    ??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVScintillaEditView@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,ScintillaEditView *,int,ScintillaEditView * const *,ScintillaEditView * const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,ScintillaEditView *,int,ScintillaEditView * const *,ScintillaEditView * const &,std::_Iterator_base12>(void)
.text$mn:000030AE                 mov     [ebp+var_4], 0
.text$mn:000030B5                 mov     eax, [ebp+var_10]
.text$mn:000030B8                 mov     ecx, [ebp+arg_0]
.text$mn:000030BB                 mov     [eax+8], ecx
.text$mn:000030BE                 mov     edx, [ebp+arg_4]
.text$mn:000030C1                 push    edx             ; struct std::_Container_base12 *
.text$mn:000030C2                 mov     ecx, [ebp+var_10] ; this
.text$mn:000030C5                 call    ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt(std::_Container_base12 const *)
.text$mn:000030CA                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000030D1                 mov     eax, [ebp+var_10]
.text$mn:000030D4                 mov     ecx, [ebp+var_C]
.text$mn:000030D7                 mov     large fs:0, ecx
.text$mn:000030DE                 pop     ecx
.text$mn:000030DF                 mov     esp, ebp
.text$mn:000030E1                 pop     ebp
.text$mn:000030E2                 retn    8
.text$mn:000030E2 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@PAPAVScintillaEditView@@PBU_Container_base12@1@@Z endp
.text$mn:000030E2
.text$mn:000030E2 ; ---------------------------------------------------------------------------
.text$mn:000030E5                 align 4
.text$mn:000030E5 _text$mn        ends
.text$mn:000030E5
.text$x:000030E8 ; ===========================================================================
.text$x:000030E8
.text$x:000030E8 ; Segment type: Pure code
.text$x:000030E8 ; Segment permissions: Read/Execute
.text$x:000030E8 _text$x         segment para public 'CODE' use32
.text$x:000030E8                 assume cs:_text$x
.text$x:000030E8                 ;org 30E8h
.text$x:000030E8 ; COMDAT (pick associative to section at 3080)
.text$x:000030E8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000030E8
.text$x:000030E8 ; =============== S U B R O U T I N E =======================================
.text$x:000030E8
.text$x:000030E8
.text$x:000030E8 __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@PAPAVScintillaEditView@@PBU_Container_base12@1@@Z$0 proc near
.text$x:000030E8                                         ; DATA XREF: .xdata$x:0000A974o
.text$x:000030E8                 mov     ecx, [ebp-10h]
.text$x:000030EB                 jmp     ??1?$_Iterator012@Urandom_access_iterator_tag@std@@PAVScintillaEditView@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,ScintillaEditView *,int,ScintillaEditView * const *,ScintillaEditView * const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,ScintillaEditView *,int,ScintillaEditView * const *,ScintillaEditView * const &,std::_Iterator_base12>(void)
.text$x:000030EB __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@PAPAVScintillaEditView@@PBU_Container_base12@1@@Z$0 endp
.text$x:000030EB
.text$x:000030F0
.text$x:000030F0 ; =============== S U B R O U T I N E =======================================
.text$x:000030F0
.text$x:000030F0
.text$x:000030F0 __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@PAPAVScintillaEditView@@PBU_Container_base12@1@@Z proc near
.text$x:000030F0                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>(ScintillaEditView * *,std::_Container_base12 const *)+5o
.text$x:000030F0
.text$x:000030F0 arg_4           = dword ptr  8
.text$x:000030F0
.text$x:000030F0                 mov     edx, [esp+arg_4]
.text$x:000030F4                 lea     eax, [edx+0Ch]
.text$x:000030F7                 mov     ecx, [edx-8]
.text$x:000030FA                 xor     ecx, eax
.text$x:000030FC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003101                 mov     eax, offset __ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@PAPAVScintillaEditView@@PBU_Container_base12@1@@Z
.text$x:00003106                 jmp     ___CxxFrameHandler3
.text$x:00003106 __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@PAPAVScintillaEditView@@PBU_Container_base12@1@@Z endp
.text$x:00003106
.text$x:00003106 ; ---------------------------------------------------------------------------
.text$x:0000310B                 align 4
.text$x:0000310B _text$x         ends
.text$x:0000310B
.text$mn:0000310C ; ===========================================================================
.text$mn:0000310C
.text$mn:0000310C ; Segment type: Pure code
.text$mn:0000310C ; Segment permissions: Read/Execute
.text$mn:0000310C _text$mn        segment para public 'CODE' use32
.text$mn:0000310C                 assume cs:_text$mn
.text$mn:0000310C                 ;org 310Ch
.text$mn:0000310C ; COMDAT (pick any)
.text$mn:0000310C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000310C
.text$mn:0000310C ; =============== S U B R O U T I N E =======================================
.text$mn:0000310C
.text$mn:0000310C ; Attributes: bp-based frame
.text$mn:0000310C
.text$mn:0000310C ; int __stdcall std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>(struct std::_Iterator_base12 *)
.text$mn:0000310C                 public ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@ABV01@@Z
.text$mn:0000310C ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@ABV01@@Z proc near
.text$mn:0000310C                                         ; CODE XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>> const &)+2Dp
.text$mn:0000310C                                         ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::assign(uint,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const &)+60p ...
.text$mn:0000310C
.text$mn:0000310C var_10          = dword ptr -10h
.text$mn:0000310C var_C           = dword ptr -0Ch
.text$mn:0000310C var_4           = dword ptr -4
.text$mn:0000310C arg_0           = dword ptr  8
.text$mn:0000310C
.text$mn:0000310C                 push    ebp
.text$mn:0000310D                 mov     ebp, esp
.text$mn:0000310F                 push    0FFFFFFFFh
.text$mn:00003111                 push    offset __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@ABV01@@Z
.text$mn:00003116                 mov     eax, large fs:0
.text$mn:0000311C                 push    eax
.text$mn:0000311D                 push    ecx
.text$mn:0000311E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003123                 xor     eax, ebp
.text$mn:00003125                 push    eax
.text$mn:00003126                 lea     eax, [ebp+var_C]
.text$mn:00003129                 mov     large fs:0, eax
.text$mn:0000312F                 mov     [ebp+var_10], ecx
.text$mn:00003132                 mov     eax, [ebp+arg_0]
.text$mn:00003135                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00003136                 mov     ecx, [ebp+var_10]
.text$mn:00003139                 call    ??0?$_Iterator012@Urandom_access_iterator_tag@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@HPBV32@ABV32@U_Iterator_base12@2@@std@@QAE@ABU01@@Z ; std::_Iterator012<std::random_access_iterator_tag,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,int,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,int,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const &,std::_Iterator_base12>(std::_Iterator012<std::random_access_iterator_tag,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,int,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equa
.text$mn:0000313E                 mov     [ebp+var_4], 0
.text$mn:00003145                 mov     ecx, [ebp+var_10]
.text$mn:00003148                 mov     edx, [ebp+arg_0]
.text$mn:0000314B                 mov     eax, [edx+8]
.text$mn:0000314E                 mov     [ecx+8], eax
.text$mn:00003151                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003158                 mov     eax, [ebp+var_10]
.text$mn:0000315B                 mov     ecx, [ebp+var_C]
.text$mn:0000315E                 mov     large fs:0, ecx
.text$mn:00003165                 pop     ecx
.text$mn:00003166                 mov     esp, ebp
.text$mn:00003168                 pop     ebp
.text$mn:00003169                 retn    4
.text$mn:00003169 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@ABV01@@Z endp
.text$mn:00003169
.text$mn:00003169 _text$mn        ends
.text$mn:00003169
.text$x:0000316C ; ===========================================================================
.text$x:0000316C
.text$x:0000316C ; Segment type: Pure code
.text$x:0000316C ; Segment permissions: Read/Execute
.text$x:0000316C _text$x         segment para public 'CODE' use32
.text$x:0000316C                 assume cs:_text$x
.text$x:0000316C                 ;org 316Ch
.text$x:0000316C ; COMDAT (pick associative to section at 310C)
.text$x:0000316C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000316C
.text$x:0000316C ; =============== S U B R O U T I N E =======================================
.text$x:0000316C
.text$x:0000316C
.text$x:0000316C __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@ABV01@@Z$0 proc near
.text$x:0000316C                                         ; DATA XREF: .xdata$x:0000ABB8o
.text$x:0000316C                 mov     ecx, [ebp-10h]
.text$x:0000316F                 jmp     ??1?$_Iterator012@Urandom_access_iterator_tag@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@HPBV32@ABV32@U_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,int,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,int,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const &,std::_Iterator_base12>(void)
.text$x:0000316F __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@ABV01@@Z$0 endp
.text$x:0000316F
.text$x:00003174
.text$x:00003174 ; =============== S U B R O U T I N E =======================================
.text$x:00003174
.text$x:00003174
.text$x:00003174 __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@ABV01@@Z proc near
.text$x:00003174                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>> const &)+5o
.text$x:00003174
.text$x:00003174 arg_4           = dword ptr  8
.text$x:00003174
.text$x:00003174                 mov     edx, [esp+arg_4]
.text$x:00003178                 lea     eax, [edx+0Ch]
.text$x:0000317B                 mov     ecx, [edx-8]
.text$x:0000317E                 xor     ecx, eax
.text$x:00003180                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003185                 mov     eax, offset __ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@ABV01@@Z
.text$x:0000318A                 jmp     ___CxxFrameHandler3
.text$x:0000318A __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@ABV01@@Z endp
.text$x:0000318A
.text$x:0000318A ; ---------------------------------------------------------------------------
.text$x:0000318F                 align 10h
.text$x:0000318F _text$x         ends
.text$x:0000318F
.text$mn:00003190 ; ===========================================================================
.text$mn:00003190
.text$mn:00003190 ; Segment type: Pure code
.text$mn:00003190 ; Segment permissions: Read/Execute
.text$mn:00003190 _text$mn        segment para public 'CODE' use32
.text$mn:00003190                 assume cs:_text$mn
.text$mn:00003190                 ;org 3190h
.text$mn:00003190 ; COMDAT (pick any)
.text$mn:00003190                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003190
.text$mn:00003190 ; =============== S U B R O U T I N E =======================================
.text$mn:00003190
.text$mn:00003190 ; Attributes: bp-based frame
.text$mn:00003190
.text$mn:00003190 ; int __stdcall std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>(int, struct std::_Container_base12 *)
.text$mn:00003190                 public ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@PBU_Container_base12@1@@Z
.text$mn:00003190 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@PBU_Container_base12@1@@Z proc near
.text$mn:00003190                                         ; CODE XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_Container_base12 const *)+31p
.text$mn:00003190
.text$mn:00003190 var_10          = dword ptr -10h
.text$mn:00003190 var_C           = dword ptr -0Ch
.text$mn:00003190 var_4           = dword ptr -4
.text$mn:00003190 arg_0           = dword ptr  8
.text$mn:00003190 arg_4           = dword ptr  0Ch
.text$mn:00003190
.text$mn:00003190                 push    ebp
.text$mn:00003191                 mov     ebp, esp
.text$mn:00003193                 push    0FFFFFFFFh
.text$mn:00003195                 push    offset __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@PBU_Container_base12@1@@Z
.text$mn:0000319A                 mov     eax, large fs:0
.text$mn:000031A0                 push    eax
.text$mn:000031A1                 push    ecx
.text$mn:000031A2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000031A7                 xor     eax, ebp
.text$mn:000031A9                 push    eax
.text$mn:000031AA                 lea     eax, [ebp+var_C]
.text$mn:000031AD                 mov     large fs:0, eax
.text$mn:000031B3                 mov     [ebp+var_10], ecx
.text$mn:000031B6                 mov     ecx, [ebp+var_10]
.text$mn:000031B9                 call    ??0?$_Iterator012@Urandom_access_iterator_tag@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@HPBV32@ABV32@U_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,int,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,int,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const &,std::_Iterator_base12>(void)
.text$mn:000031BE                 mov     [ebp+var_4], 0
.text$mn:000031C5                 mov     eax, [ebp+var_10]
.text$mn:000031C8                 mov     ecx, [ebp+arg_0]
.text$mn:000031CB                 mov     [eax+8], ecx
.text$mn:000031CE                 mov     edx, [ebp+arg_4]
.text$mn:000031D1                 push    edx             ; struct std::_Container_base12 *
.text$mn:000031D2                 mov     ecx, [ebp+var_10] ; this
.text$mn:000031D5                 call    ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt(std::_Container_base12 const *)
.text$mn:000031DA                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000031E1                 mov     eax, [ebp+var_10]
.text$mn:000031E4                 mov     ecx, [ebp+var_C]
.text$mn:000031E7                 mov     large fs:0, ecx
.text$mn:000031EE                 pop     ecx
.text$mn:000031EF                 mov     esp, ebp
.text$mn:000031F1                 pop     ebp
.text$mn:000031F2                 retn    8
.text$mn:000031F2 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@PBU_Container_base12@1@@Z endp
.text$mn:000031F2
.text$mn:000031F2 ; ---------------------------------------------------------------------------
.text$mn:000031F5                 align 4
.text$mn:000031F5 _text$mn        ends
.text$mn:000031F5
.text$x:000031F8 ; ===========================================================================
.text$x:000031F8
.text$x:000031F8 ; Segment type: Pure code
.text$x:000031F8 ; Segment permissions: Read/Execute
.text$x:000031F8 _text$x         segment para public 'CODE' use32
.text$x:000031F8                 assume cs:_text$x
.text$x:000031F8                 ;org 31F8h
.text$x:000031F8 ; COMDAT (pick associative to section at 3190)
.text$x:000031F8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000031F8
.text$x:000031F8 ; =============== S U B R O U T I N E =======================================
.text$x:000031F8
.text$x:000031F8
.text$x:000031F8 __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@PBU_Container_base12@1@@Z$0 proc near
.text$x:000031F8                                         ; DATA XREF: .xdata$x:0000AB60o
.text$x:000031F8                 mov     ecx, [ebp-10h]
.text$x:000031FB                 jmp     ??1?$_Iterator012@Urandom_access_iterator_tag@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@HPBV32@ABV32@U_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,int,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,int,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const &,std::_Iterator_base12>(void)
.text$x:000031FB __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@PBU_Container_base12@1@@Z$0 endp
.text$x:000031FB
.text$x:00003200
.text$x:00003200 ; =============== S U B R O U T I N E =======================================
.text$x:00003200
.text$x:00003200
.text$x:00003200 __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@PBU_Container_base12@1@@Z proc near
.text$x:00003200                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_Container_base12 const *)+5o
.text$x:00003200
.text$x:00003200 arg_4           = dword ptr  8
.text$x:00003200
.text$x:00003200                 mov     edx, [esp+arg_4]
.text$x:00003204                 lea     eax, [edx+0Ch]
.text$x:00003207                 mov     ecx, [edx-8]
.text$x:0000320A                 xor     ecx, eax
.text$x:0000320C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003211                 mov     eax, offset __ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@PBU_Container_base12@1@@Z
.text$x:00003216                 jmp     ___CxxFrameHandler3
.text$x:00003216 __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@PBU_Container_base12@1@@Z endp
.text$x:00003216
.text$x:00003216 ; ---------------------------------------------------------------------------
.text$x:0000321B                 align 4
.text$x:0000321B _text$x         ends
.text$x:0000321B
.text$mn:0000321C ; ===========================================================================
.text$mn:0000321C
.text$mn:0000321C ; Segment type: Pure code
.text$mn:0000321C ; Segment permissions: Read/Execute
.text$mn:0000321C _text$mn        segment para public 'CODE' use32
.text$mn:0000321C                 assume cs:_text$mn
.text$mn:0000321C                 ;org 321Ch
.text$mn:0000321C ; COMDAT (pick any)
.text$mn:0000321C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000321C
.text$mn:0000321C ; =============== S U B R O U T I N E =======================================
.text$mn:0000321C
.text$mn:0000321C ; Attributes: bp-based frame
.text$mn:0000321C
.text$mn:0000321C ; int __stdcall std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>(struct std::_Iterator_base12 *)
.text$mn:0000321C                 public ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@ABV01@@Z
.text$mn:0000321C ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@ABV01@@Z proc near
.text$mn:0000321C                                         ; CODE XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>::operator+(int)+36p
.text$mn:0000321C                                         ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>::operator+(int)+52p
.text$mn:0000321C
.text$mn:0000321C var_10          = dword ptr -10h
.text$mn:0000321C var_C           = dword ptr -0Ch
.text$mn:0000321C var_4           = dword ptr -4
.text$mn:0000321C arg_0           = dword ptr  8
.text$mn:0000321C
.text$mn:0000321C                 push    ebp
.text$mn:0000321D                 mov     ebp, esp
.text$mn:0000321F                 push    0FFFFFFFFh
.text$mn:00003221                 push    offset __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@ABV01@@Z
.text$mn:00003226                 mov     eax, large fs:0
.text$mn:0000322C                 push    eax
.text$mn:0000322D                 push    ecx
.text$mn:0000322E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003233                 xor     eax, ebp
.text$mn:00003235                 push    eax
.text$mn:00003236                 lea     eax, [ebp+var_C]
.text$mn:00003239                 mov     large fs:0, eax
.text$mn:0000323F                 mov     [ebp+var_10], ecx
.text$mn:00003242                 mov     eax, [ebp+arg_0]
.text$mn:00003245                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00003246                 mov     ecx, [ebp+var_10]
.text$mn:00003249                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>> const &)
.text$mn:0000324E                 mov     [ebp+var_4], 0
.text$mn:00003255                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000325C                 mov     eax, [ebp+var_10]
.text$mn:0000325F                 mov     ecx, [ebp+var_C]
.text$mn:00003262                 mov     large fs:0, ecx
.text$mn:00003269                 pop     ecx
.text$mn:0000326A                 mov     esp, ebp
.text$mn:0000326C                 pop     ebp
.text$mn:0000326D                 retn    4
.text$mn:0000326D ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@ABV01@@Z endp
.text$mn:0000326D
.text$mn:0000326D _text$mn        ends
.text$mn:0000326D
.text$x:00003270 ; ===========================================================================
.text$x:00003270
.text$x:00003270 ; Segment type: Pure code
.text$x:00003270 ; Segment permissions: Read/Execute
.text$x:00003270 _text$x         segment para public 'CODE' use32
.text$x:00003270                 assume cs:_text$x
.text$x:00003270                 ;org 3270h
.text$x:00003270 ; COMDAT (pick associative to section at 321C)
.text$x:00003270                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00003270
.text$x:00003270 ; =============== S U B R O U T I N E =======================================
.text$x:00003270
.text$x:00003270
.text$x:00003270 __unwindfunclet$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@ABV01@@Z$0 proc near
.text$x:00003270                                         ; DATA XREF: .xdata$x:0000AA84o
.text$x:00003270                 mov     ecx, [ebp-10h]
.text$x:00003273                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>(void)
.text$x:00003273 __unwindfunclet$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@ABV01@@Z$0 endp
.text$x:00003273
.text$x:00003278
.text$x:00003278 ; =============== S U B R O U T I N E =======================================
.text$x:00003278
.text$x:00003278
.text$x:00003278 __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@ABV01@@Z proc near
.text$x:00003278                                         ; DATA XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>> const &)+5o
.text$x:00003278
.text$x:00003278 arg_4           = dword ptr  8
.text$x:00003278
.text$x:00003278                 mov     edx, [esp+arg_4]
.text$x:0000327C                 lea     eax, [edx+0Ch]
.text$x:0000327F                 mov     ecx, [edx-8]
.text$x:00003282                 xor     ecx, eax
.text$x:00003284                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003289                 mov     eax, offset __ehfuncinfo$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@ABV01@@Z
.text$x:0000328E                 jmp     ___CxxFrameHandler3
.text$x:0000328E __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@ABV01@@Z endp
.text$x:0000328E
.text$x:0000328E ; ---------------------------------------------------------------------------
.text$x:00003293                 align 4
.text$x:00003293 _text$x         ends
.text$x:00003293
.text$mn:00003294 ; ===========================================================================
.text$mn:00003294
.text$mn:00003294 ; Segment type: Pure code
.text$mn:00003294 ; Segment permissions: Read/Execute
.text$mn:00003294 _text$mn        segment para public 'CODE' use32
.text$mn:00003294                 assume cs:_text$mn
.text$mn:00003294                 ;org 3294h
.text$mn:00003294 ; COMDAT (pick any)
.text$mn:00003294                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003294
.text$mn:00003294 ; =============== S U B R O U T I N E =======================================
.text$mn:00003294
.text$mn:00003294 ; Attributes: bp-based frame
.text$mn:00003294
.text$mn:00003294 ; int __stdcall std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>(int, struct std::_Container_base12 *)
.text$mn:00003294                 public ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@PAPAVScintillaEditView@@PBU_Container_base12@1@@Z
.text$mn:00003294 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@PAPAVScintillaEditView@@PBU_Container_base12@1@@Z proc near
.text$mn:00003294                                         ; CODE XREF: std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::_Make_iter(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>)+41p
.text$mn:00003294                                         ; std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::begin(void)+3Dp
.text$mn:00003294
.text$mn:00003294 var_10          = dword ptr -10h
.text$mn:00003294 var_C           = dword ptr -0Ch
.text$mn:00003294 var_4           = dword ptr -4
.text$mn:00003294 arg_0           = dword ptr  8
.text$mn:00003294 arg_4           = dword ptr  0Ch
.text$mn:00003294
.text$mn:00003294                 push    ebp
.text$mn:00003295                 mov     ebp, esp
.text$mn:00003297                 push    0FFFFFFFFh
.text$mn:00003299                 push    offset __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@PAPAVScintillaEditView@@PBU_Container_base12@1@@Z
.text$mn:0000329E                 mov     eax, large fs:0
.text$mn:000032A4                 push    eax
.text$mn:000032A5                 push    ecx
.text$mn:000032A6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000032AB                 xor     eax, ebp
.text$mn:000032AD                 push    eax
.text$mn:000032AE                 lea     eax, [ebp+var_C]
.text$mn:000032B1                 mov     large fs:0, eax
.text$mn:000032B7                 mov     [ebp+var_10], ecx
.text$mn:000032BA                 mov     eax, [ebp+arg_4]
.text$mn:000032BD                 push    eax             ; struct std::_Container_base12 *
.text$mn:000032BE                 mov     ecx, [ebp+arg_0]
.text$mn:000032C1                 push    ecx             ; int
.text$mn:000032C2                 mov     ecx, [ebp+var_10]
.text$mn:000032C5                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@PAPAVScintillaEditView@@PBU_Container_base12@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>(ScintillaEditView * *,std::_Container_base12 const *)
.text$mn:000032CA                 mov     [ebp+var_4], 0
.text$mn:000032D1                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000032D8                 mov     eax, [ebp+var_10]
.text$mn:000032DB                 mov     ecx, [ebp+var_C]
.text$mn:000032DE                 mov     large fs:0, ecx
.text$mn:000032E5                 pop     ecx
.text$mn:000032E6                 mov     esp, ebp
.text$mn:000032E8                 pop     ebp
.text$mn:000032E9                 retn    8
.text$mn:000032E9 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@PAPAVScintillaEditView@@PBU_Container_base12@1@@Z endp
.text$mn:000032E9
.text$mn:000032E9 _text$mn        ends
.text$mn:000032E9
.text$x:000032EC ; ===========================================================================
.text$x:000032EC
.text$x:000032EC ; Segment type: Pure code
.text$x:000032EC ; Segment permissions: Read/Execute
.text$x:000032EC _text$x         segment para public 'CODE' use32
.text$x:000032EC                 assume cs:_text$x
.text$x:000032EC                 ;org 32ECh
.text$x:000032EC ; COMDAT (pick associative to section at 3294)
.text$x:000032EC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000032EC
.text$x:000032EC ; =============== S U B R O U T I N E =======================================
.text$x:000032EC
.text$x:000032EC
.text$x:000032EC __unwindfunclet$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@PAPAVScintillaEditView@@PBU_Container_base12@1@@Z$0 proc near
.text$x:000032EC                                         ; DATA XREF: .xdata$x:0000A9F8o
.text$x:000032EC                 mov     ecx, [ebp-10h]
.text$x:000032EF                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>(void)
.text$x:000032EF __unwindfunclet$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@PAPAVScintillaEditView@@PBU_Container_base12@1@@Z$0 endp
.text$x:000032EF
.text$x:000032F4
.text$x:000032F4 ; =============== S U B R O U T I N E =======================================
.text$x:000032F4
.text$x:000032F4
.text$x:000032F4 __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@PAPAVScintillaEditView@@PBU_Container_base12@1@@Z proc near
.text$x:000032F4                                         ; DATA XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>(ScintillaEditView * *,std::_Container_base12 const *)+5o
.text$x:000032F4
.text$x:000032F4 arg_4           = dword ptr  8
.text$x:000032F4
.text$x:000032F4                 mov     edx, [esp+arg_4]
.text$x:000032F8                 lea     eax, [edx+0Ch]
.text$x:000032FB                 mov     ecx, [edx-8]
.text$x:000032FE                 xor     ecx, eax
.text$x:00003300                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003305                 mov     eax, offset __ehfuncinfo$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@PAPAVScintillaEditView@@PBU_Container_base12@1@@Z
.text$x:0000330A                 jmp     ___CxxFrameHandler3
.text$x:0000330A __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@PAPAVScintillaEditView@@PBU_Container_base12@1@@Z endp
.text$x:0000330A
.text$x:0000330A ; ---------------------------------------------------------------------------
.text$x:0000330F                 align 10h
.text$x:0000330F _text$x         ends
.text$x:0000330F
.text$mn:00003310 ; ===========================================================================
.text$mn:00003310
.text$mn:00003310 ; Segment type: Pure code
.text$mn:00003310 ; Segment permissions: Read/Execute
.text$mn:00003310 _text$mn        segment para public 'CODE' use32
.text$mn:00003310                 assume cs:_text$mn
.text$mn:00003310                 ;org 3310h
.text$mn:00003310 ; COMDAT (pick any)
.text$mn:00003310                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003310
.text$mn:00003310 ; =============== S U B R O U T I N E =======================================
.text$mn:00003310
.text$mn:00003310 ; Attributes: bp-based frame
.text$mn:00003310
.text$mn:00003310 ; int __stdcall std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>(struct std::_Iterator_base12 *)
.text$mn:00003310                 public ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@ABV01@@Z
.text$mn:00003310 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@ABV01@@Z proc near
.text$mn:00003310                                         ; CODE XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::operator+(int)+36p
.text$mn:00003310                                         ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::operator+(int)+52p
.text$mn:00003310
.text$mn:00003310 var_10          = dword ptr -10h
.text$mn:00003310 var_C           = dword ptr -0Ch
.text$mn:00003310 var_4           = dword ptr -4
.text$mn:00003310 arg_0           = dword ptr  8
.text$mn:00003310
.text$mn:00003310                 push    ebp
.text$mn:00003311                 mov     ebp, esp
.text$mn:00003313                 push    0FFFFFFFFh
.text$mn:00003315                 push    offset __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@ABV01@@Z
.text$mn:0000331A                 mov     eax, large fs:0
.text$mn:00003320                 push    eax
.text$mn:00003321                 push    ecx
.text$mn:00003322                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003327                 xor     eax, ebp
.text$mn:00003329                 push    eax
.text$mn:0000332A                 lea     eax, [ebp+var_C]
.text$mn:0000332D                 mov     large fs:0, eax
.text$mn:00003333                 mov     [ebp+var_10], ecx
.text$mn:00003336                 mov     eax, [ebp+arg_0]
.text$mn:00003339                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:0000333A                 mov     ecx, [ebp+var_10]
.text$mn:0000333D                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>> const &)
.text$mn:00003342                 mov     [ebp+var_4], 0
.text$mn:00003349                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003350                 mov     eax, [ebp+var_10]
.text$mn:00003353                 mov     ecx, [ebp+var_C]
.text$mn:00003356                 mov     large fs:0, ecx
.text$mn:0000335D                 pop     ecx
.text$mn:0000335E                 mov     esp, ebp
.text$mn:00003360                 pop     ebp
.text$mn:00003361                 retn    4
.text$mn:00003361 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@ABV01@@Z endp
.text$mn:00003361
.text$mn:00003361 _text$mn        ends
.text$mn:00003361
.text$x:00003364 ; ===========================================================================
.text$x:00003364
.text$x:00003364 ; Segment type: Pure code
.text$x:00003364 ; Segment permissions: Read/Execute
.text$x:00003364 _text$x         segment para public 'CODE' use32
.text$x:00003364                 assume cs:_text$x
.text$x:00003364                 ;org 3364h
.text$x:00003364 ; COMDAT (pick associative to section at 3310)
.text$x:00003364                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00003364
.text$x:00003364 ; =============== S U B R O U T I N E =======================================
.text$x:00003364
.text$x:00003364
.text$x:00003364 __unwindfunclet$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@ABV01@@Z$0 proc near
.text$x:00003364                                         ; DATA XREF: .xdata$x:0000AC70o
.text$x:00003364                 mov     ecx, [ebp-10h]
.text$x:00003367                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>(void)
.text$x:00003367 __unwindfunclet$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@ABV01@@Z$0 endp
.text$x:00003367
.text$x:0000336C
.text$x:0000336C ; =============== S U B R O U T I N E =======================================
.text$x:0000336C
.text$x:0000336C
.text$x:0000336C __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@ABV01@@Z proc near
.text$x:0000336C                                         ; DATA XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>> const &)+5o
.text$x:0000336C
.text$x:0000336C arg_4           = dword ptr  8
.text$x:0000336C
.text$x:0000336C                 mov     edx, [esp+arg_4]
.text$x:00003370                 lea     eax, [edx+0Ch]
.text$x:00003373                 mov     ecx, [edx-8]
.text$x:00003376                 xor     ecx, eax
.text$x:00003378                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000337D                 mov     eax, offset __ehfuncinfo$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@ABV01@@Z
.text$x:00003382                 jmp     ___CxxFrameHandler3
.text$x:00003382 __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@ABV01@@Z endp
.text$x:00003382
.text$x:00003382 ; ---------------------------------------------------------------------------
.text$x:00003387                 align 4
.text$x:00003387 _text$x         ends
.text$x:00003387
.text$mn:00003388 ; ===========================================================================
.text$mn:00003388
.text$mn:00003388 ; Segment type: Pure code
.text$mn:00003388 ; Segment permissions: Read/Execute
.text$mn:00003388 _text$mn        segment para public 'CODE' use32
.text$mn:00003388                 assume cs:_text$mn
.text$mn:00003388                 ;org 3388h
.text$mn:00003388 ; COMDAT (pick any)
.text$mn:00003388                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003388
.text$mn:00003388 ; =============== S U B R O U T I N E =======================================
.text$mn:00003388
.text$mn:00003388 ; Attributes: bp-based frame
.text$mn:00003388
.text$mn:00003388 ; int __stdcall std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>(int, struct std::_Container_base12 *)
.text$mn:00003388                 public ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@PBU_Container_base12@1@@Z
.text$mn:00003388 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@PBU_Container_base12@1@@Z proc near
.text$mn:00003388                                         ; CODE XREF: std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::begin(void)+3Dp
.text$mn:00003388
.text$mn:00003388 var_10          = dword ptr -10h
.text$mn:00003388 var_C           = dword ptr -0Ch
.text$mn:00003388 var_4           = dword ptr -4
.text$mn:00003388 arg_0           = dword ptr  8
.text$mn:00003388 arg_4           = dword ptr  0Ch
.text$mn:00003388
.text$mn:00003388                 push    ebp
.text$mn:00003389                 mov     ebp, esp
.text$mn:0000338B                 push    0FFFFFFFFh
.text$mn:0000338D                 push    offset __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@PBU_Container_base12@1@@Z
.text$mn:00003392                 mov     eax, large fs:0
.text$mn:00003398                 push    eax
.text$mn:00003399                 push    ecx
.text$mn:0000339A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000339F                 xor     eax, ebp
.text$mn:000033A1                 push    eax
.text$mn:000033A2                 lea     eax, [ebp+var_C]
.text$mn:000033A5                 mov     large fs:0, eax
.text$mn:000033AB                 mov     [ebp+var_10], ecx
.text$mn:000033AE                 mov     eax, [ebp+arg_4]
.text$mn:000033B1                 push    eax             ; struct std::_Container_base12 *
.text$mn:000033B2                 mov     ecx, [ebp+arg_0]
.text$mn:000033B5                 push    ecx             ; int
.text$mn:000033B6                 mov     ecx, [ebp+var_10]
.text$mn:000033B9                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@PBU_Container_base12@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_Container_base12 const *)
.text$mn:000033BE                 mov     [ebp+var_4], 0
.text$mn:000033C5                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000033CC                 mov     eax, [ebp+var_10]
.text$mn:000033CF                 mov     ecx, [ebp+var_C]
.text$mn:000033D2                 mov     large fs:0, ecx
.text$mn:000033D9                 pop     ecx
.text$mn:000033DA                 mov     esp, ebp
.text$mn:000033DC                 pop     ebp
.text$mn:000033DD                 retn    8
.text$mn:000033DD ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@PBU_Container_base12@1@@Z endp
.text$mn:000033DD
.text$mn:000033DD _text$mn        ends
.text$mn:000033DD
.text$x:000033E0 ; ===========================================================================
.text$x:000033E0
.text$x:000033E0 ; Segment type: Pure code
.text$x:000033E0 ; Segment permissions: Read/Execute
.text$x:000033E0 _text$x         segment para public 'CODE' use32
.text$x:000033E0                 assume cs:_text$x
.text$x:000033E0                 ;org 33E0h
.text$x:000033E0 ; COMDAT (pick associative to section at 3388)
.text$x:000033E0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000033E0
.text$x:000033E0 ; =============== S U B R O U T I N E =======================================
.text$x:000033E0
.text$x:000033E0
.text$x:000033E0 __unwindfunclet$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@PBU_Container_base12@1@@Z$0 proc near
.text$x:000033E0                                         ; DATA XREF: .xdata$x:0000ABE4o
.text$x:000033E0                 mov     ecx, [ebp-10h]
.text$x:000033E3                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>(void)
.text$x:000033E3 __unwindfunclet$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@PBU_Container_base12@1@@Z$0 endp
.text$x:000033E3
.text$x:000033E8
.text$x:000033E8 ; =============== S U B R O U T I N E =======================================
.text$x:000033E8
.text$x:000033E8
.text$x:000033E8 __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@PBU_Container_base12@1@@Z proc near
.text$x:000033E8                                         ; DATA XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_Container_base12 const *)+5o
.text$x:000033E8
.text$x:000033E8 arg_4           = dword ptr  8
.text$x:000033E8
.text$x:000033E8                 mov     edx, [esp+arg_4]
.text$x:000033EC                 lea     eax, [edx+0Ch]
.text$x:000033EF                 mov     ecx, [edx-8]
.text$x:000033F2                 xor     ecx, eax
.text$x:000033F4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000033F9                 mov     eax, offset __ehfuncinfo$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@PBU_Container_base12@1@@Z
.text$x:000033FE                 jmp     ___CxxFrameHandler3
.text$x:000033FE __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@PBU_Container_base12@1@@Z endp
.text$x:000033FE
.text$x:000033FE ; ---------------------------------------------------------------------------
.text$x:00003403                 align 4
.text$x:00003403 _text$x         ends
.text$x:00003403
.text$mn:00003404 ; ===========================================================================
.text$mn:00003404
.text$mn:00003404 ; Segment type: Pure code
.text$mn:00003404 ; Segment permissions: Read/Execute
.text$mn:00003404 _text$mn        segment para public 'CODE' use32
.text$mn:00003404                 assume cs:_text$mn
.text$mn:00003404                 ;org 3404h
.text$mn:00003404 ; COMDAT (pick any)
.text$mn:00003404                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003404
.text$mn:00003404 ; =============== S U B R O U T I N E =======================================
.text$mn:00003404
.text$mn:00003404 ; Attributes: bp-based frame
.text$mn:00003404
.text$mn:00003404 ; public: __thiscall std::_Vector_val<struct std::_Simple_types<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>>>::_Vector_val<struct std::_Simple_types<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>>>(void)
.text$mn:00003404                 public ??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ
.text$mn:00003404 ??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00003404                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>>::_Vector_alloc<0,std::_Vec_base_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>>(std::_Wrap_alloc<std:
.text$mn:00003404
.text$mn:00003404 var_10          = dword ptr -10h
.text$mn:00003404 var_C           = dword ptr -0Ch
.text$mn:00003404 var_4           = dword ptr -4
.text$mn:00003404
.text$mn:00003404                 push    ebp
.text$mn:00003405                 mov     ebp, esp
.text$mn:00003407                 push    0FFFFFFFFh
.text$mn:00003409                 push    offset __ehhandler$??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ
.text$mn:0000340E                 mov     eax, large fs:0
.text$mn:00003414                 push    eax
.text$mn:00003415                 push    ecx
.text$mn:00003416                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000341B                 xor     eax, ebp
.text$mn:0000341D                 push    eax
.text$mn:0000341E                 lea     eax, [ebp+var_C]
.text$mn:00003421                 mov     large fs:0, eax
.text$mn:00003427                 mov     [ebp+var_10], ecx
.text$mn:0000342A                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000342D                 call    ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
.text$mn:00003432                 mov     [ebp+var_4], 0
.text$mn:00003439                 mov     eax, [ebp+var_10]
.text$mn:0000343C                 mov     dword ptr [eax+4], 0
.text$mn:00003443                 mov     ecx, [ebp+var_10]
.text$mn:00003446                 mov     dword ptr [ecx+8], 0
.text$mn:0000344D                 mov     edx, [ebp+var_10]
.text$mn:00003450                 mov     dword ptr [edx+0Ch], 0
.text$mn:00003457                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000345E                 mov     eax, [ebp+var_10]
.text$mn:00003461                 mov     ecx, [ebp+var_C]
.text$mn:00003464                 mov     large fs:0, ecx
.text$mn:0000346B                 pop     ecx
.text$mn:0000346C                 mov     esp, ebp
.text$mn:0000346E                 pop     ebp
.text$mn:0000346F                 retn
.text$mn:0000346F ??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ endp
.text$mn:0000346F
.text$mn:0000346F _text$mn        ends
.text$mn:0000346F
.text$x:00003470 ; ===========================================================================
.text$x:00003470
.text$x:00003470 ; Segment type: Pure code
.text$x:00003470 ; Segment permissions: Read/Execute
.text$x:00003470 _text$x         segment para public 'CODE' use32
.text$x:00003470                 assume cs:_text$x
.text$x:00003470                 ;org 3470h
.text$x:00003470 ; COMDAT (pick associative to section at 3404)
.text$x:00003470                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00003470
.text$x:00003470 ; =============== S U B R O U T I N E =======================================
.text$x:00003470
.text$x:00003470
.text$x:00003470 __unwindfunclet$??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00003470                                         ; DATA XREF: .xdata$x:0000A0C8o
.text$x:00003470                 mov     ecx, [ebp-10h]  ; this
.text$x:00003473                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00003473 __unwindfunclet$??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:00003473
.text$x:00003478
.text$x:00003478 ; =============== S U B R O U T I N E =======================================
.text$x:00003478
.text$x:00003478
.text$x:00003478 __ehhandler$??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ proc near
.text$x:00003478                                         ; DATA XREF: std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>(void)+5o
.text$x:00003478
.text$x:00003478 arg_4           = dword ptr  8
.text$x:00003478
.text$x:00003478                 mov     edx, [esp+arg_4]
.text$x:0000347C                 lea     eax, [edx+0Ch]
.text$x:0000347F                 mov     ecx, [edx-8]
.text$x:00003482                 xor     ecx, eax
.text$x:00003484                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003489                 mov     eax, offset __ehfuncinfo$??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ
.text$x:0000348E                 jmp     ___CxxFrameHandler3
.text$x:0000348E __ehhandler$??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ endp
.text$x:0000348E
.text$x:0000348E ; ---------------------------------------------------------------------------
.text$x:00003493                 align 4
.text$x:00003493 _text$x         ends
.text$x:00003493
.text$mn:00003494 ; ===========================================================================
.text$mn:00003494
.text$mn:00003494 ; Segment type: Pure code
.text$mn:00003494 ; Segment permissions: Read/Execute
.text$mn:00003494 _text$mn        segment para public 'CODE' use32
.text$mn:00003494                 assume cs:_text$mn
.text$mn:00003494                 ;org 3494h
.text$mn:00003494 ; COMDAT (pick any)
.text$mn:00003494                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003494
.text$mn:00003494 ; =============== S U B R O U T I N E =======================================
.text$mn:00003494
.text$mn:00003494 ; Attributes: bp-based frame
.text$mn:00003494
.text$mn:00003494 ; public: __thiscall std::_Wrap_alloc<struct std::_Wrap_alloc<class std::allocator<struct std::_Container_proxy>>>::_Wrap_alloc<struct std::_Wrap_alloc<class std::allocator<struct std::_Container_proxy>>>(void)
.text$mn:00003494                 public ??0?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@@std@@QAE@XZ
.text$mn:00003494 ??0?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00003494                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>>::_Alloc_proxy(void)+Cp
.text$mn:00003494                                         ; std::_Vector_alloc<0,std::_Vec_base_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>>>>>::_Free_proxy(void)+Cp ...
.text$mn:00003494
.text$mn:00003494 var_4           = dword ptr -4
.text$mn:00003494
.text$mn:00003494                 push    ebp
.text$mn:00003495                 mov     ebp, esp
.text$mn:00003497                 push    ecx
.text$mn:00003498                 mov     [ebp+var_4], ecx
.text$mn:0000349B                 mov     ecx, [ebp+var_4]
.text$mn:0000349E                 call    ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::_Wrap_alloc<std::allocator<std::_Container_proxy>>(void)
.text$mn:000034A3                 mov     eax, [ebp+var_4]
.text$mn:000034A6                 mov     esp, ebp
.text$mn:000034A8                 pop     ebp
.text$mn:000034A9                 retn
.text$mn:000034A9 ??0?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@@std@@QAE@XZ endp
.text$mn:000034A9
.text$mn:000034A9 ; ---------------------------------------------------------------------------
.text$mn:000034AA                 align 4
.text$mn:000034AA _text$mn        ends
.text$mn:000034AA
.text$mn:000034AC ; ===========================================================================
.text$mn:000034AC
.text$mn:000034AC ; Segment type: Pure code
.text$mn:000034AC ; Segment permissions: Read/Execute
.text$mn:000034AC _text$mn        segment para public 'CODE' use32
.text$mn:000034AC                 assume cs:_text$mn
.text$mn:000034AC                 ;org 34ACh
.text$mn:000034AC ; COMDAT (pick any)
.text$mn:000034AC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000034AC
.text$mn:000034AC ; =============== S U B R O U T I N E =======================================
.text$mn:000034AC
.text$mn:000034AC ; Attributes: bp-based frame
.text$mn:000034AC
.text$mn:000034AC ; public: __thiscall std::_Wrap_alloc<struct std::_Wrap_alloc<class std::allocator<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<int const, struct Style>>>>>>>::_Wrap_alloc<struct std::_Wrap_alloc<class std::allocator<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<int const, struct Style>>>>>>>(void)
.text$mn:000034AC                 public ??0?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ
.text$mn:000034AC ??0?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ proc near
.text$mn:000034AC                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>>>>>::_Getal(void)+Ap
.text$mn:000034AC
.text$mn:000034AC var_4           = dword ptr -4
.text$mn:000034AC
.text$mn:000034AC                 push    ebp
.text$mn:000034AD                 mov     ebp, esp
.text$mn:000034AF                 push    ecx
.text$mn:000034B0                 mov     [ebp+var_4], ecx
.text$mn:000034B3                 mov     ecx, [ebp+var_4]
.text$mn:000034B6                 call    ??0?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>>>::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>>>(void)
.text$mn:000034BB                 mov     eax, [ebp+var_4]
.text$mn:000034BE                 mov     esp, ebp
.text$mn:000034C0                 pop     ebp
.text$mn:000034C1                 retn
.text$mn:000034C1 ??0?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ endp
.text$mn:000034C1
.text$mn:000034C1 ; ---------------------------------------------------------------------------
.text$mn:000034C2                 align 4
.text$mn:000034C2 _text$mn        ends
.text$mn:000034C2
.text$mn:000034C4 ; ===========================================================================
.text$mn:000034C4
.text$mn:000034C4 ; Segment type: Pure code
.text$mn:000034C4 ; Segment permissions: Read/Execute
.text$mn:000034C4 _text$mn        segment para public 'CODE' use32
.text$mn:000034C4                 assume cs:_text$mn
.text$mn:000034C4                 ;org 34C4h
.text$mn:000034C4 ; COMDAT (pick any)
.text$mn:000034C4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000034C4
.text$mn:000034C4 ; =============== S U B R O U T I N E =======================================
.text$mn:000034C4
.text$mn:000034C4 ; Attributes: bp-based frame
.text$mn:000034C4
.text$mn:000034C4 ; public: __thiscall std::_Wrap_alloc<struct std::_Wrap_alloc<class std::allocator<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>>>>::_Wrap_alloc<struct std::_Wrap_alloc<class std::allocator<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>>>>(void)
.text$mn:000034C4                 public ??0?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ
.text$mn:000034C4 ??0?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ proc near
.text$mn:000034C4                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>>::_Getal(void)+Ap
.text$mn:000034C4
.text$mn:000034C4 var_4           = dword ptr -4
.text$mn:000034C4
.text$mn:000034C4                 push    ebp
.text$mn:000034C5                 mov     ebp, esp
.text$mn:000034C7                 push    ecx
.text$mn:000034C8                 mov     [ebp+var_4], ecx
.text$mn:000034CB                 mov     ecx, [ebp+var_4]
.text$mn:000034CE                 call    ??0?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>(void)
.text$mn:000034D3                 mov     eax, [ebp+var_4]
.text$mn:000034D6                 mov     esp, ebp
.text$mn:000034D8                 pop     ebp
.text$mn:000034D9                 retn
.text$mn:000034D9 ??0?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ endp
.text$mn:000034D9
.text$mn:000034D9 ; ---------------------------------------------------------------------------
.text$mn:000034DA                 align 4
.text$mn:000034DA _text$mn        ends
.text$mn:000034DA
.text$mn:000034DC ; ===========================================================================
.text$mn:000034DC
.text$mn:000034DC ; Segment type: Pure code
.text$mn:000034DC ; Segment permissions: Read/Execute
.text$mn:000034DC _text$mn        segment para public 'CODE' use32
.text$mn:000034DC                 assume cs:_text$mn
.text$mn:000034DC                 ;org 34DCh
.text$mn:000034DC ; COMDAT (pick any)
.text$mn:000034DC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000034DC
.text$mn:000034DC ; =============== S U B R O U T I N E =======================================
.text$mn:000034DC
.text$mn:000034DC ; Attributes: bp-based frame
.text$mn:000034DC
.text$mn:000034DC ; public: __thiscall std::_Wrap_alloc<class std::allocator<char>>::_Wrap_alloc<class std::allocator<char>>(void)
.text$mn:000034DC                 public ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
.text$mn:000034DC ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ proc near
.text$mn:000034DC                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)+Ap
.text$mn:000034DC
.text$mn:000034DC var_4           = dword ptr -4
.text$mn:000034DC
.text$mn:000034DC                 push    ebp
.text$mn:000034DD                 mov     ebp, esp
.text$mn:000034DF                 push    ecx
.text$mn:000034E0                 mov     [ebp+var_4], ecx
.text$mn:000034E3                 mov     ecx, [ebp+var_4]
.text$mn:000034E6                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:000034EB                 mov     eax, [ebp+var_4]
.text$mn:000034EE                 mov     esp, ebp
.text$mn:000034F0                 pop     ebp
.text$mn:000034F1                 retn
.text$mn:000034F1 ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ endp
.text$mn:000034F1
.text$mn:000034F1 ; ---------------------------------------------------------------------------
.text$mn:000034F2                 align 4
.text$mn:000034F2 _text$mn        ends
.text$mn:000034F2
.text$mn:000034F4 ; ===========================================================================
.text$mn:000034F4
.text$mn:000034F4 ; Segment type: Pure code
.text$mn:000034F4 ; Segment permissions: Read/Execute
.text$mn:000034F4 _text$mn        segment para public 'CODE' use32
.text$mn:000034F4                 assume cs:_text$mn
.text$mn:000034F4                 ;org 34F4h
.text$mn:000034F4 ; COMDAT (pick any)
.text$mn:000034F4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000034F4
.text$mn:000034F4 ; =============== S U B R O U T I N E =======================================
.text$mn:000034F4
.text$mn:000034F4 ; Attributes: bp-based frame
.text$mn:000034F4
.text$mn:000034F4 ; public: __thiscall std::_Wrap_alloc<class std::allocator<class ScintillaEditView *>>::_Wrap_alloc<class std::allocator<class ScintillaEditView *>>(void)
.text$mn:000034F4                 public ??0?$_Wrap_alloc@V?$allocator@PAVScintillaEditView@@@std@@@std@@QAE@XZ
.text$mn:000034F4 ??0?$_Wrap_alloc@V?$allocator@PAVScintillaEditView@@@std@@@std@@QAE@XZ proc near
.text$mn:000034F4                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<ScintillaEditView *,std::allocator<ScintillaEditView *>>>::_Getal(void)+Ap
.text$mn:000034F4
.text$mn:000034F4 var_4           = dword ptr -4
.text$mn:000034F4
.text$mn:000034F4                 push    ebp
.text$mn:000034F5                 mov     ebp, esp
.text$mn:000034F7                 push    ecx
.text$mn:000034F8                 mov     [ebp+var_4], ecx
.text$mn:000034FB                 mov     ecx, [ebp+var_4]
.text$mn:000034FE                 call    ??0?$allocator@PAVScintillaEditView@@@std@@QAE@XZ ; std::allocator<ScintillaEditView *>::allocator<ScintillaEditView *>(void)
.text$mn:00003503                 mov     eax, [ebp+var_4]
.text$mn:00003506                 mov     esp, ebp
.text$mn:00003508                 pop     ebp
.text$mn:00003509                 retn
.text$mn:00003509 ??0?$_Wrap_alloc@V?$allocator@PAVScintillaEditView@@@std@@@std@@QAE@XZ endp
.text$mn:00003509
.text$mn:00003509 ; ---------------------------------------------------------------------------
.text$mn:0000350A                 align 4
.text$mn:0000350A _text$mn        ends
.text$mn:0000350A
.text$mn:0000350C ; ===========================================================================
.text$mn:0000350C
.text$mn:0000350C ; Segment type: Pure code
.text$mn:0000350C ; Segment permissions: Read/Execute
.text$mn:0000350C _text$mn        segment para public 'CODE' use32
.text$mn:0000350C                 assume cs:_text$mn
.text$mn:0000350C                 ;org 350Ch
.text$mn:0000350C ; COMDAT (pick any)
.text$mn:0000350C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000350C
.text$mn:0000350C ; =============== S U B R O U T I N E =======================================
.text$mn:0000350C
.text$mn:0000350C ; Attributes: bp-based frame
.text$mn:0000350C
.text$mn:0000350C ; public: __thiscall std::_Wrap_alloc<class std::allocator<struct std::_List_node<struct std::pair<int const, struct Style>, void *>>>::_Wrap_alloc<class std::allocator<struct std::_List_node<struct std::pair<int const, struct Style>, void *>>>(void)
.text$mn:0000350C                 public ??0?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@std@@@std@@@std@@QAE@XZ
.text$mn:0000350C ??0?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@std@@@std@@@std@@QAE@XZ proc near
.text$mn:0000350C                                         ; CODE XREF: std::_List_alloc<0,std::_List_base_types<std::pair<int const,Style>,std::allocator<std::pair<int const,Style>>>>::_Getal(void)+Ap
.text$mn:0000350C
.text$mn:0000350C var_4           = dword ptr -4
.text$mn:0000350C
.text$mn:0000350C                 push    ebp
.text$mn:0000350D                 mov     ebp, esp
.text$mn:0000350F                 push    ecx
.text$mn:00003510                 mov     [ebp+var_4], ecx
.text$mn:00003513                 mov     ecx, [ebp+var_4]
.text$mn:00003516                 call    ??0?$allocator@U?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@std@@@std@@QAE@XZ ; std::allocator<std::_List_node<std::pair<int const,Style>,void *>>::allocator<std::_List_node<std::pair<int const,Style>,void *>>(void)
.text$mn:0000351B                 mov     eax, [ebp+var_4]
.text$mn:0000351E                 mov     esp, ebp
.text$mn:00003520                 pop     ebp
.text$mn:00003521                 retn
.text$mn:00003521 ??0?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@std@@@std@@@std@@QAE@XZ endp
.text$mn:00003521
.text$mn:00003521 ; ---------------------------------------------------------------------------
.text$mn:00003522                 align 4
.text$mn:00003522 _text$mn        ends
.text$mn:00003522
.text$mn:00003524 ; ===========================================================================
.text$mn:00003524
.text$mn:00003524 ; Segment type: Pure code
.text$mn:00003524 ; Segment permissions: Read/Execute
.text$mn:00003524 _text$mn        segment para public 'CODE' use32
.text$mn:00003524                 assume cs:_text$mn
.text$mn:00003524                 ;org 3524h
.text$mn:00003524 ; COMDAT (pick any)
.text$mn:00003524                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003524
.text$mn:00003524 ; =============== S U B R O U T I N E =======================================
.text$mn:00003524
.text$mn:00003524 ; Attributes: bp-based frame
.text$mn:00003524
.text$mn:00003524 ; public: __thiscall std::_Wrap_alloc<class std::allocator<struct std::_List_node<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>, void *>>>::_Wrap_alloc<class std::allocator<struct std::_List_node<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>, void *>>>(void)
.text$mn:00003524                 public ??0?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@QAE@XZ
.text$mn:00003524 ??0?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00003524                                         ; CODE XREF: std::_List_alloc<0,std::_List_base_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::_Getal(void)+Ap
.text$mn:00003524
.text$mn:00003524 var_4           = dword ptr -4
.text$mn:00003524
.text$mn:00003524                 push    ebp
.text$mn:00003525                 mov     ebp, esp
.text$mn:00003527                 push    ecx
.text$mn:00003528                 mov     [ebp+var_4], ecx
.text$mn:0000352B                 mov     ecx, [ebp+var_4]
.text$mn:0000352E                 call    ??0?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@QAE@XZ ; std::allocator<std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *>>::allocator<std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *>>(void)
.text$mn:00003533                 mov     eax, [ebp+var_4]
.text$mn:00003536                 mov     esp, ebp
.text$mn:00003538                 pop     ebp
.text$mn:00003539                 retn
.text$mn:00003539 ??0?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@QAE@XZ endp
.text$mn:00003539
.text$mn:00003539 ; ---------------------------------------------------------------------------
.text$mn:0000353A                 align 4
.text$mn:0000353A _text$mn        ends
.text$mn:0000353A
.text$mn:0000353C ; ===========================================================================
.text$mn:0000353C
.text$mn:0000353C ; Segment type: Pure code
.text$mn:0000353C ; Segment permissions: Read/Execute
.text$mn:0000353C _text$mn        segment para public 'CODE' use32
.text$mn:0000353C                 assume cs:_text$mn
.text$mn:0000353C                 ;org 353Ch
.text$mn:0000353C ; COMDAT (pick any)
.text$mn:0000353C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000353C
.text$mn:0000353C ; =============== S U B R O U T I N E =======================================
.text$mn:0000353C
.text$mn:0000353C ; Attributes: bp-based frame
.text$mn:0000353C
.text$mn:0000353C ; public: __thiscall std::_Wrap_alloc<class std::allocator<struct std::_Container_proxy>>::_Wrap_alloc<class std::allocator<struct std::_Container_proxy>>(void)
.text$mn:0000353C                 public ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ
.text$mn:0000353C ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ proc near
.text$mn:0000353C                                         ; CODE XREF: std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_Container_proxy>>>::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_Container_proxy>>>(void)+Ap
.text$mn:0000353C                                         ; std::_List_alloc<0,std::_List_base_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::_Alloc_proxy(void)+Cp ...
.text$mn:0000353C
.text$mn:0000353C var_4           = dword ptr -4
.text$mn:0000353C
.text$mn:0000353C                 push    ebp
.text$mn:0000353D                 mov     ebp, esp
.text$mn:0000353F                 push    ecx
.text$mn:00003540                 mov     [ebp+var_4], ecx
.text$mn:00003543                 mov     ecx, [ebp+var_4]
.text$mn:00003546                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:0000354B                 mov     eax, [ebp+var_4]
.text$mn:0000354E                 mov     esp, ebp
.text$mn:00003550                 pop     ebp
.text$mn:00003551                 retn
.text$mn:00003551 ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ endp
.text$mn:00003551
.text$mn:00003551 ; ---------------------------------------------------------------------------
.text$mn:00003552                 align 4
.text$mn:00003552 _text$mn        ends
.text$mn:00003552
.text$mn:00003554 ; ===========================================================================
.text$mn:00003554
.text$mn:00003554 ; Segment type: Pure code
.text$mn:00003554 ; Segment permissions: Read/Execute
.text$mn:00003554 _text$mn        segment para public 'CODE' use32
.text$mn:00003554                 assume cs:_text$mn
.text$mn:00003554                 ;org 3554h
.text$mn:00003554 ; COMDAT (pick any)
.text$mn:00003554                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003554
.text$mn:00003554 ; =============== S U B R O U T I N E =======================================
.text$mn:00003554
.text$mn:00003554 ; Attributes: bp-based frame
.text$mn:00003554
.text$mn:00003554 ; public: __thiscall std::_Wrap_alloc<class std::allocator<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<int const, struct Style>>>>>>::_Wrap_alloc<class std::allocator<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<int const, struct Style>>>>>>(void)
.text$mn:00003554                 public ??0?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ
.text$mn:00003554 ??0?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00003554                                         ; CODE XREF: std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>>>>::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>>>>(void)+Ap
.text$mn:00003554
.text$mn:00003554 var_4           = dword ptr -4
.text$mn:00003554
.text$mn:00003554                 push    ebp
.text$mn:00003555                 mov     ebp, esp
.text$mn:00003557                 push    ecx
.text$mn:00003558                 mov     [ebp+var_4], ecx
.text$mn:0000355B                 mov     ecx, [ebp+var_4]
.text$mn:0000355E                 call    ??0?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@QAE@XZ ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>>::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>>(void)
.text$mn:00003563                 mov     eax, [ebp+var_4]
.text$mn:00003566                 mov     esp, ebp
.text$mn:00003568                 pop     ebp
.text$mn:00003569                 retn
.text$mn:00003569 ??0?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ endp
.text$mn:00003569
.text$mn:00003569 ; ---------------------------------------------------------------------------
.text$mn:0000356A                 align 4
.text$mn:0000356A _text$mn        ends
.text$mn:0000356A
.text$mn:0000356C ; ===========================================================================
.text$mn:0000356C
.text$mn:0000356C ; Segment type: Pure code
.text$mn:0000356C ; Segment permissions: Read/Execute
.text$mn:0000356C _text$mn        segment para public 'CODE' use32
.text$mn:0000356C                 assume cs:_text$mn
.text$mn:0000356C                 ;org 356Ch
.text$mn:0000356C ; COMDAT (pick any)
.text$mn:0000356C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000356C
.text$mn:0000356C ; =============== S U B R O U T I N E =======================================
.text$mn:0000356C
.text$mn:0000356C ; Attributes: bp-based frame
.text$mn:0000356C
.text$mn:0000356C ; public: __thiscall std::_Wrap_alloc<class std::allocator<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>>>::_Wrap_alloc<class std::allocator<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>>>(void)
.text$mn:0000356C                 public ??0?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ
.text$mn:0000356C ??0?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ proc near
.text$mn:0000356C                                         ; CODE XREF: std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>(void)+Ap
.text$mn:0000356C
.text$mn:0000356C var_4           = dword ptr -4
.text$mn:0000356C
.text$mn:0000356C                 push    ebp
.text$mn:0000356D                 mov     ebp, esp
.text$mn:0000356F                 push    ecx
.text$mn:00003570                 mov     [ebp+var_4], ecx
.text$mn:00003573                 mov     ecx, [ebp+var_4]
.text$mn:00003576                 call    ??0?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>(void)
.text$mn:0000357B                 mov     eax, [ebp+var_4]
.text$mn:0000357E                 mov     esp, ebp
.text$mn:00003580                 pop     ebp
.text$mn:00003581                 retn
.text$mn:00003581 ??0?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ endp
.text$mn:00003581
.text$mn:00003581 ; ---------------------------------------------------------------------------
.text$mn:00003582                 align 4
.text$mn:00003582 _text$mn        ends
.text$mn:00003582
.text$mn:00003584 ; ===========================================================================
.text$mn:00003584
.text$mn:00003584 ; Segment type: Pure code
.text$mn:00003584 ; Segment permissions: Read/Execute
.text$mn:00003584 _text$mn        segment para public 'CODE' use32
.text$mn:00003584                 assume cs:_text$mn
.text$mn:00003584                 ;org 3584h
.text$mn:00003584 ; COMDAT (pick any)
.text$mn:00003584                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003584
.text$mn:00003584 ; =============== S U B R O U T I N E =======================================
.text$mn:00003584
.text$mn:00003584 ; Attributes: bp-based frame
.text$mn:00003584
.text$mn:00003584 ; public: __thiscall std::_Wrap_alloc<class std::allocator<wchar_t>>::_Wrap_alloc<class std::allocator<wchar_t>>(void)
.text$mn:00003584                 public ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ
.text$mn:00003584 ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ proc near
.text$mn:00003584                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)+Ap
.text$mn:00003584
.text$mn:00003584 var_4           = dword ptr -4
.text$mn:00003584
.text$mn:00003584                 push    ebp
.text$mn:00003585                 mov     ebp, esp
.text$mn:00003587                 push    ecx
.text$mn:00003588                 mov     [ebp+var_4], ecx
.text$mn:0000358B                 mov     ecx, [ebp+var_4]
.text$mn:0000358E                 call    ??0?$allocator@_W@std@@QAE@XZ ; std::allocator<wchar_t>::allocator<wchar_t>(void)
.text$mn:00003593                 mov     eax, [ebp+var_4]
.text$mn:00003596                 mov     esp, ebp
.text$mn:00003598                 pop     ebp
.text$mn:00003599                 retn
.text$mn:00003599 ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ endp
.text$mn:00003599
.text$mn:00003599 ; ---------------------------------------------------------------------------
.text$mn:0000359A                 align 4
.text$mn:0000359A _text$mn        ends
.text$mn:0000359A
.text$mn:0000359C ; ===========================================================================
.text$mn:0000359C
.text$mn:0000359C ; Segment type: Pure code
.text$mn:0000359C ; Segment permissions: Read/Execute
.text$mn:0000359C _text$mn        segment para public 'CODE' use32
.text$mn:0000359C                 assume cs:_text$mn
.text$mn:0000359C                 ;org 359Ch
.text$mn:0000359C ; COMDAT (pick any)
.text$mn:0000359C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000359C
.text$mn:0000359C ; =============== S U B R O U T I N E =======================================
.text$mn:0000359C
.text$mn:0000359C ; Attributes: bp-based frame
.text$mn:0000359C
.text$mn:0000359C ; public: __thiscall std::allocator<char>::allocator<char>(void)
.text$mn:0000359C                 public ??0?$allocator@D@std@@QAE@XZ
.text$mn:0000359C ??0?$allocator@D@std@@QAE@XZ proc near  ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)+Ap
.text$mn:0000359C                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+2Bp
.text$mn:0000359C
.text$mn:0000359C var_4           = dword ptr -4
.text$mn:0000359C
.text$mn:0000359C                 push    ebp
.text$mn:0000359D                 mov     ebp, esp
.text$mn:0000359F                 push    ecx
.text$mn:000035A0                 mov     [ebp+var_4], ecx
.text$mn:000035A3                 mov     eax, [ebp+var_4]
.text$mn:000035A6                 mov     esp, ebp
.text$mn:000035A8                 pop     ebp
.text$mn:000035A9                 retn
.text$mn:000035A9 ??0?$allocator@D@std@@QAE@XZ endp
.text$mn:000035A9
.text$mn:000035A9 ; ---------------------------------------------------------------------------
.text$mn:000035AA                 align 4
.text$mn:000035AA _text$mn        ends
.text$mn:000035AA
.text$mn:000035AC ; ===========================================================================
.text$mn:000035AC
.text$mn:000035AC ; Segment type: Pure code
.text$mn:000035AC ; Segment permissions: Read/Execute
.text$mn:000035AC _text$mn        segment para public 'CODE' use32
.text$mn:000035AC                 assume cs:_text$mn
.text$mn:000035AC                 ;org 35ACh
.text$mn:000035AC ; COMDAT (pick any)
.text$mn:000035AC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000035AC
.text$mn:000035AC ; =============== S U B R O U T I N E =======================================
.text$mn:000035AC
.text$mn:000035AC ; Attributes: bp-based frame
.text$mn:000035AC
.text$mn:000035AC ; public: __thiscall std::allocator<class ScintillaEditView *>::allocator<class ScintillaEditView *>(void)
.text$mn:000035AC                 public ??0?$allocator@PAVScintillaEditView@@@std@@QAE@XZ
.text$mn:000035AC ??0?$allocator@PAVScintillaEditView@@@std@@QAE@XZ proc near
.text$mn:000035AC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<ScintillaEditView *>>::_Wrap_alloc<std::allocator<ScintillaEditView *>>(void)+Ap
.text$mn:000035AC
.text$mn:000035AC var_4           = dword ptr -4
.text$mn:000035AC
.text$mn:000035AC                 push    ebp
.text$mn:000035AD                 mov     ebp, esp
.text$mn:000035AF                 push    ecx
.text$mn:000035B0                 mov     [ebp+var_4], ecx
.text$mn:000035B3                 mov     eax, [ebp+var_4]
.text$mn:000035B6                 mov     esp, ebp
.text$mn:000035B8                 pop     ebp
.text$mn:000035B9                 retn
.text$mn:000035B9 ??0?$allocator@PAVScintillaEditView@@@std@@QAE@XZ endp
.text$mn:000035B9
.text$mn:000035B9 ; ---------------------------------------------------------------------------
.text$mn:000035BA                 align 4
.text$mn:000035BA _text$mn        ends
.text$mn:000035BA
.text$mn:000035BC ; ===========================================================================
.text$mn:000035BC
.text$mn:000035BC ; Segment type: Pure code
.text$mn:000035BC ; Segment permissions: Read/Execute
.text$mn:000035BC _text$mn        segment para public 'CODE' use32
.text$mn:000035BC                 assume cs:_text$mn
.text$mn:000035BC                 ;org 35BCh
.text$mn:000035BC ; COMDAT (pick any)
.text$mn:000035BC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000035BC
.text$mn:000035BC ; =============== S U B R O U T I N E =======================================
.text$mn:000035BC
.text$mn:000035BC ; Attributes: bp-based frame
.text$mn:000035BC
.text$mn:000035BC ; public: __thiscall std::allocator<struct std::_List_node<struct std::pair<int const, struct Style>, void *>>::allocator<struct std::_List_node<struct std::pair<int const, struct Style>, void *>>(void)
.text$mn:000035BC                 public ??0?$allocator@U?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@std@@@std@@QAE@XZ
.text$mn:000035BC ??0?$allocator@U?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@std@@@std@@QAE@XZ proc near
.text$mn:000035BC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::_List_node<std::pair<int const,Style>,void *>>>::_Wrap_alloc<std::allocator<std::_List_node<std::pair<int const,Style>,void *>>>(void)+Ap
.text$mn:000035BC
.text$mn:000035BC var_4           = dword ptr -4
.text$mn:000035BC
.text$mn:000035BC                 push    ebp
.text$mn:000035BD                 mov     ebp, esp
.text$mn:000035BF                 push    ecx
.text$mn:000035C0                 mov     [ebp+var_4], ecx
.text$mn:000035C3                 mov     eax, [ebp+var_4]
.text$mn:000035C6                 mov     esp, ebp
.text$mn:000035C8                 pop     ebp
.text$mn:000035C9                 retn
.text$mn:000035C9 ??0?$allocator@U?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@std@@@std@@QAE@XZ endp
.text$mn:000035C9
.text$mn:000035C9 ; ---------------------------------------------------------------------------
.text$mn:000035CA                 align 4
.text$mn:000035CA _text$mn        ends
.text$mn:000035CA
.text$mn:000035CC ; ===========================================================================
.text$mn:000035CC
.text$mn:000035CC ; Segment type: Pure code
.text$mn:000035CC ; Segment permissions: Read/Execute
.text$mn:000035CC _text$mn        segment para public 'CODE' use32
.text$mn:000035CC                 assume cs:_text$mn
.text$mn:000035CC                 ;org 35CCh
.text$mn:000035CC ; COMDAT (pick any)
.text$mn:000035CC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000035CC
.text$mn:000035CC ; =============== S U B R O U T I N E =======================================
.text$mn:000035CC
.text$mn:000035CC ; Attributes: bp-based frame
.text$mn:000035CC
.text$mn:000035CC ; public: __thiscall std::allocator<struct std::_List_node<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>, void *>>::allocator<struct std::_List_node<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>, void *>>(void)
.text$mn:000035CC                 public ??0?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@QAE@XZ
.text$mn:000035CC ??0?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@QAE@XZ proc near
.text$mn:000035CC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *>>>::_Wrap_alloc<std::allocator<std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *>>>(void)+Ap
.text$mn:000035CC
.text$mn:000035CC var_4           = dword ptr -4
.text$mn:000035CC
.text$mn:000035CC                 push    ebp
.text$mn:000035CD                 mov     ebp, esp
.text$mn:000035CF                 push    ecx
.text$mn:000035D0                 mov     [ebp+var_4], ecx
.text$mn:000035D3                 mov     eax, [ebp+var_4]
.text$mn:000035D6                 mov     esp, ebp
.text$mn:000035D8                 pop     ebp
.text$mn:000035D9                 retn
.text$mn:000035D9 ??0?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@QAE@XZ endp
.text$mn:000035D9
.text$mn:000035D9 ; ---------------------------------------------------------------------------
.text$mn:000035DA                 align 4
.text$mn:000035DA _text$mn        ends
.text$mn:000035DA
.text$mn:000035DC ; ===========================================================================
.text$mn:000035DC
.text$mn:000035DC ; Segment type: Pure code
.text$mn:000035DC ; Segment permissions: Read/Execute
.text$mn:000035DC _text$mn        segment para public 'CODE' use32
.text$mn:000035DC                 assume cs:_text$mn
.text$mn:000035DC                 ;org 35DCh
.text$mn:000035DC ; COMDAT (pick any)
.text$mn:000035DC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000035DC
.text$mn:000035DC ; =============== S U B R O U T I N E =======================================
.text$mn:000035DC
.text$mn:000035DC ; Attributes: bp-based frame
.text$mn:000035DC
.text$mn:000035DC ; public: __thiscall std::allocator<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>::allocator<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>(void)
.text$mn:000035DC                 public ??0?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@QAE@XZ
.text$mn:000035DC ??0?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@QAE@XZ proc near
.text$mn:000035DC                                         ; CODE XREF: std::unordered_map<Buffer *,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *,std::hash<Buffer *>,std::equal_to<Buffer *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>::unordered_map<Buffer *,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *,std::hash<Buffer *>,std::equal_to<Buffer *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>(void)+2Bp
.text$mn:000035DC
.text$mn:000035DC var_4           = dword ptr -4
.text$mn:000035DC
.text$mn:000035DC                 push    ebp
.text$mn:000035DD                 mov     ebp, esp
.text$mn:000035DF                 push    ecx
.text$mn:000035E0                 mov     [ebp+var_4], ecx
.text$mn:000035E3                 mov     eax, [ebp+var_4]
.text$mn:000035E6                 mov     esp, ebp
.text$mn:000035E8                 pop     ebp
.text$mn:000035E9                 retn
.text$mn:000035E9 ??0?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@QAE@XZ endp
.text$mn:000035E9
.text$mn:000035E9 ; ---------------------------------------------------------------------------
.text$mn:000035EA                 align 4
.text$mn:000035EA _text$mn        ends
.text$mn:000035EA
.text$mn:000035EC ; ===========================================================================
.text$mn:000035EC
.text$mn:000035EC ; Segment type: Pure code
.text$mn:000035EC ; Segment permissions: Read/Execute
.text$mn:000035EC _text$mn        segment para public 'CODE' use32
.text$mn:000035EC                 assume cs:_text$mn
.text$mn:000035EC                 ;org 35ECh
.text$mn:000035EC ; COMDAT (pick any)
.text$mn:000035EC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000035EC
.text$mn:000035EC ; =============== S U B R O U T I N E =======================================
.text$mn:000035EC
.text$mn:000035EC ; Attributes: bp-based frame
.text$mn:000035EC
.text$mn:000035EC ; public: __thiscall std::allocator<struct std::_Container_proxy>::allocator<struct std::_Container_proxy>(void)
.text$mn:000035EC                 public ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ
.text$mn:000035EC ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ proc near
.text$mn:000035EC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::_Wrap_alloc<std::allocator<std::_Container_proxy>>(void)+Ap
.text$mn:000035EC                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+Cp ...
.text$mn:000035EC
.text$mn:000035EC var_4           = dword ptr -4
.text$mn:000035EC
.text$mn:000035EC                 push    ebp
.text$mn:000035ED                 mov     ebp, esp
.text$mn:000035EF                 push    ecx
.text$mn:000035F0                 mov     [ebp+var_4], ecx
.text$mn:000035F3                 mov     eax, [ebp+var_4]
.text$mn:000035F6                 mov     esp, ebp
.text$mn:000035F8                 pop     ebp
.text$mn:000035F9                 retn
.text$mn:000035F9 ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ endp
.text$mn:000035F9
.text$mn:000035F9 ; ---------------------------------------------------------------------------
.text$mn:000035FA                 align 4
.text$mn:000035FA _text$mn        ends
.text$mn:000035FA
.text$mn:000035FC ; ===========================================================================
.text$mn:000035FC
.text$mn:000035FC ; Segment type: Pure code
.text$mn:000035FC ; Segment permissions: Read/Execute
.text$mn:000035FC _text$mn        segment para public 'CODE' use32
.text$mn:000035FC                 assume cs:_text$mn
.text$mn:000035FC                 ;org 35FCh
.text$mn:000035FC ; COMDAT (pick any)
.text$mn:000035FC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000035FC
.text$mn:000035FC ; =============== S U B R O U T I N E =======================================
.text$mn:000035FC
.text$mn:000035FC ; Attributes: bp-based frame
.text$mn:000035FC
.text$mn:000035FC ; public: __thiscall std::allocator<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<int const, struct Style>>>>>::allocator<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<int const, struct Style>>>>>(void)
.text$mn:000035FC                 public ??0?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@QAE@XZ
.text$mn:000035FC ??0?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@QAE@XZ proc near
.text$mn:000035FC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>>>::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>>>(void)+Ap
.text$mn:000035FC
.text$mn:000035FC var_4           = dword ptr -4
.text$mn:000035FC
.text$mn:000035FC                 push    ebp
.text$mn:000035FD                 mov     ebp, esp
.text$mn:000035FF                 push    ecx
.text$mn:00003600                 mov     [ebp+var_4], ecx
.text$mn:00003603                 mov     eax, [ebp+var_4]
.text$mn:00003606                 mov     esp, ebp
.text$mn:00003608                 pop     ebp
.text$mn:00003609                 retn
.text$mn:00003609 ??0?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@QAE@XZ endp
.text$mn:00003609
.text$mn:00003609 ; ---------------------------------------------------------------------------
.text$mn:0000360A                 align 4
.text$mn:0000360A _text$mn        ends
.text$mn:0000360A
.text$mn:0000360C ; ===========================================================================
.text$mn:0000360C
.text$mn:0000360C ; Segment type: Pure code
.text$mn:0000360C ; Segment permissions: Read/Execute
.text$mn:0000360C _text$mn        segment para public 'CODE' use32
.text$mn:0000360C                 assume cs:_text$mn
.text$mn:0000360C                 ;org 360Ch
.text$mn:0000360C ; COMDAT (pick any)
.text$mn:0000360C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000360C
.text$mn:0000360C ; =============== S U B R O U T I N E =======================================
.text$mn:0000360C
.text$mn:0000360C ; Attributes: bp-based frame
.text$mn:0000360C
.text$mn:0000360C ; public: __thiscall std::allocator<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>>::allocator<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>>(void)
.text$mn:0000360C                 public ??0?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ
.text$mn:0000360C ??0?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ proc near
.text$mn:0000360C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>(void)+Ap
.text$mn:0000360C
.text$mn:0000360C var_4           = dword ptr -4
.text$mn:0000360C
.text$mn:0000360C                 push    ebp
.text$mn:0000360D                 mov     ebp, esp
.text$mn:0000360F                 push    ecx
.text$mn:00003610                 mov     [ebp+var_4], ecx
.text$mn:00003613                 mov     eax, [ebp+var_4]
.text$mn:00003616                 mov     esp, ebp
.text$mn:00003618                 pop     ebp
.text$mn:00003619                 retn
.text$mn:00003619 ??0?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ endp
.text$mn:00003619
.text$mn:00003619 ; ---------------------------------------------------------------------------
.text$mn:0000361A                 align 4
.text$mn:0000361A _text$mn        ends
.text$mn:0000361A
.text$mn:0000361C ; ===========================================================================
.text$mn:0000361C
.text$mn:0000361C ; Segment type: Pure code
.text$mn:0000361C ; Segment permissions: Read/Execute
.text$mn:0000361C _text$mn        segment para public 'CODE' use32
.text$mn:0000361C                 assume cs:_text$mn
.text$mn:0000361C                 ;org 361Ch
.text$mn:0000361C ; COMDAT (pick any)
.text$mn:0000361C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000361C
.text$mn:0000361C ; =============== S U B R O U T I N E =======================================
.text$mn:0000361C
.text$mn:0000361C ; Attributes: bp-based frame
.text$mn:0000361C
.text$mn:0000361C ; public: __thiscall std::allocator<wchar_t>::allocator<wchar_t>(void)
.text$mn:0000361C                 public ??0?$allocator@_W@std@@QAE@XZ
.text$mn:0000361C ??0?$allocator@_W@std@@QAE@XZ proc near ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::_Wrap_alloc<std::allocator<wchar_t>>(void)+Ap
.text$mn:0000361C
.text$mn:0000361C var_4           = dword ptr -4
.text$mn:0000361C
.text$mn:0000361C                 push    ebp
.text$mn:0000361D                 mov     ebp, esp
.text$mn:0000361F                 push    ecx
.text$mn:00003620                 mov     [ebp+var_4], ecx
.text$mn:00003623                 mov     eax, [ebp+var_4]
.text$mn:00003626                 mov     esp, ebp
.text$mn:00003628                 pop     ebp
.text$mn:00003629                 retn
.text$mn:00003629 ??0?$allocator@_W@std@@QAE@XZ endp
.text$mn:00003629
.text$mn:00003629 ; ---------------------------------------------------------------------------
.text$mn:0000362A                 align 4
.text$mn:0000362A _text$mn        ends
.text$mn:0000362A
.text$mn:0000362C ; ===========================================================================
.text$mn:0000362C
.text$mn:0000362C ; Segment type: Pure code
.text$mn:0000362C ; Segment permissions: Read/Execute
.text$mn:0000362C _text$mn        segment para public 'CODE' use32
.text$mn:0000362C                 assume cs:_text$mn
.text$mn:0000362C                 ;org 362Ch
.text$mn:0000362C ; COMDAT (pick any)
.text$mn:0000362C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000362C
.text$mn:0000362C ; =============== S U B R O U T I N E =======================================
.text$mn:0000362C
.text$mn:0000362C ; Attributes: bp-based frame
.text$mn:0000362C
.text$mn:0000362C ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char *Str)
.text$mn:0000362C                 public ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$mn:0000362C ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
.text$mn:0000362C                                         ; CODE XREF: std::_Generic_error_category::message(int)+5Ap
.text$mn:0000362C                                         ; std::_Iostream_error_category::message(int)+3Dp ...
.text$mn:0000362C
.text$mn:0000362C var_14          = dword ptr -14h
.text$mn:0000362C var_D           = byte ptr -0Dh
.text$mn:0000362C var_C           = dword ptr -0Ch
.text$mn:0000362C var_4           = dword ptr -4
.text$mn:0000362C Str             = dword ptr  8
.text$mn:0000362C
.text$mn:0000362C                 push    ebp
.text$mn:0000362D                 mov     ebp, esp
.text$mn:0000362F                 push    0FFFFFFFFh
.text$mn:00003631                 push    offset __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$mn:00003636                 mov     eax, large fs:0
.text$mn:0000363C                 push    eax
.text$mn:0000363D                 sub     esp, 8
.text$mn:00003640                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003645                 xor     eax, ebp
.text$mn:00003647                 push    eax
.text$mn:00003648                 lea     eax, [ebp+var_C]
.text$mn:0000364B                 mov     large fs:0, eax
.text$mn:00003651                 mov     [ebp+var_14], ecx
.text$mn:00003654                 lea     ecx, [ebp+var_D]
.text$mn:00003657                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:0000365C                 push    eax
.text$mn:0000365D                 mov     ecx, [ebp+var_14]
.text$mn:00003660                 call    ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)
.text$mn:00003665                 mov     [ebp+var_4], 0
.text$mn:0000366C                 push    0               ; Size
.text$mn:0000366E                 push    0               ; char
.text$mn:00003670                 mov     ecx, [ebp+var_14]
.text$mn:00003673                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00003678                 mov     eax, [ebp+Str]
.text$mn:0000367B                 push    eax             ; Str
.text$mn:0000367C                 mov     ecx, [ebp+var_14]
.text$mn:0000367F                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)
.text$mn:00003684                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000368B                 mov     eax, [ebp+var_14]
.text$mn:0000368E                 mov     ecx, [ebp+var_C]
.text$mn:00003691                 mov     large fs:0, ecx
.text$mn:00003698                 pop     ecx
.text$mn:00003699                 mov     esp, ebp
.text$mn:0000369B                 pop     ebp
.text$mn:0000369C                 retn    4
.text$mn:0000369C ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp
.text$mn:0000369C
.text$mn:0000369C ; ---------------------------------------------------------------------------
.text$mn:0000369F                 align 10h
.text$mn:0000369F _text$mn        ends
.text$mn:0000369F
.text$x:000036A0 ; ===========================================================================
.text$x:000036A0
.text$x:000036A0 ; Segment type: Pure code
.text$x:000036A0 ; Segment permissions: Read/Execute
.text$x:000036A0 _text$x         segment para public 'CODE' use32
.text$x:000036A0                 assume cs:_text$x
.text$x:000036A0                 ;org 36A0h
.text$x:000036A0 ; COMDAT (pick associative to section at 362C)
.text$x:000036A0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000036A0
.text$x:000036A0 ; =============== S U B R O U T I N E =======================================
.text$x:000036A0
.text$x:000036A0
.text$x:000036A0 __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 proc near
.text$x:000036A0                                         ; DATA XREF: .xdata$x:0000988Co
.text$x:000036A0                 mov     ecx, [ebp-14h]
.text$x:000036A3                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:000036A3 __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 endp
.text$x:000036A3
.text$x:000036A8
.text$x:000036A8 ; =============== S U B R O U T I N E =======================================
.text$x:000036A8
.text$x:000036A8
.text$x:000036A8 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
.text$x:000036A8                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+5o
.text$x:000036A8
.text$x:000036A8 arg_4           = dword ptr  8
.text$x:000036A8
.text$x:000036A8                 mov     edx, [esp+arg_4]
.text$x:000036AC                 lea     eax, [edx+0Ch]
.text$x:000036AF                 mov     ecx, [edx-0Ch]
.text$x:000036B2                 xor     ecx, eax
.text$x:000036B4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000036B9                 mov     eax, offset __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$x:000036BE                 jmp     ___CxxFrameHandler3
.text$x:000036BE __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp
.text$x:000036BE
.text$x:000036BE ; ---------------------------------------------------------------------------
.text$x:000036C3                 align 4
.text$x:000036C3 _text$x         ends
.text$x:000036C3
.text$mn:000036C4 ; ===========================================================================
.text$mn:000036C4
.text$mn:000036C4 ; Segment type: Pure code
.text$mn:000036C4 ; Segment permissions: Read/Execute
.text$mn:000036C4 _text$mn        segment para public 'CODE' use32
.text$mn:000036C4                 assume cs:_text$mn
.text$mn:000036C4                 ;org 36C4h
.text$mn:000036C4 ; COMDAT (pick any)
.text$mn:000036C4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000036C4
.text$mn:000036C4 ; =============== S U B R O U T I N E =======================================
.text$mn:000036C4
.text$mn:000036C4 ; Attributes: bp-based frame
.text$mn:000036C4
.text$mn:000036C4 ; public: __thiscall std::list<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>, class std::allocator<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>::list<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>, class std::allocator<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>(class std::allocator<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struc
.text$mn:000036C4                 public ??0?$list@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@1@@Z
.text$mn:000036C4 ??0?$list@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@1@@Z proc near
.text$mn:000036C4                                         ; CODE XREF: std::_Hash<std::_Umap_traits<Buffer *,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *,std::_Uhash_compare<Buffer *,std::hash<Buffer *>,std::equal_to<Buffer *>>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>,0>>::_Hash<std::_Umap_traits<Buffer *,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *,std::_Uhash_compare<Buffer *,std::hash<Buffer *>,std::equal_to<Buffer *>>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>,0>>(std::_Uhash_compare<Buffer *,std::hash<Buffer *>,std::equal_to<Buffer *>> const &,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>> const &)+3Bp
.text$mn:000036C4
.text$mn:000036C4 var_10          = dword ptr -10h
.text$mn:000036C4 var_C           = dword ptr -0Ch
.text$mn:000036C4 var_4           = dword ptr -4
.text$mn:000036C4 arg_0           = dword ptr  8
.text$mn:000036C4
.text$mn:000036C4                 push    ebp
.text$mn:000036C5                 mov     ebp, esp
.text$mn:000036C7                 push    0FFFFFFFFh
.text$mn:000036C9                 push    offset __ehhandler$??0?$list@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@1@@Z
.text$mn:000036CE                 mov     eax, large fs:0
.text$mn:000036D4                 push    eax
.text$mn:000036D5                 push    ecx
.text$mn:000036D6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000036DB                 xor     eax, ebp
.text$mn:000036DD                 push    eax
.text$mn:000036DE                 lea     eax, [ebp+var_C]
.text$mn:000036E1                 mov     large fs:0, eax
.text$mn:000036E7                 mov     [ebp+var_10], ecx
.text$mn:000036EA                 mov     eax, [ebp+arg_0]
.text$mn:000036ED                 push    eax
.text$mn:000036EE                 mov     ecx, [ebp+var_10]
.text$mn:000036F1                 call    ??0?$_List_buy@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@1@@Z ; std::_List_buy<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>::_List_buy<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>(std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>> const &)
.text$mn:000036F6                 mov     [ebp+var_4], 0
.text$mn:000036FD                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003704                 mov     eax, [ebp+var_10]
.text$mn:00003707                 mov     ecx, [ebp+var_C]
.text$mn:0000370A                 mov     large fs:0, ecx
.text$mn:00003711                 pop     ecx
.text$mn:00003712                 mov     esp, ebp
.text$mn:00003714                 pop     ebp
.text$mn:00003715                 retn    4
.text$mn:00003715 ??0?$list@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@1@@Z endp
.text$mn:00003715
.text$mn:00003715 _text$mn        ends
.text$mn:00003715
.text$x:00003718 ; ===========================================================================
.text$x:00003718
.text$x:00003718 ; Segment type: Pure code
.text$x:00003718 ; Segment permissions: Read/Execute
.text$x:00003718 _text$x         segment para public 'CODE' use32
.text$x:00003718                 assume cs:_text$x
.text$x:00003718                 ;org 3718h
.text$x:00003718 ; COMDAT (pick associative to section at 36C4)
.text$x:00003718                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00003718
.text$x:00003718 ; =============== S U B R O U T I N E =======================================
.text$x:00003718
.text$x:00003718
.text$x:00003718 __unwindfunclet$??0?$list@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@1@@Z$0 proc near
.text$x:00003718                                         ; DATA XREF: .xdata$x:00009F2Co
.text$x:00003718                 mov     ecx, [ebp-10h]
.text$x:0000371B                 jmp     ??1?$_List_buy@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAE@XZ ; std::_List_buy<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>::~_List_buy<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>(void)
.text$x:0000371B __unwindfunclet$??0?$list@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@1@@Z$0 endp
.text$x:0000371B
.text$x:00003720
.text$x:00003720 ; =============== S U B R O U T I N E =======================================
.text$x:00003720
.text$x:00003720
.text$x:00003720 __ehhandler$??0?$list@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@1@@Z proc near
.text$x:00003720                                         ; DATA XREF: std::list<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>::list<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>(std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>> const &)+5o
.text$x:00003720
.text$x:00003720 arg_4           = dword ptr  8
.text$x:00003720
.text$x:00003720                 mov     edx, [esp+arg_4]
.text$x:00003724                 lea     eax, [edx+0Ch]
.text$x:00003727                 mov     ecx, [edx-8]
.text$x:0000372A                 xor     ecx, eax
.text$x:0000372C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003731                 mov     eax, offset __ehfuncinfo$??0?$list@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@1@@Z
.text$x:00003736                 jmp     ___CxxFrameHandler3
.text$x:00003736 __ehhandler$??0?$list@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@1@@Z endp
.text$x:00003736
.text$x:00003736 ; ---------------------------------------------------------------------------
.text$x:0000373B                 align 4
.text$x:0000373B _text$x         ends
.text$x:0000373B
.text$mn:0000373C ; ===========================================================================
.text$mn:0000373C
.text$mn:0000373C ; Segment type: Pure code
.text$mn:0000373C ; Segment permissions: Read/Execute
.text$mn:0000373C _text$mn        segment para public 'CODE' use32
.text$mn:0000373C                 assume cs:_text$mn
.text$mn:0000373C                 ;org 373Ch
.text$mn:0000373C ; COMDAT (pick any)
.text$mn:0000373C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000373C
.text$mn:0000373C ; =============== S U B R O U T I N E =======================================
.text$mn:0000373C
.text$mn:0000373C ; Attributes: bp-based frame
.text$mn:0000373C
.text$mn:0000373C ; public: __thiscall std::unordered_map<class Buffer *, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *, struct std::hash<class Buffer *>, struct std::equal_to<class Buffer *>, class std::allocator<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>::unordered_map<class Buffer *, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *, struct std::hash<class Buffer *>, struct std::equal_to<class Buffer *>, class std::allocator<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>(void)
.text$mn:0000373C                 public ??0?$unordered_map@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@U?$hash@PAVBuffer@@@3@U?$equal_to@PAVBuffer@@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@@std@@QAE@XZ
.text$mn:0000373C ??0?$unordered_map@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@U?$hash@PAVBuffer@@@3@U?$equal_to@PAVBuffer@@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@@std@@QAE@XZ proc near
.text$mn:0000373C                                         ; CODE XREF: ScintillaEditView::ScintillaEditView(void)+66p
.text$mn:0000373C
.text$mn:0000373C var_14          = dword ptr -14h
.text$mn:0000373C var_10          = byte ptr -10h
.text$mn:0000373C var_F           = byte ptr -0Fh
.text$mn:0000373C var_E           = byte ptr -0Eh
.text$mn:0000373C var_D           = byte ptr -0Dh
.text$mn:0000373C var_C           = dword ptr -0Ch
.text$mn:0000373C var_4           = dword ptr -4
.text$mn:0000373C
.text$mn:0000373C                 push    ebp
.text$mn:0000373D                 mov     ebp, esp
.text$mn:0000373F                 push    0FFFFFFFFh
.text$mn:00003741                 push    offset __ehhandler$??0?$unordered_map@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@U?$hash@PAVBuffer@@@3@U?$equal_to@PAVBuffer@@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@@std@@QAE@XZ
.text$mn:00003746                 mov     eax, large fs:0
.text$mn:0000374C                 push    eax
.text$mn:0000374D                 sub     esp, 8
.text$mn:00003750                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003755                 xor     eax, ebp
.text$mn:00003757                 push    eax
.text$mn:00003758                 lea     eax, [ebp+var_C]
.text$mn:0000375B                 mov     large fs:0, eax
.text$mn:00003761                 mov     [ebp+var_14], ecx
.text$mn:00003764                 lea     ecx, [ebp+var_D]
.text$mn:00003767                 call    ??0?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@QAE@XZ ; std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>(void)
.text$mn:0000376C                 push    eax
.text$mn:0000376D                 movzx   eax, [ebp+var_E]
.text$mn:00003771                 push    eax
.text$mn:00003772                 movzx   ecx, [ebp+var_F]
.text$mn:00003776                 push    ecx
.text$mn:00003777                 lea     ecx, [ebp+var_10]
.text$mn:0000377A                 call    ??0?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@std@@QAE@U?$hash@PAVBuffer@@@1@U?$equal_to@PAVBuffer@@@1@@Z ; std::_Uhash_compare<Buffer *,std::hash<Buffer *>,std::equal_to<Buffer *>>::_Uhash_compare<Buffer *,std::hash<Buffer *>,std::equal_to<Buffer *>>(std::hash<Buffer *>,std::equal_to<Buffer *>)
.text$mn:0000377F                 push    eax
.text$mn:00003780                 mov     ecx, [ebp+var_14]
.text$mn:00003783                 call    ??0?$_Hash@V?$_Umap_traits@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@V?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@$0A@@std@@@std@@QAE@ABV?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@1@ABV?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@1@@Z ; std::_Hash<std::_Umap_traits<Buffer *,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *,std::_Uhash_compare<Buffer *,std::hash<Buffer *>,std::equal_to<Buffer *>>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>,0>>::_Hash<std::_Umap_traits<Buffer *,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *,std::_Uhash_compare<Buffer *,std::hash<Buffer *>,std::equal_to<Buffer *>>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>,0>>(std::_Uhash_compare<Buffer *,std::hash<Buffer *>,std::equal_to<Buffer *>> const &,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>> const &)
.text$mn:00003788                 mov     [ebp+var_4], 0
.text$mn:0000378F                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003796                 mov     eax, [ebp+var_14]
.text$mn:00003799                 mov     ecx, [ebp+var_C]
.text$mn:0000379C                 mov     large fs:0, ecx
.text$mn:000037A3                 pop     ecx
.text$mn:000037A4                 mov     esp, ebp
.text$mn:000037A6                 pop     ebp
.text$mn:000037A7                 retn
.text$mn:000037A7 ??0?$unordered_map@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@U?$hash@PAVBuffer@@@3@U?$equal_to@PAVBuffer@@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@@std@@QAE@XZ endp
.text$mn:000037A7
.text$mn:000037A7 _text$mn        ends
.text$mn:000037A7
.text$x:000037A8 ; ===========================================================================
.text$x:000037A8
.text$x:000037A8 ; Segment type: Pure code
.text$x:000037A8 ; Segment permissions: Read/Execute
.text$x:000037A8 _text$x         segment para public 'CODE' use32
.text$x:000037A8                 assume cs:_text$x
.text$x:000037A8                 ;org 37A8h
.text$x:000037A8 ; COMDAT (pick associative to section at 373C)
.text$x:000037A8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000037A8
.text$x:000037A8 ; =============== S U B R O U T I N E =======================================
.text$x:000037A8
.text$x:000037A8
.text$x:000037A8 __unwindfunclet$??0?$unordered_map@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@U?$hash@PAVBuffer@@@3@U?$equal_to@PAVBuffer@@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@@std@@QAE@XZ$0 proc near
.text$x:000037A8                                         ; DATA XREF: .xdata$x:0000A33Co
.text$x:000037A8                 mov     ecx, [ebp-14h]
.text$x:000037AB                 jmp     ??1?$_Hash@V?$_Umap_traits@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@V?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Hash<std::_Umap_traits<Buffer *,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *,std::_Uhash_compare<Buffer *,std::hash<Buffer *>,std::equal_to<Buffer *>>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>,0>>::~_Hash<std::_Umap_traits<Buffer *,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *,std::_Uhash_compare<Buffer *,std::hash<Buffer *>,std::equal_to<Buffer *>>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>,0>>(void)
.text$x:000037AB __unwindfunclet$??0?$unordered_map@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@U?$hash@PAVBuffer@@@3@U?$equal_to@PAVBuffer@@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@@std@@QAE@XZ$0 endp
.text$x:000037AB
.text$x:000037B0
.text$x:000037B0 ; =============== S U B R O U T I N E =======================================
.text$x:000037B0
.text$x:000037B0
.text$x:000037B0 __ehhandler$??0?$unordered_map@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@U?$hash@PAVBuffer@@@3@U?$equal_to@PAVBuffer@@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@@std@@QAE@XZ proc near
.text$x:000037B0                                         ; DATA XREF: std::unordered_map<Buffer *,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *,std::hash<Buffer *>,std::equal_to<Buffer *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>::unordered_map<Buffer *,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *,std::hash<Buffer *>,std::equal_to<Buffer *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>(void)+5o
.text$x:000037B0
.text$x:000037B0 arg_4           = dword ptr  8
.text$x:000037B0
.text$x:000037B0                 mov     edx, [esp+arg_4]
.text$x:000037B4                 lea     eax, [edx+0Ch]
.text$x:000037B7                 mov     ecx, [edx-0Ch]
.text$x:000037BA                 xor     ecx, eax
.text$x:000037BC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000037C1                 mov     eax, offset __ehfuncinfo$??0?$unordered_map@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@U?$hash@PAVBuffer@@@3@U?$equal_to@PAVBuffer@@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@@std@@QAE@XZ
.text$x:000037C6                 jmp     ___CxxFrameHandler3
.text$x:000037C6 __ehhandler$??0?$unordered_map@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@U?$hash@PAVBuffer@@@3@U?$equal_to@PAVBuffer@@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@@std@@QAE@XZ endp
.text$x:000037C6
.text$x:000037C6 ; ---------------------------------------------------------------------------
.text$x:000037CB                 align 4
.text$x:000037CB _text$x         ends
.text$x:000037CB
.text$mn:000037CC ; ===========================================================================
.text$mn:000037CC
.text$mn:000037CC ; Segment type: Pure code
.text$mn:000037CC ; Segment permissions: Read/Execute
.text$mn:000037CC _text$mn        segment para public 'CODE' use32
.text$mn:000037CC                 assume cs:_text$mn
.text$mn:000037CC                 ;org 37CCh
.text$mn:000037CC ; COMDAT (pick any)
.text$mn:000037CC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000037CC
.text$mn:000037CC ; =============== S U B R O U T I N E =======================================
.text$mn:000037CC
.text$mn:000037CC ; Attributes: bp-based frame
.text$mn:000037CC
.text$mn:000037CC ; public: __thiscall std::vector<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>, struct std::_Wrap_alloc<class std::allocator<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>>>>::vector<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>, struct std::_Wrap_alloc<class std::allocator<class std
.text$mn:000037CC                 public ??0?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAE@ABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@1@@Z
.text$mn:000037CC ??0?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAE@ABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@1@@Z proc near
.text$mn:000037CC                                         ; CODE XREF: std::_Hash<std::_Umap_traits<Buffer *,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *,std::_Uhash_compare<Buffer *,std::hash<Buffer *>,std::equal_to<Buffer *>>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>,0>>::_Hash<std::_Umap_traits<Buffer *,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *,std::_Uhash_compare<Buffer *,std::hash<Buffer *>,std::equal_to<Buffer *>>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>,0>>(std::_Uhash_compare<Buffer *,std::hash<Buffer *>,std::equal_to<Buffer *>> const &,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>> const &)+5Dp
.text$mn:000037CC
.text$mn:000037CC var_10          = dword ptr -10h
.text$mn:000037CC var_C           = dword ptr -0Ch
.text$mn:000037CC var_4           = dword ptr -4
.text$mn:000037CC arg_0           = dword ptr  8
.text$mn:000037CC
.text$mn:000037CC                 push    ebp
.text$mn:000037CD                 mov     ebp, esp
.text$mn:000037CF                 push    0FFFFFFFFh
.text$mn:000037D1                 push    offset __ehhandler$??0?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAE@ABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@1@@Z
.text$mn:000037D6                 mov     eax, large fs:0
.text$mn:000037DC                 push    eax
.text$mn:000037DD                 push    ecx
.text$mn:000037DE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000037E3                 xor     eax, ebp
.text$mn:000037E5                 push    eax
.text$mn:000037E6                 lea     eax, [ebp+var_C]
.text$mn:000037E9                 mov     large fs:0, eax
.text$mn:000037EF                 mov     [ebp+var_10], ecx
.text$mn:000037F2                 mov     eax, [ebp+arg_0]
.text$mn:000037F5                 push    eax
.text$mn:000037F6                 mov     ecx, [ebp+var_10]
.text$mn:000037F9                 call    ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QAE@ABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>>::_Vector_alloc<0,std::_Vec_base_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>>(std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>> const &)
.text$mn:000037FE                 mov     [ebp+var_4], 0
.text$mn:00003805                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000380C                 mov     eax, [ebp+var_10]
.text$mn:0000380F                 mov     ecx, [ebp+var_C]
.text$mn:00003812                 mov     large fs:0, ecx
.text$mn:00003819                 pop     ecx
.text$mn:0000381A                 mov     esp, ebp
.text$mn:0000381C                 pop     ebp
.text$mn:0000381D                 retn    4
.text$mn:0000381D ??0?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAE@ABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@1@@Z endp
.text$mn:0000381D
.text$mn:0000381D _text$mn        ends
.text$mn:0000381D
.text$x:00003820 ; ===========================================================================
.text$x:00003820
.text$x:00003820 ; Segment type: Pure code
.text$x:00003820 ; Segment permissions: Read/Execute
.text$x:00003820 _text$x         segment para public 'CODE' use32
.text$x:00003820                 assume cs:_text$x
.text$x:00003820                 ;org 3820h
.text$x:00003820 ; COMDAT (pick associative to section at 37CC)
.text$x:00003820                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00003820
.text$x:00003820 ; =============== S U B R O U T I N E =======================================
.text$x:00003820
.text$x:00003820
.text$x:00003820 __unwindfunclet$??0?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAE@ABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@1@@Z$0 proc near
.text$x:00003820                                         ; DATA XREF: .xdata$x:0000A178o
.text$x:00003820                 mov     ecx, [ebp-10h]
.text$x:00003823                 jmp     ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>>::~_Vector_alloc<0,std::_Vec_base_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>>(void)
.text$x:00003823 __unwindfunclet$??0?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAE@ABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@1@@Z$0 endp
.text$x:00003823
.text$x:00003828
.text$x:00003828 ; =============== S U B R O U T I N E =======================================
.text$x:00003828
.text$x:00003828
.text$x:00003828 __ehhandler$??0?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAE@ABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@1@@Z proc near
.text$x:00003828                                         ; DATA XREF: std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>(std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_
.text$x:00003828
.text$x:00003828 arg_4           = dword ptr  8
.text$x:00003828
.text$x:00003828                 mov     edx, [esp+arg_4]
.text$x:0000382C                 lea     eax, [edx+0Ch]
.text$x:0000382F                 mov     ecx, [edx-8]
.text$x:00003832                 xor     ecx, eax
.text$x:00003834                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003839                 mov     eax, offset __ehfuncinfo$??0?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAE@ABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@1@@Z
.text$x:0000383E                 jmp     ___CxxFrameHandler3
.text$x:0000383E __ehhandler$??0?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAE@ABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@1@@Z endp
.text$x:0000383E
.text$x:0000383E ; ---------------------------------------------------------------------------
.text$x:00003843                 align 4
.text$x:00003843 _text$x         ends
.text$x:00003843
.text$mn:00003844 ; ===========================================================================
.text$mn:00003844
.text$mn:00003844 ; Segment type: Pure code
.text$mn:00003844 ; Segment permissions: Read/Execute
.text$mn:00003844 _text$mn        segment para public 'CODE' use32
.text$mn:00003844                 assume cs:_text$mn
.text$mn:00003844                 ;org 3844h
.text$mn:00003844 ; COMDAT (pick any)
.text$mn:00003844                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003844
.text$mn:00003844 ; =============== S U B R O U T I N E =======================================
.text$mn:00003844
.text$mn:00003844 ; Attributes: bp-based frame
.text$mn:00003844
.text$mn:00003844 ; public: __thiscall ScintillaEditView::ScintillaEditView(void)
.text$mn:00003844                 public ??0ScintillaEditView@@QAE@XZ
.text$mn:00003844 ??0ScintillaEditView@@QAE@XZ proc near  ; CODE XREF: ScintillaCtrls::createSintilla(HWND__ *)+4Ep
.text$mn:00003844
.text$mn:00003844 var_10          = dword ptr -10h
.text$mn:00003844 var_C           = dword ptr -0Ch
.text$mn:00003844 var_4           = dword ptr -4
.text$mn:00003844
.text$mn:00003844                 push    ebp
.text$mn:00003845                 mov     ebp, esp
.text$mn:00003847                 push    0FFFFFFFFh
.text$mn:00003849                 push    offset __ehhandler$??0ScintillaEditView@@QAE@XZ
.text$mn:0000384E                 mov     eax, large fs:0
.text$mn:00003854                 push    eax
.text$mn:00003855                 push    ecx
.text$mn:00003856                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000385B                 xor     eax, ebp
.text$mn:0000385D                 push    eax
.text$mn:0000385E                 lea     eax, [ebp+var_C]
.text$mn:00003861                 mov     large fs:0, eax
.text$mn:00003867                 mov     [ebp+var_10], ecx
.text$mn:0000386A                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000386D                 call    ??0Window@@QAE@XZ ; Window::Window(void)
.text$mn:00003872                 mov     [ebp+var_4], 0
.text$mn:00003879                 mov     eax, [ebp+var_10]
.text$mn:0000387C                 mov     dword ptr [eax], offset ??_7ScintillaEditView@@6B@ ; const ScintillaEditView::`vftable'
.text$mn:00003882                 mov     ecx, [ebp+var_10]
.text$mn:00003885                 mov     dword ptr [ecx+10h], 0
.text$mn:0000388C                 mov     edx, [ebp+var_10]
.text$mn:0000388F                 mov     dword ptr [edx+14h], 0
.text$mn:00003896                 mov     eax, [ebp+var_10]
.text$mn:00003899                 mov     byte ptr [eax+2Ch], 0
.text$mn:0000389D                 mov     ecx, [ebp+var_10]
.text$mn:000038A0                 mov     byte ptr [ecx+2Dh], 0
.text$mn:000038A4                 mov     ecx, [ebp+var_10]
.text$mn:000038A7                 add     ecx, 30h ; '0'
.text$mn:000038AA                 call    ??0?$unordered_map@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@U?$hash@PAVBuffer@@@3@U?$equal_to@PAVBuffer@@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@@std@@QAE@XZ ; std::unordered_map<Buffer *,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *,std::hash<Buffer *>,std::equal_to<Buffer *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>::unordered_map<Buffer *,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *,std::hash<Buffer *>,std::equal_to<Buffer *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>(void)
.text$mn:000038AF                 mov     byte ptr [ebp+var_4], 1
.text$mn:000038B3                 mov     edx, [ebp+var_10]
.text$mn:000038B6                 mov     dword ptr [edx+58h], 0FFFFFFFFh
.text$mn:000038BD                 mov     eax, dword ptr ds:?_refCount@ScintillaEditView@@1HA ; int ScintillaEditView::_refCount
.text$mn:000038C2                 add     eax, 1
.text$mn:000038C5                 mov     dword ptr ds:?_refCount@ScintillaEditView@@1HA, eax ; int ScintillaEditView::_refCount
.text$mn:000038CA                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000038D1                 mov     eax, [ebp+var_10]
.text$mn:000038D4                 mov     ecx, [ebp+var_C]
.text$mn:000038D7                 mov     large fs:0, ecx
.text$mn:000038DE                 pop     ecx
.text$mn:000038DF                 mov     esp, ebp
.text$mn:000038E1                 pop     ebp
.text$mn:000038E2                 retn
.text$mn:000038E2 ??0ScintillaEditView@@QAE@XZ endp
.text$mn:000038E2
.text$mn:000038E2 ; ---------------------------------------------------------------------------
.text$mn:000038E3                 align 4
.text$mn:000038E3 _text$mn        ends
.text$mn:000038E3
.text$x:000038E4 ; ===========================================================================
.text$x:000038E4
.text$x:000038E4 ; Segment type: Pure code
.text$x:000038E4 ; Segment permissions: Read/Execute
.text$x:000038E4 _text$x         segment para public 'CODE' use32
.text$x:000038E4                 assume cs:_text$x
.text$x:000038E4                 ;org 38E4h
.text$x:000038E4 ; COMDAT (pick associative to section at 3844)
.text$x:000038E4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000038E4
.text$x:000038E4 ; =============== S U B R O U T I N E =======================================
.text$x:000038E4
.text$x:000038E4
.text$x:000038E4 __unwindfunclet$??0ScintillaEditView@@QAE@XZ$0 proc near
.text$x:000038E4                                         ; DATA XREF: .xdata$x:00009D10o
.text$x:000038E4                 mov     ecx, [ebp-10h]  ; this
.text$x:000038E7                 jmp     ??1Window@@UAE@XZ ; Window::~Window(void)
.text$x:000038E7 __unwindfunclet$??0ScintillaEditView@@QAE@XZ$0 endp
.text$x:000038E7
.text$x:000038EC
.text$x:000038EC ; =============== S U B R O U T I N E =======================================
.text$x:000038EC
.text$x:000038EC
.text$x:000038EC __unwindfunclet$??0ScintillaEditView@@QAE@XZ$1 proc near
.text$x:000038EC                                         ; DATA XREF: .xdata$x:00009D18o
.text$x:000038EC                 mov     ecx, [ebp-10h]
.text$x:000038EF                 add     ecx, 30h ; '0'
.text$x:000038F2                 jmp     ??1?$unordered_map@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@U?$hash@PAVBuffer@@@3@U?$equal_to@PAVBuffer@@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@@std@@QAE@XZ ; std::unordered_map<Buffer *,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *,std::hash<Buffer *>,std::equal_to<Buffer *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>::~unordered_map<Buffer *,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *,std::hash<Buffer *>,std::equal_to<Buffer *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>(void)
.text$x:000038F2 __unwindfunclet$??0ScintillaEditView@@QAE@XZ$1 endp
.text$x:000038F2
.text$x:000038F7
.text$x:000038F7 ; =============== S U B R O U T I N E =======================================
.text$x:000038F7
.text$x:000038F7
.text$x:000038F7 __ehhandler$??0ScintillaEditView@@QAE@XZ proc near
.text$x:000038F7                                         ; DATA XREF: ScintillaEditView::ScintillaEditView(void)+5o
.text$x:000038F7
.text$x:000038F7 arg_4           = dword ptr  8
.text$x:000038F7
.text$x:000038F7                 mov     edx, [esp+arg_4]
.text$x:000038FB                 lea     eax, [edx+0Ch]
.text$x:000038FE                 mov     ecx, [edx-8]
.text$x:00003901                 xor     ecx, eax
.text$x:00003903                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003908                 mov     eax, offset __ehfuncinfo$??0ScintillaEditView@@QAE@XZ
.text$x:0000390D                 jmp     ___CxxFrameHandler3
.text$x:0000390D __ehhandler$??0ScintillaEditView@@QAE@XZ endp
.text$x:0000390D
.text$x:0000390D ; ---------------------------------------------------------------------------
.text$x:00003912                 align 4
.text$x:00003912 _text$x         ends
.text$x:00003912
.text$mn:00003914 ; ===========================================================================
.text$mn:00003914
.text$mn:00003914 ; Segment type: Pure code
.text$mn:00003914 ; Segment permissions: Read/Execute
.text$mn:00003914 _text$mn        segment para public 'CODE' use32
.text$mn:00003914                 assume cs:_text$mn
.text$mn:00003914                 ;org 3914h
.text$mn:00003914 ; COMDAT (pick any)
.text$mn:00003914                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003914
.text$mn:00003914 ; =============== S U B R O U T I N E =======================================
.text$mn:00003914
.text$mn:00003914 ; Attributes: bp-based frame
.text$mn:00003914
.text$mn:00003914 ; _DWORD __thiscall Window::Window(Window *__hidden this)
.text$mn:00003914                 public ??0Window@@QAE@XZ
.text$mn:00003914 ??0Window@@QAE@XZ proc near             ; CODE XREF: ScintillaEditView::ScintillaEditView(void)+29p
.text$mn:00003914
.text$mn:00003914 var_4           = dword ptr -4
.text$mn:00003914
.text$mn:00003914                 push    ebp
.text$mn:00003915                 mov     ebp, esp
.text$mn:00003917                 push    ecx
.text$mn:00003918                 mov     [ebp+var_4], ecx
.text$mn:0000391B                 mov     eax, [ebp+var_4]
.text$mn:0000391E                 mov     dword ptr [eax], offset ??_7Window@@6B@ ; const Window::`vftable'
.text$mn:00003924                 mov     ecx, [ebp+var_4]
.text$mn:00003927                 mov     dword ptr [ecx+4], 0
.text$mn:0000392E                 mov     edx, [ebp+var_4]
.text$mn:00003931                 mov     dword ptr [edx+8], 0
.text$mn:00003938                 mov     eax, [ebp+var_4]
.text$mn:0000393B                 mov     dword ptr [eax+0Ch], 0
.text$mn:00003942                 mov     eax, [ebp+var_4]
.text$mn:00003945                 mov     esp, ebp
.text$mn:00003947                 pop     ebp
.text$mn:00003948                 retn
.text$mn:00003948 ??0Window@@QAE@XZ endp
.text$mn:00003948
.text$mn:00003948 ; ---------------------------------------------------------------------------
.text$mn:00003949                 align 4
.text$mn:00003949 _text$mn        ends
.text$mn:00003949
.text$mn:0000394C ; ===========================================================================
.text$mn:0000394C
.text$mn:0000394C ; Segment type: Pure code
.text$mn:0000394C ; Segment permissions: Read/Execute
.text$mn:0000394C _text$mn        segment para public 'CODE' use32
.text$mn:0000394C                 assume cs:_text$mn
.text$mn:0000394C                 ;org 394Ch
.text$mn:0000394C ; COMDAT (pick any)
.text$mn:0000394C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000394C
.text$mn:0000394C ; =============== S U B R O U T I N E =======================================
.text$mn:0000394C
.text$mn:0000394C ; Attributes: bp-based frame
.text$mn:0000394C
.text$mn:0000394C ; _DWORD __thiscall std::_Container_base12::_Container_base12(std::_Container_base12 *__hidden this)
.text$mn:0000394C                 public ??0_Container_base12@std@@QAE@XZ
.text$mn:0000394C ??0_Container_base12@std@@QAE@XZ proc near
.text$mn:0000394C                                         ; CODE XREF: std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>(void)+29p
.text$mn:0000394C                                         ; std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+29p ...
.text$mn:0000394C
.text$mn:0000394C var_4           = dword ptr -4
.text$mn:0000394C
.text$mn:0000394C                 push    ebp
.text$mn:0000394D                 mov     ebp, esp
.text$mn:0000394F                 push    ecx
.text$mn:00003950                 mov     [ebp+var_4], ecx
.text$mn:00003953                 mov     eax, [ebp+var_4]
.text$mn:00003956                 mov     dword ptr [eax], 0
.text$mn:0000395C                 mov     eax, [ebp+var_4]
.text$mn:0000395F                 mov     esp, ebp
.text$mn:00003961                 pop     ebp
.text$mn:00003962                 retn
.text$mn:00003962 ??0_Container_base12@std@@QAE@XZ endp
.text$mn:00003962
.text$mn:00003962 ; ---------------------------------------------------------------------------
.text$mn:00003963                 align 4
.text$mn:00003963 _text$mn        ends
.text$mn:00003963
.text$mn:00003964 ; ===========================================================================
.text$mn:00003964
.text$mn:00003964 ; Segment type: Pure code
.text$mn:00003964 ; Segment permissions: Read/Execute
.text$mn:00003964 _text$mn        segment para public 'CODE' use32
.text$mn:00003964                 assume cs:_text$mn
.text$mn:00003964                 ;org 3964h
.text$mn:00003964 ; COMDAT (pick any)
.text$mn:00003964                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003964
.text$mn:00003964 ; =============== S U B R O U T I N E =======================================
.text$mn:00003964
.text$mn:00003964 ; Attributes: bp-based frame
.text$mn:00003964
.text$mn:00003964 ; _DWORD __thiscall std::_Container_proxy::_Container_proxy(std::_Container_proxy *__hidden this)
.text$mn:00003964                 public ??0_Container_proxy@std@@QAE@XZ
.text$mn:00003964 ??0_Container_proxy@std@@QAE@XZ proc near
.text$mn:00003964                                         ; CODE XREF: std::_List_alloc<0,std::_List_base_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::_Alloc_proxy(void)+23p
.text$mn:00003964                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+23p ...
.text$mn:00003964
.text$mn:00003964 var_4           = dword ptr -4
.text$mn:00003964
.text$mn:00003964                 push    ebp
.text$mn:00003965                 mov     ebp, esp
.text$mn:00003967                 push    ecx
.text$mn:00003968                 mov     [ebp+var_4], ecx
.text$mn:0000396B                 mov     eax, [ebp+var_4]
.text$mn:0000396E                 mov     dword ptr [eax], 0
.text$mn:00003974                 mov     ecx, [ebp+var_4]
.text$mn:00003977                 mov     dword ptr [ecx+4], 0
.text$mn:0000397E                 mov     eax, [ebp+var_4]
.text$mn:00003981                 mov     esp, ebp
.text$mn:00003983                 pop     ebp
.text$mn:00003984                 retn
.text$mn:00003984 ??0_Container_proxy@std@@QAE@XZ endp
.text$mn:00003984
.text$mn:00003984 ; ---------------------------------------------------------------------------
.text$mn:00003985                 align 4
.text$mn:00003985 _text$mn        ends
.text$mn:00003985
.text$mn:00003988 ; ===========================================================================
.text$mn:00003988
.text$mn:00003988 ; Segment type: Pure code
.text$mn:00003988 ; Segment permissions: Read/Execute
.text$mn:00003988 _text$mn        segment para public 'CODE' use32
.text$mn:00003988                 assume cs:_text$mn
.text$mn:00003988                 ;org 3988h
.text$mn:00003988 ; COMDAT (pick any)
.text$mn:00003988                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003988
.text$mn:00003988 ; =============== S U B R O U T I N E =======================================
.text$mn:00003988
.text$mn:00003988 ; Attributes: bp-based frame
.text$mn:00003988
.text$mn:00003988 ; _DWORD __thiscall std::_Generic_error_category::_Generic_error_category(std::_Generic_error_category *__hidden this)
.text$mn:00003988                 public ??0_Generic_error_category@std@@QAE@XZ
.text$mn:00003988 ??0_Generic_error_category@std@@QAE@XZ proc near
.text$mn:00003988                                         ; CODE XREF: std::_Iostream_error_category::_Iostream_error_category(void)+29p
.text$mn:00003988                                         ; std::_System_error_category::_System_error_category(void)+29p ...
.text$mn:00003988
.text$mn:00003988 var_10          = dword ptr -10h
.text$mn:00003988 var_C           = dword ptr -0Ch
.text$mn:00003988 var_4           = dword ptr -4
.text$mn:00003988
.text$mn:00003988                 push    ebp
.text$mn:00003989                 mov     ebp, esp
.text$mn:0000398B                 push    0FFFFFFFFh
.text$mn:0000398D                 push    offset __ehhandler$??0_Generic_error_category@std@@QAE@XZ
.text$mn:00003992                 mov     eax, large fs:0
.text$mn:00003998                 push    eax
.text$mn:00003999                 push    ecx
.text$mn:0000399A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000399F                 xor     eax, ebp
.text$mn:000039A1                 push    eax
.text$mn:000039A2                 lea     eax, [ebp+var_C]
.text$mn:000039A5                 mov     large fs:0, eax
.text$mn:000039AB                 mov     [ebp+var_10], ecx
.text$mn:000039AE                 mov     ecx, [ebp+var_10] ; this
.text$mn:000039B1                 call    ??0error_category@std@@QAE@XZ ; std::error_category::error_category(void)
.text$mn:000039B6                 mov     [ebp+var_4], 0
.text$mn:000039BD                 mov     eax, [ebp+var_10]
.text$mn:000039C0                 mov     dword ptr [eax], offset ??_7_Generic_error_category@std@@6B@ ; const std::_Generic_error_category::`vftable'
.text$mn:000039C6                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000039CD                 mov     eax, [ebp+var_10]
.text$mn:000039D0                 mov     ecx, [ebp+var_C]
.text$mn:000039D3                 mov     large fs:0, ecx
.text$mn:000039DA                 pop     ecx
.text$mn:000039DB                 mov     esp, ebp
.text$mn:000039DD                 pop     ebp
.text$mn:000039DE                 retn
.text$mn:000039DE ??0_Generic_error_category@std@@QAE@XZ endp
.text$mn:000039DE
.text$mn:000039DE ; ---------------------------------------------------------------------------
.text$mn:000039DF                 align 10h
.text$mn:000039DF _text$mn        ends
.text$mn:000039DF
.text$x:000039E0 ; ===========================================================================
.text$x:000039E0
.text$x:000039E0 ; Segment type: Pure code
.text$x:000039E0 ; Segment permissions: Read/Execute
.text$x:000039E0 _text$x         segment para public 'CODE' use32
.text$x:000039E0                 assume cs:_text$x
.text$x:000039E0                 ;org 39E0h
.text$x:000039E0 ; COMDAT (pick associative to section at 3988)
.text$x:000039E0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000039E0
.text$x:000039E0 ; =============== S U B R O U T I N E =======================================
.text$x:000039E0
.text$x:000039E0
.text$x:000039E0 __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0 proc near
.text$x:000039E0                                         ; DATA XREF: .xdata$x:00009B00o
.text$x:000039E0                 mov     ecx, [ebp-10h]  ; this
.text$x:000039E3                 jmp     ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$x:000039E3 __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0 endp
.text$x:000039E3
.text$x:000039E8
.text$x:000039E8 ; =============== S U B R O U T I N E =======================================
.text$x:000039E8
.text$x:000039E8
.text$x:000039E8 __ehhandler$??0_Generic_error_category@std@@QAE@XZ proc near
.text$x:000039E8                                         ; DATA XREF: std::_Generic_error_category::_Generic_error_category(void)+5o
.text$x:000039E8
.text$x:000039E8 arg_4           = dword ptr  8
.text$x:000039E8
.text$x:000039E8                 mov     edx, [esp+arg_4]
.text$x:000039EC                 lea     eax, [edx+0Ch]
.text$x:000039EF                 mov     ecx, [edx-8]
.text$x:000039F2                 xor     ecx, eax
.text$x:000039F4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000039F9                 mov     eax, offset __ehfuncinfo$??0_Generic_error_category@std@@QAE@XZ
.text$x:000039FE                 jmp     ___CxxFrameHandler3
.text$x:000039FE __ehhandler$??0_Generic_error_category@std@@QAE@XZ endp
.text$x:000039FE
.text$x:000039FE ; ---------------------------------------------------------------------------
.text$x:00003A03                 align 4
.text$x:00003A03 _text$x         ends
.text$x:00003A03
.text$mn:00003A04 ; ===========================================================================
.text$mn:00003A04
.text$mn:00003A04 ; Segment type: Pure code
.text$mn:00003A04 ; Segment permissions: Read/Execute
.text$mn:00003A04 _text$mn        segment para public 'CODE' use32
.text$mn:00003A04                 assume cs:_text$mn
.text$mn:00003A04                 ;org 3A04h
.text$mn:00003A04 ; COMDAT (pick any)
.text$mn:00003A04                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003A04
.text$mn:00003A04 ; =============== S U B R O U T I N E =======================================
.text$mn:00003A04
.text$mn:00003A04 ; Attributes: bp-based frame
.text$mn:00003A04
.text$mn:00003A04 ; _DWORD __thiscall std::_Ignore::_Ignore(std::_Ignore *__hidden this)
.text$mn:00003A04                 public ??0_Ignore@std@@QAE@XZ
.text$mn:00003A04 ??0_Ignore@std@@QAE@XZ proc near        ; CODE XREF: std::`dynamic initializer for 'ignore''(void)+8p
.text$mn:00003A04
.text$mn:00003A04 var_4           = dword ptr -4
.text$mn:00003A04
.text$mn:00003A04                 push    ebp
.text$mn:00003A05                 mov     ebp, esp
.text$mn:00003A07                 push    ecx
.text$mn:00003A08                 mov     [ebp+var_4], ecx
.text$mn:00003A0B                 mov     eax, [ebp+var_4]
.text$mn:00003A0E                 mov     esp, ebp
.text$mn:00003A10                 pop     ebp
.text$mn:00003A11                 retn
.text$mn:00003A11 ??0_Ignore@std@@QAE@XZ endp
.text$mn:00003A11
.text$mn:00003A11 ; ---------------------------------------------------------------------------
.text$mn:00003A12                 align 4
.text$mn:00003A12 _text$mn        ends
.text$mn:00003A12
.text$mn:00003A14 ; ===========================================================================
.text$mn:00003A14
.text$mn:00003A14 ; Segment type: Pure code
.text$mn:00003A14 ; Segment permissions: Read/Execute
.text$mn:00003A14 _text$mn        segment para public 'CODE' use32
.text$mn:00003A14                 assume cs:_text$mn
.text$mn:00003A14                 ;org 3A14h
.text$mn:00003A14 ; COMDAT (pick any)
.text$mn:00003A14                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003A14
.text$mn:00003A14 ; =============== S U B R O U T I N E =======================================
.text$mn:00003A14
.text$mn:00003A14 ; Attributes: bp-based frame
.text$mn:00003A14
.text$mn:00003A14 ; _DWORD __thiscall std::_Iostream_error_category::_Iostream_error_category(std::_Iostream_error_category *__hidden this)
.text$mn:00003A14                 public ??0_Iostream_error_category@std@@QAE@XZ
.text$mn:00003A14 ??0_Iostream_error_category@std@@QAE@XZ proc near
.text$mn:00003A14                                         ; CODE XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p
.text$mn:00003A14
.text$mn:00003A14 var_10          = dword ptr -10h
.text$mn:00003A14 var_C           = dword ptr -0Ch
.text$mn:00003A14 var_4           = dword ptr -4
.text$mn:00003A14
.text$mn:00003A14                 push    ebp
.text$mn:00003A15                 mov     ebp, esp
.text$mn:00003A17                 push    0FFFFFFFFh
.text$mn:00003A19                 push    offset __ehhandler$??0_Iostream_error_category@std@@QAE@XZ
.text$mn:00003A1E                 mov     eax, large fs:0
.text$mn:00003A24                 push    eax
.text$mn:00003A25                 push    ecx
.text$mn:00003A26                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003A2B                 xor     eax, ebp
.text$mn:00003A2D                 push    eax
.text$mn:00003A2E                 lea     eax, [ebp+var_C]
.text$mn:00003A31                 mov     large fs:0, eax
.text$mn:00003A37                 mov     [ebp+var_10], ecx
.text$mn:00003A3A                 mov     ecx, [ebp+var_10] ; this
.text$mn:00003A3D                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$mn:00003A42                 mov     [ebp+var_4], 0
.text$mn:00003A49                 mov     eax, [ebp+var_10]
.text$mn:00003A4C                 mov     dword ptr [eax], offset ??_7_Iostream_error_category@std@@6B@ ; const std::_Iostream_error_category::`vftable'
.text$mn:00003A52                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003A59                 mov     eax, [ebp+var_10]
.text$mn:00003A5C                 mov     ecx, [ebp+var_C]
.text$mn:00003A5F                 mov     large fs:0, ecx
.text$mn:00003A66                 pop     ecx
.text$mn:00003A67                 mov     esp, ebp
.text$mn:00003A69                 pop     ebp
.text$mn:00003A6A                 retn
.text$mn:00003A6A ??0_Iostream_error_category@std@@QAE@XZ endp
.text$mn:00003A6A
.text$mn:00003A6A ; ---------------------------------------------------------------------------
.text$mn:00003A6B                 align 4
.text$mn:00003A6B _text$mn        ends
.text$mn:00003A6B
.text$x:00003A6C ; ===========================================================================
.text$x:00003A6C
.text$x:00003A6C ; Segment type: Pure code
.text$x:00003A6C ; Segment permissions: Read/Execute
.text$x:00003A6C _text$x         segment para public 'CODE' use32
.text$x:00003A6C                 assume cs:_text$x
.text$x:00003A6C                 ;org 3A6Ch
.text$x:00003A6C ; COMDAT (pick associative to section at 3A14)
.text$x:00003A6C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00003A6C
.text$x:00003A6C ; =============== S U B R O U T I N E =======================================
.text$x:00003A6C
.text$x:00003A6C
.text$x:00003A6C __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0 proc near
.text$x:00003A6C                                         ; DATA XREF: .xdata$x:00009B84o
.text$x:00003A6C                 mov     ecx, [ebp-10h]  ; this
.text$x:00003A6F                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00003A6F __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0 endp
.text$x:00003A6F
.text$x:00003A74
.text$x:00003A74 ; =============== S U B R O U T I N E =======================================
.text$x:00003A74
.text$x:00003A74
.text$x:00003A74 __ehhandler$??0_Iostream_error_category@std@@QAE@XZ proc near
.text$x:00003A74                                         ; DATA XREF: std::_Iostream_error_category::_Iostream_error_category(void)+5o
.text$x:00003A74
.text$x:00003A74 arg_4           = dword ptr  8
.text$x:00003A74
.text$x:00003A74                 mov     edx, [esp+arg_4]
.text$x:00003A78                 lea     eax, [edx+0Ch]
.text$x:00003A7B                 mov     ecx, [edx-8]
.text$x:00003A7E                 xor     ecx, eax
.text$x:00003A80                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003A85                 mov     eax, offset __ehfuncinfo$??0_Iostream_error_category@std@@QAE@XZ
.text$x:00003A8A                 jmp     ___CxxFrameHandler3
.text$x:00003A8A __ehhandler$??0_Iostream_error_category@std@@QAE@XZ endp
.text$x:00003A8A
.text$x:00003A8A ; ---------------------------------------------------------------------------
.text$x:00003A8F                 align 10h
.text$x:00003A8F _text$x         ends
.text$x:00003A8F
.text$mn:00003A90 ; ===========================================================================
.text$mn:00003A90
.text$mn:00003A90 ; Segment type: Pure code
.text$mn:00003A90 ; Segment permissions: Read/Execute
.text$mn:00003A90 _text$mn        segment para public 'CODE' use32
.text$mn:00003A90                 assume cs:_text$mn
.text$mn:00003A90                 ;org 3A90h
.text$mn:00003A90 ; COMDAT (pick any)
.text$mn:00003A90                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003A90
.text$mn:00003A90 ; =============== S U B R O U T I N E =======================================
.text$mn:00003A90
.text$mn:00003A90 ; Attributes: bp-based frame
.text$mn:00003A90
.text$mn:00003A90 ; _DWORD __thiscall std::_Iterator_base12::_Iterator_base12(std::_Iterator_base12 *this, const struct std::_Iterator_base12 *)
.text$mn:00003A90                 public ??0_Iterator_base12@std@@QAE@ABU01@@Z
.text$mn:00003A90 ??0_Iterator_base12@std@@QAE@ABU01@@Z proc near
.text$mn:00003A90                                         ; CODE XREF: std::_Iterator012<std::random_access_iterator_tag,ScintillaEditView *,int,ScintillaEditView * const *,ScintillaEditView * const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,ScintillaEditView *,int,ScintillaEditView * const *,ScintillaEditView * const &,std::_Iterator_base12>(std::_Iterator012<std::random_access_iterator_tag,ScintillaEditView *,int,ScintillaEditView * const *,ScintillaEditView * const &,std::_Iterator_base12> const &)+2Dp
.text$mn:00003A90                                         ; std::_Iterator012<std::random_access_iterator_tag,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,int,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,int,std::_List_unchecked_iterator<std::_List_
.text$mn:00003A90
.text$mn:00003A90 var_4           = dword ptr -4
.text$mn:00003A90 arg_0           = dword ptr  8
.text$mn:00003A90
.text$mn:00003A90                 push    ebp
.text$mn:00003A91                 mov     ebp, esp
.text$mn:00003A93                 push    ecx
.text$mn:00003A94                 mov     [ebp+var_4], ecx
.text$mn:00003A97                 mov     eax, [ebp+var_4]
.text$mn:00003A9A                 mov     dword ptr [eax], 0
.text$mn:00003AA0                 mov     ecx, [ebp+var_4]
.text$mn:00003AA3                 mov     dword ptr [ecx+4], 0
.text$mn:00003AAA                 mov     edx, [ebp+arg_0]
.text$mn:00003AAD                 push    edx
.text$mn:00003AAE                 mov     ecx, [ebp+var_4]
.text$mn:00003AB1                 call    ??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z ; std::_Iterator_base12::operator=(std::_Iterator_base12 const &)
.text$mn:00003AB6                 mov     eax, [ebp+var_4]
.text$mn:00003AB9                 mov     esp, ebp
.text$mn:00003ABB                 pop     ebp
.text$mn:00003ABC                 retn    4
.text$mn:00003ABC ??0_Iterator_base12@std@@QAE@ABU01@@Z endp
.text$mn:00003ABC
.text$mn:00003ABC ; ---------------------------------------------------------------------------
.text$mn:00003ABF                 align 10h
.text$mn:00003ABF _text$mn        ends
.text$mn:00003ABF
.text$mn:00003AC0 ; ===========================================================================
.text$mn:00003AC0
.text$mn:00003AC0 ; Segment type: Pure code
.text$mn:00003AC0 ; Segment permissions: Read/Execute
.text$mn:00003AC0 _text$mn        segment para public 'CODE' use32
.text$mn:00003AC0                 assume cs:_text$mn
.text$mn:00003AC0                 ;org 3AC0h
.text$mn:00003AC0 ; COMDAT (pick any)
.text$mn:00003AC0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003AC0
.text$mn:00003AC0 ; =============== S U B R O U T I N E =======================================
.text$mn:00003AC0
.text$mn:00003AC0 ; Attributes: bp-based frame
.text$mn:00003AC0
.text$mn:00003AC0 ; _DWORD __thiscall std::_Iterator_base12::_Iterator_base12(std::_Iterator_base12 *__hidden this)
.text$mn:00003AC0                 public ??0_Iterator_base12@std@@QAE@XZ
.text$mn:00003AC0 ??0_Iterator_base12@std@@QAE@XZ proc near
.text$mn:00003AC0                                         ; CODE XREF: std::_Iterator012<std::bidirectional_iterator_tag,std::pair<int const,Style>,int,std::pair<int const,Style> const *,std::pair<int const,Style> const &,std::_Iterator_base12>::_Iterator012<std::bidirectional_iterator_tag,std::pair<int const,Style>,int,std::pair<int const,Style> const *,std::pair<int const,Style> const &,std::_Iterator_base12>(void)+29p
.text$mn:00003AC0                                         ; std::_Iterator012<std::bidirectional_iterator_tag,std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,int,std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *> const *,std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *> const &,std::_Iterator_base12>::_Iterator012<std::bidirectional_iterator_tag,std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,int,std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *> const *,std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *> const &,std::_Iterator_base12>(void)+29p ...
.text$mn:00003AC0
.text$mn:00003AC0 var_4           = dword ptr -4
.text$mn:00003AC0
.text$mn:00003AC0                 push    ebp
.text$mn:00003AC1                 mov     ebp, esp
.text$mn:00003AC3                 push    ecx
.text$mn:00003AC4                 mov     [ebp+var_4], ecx
.text$mn:00003AC7                 mov     eax, [ebp+var_4]
.text$mn:00003ACA                 mov     dword ptr [eax], 0
.text$mn:00003AD0                 mov     ecx, [ebp+var_4]
.text$mn:00003AD3                 mov     dword ptr [ecx+4], 0
.text$mn:00003ADA                 mov     eax, [ebp+var_4]
.text$mn:00003ADD                 mov     esp, ebp
.text$mn:00003ADF                 pop     ebp
.text$mn:00003AE0                 retn
.text$mn:00003AE0 ??0_Iterator_base12@std@@QAE@XZ endp
.text$mn:00003AE0
.text$mn:00003AE0 ; ---------------------------------------------------------------------------
.text$mn:00003AE1                 align 4
.text$mn:00003AE1 _text$mn        ends
.text$mn:00003AE1
.text$mn:00003AE4 ; ===========================================================================
.text$mn:00003AE4
.text$mn:00003AE4 ; Segment type: Pure code
.text$mn:00003AE4 ; Segment permissions: Read/Execute
.text$mn:00003AE4 _text$mn        segment para public 'CODE' use32
.text$mn:00003AE4                 assume cs:_text$mn
.text$mn:00003AE4                 ;org 3AE4h
.text$mn:00003AE4 ; COMDAT (pick any)
.text$mn:00003AE4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003AE4
.text$mn:00003AE4 ; =============== S U B R O U T I N E =======================================
.text$mn:00003AE4
.text$mn:00003AE4 ; Attributes: bp-based frame
.text$mn:00003AE4
.text$mn:00003AE4 ; _DWORD __thiscall std::_System_error_category::_System_error_category(std::_System_error_category *__hidden this)
.text$mn:00003AE4                 public ??0_System_error_category@std@@QAE@XZ
.text$mn:00003AE4 ??0_System_error_category@std@@QAE@XZ proc near
.text$mn:00003AE4                                         ; CODE XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p
.text$mn:00003AE4
.text$mn:00003AE4 var_10          = dword ptr -10h
.text$mn:00003AE4 var_C           = dword ptr -0Ch
.text$mn:00003AE4 var_4           = dword ptr -4
.text$mn:00003AE4
.text$mn:00003AE4                 push    ebp
.text$mn:00003AE5                 mov     ebp, esp
.text$mn:00003AE7                 push    0FFFFFFFFh
.text$mn:00003AE9                 push    offset __ehhandler$??0_System_error_category@std@@QAE@XZ
.text$mn:00003AEE                 mov     eax, large fs:0
.text$mn:00003AF4                 push    eax
.text$mn:00003AF5                 push    ecx
.text$mn:00003AF6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003AFB                 xor     eax, ebp
.text$mn:00003AFD                 push    eax
.text$mn:00003AFE                 lea     eax, [ebp+var_C]
.text$mn:00003B01                 mov     large fs:0, eax
.text$mn:00003B07                 mov     [ebp+var_10], ecx
.text$mn:00003B0A                 mov     ecx, [ebp+var_10] ; this
.text$mn:00003B0D                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$mn:00003B12                 mov     [ebp+var_4], 0
.text$mn:00003B19                 mov     eax, [ebp+var_10]
.text$mn:00003B1C                 mov     dword ptr [eax], offset ??_7_System_error_category@std@@6B@ ; const std::_System_error_category::`vftable'
.text$mn:00003B22                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003B29                 mov     eax, [ebp+var_10]
.text$mn:00003B2C                 mov     ecx, [ebp+var_C]
.text$mn:00003B2F                 mov     large fs:0, ecx
.text$mn:00003B36                 pop     ecx
.text$mn:00003B37                 mov     esp, ebp
.text$mn:00003B39                 pop     ebp
.text$mn:00003B3A                 retn
.text$mn:00003B3A ??0_System_error_category@std@@QAE@XZ endp
.text$mn:00003B3A
.text$mn:00003B3A ; ---------------------------------------------------------------------------
.text$mn:00003B3B                 align 4
.text$mn:00003B3B _text$mn        ends
.text$mn:00003B3B
.text$x:00003B3C ; ===========================================================================
.text$x:00003B3C
.text$x:00003B3C ; Segment type: Pure code
.text$x:00003B3C ; Segment permissions: Read/Execute
.text$x:00003B3C _text$x         segment para public 'CODE' use32
.text$x:00003B3C                 assume cs:_text$x
.text$x:00003B3C                 ;org 3B3Ch
.text$x:00003B3C ; COMDAT (pick associative to section at 3AE4)
.text$x:00003B3C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00003B3C
.text$x:00003B3C ; =============== S U B R O U T I N E =======================================
.text$x:00003B3C
.text$x:00003B3C
.text$x:00003B3C __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0 proc near
.text$x:00003B3C                                         ; DATA XREF: .xdata$x:00009C08o
.text$x:00003B3C                 mov     ecx, [ebp-10h]  ; this
.text$x:00003B3F                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00003B3F __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0 endp
.text$x:00003B3F
.text$x:00003B44
.text$x:00003B44 ; =============== S U B R O U T I N E =======================================
.text$x:00003B44
.text$x:00003B44
.text$x:00003B44 __ehhandler$??0_System_error_category@std@@QAE@XZ proc near
.text$x:00003B44                                         ; DATA XREF: std::_System_error_category::_System_error_category(void)+5o
.text$x:00003B44
.text$x:00003B44 arg_4           = dword ptr  8
.text$x:00003B44
.text$x:00003B44                 mov     edx, [esp+arg_4]
.text$x:00003B48                 lea     eax, [edx+0Ch]
.text$x:00003B4B                 mov     ecx, [edx-8]
.text$x:00003B4E                 xor     ecx, eax
.text$x:00003B50                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003B55                 mov     eax, offset __ehfuncinfo$??0_System_error_category@std@@QAE@XZ
.text$x:00003B5A                 jmp     ___CxxFrameHandler3
.text$x:00003B5A __ehhandler$??0_System_error_category@std@@QAE@XZ endp
.text$x:00003B5A
.text$x:00003B5A ; ---------------------------------------------------------------------------
.text$x:00003B5F                 align 10h
.text$x:00003B5F _text$x         ends
.text$x:00003B5F
.text$mn:00003B60 ; ===========================================================================
.text$mn:00003B60
.text$mn:00003B60 ; Segment type: Pure code
.text$mn:00003B60 ; Segment permissions: Read/Execute
.text$mn:00003B60 _text$mn        segment para public 'CODE' use32
.text$mn:00003B60                 assume cs:_text$mn
.text$mn:00003B60                 ;org 3B60h
.text$mn:00003B60 ; COMDAT (pick any)
.text$mn:00003B60                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003B60
.text$mn:00003B60 ; =============== S U B R O U T I N E =======================================
.text$mn:00003B60
.text$mn:00003B60 ; Attributes: bp-based frame
.text$mn:00003B60
.text$mn:00003B60 ; _DWORD __thiscall std::error_category::error_category(std::error_category *__hidden this)
.text$mn:00003B60                 public ??0error_category@std@@QAE@XZ
.text$mn:00003B60 ??0error_category@std@@QAE@XZ proc near ; CODE XREF: std::_Generic_error_category::_Generic_error_category(void)+29p
.text$mn:00003B60
.text$mn:00003B60 var_4           = dword ptr -4
.text$mn:00003B60
.text$mn:00003B60                 push    ebp
.text$mn:00003B61                 mov     ebp, esp
.text$mn:00003B63                 push    ecx
.text$mn:00003B64                 mov     [ebp+var_4], ecx
.text$mn:00003B67                 mov     eax, [ebp+var_4]
.text$mn:00003B6A                 mov     dword ptr [eax], offset ??_7error_category@std@@6B@ ; const std::error_category::`vftable'
.text$mn:00003B70                 mov     eax, [ebp+var_4]
.text$mn:00003B73                 mov     esp, ebp
.text$mn:00003B75                 pop     ebp
.text$mn:00003B76                 retn
.text$mn:00003B76 ??0error_category@std@@QAE@XZ endp
.text$mn:00003B76
.text$mn:00003B76 ; ---------------------------------------------------------------------------
.text$mn:00003B77                 align 4
.text$mn:00003B77 _text$mn        ends
.text$mn:00003B77
.text$mn:00003B78 ; ===========================================================================
.text$mn:00003B78
.text$mn:00003B78 ; Segment type: Pure code
.text$mn:00003B78 ; Segment permissions: Read/Execute
.text$mn:00003B78 _text$mn        segment para public 'CODE' use32
.text$mn:00003B78                 assume cs:_text$mn
.text$mn:00003B78                 ;org 3B78h
.text$mn:00003B78 ; COMDAT (pick any)
.text$mn:00003B78                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003B78
.text$mn:00003B78 ; =============== S U B R O U T I N E =======================================
.text$mn:00003B78
.text$mn:00003B78 ; Attributes: bp-based frame
.text$mn:00003B78
.text$mn:00003B78 ; _DWORD __thiscall std::error_condition::error_condition(std::error_condition *this, int, const struct std::error_category *)
.text$mn:00003B78                 public ??0error_condition@std@@QAE@HABVerror_category@1@@Z
.text$mn:00003B78 ??0error_condition@std@@QAE@HABVerror_category@1@@Z proc near
.text$mn:00003B78                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+24p
.text$mn:00003B78                                         ; std::_System_error_category::default_error_condition(int)+3Dp ...
.text$mn:00003B78
.text$mn:00003B78 var_4           = dword ptr -4
.text$mn:00003B78 arg_0           = dword ptr  8
.text$mn:00003B78 arg_4           = dword ptr  0Ch
.text$mn:00003B78
.text$mn:00003B78                 push    ebp
.text$mn:00003B79                 mov     ebp, esp
.text$mn:00003B7B                 push    ecx
.text$mn:00003B7C                 mov     [ebp+var_4], ecx
.text$mn:00003B7F                 mov     eax, [ebp+var_4]
.text$mn:00003B82                 mov     ecx, [ebp+arg_0]
.text$mn:00003B85                 mov     [eax], ecx
.text$mn:00003B87                 mov     edx, [ebp+var_4]
.text$mn:00003B8A                 mov     eax, [ebp+arg_4]
.text$mn:00003B8D                 mov     [edx+4], eax
.text$mn:00003B90                 mov     eax, [ebp+var_4]
.text$mn:00003B93                 mov     esp, ebp
.text$mn:00003B95                 pop     ebp
.text$mn:00003B96                 retn    8
.text$mn:00003B96 ??0error_condition@std@@QAE@HABVerror_category@1@@Z endp
.text$mn:00003B96
.text$mn:00003B96 ; ---------------------------------------------------------------------------
.text$mn:00003B99                 align 4
.text$mn:00003B99 _text$mn        ends
.text$mn:00003B99
.text$mn:00003B9C ; ===========================================================================
.text$mn:00003B9C
.text$mn:00003B9C ; Segment type: Pure code
.text$mn:00003B9C ; Segment permissions: Read/Execute
.text$mn:00003B9C _text$mn        segment para public 'CODE' use32
.text$mn:00003B9C                 assume cs:_text$mn
.text$mn:00003B9C                 ;org 3B9Ch
.text$mn:00003B9C ; COMDAT (pick any)
.text$mn:00003B9C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003B9C
.text$mn:00003B9C ; =============== S U B R O U T I N E =======================================
.text$mn:00003B9C
.text$mn:00003B9C ; Attributes: bp-based frame
.text$mn:00003B9C
.text$mn:00003B9C ; _DWORD __thiscall std::locale::id::id(std::locale::id *this, unsigned int)
.text$mn:00003B9C                 public ??0id@locale@std@@QAE@I@Z
.text$mn:00003B9C ??0id@locale@std@@QAE@I@Z proc near     ; CODE XREF: `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)+Ap
.text$mn:00003B9C                                         ; `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)+Ap ...
.text$mn:00003B9C
.text$mn:00003B9C var_4           = dword ptr -4
.text$mn:00003B9C arg_0           = dword ptr  8
.text$mn:00003B9C
.text$mn:00003B9C                 push    ebp
.text$mn:00003B9D                 mov     ebp, esp
.text$mn:00003B9F                 push    ecx
.text$mn:00003BA0                 mov     [ebp+var_4], ecx
.text$mn:00003BA3                 mov     eax, [ebp+var_4]
.text$mn:00003BA6                 mov     ecx, [ebp+arg_0]
.text$mn:00003BA9                 mov     [eax], ecx
.text$mn:00003BAB                 mov     eax, [ebp+var_4]
.text$mn:00003BAE                 mov     esp, ebp
.text$mn:00003BB0                 pop     ebp
.text$mn:00003BB1                 retn    4
.text$mn:00003BB1 ??0id@locale@std@@QAE@I@Z endp
.text$mn:00003BB1
.text$mn:00003BB1 _text$mn        ends
.text$mn:00003BB1
.text$mn:00003BB4 ; ===========================================================================
.text$mn:00003BB4
.text$mn:00003BB4 ; Segment type: Pure code
.text$mn:00003BB4 ; Segment permissions: Read/Execute
.text$mn:00003BB4 _text$mn        segment para public 'CODE' use32
.text$mn:00003BB4                 assume cs:_text$mn
.text$mn:00003BB4                 ;org 3BB4h
.text$mn:00003BB4 ; COMDAT (pick any)
.text$mn:00003BB4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003BB4
.text$mn:00003BB4 ; =============== S U B R O U T I N E =======================================
.text$mn:00003BB4
.text$mn:00003BB4 ; Attributes: bp-based frame
.text$mn:00003BB4
.text$mn:00003BB4 ; public: __thiscall std::_Hash<class std::_Umap_traits<int, struct Style, class std::_Uhash_compare<int, struct std::hash<int>, struct std::equal_to<int>>, class std::allocator<struct std::pair<int const, struct Style>>, 0>>::~_Hash<class std::_Umap_traits<int, struct Style, class std::_Uhash_compare<int, struct std::hash<int>, struct std::equal_to<int>>, class std::allocator<struct std::pair<int const, struct Style>>, 0>>(void)
.text$mn:00003BB4                 public ??1?$_Hash@V?$_Umap_traits@HUStyle@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@$0A@@std@@@std@@QAE@XZ
.text$mn:00003BB4 ??1?$_Hash@V?$_Umap_traits@HUStyle@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@$0A@@std@@@std@@QAE@XZ proc near
.text$mn:00003BB4                                         ; CODE XREF: std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>>::~unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>>(void)+37p
.text$mn:00003BB4                                         ; __unwindfunclet$??1?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@QAE@XZ$0+3j
.text$mn:00003BB4
.text$mn:00003BB4 var_10          = dword ptr -10h
.text$mn:00003BB4 var_C           = dword ptr -0Ch
.text$mn:00003BB4 var_4           = dword ptr -4
.text$mn:00003BB4
.text$mn:00003BB4                 push    ebp
.text$mn:00003BB5                 mov     ebp, esp
.text$mn:00003BB7                 push    0FFFFFFFFh
.text$mn:00003BB9                 push    offset __ehhandler$??1?$_Hash@V?$_Umap_traits@HUStyle@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@$0A@@std@@@std@@QAE@XZ
.text$mn:00003BBE                 mov     eax, large fs:0
.text$mn:00003BC4                 push    eax
.text$mn:00003BC5                 push    ecx
.text$mn:00003BC6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003BCB                 xor     eax, ebp
.text$mn:00003BCD                 push    eax
.text$mn:00003BCE                 lea     eax, [ebp+var_C]
.text$mn:00003BD1                 mov     large fs:0, eax
.text$mn:00003BD7                 mov     [ebp+var_10], ecx
.text$mn:00003BDA                 mov     [ebp+var_4], 1
.text$mn:00003BE1                 mov     byte ptr [ebp+var_4], 0
.text$mn:00003BE5                 mov     ecx, [ebp+var_10]
.text$mn:00003BE8                 add     ecx, 0Ch
.text$mn:00003BEB                 call    ??1?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAE@XZ ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>>>>::~vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>>>>(void)
.text$mn:00003BF0                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003BF7                 mov     ecx, [ebp+var_10]
.text$mn:00003BFA                 call    ??1?$list@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@QAE@XZ ; std::list<std::pair<int const,Style>,std::allocator<std::pair<int const,Style>>>::~list<std::pair<int const,Style>,std::allocator<std::pair<int const,Style>>>(void)
.text$mn:00003BFF                 mov     ecx, [ebp+var_C]
.text$mn:00003C02                 mov     large fs:0, ecx
.text$mn:00003C09                 pop     ecx
.text$mn:00003C0A                 mov     esp, ebp
.text$mn:00003C0C                 pop     ebp
.text$mn:00003C0D                 retn
.text$mn:00003C0D ??1?$_Hash@V?$_Umap_traits@HUStyle@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@$0A@@std@@@std@@QAE@XZ endp
.text$mn:00003C0D
.text$mn:00003C0D ; ---------------------------------------------------------------------------
.text$mn:00003C0E                 align 10h
.text$mn:00003C0E _text$mn        ends
.text$mn:00003C0E
.text$x:00003C10 ; ===========================================================================
.text$x:00003C10
.text$x:00003C10 ; Segment type: Pure code
.text$x:00003C10 ; Segment permissions: Read/Execute
.text$x:00003C10 _text$x         segment para public 'CODE' use32
.text$x:00003C10                 assume cs:_text$x
.text$x:00003C10                 ;org 3C10h
.text$x:00003C10 ; COMDAT (pick associative to section at 3BB4)
.text$x:00003C10                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00003C10
.text$x:00003C10 ; =============== S U B R O U T I N E =======================================
.text$x:00003C10
.text$x:00003C10
.text$x:00003C10 __unwindfunclet$??1?$_Hash@V?$_Umap_traits@HUStyle@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@$0A@@std@@@std@@QAE@XZ$0 proc near
.text$x:00003C10                                         ; DATA XREF: .xdata$x:0000A628o
.text$x:00003C10                 mov     ecx, [ebp-10h]
.text$x:00003C13                 jmp     ??1?$list@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@QAE@XZ ; std::list<std::pair<int const,Style>,std::allocator<std::pair<int const,Style>>>::~list<std::pair<int const,Style>,std::allocator<std::pair<int const,Style>>>(void)
.text$x:00003C13 __unwindfunclet$??1?$_Hash@V?$_Umap_traits@HUStyle@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@$0A@@std@@@std@@QAE@XZ$0 endp
.text$x:00003C13
.text$x:00003C18
.text$x:00003C18 ; =============== S U B R O U T I N E =======================================
.text$x:00003C18
.text$x:00003C18
.text$x:00003C18 __unwindfunclet$??1?$_Hash@V?$_Umap_traits@HUStyle@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@$0A@@std@@@std@@QAE@XZ$1 proc near
.text$x:00003C18                                         ; DATA XREF: .xdata$x:0000A630o
.text$x:00003C18                 mov     ecx, [ebp-10h]
.text$x:00003C1B                 add     ecx, 0Ch
.text$x:00003C1E                 jmp     ??1?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAE@XZ ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>>>>::~vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>>>>(void)
.text$x:00003C1E __unwindfunclet$??1?$_Hash@V?$_Umap_traits@HUStyle@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@$0A@@std@@@std@@QAE@XZ$1 endp
.text$x:00003C1E
.text$x:00003C23
.text$x:00003C23 ; =============== S U B R O U T I N E =======================================
.text$x:00003C23
.text$x:00003C23
.text$x:00003C23 __ehhandler$??1?$_Hash@V?$_Umap_traits@HUStyle@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@$0A@@std@@@std@@QAE@XZ proc near
.text$x:00003C23                                         ; DATA XREF: std::_Hash<std::_Umap_traits<int,Style,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int>>,std::allocator<std::pair<int const,Style>>,0>>::~_Hash<std::_Umap_traits<int,Style,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int>>,std::allocator<std::pair<int const,Style>>,0>>(void)+5o
.text$x:00003C23
.text$x:00003C23 arg_4           = dword ptr  8
.text$x:00003C23
.text$x:00003C23                 mov     edx, [esp+arg_4]
.text$x:00003C27                 lea     eax, [edx+0Ch]
.text$x:00003C2A                 mov     ecx, [edx-8]
.text$x:00003C2D                 xor     ecx, eax
.text$x:00003C2F                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003C34                 mov     eax, offset __ehfuncinfo$??1?$_Hash@V?$_Umap_traits@HUStyle@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@$0A@@std@@@std@@QAE@XZ
.text$x:00003C39                 jmp     ___CxxFrameHandler3
.text$x:00003C39 __ehhandler$??1?$_Hash@V?$_Umap_traits@HUStyle@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@$0A@@std@@@std@@QAE@XZ endp
.text$x:00003C39
.text$x:00003C39 ; ---------------------------------------------------------------------------
.text$x:00003C3E                 align 10h
.text$x:00003C3E _text$x         ends
.text$x:00003C3E
.text$mn:00003C40 ; ===========================================================================
.text$mn:00003C40
.text$mn:00003C40 ; Segment type: Pure code
.text$mn:00003C40 ; Segment permissions: Read/Execute
.text$mn:00003C40 _text$mn        segment para public 'CODE' use32
.text$mn:00003C40                 assume cs:_text$mn
.text$mn:00003C40                 ;org 3C40h
.text$mn:00003C40 ; COMDAT (pick any)
.text$mn:00003C40                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003C40
.text$mn:00003C40 ; =============== S U B R O U T I N E =======================================
.text$mn:00003C40
.text$mn:00003C40 ; Attributes: bp-based frame
.text$mn:00003C40
.text$mn:00003C40 ; public: __thiscall std::_Hash<class std::_Umap_traits<class Buffer *, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *, class std::_Uhash_compare<class Buffer *, struct std::hash<class Buffer *>, struct std::equal_to<class Buffer *>>, class std::allocator<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>, 0>>::~_Hash<class std::_Umap_traits<class Buffer *, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *, class std::_Uhash_compare<class Buffer *, struct std::hash<class Buffer *>, struct std::equal_to<class Buffer *>>, class std::allocator<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::has
.text$mn:00003C40                 public ??1?$_Hash@V?$_Umap_traits@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@V?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@$0A@@std@@@std@@QAE@XZ
.text$mn:00003C40 ??1?$_Hash@V?$_Umap_traits@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@V?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@$0A@@std@@@std@@QAE@XZ proc near
.text$mn:00003C40                                         ; CODE XREF: __unwindfunclet$??0?$unordered_map@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@U?$hash@PAVBuffer@@@3@U?$equal_to@PAVBuffer@@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@@std@@QAE@XZ$0+3j
.text$mn:00003C40                                         ; std::unordered_map<Buffer *,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *,std::hash<Buffer *>,std::equal_to<Buffer *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>::~unordered_map<Buffer *,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *,std::hash<Buffer *>,std::equal_to<Buffer *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>(void)+37p ...
.text$mn:00003C40
.text$mn:00003C40 var_10          = dword ptr -10h
.text$mn:00003C40 var_C           = dword ptr -0Ch
.text$mn:00003C40 var_4           = dword ptr -4
.text$mn:00003C40
.text$mn:00003C40                 push    ebp
.text$mn:00003C41                 mov     ebp, esp
.text$mn:00003C43                 push    0FFFFFFFFh
.text$mn:00003C45                 push    offset __ehhandler$??1?$_Hash@V?$_Umap_traits@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@V?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@$0A@@std@@@std@@QAE@XZ
.text$mn:00003C4A                 mov     eax, large fs:0
.text$mn:00003C50                 push    eax
.text$mn:00003C51                 push    ecx
.text$mn:00003C52                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003C57                 xor     eax, ebp
.text$mn:00003C59                 push    eax
.text$mn:00003C5A                 lea     eax, [ebp+var_C]
.text$mn:00003C5D                 mov     large fs:0, eax
.text$mn:00003C63                 mov     [ebp+var_10], ecx
.text$mn:00003C66                 mov     [ebp+var_4], 1
.text$mn:00003C6D                 mov     byte ptr [ebp+var_4], 0
.text$mn:00003C71                 mov     ecx, [ebp+var_10]
.text$mn:00003C74                 add     ecx, 0Ch
.text$mn:00003C77                 call    ??1?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAE@XZ ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::~vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>(void)
.text$mn:00003C7C                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003C83                 mov     ecx, [ebp+var_10]
.text$mn:00003C86                 call    ??1?$list@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAE@XZ ; std::list<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>::~list<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>(void)
.text$mn:00003C8B                 mov     ecx, [ebp+var_C]
.text$mn:00003C8E                 mov     large fs:0, ecx
.text$mn:00003C95                 pop     ecx
.text$mn:00003C96                 mov     esp, ebp
.text$mn:00003C98                 pop     ebp
.text$mn:00003C99                 retn
.text$mn:00003C99 ??1?$_Hash@V?$_Umap_traits@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@V?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@$0A@@std@@@std@@QAE@XZ endp
.text$mn:00003C99
.text$mn:00003C99 ; ---------------------------------------------------------------------------
.text$mn:00003C9A                 align 4
.text$mn:00003C9A _text$mn        ends
.text$mn:00003C9A
.text$x:00003C9C ; ===========================================================================
.text$x:00003C9C
.text$x:00003C9C ; Segment type: Pure code
.text$x:00003C9C ; Segment permissions: Read/Execute
.text$x:00003C9C _text$x         segment para public 'CODE' use32
.text$x:00003C9C                 assume cs:_text$x
.text$x:00003C9C                 ;org 3C9Ch
.text$x:00003C9C ; COMDAT (pick associative to section at 3C40)
.text$x:00003C9C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00003C9C
.text$x:00003C9C ; =============== S U B R O U T I N E =======================================
.text$x:00003C9C
.text$x:00003C9C
.text$x:00003C9C __unwindfunclet$??1?$_Hash@V?$_Umap_traits@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@V?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@$0A@@std@@@std@@QAE@XZ$0 proc near
.text$x:00003C9C                                         ; DATA XREF: .xdata$x:0000A03Co
.text$x:00003C9C                 mov     ecx, [ebp-10h]
.text$x:00003C9F                 jmp     ??1?$list@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAE@XZ ; std::list<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>::~list<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>(void)
.text$x:00003C9F __unwindfunclet$??1?$_Hash@V?$_Umap_traits@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@V?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@$0A@@std@@@std@@QAE@XZ$0 endp
.text$x:00003C9F
.text$x:00003CA4
.text$x:00003CA4 ; =============== S U B R O U T I N E =======================================
.text$x:00003CA4
.text$x:00003CA4
.text$x:00003CA4 __unwindfunclet$??1?$_Hash@V?$_Umap_traits@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@V?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@$0A@@std@@@std@@QAE@XZ$1 proc near
.text$x:00003CA4                                         ; DATA XREF: .xdata$x:0000A044o
.text$x:00003CA4                 mov     ecx, [ebp-10h]
.text$x:00003CA7                 add     ecx, 0Ch
.text$x:00003CAA                 jmp     ??1?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAE@XZ ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::~vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>(void)
.text$x:00003CAA __unwindfunclet$??1?$_Hash@V?$_Umap_traits@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@V?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@$0A@@std@@@std@@QAE@XZ$1 endp
.text$x:00003CAA
.text$x:00003CAF
.text$x:00003CAF ; =============== S U B R O U T I N E =======================================
.text$x:00003CAF
.text$x:00003CAF
.text$x:00003CAF __ehhandler$??1?$_Hash@V?$_Umap_traits@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@V?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@$0A@@std@@@std@@QAE@XZ proc near
.text$x:00003CAF                                         ; DATA XREF: std::_Hash<std::_Umap_traits<Buffer *,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *,std::_Uhash_compare<Buffer *,std::hash<Buffer *>,std::equal_to<Buffer *>>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>,0>>::~_Hash<std::_Umap_traits<Buffer *,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *,std::_Uhash_compare<Buffer *,std::hash<Buffer *>,std::equal_to<Buffer *>>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>,0>>(void)+5o
.text$x:00003CAF
.text$x:00003CAF arg_4           = dword ptr  8
.text$x:00003CAF
.text$x:00003CAF                 mov     edx, [esp+arg_4]
.text$x:00003CB3                 lea     eax, [edx+0Ch]
.text$x:00003CB6                 mov     ecx, [edx-8]
.text$x:00003CB9                 xor     ecx, eax
.text$x:00003CBB                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003CC0                 mov     eax, offset __ehfuncinfo$??1?$_Hash@V?$_Umap_traits@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@V?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@$0A@@std@@@std@@QAE@XZ
.text$x:00003CC5                 jmp     ___CxxFrameHandler3
.text$x:00003CC5 __ehhandler$??1?$_Hash@V?$_Umap_traits@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@V?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@$0A@@std@@@std@@QAE@XZ endp
.text$x:00003CC5
.text$x:00003CC5 ; ---------------------------------------------------------------------------
.text$x:00003CCA                 align 4
.text$x:00003CCA _text$x         ends
.text$x:00003CCA
.text$mn:00003CCC ; ===========================================================================
.text$mn:00003CCC
.text$mn:00003CCC ; Segment type: Pure code
.text$mn:00003CCC ; Segment permissions: Read/Execute
.text$mn:00003CCC _text$mn        segment para public 'CODE' use32
.text$mn:00003CCC                 assume cs:_text$mn
.text$mn:00003CCC                 ;org 3CCCh
.text$mn:00003CCC ; COMDAT (pick any)
.text$mn:00003CCC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003CCC
.text$mn:00003CCC ; =============== S U B R O U T I N E =======================================
.text$mn:00003CCC
.text$mn:00003CCC ; Attributes: bp-based frame
.text$mn:00003CCC
.text$mn:00003CCC ; public: __thiscall std::_Iterator012<struct std::bidirectional_iterator_tag, struct std::pair<int const, struct Style>, int, struct std::pair<int const, struct Style> const *, struct std::pair<int const, struct Style> const &, struct std::_Iterator_base12>::~_Iterator012<struct std::bidirectional_iterator_tag, struct std::pair<int const, struct Style>, int, struct std::pair<int const, struct Style> const *, struct std::pair<int const, struct Style> const &, struct std::_Iterator_base12>(void)
.text$mn:00003CCC                 public ??1?$_Iterator012@Ubidirectional_iterator_tag@std@@U?$pair@$$CBHUStyle@@@2@HPBU32@ABU32@U_Iterator_base12@2@@std@@QAE@XZ
.text$mn:00003CCC ??1?$_Iterator012@Ubidirectional_iterator_tag@std@@U?$pair@$$CBHUStyle@@@2@HPBU32@ABU32@U_Iterator_base12@2@@std@@QAE@XZ proc near
.text$mn:00003CCC                                         ; CODE XREF: __unwindfunclet$??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QAE@PAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@1@@Z$0+3j
.text$mn:00003CCC                                         ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>,std::_Iterator_base12>::~_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>,std::_Iterator_base12>(void)+37p ...
.text$mn:00003CCC
.text$mn:00003CCC var_10          = dword ptr -10h
.text$mn:00003CCC var_C           = dword ptr -0Ch
.text$mn:00003CCC var_4           = dword ptr -4
.text$mn:00003CCC
.text$mn:00003CCC                 push    ebp
.text$mn:00003CCD                 mov     ebp, esp
.text$mn:00003CCF                 push    0FFFFFFFFh
.text$mn:00003CD1                 push    offset __ehhandler$??1?$_Iterator012@Ubidirectional_iterator_tag@std@@U?$pair@$$CBHUStyle@@@2@HPBU32@ABU32@U_Iterator_base12@2@@std@@QAE@XZ
.text$mn:00003CD6                 mov     eax, large fs:0
.text$mn:00003CDC                 push    eax
.text$mn:00003CDD                 push    ecx
.text$mn:00003CDE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003CE3                 xor     eax, ebp
.text$mn:00003CE5                 push    eax
.text$mn:00003CE6                 lea     eax, [ebp+var_C]
.text$mn:00003CE9                 mov     large fs:0, eax
.text$mn:00003CEF                 mov     [ebp+var_10], ecx
.text$mn:00003CF2                 mov     [ebp+var_4], 0
.text$mn:00003CF9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003D00                 mov     ecx, [ebp+var_10] ; this
.text$mn:00003D03                 call    ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$mn:00003D08                 mov     ecx, [ebp+var_C]
.text$mn:00003D0B                 mov     large fs:0, ecx
.text$mn:00003D12                 pop     ecx
.text$mn:00003D13                 mov     esp, ebp
.text$mn:00003D15                 pop     ebp
.text$mn:00003D16                 retn
.text$mn:00003D16 ??1?$_Iterator012@Ubidirectional_iterator_tag@std@@U?$pair@$$CBHUStyle@@@2@HPBU32@ABU32@U_Iterator_base12@2@@std@@QAE@XZ endp
.text$mn:00003D16
.text$mn:00003D16 ; ---------------------------------------------------------------------------
.text$mn:00003D17                 align 4
.text$mn:00003D17 _text$mn        ends
.text$mn:00003D17
.text$x:00003D18 ; ===========================================================================
.text$x:00003D18
.text$x:00003D18 ; Segment type: Pure code
.text$x:00003D18 ; Segment permissions: Read/Execute
.text$x:00003D18 _text$x         segment para public 'CODE' use32
.text$x:00003D18                 assume cs:_text$x
.text$x:00003D18                 ;org 3D18h
.text$x:00003D18 ; COMDAT (pick associative to section at 3CCC)
.text$x:00003D18                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00003D18
.text$x:00003D18 ; =============== S U B R O U T I N E =======================================
.text$x:00003D18
.text$x:00003D18
.text$x:00003D18 __unwindfunclet$??1?$_Iterator012@Ubidirectional_iterator_tag@std@@U?$pair@$$CBHUStyle@@@2@HPBU32@ABU32@U_Iterator_base12@2@@std@@QAE@XZ$0 proc near
.text$x:00003D18                                         ; DATA XREF: .xdata$x:0000A790o
.text$x:00003D18                 mov     ecx, [ebp-10h]  ; this
.text$x:00003D1B                 jmp     ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$x:00003D1B __unwindfunclet$??1?$_Iterator012@Ubidirectional_iterator_tag@std@@U?$pair@$$CBHUStyle@@@2@HPBU32@ABU32@U_Iterator_base12@2@@std@@QAE@XZ$0 endp
.text$x:00003D1B
.text$x:00003D20
.text$x:00003D20 ; =============== S U B R O U T I N E =======================================
.text$x:00003D20
.text$x:00003D20
.text$x:00003D20 __ehhandler$??1?$_Iterator012@Ubidirectional_iterator_tag@std@@U?$pair@$$CBHUStyle@@@2@HPBU32@ABU32@U_Iterator_base12@2@@std@@QAE@XZ proc near
.text$x:00003D20                                         ; DATA XREF: std::_Iterator012<std::bidirectional_iterator_tag,std::pair<int const,Style>,int,std::pair<int const,Style> const *,std::pair<int const,Style> const &,std::_Iterator_base12>::~_Iterator012<std::bidirectional_iterator_tag,std::pair<int const,Style>,int,std::pair<int const,Style> const *,std::pair<int const,Style> const &,std::_Iterator_base12>(void)+5o
.text$x:00003D20
.text$x:00003D20 arg_4           = dword ptr  8
.text$x:00003D20
.text$x:00003D20                 mov     edx, [esp+arg_4]
.text$x:00003D24                 lea     eax, [edx+0Ch]
.text$x:00003D27                 mov     ecx, [edx-8]
.text$x:00003D2A                 xor     ecx, eax
.text$x:00003D2C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003D31                 mov     eax, offset __ehfuncinfo$??1?$_Iterator012@Ubidirectional_iterator_tag@std@@U?$pair@$$CBHUStyle@@@2@HPBU32@ABU32@U_Iterator_base12@2@@std@@QAE@XZ
.text$x:00003D36                 jmp     ___CxxFrameHandler3
.text$x:00003D36 __ehhandler$??1?$_Iterator012@Ubidirectional_iterator_tag@std@@U?$pair@$$CBHUStyle@@@2@HPBU32@ABU32@U_Iterator_base12@2@@std@@QAE@XZ endp
.text$x:00003D36
.text$x:00003D36 ; ---------------------------------------------------------------------------
.text$x:00003D3B                 align 4
.text$x:00003D3B _text$x         ends
.text$x:00003D3B
.text$mn:00003D3C ; ===========================================================================
.text$mn:00003D3C
.text$mn:00003D3C ; Segment type: Pure code
.text$mn:00003D3C ; Segment permissions: Read/Execute
.text$mn:00003D3C _text$mn        segment para public 'CODE' use32
.text$mn:00003D3C                 assume cs:_text$mn
.text$mn:00003D3C                 ;org 3D3Ch
.text$mn:00003D3C ; COMDAT (pick any)
.text$mn:00003D3C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003D3C
.text$mn:00003D3C ; =============== S U B R O U T I N E =======================================
.text$mn:00003D3C
.text$mn:00003D3C ; Attributes: bp-based frame
.text$mn:00003D3C
.text$mn:00003D3C ; public: __thiscall std::_Iterator012<struct std::bidirectional_iterator_tag, struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>, int, struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *> const *, struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *> const &, struct std::_Iterator_base12>::~_Iterator012<struct std::bidirectional_iterator_tag, struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>, int, struct std::pair<class
.text$mn:00003D3C                 public ??1?$_Iterator012@Ubidirectional_iterator_tag@std@@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@2@HPBU32@ABU32@U_Iterator_base12@2@@std@@QAE@XZ
.text$mn:00003D3C ??1?$_Iterator012@Ubidirectional_iterator_tag@std@@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@2@HPBU32@ABU32@U_Iterator_base12@2@@std@@QAE@XZ proc near
.text$mn:00003D3C                                         ; CODE XREF: __unwindfunclet$??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QAE@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@1@@Z$0+3j
.text$mn:00003D3C                                         ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>,std::_Iterator_base12>::~_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>,std::_Iterator_base12>(void)+37p ...
.text$mn:00003D3C
.text$mn:00003D3C var_10          = dword ptr -10h
.text$mn:00003D3C var_C           = dword ptr -0Ch
.text$mn:00003D3C var_4           = dword ptr -4
.text$mn:00003D3C
.text$mn:00003D3C                 push    ebp
.text$mn:00003D3D                 mov     ebp, esp
.text$mn:00003D3F                 push    0FFFFFFFFh
.text$mn:00003D41                 push    offset __ehhandler$??1?$_Iterator012@Ubidirectional_iterator_tag@std@@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@2@HPBU32@ABU32@U_Iterator_base12@2@@std@@QAE@XZ
.text$mn:00003D46                 mov     eax, large fs:0
.text$mn:00003D4C                 push    eax
.text$mn:00003D4D                 push    ecx
.text$mn:00003D4E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003D53                 xor     eax, ebp
.text$mn:00003D55                 push    eax
.text$mn:00003D56                 lea     eax, [ebp+var_C]
.text$mn:00003D59                 mov     large fs:0, eax
.text$mn:00003D5F                 mov     [ebp+var_10], ecx
.text$mn:00003D62                 mov     [ebp+var_4], 0
.text$mn:00003D69                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003D70                 mov     ecx, [ebp+var_10] ; this
.text$mn:00003D73                 call    ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$mn:00003D78                 mov     ecx, [ebp+var_C]
.text$mn:00003D7B                 mov     large fs:0, ecx
.text$mn:00003D82                 pop     ecx
.text$mn:00003D83                 mov     esp, ebp
.text$mn:00003D85                 pop     ebp
.text$mn:00003D86                 retn
.text$mn:00003D86 ??1?$_Iterator012@Ubidirectional_iterator_tag@std@@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@2@HPBU32@ABU32@U_Iterator_base12@2@@std@@QAE@XZ endp
.text$mn:00003D86
.text$mn:00003D86 ; ---------------------------------------------------------------------------
.text$mn:00003D87                 align 4
.text$mn:00003D87 _text$mn        ends
.text$mn:00003D87
.text$x:00003D88 ; ===========================================================================
.text$x:00003D88
.text$x:00003D88 ; Segment type: Pure code
.text$x:00003D88 ; Segment permissions: Read/Execute
.text$x:00003D88 _text$x         segment para public 'CODE' use32
.text$x:00003D88                 assume cs:_text$x
.text$x:00003D88                 ;org 3D88h
.text$x:00003D88 ; COMDAT (pick associative to section at 3D3C)
.text$x:00003D88                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00003D88
.text$x:00003D88 ; =============== S U B R O U T I N E =======================================
.text$x:00003D88
.text$x:00003D88
.text$x:00003D88 __unwindfunclet$??1?$_Iterator012@Ubidirectional_iterator_tag@std@@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@2@HPBU32@ABU32@U_Iterator_base12@2@@std@@QAE@XZ$0 proc near
.text$x:00003D88                                         ; DATA XREF: .xdata$x:0000A3C0o
.text$x:00003D88                 mov     ecx, [ebp-10h]  ; this
.text$x:00003D8B                 jmp     ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$x:00003D8B __unwindfunclet$??1?$_Iterator012@Ubidirectional_iterator_tag@std@@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@2@HPBU32@ABU32@U_Iterator_base12@2@@std@@QAE@XZ$0 endp
.text$x:00003D8B
.text$x:00003D90
.text$x:00003D90 ; =============== S U B R O U T I N E =======================================
.text$x:00003D90
.text$x:00003D90
.text$x:00003D90 __ehhandler$??1?$_Iterator012@Ubidirectional_iterator_tag@std@@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@2@HPBU32@ABU32@U_Iterator_base12@2@@std@@QAE@XZ proc near
.text$x:00003D90                                         ; DATA XREF: std::_Iterator012<std::bidirectional_iterator_tag,std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,int,std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *> const *,std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *> const &,std::_Iterator_base12>::~_Iterator012<std::bidirectional_iterator_tag,std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,int,std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *> const *,std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *> const &,std::_Iterator_base12>(void)+5
.text$x:00003D90
.text$x:00003D90 arg_4           = dword ptr  8
.text$x:00003D90
.text$x:00003D90                 mov     edx, [esp+arg_4]
.text$x:00003D94                 lea     eax, [edx+0Ch]
.text$x:00003D97                 mov     ecx, [edx-8]
.text$x:00003D9A                 xor     ecx, eax
.text$x:00003D9C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003DA1                 mov     eax, offset __ehfuncinfo$??1?$_Iterator012@Ubidirectional_iterator_tag@std@@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@2@HPBU32@ABU32@U_Iterator_base12@2@@std@@QAE@XZ
.text$x:00003DA6                 jmp     ___CxxFrameHandler3
.text$x:00003DA6 __ehhandler$??1?$_Iterator012@Ubidirectional_iterator_tag@std@@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@2@HPBU32@ABU32@U_Iterator_base12@2@@std@@QAE@XZ endp
.text$x:00003DA6
.text$x:00003DA6 ; ---------------------------------------------------------------------------
.text$x:00003DAB                 align 4
.text$x:00003DAB _text$x         ends
.text$x:00003DAB
.text$mn:00003DAC ; ===========================================================================
.text$mn:00003DAC
.text$mn:00003DAC ; Segment type: Pure code
.text$mn:00003DAC ; Segment permissions: Read/Execute
.text$mn:00003DAC _text$mn        segment para public 'CODE' use32
.text$mn:00003DAC                 assume cs:_text$mn
.text$mn:00003DAC                 ;org 3DACh
.text$mn:00003DAC ; COMDAT (pick any)
.text$mn:00003DAC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003DAC
.text$mn:00003DAC ; =============== S U B R O U T I N E =======================================
.text$mn:00003DAC
.text$mn:00003DAC ; Attributes: bp-based frame
.text$mn:00003DAC
.text$mn:00003DAC ; public: __thiscall std::_Iterator012<struct std::random_access_iterator_tag, class ScintillaEditView *, int, class ScintillaEditView * const *, class ScintillaEditView * const &, struct std::_Iterator_base12>::~_Iterator012<struct std::random_access_iterator_tag, class ScintillaEditView *, int, class ScintillaEditView * const *, class ScintillaEditView * const &, struct std::_Iterator_base12>(void)
.text$mn:00003DAC                 public ??1?$_Iterator012@Urandom_access_iterator_tag@std@@PAVScintillaEditView@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ
.text$mn:00003DAC ??1?$_Iterator012@Urandom_access_iterator_tag@std@@PAVScintillaEditView@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ proc near
.text$mn:00003DAC                                         ; CODE XREF: __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@ABV01@@Z$0+3j
.text$mn:00003DAC                                         ; __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@PAPAVScintillaEditView@@PBU_Container_base12@1@@Z$0+3j ...
.text$mn:00003DAC
.text$mn:00003DAC var_10          = dword ptr -10h
.text$mn:00003DAC var_C           = dword ptr -0Ch
.text$mn:00003DAC var_4           = dword ptr -4
.text$mn:00003DAC
.text$mn:00003DAC                 push    ebp
.text$mn:00003DAD                 mov     ebp, esp
.text$mn:00003DAF                 push    0FFFFFFFFh
.text$mn:00003DB1                 push    offset __ehhandler$??1?$_Iterator012@Urandom_access_iterator_tag@std@@PAVScintillaEditView@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ
.text$mn:00003DB6                 mov     eax, large fs:0
.text$mn:00003DBC                 push    eax
.text$mn:00003DBD                 push    ecx
.text$mn:00003DBE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003DC3                 xor     eax, ebp
.text$mn:00003DC5                 push    eax
.text$mn:00003DC6                 lea     eax, [ebp+var_C]
.text$mn:00003DC9                 mov     large fs:0, eax
.text$mn:00003DCF                 mov     [ebp+var_10], ecx
.text$mn:00003DD2                 mov     [ebp+var_4], 0
.text$mn:00003DD9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003DE0                 mov     ecx, [ebp+var_10] ; this
.text$mn:00003DE3                 call    ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$mn:00003DE8                 mov     ecx, [ebp+var_C]
.text$mn:00003DEB                 mov     large fs:0, ecx
.text$mn:00003DF2                 pop     ecx
.text$mn:00003DF3                 mov     esp, ebp
.text$mn:00003DF5                 pop     ebp
.text$mn:00003DF6                 retn
.text$mn:00003DF6 ??1?$_Iterator012@Urandom_access_iterator_tag@std@@PAVScintillaEditView@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ endp
.text$mn:00003DF6
.text$mn:00003DF6 ; ---------------------------------------------------------------------------
.text$mn:00003DF7                 align 4
.text$mn:00003DF7 _text$mn        ends
.text$mn:00003DF7
.text$x:00003DF8 ; ===========================================================================
.text$x:00003DF8
.text$x:00003DF8 ; Segment type: Pure code
.text$x:00003DF8 ; Segment permissions: Read/Execute
.text$x:00003DF8 _text$x         segment para public 'CODE' use32
.text$x:00003DF8                 assume cs:_text$x
.text$x:00003DF8                 ;org 3DF8h
.text$x:00003DF8 ; COMDAT (pick associative to section at 3DAC)
.text$x:00003DF8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00003DF8
.text$x:00003DF8 ; =============== S U B R O U T I N E =======================================
.text$x:00003DF8
.text$x:00003DF8
.text$x:00003DF8 __unwindfunclet$??1?$_Iterator012@Urandom_access_iterator_tag@std@@PAVScintillaEditView@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ$0 proc near
.text$x:00003DF8                                         ; DATA XREF: .xdata$x:0000A91Co
.text$x:00003DF8                 mov     ecx, [ebp-10h]  ; this
.text$x:00003DFB                 jmp     ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$x:00003DFB __unwindfunclet$??1?$_Iterator012@Urandom_access_iterator_tag@std@@PAVScintillaEditView@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ$0 endp
.text$x:00003DFB
.text$x:00003E00
.text$x:00003E00 ; =============== S U B R O U T I N E =======================================
.text$x:00003E00
.text$x:00003E00
.text$x:00003E00 __ehhandler$??1?$_Iterator012@Urandom_access_iterator_tag@std@@PAVScintillaEditView@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ proc near
.text$x:00003E00                                         ; DATA XREF: std::_Iterator012<std::random_access_iterator_tag,ScintillaEditView *,int,ScintillaEditView * const *,ScintillaEditView * const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,ScintillaEditView *,int,ScintillaEditView * const *,ScintillaEditView * const &,std::_Iterator_base12>(void)+5o
.text$x:00003E00
.text$x:00003E00 arg_4           = dword ptr  8
.text$x:00003E00
.text$x:00003E00                 mov     edx, [esp+arg_4]
.text$x:00003E04                 lea     eax, [edx+0Ch]
.text$x:00003E07                 mov     ecx, [edx-8]
.text$x:00003E0A                 xor     ecx, eax
.text$x:00003E0C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003E11                 mov     eax, offset __ehfuncinfo$??1?$_Iterator012@Urandom_access_iterator_tag@std@@PAVScintillaEditView@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ
.text$x:00003E16                 jmp     ___CxxFrameHandler3
.text$x:00003E16 __ehhandler$??1?$_Iterator012@Urandom_access_iterator_tag@std@@PAVScintillaEditView@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ endp
.text$x:00003E16
.text$x:00003E16 ; ---------------------------------------------------------------------------
.text$x:00003E1B                 align 4
.text$x:00003E1B _text$x         ends
.text$x:00003E1B
.text$mn:00003E1C ; ===========================================================================
.text$mn:00003E1C
.text$mn:00003E1C ; Segment type: Pure code
.text$mn:00003E1C ; Segment permissions: Read/Execute
.text$mn:00003E1C _text$mn        segment para public 'CODE' use32
.text$mn:00003E1C                 assume cs:_text$mn
.text$mn:00003E1C                 ;org 3E1Ch
.text$mn:00003E1C ; COMDAT (pick any)
.text$mn:00003E1C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003E1C
.text$mn:00003E1C ; =============== S U B R O U T I N E =======================================
.text$mn:00003E1C
.text$mn:00003E1C ; Attributes: bp-based frame
.text$mn:00003E1C
.text$mn:00003E1C ; public: __thiscall std::_Iterator012<struct std::random_access_iterator_tag, class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>, int, class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>> const *, class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>> const &, struct std::_Iterator_base12>::~_Iterator0
.text$mn:00003E1C                 public ??1?$_Iterator012@Urandom_access_iterator_tag@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@HPBV32@ABV32@U_Iterator_base12@2@@std@@QAE@XZ
.text$mn:00003E1C ??1?$_Iterator012@Urandom_access_iterator_tag@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@HPBV32@ABV32@U_Iterator_base12@2@@std@@QAE@XZ proc near
.text$mn:00003E1C                                         ; CODE XREF: __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@ABV01@@Z$0+3j
.text$mn:00003E1C                                         ; __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@PBU_Container_base12@1@@Z$0+3j ...
.text$mn:00003E1C
.text$mn:00003E1C var_10          = dword ptr -10h
.text$mn:00003E1C var_C           = dword ptr -0Ch
.text$mn:00003E1C var_4           = dword ptr -4
.text$mn:00003E1C
.text$mn:00003E1C                 push    ebp
.text$mn:00003E1D                 mov     ebp, esp
.text$mn:00003E1F                 push    0FFFFFFFFh
.text$mn:00003E21                 push    offset __ehhandler$??1?$_Iterator012@Urandom_access_iterator_tag@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@HPBV32@ABV32@U_Iterator_base12@2@@std@@QAE@XZ
.text$mn:00003E26                 mov     eax, large fs:0
.text$mn:00003E2C                 push    eax
.text$mn:00003E2D                 push    ecx
.text$mn:00003E2E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003E33                 xor     eax, ebp
.text$mn:00003E35                 push    eax
.text$mn:00003E36                 lea     eax, [ebp+var_C]
.text$mn:00003E39                 mov     large fs:0, eax
.text$mn:00003E3F                 mov     [ebp+var_10], ecx
.text$mn:00003E42                 mov     [ebp+var_4], 0
.text$mn:00003E49                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003E50                 mov     ecx, [ebp+var_10] ; this
.text$mn:00003E53                 call    ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$mn:00003E58                 mov     ecx, [ebp+var_C]
.text$mn:00003E5B                 mov     large fs:0, ecx
.text$mn:00003E62                 pop     ecx
.text$mn:00003E63                 mov     esp, ebp
.text$mn:00003E65                 pop     ebp
.text$mn:00003E66                 retn
.text$mn:00003E66 ??1?$_Iterator012@Urandom_access_iterator_tag@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@HPBV32@ABV32@U_Iterator_base12@2@@std@@QAE@XZ endp
.text$mn:00003E66
.text$mn:00003E66 ; ---------------------------------------------------------------------------
.text$mn:00003E67                 align 4
.text$mn:00003E67 _text$mn        ends
.text$mn:00003E67
.text$x:00003E68 ; ===========================================================================
.text$x:00003E68
.text$x:00003E68 ; Segment type: Pure code
.text$x:00003E68 ; Segment permissions: Read/Execute
.text$x:00003E68 _text$x         segment para public 'CODE' use32
.text$x:00003E68                 assume cs:_text$x
.text$x:00003E68                 ;org 3E68h
.text$x:00003E68 ; COMDAT (pick associative to section at 3E1C)
.text$x:00003E68                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00003E68
.text$x:00003E68 ; =============== S U B R O U T I N E =======================================
.text$x:00003E68
.text$x:00003E68
.text$x:00003E68 __unwindfunclet$??1?$_Iterator012@Urandom_access_iterator_tag@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@HPBV32@ABV32@U_Iterator_base12@2@@std@@QAE@XZ$0 proc near
.text$x:00003E68                                         ; DATA XREF: .xdata$x:0000AB08o
.text$x:00003E68                 mov     ecx, [ebp-10h]  ; this
.text$x:00003E6B                 jmp     ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$x:00003E6B __unwindfunclet$??1?$_Iterator012@Urandom_access_iterator_tag@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@HPBV32@ABV32@U_Iterator_base12@2@@std@@QAE@XZ$0 endp
.text$x:00003E6B
.text$x:00003E70
.text$x:00003E70 ; =============== S U B R O U T I N E =======================================
.text$x:00003E70
.text$x:00003E70
.text$x:00003E70 __ehhandler$??1?$_Iterator012@Urandom_access_iterator_tag@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@HPBV32@ABV32@U_Iterator_base12@2@@std@@QAE@XZ proc near
.text$x:00003E70                                         ; DATA XREF: std::_Iterator012<std::random_access_iterator_tag,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,int,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,int,std::_List_unchecked_iterator
.text$x:00003E70
.text$x:00003E70 arg_4           = dword ptr  8
.text$x:00003E70
.text$x:00003E70                 mov     edx, [esp+arg_4]
.text$x:00003E74                 lea     eax, [edx+0Ch]
.text$x:00003E77                 mov     ecx, [edx-8]
.text$x:00003E7A                 xor     ecx, eax
.text$x:00003E7C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003E81                 mov     eax, offset __ehfuncinfo$??1?$_Iterator012@Urandom_access_iterator_tag@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@HPBV32@ABV32@U_Iterator_base12@2@@std@@QAE@XZ
.text$x:00003E86                 jmp     ___CxxFrameHandler3
.text$x:00003E86 __ehhandler$??1?$_Iterator012@Urandom_access_iterator_tag@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@HPBV32@ABV32@U_Iterator_base12@2@@std@@QAE@XZ endp
.text$x:00003E86
.text$x:00003E86 ; ---------------------------------------------------------------------------
.text$x:00003E8B                 align 4
.text$x:00003E8B _text$x         ends
.text$x:00003E8B
.text$mn:00003E8C ; ===========================================================================
.text$mn:00003E8C
.text$mn:00003E8C ; Segment type: Pure code
.text$mn:00003E8C ; Segment permissions: Read/Execute
.text$mn:00003E8C _text$mn        segment para public 'CODE' use32
.text$mn:00003E8C                 assume cs:_text$mn
.text$mn:00003E8C                 ;org 3E8Ch
.text$mn:00003E8C ; COMDAT (pick any)
.text$mn:00003E8C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003E8C
.text$mn:00003E8C ; =============== S U B R O U T I N E =======================================
.text$mn:00003E8C
.text$mn:00003E8C ; Attributes: bp-based frame
.text$mn:00003E8C
.text$mn:00003E8C ; public: __thiscall std::_List_alloc<0, struct std::_List_base_types<struct std::pair<int const, struct Style>, class std::allocator<struct std::pair<int const, struct Style>>>>::~_List_alloc<0, struct std::_List_base_types<struct std::pair<int const, struct Style>, class std::allocator<struct std::pair<int const, struct Style>>>>(void)
.text$mn:00003E8C                 public ??1?$_List_alloc@$0A@U?$_List_base_types@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@@std@@QAE@XZ
.text$mn:00003E8C ??1?$_List_alloc@$0A@U?$_List_base_types@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@@std@@QAE@XZ proc near
.text$mn:00003E8C                                         ; CODE XREF: std::_List_buy<std::pair<int const,Style>,std::allocator<std::pair<int const,Style>>>::~_List_buy<std::pair<int const,Style>,std::allocator<std::pair<int const,Style>>>(void)+37p
.text$mn:00003E8C                                         ; __unwindfunclet$??1?$_List_buy@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@QAE@XZ$0+3j
.text$mn:00003E8C
.text$mn:00003E8C var_10          = dword ptr -10h
.text$mn:00003E8C var_C           = dword ptr -0Ch
.text$mn:00003E8C var_4           = dword ptr -4
.text$mn:00003E8C
.text$mn:00003E8C                 push    ebp
.text$mn:00003E8D                 mov     ebp, esp
.text$mn:00003E8F                 push    0FFFFFFFFh
.text$mn:00003E91                 push    offset __ehhandler$??1?$_List_alloc@$0A@U?$_List_base_types@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@@std@@QAE@XZ
.text$mn:00003E96                 mov     eax, large fs:0
.text$mn:00003E9C                 push    eax
.text$mn:00003E9D                 push    ecx
.text$mn:00003E9E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003EA3                 xor     eax, ebp
.text$mn:00003EA5                 push    eax
.text$mn:00003EA6                 lea     eax, [ebp+var_C]
.text$mn:00003EA9                 mov     large fs:0, eax
.text$mn:00003EAF                 mov     [ebp+var_10], ecx
.text$mn:00003EB2                 mov     [ebp+var_4], 0
.text$mn:00003EB9                 mov     eax, [ebp+var_10]
.text$mn:00003EBC                 mov     ecx, [eax+4]
.text$mn:00003EBF                 push    ecx             ; void *
.text$mn:00003EC0                 mov     ecx, [ebp+var_10]
.text$mn:00003EC3                 call    ?_Freeheadnode@?$_List_alloc@$0A@U?$_List_base_types@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@@std@@QAEXPAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@2@@Z ; std::_List_alloc<0,std::_List_base_types<std::pair<int const,Style>,std::allocator<std::pair<int const,Style>>>>::_Freeheadnode(std::_List_node<std::pair<int const,Style>,void *> *)
.text$mn:00003EC8                 mov     ecx, [ebp+var_10]
.text$mn:00003ECB                 call    ?_Free_proxy@?$_List_alloc@$0A@U?$_List_base_types@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@@std@@QAEXXZ ; std::_List_alloc<0,std::_List_base_types<std::pair<int const,Style>,std::allocator<std::pair<int const,Style>>>>::_Free_proxy(void)
.text$mn:00003ED0                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003ED7                 mov     ecx, [ebp+var_10]
.text$mn:00003EDA                 call    ??1?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@QAE@XZ ; std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>::~_List_val<std::_List_simple_types<std::pair<int const,Style>>>(void)
.text$mn:00003EDF                 mov     ecx, [ebp+var_C]
.text$mn:00003EE2                 mov     large fs:0, ecx
.text$mn:00003EE9                 pop     ecx
.text$mn:00003EEA                 mov     esp, ebp
.text$mn:00003EEC                 pop     ebp
.text$mn:00003EED                 retn
.text$mn:00003EED ??1?$_List_alloc@$0A@U?$_List_base_types@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@@std@@QAE@XZ endp
.text$mn:00003EED
.text$mn:00003EED ; ---------------------------------------------------------------------------
.text$mn:00003EEE                 align 10h
.text$mn:00003EEE _text$mn        ends
.text$mn:00003EEE
.text$x:00003EF0 ; ===========================================================================
.text$x:00003EF0
.text$x:00003EF0 ; Segment type: Pure code
.text$x:00003EF0 ; Segment permissions: Read/Execute
.text$x:00003EF0 _text$x         segment para public 'CODE' use32
.text$x:00003EF0                 assume cs:_text$x
.text$x:00003EF0                 ;org 3EF0h
.text$x:00003EF0 ; COMDAT (pick associative to section at 3E8C)
.text$x:00003EF0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00003EF0
.text$x:00003EF0 ; =============== S U B R O U T I N E =======================================
.text$x:00003EF0
.text$x:00003EF0
.text$x:00003EF0 __unwindfunclet$??1?$_List_alloc@$0A@U?$_List_base_types@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@@std@@QAE@XZ$0 proc near
.text$x:00003EF0                                         ; DATA XREF: .xdata$x:0000A520o
.text$x:00003EF0                 mov     ecx, [ebp-10h]
.text$x:00003EF3                 jmp     ??1?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@QAE@XZ ; std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>::~_List_val<std::_List_simple_types<std::pair<int const,Style>>>(void)
.text$x:00003EF3 __unwindfunclet$??1?$_List_alloc@$0A@U?$_List_base_types@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@@std@@QAE@XZ$0 endp
.text$x:00003EF3
.text$x:00003EF8
.text$x:00003EF8 ; =============== S U B R O U T I N E =======================================
.text$x:00003EF8
.text$x:00003EF8
.text$x:00003EF8 __ehhandler$??1?$_List_alloc@$0A@U?$_List_base_types@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@@std@@QAE@XZ proc near
.text$x:00003EF8                                         ; DATA XREF: std::_List_alloc<0,std::_List_base_types<std::pair<int const,Style>,std::allocator<std::pair<int const,Style>>>>::~_List_alloc<0,std::_List_base_types<std::pair<int const,Style>,std::allocator<std::pair<int const,Style>>>>(void)+5o
.text$x:00003EF8
.text$x:00003EF8 arg_4           = dword ptr  8
.text$x:00003EF8
.text$x:00003EF8                 mov     edx, [esp+arg_4]
.text$x:00003EFC                 lea     eax, [edx+0Ch]
.text$x:00003EFF                 mov     ecx, [edx-8]
.text$x:00003F02                 xor     ecx, eax
.text$x:00003F04                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003F09                 mov     eax, offset __ehfuncinfo$??1?$_List_alloc@$0A@U?$_List_base_types@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@@std@@QAE@XZ
.text$x:00003F0E                 jmp     ___CxxFrameHandler3
.text$x:00003F0E __ehhandler$??1?$_List_alloc@$0A@U?$_List_base_types@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@@std@@QAE@XZ endp
.text$x:00003F0E
.text$x:00003F0E ; ---------------------------------------------------------------------------
.text$x:00003F13                 align 4
.text$x:00003F13 _text$x         ends
.text$x:00003F13
.text$mn:00003F14 ; ===========================================================================
.text$mn:00003F14
.text$mn:00003F14 ; Segment type: Pure code
.text$mn:00003F14 ; Segment permissions: Read/Execute
.text$mn:00003F14 _text$mn        segment para public 'CODE' use32
.text$mn:00003F14                 assume cs:_text$mn
.text$mn:00003F14                 ;org 3F14h
.text$mn:00003F14 ; COMDAT (pick any)
.text$mn:00003F14                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003F14
.text$mn:00003F14 ; =============== S U B R O U T I N E =======================================
.text$mn:00003F14
.text$mn:00003F14 ; Attributes: bp-based frame
.text$mn:00003F14
.text$mn:00003F14 ; public: __thiscall std::_List_alloc<0, struct std::_List_base_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>, class std::allocator<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>::~_List_alloc<0, struct std::_List_base_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>, class std::allocator<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>(void)
.text$mn:00003F14                 public ??1?$_List_alloc@$0A@U?$_List_base_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@@std@@QAE@XZ
.text$mn:00003F14 ??1?$_List_alloc@$0A@U?$_List_base_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@@std@@QAE@XZ proc near
.text$mn:00003F14                                         ; CODE XREF: __unwindfunclet$??0?$_List_buy@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@1@@Z$0+3j
.text$mn:00003F14                                         ; std::_List_buy<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>::~_List_buy<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>(void)+37p ...
.text$mn:00003F14
.text$mn:00003F14 var_10          = dword ptr -10h
.text$mn:00003F14 var_C           = dword ptr -0Ch
.text$mn:00003F14 var_4           = dword ptr -4
.text$mn:00003F14
.text$mn:00003F14                 push    ebp
.text$mn:00003F15                 mov     ebp, esp
.text$mn:00003F17                 push    0FFFFFFFFh
.text$mn:00003F19                 push    offset __ehhandler$??1?$_List_alloc@$0A@U?$_List_base_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@@std@@QAE@XZ
.text$mn:00003F1E                 mov     eax, large fs:0
.text$mn:00003F24                 push    eax
.text$mn:00003F25                 push    ecx
.text$mn:00003F26                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003F2B                 xor     eax, ebp
.text$mn:00003F2D                 push    eax
.text$mn:00003F2E                 lea     eax, [ebp+var_C]
.text$mn:00003F31                 mov     large fs:0, eax
.text$mn:00003F37                 mov     [ebp+var_10], ecx
.text$mn:00003F3A                 mov     [ebp+var_4], 0
.text$mn:00003F41                 mov     eax, [ebp+var_10]
.text$mn:00003F44                 mov     ecx, [eax+4]
.text$mn:00003F47                 push    ecx             ; void *
.text$mn:00003F48                 mov     ecx, [ebp+var_10]
.text$mn:00003F4B                 call    ?_Freeheadnode@?$_List_alloc@$0A@U?$_List_base_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@@std@@QAEXPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@2@@Z ; std::_List_alloc<0,std::_List_base_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::_Freeheadnode(std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *)
.text$mn:00003F50                 mov     ecx, [ebp+var_10]
.text$mn:00003F53                 call    ?_Free_proxy@?$_List_alloc@$0A@U?$_List_base_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@@std@@QAEXXZ ; std::_List_alloc<0,std::_List_base_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::_Free_proxy(void)
.text$mn:00003F58                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003F5F                 mov     ecx, [ebp+var_10]
.text$mn:00003F62                 call    ??1?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@QAE@XZ ; std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>::~_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>(void)
.text$mn:00003F67                 mov     ecx, [ebp+var_C]
.text$mn:00003F6A                 mov     large fs:0, ecx
.text$mn:00003F71                 pop     ecx
.text$mn:00003F72                 mov     esp, ebp
.text$mn:00003F74                 pop     ebp
.text$mn:00003F75                 retn
.text$mn:00003F75 ??1?$_List_alloc@$0A@U?$_List_base_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@@std@@QAE@XZ endp
.text$mn:00003F75
.text$mn:00003F75 ; ---------------------------------------------------------------------------
.text$mn:00003F76                 align 4
.text$mn:00003F76 _text$mn        ends
.text$mn:00003F76
.text$x:00003F78 ; ===========================================================================
.text$x:00003F78
.text$x:00003F78 ; Segment type: Pure code
.text$x:00003F78 ; Segment permissions: Read/Execute
.text$x:00003F78 _text$x         segment para public 'CODE' use32
.text$x:00003F78                 assume cs:_text$x
.text$x:00003F78                 ;org 3F78h
.text$x:00003F78 ; COMDAT (pick associative to section at 3F14)
.text$x:00003F78                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00003F78
.text$x:00003F78 ; =============== S U B R O U T I N E =======================================
.text$x:00003F78
.text$x:00003F78
.text$x:00003F78 __unwindfunclet$??1?$_List_alloc@$0A@U?$_List_base_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@@std@@QAE@XZ$0 proc near
.text$x:00003F78                                         ; DATA XREF: .xdata$x:00009E50o
.text$x:00003F78                 mov     ecx, [ebp-10h]
.text$x:00003F7B                 jmp     ??1?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@QAE@XZ ; std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>::~_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>(void)
.text$x:00003F7B __unwindfunclet$??1?$_List_alloc@$0A@U?$_List_base_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@@std@@QAE@XZ$0 endp
.text$x:00003F7B
.text$x:00003F80
.text$x:00003F80 ; =============== S U B R O U T I N E =======================================
.text$x:00003F80
.text$x:00003F80
.text$x:00003F80 __ehhandler$??1?$_List_alloc@$0A@U?$_List_base_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@@std@@QAE@XZ proc near
.text$x:00003F80                                         ; DATA XREF: std::_List_alloc<0,std::_List_base_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::~_List_alloc<0,std::_List_base_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>(void)+5o
.text$x:00003F80
.text$x:00003F80 arg_4           = dword ptr  8
.text$x:00003F80
.text$x:00003F80                 mov     edx, [esp+arg_4]
.text$x:00003F84                 lea     eax, [edx+0Ch]
.text$x:00003F87                 mov     ecx, [edx-8]
.text$x:00003F8A                 xor     ecx, eax
.text$x:00003F8C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003F91                 mov     eax, offset __ehfuncinfo$??1?$_List_alloc@$0A@U?$_List_base_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@@std@@QAE@XZ
.text$x:00003F96                 jmp     ___CxxFrameHandler3
.text$x:00003F96 __ehhandler$??1?$_List_alloc@$0A@U?$_List_base_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@@std@@QAE@XZ endp
.text$x:00003F96
.text$x:00003F96 ; ---------------------------------------------------------------------------
.text$x:00003F9B                 align 4
.text$x:00003F9B _text$x         ends
.text$x:00003F9B
.text$mn:00003F9C ; ===========================================================================
.text$mn:00003F9C
.text$mn:00003F9C ; Segment type: Pure code
.text$mn:00003F9C ; Segment permissions: Read/Execute
.text$mn:00003F9C _text$mn        segment para public 'CODE' use32
.text$mn:00003F9C                 assume cs:_text$mn
.text$mn:00003F9C                 ;org 3F9Ch
.text$mn:00003F9C ; COMDAT (pick any)
.text$mn:00003F9C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003F9C
.text$mn:00003F9C ; =============== S U B R O U T I N E =======================================
.text$mn:00003F9C
.text$mn:00003F9C ; Attributes: bp-based frame
.text$mn:00003F9C
.text$mn:00003F9C ; public: __thiscall std::_List_buy<struct std::pair<int const, struct Style>, class std::allocator<struct std::pair<int const, struct Style>>>::~_List_buy<struct std::pair<int const, struct Style>, class std::allocator<struct std::pair<int const, struct Style>>>(void)
.text$mn:00003F9C                 public ??1?$_List_buy@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@QAE@XZ
.text$mn:00003F9C ??1?$_List_buy@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@QAE@XZ proc near
.text$mn:00003F9C                                         ; CODE XREF: std::list<std::pair<int const,Style>,std::allocator<std::pair<int const,Style>>>::~list<std::pair<int const,Style>,std::allocator<std::pair<int const,Style>>>(void)+3Fp
.text$mn:00003F9C                                         ; __unwindfunclet$??1?$list@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@QAE@XZ$0+3j
.text$mn:00003F9C
.text$mn:00003F9C var_10          = dword ptr -10h
.text$mn:00003F9C var_C           = dword ptr -0Ch
.text$mn:00003F9C var_4           = dword ptr -4
.text$mn:00003F9C
.text$mn:00003F9C                 push    ebp
.text$mn:00003F9D                 mov     ebp, esp
.text$mn:00003F9F                 push    0FFFFFFFFh
.text$mn:00003FA1                 push    offset __ehhandler$??1?$_List_buy@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@QAE@XZ
.text$mn:00003FA6                 mov     eax, large fs:0
.text$mn:00003FAC                 push    eax
.text$mn:00003FAD                 push    ecx
.text$mn:00003FAE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003FB3                 xor     eax, ebp
.text$mn:00003FB5                 push    eax
.text$mn:00003FB6                 lea     eax, [ebp+var_C]
.text$mn:00003FB9                 mov     large fs:0, eax
.text$mn:00003FBF                 mov     [ebp+var_10], ecx
.text$mn:00003FC2                 mov     [ebp+var_4], 0
.text$mn:00003FC9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003FD0                 mov     ecx, [ebp+var_10]
.text$mn:00003FD3                 call    ??1?$_List_alloc@$0A@U?$_List_base_types@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@@std@@QAE@XZ ; std::_List_alloc<0,std::_List_base_types<std::pair<int const,Style>,std::allocator<std::pair<int const,Style>>>>::~_List_alloc<0,std::_List_base_types<std::pair<int const,Style>,std::allocator<std::pair<int const,Style>>>>(void)
.text$mn:00003FD8                 mov     ecx, [ebp+var_C]
.text$mn:00003FDB                 mov     large fs:0, ecx
.text$mn:00003FE2                 pop     ecx
.text$mn:00003FE3                 mov     esp, ebp
.text$mn:00003FE5                 pop     ebp
.text$mn:00003FE6                 retn
.text$mn:00003FE6 ??1?$_List_buy@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@QAE@XZ endp
.text$mn:00003FE6
.text$mn:00003FE6 ; ---------------------------------------------------------------------------
.text$mn:00003FE7                 align 4
.text$mn:00003FE7 _text$mn        ends
.text$mn:00003FE7
.text$x:00003FE8 ; ===========================================================================
.text$x:00003FE8
.text$x:00003FE8 ; Segment type: Pure code
.text$x:00003FE8 ; Segment permissions: Read/Execute
.text$x:00003FE8 _text$x         segment para public 'CODE' use32
.text$x:00003FE8                 assume cs:_text$x
.text$x:00003FE8                 ;org 3FE8h
.text$x:00003FE8 ; COMDAT (pick associative to section at 3F9C)
.text$x:00003FE8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00003FE8
.text$x:00003FE8 ; =============== S U B R O U T I N E =======================================
.text$x:00003FE8
.text$x:00003FE8
.text$x:00003FE8 __unwindfunclet$??1?$_List_buy@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@QAE@XZ$0 proc near
.text$x:00003FE8                                         ; DATA XREF: .xdata$x:0000A54Co
.text$x:00003FE8                 mov     ecx, [ebp-10h]
.text$x:00003FEB                 jmp     ??1?$_List_alloc@$0A@U?$_List_base_types@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@@std@@QAE@XZ ; std::_List_alloc<0,std::_List_base_types<std::pair<int const,Style>,std::allocator<std::pair<int const,Style>>>>::~_List_alloc<0,std::_List_base_types<std::pair<int const,Style>,std::allocator<std::pair<int const,Style>>>>(void)
.text$x:00003FEB __unwindfunclet$??1?$_List_buy@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@QAE@XZ$0 endp
.text$x:00003FEB
.text$x:00003FF0
.text$x:00003FF0 ; =============== S U B R O U T I N E =======================================
.text$x:00003FF0
.text$x:00003FF0
.text$x:00003FF0 __ehhandler$??1?$_List_buy@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@QAE@XZ proc near
.text$x:00003FF0                                         ; DATA XREF: std::_List_buy<std::pair<int const,Style>,std::allocator<std::pair<int const,Style>>>::~_List_buy<std::pair<int const,Style>,std::allocator<std::pair<int const,Style>>>(void)+5o
.text$x:00003FF0
.text$x:00003FF0 arg_4           = dword ptr  8
.text$x:00003FF0
.text$x:00003FF0                 mov     edx, [esp+arg_4]
.text$x:00003FF4                 lea     eax, [edx+0Ch]
.text$x:00003FF7                 mov     ecx, [edx-8]
.text$x:00003FFA                 xor     ecx, eax
.text$x:00003FFC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004001                 mov     eax, offset __ehfuncinfo$??1?$_List_buy@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@QAE@XZ
.text$x:00004006                 jmp     ___CxxFrameHandler3
.text$x:00004006 __ehhandler$??1?$_List_buy@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@QAE@XZ endp
.text$x:00004006
.text$x:00004006 ; ---------------------------------------------------------------------------
.text$x:0000400B                 align 4
.text$x:0000400B _text$x         ends
.text$x:0000400B
.text$mn:0000400C ; ===========================================================================
.text$mn:0000400C
.text$mn:0000400C ; Segment type: Pure code
.text$mn:0000400C ; Segment permissions: Read/Execute
.text$mn:0000400C _text$mn        segment para public 'CODE' use32
.text$mn:0000400C                 assume cs:_text$mn
.text$mn:0000400C                 ;org 400Ch
.text$mn:0000400C ; COMDAT (pick any)
.text$mn:0000400C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000400C
.text$mn:0000400C ; =============== S U B R O U T I N E =======================================
.text$mn:0000400C
.text$mn:0000400C ; Attributes: bp-based frame
.text$mn:0000400C
.text$mn:0000400C ; public: __thiscall std::_List_buy<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>, class std::allocator<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>::~_List_buy<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>, class std::allocator<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>(void)
.text$mn:0000400C                 public ??1?$_List_buy@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAE@XZ
.text$mn:0000400C ??1?$_List_buy@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAE@XZ proc near
.text$mn:0000400C                                         ; CODE XREF: __unwindfunclet$??0?$list@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@1@@Z$0+3j
.text$mn:0000400C                                         ; std::list<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>::~list<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>(void)+3Fp ...
.text$mn:0000400C
.text$mn:0000400C var_10          = dword ptr -10h
.text$mn:0000400C var_C           = dword ptr -0Ch
.text$mn:0000400C var_4           = dword ptr -4
.text$mn:0000400C
.text$mn:0000400C                 push    ebp
.text$mn:0000400D                 mov     ebp, esp
.text$mn:0000400F                 push    0FFFFFFFFh
.text$mn:00004011                 push    offset __ehhandler$??1?$_List_buy@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAE@XZ
.text$mn:00004016                 mov     eax, large fs:0
.text$mn:0000401C                 push    eax
.text$mn:0000401D                 push    ecx
.text$mn:0000401E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004023                 xor     eax, ebp
.text$mn:00004025                 push    eax
.text$mn:00004026                 lea     eax, [ebp+var_C]
.text$mn:00004029                 mov     large fs:0, eax
.text$mn:0000402F                 mov     [ebp+var_10], ecx
.text$mn:00004032                 mov     [ebp+var_4], 0
.text$mn:00004039                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004040                 mov     ecx, [ebp+var_10]
.text$mn:00004043                 call    ??1?$_List_alloc@$0A@U?$_List_base_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@@std@@QAE@XZ ; std::_List_alloc<0,std::_List_base_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::~_List_alloc<0,std::_List_base_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>(void)
.text$mn:00004048                 mov     ecx, [ebp+var_C]
.text$mn:0000404B                 mov     large fs:0, ecx
.text$mn:00004052                 pop     ecx
.text$mn:00004053                 mov     esp, ebp
.text$mn:00004055                 pop     ebp
.text$mn:00004056                 retn
.text$mn:00004056 ??1?$_List_buy@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAE@XZ endp
.text$mn:00004056
.text$mn:00004056 ; ---------------------------------------------------------------------------
.text$mn:00004057                 align 4
.text$mn:00004057 _text$mn        ends
.text$mn:00004057
.text$x:00004058 ; ===========================================================================
.text$x:00004058
.text$x:00004058 ; Segment type: Pure code
.text$x:00004058 ; Segment permissions: Read/Execute
.text$x:00004058 _text$x         segment para public 'CODE' use32
.text$x:00004058                 assume cs:_text$x
.text$x:00004058                 ;org 4058h
.text$x:00004058 ; COMDAT (pick associative to section at 400C)
.text$x:00004058                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00004058
.text$x:00004058 ; =============== S U B R O U T I N E =======================================
.text$x:00004058
.text$x:00004058
.text$x:00004058 __unwindfunclet$??1?$_List_buy@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAE@XZ$0 proc near
.text$x:00004058                                         ; DATA XREF: .xdata$x:00009F00o
.text$x:00004058                 mov     ecx, [ebp-10h]
.text$x:0000405B                 jmp     ??1?$_List_alloc@$0A@U?$_List_base_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@@std@@QAE@XZ ; std::_List_alloc<0,std::_List_base_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::~_List_alloc<0,std::_List_base_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>(void)
.text$x:0000405B __unwindfunclet$??1?$_List_buy@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAE@XZ$0 endp
.text$x:0000405B
.text$x:00004060
.text$x:00004060 ; =============== S U B R O U T I N E =======================================
.text$x:00004060
.text$x:00004060
.text$x:00004060 __ehhandler$??1?$_List_buy@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAE@XZ proc near
.text$x:00004060                                         ; DATA XREF: std::_List_buy<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>::~_List_buy<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>(void)+5o
.text$x:00004060
.text$x:00004060 arg_4           = dword ptr  8
.text$x:00004060
.text$x:00004060                 mov     edx, [esp+arg_4]
.text$x:00004064                 lea     eax, [edx+0Ch]
.text$x:00004067                 mov     ecx, [edx-8]
.text$x:0000406A                 xor     ecx, eax
.text$x:0000406C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004071                 mov     eax, offset __ehfuncinfo$??1?$_List_buy@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAE@XZ
.text$x:00004076                 jmp     ___CxxFrameHandler3
.text$x:00004076 __ehhandler$??1?$_List_buy@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAE@XZ endp
.text$x:00004076
.text$x:00004076 ; ---------------------------------------------------------------------------
.text$x:0000407B                 align 4
.text$x:0000407B _text$x         ends
.text$x:0000407B
.text$mn:0000407C ; ===========================================================================
.text$mn:0000407C
.text$mn:0000407C ; Segment type: Pure code
.text$mn:0000407C ; Segment permissions: Read/Execute
.text$mn:0000407C _text$mn        segment para public 'CODE' use32
.text$mn:0000407C                 assume cs:_text$mn
.text$mn:0000407C                 ;org 407Ch
.text$mn:0000407C ; COMDAT (pick any)
.text$mn:0000407C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000407C
.text$mn:0000407C ; =============== S U B R O U T I N E =======================================
.text$mn:0000407C
.text$mn:0000407C ; Attributes: bp-based frame
.text$mn:0000407C
.text$mn:0000407C ; public: __thiscall std::_List_const_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<int const, struct Style>>>>::~_List_const_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<int const, struct Style>>>>(void)
.text$mn:0000407C                 public ??1?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@QAE@XZ
.text$mn:0000407C ??1?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@QAE@XZ proc near
.text$mn:0000407C                                         ; CODE XREF: __unwindfunclet$??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@1@@Z$0+3j
.text$mn:0000407C                                         ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>::~_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>(void)+37p ...
.text$mn:0000407C
.text$mn:0000407C var_10          = dword ptr -10h
.text$mn:0000407C var_C           = dword ptr -0Ch
.text$mn:0000407C var_4           = dword ptr -4
.text$mn:0000407C
.text$mn:0000407C                 push    ebp
.text$mn:0000407D                 mov     ebp, esp
.text$mn:0000407F                 push    0FFFFFFFFh
.text$mn:00004081                 push    offset __ehhandler$??1?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@QAE@XZ
.text$mn:00004086                 mov     eax, large fs:0
.text$mn:0000408C                 push    eax
.text$mn:0000408D                 push    ecx
.text$mn:0000408E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004093                 xor     eax, ebp
.text$mn:00004095                 push    eax
.text$mn:00004096                 lea     eax, [ebp+var_C]
.text$mn:00004099                 mov     large fs:0, eax
.text$mn:0000409F                 mov     [ebp+var_10], ecx
.text$mn:000040A2                 mov     [ebp+var_4], 0
.text$mn:000040A9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000040B0                 mov     ecx, [ebp+var_10]
.text$mn:000040B3                 call    ??1?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QAE@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>,std::_Iterator_base12>::~_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>,std::_Iterator_base12>(void)
.text$mn:000040B8                 mov     ecx, [ebp+var_C]
.text$mn:000040BB                 mov     large fs:0, ecx
.text$mn:000040C2                 pop     ecx
.text$mn:000040C3                 mov     esp, ebp
.text$mn:000040C5                 pop     ebp
.text$mn:000040C6                 retn
.text$mn:000040C6 ??1?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@QAE@XZ endp
.text$mn:000040C6
.text$mn:000040C6 ; ---------------------------------------------------------------------------
.text$mn:000040C7                 align 4
.text$mn:000040C7 _text$mn        ends
.text$mn:000040C7
.text$x:000040C8 ; ===========================================================================
.text$x:000040C8
.text$x:000040C8 ; Segment type: Pure code
.text$x:000040C8 ; Segment permissions: Read/Execute
.text$x:000040C8 _text$x         segment para public 'CODE' use32
.text$x:000040C8                 assume cs:_text$x
.text$x:000040C8                 ;org 40C8h
.text$x:000040C8 ; COMDAT (pick associative to section at 407C)
.text$x:000040C8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000040C8
.text$x:000040C8 ; =============== S U B R O U T I N E =======================================
.text$x:000040C8
.text$x:000040C8
.text$x:000040C8 __unwindfunclet$??1?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:000040C8                                         ; DATA XREF: .xdata$x:0000A840o
.text$x:000040C8                 mov     ecx, [ebp-10h]
.text$x:000040CB                 jmp     ??1?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QAE@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>,std::_Iterator_base12>::~_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>,std::_Iterator_base12>(void)
.text$x:000040CB __unwindfunclet$??1?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:000040CB
.text$x:000040D0
.text$x:000040D0 ; =============== S U B R O U T I N E =======================================
.text$x:000040D0
.text$x:000040D0
.text$x:000040D0 __ehhandler$??1?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@QAE@XZ proc near
.text$x:000040D0                                         ; DATA XREF: std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>::~_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>(void)+5o
.text$x:000040D0
.text$x:000040D0 arg_4           = dword ptr  8
.text$x:000040D0
.text$x:000040D0                 mov     edx, [esp+arg_4]
.text$x:000040D4                 lea     eax, [edx+0Ch]
.text$x:000040D7                 mov     ecx, [edx-8]
.text$x:000040DA                 xor     ecx, eax
.text$x:000040DC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000040E1                 mov     eax, offset __ehfuncinfo$??1?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@QAE@XZ
.text$x:000040E6                 jmp     ___CxxFrameHandler3
.text$x:000040E6 __ehhandler$??1?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@QAE@XZ endp
.text$x:000040E6
.text$x:000040E6 ; ---------------------------------------------------------------------------
.text$x:000040EB                 align 4
.text$x:000040EB _text$x         ends
.text$x:000040EB
.text$mn:000040EC ; ===========================================================================
.text$mn:000040EC
.text$mn:000040EC ; Segment type: Pure code
.text$mn:000040EC ; Segment permissions: Read/Execute
.text$mn:000040EC _text$mn        segment para public 'CODE' use32
.text$mn:000040EC                 assume cs:_text$mn
.text$mn:000040EC                 ;org 40ECh
.text$mn:000040EC ; COMDAT (pick any)
.text$mn:000040EC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000040EC
.text$mn:000040EC ; =============== S U B R O U T I N E =======================================
.text$mn:000040EC
.text$mn:000040EC ; Attributes: bp-based frame
.text$mn:000040EC
.text$mn:000040EC ; public: __thiscall std::_List_const_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>::~_List_const_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>(void)
.text$mn:000040EC                 public ??1?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QAE@XZ
.text$mn:000040EC ??1?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QAE@XZ proc near
.text$mn:000040EC                                         ; CODE XREF: __unwindfunclet$??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@1@@Z$0+3j
.text$mn:000040EC                                         ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::~_List_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>(void)+37p ...
.text$mn:000040EC
.text$mn:000040EC var_10          = dword ptr -10h
.text$mn:000040EC var_C           = dword ptr -0Ch
.text$mn:000040EC var_4           = dword ptr -4
.text$mn:000040EC
.text$mn:000040EC                 push    ebp
.text$mn:000040ED                 mov     ebp, esp
.text$mn:000040EF                 push    0FFFFFFFFh
.text$mn:000040F1                 push    offset __ehhandler$??1?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QAE@XZ
.text$mn:000040F6                 mov     eax, large fs:0
.text$mn:000040FC                 push    eax
.text$mn:000040FD                 push    ecx
.text$mn:000040FE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004103                 xor     eax, ebp
.text$mn:00004105                 push    eax
.text$mn:00004106                 lea     eax, [ebp+var_C]
.text$mn:00004109                 mov     large fs:0, eax
.text$mn:0000410F                 mov     [ebp+var_10], ecx
.text$mn:00004112                 mov     [ebp+var_4], 0
.text$mn:00004119                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004120                 mov     ecx, [ebp+var_10]
.text$mn:00004123                 call    ??1?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QAE@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>,std::_Iterator_base12>::~_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>,std::_Iterator_base12>(void)
.text$mn:00004128                 mov     ecx, [ebp+var_C]
.text$mn:0000412B                 mov     large fs:0, ecx
.text$mn:00004132                 pop     ecx
.text$mn:00004133                 mov     esp, ebp
.text$mn:00004135                 pop     ebp
.text$mn:00004136                 retn
.text$mn:00004136 ??1?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QAE@XZ endp
.text$mn:00004136
.text$mn:00004136 ; ---------------------------------------------------------------------------
.text$mn:00004137                 align 4
.text$mn:00004137 _text$mn        ends
.text$mn:00004137
.text$x:00004138 ; ===========================================================================
.text$x:00004138
.text$x:00004138 ; Segment type: Pure code
.text$x:00004138 ; Segment permissions: Read/Execute
.text$x:00004138 _text$x         segment para public 'CODE' use32
.text$x:00004138                 assume cs:_text$x
.text$x:00004138                 ;org 4138h
.text$x:00004138 ; COMDAT (pick associative to section at 40EC)
.text$x:00004138                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00004138
.text$x:00004138 ; =============== S U B R O U T I N E =======================================
.text$x:00004138
.text$x:00004138
.text$x:00004138 __unwindfunclet$??1?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00004138                                         ; DATA XREF: .xdata$x:0000A470o
.text$x:00004138                 mov     ecx, [ebp-10h]
.text$x:0000413B                 jmp     ??1?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QAE@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>,std::_Iterator_base12>::~_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>,std::_Iterator_base12>(void)
.text$x:0000413B __unwindfunclet$??1?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:0000413B
.text$x:00004140
.text$x:00004140 ; =============== S U B R O U T I N E =======================================
.text$x:00004140
.text$x:00004140
.text$x:00004140 __ehhandler$??1?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QAE@XZ proc near
.text$x:00004140                                         ; DATA XREF: std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::~_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>(void)+5o
.text$x:00004140
.text$x:00004140 arg_4           = dword ptr  8
.text$x:00004140
.text$x:00004140                 mov     edx, [esp+arg_4]
.text$x:00004144                 lea     eax, [edx+0Ch]
.text$x:00004147                 mov     ecx, [edx-8]
.text$x:0000414A                 xor     ecx, eax
.text$x:0000414C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004151                 mov     eax, offset __ehfuncinfo$??1?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QAE@XZ
.text$x:00004156                 jmp     ___CxxFrameHandler3
.text$x:00004156 __ehhandler$??1?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QAE@XZ endp
.text$x:00004156
.text$x:00004156 ; ---------------------------------------------------------------------------
.text$x:0000415B                 align 4
.text$x:0000415B _text$x         ends
.text$x:0000415B
.text$mn:0000415C ; ===========================================================================
.text$mn:0000415C
.text$mn:0000415C ; Segment type: Pure code
.text$mn:0000415C ; Segment permissions: Read/Execute
.text$mn:0000415C _text$mn        segment para public 'CODE' use32
.text$mn:0000415C                 assume cs:_text$mn
.text$mn:0000415C                 ;org 415Ch
.text$mn:0000415C ; COMDAT (pick any)
.text$mn:0000415C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000415C
.text$mn:0000415C ; =============== S U B R O U T I N E =======================================
.text$mn:0000415C
.text$mn:0000415C ; Attributes: bp-based frame
.text$mn:0000415C
.text$mn:0000415C ; public: __thiscall std::_List_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<int const, struct Style>>>>::~_List_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<int const, struct Style>>>>(void)
.text$mn:0000415C                 public ??1?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@QAE@XZ
.text$mn:0000415C ??1?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@QAE@XZ proc near
.text$mn:0000415C                                         ; CODE XREF: ScintillaEditView::~ScintillaEditView(void)+120p
.text$mn:0000415C                                         ; ScintillaEditView::~ScintillaEditView(void)+15Ep ...
.text$mn:0000415C
.text$mn:0000415C var_10          = dword ptr -10h
.text$mn:0000415C var_C           = dword ptr -0Ch
.text$mn:0000415C var_4           = dword ptr -4
.text$mn:0000415C
.text$mn:0000415C                 push    ebp
.text$mn:0000415D                 mov     ebp, esp
.text$mn:0000415F                 push    0FFFFFFFFh
.text$mn:00004161                 push    offset __ehhandler$??1?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@QAE@XZ
.text$mn:00004166                 mov     eax, large fs:0
.text$mn:0000416C                 push    eax
.text$mn:0000416D                 push    ecx
.text$mn:0000416E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004173                 xor     eax, ebp
.text$mn:00004175                 push    eax
.text$mn:00004176                 lea     eax, [ebp+var_C]
.text$mn:00004179                 mov     large fs:0, eax
.text$mn:0000417F                 mov     [ebp+var_10], ecx
.text$mn:00004182                 mov     [ebp+var_4], 0
.text$mn:00004189                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004190                 mov     ecx, [ebp+var_10]
.text$mn:00004193                 call    ??1?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>::~_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>(void)
.text$mn:00004198                 mov     ecx, [ebp+var_C]
.text$mn:0000419B                 mov     large fs:0, ecx
.text$mn:000041A2                 pop     ecx
.text$mn:000041A3                 mov     esp, ebp
.text$mn:000041A5                 pop     ebp
.text$mn:000041A6                 retn
.text$mn:000041A6 ??1?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@QAE@XZ endp
.text$mn:000041A6
.text$mn:000041A6 ; ---------------------------------------------------------------------------
.text$mn:000041A7                 align 4
.text$mn:000041A7 _text$mn        ends
.text$mn:000041A7
.text$x:000041A8 ; ===========================================================================
.text$x:000041A8
.text$x:000041A8 ; Segment type: Pure code
.text$x:000041A8 ; Segment permissions: Read/Execute
.text$x:000041A8 _text$x         segment para public 'CODE' use32
.text$x:000041A8                 assume cs:_text$x
.text$x:000041A8                 ;org 41A8h
.text$x:000041A8 ; COMDAT (pick associative to section at 415C)
.text$x:000041A8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000041A8
.text$x:000041A8 ; =============== S U B R O U T I N E =======================================
.text$x:000041A8
.text$x:000041A8
.text$x:000041A8 __unwindfunclet$??1?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:000041A8                                         ; DATA XREF: .xdata$x:0000A898o
.text$x:000041A8                 mov     ecx, [ebp-10h]
.text$x:000041AB                 jmp     ??1?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>::~_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>(void)
.text$x:000041AB __unwindfunclet$??1?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:000041AB
.text$x:000041B0
.text$x:000041B0 ; =============== S U B R O U T I N E =======================================
.text$x:000041B0
.text$x:000041B0
.text$x:000041B0 __ehhandler$??1?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@QAE@XZ proc near
.text$x:000041B0                                         ; DATA XREF: std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>::~_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>(void)+5o
.text$x:000041B0
.text$x:000041B0 arg_4           = dword ptr  8
.text$x:000041B0
.text$x:000041B0                 mov     edx, [esp+arg_4]
.text$x:000041B4                 lea     eax, [edx+0Ch]
.text$x:000041B7                 mov     ecx, [edx-8]
.text$x:000041BA                 xor     ecx, eax
.text$x:000041BC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000041C1                 mov     eax, offset __ehfuncinfo$??1?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@QAE@XZ
.text$x:000041C6                 jmp     ___CxxFrameHandler3
.text$x:000041C6 __ehhandler$??1?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@QAE@XZ endp
.text$x:000041C6
.text$x:000041C6 ; ---------------------------------------------------------------------------
.text$x:000041CB                 align 4
.text$x:000041CB _text$x         ends
.text$x:000041CB
.text$mn:000041CC ; ===========================================================================
.text$mn:000041CC
.text$mn:000041CC ; Segment type: Pure code
.text$mn:000041CC ; Segment permissions: Read/Execute
.text$mn:000041CC _text$mn        segment para public 'CODE' use32
.text$mn:000041CC                 assume cs:_text$mn
.text$mn:000041CC                 ;org 41CCh
.text$mn:000041CC ; COMDAT (pick any)
.text$mn:000041CC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000041CC
.text$mn:000041CC ; =============== S U B R O U T I N E =======================================
.text$mn:000041CC
.text$mn:000041CC ; Attributes: bp-based frame
.text$mn:000041CC
.text$mn:000041CC ; public: __thiscall std::_List_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>::~_List_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>(void)
.text$mn:000041CC                 public ??1?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QAE@XZ
.text$mn:000041CC ??1?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QAE@XZ proc near
.text$mn:000041CC                                         ; CODE XREF: ScintillaEditView::~ScintillaEditView(void)+B6p
.text$mn:000041CC                                         ; ScintillaEditView::~ScintillaEditView(void)+19Fp ...
.text$mn:000041CC
.text$mn:000041CC var_10          = dword ptr -10h
.text$mn:000041CC var_C           = dword ptr -0Ch
.text$mn:000041CC var_4           = dword ptr -4
.text$mn:000041CC
.text$mn:000041CC                 push    ebp
.text$mn:000041CD                 mov     ebp, esp
.text$mn:000041CF                 push    0FFFFFFFFh
.text$mn:000041D1                 push    offset __ehhandler$??1?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QAE@XZ
.text$mn:000041D6                 mov     eax, large fs:0
.text$mn:000041DC                 push    eax
.text$mn:000041DD                 push    ecx
.text$mn:000041DE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000041E3                 xor     eax, ebp
.text$mn:000041E5                 push    eax
.text$mn:000041E6                 lea     eax, [ebp+var_C]
.text$mn:000041E9                 mov     large fs:0, eax
.text$mn:000041EF                 mov     [ebp+var_10], ecx
.text$mn:000041F2                 mov     [ebp+var_4], 0
.text$mn:000041F9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004200                 mov     ecx, [ebp+var_10]
.text$mn:00004203                 call    ??1?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::~_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>(void)
.text$mn:00004208                 mov     ecx, [ebp+var_C]
.text$mn:0000420B                 mov     large fs:0, ecx
.text$mn:00004212                 pop     ecx
.text$mn:00004213                 mov     esp, ebp
.text$mn:00004215                 pop     ebp
.text$mn:00004216                 retn
.text$mn:00004216 ??1?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QAE@XZ endp
.text$mn:00004216
.text$mn:00004216 ; ---------------------------------------------------------------------------
.text$mn:00004217                 align 4
.text$mn:00004217 _text$mn        ends
.text$mn:00004217
.text$x:00004218 ; ===========================================================================
.text$x:00004218
.text$x:00004218 ; Segment type: Pure code
.text$x:00004218 ; Segment permissions: Read/Execute
.text$x:00004218 _text$x         segment para public 'CODE' use32
.text$x:00004218                 assume cs:_text$x
.text$x:00004218                 ;org 4218h
.text$x:00004218 ; COMDAT (pick associative to section at 41CC)
.text$x:00004218                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00004218
.text$x:00004218 ; =============== S U B R O U T I N E =======================================
.text$x:00004218
.text$x:00004218
.text$x:00004218 __unwindfunclet$??1?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00004218                                         ; DATA XREF: .xdata$x:0000A4C8o
.text$x:00004218                 mov     ecx, [ebp-10h]
.text$x:0000421B                 jmp     ??1?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::~_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>(void)
.text$x:0000421B __unwindfunclet$??1?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:0000421B
.text$x:00004220
.text$x:00004220 ; =============== S U B R O U T I N E =======================================
.text$x:00004220
.text$x:00004220
.text$x:00004220 __ehhandler$??1?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QAE@XZ proc near
.text$x:00004220                                         ; DATA XREF: std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::~_List_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>(void)+5o
.text$x:00004220
.text$x:00004220 arg_4           = dword ptr  8
.text$x:00004220
.text$x:00004220                 mov     edx, [esp+arg_4]
.text$x:00004224                 lea     eax, [edx+0Ch]
.text$x:00004227                 mov     ecx, [edx-8]
.text$x:0000422A                 xor     ecx, eax
.text$x:0000422C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004231                 mov     eax, offset __ehfuncinfo$??1?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QAE@XZ
.text$x:00004236                 jmp     ___CxxFrameHandler3
.text$x:00004236 __ehhandler$??1?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QAE@XZ endp
.text$x:00004236
.text$x:00004236 ; ---------------------------------------------------------------------------
.text$x:0000423B                 align 4
.text$x:0000423B _text$x         ends
.text$x:0000423B
.text$mn:0000423C ; ===========================================================================
.text$mn:0000423C
.text$mn:0000423C ; Segment type: Pure code
.text$mn:0000423C ; Segment permissions: Read/Execute
.text$mn:0000423C _text$mn        segment para public 'CODE' use32
.text$mn:0000423C                 assume cs:_text$mn
.text$mn:0000423C                 ;org 423Ch
.text$mn:0000423C ; COMDAT (pick any)
.text$mn:0000423C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000423C
.text$mn:0000423C ; =============== S U B R O U T I N E =======================================
.text$mn:0000423C
.text$mn:0000423C ; Attributes: bp-based frame
.text$mn:0000423C
.text$mn:0000423C ; public: __thiscall std::_List_unchecked_const_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<int const, struct Style>>>, struct std::_Iterator_base12>::~_List_unchecked_const_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<int const, struct Style>>>, struct std::_Iterator_base12>(void)
.text$mn:0000423C                 public ??1?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QAE@XZ
.text$mn:0000423C ??1?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QAE@XZ proc near
.text$mn:0000423C                                         ; CODE XREF: __unwindfunclet$??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@1@@Z$0+3j
.text$mn:0000423C                                         ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>::~_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>(void)+37p ...
.text$mn:0000423C
.text$mn:0000423C var_10          = dword ptr -10h
.text$mn:0000423C var_C           = dword ptr -0Ch
.text$mn:0000423C var_4           = dword ptr -4
.text$mn:0000423C
.text$mn:0000423C                 push    ebp
.text$mn:0000423D                 mov     ebp, esp
.text$mn:0000423F                 push    0FFFFFFFFh
.text$mn:00004241                 push    offset __ehhandler$??1?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QAE@XZ
.text$mn:00004246                 mov     eax, large fs:0
.text$mn:0000424C                 push    eax
.text$mn:0000424D                 push    ecx
.text$mn:0000424E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004253                 xor     eax, ebp
.text$mn:00004255                 push    eax
.text$mn:00004256                 lea     eax, [ebp+var_C]
.text$mn:00004259                 mov     large fs:0, eax
.text$mn:0000425F                 mov     [ebp+var_10], ecx
.text$mn:00004262                 mov     [ebp+var_4], 0
.text$mn:00004269                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004270                 mov     ecx, [ebp+var_10]
.text$mn:00004273                 call    ??1?$_Iterator012@Ubidirectional_iterator_tag@std@@U?$pair@$$CBHUStyle@@@2@HPBU32@ABU32@U_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::bidirectional_iterator_tag,std::pair<int const,Style>,int,std::pair<int const,Style> const *,std::pair<int const,Style> const &,std::_Iterator_base12>::~_Iterator012<std::bidirectional_iterator_tag,std::pair<int const,Style>,int,std::pair<int const,Style> const *,std::pair<int const,Style> const &,std::_Iterator_base12>(void)
.text$mn:00004278                 mov     ecx, [ebp+var_C]
.text$mn:0000427B                 mov     large fs:0, ecx
.text$mn:00004282                 pop     ecx
.text$mn:00004283                 mov     esp, ebp
.text$mn:00004285                 pop     ebp
.text$mn:00004286                 retn
.text$mn:00004286 ??1?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QAE@XZ endp
.text$mn:00004286
.text$mn:00004286 ; ---------------------------------------------------------------------------
.text$mn:00004287                 align 4
.text$mn:00004287 _text$mn        ends
.text$mn:00004287
.text$x:00004288 ; ===========================================================================
.text$x:00004288
.text$x:00004288 ; Segment type: Pure code
.text$x:00004288 ; Segment permissions: Read/Execute
.text$x:00004288 _text$x         segment para public 'CODE' use32
.text$x:00004288                 assume cs:_text$x
.text$x:00004288                 ;org 4288h
.text$x:00004288 ; COMDAT (pick associative to section at 423C)
.text$x:00004288                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00004288
.text$x:00004288 ; =============== S U B R O U T I N E =======================================
.text$x:00004288
.text$x:00004288
.text$x:00004288 __unwindfunclet$??1?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QAE@XZ$0 proc near
.text$x:00004288                                         ; DATA XREF: .xdata$x:0000A7E8o
.text$x:00004288                 mov     ecx, [ebp-10h]
.text$x:0000428B                 jmp     ??1?$_Iterator012@Ubidirectional_iterator_tag@std@@U?$pair@$$CBHUStyle@@@2@HPBU32@ABU32@U_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::bidirectional_iterator_tag,std::pair<int const,Style>,int,std::pair<int const,Style> const *,std::pair<int const,Style> const &,std::_Iterator_base12>::~_Iterator012<std::bidirectional_iterator_tag,std::pair<int const,Style>,int,std::pair<int const,Style> const *,std::pair<int const,Style> const &,std::_Iterator_base12>(void)
.text$x:0000428B __unwindfunclet$??1?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QAE@XZ$0 endp
.text$x:0000428B
.text$x:00004290
.text$x:00004290 ; =============== S U B R O U T I N E =======================================
.text$x:00004290
.text$x:00004290
.text$x:00004290 __ehhandler$??1?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QAE@XZ proc near
.text$x:00004290                                         ; DATA XREF: std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>,std::_Iterator_base12>::~_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>,std::_Iterator_base12>(void)+5o
.text$x:00004290
.text$x:00004290 arg_4           = dword ptr  8
.text$x:00004290
.text$x:00004290                 mov     edx, [esp+arg_4]
.text$x:00004294                 lea     eax, [edx+0Ch]
.text$x:00004297                 mov     ecx, [edx-8]
.text$x:0000429A                 xor     ecx, eax
.text$x:0000429C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000042A1                 mov     eax, offset __ehfuncinfo$??1?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QAE@XZ
.text$x:000042A6                 jmp     ___CxxFrameHandler3
.text$x:000042A6 __ehhandler$??1?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QAE@XZ endp
.text$x:000042A6
.text$x:000042A6 ; ---------------------------------------------------------------------------
.text$x:000042AB                 align 4
.text$x:000042AB _text$x         ends
.text$x:000042AB
.text$mn:000042AC ; ===========================================================================
.text$mn:000042AC
.text$mn:000042AC ; Segment type: Pure code
.text$mn:000042AC ; Segment permissions: Read/Execute
.text$mn:000042AC _text$mn        segment para public 'CODE' use32
.text$mn:000042AC                 assume cs:_text$mn
.text$mn:000042AC                 ;org 42ACh
.text$mn:000042AC ; COMDAT (pick any)
.text$mn:000042AC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000042AC
.text$mn:000042AC ; =============== S U B R O U T I N E =======================================
.text$mn:000042AC
.text$mn:000042AC ; Attributes: bp-based frame
.text$mn:000042AC
.text$mn:000042AC ; public: __thiscall std::_List_unchecked_const_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>, struct std::_Iterator_base12>::~_List_unchecked_const_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>, struct std::_Iterator_base12>(void)
.text$mn:000042AC                 public ??1?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QAE@XZ
.text$mn:000042AC ??1?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QAE@XZ proc near
.text$mn:000042AC                                         ; CODE XREF: __unwindfunclet$??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@1@@Z$0+3j
.text$mn:000042AC                                         ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::~_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>(void)+37p ...
.text$mn:000042AC
.text$mn:000042AC var_10          = dword ptr -10h
.text$mn:000042AC var_C           = dword ptr -0Ch
.text$mn:000042AC var_4           = dword ptr -4
.text$mn:000042AC
.text$mn:000042AC                 push    ebp
.text$mn:000042AD                 mov     ebp, esp
.text$mn:000042AF                 push    0FFFFFFFFh
.text$mn:000042B1                 push    offset __ehhandler$??1?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QAE@XZ
.text$mn:000042B6                 mov     eax, large fs:0
.text$mn:000042BC                 push    eax
.text$mn:000042BD                 push    ecx
.text$mn:000042BE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000042C3                 xor     eax, ebp
.text$mn:000042C5                 push    eax
.text$mn:000042C6                 lea     eax, [ebp+var_C]
.text$mn:000042C9                 mov     large fs:0, eax
.text$mn:000042CF                 mov     [ebp+var_10], ecx
.text$mn:000042D2                 mov     [ebp+var_4], 0
.text$mn:000042D9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000042E0                 mov     ecx, [ebp+var_10]
.text$mn:000042E3                 call    ??1?$_Iterator012@Ubidirectional_iterator_tag@std@@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@2@HPBU32@ABU32@U_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::bidirectional_iterator_tag,std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,int,std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *> const *,std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *> const &,std::_Iterator_base12>::~_Iterator012<std::bidirectional_iterator_tag,std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,int,std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *> const *,std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *> const &,std::_Iterator_base12>(void)
.text$mn:000042E8                 mov     ecx, [ebp+var_C]
.text$mn:000042EB                 mov     large fs:0, ecx
.text$mn:000042F2                 pop     ecx
.text$mn:000042F3                 mov     esp, ebp
.text$mn:000042F5                 pop     ebp
.text$mn:000042F6                 retn
.text$mn:000042F6 ??1?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QAE@XZ endp
.text$mn:000042F6
.text$mn:000042F6 ; ---------------------------------------------------------------------------
.text$mn:000042F7                 align 4
.text$mn:000042F7 _text$mn        ends
.text$mn:000042F7
.text$x:000042F8 ; ===========================================================================
.text$x:000042F8
.text$x:000042F8 ; Segment type: Pure code
.text$x:000042F8 ; Segment permissions: Read/Execute
.text$x:000042F8 _text$x         segment para public 'CODE' use32
.text$x:000042F8                 assume cs:_text$x
.text$x:000042F8                 ;org 42F8h
.text$x:000042F8 ; COMDAT (pick associative to section at 42AC)
.text$x:000042F8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000042F8
.text$x:000042F8 ; =============== S U B R O U T I N E =======================================
.text$x:000042F8
.text$x:000042F8
.text$x:000042F8 __unwindfunclet$??1?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QAE@XZ$0 proc near
.text$x:000042F8                                         ; DATA XREF: .xdata$x:0000A418o
.text$x:000042F8                 mov     ecx, [ebp-10h]
.text$x:000042FB                 jmp     ??1?$_Iterator012@Ubidirectional_iterator_tag@std@@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@2@HPBU32@ABU32@U_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::bidirectional_iterator_tag,std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,int,std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *> const *,std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *> const &,std::_Iterator_base12>::~_Iterator012<std::bidirectional_iterator_tag,std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,int,std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *> const *,std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *> const &,std::_Iterator_base12>(void)
.text$x:000042FB __unwindfunclet$??1?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QAE@XZ$0 endp
.text$x:000042FB
.text$x:00004300
.text$x:00004300 ; =============== S U B R O U T I N E =======================================
.text$x:00004300
.text$x:00004300
.text$x:00004300 __ehhandler$??1?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QAE@XZ proc near
.text$x:00004300                                         ; DATA XREF: std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>,std::_Iterator_base12>::~_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>,std::_Iterator_base12>(void)+5o
.text$x:00004300
.text$x:00004300 arg_4           = dword ptr  8
.text$x:00004300
.text$x:00004300                 mov     edx, [esp+arg_4]
.text$x:00004304                 lea     eax, [edx+0Ch]
.text$x:00004307                 mov     ecx, [edx-8]
.text$x:0000430A                 xor     ecx, eax
.text$x:0000430C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004311                 mov     eax, offset __ehfuncinfo$??1?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QAE@XZ
.text$x:00004316                 jmp     ___CxxFrameHandler3
.text$x:00004316 __ehhandler$??1?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QAE@XZ endp
.text$x:00004316
.text$x:00004316 ; ---------------------------------------------------------------------------
.text$x:0000431B                 align 4
.text$x:0000431B _text$x         ends
.text$x:0000431B
.text$mn:0000431C ; ===========================================================================
.text$mn:0000431C
.text$mn:0000431C ; Segment type: Pure code
.text$mn:0000431C ; Segment permissions: Read/Execute
.text$mn:0000431C _text$mn        segment para public 'CODE' use32
.text$mn:0000431C                 assume cs:_text$mn
.text$mn:0000431C                 ;org 431Ch
.text$mn:0000431C ; COMDAT (pick any)
.text$mn:0000431C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000431C
.text$mn:0000431C ; =============== S U B R O U T I N E =======================================
.text$mn:0000431C
.text$mn:0000431C ; Attributes: bp-based frame
.text$mn:0000431C
.text$mn:0000431C ; public: __thiscall std::_List_val<struct std::_List_simple_types<struct std::pair<int const, struct Style>>>::~_List_val<struct std::_List_simple_types<struct std::pair<int const, struct Style>>>(void)
.text$mn:0000431C                 public ??1?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@QAE@XZ
.text$mn:0000431C ??1?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@QAE@XZ proc near
.text$mn:0000431C                                         ; CODE XREF: std::_List_alloc<0,std::_List_base_types<std::pair<int const,Style>,std::allocator<std::pair<int const,Style>>>>::~_List_alloc<0,std::_List_base_types<std::pair<int const,Style>,std::allocator<std::pair<int const,Style>>>>(void)+4Ep
.text$mn:0000431C                                         ; __unwindfunclet$??1?$_List_alloc@$0A@U?$_List_base_types@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@@std@@QAE@XZ$0+3j
.text$mn:0000431C
.text$mn:0000431C var_10          = dword ptr -10h
.text$mn:0000431C var_C           = dword ptr -0Ch
.text$mn:0000431C var_4           = dword ptr -4
.text$mn:0000431C
.text$mn:0000431C                 push    ebp
.text$mn:0000431D                 mov     ebp, esp
.text$mn:0000431F                 push    0FFFFFFFFh
.text$mn:00004321                 push    offset __ehhandler$??1?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@QAE@XZ
.text$mn:00004326                 mov     eax, large fs:0
.text$mn:0000432C                 push    eax
.text$mn:0000432D                 push    ecx
.text$mn:0000432E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004333                 xor     eax, ebp
.text$mn:00004335                 push    eax
.text$mn:00004336                 lea     eax, [ebp+var_C]
.text$mn:00004339                 mov     large fs:0, eax
.text$mn:0000433F                 mov     [ebp+var_10], ecx
.text$mn:00004342                 mov     [ebp+var_4], 0
.text$mn:00004349                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004350                 mov     ecx, [ebp+var_10] ; this
.text$mn:00004353                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:00004358                 mov     ecx, [ebp+var_C]
.text$mn:0000435B                 mov     large fs:0, ecx
.text$mn:00004362                 pop     ecx
.text$mn:00004363                 mov     esp, ebp
.text$mn:00004365                 pop     ebp
.text$mn:00004366                 retn
.text$mn:00004366 ??1?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@QAE@XZ endp
.text$mn:00004366
.text$mn:00004366 ; ---------------------------------------------------------------------------
.text$mn:00004367                 align 4
.text$mn:00004367 _text$mn        ends
.text$mn:00004367
.text$x:00004368 ; ===========================================================================
.text$x:00004368
.text$x:00004368 ; Segment type: Pure code
.text$x:00004368 ; Segment permissions: Read/Execute
.text$x:00004368 _text$x         segment para public 'CODE' use32
.text$x:00004368                 assume cs:_text$x
.text$x:00004368                 ;org 4368h
.text$x:00004368 ; COMDAT (pick associative to section at 431C)
.text$x:00004368                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00004368
.text$x:00004368 ; =============== S U B R O U T I N E =======================================
.text$x:00004368
.text$x:00004368
.text$x:00004368 __unwindfunclet$??1?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00004368                                         ; DATA XREF: .xdata$x:0000A4F4o
.text$x:00004368                 mov     ecx, [ebp-10h]  ; this
.text$x:0000436B                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:0000436B __unwindfunclet$??1?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:0000436B
.text$x:00004370
.text$x:00004370 ; =============== S U B R O U T I N E =======================================
.text$x:00004370
.text$x:00004370
.text$x:00004370 __ehhandler$??1?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@QAE@XZ proc near
.text$x:00004370                                         ; DATA XREF: std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>::~_List_val<std::_List_simple_types<std::pair<int const,Style>>>(void)+5o
.text$x:00004370
.text$x:00004370 arg_4           = dword ptr  8
.text$x:00004370
.text$x:00004370                 mov     edx, [esp+arg_4]
.text$x:00004374                 lea     eax, [edx+0Ch]
.text$x:00004377                 mov     ecx, [edx-8]
.text$x:0000437A                 xor     ecx, eax
.text$x:0000437C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004381                 mov     eax, offset __ehfuncinfo$??1?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@QAE@XZ
.text$x:00004386                 jmp     ___CxxFrameHandler3
.text$x:00004386 __ehhandler$??1?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@QAE@XZ endp
.text$x:00004386
.text$x:00004386 ; ---------------------------------------------------------------------------
.text$x:0000438B                 align 4
.text$x:0000438B _text$x         ends
.text$x:0000438B
.text$mn:0000438C ; ===========================================================================
.text$mn:0000438C
.text$mn:0000438C ; Segment type: Pure code
.text$mn:0000438C ; Segment permissions: Read/Execute
.text$mn:0000438C _text$mn        segment para public 'CODE' use32
.text$mn:0000438C                 assume cs:_text$mn
.text$mn:0000438C                 ;org 438Ch
.text$mn:0000438C ; COMDAT (pick any)
.text$mn:0000438C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000438C
.text$mn:0000438C ; =============== S U B R O U T I N E =======================================
.text$mn:0000438C
.text$mn:0000438C ; Attributes: bp-based frame
.text$mn:0000438C
.text$mn:0000438C ; public: __thiscall std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>::~_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>(void)
.text$mn:0000438C                 public ??1?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@QAE@XZ
.text$mn:0000438C ??1?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@QAE@XZ proc near
.text$mn:0000438C                                         ; CODE XREF: __unwindfunclet$??0?$_List_alloc@$0A@U?$_List_base_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@1@@Z$2+3j
.text$mn:0000438C                                         ; std::_List_alloc<0,std::_List_base_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::~_List_alloc<0,std::_List_base_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>(void)+4Ep ...
.text$mn:0000438C
.text$mn:0000438C var_10          = dword ptr -10h
.text$mn:0000438C var_C           = dword ptr -0Ch
.text$mn:0000438C var_4           = dword ptr -4
.text$mn:0000438C
.text$mn:0000438C                 push    ebp
.text$mn:0000438D                 mov     ebp, esp
.text$mn:0000438F                 push    0FFFFFFFFh
.text$mn:00004391                 push    offset __ehhandler$??1?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@QAE@XZ
.text$mn:00004396                 mov     eax, large fs:0
.text$mn:0000439C                 push    eax
.text$mn:0000439D                 push    ecx
.text$mn:0000439E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000043A3                 xor     eax, ebp
.text$mn:000043A5                 push    eax
.text$mn:000043A6                 lea     eax, [ebp+var_C]
.text$mn:000043A9                 mov     large fs:0, eax
.text$mn:000043AF                 mov     [ebp+var_10], ecx
.text$mn:000043B2                 mov     [ebp+var_4], 0
.text$mn:000043B9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000043C0                 mov     ecx, [ebp+var_10] ; this
.text$mn:000043C3                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:000043C8                 mov     ecx, [ebp+var_C]
.text$mn:000043CB                 mov     large fs:0, ecx
.text$mn:000043D2                 pop     ecx
.text$mn:000043D3                 mov     esp, ebp
.text$mn:000043D5                 pop     ebp
.text$mn:000043D6                 retn
.text$mn:000043D6 ??1?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@QAE@XZ endp
.text$mn:000043D6
.text$mn:000043D6 ; ---------------------------------------------------------------------------
.text$mn:000043D7                 align 4
.text$mn:000043D7 _text$mn        ends
.text$mn:000043D7
.text$x:000043D8 ; ===========================================================================
.text$x:000043D8
.text$x:000043D8 ; Segment type: Pure code
.text$x:000043D8 ; Segment permissions: Read/Execute
.text$x:000043D8 _text$x         segment para public 'CODE' use32
.text$x:000043D8                 assume cs:_text$x
.text$x:000043D8                 ;org 43D8h
.text$x:000043D8 ; COMDAT (pick associative to section at 438C)
.text$x:000043D8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000043D8
.text$x:000043D8 ; =============== S U B R O U T I N E =======================================
.text$x:000043D8
.text$x:000043D8
.text$x:000043D8 __unwindfunclet$??1?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:000043D8                                         ; DATA XREF: .xdata$x:00009DC4o
.text$x:000043D8                 mov     ecx, [ebp-10h]  ; this
.text$x:000043DB                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:000043DB __unwindfunclet$??1?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:000043DB
.text$x:000043E0
.text$x:000043E0 ; =============== S U B R O U T I N E =======================================
.text$x:000043E0
.text$x:000043E0
.text$x:000043E0 __ehhandler$??1?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@QAE@XZ proc near
.text$x:000043E0                                         ; DATA XREF: std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>::~_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>(void)+5o
.text$x:000043E0
.text$x:000043E0 arg_4           = dword ptr  8
.text$x:000043E0
.text$x:000043E0                 mov     edx, [esp+arg_4]
.text$x:000043E4                 lea     eax, [edx+0Ch]
.text$x:000043E7                 mov     ecx, [edx-8]
.text$x:000043EA                 xor     ecx, eax
.text$x:000043EC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000043F1                 mov     eax, offset __ehfuncinfo$??1?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@QAE@XZ
.text$x:000043F6                 jmp     ___CxxFrameHandler3
.text$x:000043F6 __ehhandler$??1?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@QAE@XZ endp
.text$x:000043F6
.text$x:000043F6 ; ---------------------------------------------------------------------------
.text$x:000043FB                 align 4
.text$x:000043FB _text$x         ends
.text$x:000043FB
.text$mn:000043FC ; ===========================================================================
.text$mn:000043FC
.text$mn:000043FC ; Segment type: Pure code
.text$mn:000043FC ; Segment permissions: Read/Execute
.text$mn:000043FC _text$mn        segment para public 'CODE' use32
.text$mn:000043FC                 assume cs:_text$mn
.text$mn:000043FC                 ;org 43FCh
.text$mn:000043FC ; COMDAT (pick any)
.text$mn:000043FC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000043FC
.text$mn:000043FC ; =============== S U B R O U T I N E =======================================
.text$mn:000043FC
.text$mn:000043FC ; Attributes: bp-based frame
.text$mn:000043FC
.text$mn:000043FC ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::~_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>(void)
.text$mn:000043FC                 public ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$mn:000043FC ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
.text$mn:000043FC                                         ; CODE XREF: __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0+3j
.text$mn:000043FC                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+43p ...
.text$mn:000043FC
.text$mn:000043FC var_10          = dword ptr -10h
.text$mn:000043FC var_C           = dword ptr -0Ch
.text$mn:000043FC var_4           = dword ptr -4
.text$mn:000043FC
.text$mn:000043FC                 push    ebp
.text$mn:000043FD                 mov     ebp, esp
.text$mn:000043FF                 push    0FFFFFFFFh
.text$mn:00004401                 push    offset __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$mn:00004406                 mov     eax, large fs:0
.text$mn:0000440C                 push    eax
.text$mn:0000440D                 push    ecx
.text$mn:0000440E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004413                 xor     eax, ebp
.text$mn:00004415                 push    eax
.text$mn:00004416                 lea     eax, [ebp+var_C]
.text$mn:00004419                 mov     large fs:0, eax
.text$mn:0000441F                 mov     [ebp+var_10], ecx
.text$mn:00004422                 mov     [ebp+var_4], 0
.text$mn:00004429                 mov     ecx, [ebp+var_10]
.text$mn:0000442C                 call    ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)
.text$mn:00004431                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004438                 mov     ecx, [ebp+var_10]
.text$mn:0000443B                 call    ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$mn:00004440                 mov     ecx, [ebp+var_C]
.text$mn:00004443                 mov     large fs:0, ecx
.text$mn:0000444A                 pop     ecx
.text$mn:0000444B                 mov     esp, ebp
.text$mn:0000444D                 pop     ebp
.text$mn:0000444E                 retn
.text$mn:0000444E ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp
.text$mn:0000444E
.text$mn:0000444E ; ---------------------------------------------------------------------------
.text$mn:0000444F                 align 10h
.text$mn:0000444F _text$mn        ends
.text$mn:0000444F
.text$x:00004450 ; ===========================================================================
.text$x:00004450
.text$x:00004450 ; Segment type: Pure code
.text$x:00004450 ; Segment permissions: Read/Execute
.text$x:00004450 _text$x         segment para public 'CODE' use32
.text$x:00004450                 assume cs:_text$x
.text$x:00004450                 ;org 4450h
.text$x:00004450 ; COMDAT (pick associative to section at 43FC)
.text$x:00004450                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00004450
.text$x:00004450 ; =============== S U B R O U T I N E =======================================
.text$x:00004450
.text$x:00004450
.text$x:00004450 __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00004450                                         ; DATA XREF: .xdata$x:00009860o
.text$x:00004450                 mov     ecx, [ebp-10h]
.text$x:00004453                 jmp     ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$x:00004453 __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:00004453
.text$x:00004458
.text$x:00004458 ; =============== S U B R O U T I N E =======================================
.text$x:00004458
.text$x:00004458
.text$x:00004458 __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
.text$x:00004458                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+5o
.text$x:00004458
.text$x:00004458 arg_4           = dword ptr  8
.text$x:00004458
.text$x:00004458                 mov     edx, [esp+arg_4]
.text$x:0000445C                 lea     eax, [edx+0Ch]
.text$x:0000445F                 mov     ecx, [edx-8]
.text$x:00004462                 xor     ecx, eax
.text$x:00004464                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004469                 mov     eax, offset __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$x:0000446E                 jmp     ___CxxFrameHandler3
.text$x:0000446E __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp
.text$x:0000446E
.text$x:0000446E ; ---------------------------------------------------------------------------
.text$x:00004473                 align 4
.text$x:00004473 _text$x         ends
.text$x:00004473
.text$mn:00004474 ; ===========================================================================
.text$mn:00004474
.text$mn:00004474 ; Segment type: Pure code
.text$mn:00004474 ; Segment permissions: Read/Execute
.text$mn:00004474 _text$mn        segment para public 'CODE' use32
.text$mn:00004474                 assume cs:_text$mn
.text$mn:00004474                 ;org 4474h
.text$mn:00004474 ; COMDAT (pick any)
.text$mn:00004474                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004474
.text$mn:00004474 ; =============== S U B R O U T I N E =======================================
.text$mn:00004474
.text$mn:00004474 ; Attributes: bp-based frame
.text$mn:00004474
.text$mn:00004474 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>::~_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>(void)
.text$mn:00004474                 public ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
.text$mn:00004474 ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00004474                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)+43p
.text$mn:00004474                                         ; __unwindfunclet$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ$0+3j
.text$mn:00004474
.text$mn:00004474 var_10          = dword ptr -10h
.text$mn:00004474 var_C           = dword ptr -0Ch
.text$mn:00004474 var_4           = dword ptr -4
.text$mn:00004474
.text$mn:00004474                 push    ebp
.text$mn:00004475                 mov     ebp, esp
.text$mn:00004477                 push    0FFFFFFFFh
.text$mn:00004479                 push    offset __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
.text$mn:0000447E                 mov     eax, large fs:0
.text$mn:00004484                 push    eax
.text$mn:00004485                 push    ecx
.text$mn:00004486                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000448B                 xor     eax, ebp
.text$mn:0000448D                 push    eax
.text$mn:0000448E                 lea     eax, [ebp+var_C]
.text$mn:00004491                 mov     large fs:0, eax
.text$mn:00004497                 mov     [ebp+var_10], ecx
.text$mn:0000449A                 mov     [ebp+var_4], 0
.text$mn:000044A1                 mov     ecx, [ebp+var_10]
.text$mn:000044A4                 call    ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Free_proxy(void)
.text$mn:000044A9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000044B0                 mov     ecx, [ebp+var_10]
.text$mn:000044B3                 call    ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t>>::~_String_val<std::_Simple_types<wchar_t>>(void)
.text$mn:000044B8                 mov     ecx, [ebp+var_C]
.text$mn:000044BB                 mov     large fs:0, ecx
.text$mn:000044C2                 pop     ecx
.text$mn:000044C3                 mov     esp, ebp
.text$mn:000044C5                 pop     ebp
.text$mn:000044C6                 retn
.text$mn:000044C6 ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ endp
.text$mn:000044C6
.text$mn:000044C6 ; ---------------------------------------------------------------------------
.text$mn:000044C7                 align 4
.text$mn:000044C7 _text$mn        ends
.text$mn:000044C7
.text$x:000044C8 ; ===========================================================================
.text$x:000044C8
.text$x:000044C8 ; Segment type: Pure code
.text$x:000044C8 ; Segment permissions: Read/Execute
.text$x:000044C8 _text$x         segment para public 'CODE' use32
.text$x:000044C8                 assume cs:_text$x
.text$x:000044C8                 ;org 44C8h
.text$x:000044C8 ; COMDAT (pick associative to section at 4474)
.text$x:000044C8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000044C8
.text$x:000044C8 ; =============== S U B R O U T I N E =======================================
.text$x:000044C8
.text$x:000044C8
.text$x:000044C8 __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:000044C8                                         ; DATA XREF: .xdata$x:00009CB8o
.text$x:000044C8                 mov     ecx, [ebp-10h]
.text$x:000044CB                 jmp     ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t>>::~_String_val<std::_Simple_types<wchar_t>>(void)
.text$x:000044CB __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:000044CB
.text$x:000044D0
.text$x:000044D0 ; =============== S U B R O U T I N E =======================================
.text$x:000044D0
.text$x:000044D0
.text$x:000044D0 __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ proc near
.text$x:000044D0                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)+5o
.text$x:000044D0
.text$x:000044D0 arg_4           = dword ptr  8
.text$x:000044D0
.text$x:000044D0                 mov     edx, [esp+arg_4]
.text$x:000044D4                 lea     eax, [edx+0Ch]
.text$x:000044D7                 mov     ecx, [edx-8]
.text$x:000044DA                 xor     ecx, eax
.text$x:000044DC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000044E1                 mov     eax, offset __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
.text$x:000044E6                 jmp     ___CxxFrameHandler3
.text$x:000044E6 __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ endp
.text$x:000044E6
.text$x:000044E6 ; ---------------------------------------------------------------------------
.text$x:000044EB                 align 4
.text$x:000044EB _text$x         ends
.text$x:000044EB
.text$mn:000044EC ; ===========================================================================
.text$mn:000044EC
.text$mn:000044EC ; Segment type: Pure code
.text$mn:000044EC ; Segment permissions: Read/Execute
.text$mn:000044EC _text$mn        segment para public 'CODE' use32
.text$mn:000044EC                 assume cs:_text$mn
.text$mn:000044EC                 ;org 44ECh
.text$mn:000044EC ; COMDAT (pick any)
.text$mn:000044EC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000044EC
.text$mn:000044EC ; =============== S U B R O U T I N E =======================================
.text$mn:000044EC
.text$mn:000044EC ; Attributes: bp-based frame
.text$mn:000044EC
.text$mn:000044EC ; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::~_String_val<struct std::_Simple_types<char>>(void)
.text$mn:000044EC                 public ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:000044EC ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$mn:000044EC                                         ; CODE XREF: __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0+3j
.text$mn:000044EC                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+3Fp ...
.text$mn:000044EC
.text$mn:000044EC var_10          = dword ptr -10h
.text$mn:000044EC var_C           = dword ptr -0Ch
.text$mn:000044EC var_4           = dword ptr -4
.text$mn:000044EC
.text$mn:000044EC                 push    ebp
.text$mn:000044ED                 mov     ebp, esp
.text$mn:000044EF                 push    0FFFFFFFFh
.text$mn:000044F1                 push    offset __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:000044F6                 mov     eax, large fs:0
.text$mn:000044FC                 push    eax
.text$mn:000044FD                 push    ecx
.text$mn:000044FE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004503                 xor     eax, ebp
.text$mn:00004505                 push    eax
.text$mn:00004506                 lea     eax, [ebp+var_C]
.text$mn:00004509                 mov     large fs:0, eax
.text$mn:0000450F                 mov     [ebp+var_10], ecx
.text$mn:00004512                 mov     [ebp+var_4], 0
.text$mn:00004519                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004520                 mov     ecx, [ebp+var_10] ; this
.text$mn:00004523                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:00004528                 mov     ecx, [ebp+var_C]
.text$mn:0000452B                 mov     large fs:0, ecx
.text$mn:00004532                 pop     ecx
.text$mn:00004533                 mov     esp, ebp
.text$mn:00004535                 pop     ebp
.text$mn:00004536                 retn
.text$mn:00004536 ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$mn:00004536
.text$mn:00004536 ; ---------------------------------------------------------------------------
.text$mn:00004537                 align 4
.text$mn:00004537 _text$mn        ends
.text$mn:00004537
.text$x:00004538 ; ===========================================================================
.text$x:00004538
.text$x:00004538 ; Segment type: Pure code
.text$x:00004538 ; Segment permissions: Read/Execute
.text$x:00004538 _text$x         segment para public 'CODE' use32
.text$x:00004538                 assume cs:_text$x
.text$x:00004538                 ;org 4538h
.text$x:00004538 ; COMDAT (pick associative to section at 44EC)
.text$x:00004538                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00004538
.text$x:00004538 ; =============== S U B R O U T I N E =======================================
.text$x:00004538
.text$x:00004538
.text$x:00004538 __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 proc near
.text$x:00004538                                         ; DATA XREF: .xdata$x:00009808o
.text$x:00004538                 mov     ecx, [ebp-10h]  ; this
.text$x:0000453B                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:0000453B __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 endp
.text$x:0000453B
.text$x:00004540
.text$x:00004540 ; =============== S U B R O U T I N E =======================================
.text$x:00004540
.text$x:00004540
.text$x:00004540 __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$x:00004540                                         ; DATA XREF: std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)+5o
.text$x:00004540
.text$x:00004540 arg_4           = dword ptr  8
.text$x:00004540
.text$x:00004540                 mov     edx, [esp+arg_4]
.text$x:00004544                 lea     eax, [edx+0Ch]
.text$x:00004547                 mov     ecx, [edx-8]
.text$x:0000454A                 xor     ecx, eax
.text$x:0000454C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004551                 mov     eax, offset __ehfuncinfo$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$x:00004556                 jmp     ___CxxFrameHandler3
.text$x:00004556 __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$x:00004556
.text$x:00004556 ; ---------------------------------------------------------------------------
.text$x:0000455B                 align 4
.text$x:0000455B _text$x         ends
.text$x:0000455B
.text$mn:0000455C ; ===========================================================================
.text$mn:0000455C
.text$mn:0000455C ; Segment type: Pure code
.text$mn:0000455C ; Segment permissions: Read/Execute
.text$mn:0000455C _text$mn        segment para public 'CODE' use32
.text$mn:0000455C                 assume cs:_text$mn
.text$mn:0000455C                 ;org 455Ch
.text$mn:0000455C ; COMDAT (pick any)
.text$mn:0000455C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000455C
.text$mn:0000455C ; =============== S U B R O U T I N E =======================================
.text$mn:0000455C
.text$mn:0000455C ; Attributes: bp-based frame
.text$mn:0000455C
.text$mn:0000455C ; public: __thiscall std::_String_val<struct std::_Simple_types<wchar_t>>::~_String_val<struct std::_Simple_types<wchar_t>>(void)
.text$mn:0000455C                 public ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$mn:0000455C ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ proc near
.text$mn:0000455C                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)+3Fp
.text$mn:0000455C                                         ; __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ$0+3j
.text$mn:0000455C
.text$mn:0000455C var_10          = dword ptr -10h
.text$mn:0000455C var_C           = dword ptr -0Ch
.text$mn:0000455C var_4           = dword ptr -4
.text$mn:0000455C
.text$mn:0000455C                 push    ebp
.text$mn:0000455D                 mov     ebp, esp
.text$mn:0000455F                 push    0FFFFFFFFh
.text$mn:00004561                 push    offset __ehhandler$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$mn:00004566                 mov     eax, large fs:0
.text$mn:0000456C                 push    eax
.text$mn:0000456D                 push    ecx
.text$mn:0000456E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004573                 xor     eax, ebp
.text$mn:00004575                 push    eax
.text$mn:00004576                 lea     eax, [ebp+var_C]
.text$mn:00004579                 mov     large fs:0, eax
.text$mn:0000457F                 mov     [ebp+var_10], ecx
.text$mn:00004582                 mov     [ebp+var_4], 0
.text$mn:00004589                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004590                 mov     ecx, [ebp+var_10] ; this
.text$mn:00004593                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:00004598                 mov     ecx, [ebp+var_C]
.text$mn:0000459B                 mov     large fs:0, ecx
.text$mn:000045A2                 pop     ecx
.text$mn:000045A3                 mov     esp, ebp
.text$mn:000045A5                 pop     ebp
.text$mn:000045A6                 retn
.text$mn:000045A6 ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ endp
.text$mn:000045A6
.text$mn:000045A6 ; ---------------------------------------------------------------------------
.text$mn:000045A7                 align 4
.text$mn:000045A7 _text$mn        ends
.text$mn:000045A7
.text$x:000045A8 ; ===========================================================================
.text$x:000045A8
.text$x:000045A8 ; Segment type: Pure code
.text$x:000045A8 ; Segment permissions: Read/Execute
.text$x:000045A8 _text$x         segment para public 'CODE' use32
.text$x:000045A8                 assume cs:_text$x
.text$x:000045A8                 ;org 45A8h
.text$x:000045A8 ; COMDAT (pick associative to section at 455C)
.text$x:000045A8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000045A8
.text$x:000045A8 ; =============== S U B R O U T I N E =======================================
.text$x:000045A8
.text$x:000045A8
.text$x:000045A8 __unwindfunclet$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0 proc near
.text$x:000045A8                                         ; DATA XREF: .xdata$x:00009C8Co
.text$x:000045A8                 mov     ecx, [ebp-10h]  ; this
.text$x:000045AB                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:000045AB __unwindfunclet$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0 endp
.text$x:000045AB
.text$x:000045B0
.text$x:000045B0 ; =============== S U B R O U T I N E =======================================
.text$x:000045B0
.text$x:000045B0
.text$x:000045B0 __ehhandler$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ proc near
.text$x:000045B0                                         ; DATA XREF: std::_String_val<std::_Simple_types<wchar_t>>::~_String_val<std::_Simple_types<wchar_t>>(void)+5o
.text$x:000045B0
.text$x:000045B0 arg_4           = dword ptr  8
.text$x:000045B0
.text$x:000045B0                 mov     edx, [esp+arg_4]
.text$x:000045B4                 lea     eax, [edx+0Ch]
.text$x:000045B7                 mov     ecx, [edx-8]
.text$x:000045BA                 xor     ecx, eax
.text$x:000045BC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000045C1                 mov     eax, offset __ehfuncinfo$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$x:000045C6                 jmp     ___CxxFrameHandler3
.text$x:000045C6 __ehhandler$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ endp
.text$x:000045C6
.text$x:000045C6 ; ---------------------------------------------------------------------------
.text$x:000045CB                 align 4
.text$x:000045CB _text$x         ends
.text$x:000045CB
.text$mn:000045CC ; ===========================================================================
.text$mn:000045CC
.text$mn:000045CC ; Segment type: Pure code
.text$mn:000045CC ; Segment permissions: Read/Execute
.text$mn:000045CC _text$mn        segment para public 'CODE' use32
.text$mn:000045CC                 assume cs:_text$mn
.text$mn:000045CC                 ;org 45CCh
.text$mn:000045CC ; COMDAT (pick any)
.text$mn:000045CC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000045CC
.text$mn:000045CC ; =============== S U B R O U T I N E =======================================
.text$mn:000045CC
.text$mn:000045CC ; Attributes: bp-based frame
.text$mn:000045CC
.text$mn:000045CC ; public: __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<int const, struct Style>>>>, struct std::_Wrap_alloc<class std::allocator<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<int const, struct Style>>>>>>>>::~_Vector_alloc<0, struct std::_Vec_base_types<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<int const, struct Style>>>>, struct std::_Wrap_alloc<class std::allocator<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<int const, struct Style>>>>>>>>(void)
.text$mn:000045CC                 public ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QAE@XZ
.text$mn:000045CC ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QAE@XZ proc near
.text$mn:000045CC                                         ; CODE XREF: std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>>>>::~vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>>>>(void)+3Fp
.text$mn:000045CC                                         ; __unwindfunclet$??1?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAE@XZ$0+3j
.text$mn:000045CC
.text$mn:000045CC var_10          = dword ptr -10h
.text$mn:000045CC var_C           = dword ptr -0Ch
.text$mn:000045CC var_4           = dword ptr -4
.text$mn:000045CC
.text$mn:000045CC                 push    ebp
.text$mn:000045CD                 mov     ebp, esp
.text$mn:000045CF                 push    0FFFFFFFFh
.text$mn:000045D1                 push    offset __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QAE@XZ
.text$mn:000045D6                 mov     eax, large fs:0
.text$mn:000045DC                 push    eax
.text$mn:000045DD                 push    ecx
.text$mn:000045DE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000045E3                 xor     eax, ebp
.text$mn:000045E5                 push    eax
.text$mn:000045E6                 lea     eax, [ebp+var_C]
.text$mn:000045E9                 mov     large fs:0, eax
.text$mn:000045EF                 mov     [ebp+var_10], ecx
.text$mn:000045F2                 mov     [ebp+var_4], 0
.text$mn:000045F9                 mov     ecx, [ebp+var_10]
.text$mn:000045FC                 call    ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QAEXXZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>>>>>::_Free_proxy(void)
.text$mn:00004601                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004608                 mov     ecx, [ebp+var_10]
.text$mn:0000460B                 call    ??1?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>>>::~_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>>>(void)
.text$mn:00004610                 mov     ecx, [ebp+var_C]
.text$mn:00004613                 mov     large fs:0, ecx
.text$mn:0000461A                 pop     ecx
.text$mn:0000461B                 mov     esp, ebp
.text$mn:0000461D                 pop     ebp
.text$mn:0000461E                 retn
.text$mn:0000461E ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QAE@XZ endp
.text$mn:0000461E
.text$mn:0000461E ; ---------------------------------------------------------------------------
.text$mn:0000461F                 align 10h
.text$mn:0000461F _text$mn        ends
.text$mn:0000461F
.text$x:00004620 ; ===========================================================================
.text$x:00004620
.text$x:00004620 ; Segment type: Pure code
.text$x:00004620 ; Segment permissions: Read/Execute
.text$x:00004620 _text$x         segment para public 'CODE' use32
.text$x:00004620                 assume cs:_text$x
.text$x:00004620                 ;org 4620h
.text$x:00004620 ; COMDAT (pick associative to section at 45CC)
.text$x:00004620                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00004620
.text$x:00004620 ; =============== S U B R O U T I N E =======================================
.text$x:00004620
.text$x:00004620
.text$x:00004620 __unwindfunclet$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QAE@XZ$0 proc near
.text$x:00004620                                         ; DATA XREF: .xdata$x:0000A6E0o
.text$x:00004620                 mov     ecx, [ebp-10h]
.text$x:00004623                 jmp     ??1?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>>>::~_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>>>(void)
.text$x:00004623 __unwindfunclet$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QAE@XZ$0 endp
.text$x:00004623
.text$x:00004628
.text$x:00004628 ; =============== S U B R O U T I N E =======================================
.text$x:00004628
.text$x:00004628
.text$x:00004628 __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QAE@XZ proc near
.text$x:00004628                                         ; DATA XREF: std::_Vector_alloc<0,std::_Vec_base_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>>>>>::~_Vector_alloc<0,std::_Vec_base_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>>>>>(void)+5o
.text$x:00004628
.text$x:00004628 arg_4           = dword ptr  8
.text$x:00004628
.text$x:00004628                 mov     edx, [esp+arg_4]
.text$x:0000462C                 lea     eax, [edx+0Ch]
.text$x:0000462F                 mov     ecx, [edx-8]
.text$x:00004632                 xor     ecx, eax
.text$x:00004634                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004639                 mov     eax, offset __ehfuncinfo$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QAE@XZ
.text$x:0000463E                 jmp     ___CxxFrameHandler3
.text$x:0000463E __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QAE@XZ endp
.text$x:0000463E
.text$x:0000463E ; ---------------------------------------------------------------------------
.text$x:00004643                 align 4
.text$x:00004643 _text$x         ends
.text$x:00004643
.text$mn:00004644 ; ===========================================================================
.text$mn:00004644
.text$mn:00004644 ; Segment type: Pure code
.text$mn:00004644 ; Segment permissions: Read/Execute
.text$mn:00004644 _text$mn        segment para public 'CODE' use32
.text$mn:00004644                 assume cs:_text$mn
.text$mn:00004644                 ;org 4644h
.text$mn:00004644 ; COMDAT (pick any)
.text$mn:00004644                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004644
.text$mn:00004644 ; =============== S U B R O U T I N E =======================================
.text$mn:00004644
.text$mn:00004644 ; Attributes: bp-based frame
.text$mn:00004644
.text$mn:00004644 ; public: __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>, struct std::_Wrap_alloc<class std::allocator<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>>>>>::~_Vector_alloc<0, struct std::_Vec_base_types<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const,
.text$mn:00004644                 public ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QAE@XZ
.text$mn:00004644 ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QAE@XZ proc near
.text$mn:00004644                                         ; CODE XREF: __unwindfunclet$??0?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAE@ABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@1@@Z$0+3j
.text$mn:00004644                                         ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::~vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>(void)+3Fp ...
.text$mn:00004644
.text$mn:00004644 var_10          = dword ptr -10h
.text$mn:00004644 var_C           = dword ptr -0Ch
.text$mn:00004644 var_4           = dword ptr -4
.text$mn:00004644
.text$mn:00004644                 push    ebp
.text$mn:00004645                 mov     ebp, esp
.text$mn:00004647                 push    0FFFFFFFFh
.text$mn:00004649                 push    offset __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QAE@XZ
.text$mn:0000464E                 mov     eax, large fs:0
.text$mn:00004654                 push    eax
.text$mn:00004655                 push    ecx
.text$mn:00004656                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000465B                 xor     eax, ebp
.text$mn:0000465D                 push    eax
.text$mn:0000465E                 lea     eax, [ebp+var_C]
.text$mn:00004661                 mov     large fs:0, eax
.text$mn:00004667                 mov     [ebp+var_10], ecx
.text$mn:0000466A                 mov     [ebp+var_4], 0
.text$mn:00004671                 mov     ecx, [ebp+var_10]
.text$mn:00004674                 call    ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QAEXXZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>>::_Free_proxy(void)
.text$mn:00004679                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004680                 mov     ecx, [ebp+var_10]
.text$mn:00004683                 call    ??1?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>::~_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>(void)
.text$mn:00004688                 mov     ecx, [ebp+var_C]
.text$mn:0000468B                 mov     large fs:0, ecx
.text$mn:00004692                 pop     ecx
.text$mn:00004693                 mov     esp, ebp
.text$mn:00004695                 pop     ebp
.text$mn:00004696                 retn
.text$mn:00004696 ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QAE@XZ endp
.text$mn:00004696
.text$mn:00004696 ; ---------------------------------------------------------------------------
.text$mn:00004697                 align 4
.text$mn:00004697 _text$mn        ends
.text$mn:00004697
.text$x:00004698 ; ===========================================================================
.text$x:00004698
.text$x:00004698 ; Segment type: Pure code
.text$x:00004698 ; Segment permissions: Read/Execute
.text$x:00004698 _text$x         segment para public 'CODE' use32
.text$x:00004698                 assume cs:_text$x
.text$x:00004698                 ;org 4698h
.text$x:00004698 ; COMDAT (pick associative to section at 4644)
.text$x:00004698                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00004698
.text$x:00004698 ; =============== S U B R O U T I N E =======================================
.text$x:00004698
.text$x:00004698
.text$x:00004698 __unwindfunclet$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QAE@XZ$0 proc near
.text$x:00004698                                         ; DATA XREF: .xdata$x:0000A14Co
.text$x:00004698                 mov     ecx, [ebp-10h]
.text$x:0000469B                 jmp     ??1?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>::~_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>(void)
.text$x:0000469B __unwindfunclet$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QAE@XZ$0 endp
.text$x:0000469B
.text$x:000046A0
.text$x:000046A0 ; =============== S U B R O U T I N E =======================================
.text$x:000046A0
.text$x:000046A0
.text$x:000046A0 __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QAE@XZ proc near
.text$x:000046A0                                         ; DATA XREF: std::_Vector_alloc<0,std::_Vec_base_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>>::~_Vector_alloc<0,std::_Vec_base_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>>(void)+5o
.text$x:000046A0
.text$x:000046A0 arg_4           = dword ptr  8
.text$x:000046A0
.text$x:000046A0                 mov     edx, [esp+arg_4]
.text$x:000046A4                 lea     eax, [edx+0Ch]
.text$x:000046A7                 mov     ecx, [edx-8]
.text$x:000046AA                 xor     ecx, eax
.text$x:000046AC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000046B1                 mov     eax, offset __ehfuncinfo$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QAE@XZ
.text$x:000046B6                 jmp     ___CxxFrameHandler3
.text$x:000046B6 __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QAE@XZ endp
.text$x:000046B6
.text$x:000046B6 ; ---------------------------------------------------------------------------
.text$x:000046BB                 align 4
.text$x:000046BB _text$x         ends
.text$x:000046BB
.text$mn:000046BC ; ===========================================================================
.text$mn:000046BC
.text$mn:000046BC ; Segment type: Pure code
.text$mn:000046BC ; Segment permissions: Read/Execute
.text$mn:000046BC _text$mn        segment para public 'CODE' use32
.text$mn:000046BC                 assume cs:_text$mn
.text$mn:000046BC                 ;org 46BCh
.text$mn:000046BC ; COMDAT (pick any)
.text$mn:000046BC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000046BC
.text$mn:000046BC ; =============== S U B R O U T I N E =======================================
.text$mn:000046BC
.text$mn:000046BC ; Attributes: bp-based frame
.text$mn:000046BC
.text$mn:000046BC ; public: __thiscall std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<class ScintillaEditView *>>>::~_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<class ScintillaEditView *>>>(void)
.text$mn:000046BC                 public ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@XZ
.text$mn:000046BC ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@XZ proc near
.text$mn:000046BC                                         ; CODE XREF: __unwindfunclet$?destroyScintilla@ScintillaCtrls@@QAE_NPAUHWND__@@@Z$2+3j
.text$mn:000046BC                                         ; __unwindfunclet$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@ABV01@@Z$0+3j ...
.text$mn:000046BC
.text$mn:000046BC var_10          = dword ptr -10h
.text$mn:000046BC var_C           = dword ptr -0Ch
.text$mn:000046BC var_4           = dword ptr -4
.text$mn:000046BC
.text$mn:000046BC                 push    ebp
.text$mn:000046BD                 mov     ebp, esp
.text$mn:000046BF                 push    0FFFFFFFFh
.text$mn:000046C1                 push    offset __ehhandler$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@XZ
.text$mn:000046C6                 mov     eax, large fs:0
.text$mn:000046CC                 push    eax
.text$mn:000046CD                 push    ecx
.text$mn:000046CE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000046D3                 xor     eax, ebp
.text$mn:000046D5                 push    eax
.text$mn:000046D6                 lea     eax, [ebp+var_C]
.text$mn:000046D9                 mov     large fs:0, eax
.text$mn:000046DF                 mov     [ebp+var_10], ecx
.text$mn:000046E2                 mov     [ebp+var_4], 0
.text$mn:000046E9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000046F0                 mov     ecx, [ebp+var_10]
.text$mn:000046F3                 call    ??1?$_Iterator012@Urandom_access_iterator_tag@std@@PAVScintillaEditView@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,ScintillaEditView *,int,ScintillaEditView * const *,ScintillaEditView * const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,ScintillaEditView *,int,ScintillaEditView * const *,ScintillaEditView * const &,std::_Iterator_base12>(void)
.text$mn:000046F8                 mov     ecx, [ebp+var_C]
.text$mn:000046FB                 mov     large fs:0, ecx
.text$mn:00004702                 pop     ecx
.text$mn:00004703                 mov     esp, ebp
.text$mn:00004705                 pop     ebp
.text$mn:00004706                 retn
.text$mn:00004706 ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@XZ endp
.text$mn:00004706
.text$mn:00004706 ; ---------------------------------------------------------------------------
.text$mn:00004707                 align 4
.text$mn:00004707 _text$mn        ends
.text$mn:00004707
.text$x:00004708 ; ===========================================================================
.text$x:00004708
.text$x:00004708 ; Segment type: Pure code
.text$x:00004708 ; Segment permissions: Read/Execute
.text$x:00004708 _text$x         segment para public 'CODE' use32
.text$x:00004708                 assume cs:_text$x
.text$x:00004708                 ;org 4708h
.text$x:00004708 ; COMDAT (pick associative to section at 46BC)
.text$x:00004708                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00004708
.text$x:00004708 ; =============== S U B R O U T I N E =======================================
.text$x:00004708
.text$x:00004708
.text$x:00004708 __unwindfunclet$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00004708                                         ; DATA XREF: .xdata$x:0000A9A0o
.text$x:00004708                 mov     ecx, [ebp-10h]
.text$x:0000470B                 jmp     ??1?$_Iterator012@Urandom_access_iterator_tag@std@@PAVScintillaEditView@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,ScintillaEditView *,int,ScintillaEditView * const *,ScintillaEditView * const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,ScintillaEditView *,int,ScintillaEditView * const *,ScintillaEditView * const &,std::_Iterator_base12>(void)
.text$x:0000470B __unwindfunclet$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:0000470B
.text$x:00004710
.text$x:00004710 ; =============== S U B R O U T I N E =======================================
.text$x:00004710
.text$x:00004710
.text$x:00004710 __ehhandler$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@XZ proc near
.text$x:00004710                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>(void)+5o
.text$x:00004710
.text$x:00004710 arg_4           = dword ptr  8
.text$x:00004710
.text$x:00004710                 mov     edx, [esp+arg_4]
.text$x:00004714                 lea     eax, [edx+0Ch]
.text$x:00004717                 mov     ecx, [edx-8]
.text$x:0000471A                 xor     ecx, eax
.text$x:0000471C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004721                 mov     eax, offset __ehfuncinfo$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@XZ
.text$x:00004726                 jmp     ___CxxFrameHandler3
.text$x:00004726 __ehhandler$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@XZ endp
.text$x:00004726
.text$x:00004726 ; ---------------------------------------------------------------------------
.text$x:0000472B                 align 4
.text$x:0000472B _text$x         ends
.text$x:0000472B
.text$mn:0000472C ; ===========================================================================
.text$mn:0000472C
.text$mn:0000472C ; Segment type: Pure code
.text$mn:0000472C ; Segment permissions: Read/Execute
.text$mn:0000472C _text$mn        segment para public 'CODE' use32
.text$mn:0000472C                 assume cs:_text$mn
.text$mn:0000472C                 ;org 472Ch
.text$mn:0000472C ; COMDAT (pick any)
.text$mn:0000472C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000472C
.text$mn:0000472C ; =============== S U B R O U T I N E =======================================
.text$mn:0000472C
.text$mn:0000472C ; Attributes: bp-based frame
.text$mn:0000472C
.text$mn:0000472C ; public: __thiscall std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>>>>::~_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>>>>(void)
.text$mn:0000472C                 public ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ
.text$mn:0000472C ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ proc near
.text$mn:0000472C                                         ; CODE XREF: __unwindfunclet$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@ABV01@@Z$0+3j
.text$mn:0000472C                                         ; __unwindfunclet$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@PBU_Container_base12@1@@Z$0+3j ...
.text$mn:0000472C
.text$mn:0000472C var_10          = dword ptr -10h
.text$mn:0000472C var_C           = dword ptr -0Ch
.text$mn:0000472C var_4           = dword ptr -4
.text$mn:0000472C
.text$mn:0000472C                 push    ebp
.text$mn:0000472D                 mov     ebp, esp
.text$mn:0000472F                 push    0FFFFFFFFh
.text$mn:00004731                 push    offset __ehhandler$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ
.text$mn:00004736                 mov     eax, large fs:0
.text$mn:0000473C                 push    eax
.text$mn:0000473D                 push    ecx
.text$mn:0000473E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004743                 xor     eax, ebp
.text$mn:00004745                 push    eax
.text$mn:00004746                 lea     eax, [ebp+var_C]
.text$mn:00004749                 mov     large fs:0, eax
.text$mn:0000474F                 mov     [ebp+var_10], ecx
.text$mn:00004752                 mov     [ebp+var_4], 0
.text$mn:00004759                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004760                 mov     ecx, [ebp+var_10]
.text$mn:00004763                 call    ??1?$_Iterator012@Urandom_access_iterator_tag@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@HPBV32@ABV32@U_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,int,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,int,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const &,std::_Iterator_base12>(void)
.text$mn:00004768                 mov     ecx, [ebp+var_C]
.text$mn:0000476B                 mov     large fs:0, ecx
.text$mn:00004772                 pop     ecx
.text$mn:00004773                 mov     esp, ebp
.text$mn:00004775                 pop     ebp
.text$mn:00004776                 retn
.text$mn:00004776 ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ endp
.text$mn:00004776
.text$mn:00004776 ; ---------------------------------------------------------------------------
.text$mn:00004777                 align 4
.text$mn:00004777 _text$mn        ends
.text$mn:00004777
.text$x:00004778 ; ===========================================================================
.text$x:00004778
.text$x:00004778 ; Segment type: Pure code
.text$x:00004778 ; Segment permissions: Read/Execute
.text$x:00004778 _text$x         segment para public 'CODE' use32
.text$x:00004778                 assume cs:_text$x
.text$x:00004778                 ;org 4778h
.text$x:00004778 ; COMDAT (pick associative to section at 472C)
.text$x:00004778                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00004778
.text$x:00004778 ; =============== S U B R O U T I N E =======================================
.text$x:00004778
.text$x:00004778
.text$x:00004778 __unwindfunclet$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00004778                                         ; DATA XREF: .xdata$x:0000AB8Co
.text$x:00004778                 mov     ecx, [ebp-10h]
.text$x:0000477B                 jmp     ??1?$_Iterator012@Urandom_access_iterator_tag@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@HPBV32@ABV32@U_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,int,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,int,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const &,std::_Iterator_base12>(void)
.text$x:0000477B __unwindfunclet$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:0000477B
.text$x:00004780
.text$x:00004780 ; =============== S U B R O U T I N E =======================================
.text$x:00004780
.text$x:00004780
.text$x:00004780 __ehhandler$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ proc near
.text$x:00004780                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>(void)+5o
.text$x:00004780
.text$x:00004780 arg_4           = dword ptr  8
.text$x:00004780
.text$x:00004780                 mov     edx, [esp+arg_4]
.text$x:00004784                 lea     eax, [edx+0Ch]
.text$x:00004787                 mov     ecx, [edx-8]
.text$x:0000478A                 xor     ecx, eax
.text$x:0000478C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004791                 mov     eax, offset __ehfuncinfo$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ
.text$x:00004796                 jmp     ___CxxFrameHandler3
.text$x:00004796 __ehhandler$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ endp
.text$x:00004796
.text$x:00004796 ; ---------------------------------------------------------------------------
.text$x:0000479B                 align 4
.text$x:0000479B _text$x         ends
.text$x:0000479B
.text$mn:0000479C ; ===========================================================================
.text$mn:0000479C
.text$mn:0000479C ; Segment type: Pure code
.text$mn:0000479C ; Segment permissions: Read/Execute
.text$mn:0000479C _text$mn        segment para public 'CODE' use32
.text$mn:0000479C                 assume cs:_text$mn
.text$mn:0000479C                 ;org 479Ch
.text$mn:0000479C ; COMDAT (pick any)
.text$mn:0000479C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000479C
.text$mn:0000479C ; =============== S U B R O U T I N E =======================================
.text$mn:0000479C
.text$mn:0000479C ; Attributes: bp-based frame
.text$mn:0000479C
.text$mn:0000479C ; public: __thiscall std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<class ScintillaEditView *>>>::~_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<class ScintillaEditView *>>>(void)
.text$mn:0000479C                 public ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@XZ
.text$mn:0000479C ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@XZ proc near
.text$mn:0000479C                                         ; CODE XREF: ScintillaCtrls::destroyScintilla(HWND__ *)+CCp
.text$mn:0000479C                                         ; ScintillaCtrls::destroyScintilla(HWND__ *)+105p ...
.text$mn:0000479C
.text$mn:0000479C var_10          = dword ptr -10h
.text$mn:0000479C var_C           = dword ptr -0Ch
.text$mn:0000479C var_4           = dword ptr -4
.text$mn:0000479C
.text$mn:0000479C                 push    ebp
.text$mn:0000479D                 mov     ebp, esp
.text$mn:0000479F                 push    0FFFFFFFFh
.text$mn:000047A1                 push    offset __ehhandler$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@XZ
.text$mn:000047A6                 mov     eax, large fs:0
.text$mn:000047AC                 push    eax
.text$mn:000047AD                 push    ecx
.text$mn:000047AE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000047B3                 xor     eax, ebp
.text$mn:000047B5                 push    eax
.text$mn:000047B6                 lea     eax, [ebp+var_C]
.text$mn:000047B9                 mov     large fs:0, eax
.text$mn:000047BF                 mov     [ebp+var_10], ecx
.text$mn:000047C2                 mov     [ebp+var_4], 0
.text$mn:000047C9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000047D0                 mov     ecx, [ebp+var_10]
.text$mn:000047D3                 call    ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>(void)
.text$mn:000047D8                 mov     ecx, [ebp+var_C]
.text$mn:000047DB                 mov     large fs:0, ecx
.text$mn:000047E2                 pop     ecx
.text$mn:000047E3                 mov     esp, ebp
.text$mn:000047E5                 pop     ebp
.text$mn:000047E6                 retn
.text$mn:000047E6 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@XZ endp
.text$mn:000047E6
.text$mn:000047E6 ; ---------------------------------------------------------------------------
.text$mn:000047E7                 align 4
.text$mn:000047E7 _text$mn        ends
.text$mn:000047E7
.text$x:000047E8 ; ===========================================================================
.text$x:000047E8
.text$x:000047E8 ; Segment type: Pure code
.text$x:000047E8 ; Segment permissions: Read/Execute
.text$x:000047E8 _text$x         segment para public 'CODE' use32
.text$x:000047E8                 assume cs:_text$x
.text$x:000047E8                 ;org 47E8h
.text$x:000047E8 ; COMDAT (pick associative to section at 479C)
.text$x:000047E8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000047E8
.text$x:000047E8 ; =============== S U B R O U T I N E =======================================
.text$x:000047E8
.text$x:000047E8
.text$x:000047E8 __unwindfunclet$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:000047E8                                         ; DATA XREF: .xdata$x:0000AA58o
.text$x:000047E8                 mov     ecx, [ebp-10h]
.text$x:000047EB                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>(void)
.text$x:000047EB __unwindfunclet$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:000047EB
.text$x:000047F0
.text$x:000047F0 ; =============== S U B R O U T I N E =======================================
.text$x:000047F0
.text$x:000047F0
.text$x:000047F0 __ehhandler$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@XZ proc near
.text$x:000047F0                                         ; DATA XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>(void)+5o
.text$x:000047F0
.text$x:000047F0 arg_4           = dword ptr  8
.text$x:000047F0
.text$x:000047F0                 mov     edx, [esp+arg_4]
.text$x:000047F4                 lea     eax, [edx+0Ch]
.text$x:000047F7                 mov     ecx, [edx-8]
.text$x:000047FA                 xor     ecx, eax
.text$x:000047FC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004801                 mov     eax, offset __ehfuncinfo$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@XZ
.text$x:00004806                 jmp     ___CxxFrameHandler3
.text$x:00004806 __ehhandler$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@XZ endp
.text$x:00004806
.text$x:00004806 ; ---------------------------------------------------------------------------
.text$x:0000480B                 align 4
.text$x:0000480B _text$x         ends
.text$x:0000480B
.text$mn:0000480C ; ===========================================================================
.text$mn:0000480C
.text$mn:0000480C ; Segment type: Pure code
.text$mn:0000480C ; Segment permissions: Read/Execute
.text$mn:0000480C _text$mn        segment para public 'CODE' use32
.text$mn:0000480C                 assume cs:_text$mn
.text$mn:0000480C                 ;org 480Ch
.text$mn:0000480C ; COMDAT (pick any)
.text$mn:0000480C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000480C
.text$mn:0000480C ; =============== S U B R O U T I N E =======================================
.text$mn:0000480C
.text$mn:0000480C ; Attributes: bp-based frame
.text$mn:0000480C
.text$mn:0000480C ; public: __thiscall std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>>>>::~_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>>>>(void)
.text$mn:0000480C                 public ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ
.text$mn:0000480C ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ proc near
.text$mn:0000480C                                         ; CODE XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::operator+(int)+67p
.text$mn:0000480C                                         ; __unwindfunclet$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QBE?AV01@H@Z$0+3j ...
.text$mn:0000480C
.text$mn:0000480C var_10          = dword ptr -10h
.text$mn:0000480C var_C           = dword ptr -0Ch
.text$mn:0000480C var_4           = dword ptr -4
.text$mn:0000480C
.text$mn:0000480C                 push    ebp
.text$mn:0000480D                 mov     ebp, esp
.text$mn:0000480F                 push    0FFFFFFFFh
.text$mn:00004811                 push    offset __ehhandler$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ
.text$mn:00004816                 mov     eax, large fs:0
.text$mn:0000481C                 push    eax
.text$mn:0000481D                 push    ecx
.text$mn:0000481E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004823                 xor     eax, ebp
.text$mn:00004825                 push    eax
.text$mn:00004826                 lea     eax, [ebp+var_C]
.text$mn:00004829                 mov     large fs:0, eax
.text$mn:0000482F                 mov     [ebp+var_10], ecx
.text$mn:00004832                 mov     [ebp+var_4], 0
.text$mn:00004839                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004840                 mov     ecx, [ebp+var_10]
.text$mn:00004843                 call    ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>(void)
.text$mn:00004848                 mov     ecx, [ebp+var_C]
.text$mn:0000484B                 mov     large fs:0, ecx
.text$mn:00004852                 pop     ecx
.text$mn:00004853                 mov     esp, ebp
.text$mn:00004855                 pop     ebp
.text$mn:00004856                 retn
.text$mn:00004856 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ endp
.text$mn:00004856
.text$mn:00004856 ; ---------------------------------------------------------------------------
.text$mn:00004857                 align 4
.text$mn:00004857 _text$mn        ends
.text$mn:00004857
.text$x:00004858 ; ===========================================================================
.text$x:00004858
.text$x:00004858 ; Segment type: Pure code
.text$x:00004858 ; Segment permissions: Read/Execute
.text$x:00004858 _text$x         segment para public 'CODE' use32
.text$x:00004858                 assume cs:_text$x
.text$x:00004858                 ;org 4858h
.text$x:00004858 ; COMDAT (pick associative to section at 480C)
.text$x:00004858                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00004858
.text$x:00004858 ; =============== S U B R O U T I N E =======================================
.text$x:00004858
.text$x:00004858
.text$x:00004858 __unwindfunclet$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00004858                                         ; DATA XREF: .xdata$x:0000AC44o
.text$x:00004858                 mov     ecx, [ebp-10h]
.text$x:0000485B                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>(void)
.text$x:0000485B __unwindfunclet$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:0000485B
.text$x:00004860
.text$x:00004860 ; =============== S U B R O U T I N E =======================================
.text$x:00004860
.text$x:00004860
.text$x:00004860 __ehhandler$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ proc near
.text$x:00004860                                         ; DATA XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>(void)+5o
.text$x:00004860
.text$x:00004860 arg_4           = dword ptr  8
.text$x:00004860
.text$x:00004860                 mov     edx, [esp+arg_4]
.text$x:00004864                 lea     eax, [edx+0Ch]
.text$x:00004867                 mov     ecx, [edx-8]
.text$x:0000486A                 xor     ecx, eax
.text$x:0000486C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004871                 mov     eax, offset __ehfuncinfo$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ
.text$x:00004876                 jmp     ___CxxFrameHandler3
.text$x:00004876 __ehhandler$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ endp
.text$x:00004876
.text$x:00004876 ; ---------------------------------------------------------------------------
.text$x:0000487B                 align 4
.text$x:0000487B _text$x         ends
.text$x:0000487B
.text$mn:0000487C ; ===========================================================================
.text$mn:0000487C
.text$mn:0000487C ; Segment type: Pure code
.text$mn:0000487C ; Segment permissions: Read/Execute
.text$mn:0000487C _text$mn        segment para public 'CODE' use32
.text$mn:0000487C                 assume cs:_text$mn
.text$mn:0000487C                 ;org 487Ch
.text$mn:0000487C ; COMDAT (pick any)
.text$mn:0000487C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000487C
.text$mn:0000487C ; =============== S U B R O U T I N E =======================================
.text$mn:0000487C
.text$mn:0000487C ; Attributes: bp-based frame
.text$mn:0000487C
.text$mn:0000487C ; public: __thiscall std::_Vector_val<struct std::_Simple_types<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<int const, struct Style>>>>>>::~_Vector_val<struct std::_Simple_types<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<int const, struct Style>>>>>>(void)
.text$mn:0000487C                 public ??1?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ
.text$mn:0000487C ??1?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ proc near
.text$mn:0000487C                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>>>>>::~_Vector_alloc<0,std::_Vec_base_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>>>>>(void)+3Fp
.text$mn:0000487C                                         ; __unwindfunclet$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QAE@XZ$0+3j
.text$mn:0000487C
.text$mn:0000487C var_10          = dword ptr -10h
.text$mn:0000487C var_C           = dword ptr -0Ch
.text$mn:0000487C var_4           = dword ptr -4
.text$mn:0000487C
.text$mn:0000487C                 push    ebp
.text$mn:0000487D                 mov     ebp, esp
.text$mn:0000487F                 push    0FFFFFFFFh
.text$mn:00004881                 push    offset __ehhandler$??1?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ
.text$mn:00004886                 mov     eax, large fs:0
.text$mn:0000488C                 push    eax
.text$mn:0000488D                 push    ecx
.text$mn:0000488E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004893                 xor     eax, ebp
.text$mn:00004895                 push    eax
.text$mn:00004896                 lea     eax, [ebp+var_C]
.text$mn:00004899                 mov     large fs:0, eax
.text$mn:0000489F                 mov     [ebp+var_10], ecx
.text$mn:000048A2                 mov     [ebp+var_4], 0
.text$mn:000048A9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000048B0                 mov     ecx, [ebp+var_10] ; this
.text$mn:000048B3                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:000048B8                 mov     ecx, [ebp+var_C]
.text$mn:000048BB                 mov     large fs:0, ecx
.text$mn:000048C2                 pop     ecx
.text$mn:000048C3                 mov     esp, ebp
.text$mn:000048C5                 pop     ebp
.text$mn:000048C6                 retn
.text$mn:000048C6 ??1?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ endp
.text$mn:000048C6
.text$mn:000048C6 ; ---------------------------------------------------------------------------
.text$mn:000048C7                 align 4
.text$mn:000048C7 _text$mn        ends
.text$mn:000048C7
.text$x:000048C8 ; ===========================================================================
.text$x:000048C8
.text$x:000048C8 ; Segment type: Pure code
.text$x:000048C8 ; Segment permissions: Read/Execute
.text$x:000048C8 _text$x         segment para public 'CODE' use32
.text$x:000048C8                 assume cs:_text$x
.text$x:000048C8                 ;org 48C8h
.text$x:000048C8 ; COMDAT (pick associative to section at 487C)
.text$x:000048C8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000048C8
.text$x:000048C8 ; =============== S U B R O U T I N E =======================================
.text$x:000048C8
.text$x:000048C8
.text$x:000048C8 __unwindfunclet$??1?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:000048C8                                         ; DATA XREF: .xdata$x:0000A6B4o
.text$x:000048C8                 mov     ecx, [ebp-10h]  ; this
.text$x:000048CB                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:000048CB __unwindfunclet$??1?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:000048CB
.text$x:000048D0
.text$x:000048D0 ; =============== S U B R O U T I N E =======================================
.text$x:000048D0
.text$x:000048D0
.text$x:000048D0 __ehhandler$??1?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ proc near
.text$x:000048D0                                         ; DATA XREF: std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>>>::~_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>>>(void)+5o
.text$x:000048D0
.text$x:000048D0 arg_4           = dword ptr  8
.text$x:000048D0
.text$x:000048D0                 mov     edx, [esp+arg_4]
.text$x:000048D4                 lea     eax, [edx+0Ch]
.text$x:000048D7                 mov     ecx, [edx-8]
.text$x:000048DA                 xor     ecx, eax
.text$x:000048DC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000048E1                 mov     eax, offset __ehfuncinfo$??1?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ
.text$x:000048E6                 jmp     ___CxxFrameHandler3
.text$x:000048E6 __ehhandler$??1?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ endp
.text$x:000048E6
.text$x:000048E6 ; ---------------------------------------------------------------------------
.text$x:000048EB                 align 4
.text$x:000048EB _text$x         ends
.text$x:000048EB
.text$mn:000048EC ; ===========================================================================
.text$mn:000048EC
.text$mn:000048EC ; Segment type: Pure code
.text$mn:000048EC ; Segment permissions: Read/Execute
.text$mn:000048EC _text$mn        segment para public 'CODE' use32
.text$mn:000048EC                 assume cs:_text$mn
.text$mn:000048EC                 ;org 48ECh
.text$mn:000048EC ; COMDAT (pick any)
.text$mn:000048EC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000048EC
.text$mn:000048EC ; =============== S U B R O U T I N E =======================================
.text$mn:000048EC
.text$mn:000048EC ; Attributes: bp-based frame
.text$mn:000048EC
.text$mn:000048EC ; public: __thiscall std::_Vector_val<struct std::_Simple_types<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>>>::~_Vector_val<struct std::_Simple_types<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>>>(void)
.text$mn:000048EC                 public ??1?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ
.text$mn:000048EC ??1?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ proc near
.text$mn:000048EC                                         ; CODE XREF: __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QAE@ABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@1@@Z$0+3j
.text$mn:000048EC                                         ; std::_Vector_alloc<0,std::_Vec_base_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>>::~_Vector_alloc<0,std::_Vec_base_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>>(void)+3Fp ...
.text$mn:000048EC
.text$mn:000048EC var_10          = dword ptr -10h
.text$mn:000048EC var_C           = dword ptr -0Ch
.text$mn:000048EC var_4           = dword ptr -4
.text$mn:000048EC
.text$mn:000048EC                 push    ebp
.text$mn:000048ED                 mov     ebp, esp
.text$mn:000048EF                 push    0FFFFFFFFh
.text$mn:000048F1                 push    offset __ehhandler$??1?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ
.text$mn:000048F6                 mov     eax, large fs:0
.text$mn:000048FC                 push    eax
.text$mn:000048FD                 push    ecx
.text$mn:000048FE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004903                 xor     eax, ebp
.text$mn:00004905                 push    eax
.text$mn:00004906                 lea     eax, [ebp+var_C]
.text$mn:00004909                 mov     large fs:0, eax
.text$mn:0000490F                 mov     [ebp+var_10], ecx
.text$mn:00004912                 mov     [ebp+var_4], 0
.text$mn:00004919                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004920                 mov     ecx, [ebp+var_10] ; this
.text$mn:00004923                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:00004928                 mov     ecx, [ebp+var_C]
.text$mn:0000492B                 mov     large fs:0, ecx
.text$mn:00004932                 pop     ecx
.text$mn:00004933                 mov     esp, ebp
.text$mn:00004935                 pop     ebp
.text$mn:00004936                 retn
.text$mn:00004936 ??1?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ endp
.text$mn:00004936
.text$mn:00004936 ; ---------------------------------------------------------------------------
.text$mn:00004937                 align 4
.text$mn:00004937 _text$mn        ends
.text$mn:00004937
.text$x:00004938 ; ===========================================================================
.text$x:00004938
.text$x:00004938 ; Segment type: Pure code
.text$x:00004938 ; Segment permissions: Read/Execute
.text$x:00004938 _text$x         segment para public 'CODE' use32
.text$x:00004938                 assume cs:_text$x
.text$x:00004938                 ;org 4938h
.text$x:00004938 ; COMDAT (pick associative to section at 48EC)
.text$x:00004938                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00004938
.text$x:00004938 ; =============== S U B R O U T I N E =======================================
.text$x:00004938
.text$x:00004938
.text$x:00004938 __unwindfunclet$??1?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00004938                                         ; DATA XREF: .xdata$x:0000A0F4o
.text$x:00004938                 mov     ecx, [ebp-10h]  ; this
.text$x:0000493B                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:0000493B __unwindfunclet$??1?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:0000493B
.text$x:00004940
.text$x:00004940 ; =============== S U B R O U T I N E =======================================
.text$x:00004940
.text$x:00004940
.text$x:00004940 __ehhandler$??1?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ proc near
.text$x:00004940                                         ; DATA XREF: std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>::~_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>(void)+5o
.text$x:00004940
.text$x:00004940 arg_4           = dword ptr  8
.text$x:00004940
.text$x:00004940                 mov     edx, [esp+arg_4]
.text$x:00004944                 lea     eax, [edx+0Ch]
.text$x:00004947                 mov     ecx, [edx-8]
.text$x:0000494A                 xor     ecx, eax
.text$x:0000494C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004951                 mov     eax, offset __ehfuncinfo$??1?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ
.text$x:00004956                 jmp     ___CxxFrameHandler3
.text$x:00004956 __ehhandler$??1?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ endp
.text$x:00004956
.text$x:00004956 ; ---------------------------------------------------------------------------
.text$x:0000495B                 align 4
.text$x:0000495B _text$x         ends
.text$x:0000495B
.text$mn:0000495C ; ===========================================================================
.text$mn:0000495C
.text$mn:0000495C ; Segment type: Pure code
.text$mn:0000495C ; Segment permissions: Read/Execute
.text$mn:0000495C _text$mn        segment para public 'CODE' use32
.text$mn:0000495C                 assume cs:_text$mn
.text$mn:0000495C                 ;org 495Ch
.text$mn:0000495C ; COMDAT (pick any)
.text$mn:0000495C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000495C
.text$mn:0000495C ; =============== S U B R O U T I N E =======================================
.text$mn:0000495C
.text$mn:0000495C ; Attributes: bp-based frame
.text$mn:0000495C
.text$mn:0000495C ; public: __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::~basic_string<char, struct std::char_traits<char>, class std::allocator<char>>(void)
.text$mn:0000495C                 public ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:0000495C ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$mn:0000495C                                         ; CODE XREF: __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+13j
.text$mn:0000495C                                         ; __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+13j ...
.text$mn:0000495C
.text$mn:0000495C var_10          = dword ptr -10h
.text$mn:0000495C var_C           = dword ptr -0Ch
.text$mn:0000495C var_4           = dword ptr -4
.text$mn:0000495C
.text$mn:0000495C                 push    ebp
.text$mn:0000495D                 mov     ebp, esp
.text$mn:0000495F                 push    0FFFFFFFFh
.text$mn:00004961                 push    offset __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:00004966                 mov     eax, large fs:0
.text$mn:0000496C                 push    eax
.text$mn:0000496D                 push    ecx
.text$mn:0000496E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004973                 xor     eax, ebp
.text$mn:00004975                 push    eax
.text$mn:00004976                 lea     eax, [ebp+var_C]
.text$mn:00004979                 mov     large fs:0, eax
.text$mn:0000497F                 mov     [ebp+var_10], ecx
.text$mn:00004982                 mov     [ebp+var_4], 0
.text$mn:00004989                 push    0               ; Size
.text$mn:0000498B                 push    1               ; char
.text$mn:0000498D                 mov     ecx, [ebp+var_10]
.text$mn:00004990                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00004995                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000499C                 mov     ecx, [ebp+var_10]
.text$mn:0000499F                 call    ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$mn:000049A4                 mov     ecx, [ebp+var_C]
.text$mn:000049A7                 mov     large fs:0, ecx
.text$mn:000049AE                 pop     ecx
.text$mn:000049AF                 mov     esp, ebp
.text$mn:000049B1                 pop     ebp
.text$mn:000049B2                 retn
.text$mn:000049B2 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$mn:000049B2
.text$mn:000049B2 ; ---------------------------------------------------------------------------
.text$mn:000049B3                 align 4
.text$mn:000049B3 _text$mn        ends
.text$mn:000049B3
.text$x:000049B4 ; ===========================================================================
.text$x:000049B4
.text$x:000049B4 ; Segment type: Pure code
.text$x:000049B4 ; Segment permissions: Read/Execute
.text$x:000049B4 _text$x         segment para public 'CODE' use32
.text$x:000049B4                 assume cs:_text$x
.text$x:000049B4                 ;org 49B4h
.text$x:000049B4 ; COMDAT (pick associative to section at 495C)
.text$x:000049B4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000049B4
.text$x:000049B4 ; =============== S U B R O U T I N E =======================================
.text$x:000049B4
.text$x:000049B4
.text$x:000049B4 __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 proc near
.text$x:000049B4                                         ; DATA XREF: .xdata$x:000098B8o
.text$x:000049B4                 mov     ecx, [ebp-10h]
.text$x:000049B7                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:000049B7 __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 endp
.text$x:000049B7
.text$x:000049BC
.text$x:000049BC ; =============== S U B R O U T I N E =======================================
.text$x:000049BC
.text$x:000049BC
.text$x:000049BC __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$x:000049BC                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+5o
.text$x:000049BC
.text$x:000049BC arg_4           = dword ptr  8
.text$x:000049BC
.text$x:000049BC                 mov     edx, [esp+arg_4]
.text$x:000049C0                 lea     eax, [edx+0Ch]
.text$x:000049C3                 mov     ecx, [edx-8]
.text$x:000049C6                 xor     ecx, eax
.text$x:000049C8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000049CD                 mov     eax, offset __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$x:000049D2                 jmp     ___CxxFrameHandler3
.text$x:000049D2 __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$x:000049D2
.text$x:000049D2 ; ---------------------------------------------------------------------------
.text$x:000049D7                 align 4
.text$x:000049D7 _text$x         ends
.text$x:000049D7
.text$mn:000049D8 ; ===========================================================================
.text$mn:000049D8
.text$mn:000049D8 ; Segment type: Pure code
.text$mn:000049D8 ; Segment permissions: Read/Execute
.text$mn:000049D8 _text$mn        segment para public 'CODE' use32
.text$mn:000049D8                 assume cs:_text$mn
.text$mn:000049D8                 ;org 49D8h
.text$mn:000049D8 ; COMDAT (pick any)
.text$mn:000049D8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000049D8
.text$mn:000049D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000049D8
.text$mn:000049D8 ; Attributes: bp-based frame
.text$mn:000049D8
.text$mn:000049D8 ; public: __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::~basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>(void)
.text$mn:000049D8                 public ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.text$mn:000049D8 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ proc near
.text$mn:000049D8                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::`scalar deleting destructor'(uint)+Ap
.text$mn:000049D8
.text$mn:000049D8 var_10          = dword ptr -10h
.text$mn:000049D8 var_C           = dword ptr -0Ch
.text$mn:000049D8 var_4           = dword ptr -4
.text$mn:000049D8
.text$mn:000049D8                 push    ebp
.text$mn:000049D9                 mov     ebp, esp
.text$mn:000049DB                 push    0FFFFFFFFh
.text$mn:000049DD                 push    offset __ehhandler$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.text$mn:000049E2                 mov     eax, large fs:0
.text$mn:000049E8                 push    eax
.text$mn:000049E9                 push    ecx
.text$mn:000049EA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000049EF                 xor     eax, ebp
.text$mn:000049F1                 push    eax
.text$mn:000049F2                 lea     eax, [ebp+var_C]
.text$mn:000049F5                 mov     large fs:0, eax
.text$mn:000049FB                 mov     [ebp+var_10], ecx
.text$mn:000049FE                 mov     [ebp+var_4], 0
.text$mn:00004A05                 push    0
.text$mn:00004A07                 push    1
.text$mn:00004A09                 mov     ecx, [ebp+var_10]
.text$mn:00004A0C                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:00004A11                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004A18                 mov     ecx, [ebp+var_10]
.text$mn:00004A1B                 call    ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)
.text$mn:00004A20                 mov     ecx, [ebp+var_C]
.text$mn:00004A23                 mov     large fs:0, ecx
.text$mn:00004A2A                 pop     ecx
.text$mn:00004A2B                 mov     esp, ebp
.text$mn:00004A2D                 pop     ebp
.text$mn:00004A2E                 retn
.text$mn:00004A2E ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ endp
.text$mn:00004A2E
.text$mn:00004A2E ; ---------------------------------------------------------------------------
.text$mn:00004A2F                 align 10h
.text$mn:00004A2F _text$mn        ends
.text$mn:00004A2F
.text$x:00004A30 ; ===========================================================================
.text$x:00004A30
.text$x:00004A30 ; Segment type: Pure code
.text$x:00004A30 ; Segment permissions: Read/Execute
.text$x:00004A30 _text$x         segment para public 'CODE' use32
.text$x:00004A30                 assume cs:_text$x
.text$x:00004A30                 ;org 4A30h
.text$x:00004A30 ; COMDAT (pick associative to section at 49D8)
.text$x:00004A30                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00004A30
.text$x:00004A30 ; =============== S U B R O U T I N E =======================================
.text$x:00004A30
.text$x:00004A30
.text$x:00004A30 __unwindfunclet$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ$0 proc near
.text$x:00004A30                                         ; DATA XREF: .xdata$x:00009CE4o
.text$x:00004A30                 mov     ecx, [ebp-10h]
.text$x:00004A33                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)
.text$x:00004A33 __unwindfunclet$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ$0 endp
.text$x:00004A33
.text$x:00004A38
.text$x:00004A38 ; =============== S U B R O U T I N E =======================================
.text$x:00004A38
.text$x:00004A38
.text$x:00004A38 __ehhandler$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ proc near
.text$x:00004A38                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)+5o
.text$x:00004A38
.text$x:00004A38 arg_4           = dword ptr  8
.text$x:00004A38
.text$x:00004A38                 mov     edx, [esp+arg_4]
.text$x:00004A3C                 lea     eax, [edx+0Ch]
.text$x:00004A3F                 mov     ecx, [edx-8]
.text$x:00004A42                 xor     ecx, eax
.text$x:00004A44                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004A49                 mov     eax, offset __ehfuncinfo$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.text$x:00004A4E                 jmp     ___CxxFrameHandler3
.text$x:00004A4E __ehhandler$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ endp
.text$x:00004A4E
.text$x:00004A4E ; ---------------------------------------------------------------------------
.text$x:00004A53                 align 4
.text$x:00004A53 _text$x         ends
.text$x:00004A53
.text$mn:00004A54 ; ===========================================================================
.text$mn:00004A54
.text$mn:00004A54 ; Segment type: Pure code
.text$mn:00004A54 ; Segment permissions: Read/Execute
.text$mn:00004A54 _text$mn        segment para public 'CODE' use32
.text$mn:00004A54                 assume cs:_text$mn
.text$mn:00004A54                 ;org 4A54h
.text$mn:00004A54 ; COMDAT (pick any)
.text$mn:00004A54                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004A54
.text$mn:00004A54 ; =============== S U B R O U T I N E =======================================
.text$mn:00004A54
.text$mn:00004A54 ; Attributes: bp-based frame
.text$mn:00004A54
.text$mn:00004A54 ; public: __thiscall std::list<struct std::pair<int const, struct Style>, class std::allocator<struct std::pair<int const, struct Style>>>::~list<struct std::pair<int const, struct Style>, class std::allocator<struct std::pair<int const, struct Style>>>(void)
.text$mn:00004A54                 public ??1?$list@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@QAE@XZ
.text$mn:00004A54 ??1?$list@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@QAE@XZ proc near
.text$mn:00004A54                                         ; CODE XREF: std::_Hash<std::_Umap_traits<int,Style,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int>>,std::allocator<std::pair<int const,Style>>,0>>::~_Hash<std::_Umap_traits<int,Style,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int>>,std::allocator<std::pair<int const,Style>>,0>>(void)+46p
.text$mn:00004A54                                         ; __unwindfunclet$??1?$_Hash@V?$_Umap_traits@HUStyle@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@$0A@@std@@@std@@QAE@XZ$0+3j
.text$mn:00004A54
.text$mn:00004A54 var_10          = dword ptr -10h
.text$mn:00004A54 var_C           = dword ptr -0Ch
.text$mn:00004A54 var_4           = dword ptr -4
.text$mn:00004A54
.text$mn:00004A54                 push    ebp
.text$mn:00004A55                 mov     ebp, esp
.text$mn:00004A57                 push    0FFFFFFFFh
.text$mn:00004A59                 push    offset __ehhandler$??1?$list@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@QAE@XZ
.text$mn:00004A5E                 mov     eax, large fs:0
.text$mn:00004A64                 push    eax
.text$mn:00004A65                 push    ecx
.text$mn:00004A66                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004A6B                 xor     eax, ebp
.text$mn:00004A6D                 push    eax
.text$mn:00004A6E                 lea     eax, [ebp+var_C]
.text$mn:00004A71                 mov     large fs:0, eax
.text$mn:00004A77                 mov     [ebp+var_10], ecx
.text$mn:00004A7A                 mov     [ebp+var_4], 0
.text$mn:00004A81                 mov     ecx, [ebp+var_10]
.text$mn:00004A84                 call    ?_Tidy@?$list@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@QAEXXZ ; std::list<std::pair<int const,Style>,std::allocator<std::pair<int const,Style>>>::_Tidy(void)
.text$mn:00004A89                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004A90                 mov     ecx, [ebp+var_10]
.text$mn:00004A93                 call    ??1?$_List_buy@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@QAE@XZ ; std::_List_buy<std::pair<int const,Style>,std::allocator<std::pair<int const,Style>>>::~_List_buy<std::pair<int const,Style>,std::allocator<std::pair<int const,Style>>>(void)
.text$mn:00004A98                 mov     ecx, [ebp+var_C]
.text$mn:00004A9B                 mov     large fs:0, ecx
.text$mn:00004AA2                 pop     ecx
.text$mn:00004AA3                 mov     esp, ebp
.text$mn:00004AA5                 pop     ebp
.text$mn:00004AA6                 retn
.text$mn:00004AA6 ??1?$list@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@QAE@XZ endp
.text$mn:00004AA6
.text$mn:00004AA6 ; ---------------------------------------------------------------------------
.text$mn:00004AA7                 align 4
.text$mn:00004AA7 _text$mn        ends
.text$mn:00004AA7
.text$x:00004AA8 ; ===========================================================================
.text$x:00004AA8
.text$x:00004AA8 ; Segment type: Pure code
.text$x:00004AA8 ; Segment permissions: Read/Execute
.text$x:00004AA8 _text$x         segment para public 'CODE' use32
.text$x:00004AA8                 assume cs:_text$x
.text$x:00004AA8                 ;org 4AA8h
.text$x:00004AA8 ; COMDAT (pick associative to section at 4A54)
.text$x:00004AA8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00004AA8
.text$x:00004AA8 ; =============== S U B R O U T I N E =======================================
.text$x:00004AA8
.text$x:00004AA8
.text$x:00004AA8 __unwindfunclet$??1?$list@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@QAE@XZ$0 proc near
.text$x:00004AA8                                         ; DATA XREF: .xdata$x:0000A578o
.text$x:00004AA8                 mov     ecx, [ebp-10h]
.text$x:00004AAB                 jmp     ??1?$_List_buy@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@QAE@XZ ; std::_List_buy<std::pair<int const,Style>,std::allocator<std::pair<int const,Style>>>::~_List_buy<std::pair<int const,Style>,std::allocator<std::pair<int const,Style>>>(void)
.text$x:00004AAB __unwindfunclet$??1?$list@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@QAE@XZ$0 endp
.text$x:00004AAB
.text$x:00004AB0
.text$x:00004AB0 ; =============== S U B R O U T I N E =======================================
.text$x:00004AB0
.text$x:00004AB0
.text$x:00004AB0 __ehhandler$??1?$list@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@QAE@XZ proc near
.text$x:00004AB0                                         ; DATA XREF: std::list<std::pair<int const,Style>,std::allocator<std::pair<int const,Style>>>::~list<std::pair<int const,Style>,std::allocator<std::pair<int const,Style>>>(void)+5o
.text$x:00004AB0
.text$x:00004AB0 arg_4           = dword ptr  8
.text$x:00004AB0
.text$x:00004AB0                 mov     edx, [esp+arg_4]
.text$x:00004AB4                 lea     eax, [edx+0Ch]
.text$x:00004AB7                 mov     ecx, [edx-8]
.text$x:00004ABA                 xor     ecx, eax
.text$x:00004ABC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004AC1                 mov     eax, offset __ehfuncinfo$??1?$list@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@QAE@XZ
.text$x:00004AC6                 jmp     ___CxxFrameHandler3
.text$x:00004AC6 __ehhandler$??1?$list@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@QAE@XZ endp
.text$x:00004AC6
.text$x:00004AC6 ; ---------------------------------------------------------------------------
.text$x:00004ACB                 align 4
.text$x:00004ACB _text$x         ends
.text$x:00004ACB
.text$mn:00004ACC ; ===========================================================================
.text$mn:00004ACC
.text$mn:00004ACC ; Segment type: Pure code
.text$mn:00004ACC ; Segment permissions: Read/Execute
.text$mn:00004ACC _text$mn        segment para public 'CODE' use32
.text$mn:00004ACC                 assume cs:_text$mn
.text$mn:00004ACC                 ;org 4ACCh
.text$mn:00004ACC ; COMDAT (pick any)
.text$mn:00004ACC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004ACC
.text$mn:00004ACC ; =============== S U B R O U T I N E =======================================
.text$mn:00004ACC
.text$mn:00004ACC ; Attributes: bp-based frame
.text$mn:00004ACC
.text$mn:00004ACC ; public: __thiscall std::list<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>, class std::allocator<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>::~list<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>, class std::allocator<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>(void)
.text$mn:00004ACC                 public ??1?$list@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAE@XZ
.text$mn:00004ACC ??1?$list@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAE@XZ proc near
.text$mn:00004ACC                                         ; CODE XREF: __unwindfunclet$??0?$_Hash@V?$_Umap_traits@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@V?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@$0A@@std@@@std@@QAE@ABV?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@1@ABV?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@1@@Z$0+3j
.text$mn:00004ACC                                         ; std::_Hash<std::_Umap_traits<Buffer *,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *,std::_Uhash_compare<Buffer *,std::hash<Buffer *>,std::equal_to<Buffer *>>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>,0>>::~_Hash<std::_Umap_traits<Buffer *,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *,std::_Uhash_compare<Buffer *,std::hash<Buffer *>,std::equal_to<Buffer *>>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>,0>>(void)+46p ...
.text$mn:00004ACC
.text$mn:00004ACC var_10          = dword ptr -10h
.text$mn:00004ACC var_C           = dword ptr -0Ch
.text$mn:00004ACC var_4           = dword ptr -4
.text$mn:00004ACC
.text$mn:00004ACC                 push    ebp
.text$mn:00004ACD                 mov     ebp, esp
.text$mn:00004ACF                 push    0FFFFFFFFh
.text$mn:00004AD1                 push    offset __ehhandler$??1?$list@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAE@XZ
.text$mn:00004AD6                 mov     eax, large fs:0
.text$mn:00004ADC                 push    eax
.text$mn:00004ADD                 push    ecx
.text$mn:00004ADE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004AE3                 xor     eax, ebp
.text$mn:00004AE5                 push    eax
.text$mn:00004AE6                 lea     eax, [ebp+var_C]
.text$mn:00004AE9                 mov     large fs:0, eax
.text$mn:00004AEF                 mov     [ebp+var_10], ecx
.text$mn:00004AF2                 mov     [ebp+var_4], 0
.text$mn:00004AF9                 mov     ecx, [ebp+var_10]
.text$mn:00004AFC                 call    ?_Tidy@?$list@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAEXXZ ; std::list<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>::_Tidy(void)
.text$mn:00004B01                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004B08                 mov     ecx, [ebp+var_10]
.text$mn:00004B0B                 call    ??1?$_List_buy@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAE@XZ ; std::_List_buy<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>::~_List_buy<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>(void)
.text$mn:00004B10                 mov     ecx, [ebp+var_C]
.text$mn:00004B13                 mov     large fs:0, ecx
.text$mn:00004B1A                 pop     ecx
.text$mn:00004B1B                 mov     esp, ebp
.text$mn:00004B1D                 pop     ebp
.text$mn:00004B1E                 retn
.text$mn:00004B1E ??1?$list@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAE@XZ endp
.text$mn:00004B1E
.text$mn:00004B1E ; ---------------------------------------------------------------------------
.text$mn:00004B1F                 align 10h
.text$mn:00004B1F _text$mn        ends
.text$mn:00004B1F
.text$x:00004B20 ; ===========================================================================
.text$x:00004B20
.text$x:00004B20 ; Segment type: Pure code
.text$x:00004B20 ; Segment permissions: Read/Execute
.text$x:00004B20 _text$x         segment para public 'CODE' use32
.text$x:00004B20                 assume cs:_text$x
.text$x:00004B20                 ;org 4B20h
.text$x:00004B20 ; COMDAT (pick associative to section at 4ACC)
.text$x:00004B20                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00004B20
.text$x:00004B20 ; =============== S U B R O U T I N E =======================================
.text$x:00004B20
.text$x:00004B20
.text$x:00004B20 __unwindfunclet$??1?$list@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAE@XZ$0 proc near
.text$x:00004B20                                         ; DATA XREF: .xdata$x:00009F58o
.text$x:00004B20                 mov     ecx, [ebp-10h]
.text$x:00004B23                 jmp     ??1?$_List_buy@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAE@XZ ; std::_List_buy<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>::~_List_buy<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>(void)
.text$x:00004B23 __unwindfunclet$??1?$list@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAE@XZ$0 endp
.text$x:00004B23
.text$x:00004B28
.text$x:00004B28 ; =============== S U B R O U T I N E =======================================
.text$x:00004B28
.text$x:00004B28
.text$x:00004B28 __ehhandler$??1?$list@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAE@XZ proc near
.text$x:00004B28                                         ; DATA XREF: std::list<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>::~list<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>(void)+5o
.text$x:00004B28
.text$x:00004B28 arg_4           = dword ptr  8
.text$x:00004B28
.text$x:00004B28                 mov     edx, [esp+arg_4]
.text$x:00004B2C                 lea     eax, [edx+0Ch]
.text$x:00004B2F                 mov     ecx, [edx-8]
.text$x:00004B32                 xor     ecx, eax
.text$x:00004B34                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004B39                 mov     eax, offset __ehfuncinfo$??1?$list@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAE@XZ
.text$x:00004B3E                 jmp     ___CxxFrameHandler3
.text$x:00004B3E __ehhandler$??1?$list@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAE@XZ endp
.text$x:00004B3E
.text$x:00004B3E ; ---------------------------------------------------------------------------
.text$x:00004B43                 align 4
.text$x:00004B43 _text$x         ends
.text$x:00004B43
.text$mn:00004B44 ; ===========================================================================
.text$mn:00004B44
.text$mn:00004B44 ; Segment type: Pure code
.text$mn:00004B44 ; Segment permissions: Read/Execute
.text$mn:00004B44 _text$mn        segment para public 'CODE' use32
.text$mn:00004B44                 assume cs:_text$mn
.text$mn:00004B44                 ;org 4B44h
.text$mn:00004B44 ; COMDAT (pick any)
.text$mn:00004B44                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004B44
.text$mn:00004B44 ; =============== S U B R O U T I N E =======================================
.text$mn:00004B44
.text$mn:00004B44 ; Attributes: bp-based frame
.text$mn:00004B44
.text$mn:00004B44 ; public: __thiscall std::pair<int const, struct Style>::~pair<int const, struct Style>(void)
.text$mn:00004B44                 public ??1?$pair@$$CBHUStyle@@@std@@QAE@XZ
.text$mn:00004B44 ??1?$pair@$$CBHUStyle@@@std@@QAE@XZ proc near
.text$mn:00004B44                                         ; CODE XREF: std::pair<int const,Style>::`scalar deleting destructor'(uint)+Ap
.text$mn:00004B44
.text$mn:00004B44 var_10          = dword ptr -10h
.text$mn:00004B44 var_C           = dword ptr -0Ch
.text$mn:00004B44 var_4           = dword ptr -4
.text$mn:00004B44
.text$mn:00004B44                 push    ebp
.text$mn:00004B45                 mov     ebp, esp
.text$mn:00004B47                 push    0FFFFFFFFh
.text$mn:00004B49                 push    offset __ehhandler$??1?$pair@$$CBHUStyle@@@std@@QAE@XZ
.text$mn:00004B4E                 mov     eax, large fs:0
.text$mn:00004B54                 push    eax
.text$mn:00004B55                 push    ecx
.text$mn:00004B56                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004B5B                 xor     eax, ebp
.text$mn:00004B5D                 push    eax
.text$mn:00004B5E                 lea     eax, [ebp+var_C]
.text$mn:00004B61                 mov     large fs:0, eax
.text$mn:00004B67                 mov     [ebp+var_10], ecx
.text$mn:00004B6A                 mov     [ebp+var_4], 0
.text$mn:00004B71                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004B78                 mov     ecx, [ebp+var_10]
.text$mn:00004B7B                 add     ecx, 4          ; this
.text$mn:00004B7E                 call    ??1Style@@QAE@XZ ; Style::~Style(void)
.text$mn:00004B83                 mov     ecx, [ebp+var_C]
.text$mn:00004B86                 mov     large fs:0, ecx
.text$mn:00004B8D                 pop     ecx
.text$mn:00004B8E                 mov     esp, ebp
.text$mn:00004B90                 pop     ebp
.text$mn:00004B91                 retn
.text$mn:00004B91 ??1?$pair@$$CBHUStyle@@@std@@QAE@XZ endp
.text$mn:00004B91
.text$mn:00004B91 ; ---------------------------------------------------------------------------
.text$mn:00004B92                 align 4
.text$mn:00004B92 _text$mn        ends
.text$mn:00004B92
.text$x:00004B94 ; ===========================================================================
.text$x:00004B94
.text$x:00004B94 ; Segment type: Pure code
.text$x:00004B94 ; Segment permissions: Read/Execute
.text$x:00004B94 _text$x         segment para public 'CODE' use32
.text$x:00004B94                 assume cs:_text$x
.text$x:00004B94                 ;org 4B94h
.text$x:00004B94 ; COMDAT (pick associative to section at 4B44)
.text$x:00004B94                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00004B94
.text$x:00004B94 ; =============== S U B R O U T I N E =======================================
.text$x:00004B94
.text$x:00004B94
.text$x:00004B94 __unwindfunclet$??1?$pair@$$CBHUStyle@@@std@@QAE@XZ$0 proc near
.text$x:00004B94                                         ; DATA XREF: .xdata$x:0000A8C4o
.text$x:00004B94                 mov     ecx, [ebp-10h]
.text$x:00004B97                 add     ecx, 4          ; this
.text$x:00004B9A                 jmp     ??1Style@@QAE@XZ ; Style::~Style(void)
.text$x:00004B9A __unwindfunclet$??1?$pair@$$CBHUStyle@@@std@@QAE@XZ$0 endp
.text$x:00004B9A
.text$x:00004B9F
.text$x:00004B9F ; =============== S U B R O U T I N E =======================================
.text$x:00004B9F
.text$x:00004B9F
.text$x:00004B9F __ehhandler$??1?$pair@$$CBHUStyle@@@std@@QAE@XZ proc near
.text$x:00004B9F                                         ; DATA XREF: std::pair<int const,Style>::~pair<int const,Style>(void)+5o
.text$x:00004B9F
.text$x:00004B9F arg_4           = dword ptr  8
.text$x:00004B9F
.text$x:00004B9F                 mov     edx, [esp+arg_4]
.text$x:00004BA3                 lea     eax, [edx+0Ch]
.text$x:00004BA6                 mov     ecx, [edx-8]
.text$x:00004BA9                 xor     ecx, eax
.text$x:00004BAB                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004BB0                 mov     eax, offset __ehfuncinfo$??1?$pair@$$CBHUStyle@@@std@@QAE@XZ
.text$x:00004BB5                 jmp     ___CxxFrameHandler3
.text$x:00004BB5 __ehhandler$??1?$pair@$$CBHUStyle@@@std@@QAE@XZ endp
.text$x:00004BB5
.text$x:00004BB5 ; ---------------------------------------------------------------------------
.text$x:00004BBA                 align 4
.text$x:00004BBA _text$x         ends
.text$x:00004BBA
.text$mn:00004BBC ; ===========================================================================
.text$mn:00004BBC
.text$mn:00004BBC ; Segment type: Pure code
.text$mn:00004BBC ; Segment permissions: Read/Execute
.text$mn:00004BBC _text$mn        segment para public 'CODE' use32
.text$mn:00004BBC                 assume cs:_text$mn
.text$mn:00004BBC                 ;org 4BBCh
.text$mn:00004BBC ; COMDAT (pick any)
.text$mn:00004BBC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004BBC
.text$mn:00004BBC ; =============== S U B R O U T I N E =======================================
.text$mn:00004BBC
.text$mn:00004BBC ; Attributes: bp-based frame
.text$mn:00004BBC
.text$mn:00004BBC ; public: __thiscall std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>>::~unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>>(void)
.text$mn:00004BBC                 public ??1?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@QAE@XZ
.text$mn:00004BBC ??1?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@QAE@XZ proc near
.text$mn:00004BBC                                         ; CODE XREF: std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>>::`scalar deleting destructor'(uint)+Ap
.text$mn:00004BBC
.text$mn:00004BBC var_10          = dword ptr -10h
.text$mn:00004BBC var_C           = dword ptr -0Ch
.text$mn:00004BBC var_4           = dword ptr -4
.text$mn:00004BBC
.text$mn:00004BBC                 push    ebp
.text$mn:00004BBD                 mov     ebp, esp
.text$mn:00004BBF                 push    0FFFFFFFFh
.text$mn:00004BC1                 push    offset __ehhandler$??1?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@QAE@XZ
.text$mn:00004BC6                 mov     eax, large fs:0
.text$mn:00004BCC                 push    eax
.text$mn:00004BCD                 push    ecx
.text$mn:00004BCE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004BD3                 xor     eax, ebp
.text$mn:00004BD5                 push    eax
.text$mn:00004BD6                 lea     eax, [ebp+var_C]
.text$mn:00004BD9                 mov     large fs:0, eax
.text$mn:00004BDF                 mov     [ebp+var_10], ecx
.text$mn:00004BE2                 mov     [ebp+var_4], 0
.text$mn:00004BE9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004BF0                 mov     ecx, [ebp+var_10]
.text$mn:00004BF3                 call    ??1?$_Hash@V?$_Umap_traits@HUStyle@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Hash<std::_Umap_traits<int,Style,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int>>,std::allocator<std::pair<int const,Style>>,0>>::~_Hash<std::_Umap_traits<int,Style,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int>>,std::allocator<std::pair<int const,Style>>,0>>(void)
.text$mn:00004BF8                 mov     ecx, [ebp+var_C]
.text$mn:00004BFB                 mov     large fs:0, ecx
.text$mn:00004C02                 pop     ecx
.text$mn:00004C03                 mov     esp, ebp
.text$mn:00004C05                 pop     ebp
.text$mn:00004C06                 retn
.text$mn:00004C06 ??1?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@QAE@XZ endp
.text$mn:00004C06
.text$mn:00004C06 ; ---------------------------------------------------------------------------
.text$mn:00004C07                 align 4
.text$mn:00004C07 _text$mn        ends
.text$mn:00004C07
.text$x:00004C08 ; ===========================================================================
.text$x:00004C08
.text$x:00004C08 ; Segment type: Pure code
.text$x:00004C08 ; Segment permissions: Read/Execute
.text$x:00004C08 _text$x         segment para public 'CODE' use32
.text$x:00004C08                 assume cs:_text$x
.text$x:00004C08                 ;org 4C08h
.text$x:00004C08 ; COMDAT (pick associative to section at 4BBC)
.text$x:00004C08                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00004C08
.text$x:00004C08 ; =============== S U B R O U T I N E =======================================
.text$x:00004C08
.text$x:00004C08
.text$x:00004C08 __unwindfunclet$??1?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@QAE@XZ$0 proc near
.text$x:00004C08                                         ; DATA XREF: .xdata$x:0000A738o
.text$x:00004C08                 mov     ecx, [ebp-10h]
.text$x:00004C0B                 jmp     ??1?$_Hash@V?$_Umap_traits@HUStyle@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Hash<std::_Umap_traits<int,Style,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int>>,std::allocator<std::pair<int const,Style>>,0>>::~_Hash<std::_Umap_traits<int,Style,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int>>,std::allocator<std::pair<int const,Style>>,0>>(void)
.text$x:00004C0B __unwindfunclet$??1?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@QAE@XZ$0 endp
.text$x:00004C0B
.text$x:00004C10
.text$x:00004C10 ; =============== S U B R O U T I N E =======================================
.text$x:00004C10
.text$x:00004C10
.text$x:00004C10 __ehhandler$??1?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@QAE@XZ proc near
.text$x:00004C10                                         ; DATA XREF: std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>>::~unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>>(void)+5o
.text$x:00004C10
.text$x:00004C10 arg_4           = dword ptr  8
.text$x:00004C10
.text$x:00004C10                 mov     edx, [esp+arg_4]
.text$x:00004C14                 lea     eax, [edx+0Ch]
.text$x:00004C17                 mov     ecx, [edx-8]
.text$x:00004C1A                 xor     ecx, eax
.text$x:00004C1C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004C21                 mov     eax, offset __ehfuncinfo$??1?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@QAE@XZ
.text$x:00004C26                 jmp     ___CxxFrameHandler3
.text$x:00004C26 __ehhandler$??1?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@QAE@XZ endp
.text$x:00004C26
.text$x:00004C26 ; ---------------------------------------------------------------------------
.text$x:00004C2B                 align 4
.text$x:00004C2B _text$x         ends
.text$x:00004C2B
.text$mn:00004C2C ; ===========================================================================
.text$mn:00004C2C
.text$mn:00004C2C ; Segment type: Pure code
.text$mn:00004C2C ; Segment permissions: Read/Execute
.text$mn:00004C2C _text$mn        segment para public 'CODE' use32
.text$mn:00004C2C                 assume cs:_text$mn
.text$mn:00004C2C                 ;org 4C2Ch
.text$mn:00004C2C ; COMDAT (pick any)
.text$mn:00004C2C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004C2C
.text$mn:00004C2C ; =============== S U B R O U T I N E =======================================
.text$mn:00004C2C
.text$mn:00004C2C ; Attributes: bp-based frame
.text$mn:00004C2C
.text$mn:00004C2C ; public: __thiscall std::unordered_map<class Buffer *, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *, struct std::hash<class Buffer *>, struct std::equal_to<class Buffer *>, class std::allocator<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>::~unordered_map<class Buffer *, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *, struct std::hash<class Buffer *>, struct std::equal_to<class Buffer *>, class std::allocator<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>(void)
.text$mn:00004C2C                 public ??1?$unordered_map@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@U?$hash@PAVBuffer@@@3@U?$equal_to@PAVBuffer@@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@@std@@QAE@XZ
.text$mn:00004C2C ??1?$unordered_map@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@U?$hash@PAVBuffer@@@3@U?$equal_to@PAVBuffer@@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@@std@@QAE@XZ proc near
.text$mn:00004C2C                                         ; CODE XREF: __unwindfunclet$??0ScintillaEditView@@QAE@XZ$1+6j
.text$mn:00004C2C                                         ; ScintillaEditView::~ScintillaEditView(void)+1AEp ...
.text$mn:00004C2C
.text$mn:00004C2C var_10          = dword ptr -10h
.text$mn:00004C2C var_C           = dword ptr -0Ch
.text$mn:00004C2C var_4           = dword ptr -4
.text$mn:00004C2C
.text$mn:00004C2C                 push    ebp
.text$mn:00004C2D                 mov     ebp, esp
.text$mn:00004C2F                 push    0FFFFFFFFh
.text$mn:00004C31                 push    offset __ehhandler$??1?$unordered_map@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@U?$hash@PAVBuffer@@@3@U?$equal_to@PAVBuffer@@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@@std@@QAE@XZ
.text$mn:00004C36                 mov     eax, large fs:0
.text$mn:00004C3C                 push    eax
.text$mn:00004C3D                 push    ecx
.text$mn:00004C3E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004C43                 xor     eax, ebp
.text$mn:00004C45                 push    eax
.text$mn:00004C46                 lea     eax, [ebp+var_C]
.text$mn:00004C49                 mov     large fs:0, eax
.text$mn:00004C4F                 mov     [ebp+var_10], ecx
.text$mn:00004C52                 mov     [ebp+var_4], 0
.text$mn:00004C59                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004C60                 mov     ecx, [ebp+var_10]
.text$mn:00004C63                 call    ??1?$_Hash@V?$_Umap_traits@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@V?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Hash<std::_Umap_traits<Buffer *,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *,std::_Uhash_compare<Buffer *,std::hash<Buffer *>,std::equal_to<Buffer *>>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>,0>>::~_Hash<std::_Umap_traits<Buffer *,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *,std::_Uhash_compare<Buffer *,std::hash<Buffer *>,std::equal_to<Buffer *>>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>,0>>(void)
.text$mn:00004C68                 mov     ecx, [ebp+var_C]
.text$mn:00004C6B                 mov     large fs:0, ecx
.text$mn:00004C72                 pop     ecx
.text$mn:00004C73                 mov     esp, ebp
.text$mn:00004C75                 pop     ebp
.text$mn:00004C76                 retn
.text$mn:00004C76 ??1?$unordered_map@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@U?$hash@PAVBuffer@@@3@U?$equal_to@PAVBuffer@@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@@std@@QAE@XZ endp
.text$mn:00004C76
.text$mn:00004C76 ; ---------------------------------------------------------------------------
.text$mn:00004C77                 align 4
.text$mn:00004C77 _text$mn        ends
.text$mn:00004C77
.text$x:00004C78 ; ===========================================================================
.text$x:00004C78
.text$x:00004C78 ; Segment type: Pure code
.text$x:00004C78 ; Segment permissions: Read/Execute
.text$x:00004C78 _text$x         segment para public 'CODE' use32
.text$x:00004C78                 assume cs:_text$x
.text$x:00004C78                 ;org 4C78h
.text$x:00004C78 ; COMDAT (pick associative to section at 4C2C)
.text$x:00004C78                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00004C78
.text$x:00004C78 ; =============== S U B R O U T I N E =======================================
.text$x:00004C78
.text$x:00004C78
.text$x:00004C78 __unwindfunclet$??1?$unordered_map@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@U?$hash@PAVBuffer@@@3@U?$equal_to@PAVBuffer@@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@@std@@QAE@XZ$0 proc near
.text$x:00004C78                                         ; DATA XREF: .xdata$x:0000A368o
.text$x:00004C78                 mov     ecx, [ebp-10h]
.text$x:00004C7B                 jmp     ??1?$_Hash@V?$_Umap_traits@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@V?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Hash<std::_Umap_traits<Buffer *,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *,std::_Uhash_compare<Buffer *,std::hash<Buffer *>,std::equal_to<Buffer *>>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>,0>>::~_Hash<std::_Umap_traits<Buffer *,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *,std::_Uhash_compare<Buffer *,std::hash<Buffer *>,std::equal_to<Buffer *>>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>,0>>(void)
.text$x:00004C7B __unwindfunclet$??1?$unordered_map@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@U?$hash@PAVBuffer@@@3@U?$equal_to@PAVBuffer@@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@@std@@QAE@XZ$0 endp
.text$x:00004C7B
.text$x:00004C80
.text$x:00004C80 ; =============== S U B R O U T I N E =======================================
.text$x:00004C80
.text$x:00004C80
.text$x:00004C80 __ehhandler$??1?$unordered_map@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@U?$hash@PAVBuffer@@@3@U?$equal_to@PAVBuffer@@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@@std@@QAE@XZ proc near
.text$x:00004C80                                         ; DATA XREF: std::unordered_map<Buffer *,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *,std::hash<Buffer *>,std::equal_to<Buffer *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>::~unordered_map<Buffer *,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *,std::hash<Buffer *>,std::equal_to<Buffer *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>(void)+5o
.text$x:00004C80
.text$x:00004C80 arg_4           = dword ptr  8
.text$x:00004C80
.text$x:00004C80                 mov     edx, [esp+arg_4]
.text$x:00004C84                 lea     eax, [edx+0Ch]
.text$x:00004C87                 mov     ecx, [edx-8]
.text$x:00004C8A                 xor     ecx, eax
.text$x:00004C8C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004C91                 mov     eax, offset __ehfuncinfo$??1?$unordered_map@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@U?$hash@PAVBuffer@@@3@U?$equal_to@PAVBuffer@@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@@std@@QAE@XZ
.text$x:00004C96                 jmp     ___CxxFrameHandler3
.text$x:00004C96 __ehhandler$??1?$unordered_map@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@U?$hash@PAVBuffer@@@3@U?$equal_to@PAVBuffer@@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@@std@@QAE@XZ endp
.text$x:00004C96
.text$x:00004C96 ; ---------------------------------------------------------------------------
.text$x:00004C9B                 align 4
.text$x:00004C9B _text$x         ends
.text$x:00004C9B
.text$mn:00004C9C ; ===========================================================================
.text$mn:00004C9C
.text$mn:00004C9C ; Segment type: Pure code
.text$mn:00004C9C ; Segment permissions: Read/Execute
.text$mn:00004C9C _text$mn        segment para public 'CODE' use32
.text$mn:00004C9C                 assume cs:_text$mn
.text$mn:00004C9C                 ;org 4C9Ch
.text$mn:00004C9C ; COMDAT (pick any)
.text$mn:00004C9C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004C9C
.text$mn:00004C9C ; =============== S U B R O U T I N E =======================================
.text$mn:00004C9C
.text$mn:00004C9C ; Attributes: bp-based frame
.text$mn:00004C9C
.text$mn:00004C9C ; public: __thiscall std::vector<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<int const, struct Style>>>>, struct std::_Wrap_alloc<class std::allocator<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<int const, struct Style>>>>>>>::~vector<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<int const, struct Style>>>>, struct std::_Wrap_alloc<class std::allocator<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<int const, struct Style>>>>>>>(void)
.text$mn:00004C9C                 public ??1?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAE@XZ
.text$mn:00004C9C ??1?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAE@XZ proc near
.text$mn:00004C9C                                         ; CODE XREF: std::_Hash<std::_Umap_traits<int,Style,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int>>,std::allocator<std::pair<int const,Style>>,0>>::~_Hash<std::_Umap_traits<int,Style,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int>>,std::allocator<std::pair<int const,Style>>,0>>(void)+37p
.text$mn:00004C9C                                         ; __unwindfunclet$??1?$_Hash@V?$_Umap_traits@HUStyle@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@$0A@@std@@@std@@QAE@XZ$1+6j
.text$mn:00004C9C
.text$mn:00004C9C var_10          = dword ptr -10h
.text$mn:00004C9C var_C           = dword ptr -0Ch
.text$mn:00004C9C var_4           = dword ptr -4
.text$mn:00004C9C
.text$mn:00004C9C                 push    ebp
.text$mn:00004C9D                 mov     ebp, esp
.text$mn:00004C9F                 push    0FFFFFFFFh
.text$mn:00004CA1                 push    offset __ehhandler$??1?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAE@XZ
.text$mn:00004CA6                 mov     eax, large fs:0
.text$mn:00004CAC                 push    eax
.text$mn:00004CAD                 push    ecx
.text$mn:00004CAE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004CB3                 xor     eax, ebp
.text$mn:00004CB5                 push    eax
.text$mn:00004CB6                 lea     eax, [ebp+var_C]
.text$mn:00004CB9                 mov     large fs:0, eax
.text$mn:00004CBF                 mov     [ebp+var_10], ecx
.text$mn:00004CC2                 mov     [ebp+var_4], 0
.text$mn:00004CC9                 mov     ecx, [ebp+var_10]
.text$mn:00004CCC                 call    ?_Tidy@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAEXXZ ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>>>>::_Tidy(void)
.text$mn:00004CD1                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004CD8                 mov     ecx, [ebp+var_10]
.text$mn:00004CDB                 call    ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>>>>>::~_Vector_alloc<0,std::_Vec_base_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>>>>>(void)
.text$mn:00004CE0                 mov     ecx, [ebp+var_C]
.text$mn:00004CE3                 mov     large fs:0, ecx
.text$mn:00004CEA                 pop     ecx
.text$mn:00004CEB                 mov     esp, ebp
.text$mn:00004CED                 pop     ebp
.text$mn:00004CEE                 retn
.text$mn:00004CEE ??1?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAE@XZ endp
.text$mn:00004CEE
.text$mn:00004CEE ; ---------------------------------------------------------------------------
.text$mn:00004CEF                 align 10h
.text$mn:00004CEF _text$mn        ends
.text$mn:00004CEF
.text$x:00004CF0 ; ===========================================================================
.text$x:00004CF0
.text$x:00004CF0 ; Segment type: Pure code
.text$x:00004CF0 ; Segment permissions: Read/Execute
.text$x:00004CF0 _text$x         segment para public 'CODE' use32
.text$x:00004CF0                 assume cs:_text$x
.text$x:00004CF0                 ;org 4CF0h
.text$x:00004CF0 ; COMDAT (pick associative to section at 4C9C)
.text$x:00004CF0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00004CF0
.text$x:00004CF0 ; =============== S U B R O U T I N E =======================================
.text$x:00004CF0
.text$x:00004CF0
.text$x:00004CF0 __unwindfunclet$??1?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAE@XZ$0 proc near
.text$x:00004CF0                                         ; DATA XREF: .xdata$x:0000A70Co
.text$x:00004CF0                 mov     ecx, [ebp-10h]
.text$x:00004CF3                 jmp     ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>>>>>::~_Vector_alloc<0,std::_Vec_base_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>>>>>(void)
.text$x:00004CF3 __unwindfunclet$??1?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAE@XZ$0 endp
.text$x:00004CF3
.text$x:00004CF8
.text$x:00004CF8 ; =============== S U B R O U T I N E =======================================
.text$x:00004CF8
.text$x:00004CF8
.text$x:00004CF8 __ehhandler$??1?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAE@XZ proc near
.text$x:00004CF8                                         ; DATA XREF: std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>>>>::~vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>>>>(void)+5o
.text$x:00004CF8
.text$x:00004CF8 arg_4           = dword ptr  8
.text$x:00004CF8
.text$x:00004CF8                 mov     edx, [esp+arg_4]
.text$x:00004CFC                 lea     eax, [edx+0Ch]
.text$x:00004CFF                 mov     ecx, [edx-8]
.text$x:00004D02                 xor     ecx, eax
.text$x:00004D04                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004D09                 mov     eax, offset __ehfuncinfo$??1?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAE@XZ
.text$x:00004D0E                 jmp     ___CxxFrameHandler3
.text$x:00004D0E __ehhandler$??1?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAE@XZ endp
.text$x:00004D0E
.text$x:00004D0E ; ---------------------------------------------------------------------------
.text$x:00004D13                 align 4
.text$x:00004D13 _text$x         ends
.text$x:00004D13
.text$mn:00004D14 ; ===========================================================================
.text$mn:00004D14
.text$mn:00004D14 ; Segment type: Pure code
.text$mn:00004D14 ; Segment permissions: Read/Execute
.text$mn:00004D14 _text$mn        segment para public 'CODE' use32
.text$mn:00004D14                 assume cs:_text$mn
.text$mn:00004D14                 ;org 4D14h
.text$mn:00004D14 ; COMDAT (pick any)
.text$mn:00004D14                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004D14
.text$mn:00004D14 ; =============== S U B R O U T I N E =======================================
.text$mn:00004D14
.text$mn:00004D14 ; Attributes: bp-based frame
.text$mn:00004D14
.text$mn:00004D14 ; public: __thiscall std::vector<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>, struct std::_Wrap_alloc<class std::allocator<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>>>>::~vector<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>, struct std::_Wrap_alloc<class std::allocator<class st
.text$mn:00004D14                 public ??1?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAE@XZ
.text$mn:00004D14 ??1?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAE@XZ proc near
.text$mn:00004D14                                         ; CODE XREF: __unwindfunclet$??0?$_Hash@V?$_Umap_traits@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@V?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@$0A@@std@@@std@@QAE@ABV?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@1@ABV?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@1@@Z$1+6j
.text$mn:00004D14                                         ; std::_Hash<std::_Umap_traits<Buffer *,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *,std::_Uhash_compare<Buffer *,std::hash<Buffer *>,std::equal_to<Buffer *>>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>,0>>::~_Hash<std::_Umap_traits<Buffer *,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *,std::_Uhash_compare<Buffer *,std::hash<Buffer *>,std::equal_to<Buffer *>>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>,0>>(void)+37p ...
.text$mn:00004D14
.text$mn:00004D14 var_10          = dword ptr -10h
.text$mn:00004D14 var_C           = dword ptr -0Ch
.text$mn:00004D14 var_4           = dword ptr -4
.text$mn:00004D14
.text$mn:00004D14                 push    ebp
.text$mn:00004D15                 mov     ebp, esp
.text$mn:00004D17                 push    0FFFFFFFFh
.text$mn:00004D19                 push    offset __ehhandler$??1?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAE@XZ
.text$mn:00004D1E                 mov     eax, large fs:0
.text$mn:00004D24                 push    eax
.text$mn:00004D25                 push    ecx
.text$mn:00004D26                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004D2B                 xor     eax, ebp
.text$mn:00004D2D                 push    eax
.text$mn:00004D2E                 lea     eax, [ebp+var_C]
.text$mn:00004D31                 mov     large fs:0, eax
.text$mn:00004D37                 mov     [ebp+var_10], ecx
.text$mn:00004D3A                 mov     [ebp+var_4], 0
.text$mn:00004D41                 mov     ecx, [ebp+var_10]
.text$mn:00004D44                 call    ?_Tidy@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAEXXZ ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::_Tidy(void)
.text$mn:00004D49                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004D50                 mov     ecx, [ebp+var_10]
.text$mn:00004D53                 call    ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>>::~_Vector_alloc<0,std::_Vec_base_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>>(void)
.text$mn:00004D58                 mov     ecx, [ebp+var_C]
.text$mn:00004D5B                 mov     large fs:0, ecx
.text$mn:00004D62                 pop     ecx
.text$mn:00004D63                 mov     esp, ebp
.text$mn:00004D65                 pop     ebp
.text$mn:00004D66                 retn
.text$mn:00004D66 ??1?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAE@XZ endp
.text$mn:00004D66
.text$mn:00004D66 ; ---------------------------------------------------------------------------
.text$mn:00004D67                 align 4
.text$mn:00004D67 _text$mn        ends
.text$mn:00004D67
.text$x:00004D68 ; ===========================================================================
.text$x:00004D68
.text$x:00004D68 ; Segment type: Pure code
.text$x:00004D68 ; Segment permissions: Read/Execute
.text$x:00004D68 _text$x         segment para public 'CODE' use32
.text$x:00004D68                 assume cs:_text$x
.text$x:00004D68                 ;org 4D68h
.text$x:00004D68 ; COMDAT (pick associative to section at 4D14)
.text$x:00004D68                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00004D68
.text$x:00004D68 ; =============== S U B R O U T I N E =======================================
.text$x:00004D68
.text$x:00004D68
.text$x:00004D68 __unwindfunclet$??1?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAE@XZ$0 proc near
.text$x:00004D68                                         ; DATA XREF: .xdata$x:0000A1A4o
.text$x:00004D68                 mov     ecx, [ebp-10h]
.text$x:00004D6B                 jmp     ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>>::~_Vector_alloc<0,std::_Vec_base_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>>(void)
.text$x:00004D6B __unwindfunclet$??1?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAE@XZ$0 endp
.text$x:00004D6B
.text$x:00004D70
.text$x:00004D70 ; =============== S U B R O U T I N E =======================================
.text$x:00004D70
.text$x:00004D70
.text$x:00004D70 __ehhandler$??1?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAE@XZ proc near
.text$x:00004D70                                         ; DATA XREF: std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::~vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>(void)+5o
.text$x:00004D70
.text$x:00004D70 arg_4           = dword ptr  8
.text$x:00004D70
.text$x:00004D70                 mov     edx, [esp+arg_4]
.text$x:00004D74                 lea     eax, [edx+0Ch]
.text$x:00004D77                 mov     ecx, [edx-8]
.text$x:00004D7A                 xor     ecx, eax
.text$x:00004D7C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004D81                 mov     eax, offset __ehfuncinfo$??1?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAE@XZ
.text$x:00004D86                 jmp     ___CxxFrameHandler3
.text$x:00004D86 __ehhandler$??1?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAE@XZ endp
.text$x:00004D86
.text$x:00004D86 ; ---------------------------------------------------------------------------
.text$x:00004D8B                 align 4
.text$x:00004D8B _text$x         ends
.text$x:00004D8B
.text$mn:00004D8C ; ===========================================================================
.text$mn:00004D8C
.text$mn:00004D8C ; Segment type: Pure code
.text$mn:00004D8C ; Segment permissions: Read/Execute
.text$mn:00004D8C _text$mn        segment para public 'CODE' use32
.text$mn:00004D8C                 assume cs:_text$mn
.text$mn:00004D8C                 ;org 4D8Ch
.text$mn:00004D8C ; COMDAT (pick any)
.text$mn:00004D8C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004D8C
.text$mn:00004D8C ; =============== S U B R O U T I N E =======================================
.text$mn:00004D8C
.text$mn:00004D8C ; Attributes: bp-based frame
.text$mn:00004D8C
.text$mn:00004D8C ; _DWORD __thiscall ScintillaEditView::~ScintillaEditView(ScintillaEditView *__hidden this)
.text$mn:00004D8C                 public ??1ScintillaEditView@@UAE@XZ
.text$mn:00004D8C ??1ScintillaEditView@@UAE@XZ proc near  ; CODE XREF: ScintillaEditView::`scalar deleting destructor'(uint)+Ap
.text$mn:00004D8C
.text$mn:00004D8C var_64          = byte ptr -64h
.text$mn:00004D8C var_58          = byte ptr -58h
.text$mn:00004D8C var_4C          = byte ptr -4Ch
.text$mn:00004D8C var_40          = byte ptr -40h
.text$mn:00004D8C var_34          = dword ptr -34h
.text$mn:00004D8C var_30          = dword ptr -30h
.text$mn:00004D8C var_2C          = dword ptr -2Ch
.text$mn:00004D8C var_28          = dword ptr -28h
.text$mn:00004D8C var_24          = dword ptr -24h
.text$mn:00004D8C var_20          = dword ptr -20h
.text$mn:00004D8C var_1C          = dword ptr -1Ch
.text$mn:00004D8C var_18          = dword ptr -18h
.text$mn:00004D8C var_14          = dword ptr -14h
.text$mn:00004D8C var_E           = byte ptr -0Eh
.text$mn:00004D8C var_D           = byte ptr -0Dh
.text$mn:00004D8C var_C           = dword ptr -0Ch
.text$mn:00004D8C var_4           = dword ptr -4
.text$mn:00004D8C
.text$mn:00004D8C                 push    ebp
.text$mn:00004D8D                 mov     ebp, esp
.text$mn:00004D8F                 push    0FFFFFFFFh
.text$mn:00004D91                 push    offset __ehhandler$??1ScintillaEditView@@UAE@XZ
.text$mn:00004D96                 mov     eax, large fs:0
.text$mn:00004D9C                 push    eax
.text$mn:00004D9D                 sub     esp, 58h
.text$mn:00004DA0                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004DA5                 xor     eax, ebp
.text$mn:00004DA7                 push    eax
.text$mn:00004DA8                 lea     eax, [ebp+var_C]
.text$mn:00004DAB                 mov     large fs:0, eax
.text$mn:00004DB1                 mov     [ebp+var_14], ecx
.text$mn:00004DB4                 mov     eax, [ebp+var_14]
.text$mn:00004DB7                 mov     dword ptr [eax], offset ??_7ScintillaEditView@@6B@ ; const ScintillaEditView::`vftable'
.text$mn:00004DBD                 mov     [ebp+var_4], 1
.text$mn:00004DC4                 mov     ecx, dword ptr ds:?_refCount@ScintillaEditView@@1HA ; int ScintillaEditView::_refCount
.text$mn:00004DCA                 sub     ecx, 1
.text$mn:00004DCD                 mov     dword ptr ds:?_refCount@ScintillaEditView@@1HA, ecx ; int ScintillaEditView::_refCount
.text$mn:00004DD3                 jnz     loc_4F30
.text$mn:00004DD9                 cmp     dword ptr ds:?_hLib@ScintillaEditView@@1PAUHINSTANCE__@@A, 0 ; HINSTANCE__ * ScintillaEditView::_hLib
.text$mn:00004DE0                 jz      loc_4F30
.text$mn:00004DE6                 mov     edx, dword ptr ds:?_hLib@ScintillaEditView@@1PAUHINSTANCE__@@A ; HINSTANCE__ * ScintillaEditView::_hLib
.text$mn:00004DEC                 push    edx             ; hLibModule
.text$mn:00004DED                 call    dword ptr ds:__imp__FreeLibrary@4 ; FreeLibrary(x)
.text$mn:00004DF3                 lea     eax, [ebp+var_40]
.text$mn:00004DF6                 push    eax
.text$mn:00004DF7                 mov     ecx, [ebp+var_14]
.text$mn:00004DFA                 add     ecx, 30h ; '0'
.text$mn:00004DFD                 call    ?begin@?$_Hash@V?$_Umap_traits@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@V?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@XZ ; std::_Hash<std::_Umap_traits<Buffer *,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *,std::_Uhash_compare<Buffer *,std::hash<Buffer *>,std::equal_to<Buffer *>>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>,0>>::begin(void)
.text$mn:00004E02                 mov     byte ptr [ebp+var_4], 2
.text$mn:00004E06                 jmp     short loc_4E10
.text$mn:00004E08 ; ---------------------------------------------------------------------------
.text$mn:00004E08
.text$mn:00004E08 loc_4E08:                               ; CODE XREF: ScintillaEditView::~ScintillaEditView(void):loc_4F1Fj
.text$mn:00004E08                 lea     ecx, [ebp+var_40]
.text$mn:00004E0B                 call    ??E?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::operator++(void)
.text$mn:00004E10
.text$mn:00004E10 loc_4E10:                               ; CODE XREF: ScintillaEditView::~ScintillaEditView(void)+7Aj
.text$mn:00004E10                 lea     ecx, [ebp+var_58]
.text$mn:00004E13                 push    ecx
.text$mn:00004E14                 mov     ecx, [ebp+var_14]
.text$mn:00004E17                 add     ecx, 30h ; '0'
.text$mn:00004E1A                 call    ?end@?$_Hash@V?$_Umap_traits@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@V?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@XZ ; std::_Hash<std::_Umap_traits<Buffer *,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *,std::_Uhash_compare<Buffer *,std::hash<Buffer *>,std::equal_to<Buffer *>>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>,0>>::end(void)
.text$mn:00004E1F                 mov     [ebp+var_1C], eax
.text$mn:00004E22                 mov     edx, [ebp+var_1C]
.text$mn:00004E25                 mov     [ebp+var_20], edx
.text$mn:00004E28                 mov     byte ptr [ebp+var_4], 3
.text$mn:00004E2C                 mov     eax, [ebp+var_20]
.text$mn:00004E2F                 push    eax             ; std::_Iterator_base12 *
.text$mn:00004E30                 lea     ecx, [ebp+var_40]
.text$mn:00004E33                 call    ??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::operator!=(std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const &)
.text$mn:00004E38                 mov     [ebp+var_D], al
.text$mn:00004E3B                 mov     byte ptr [ebp+var_4], 2
.text$mn:00004E3F                 lea     ecx, [ebp+var_58]
.text$mn:00004E42                 call    ??1?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::~_List_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>(void)
.text$mn:00004E47                 movzx   ecx, [ebp+var_D]
.text$mn:00004E4B                 test    ecx, ecx
.text$mn:00004E4D                 jz      loc_4F24
.text$mn:00004E53                 lea     edx, [ebp+var_4C]
.text$mn:00004E56                 push    edx
.text$mn:00004E57                 lea     ecx, [ebp+var_40]
.text$mn:00004E5A                 call    ??C?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QBEPAU?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@1@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::operator->(void)
.text$mn:00004E5F                 mov     ecx, [eax+4]
.text$mn:00004E62                 call    ?begin@?$_Hash@V?$_Umap_traits@HUStyle@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@2@XZ ; std::_Hash<std::_Umap_traits<int,Style,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int>>,std::allocator<std::pair<int const,Style>>,0>>::begin(void)
.text$mn:00004E67                 mov     byte ptr [ebp+var_4], 4
.text$mn:00004E6B                 jmp     short loc_4E75
.text$mn:00004E6D ; ---------------------------------------------------------------------------
.text$mn:00004E6D
.text$mn:00004E6D loc_4E6D:                               ; CODE XREF: ScintillaEditView::~ScintillaEditView(void):loc_4EE1j
.text$mn:00004E6D                 lea     ecx, [ebp+var_4C]
.text$mn:00004E70                 call    ??E?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>::operator++(void)
.text$mn:00004E75
.text$mn:00004E75 loc_4E75:                               ; CODE XREF: ScintillaEditView::~ScintillaEditView(void)+DFj
.text$mn:00004E75                 lea     eax, [ebp+var_64]
.text$mn:00004E78                 push    eax
.text$mn:00004E79                 lea     ecx, [ebp+var_40]
.text$mn:00004E7C                 call    ??C?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QBEPAU?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@1@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::operator->(void)
.text$mn:00004E81                 mov     ecx, [eax+4]
.text$mn:00004E84                 call    ?end@?$_Hash@V?$_Umap_traits@HUStyle@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@2@XZ ; std::_Hash<std::_Umap_traits<int,Style,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int>>,std::allocator<std::pair<int const,Style>>,0>>::end(void)
.text$mn:00004E89                 mov     [ebp+var_24], eax
.text$mn:00004E8C                 mov     ecx, [ebp+var_24]
.text$mn:00004E8F                 mov     [ebp+var_28], ecx
.text$mn:00004E92                 mov     byte ptr [ebp+var_4], 5
.text$mn:00004E96                 mov     edx, [ebp+var_28]
.text$mn:00004E99                 push    edx             ; std::_Iterator_base12 *
.text$mn:00004E9A                 lea     ecx, [ebp+var_4C]
.text$mn:00004E9D                 call    ??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>::operator!=(std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>> const &)
.text$mn:00004EA2                 mov     [ebp+var_E], al
.text$mn:00004EA5                 mov     byte ptr [ebp+var_4], 4
.text$mn:00004EA9                 lea     ecx, [ebp+var_64]
.text$mn:00004EAC                 call    ??1?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>::~_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>(void)
.text$mn:00004EB1                 movzx   eax, [ebp+var_E]
.text$mn:00004EB5                 test    eax, eax
.text$mn:00004EB7                 jz      short loc_4EE3
.text$mn:00004EB9                 lea     ecx, [ebp+var_4C]
.text$mn:00004EBC                 call    ??C?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@QBEPAU?$pair@$$CBHUStyle@@@1@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>::operator->(void)
.text$mn:00004EC1                 cmp     dword ptr [eax+18h], 0
.text$mn:00004EC5                 jz      short loc_4EE1
.text$mn:00004EC7                 lea     ecx, [ebp+var_4C]
.text$mn:00004ECA                 call    ??C?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@QBEPAU?$pair@$$CBHUStyle@@@1@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>::operator->(void)
.text$mn:00004ECF                 mov     ecx, [eax+18h]
.text$mn:00004ED2                 mov     [ebp+var_2C], ecx
.text$mn:00004ED5                 mov     edx, [ebp+var_2C]
.text$mn:00004ED8                 push    edx             ; void *
.text$mn:00004ED9                 call    ??_V@YAXPAX@Z   ; operator delete[](void *)
.text$mn:00004EDE                 add     esp, 4
.text$mn:00004EE1
.text$mn:00004EE1 loc_4EE1:                               ; CODE XREF: ScintillaEditView::~ScintillaEditView(void)+139j
.text$mn:00004EE1                 jmp     short loc_4E6D
.text$mn:00004EE3 ; ---------------------------------------------------------------------------
.text$mn:00004EE3
.text$mn:00004EE3 loc_4EE3:                               ; CODE XREF: ScintillaEditView::~ScintillaEditView(void)+12Bj
.text$mn:00004EE3                 mov     byte ptr [ebp+var_4], 2
.text$mn:00004EE7                 lea     ecx, [ebp+var_4C]
.text$mn:00004EEA                 call    ??1?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>::~_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>(void)
.text$mn:00004EEF                 lea     ecx, [ebp+var_40]
.text$mn:00004EF2                 call    ??C?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QBEPAU?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@1@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::operator->(void)
.text$mn:00004EF7                 mov     eax, [eax+4]
.text$mn:00004EFA                 mov     [ebp+var_30], eax
.text$mn:00004EFD                 mov     ecx, [ebp+var_30]
.text$mn:00004F00                 mov     [ebp+var_18], ecx
.text$mn:00004F03                 cmp     [ebp+var_18], 0
.text$mn:00004F07                 jz      short loc_4F18
.text$mn:00004F09                 push    1
.text$mn:00004F0B                 mov     ecx, [ebp+var_18]
.text$mn:00004F0E                 call    ??_G?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@QAEPAXI@Z ; std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>>::`scalar deleting destructor'(uint)
.text$mn:00004F13                 mov     [ebp+var_34], eax
.text$mn:00004F16                 jmp     short loc_4F1F
.text$mn:00004F18 ; ---------------------------------------------------------------------------
.text$mn:00004F18
.text$mn:00004F18 loc_4F18:                               ; CODE XREF: ScintillaEditView::~ScintillaEditView(void)+17Bj
.text$mn:00004F18                 mov     [ebp+var_34], 0
.text$mn:00004F1F
.text$mn:00004F1F loc_4F1F:                               ; CODE XREF: ScintillaEditView::~ScintillaEditView(void)+18Aj
.text$mn:00004F1F                 jmp     loc_4E08
.text$mn:00004F24 ; ---------------------------------------------------------------------------
.text$mn:00004F24
.text$mn:00004F24 loc_4F24:                               ; CODE XREF: ScintillaEditView::~ScintillaEditView(void)+C1j
.text$mn:00004F24                 mov     byte ptr [ebp+var_4], 1
.text$mn:00004F28                 lea     ecx, [ebp+var_40]
.text$mn:00004F2B                 call    ??1?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::~_List_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>(void)
.text$mn:00004F30
.text$mn:00004F30 loc_4F30:                               ; CODE XREF: ScintillaEditView::~ScintillaEditView(void)+47j
.text$mn:00004F30                                         ; ScintillaEditView::~ScintillaEditView(void)+54j
.text$mn:00004F30                 mov     byte ptr [ebp+var_4], 0
.text$mn:00004F34                 mov     ecx, [ebp+var_14]
.text$mn:00004F37                 add     ecx, 30h ; '0'
.text$mn:00004F3A                 call    ??1?$unordered_map@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@U?$hash@PAVBuffer@@@3@U?$equal_to@PAVBuffer@@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@@std@@QAE@XZ ; std::unordered_map<Buffer *,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *,std::hash<Buffer *>,std::equal_to<Buffer *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>::~unordered_map<Buffer *,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *,std::hash<Buffer *>,std::equal_to<Buffer *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>(void)
.text$mn:00004F3F                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004F46                 mov     ecx, [ebp+var_14] ; this
.text$mn:00004F49                 call    ??1Window@@UAE@XZ ; Window::~Window(void)
.text$mn:00004F4E                 mov     ecx, [ebp+var_C]
.text$mn:00004F51                 mov     large fs:0, ecx
.text$mn:00004F58                 pop     ecx
.text$mn:00004F59                 mov     esp, ebp
.text$mn:00004F5B                 pop     ebp
.text$mn:00004F5C                 retn
.text$mn:00004F5C ??1ScintillaEditView@@UAE@XZ endp
.text$mn:00004F5C
.text$mn:00004F5C ; ---------------------------------------------------------------------------
.text$mn:00004F5D                 align 10h
.text$mn:00004F5D _text$mn        ends
.text$mn:00004F5D
.text$x:00004F60 ; ===========================================================================
.text$x:00004F60
.text$x:00004F60 ; Segment type: Pure code
.text$x:00004F60 ; Segment permissions: Read/Execute
.text$x:00004F60 _text$x         segment para public 'CODE' use32
.text$x:00004F60                 assume cs:_text$x
.text$x:00004F60                 ;org 4F60h
.text$x:00004F60 ; COMDAT (pick associative to section at 4D8C)
.text$x:00004F60                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00004F60
.text$x:00004F60 ; =============== S U B R O U T I N E =======================================
.text$x:00004F60
.text$x:00004F60
.text$x:00004F60 __unwindfunclet$??1ScintillaEditView@@UAE@XZ$0 proc near
.text$x:00004F60                                         ; DATA XREF: .xdata$x:00009D68o
.text$x:00004F60                 mov     ecx, [ebp-14h]  ; this
.text$x:00004F63                 jmp     ??1Window@@UAE@XZ ; Window::~Window(void)
.text$x:00004F63 __unwindfunclet$??1ScintillaEditView@@UAE@XZ$0 endp
.text$x:00004F63
.text$x:00004F68
.text$x:00004F68 ; =============== S U B R O U T I N E =======================================
.text$x:00004F68
.text$x:00004F68
.text$x:00004F68 __unwindfunclet$??1ScintillaEditView@@UAE@XZ$1 proc near
.text$x:00004F68                                         ; DATA XREF: .xdata$x:00009D70o
.text$x:00004F68                 mov     ecx, [ebp-14h]
.text$x:00004F6B                 add     ecx, 30h ; '0'
.text$x:00004F6E                 jmp     ??1?$unordered_map@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@U?$hash@PAVBuffer@@@3@U?$equal_to@PAVBuffer@@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@@std@@QAE@XZ ; std::unordered_map<Buffer *,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *,std::hash<Buffer *>,std::equal_to<Buffer *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>::~unordered_map<Buffer *,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *,std::hash<Buffer *>,std::equal_to<Buffer *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>(void)
.text$x:00004F6E __unwindfunclet$??1ScintillaEditView@@UAE@XZ$1 endp
.text$x:00004F6E
.text$x:00004F73
.text$x:00004F73 ; =============== S U B R O U T I N E =======================================
.text$x:00004F73
.text$x:00004F73
.text$x:00004F73 __unwindfunclet$??1ScintillaEditView@@UAE@XZ$2 proc near
.text$x:00004F73                                         ; DATA XREF: .xdata$x:00009D78o
.text$x:00004F73                 lea     ecx, [ebp-40h]
.text$x:00004F76                 jmp     ??1?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::~_List_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>(void)
.text$x:00004F76 __unwindfunclet$??1ScintillaEditView@@UAE@XZ$2 endp
.text$x:00004F76
.text$x:00004F7B
.text$x:00004F7B ; =============== S U B R O U T I N E =======================================
.text$x:00004F7B
.text$x:00004F7B
.text$x:00004F7B __unwindfunclet$??1ScintillaEditView@@UAE@XZ$3 proc near
.text$x:00004F7B                                         ; DATA XREF: .xdata$x:00009D80o
.text$x:00004F7B                 lea     ecx, [ebp-58h]
.text$x:00004F7E                 jmp     ??1?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::~_List_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>(void)
.text$x:00004F7E __unwindfunclet$??1ScintillaEditView@@UAE@XZ$3 endp
.text$x:00004F7E
.text$x:00004F83
.text$x:00004F83 ; =============== S U B R O U T I N E =======================================
.text$x:00004F83
.text$x:00004F83
.text$x:00004F83 __unwindfunclet$??1ScintillaEditView@@UAE@XZ$4 proc near
.text$x:00004F83                                         ; DATA XREF: .xdata$x:00009D88o
.text$x:00004F83                 lea     ecx, [ebp-4Ch]
.text$x:00004F86                 jmp     ??1?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>::~_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>(void)
.text$x:00004F86 __unwindfunclet$??1ScintillaEditView@@UAE@XZ$4 endp
.text$x:00004F86
.text$x:00004F8B
.text$x:00004F8B ; =============== S U B R O U T I N E =======================================
.text$x:00004F8B
.text$x:00004F8B
.text$x:00004F8B __unwindfunclet$??1ScintillaEditView@@UAE@XZ$5 proc near
.text$x:00004F8B                                         ; DATA XREF: .xdata$x:00009D90o
.text$x:00004F8B                 lea     ecx, [ebp-64h]
.text$x:00004F8E                 jmp     ??1?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>::~_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>(void)
.text$x:00004F8E __unwindfunclet$??1ScintillaEditView@@UAE@XZ$5 endp
.text$x:00004F8E
.text$x:00004F93
.text$x:00004F93 ; =============== S U B R O U T I N E =======================================
.text$x:00004F93
.text$x:00004F93
.text$x:00004F93 __ehhandler$??1ScintillaEditView@@UAE@XZ proc near
.text$x:00004F93                                         ; DATA XREF: ScintillaEditView::~ScintillaEditView(void)+5o
.text$x:00004F93
.text$x:00004F93 arg_4           = dword ptr  8
.text$x:00004F93
.text$x:00004F93                 mov     edx, [esp+arg_4]
.text$x:00004F97                 lea     eax, [edx+0Ch]
.text$x:00004F9A                 mov     ecx, [edx-5Ch]
.text$x:00004F9D                 xor     ecx, eax
.text$x:00004F9F                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004FA4                 mov     eax, offset __ehfuncinfo$??1ScintillaEditView@@UAE@XZ
.text$x:00004FA9                 jmp     ___CxxFrameHandler3
.text$x:00004FA9 __ehhandler$??1ScintillaEditView@@UAE@XZ endp
.text$x:00004FA9
.text$x:00004FA9 ; ---------------------------------------------------------------------------
.text$x:00004FAE                 align 10h
.text$x:00004FAE _text$x         ends
.text$x:00004FAE
.text$mn:00004FB0 ; ===========================================================================
.text$mn:00004FB0
.text$mn:00004FB0 ; Segment type: Pure code
.text$mn:00004FB0 ; Segment permissions: Read/Execute
.text$mn:00004FB0 _text$mn        segment para public 'CODE' use32
.text$mn:00004FB0                 assume cs:_text$mn
.text$mn:00004FB0                 ;org 4FB0h
.text$mn:00004FB0 ; COMDAT (pick any)
.text$mn:00004FB0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004FB0
.text$mn:00004FB0 ; =============== S U B R O U T I N E =======================================
.text$mn:00004FB0
.text$mn:00004FB0 ; Attributes: bp-based frame
.text$mn:00004FB0
.text$mn:00004FB0 ; _DWORD __thiscall Style::~Style(Style *__hidden this)
.text$mn:00004FB0                 public ??1Style@@QAE@XZ
.text$mn:00004FB0 ??1Style@@QAE@XZ proc near              ; CODE XREF: std::pair<int const,Style>::~pair<int const,Style>(void)+3Ap
.text$mn:00004FB0                                         ; __unwindfunclet$??1?$pair@$$CBHUStyle@@@std@@QAE@XZ$0+6j
.text$mn:00004FB0
.text$mn:00004FB0 var_10          = dword ptr -10h
.text$mn:00004FB0 var_C           = dword ptr -0Ch
.text$mn:00004FB0 var_8           = dword ptr -8
.text$mn:00004FB0 var_4           = dword ptr -4
.text$mn:00004FB0
.text$mn:00004FB0                 push    ebp
.text$mn:00004FB1                 mov     ebp, esp
.text$mn:00004FB3                 sub     esp, 10h
.text$mn:00004FB6                 mov     [ebp+var_4], ecx
.text$mn:00004FB9                 mov     eax, [ebp+var_4]
.text$mn:00004FBC                 cmp     dword ptr [eax+28h], 0
.text$mn:00004FC0                 jz      short loc_4FED
.text$mn:00004FC2                 mov     ecx, [ebp+var_4]
.text$mn:00004FC5                 mov     edx, [ecx+28h]
.text$mn:00004FC8                 mov     [ebp+var_C], edx
.text$mn:00004FCB                 mov     eax, [ebp+var_C]
.text$mn:00004FCE                 mov     [ebp+var_8], eax
.text$mn:00004FD1                 cmp     [ebp+var_8], 0
.text$mn:00004FD5                 jz      short loc_4FE6
.text$mn:00004FD7                 push    1
.text$mn:00004FD9                 mov     ecx, [ebp+var_8]
.text$mn:00004FDC                 call    ??_G?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEPAXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::`scalar deleting destructor'(uint)
.text$mn:00004FE1                 mov     [ebp+var_10], eax
.text$mn:00004FE4                 jmp     short loc_4FED
.text$mn:00004FE6 ; ---------------------------------------------------------------------------
.text$mn:00004FE6
.text$mn:00004FE6 loc_4FE6:                               ; CODE XREF: Style::~Style(void)+25j
.text$mn:00004FE6                 mov     [ebp+var_10], 0
.text$mn:00004FED
.text$mn:00004FED loc_4FED:                               ; CODE XREF: Style::~Style(void)+10j
.text$mn:00004FED                                         ; Style::~Style(void)+34j
.text$mn:00004FED                 mov     esp, ebp
.text$mn:00004FEF                 pop     ebp
.text$mn:00004FF0                 retn
.text$mn:00004FF0 ??1Style@@QAE@XZ endp
.text$mn:00004FF0
.text$mn:00004FF0 ; ---------------------------------------------------------------------------
.text$mn:00004FF1                 align 4
.text$mn:00004FF1 _text$mn        ends
.text$mn:00004FF1
.text$mn:00004FF4 ; ===========================================================================
.text$mn:00004FF4
.text$mn:00004FF4 ; Segment type: Pure code
.text$mn:00004FF4 ; Segment permissions: Read/Execute
.text$mn:00004FF4 _text$mn        segment para public 'CODE' use32
.text$mn:00004FF4                 assume cs:_text$mn
.text$mn:00004FF4                 ;org 4FF4h
.text$mn:00004FF4 ; COMDAT (pick any)
.text$mn:00004FF4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004FF4
.text$mn:00004FF4 ; =============== S U B R O U T I N E =======================================
.text$mn:00004FF4
.text$mn:00004FF4 ; Attributes: bp-based frame
.text$mn:00004FF4
.text$mn:00004FF4 ; _DWORD __thiscall Window::~Window(Window *__hidden this)
.text$mn:00004FF4                 public ??1Window@@UAE@XZ
.text$mn:00004FF4 ??1Window@@UAE@XZ proc near             ; CODE XREF: __unwindfunclet$??0ScintillaEditView@@QAE@XZ$0+3j
.text$mn:00004FF4                                         ; ScintillaEditView::~ScintillaEditView(void)+1BDp ...
.text$mn:00004FF4
.text$mn:00004FF4 var_4           = dword ptr -4
.text$mn:00004FF4
.text$mn:00004FF4                 push    ebp
.text$mn:00004FF5                 mov     ebp, esp
.text$mn:00004FF7                 push    ecx
.text$mn:00004FF8                 mov     [ebp+var_4], ecx
.text$mn:00004FFB                 mov     eax, [ebp+var_4]
.text$mn:00004FFE                 mov     dword ptr [eax], offset ??_7Window@@6B@ ; const Window::`vftable'
.text$mn:00005004                 mov     esp, ebp
.text$mn:00005006                 pop     ebp
.text$mn:00005007                 retn
.text$mn:00005007 ??1Window@@UAE@XZ endp
.text$mn:00005007
.text$mn:00005007 _text$mn        ends
.text$mn:00005007
.text$mn:00005008 ; ===========================================================================
.text$mn:00005008
.text$mn:00005008 ; Segment type: Pure code
.text$mn:00005008 ; Segment permissions: Read/Execute
.text$mn:00005008 _text$mn        segment para public 'CODE' use32
.text$mn:00005008                 assume cs:_text$mn
.text$mn:00005008                 ;org 5008h
.text$mn:00005008 ; COMDAT (pick any)
.text$mn:00005008                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005008
.text$mn:00005008 ; =============== S U B R O U T I N E =======================================
.text$mn:00005008
.text$mn:00005008 ; Attributes: bp-based frame
.text$mn:00005008
.text$mn:00005008 ; _DWORD __thiscall std::_Container_base12::~_Container_base12(std::_Container_base12 *__hidden this)
.text$mn:00005008                 public ??1_Container_base12@std@@QAE@XZ
.text$mn:00005008 ??1_Container_base12@std@@QAE@XZ proc near
.text$mn:00005008                                         ; CODE XREF: __unwindfunclet$??0?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@QAE@XZ$0+3j
.text$mn:00005008                                         ; __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0+3j ...
.text$mn:00005008
.text$mn:00005008 var_4           = dword ptr -4
.text$mn:00005008
.text$mn:00005008                 push    ebp
.text$mn:00005009                 mov     ebp, esp
.text$mn:0000500B                 push    ecx
.text$mn:0000500C                 mov     [ebp+var_4], ecx
.text$mn:0000500F                 mov     ecx, [ebp+var_4] ; this
.text$mn:00005012                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00005017                 mov     esp, ebp
.text$mn:00005019                 pop     ebp
.text$mn:0000501A                 retn
.text$mn:0000501A ??1_Container_base12@std@@QAE@XZ endp
.text$mn:0000501A
.text$mn:0000501A ; ---------------------------------------------------------------------------
.text$mn:0000501B                 align 4
.text$mn:0000501B _text$mn        ends
.text$mn:0000501B
.text$mn:0000501C ; ===========================================================================
.text$mn:0000501C
.text$mn:0000501C ; Segment type: Pure code
.text$mn:0000501C ; Segment permissions: Read/Execute
.text$mn:0000501C _text$mn        segment para public 'CODE' use32
.text$mn:0000501C                 assume cs:_text$mn
.text$mn:0000501C                 ;org 501Ch
.text$mn:0000501C ; COMDAT (pick any)
.text$mn:0000501C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000501C
.text$mn:0000501C ; =============== S U B R O U T I N E =======================================
.text$mn:0000501C
.text$mn:0000501C ; Attributes: bp-based frame
.text$mn:0000501C
.text$mn:0000501C ; _DWORD __thiscall std::_Generic_error_category::~_Generic_error_category(std::_Generic_error_category *__hidden this)
.text$mn:0000501C                 public ??1_Generic_error_category@std@@UAE@XZ
.text$mn:0000501C ??1_Generic_error_category@std@@UAE@XZ proc near
.text$mn:0000501C                                         ; CODE XREF: __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0+3j
.text$mn:0000501C                                         ; __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0+3j ...
.text$mn:0000501C
.text$mn:0000501C var_10          = dword ptr -10h
.text$mn:0000501C var_C           = dword ptr -0Ch
.text$mn:0000501C var_4           = dword ptr -4
.text$mn:0000501C
.text$mn:0000501C                 push    ebp
.text$mn:0000501D                 mov     ebp, esp
.text$mn:0000501F                 push    0FFFFFFFFh
.text$mn:00005021                 push    offset __ehhandler$??1_Generic_error_category@std@@UAE@XZ
.text$mn:00005026                 mov     eax, large fs:0
.text$mn:0000502C                 push    eax
.text$mn:0000502D                 push    ecx
.text$mn:0000502E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005033                 xor     eax, ebp
.text$mn:00005035                 push    eax
.text$mn:00005036                 lea     eax, [ebp+var_C]
.text$mn:00005039                 mov     large fs:0, eax
.text$mn:0000503F                 mov     [ebp+var_10], ecx
.text$mn:00005042                 mov     [ebp+var_4], 0
.text$mn:00005049                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005050                 mov     ecx, [ebp+var_10] ; this
.text$mn:00005053                 call    ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$mn:00005058                 mov     ecx, [ebp+var_C]
.text$mn:0000505B                 mov     large fs:0, ecx
.text$mn:00005062                 pop     ecx
.text$mn:00005063                 mov     esp, ebp
.text$mn:00005065                 pop     ebp
.text$mn:00005066                 retn
.text$mn:00005066 ??1_Generic_error_category@std@@UAE@XZ endp
.text$mn:00005066
.text$mn:00005066 ; ---------------------------------------------------------------------------
.text$mn:00005067                 align 4
.text$mn:00005067 _text$mn        ends
.text$mn:00005067
.text$x:00005068 ; ===========================================================================
.text$x:00005068
.text$x:00005068 ; Segment type: Pure code
.text$x:00005068 ; Segment permissions: Read/Execute
.text$x:00005068 _text$x         segment para public 'CODE' use32
.text$x:00005068                 assume cs:_text$x
.text$x:00005068                 ;org 5068h
.text$x:00005068 ; COMDAT (pick associative to section at 501C)
.text$x:00005068                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00005068
.text$x:00005068 ; =============== S U B R O U T I N E =======================================
.text$x:00005068
.text$x:00005068
.text$x:00005068 __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0 proc near
.text$x:00005068                                         ; DATA XREF: .xdata$x:00009B58o
.text$x:00005068                 mov     ecx, [ebp-10h]  ; this
.text$x:0000506B                 jmp     ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$x:0000506B __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0 endp
.text$x:0000506B
.text$x:00005070
.text$x:00005070 ; =============== S U B R O U T I N E =======================================
.text$x:00005070
.text$x:00005070
.text$x:00005070 __ehhandler$??1_Generic_error_category@std@@UAE@XZ proc near
.text$x:00005070                                         ; DATA XREF: std::_Generic_error_category::~_Generic_error_category(void)+5o
.text$x:00005070
.text$x:00005070 arg_4           = dword ptr  8
.text$x:00005070
.text$x:00005070                 mov     edx, [esp+arg_4]
.text$x:00005074                 lea     eax, [edx+0Ch]
.text$x:00005077                 mov     ecx, [edx-8]
.text$x:0000507A                 xor     ecx, eax
.text$x:0000507C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005081                 mov     eax, offset __ehfuncinfo$??1_Generic_error_category@std@@UAE@XZ
.text$x:00005086                 jmp     ___CxxFrameHandler3
.text$x:00005086 __ehhandler$??1_Generic_error_category@std@@UAE@XZ endp
.text$x:00005086
.text$x:00005086 ; ---------------------------------------------------------------------------
.text$x:0000508B                 align 4
.text$x:0000508B _text$x         ends
.text$x:0000508B
.text$mn:0000508C ; ===========================================================================
.text$mn:0000508C
.text$mn:0000508C ; Segment type: Pure code
.text$mn:0000508C ; Segment permissions: Read/Execute
.text$mn:0000508C _text$mn        segment para public 'CODE' use32
.text$mn:0000508C                 assume cs:_text$mn
.text$mn:0000508C                 ;org 508Ch
.text$mn:0000508C ; COMDAT (pick any)
.text$mn:0000508C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000508C
.text$mn:0000508C ; =============== S U B R O U T I N E =======================================
.text$mn:0000508C
.text$mn:0000508C ; Attributes: bp-based frame
.text$mn:0000508C
.text$mn:0000508C ; _DWORD __thiscall std::_Iostream_error_category::~_Iostream_error_category(std::_Iostream_error_category *__hidden this)
.text$mn:0000508C                 public ??1_Iostream_error_category@std@@UAE@XZ
.text$mn:0000508C ??1_Iostream_error_category@std@@UAE@XZ proc near
.text$mn:0000508C                                         ; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+Ap
.text$mn:0000508C                                         ; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p
.text$mn:0000508C
.text$mn:0000508C var_10          = dword ptr -10h
.text$mn:0000508C var_C           = dword ptr -0Ch
.text$mn:0000508C var_4           = dword ptr -4
.text$mn:0000508C
.text$mn:0000508C                 push    ebp
.text$mn:0000508D                 mov     ebp, esp
.text$mn:0000508F                 push    0FFFFFFFFh
.text$mn:00005091                 push    offset __ehhandler$??1_Iostream_error_category@std@@UAE@XZ
.text$mn:00005096                 mov     eax, large fs:0
.text$mn:0000509C                 push    eax
.text$mn:0000509D                 push    ecx
.text$mn:0000509E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000050A3                 xor     eax, ebp
.text$mn:000050A5                 push    eax
.text$mn:000050A6                 lea     eax, [ebp+var_C]
.text$mn:000050A9                 mov     large fs:0, eax
.text$mn:000050AF                 mov     [ebp+var_10], ecx
.text$mn:000050B2                 mov     [ebp+var_4], 0
.text$mn:000050B9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000050C0                 mov     ecx, [ebp+var_10] ; this
.text$mn:000050C3                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:000050C8                 mov     ecx, [ebp+var_C]
.text$mn:000050CB                 mov     large fs:0, ecx
.text$mn:000050D2                 pop     ecx
.text$mn:000050D3                 mov     esp, ebp
.text$mn:000050D5                 pop     ebp
.text$mn:000050D6                 retn
.text$mn:000050D6 ??1_Iostream_error_category@std@@UAE@XZ endp
.text$mn:000050D6
.text$mn:000050D6 ; ---------------------------------------------------------------------------
.text$mn:000050D7                 align 4
.text$mn:000050D7 _text$mn        ends
.text$mn:000050D7
.text$x:000050D8 ; ===========================================================================
.text$x:000050D8
.text$x:000050D8 ; Segment type: Pure code
.text$x:000050D8 ; Segment permissions: Read/Execute
.text$x:000050D8 _text$x         segment para public 'CODE' use32
.text$x:000050D8                 assume cs:_text$x
.text$x:000050D8                 ;org 50D8h
.text$x:000050D8 ; COMDAT (pick associative to section at 508C)
.text$x:000050D8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000050D8
.text$x:000050D8 ; =============== S U B R O U T I N E =======================================
.text$x:000050D8
.text$x:000050D8
.text$x:000050D8 __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0 proc near
.text$x:000050D8                                         ; DATA XREF: .xdata$x:00009BDCo
.text$x:000050D8                 mov     ecx, [ebp-10h]  ; this
.text$x:000050DB                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:000050DB __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0 endp
.text$x:000050DB
.text$x:000050E0
.text$x:000050E0 ; =============== S U B R O U T I N E =======================================
.text$x:000050E0
.text$x:000050E0
.text$x:000050E0 __ehhandler$??1_Iostream_error_category@std@@UAE@XZ proc near
.text$x:000050E0                                         ; DATA XREF: std::_Iostream_error_category::~_Iostream_error_category(void)+5o
.text$x:000050E0
.text$x:000050E0 arg_4           = dword ptr  8
.text$x:000050E0
.text$x:000050E0                 mov     edx, [esp+arg_4]
.text$x:000050E4                 lea     eax, [edx+0Ch]
.text$x:000050E7                 mov     ecx, [edx-8]
.text$x:000050EA                 xor     ecx, eax
.text$x:000050EC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000050F1                 mov     eax, offset __ehfuncinfo$??1_Iostream_error_category@std@@UAE@XZ
.text$x:000050F6                 jmp     ___CxxFrameHandler3
.text$x:000050F6 __ehhandler$??1_Iostream_error_category@std@@UAE@XZ endp
.text$x:000050F6
.text$x:000050F6 ; ---------------------------------------------------------------------------
.text$x:000050FB                 align 4
.text$x:000050FB _text$x         ends
.text$x:000050FB
.text$mn:000050FC ; ===========================================================================
.text$mn:000050FC
.text$mn:000050FC ; Segment type: Pure code
.text$mn:000050FC ; Segment permissions: Read/Execute
.text$mn:000050FC _text$mn        segment para public 'CODE' use32
.text$mn:000050FC                 assume cs:_text$mn
.text$mn:000050FC                 ;org 50FCh
.text$mn:000050FC ; COMDAT (pick any)
.text$mn:000050FC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000050FC
.text$mn:000050FC ; =============== S U B R O U T I N E =======================================
.text$mn:000050FC
.text$mn:000050FC ; Attributes: bp-based frame
.text$mn:000050FC
.text$mn:000050FC ; _DWORD __thiscall std::_Iterator_base12::~_Iterator_base12(std::_Iterator_base12 *__hidden this)
.text$mn:000050FC                 public ??1_Iterator_base12@std@@QAE@XZ
.text$mn:000050FC ??1_Iterator_base12@std@@QAE@XZ proc near
.text$mn:000050FC                                         ; CODE XREF: __unwindfunclet$??0?$_Iterator012@Ubidirectional_iterator_tag@std@@U?$pair@$$CBHUStyle@@@2@HPBU32@ABU32@U_Iterator_base12@2@@std@@QAE@XZ$0+3j
.text$mn:000050FC                                         ; __unwindfunclet$??0?$_Iterator012@Ubidirectional_iterator_tag@std@@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@2@HPBU32@ABU32@U_Iterator_base12@2@@std@@QAE@XZ$0+3j ...
.text$mn:000050FC
.text$mn:000050FC var_14          = byte ptr -14h
.text$mn:000050FC var_10          = dword ptr -10h
.text$mn:000050FC var_C           = dword ptr -0Ch
.text$mn:000050FC var_4           = dword ptr -4
.text$mn:000050FC
.text$mn:000050FC                 push    ebp
.text$mn:000050FD                 mov     ebp, esp
.text$mn:000050FF                 push    0FFFFFFFFh
.text$mn:00005101                 push    offset __ehhandler$??1_Iterator_base12@std@@QAE@XZ
.text$mn:00005106                 mov     eax, large fs:0
.text$mn:0000510C                 push    eax
.text$mn:0000510D                 sub     esp, 8
.text$mn:00005110                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005115                 xor     eax, ebp
.text$mn:00005117                 push    eax
.text$mn:00005118                 lea     eax, [ebp+var_C]
.text$mn:0000511B                 mov     large fs:0, eax
.text$mn:00005121                 mov     [ebp+var_10], ecx
.text$mn:00005124                 push    3               ; int
.text$mn:00005126                 lea     ecx, [ebp+var_14] ; this
.text$mn:00005129                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:0000512E                 mov     [ebp+var_4], 0
.text$mn:00005135                 mov     ecx, [ebp+var_10] ; this
.text$mn:00005138                 call    ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me(void)
.text$mn:0000513D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005144                 lea     ecx, [ebp+var_14] ; this
.text$mn:00005147                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:0000514C                 mov     ecx, [ebp+var_C]
.text$mn:0000514F                 mov     large fs:0, ecx
.text$mn:00005156                 pop     ecx
.text$mn:00005157                 mov     esp, ebp
.text$mn:00005159                 pop     ebp
.text$mn:0000515A                 retn
.text$mn:0000515A ??1_Iterator_base12@std@@QAE@XZ endp
.text$mn:0000515A
.text$mn:0000515A ; ---------------------------------------------------------------------------
.text$mn:0000515B                 align 4
.text$mn:0000515B _text$mn        ends
.text$mn:0000515B
.text$x:0000515C ; ===========================================================================
.text$x:0000515C
.text$x:0000515C ; Segment type: Pure code
.text$x:0000515C ; Segment permissions: Read/Execute
.text$x:0000515C _text$x         segment para public 'CODE' use32
.text$x:0000515C                 assume cs:_text$x
.text$x:0000515C                 ;org 515Ch
.text$x:0000515C ; COMDAT (pick associative to section at 50FC)
.text$x:0000515C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000515C
.text$x:0000515C ; =============== S U B R O U T I N E =======================================
.text$x:0000515C
.text$x:0000515C
.text$x:0000515C __unwindfunclet$??1_Iterator_base12@std@@QAE@XZ$0 proc near
.text$x:0000515C                                         ; DATA XREF: .xdata$x:0000977Co
.text$x:0000515C                 lea     ecx, [ebp-14h]  ; this
.text$x:0000515F                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:0000515F __unwindfunclet$??1_Iterator_base12@std@@QAE@XZ$0 endp
.text$x:0000515F
.text$x:00005164
.text$x:00005164 ; =============== S U B R O U T I N E =======================================
.text$x:00005164
.text$x:00005164
.text$x:00005164 __ehhandler$??1_Iterator_base12@std@@QAE@XZ proc near
.text$x:00005164                                         ; DATA XREF: std::_Iterator_base12::~_Iterator_base12(void)+5o
.text$x:00005164
.text$x:00005164 arg_4           = dword ptr  8
.text$x:00005164
.text$x:00005164                 mov     edx, [esp+arg_4]
.text$x:00005168                 lea     eax, [edx+0Ch]
.text$x:0000516B                 mov     ecx, [edx-0Ch]
.text$x:0000516E                 xor     ecx, eax
.text$x:00005170                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005175                 mov     eax, offset __ehfuncinfo$??1_Iterator_base12@std@@QAE@XZ
.text$x:0000517A                 jmp     ___CxxFrameHandler3
.text$x:0000517A __ehhandler$??1_Iterator_base12@std@@QAE@XZ endp
.text$x:0000517A
.text$x:0000517A ; ---------------------------------------------------------------------------
.text$x:0000517F                 align 10h
.text$x:0000517F _text$x         ends
.text$x:0000517F
.text$mn:00005180 ; ===========================================================================
.text$mn:00005180
.text$mn:00005180 ; Segment type: Pure code
.text$mn:00005180 ; Segment permissions: Read/Execute
.text$mn:00005180 _text$mn        segment para public 'CODE' use32
.text$mn:00005180                 assume cs:_text$mn
.text$mn:00005180                 ;org 5180h
.text$mn:00005180 ; COMDAT (pick any)
.text$mn:00005180                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005180
.text$mn:00005180 ; =============== S U B R O U T I N E =======================================
.text$mn:00005180
.text$mn:00005180 ; Attributes: bp-based frame
.text$mn:00005180
.text$mn:00005180 ; _DWORD __thiscall std::_System_error_category::~_System_error_category(std::_System_error_category *__hidden this)
.text$mn:00005180                 public ??1_System_error_category@std@@UAE@XZ
.text$mn:00005180 ??1_System_error_category@std@@UAE@XZ proc near
.text$mn:00005180                                         ; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+Ap
.text$mn:00005180                                         ; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p
.text$mn:00005180
.text$mn:00005180 var_10          = dword ptr -10h
.text$mn:00005180 var_C           = dword ptr -0Ch
.text$mn:00005180 var_4           = dword ptr -4
.text$mn:00005180
.text$mn:00005180                 push    ebp
.text$mn:00005181                 mov     ebp, esp
.text$mn:00005183                 push    0FFFFFFFFh
.text$mn:00005185                 push    offset __ehhandler$??1_System_error_category@std@@UAE@XZ
.text$mn:0000518A                 mov     eax, large fs:0
.text$mn:00005190                 push    eax
.text$mn:00005191                 push    ecx
.text$mn:00005192                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005197                 xor     eax, ebp
.text$mn:00005199                 push    eax
.text$mn:0000519A                 lea     eax, [ebp+var_C]
.text$mn:0000519D                 mov     large fs:0, eax
.text$mn:000051A3                 mov     [ebp+var_10], ecx
.text$mn:000051A6                 mov     [ebp+var_4], 0
.text$mn:000051AD                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000051B4                 mov     ecx, [ebp+var_10] ; this
.text$mn:000051B7                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:000051BC                 mov     ecx, [ebp+var_C]
.text$mn:000051BF                 mov     large fs:0, ecx
.text$mn:000051C6                 pop     ecx
.text$mn:000051C7                 mov     esp, ebp
.text$mn:000051C9                 pop     ebp
.text$mn:000051CA                 retn
.text$mn:000051CA ??1_System_error_category@std@@UAE@XZ endp
.text$mn:000051CA
.text$mn:000051CA ; ---------------------------------------------------------------------------
.text$mn:000051CB                 align 4
.text$mn:000051CB _text$mn        ends
.text$mn:000051CB
.text$x:000051CC ; ===========================================================================
.text$x:000051CC
.text$x:000051CC ; Segment type: Pure code
.text$x:000051CC ; Segment permissions: Read/Execute
.text$x:000051CC _text$x         segment para public 'CODE' use32
.text$x:000051CC                 assume cs:_text$x
.text$x:000051CC                 ;org 51CCh
.text$x:000051CC ; COMDAT (pick associative to section at 5180)
.text$x:000051CC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000051CC
.text$x:000051CC ; =============== S U B R O U T I N E =======================================
.text$x:000051CC
.text$x:000051CC
.text$x:000051CC __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0 proc near
.text$x:000051CC                                         ; DATA XREF: .xdata$x:00009C60o
.text$x:000051CC                 mov     ecx, [ebp-10h]  ; this
.text$x:000051CF                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:000051CF __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0 endp
.text$x:000051CF
.text$x:000051D4
.text$x:000051D4 ; =============== S U B R O U T I N E =======================================
.text$x:000051D4
.text$x:000051D4
.text$x:000051D4 __ehhandler$??1_System_error_category@std@@UAE@XZ proc near
.text$x:000051D4                                         ; DATA XREF: std::_System_error_category::~_System_error_category(void)+5o
.text$x:000051D4
.text$x:000051D4 arg_4           = dword ptr  8
.text$x:000051D4
.text$x:000051D4                 mov     edx, [esp+arg_4]
.text$x:000051D8                 lea     eax, [edx+0Ch]
.text$x:000051DB                 mov     ecx, [edx-8]
.text$x:000051DE                 xor     ecx, eax
.text$x:000051E0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000051E5                 mov     eax, offset __ehfuncinfo$??1_System_error_category@std@@UAE@XZ
.text$x:000051EA                 jmp     ___CxxFrameHandler3
.text$x:000051EA __ehhandler$??1_System_error_category@std@@UAE@XZ endp
.text$x:000051EA
.text$x:000051EA ; ---------------------------------------------------------------------------
.text$x:000051EF                 align 10h
.text$x:000051EF _text$x         ends
.text$x:000051EF
.text$mn:000051F0 ; ===========================================================================
.text$mn:000051F0
.text$mn:000051F0 ; Segment type: Pure code
.text$mn:000051F0 ; Segment permissions: Read/Execute
.text$mn:000051F0 _text$mn        segment para public 'CODE' use32
.text$mn:000051F0                 assume cs:_text$mn
.text$mn:000051F0                 ;org 51F0h
.text$mn:000051F0 ; COMDAT (pick any)
.text$mn:000051F0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000051F0
.text$mn:000051F0 ; =============== S U B R O U T I N E =======================================
.text$mn:000051F0
.text$mn:000051F0 ; Attributes: bp-based frame
.text$mn:000051F0
.text$mn:000051F0 ; _DWORD __thiscall std::error_category::~error_category(std::error_category *__hidden this)
.text$mn:000051F0                 public ??1error_category@std@@UAE@XZ
.text$mn:000051F0 ??1error_category@std@@UAE@XZ proc near ; CODE XREF: __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0+3j
.text$mn:000051F0                                         ; std::_Generic_error_category::~_Generic_error_category(void)+37p ...
.text$mn:000051F0
.text$mn:000051F0 var_4           = dword ptr -4
.text$mn:000051F0
.text$mn:000051F0                 push    ebp
.text$mn:000051F1                 mov     ebp, esp
.text$mn:000051F3                 push    ecx
.text$mn:000051F4                 mov     [ebp+var_4], ecx
.text$mn:000051F7                 mov     eax, [ebp+var_4]
.text$mn:000051FA                 mov     dword ptr [eax], offset ??_7error_category@std@@6B@ ; const std::error_category::`vftable'
.text$mn:00005200                 mov     esp, ebp
.text$mn:00005202                 pop     ebp
.text$mn:00005203                 retn
.text$mn:00005203 ??1error_category@std@@UAE@XZ endp
.text$mn:00005203
.text$mn:00005203 _text$mn        ends
.text$mn:00005203
.text$mn:00005204 ; ===========================================================================
.text$mn:00005204
.text$mn:00005204 ; Segment type: Pure code
.text$mn:00005204 ; Segment permissions: Read/Execute
.text$mn:00005204 _text$mn        segment para public 'CODE' use32
.text$mn:00005204                 assume cs:_text$mn
.text$mn:00005204                 ;org 5204h
.text$mn:00005204 ; COMDAT (pick any)
.text$mn:00005204                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005204
.text$mn:00005204 ; =============== S U B R O U T I N E =======================================
.text$mn:00005204
.text$mn:00005204 ; Attributes: bp-based frame
.text$mn:00005204
.text$mn:00005204 ; void *__cdecl operator new(unsigned int, void *)
.text$mn:00005204                 public ??2@YAPAXIPAX@Z
.text$mn:00005204 ??2@YAPAXIPAX@Z proc near               ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+2Ep
.text$mn:00005204                                         ; std::allocator<std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *>>::construct<std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *,std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> * &>(std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> * *,std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> * &)+2Ep ...
.text$mn:00005204
.text$mn:00005204 arg_4           = dword ptr  0Ch
.text$mn:00005204
.text$mn:00005204                 push    ebp
.text$mn:00005205                 mov     ebp, esp
.text$mn:00005207                 mov     eax, [ebp+arg_4]
.text$mn:0000520A                 pop     ebp
.text$mn:0000520B                 retn
.text$mn:0000520B ??2@YAPAXIPAX@Z endp
.text$mn:0000520B
.text$mn:0000520B _text$mn        ends
.text$mn:0000520B
.text$mn:0000520C ; ===========================================================================
.text$mn:0000520C
.text$mn:0000520C ; Segment type: Pure code
.text$mn:0000520C ; Segment permissions: Read/Execute
.text$mn:0000520C _text$mn        segment para public 'CODE' use32
.text$mn:0000520C                 assume cs:_text$mn
.text$mn:0000520C                 ;org 520Ch
.text$mn:0000520C ; COMDAT (pick any)
.text$mn:0000520C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000520C
.text$mn:0000520C ; =============== S U B R O U T I N E =======================================
.text$mn:0000520C
.text$mn:0000520C ; Attributes: bp-based frame
.text$mn:0000520C
.text$mn:0000520C ; void __cdecl operator delete(void *)
.text$mn:0000520C                 public ??3@YAXPAX0@Z
.text$mn:0000520C ??3@YAXPAX0@Z   proc near               ; CODE XREF: __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0+8p
.text$mn:0000520C                                         ; __unwindfunclet$??$construct@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@AAPAU12@@?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@QAEXPAPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@1@AAPAU21@@Z$0+8p ...
.text$mn:0000520C                 push    ebp
.text$mn:0000520D                 mov     ebp, esp
.text$mn:0000520F                 pop     ebp
.text$mn:00005210                 retn
.text$mn:00005210 ??3@YAXPAX0@Z   endp
.text$mn:00005210
.text$mn:00005210 ; ---------------------------------------------------------------------------
.text$mn:00005211                 align 4
.text$mn:00005211 _text$mn        ends
.text$mn:00005211
.text$mn:00005214 ; ===========================================================================
.text$mn:00005214
.text$mn:00005214 ; Segment type: Pure code
.text$mn:00005214 ; Segment permissions: Read/Execute
.text$mn:00005214 _text$mn        segment para public 'CODE' use32
.text$mn:00005214                 assume cs:_text$mn
.text$mn:00005214                 ;org 5214h
.text$mn:00005214 ; COMDAT (pick any)
.text$mn:00005214                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005214
.text$mn:00005214 ; =============== S U B R O U T I N E =======================================
.text$mn:00005214
.text$mn:00005214 ; Attributes: bp-based frame
.text$mn:00005214
.text$mn:00005214 ; public: struct std::_Iterator_base12 & __thiscall std::_Iterator_base12::operator=(struct std::_Iterator_base12 const &)
.text$mn:00005214                 public ??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z
.text$mn:00005214 ??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z proc near
.text$mn:00005214                                         ; CODE XREF: std::_Iterator_base12::_Iterator_base12(std::_Iterator_base12 const &)+21p
.text$mn:00005214
.text$mn:00005214 var_14          = byte ptr -14h
.text$mn:00005214 var_10          = dword ptr -10h
.text$mn:00005214 var_C           = dword ptr -0Ch
.text$mn:00005214 var_4           = dword ptr -4
.text$mn:00005214 arg_0           = dword ptr  8
.text$mn:00005214
.text$mn:00005214                 push    ebp
.text$mn:00005215                 mov     ebp, esp
.text$mn:00005217                 push    0FFFFFFFFh
.text$mn:00005219                 push    offset __ehhandler$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z
.text$mn:0000521E                 mov     eax, large fs:0
.text$mn:00005224                 push    eax
.text$mn:00005225                 sub     esp, 8
.text$mn:00005228                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000522D                 xor     eax, ebp
.text$mn:0000522F                 push    eax
.text$mn:00005230                 lea     eax, [ebp+var_C]
.text$mn:00005233                 mov     large fs:0, eax
.text$mn:00005239                 mov     [ebp+var_10], ecx
.text$mn:0000523C                 mov     eax, [ebp+var_10]
.text$mn:0000523F                 mov     ecx, [ebp+arg_0]
.text$mn:00005242                 mov     edx, [eax]
.text$mn:00005244                 cmp     edx, [ecx]
.text$mn:00005246                 jnz     short loc_524A
.text$mn:00005248                 jmp     short loc_528C
.text$mn:0000524A ; ---------------------------------------------------------------------------
.text$mn:0000524A
.text$mn:0000524A loc_524A:                               ; CODE XREF: std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+32j
.text$mn:0000524A                 mov     eax, [ebp+arg_0]
.text$mn:0000524D                 cmp     dword ptr [eax], 0
.text$mn:00005250                 jz      short loc_5264
.text$mn:00005252                 mov     ecx, [ebp+arg_0]
.text$mn:00005255                 mov     edx, [ecx]
.text$mn:00005257                 mov     eax, [edx]
.text$mn:00005259                 push    eax             ; struct std::_Container_base12 *
.text$mn:0000525A                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000525D                 call    ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt(std::_Container_base12 const *)
.text$mn:00005262                 jmp     short loc_528C
.text$mn:00005264 ; ---------------------------------------------------------------------------
.text$mn:00005264
.text$mn:00005264 loc_5264:                               ; CODE XREF: std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+3Cj
.text$mn:00005264                 push    3               ; int
.text$mn:00005266                 lea     ecx, [ebp+var_14] ; this
.text$mn:00005269                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:0000526E                 mov     [ebp+var_4], 0
.text$mn:00005275                 mov     ecx, [ebp+var_10] ; this
.text$mn:00005278                 call    ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me(void)
.text$mn:0000527D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005284                 lea     ecx, [ebp+var_14] ; this
.text$mn:00005287                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:0000528C
.text$mn:0000528C loc_528C:                               ; CODE XREF: std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+34j
.text$mn:0000528C                                         ; std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+4Ej
.text$mn:0000528C                 mov     eax, [ebp+var_10]
.text$mn:0000528F                 mov     ecx, [ebp+var_C]
.text$mn:00005292                 mov     large fs:0, ecx
.text$mn:00005299                 pop     ecx
.text$mn:0000529A                 mov     esp, ebp
.text$mn:0000529C                 pop     ebp
.text$mn:0000529D                 retn    4
.text$mn:0000529D ??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z endp
.text$mn:0000529D
.text$mn:0000529D _text$mn        ends
.text$mn:0000529D
.text$x:000052A0 ; ===========================================================================
.text$x:000052A0
.text$x:000052A0 ; Segment type: Pure code
.text$x:000052A0 ; Segment permissions: Read/Execute
.text$x:000052A0 _text$x         segment para public 'CODE' use32
.text$x:000052A0                 assume cs:_text$x
.text$x:000052A0                 ;org 52A0h
.text$x:000052A0 ; COMDAT (pick associative to section at 5214)
.text$x:000052A0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000052A0
.text$x:000052A0 ; =============== S U B R O U T I N E =======================================
.text$x:000052A0
.text$x:000052A0
.text$x:000052A0 __unwindfunclet$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z$0 proc near
.text$x:000052A0                                         ; DATA XREF: .xdata$x:00009750o
.text$x:000052A0                 lea     ecx, [ebp-14h]  ; this
.text$x:000052A3                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:000052A3 __unwindfunclet$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z$0 endp
.text$x:000052A3
.text$x:000052A8
.text$x:000052A8 ; =============== S U B R O U T I N E =======================================
.text$x:000052A8
.text$x:000052A8
.text$x:000052A8 __ehhandler$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z proc near
.text$x:000052A8                                         ; DATA XREF: std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+5o
.text$x:000052A8
.text$x:000052A8 arg_4           = dword ptr  8
.text$x:000052A8
.text$x:000052A8                 mov     edx, [esp+arg_4]
.text$x:000052AC                 lea     eax, [edx+0Ch]
.text$x:000052AF                 mov     ecx, [edx-0Ch]
.text$x:000052B2                 xor     ecx, eax
.text$x:000052B4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000052B9                 mov     eax, offset __ehfuncinfo$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z
.text$x:000052BE                 jmp     ___CxxFrameHandler3
.text$x:000052BE __ehhandler$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z endp
.text$x:000052BE
.text$x:000052BE ; ---------------------------------------------------------------------------
.text$x:000052C3                 align 4
.text$x:000052C3 _text$x         ends
.text$x:000052C3
.text$mn:000052C4 ; ===========================================================================
.text$mn:000052C4
.text$mn:000052C4 ; Segment type: Pure code
.text$mn:000052C4 ; Segment permissions: Read/Execute
.text$mn:000052C4 _text$mn        segment para public 'CODE' use32
.text$mn:000052C4                 assume cs:_text$mn
.text$mn:000052C4                 ;org 52C4h
.text$mn:000052C4 ; COMDAT (pick any)
.text$mn:000052C4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000052C4
.text$mn:000052C4 ; =============== S U B R O U T I N E =======================================
.text$mn:000052C4
.text$mn:000052C4 ; Attributes: bp-based frame
.text$mn:000052C4
.text$mn:000052C4 ; int __stdcall std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>::operator==(std::_Iterator_base12 *)
.text$mn:000052C4                 public ??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z
.text$mn:000052C4 ??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z proc near
.text$mn:000052C4                                         ; CODE XREF: std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>::operator!=(std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>> const &)+10p
.text$mn:000052C4
.text$mn:000052C4 var_8           = dword ptr -8
.text$mn:000052C4 var_4           = dword ptr -4
.text$mn:000052C4 arg_0           = dword ptr  8
.text$mn:000052C4
.text$mn:000052C4                 push    ebp
.text$mn:000052C5                 mov     ebp, esp
.text$mn:000052C7                 sub     esp, 8
.text$mn:000052CA                 push    esi
.text$mn:000052CB                 mov     [ebp+var_4], ecx
.text$mn:000052CE                 mov     ecx, [ebp+var_4] ; this
.text$mn:000052D1                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:000052D6                 test    eax, eax
.text$mn:000052D8                 jz      short loc_52F0
.text$mn:000052DA                 mov     ecx, [ebp+var_4] ; this
.text$mn:000052DD                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:000052E2                 mov     esi, eax
.text$mn:000052E4                 mov     ecx, [ebp+arg_0] ; this
.text$mn:000052E7                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:000052EC                 cmp     esi, eax
.text$mn:000052EE                 jz      short loc_5358
.text$mn:000052F0
.text$mn:000052F0 loc_52F0:                               ; CODE XREF: std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>::operator==(std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>> const &)+14j
.text$mn:000052F0                 push    121h            ; unsigned int
.text$mn:000052F5                 push    offset ??_C@_1II@KCNBAEMF@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000052FA                 push    offset ??_C@_1DI@MDELDGPI@?$AAl?$AAi?$AAs?$AAt?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AAs?$AA?5?$AAi?$AAn?$AAc?$AAo?$AAm?$AAp?$AAa?$AAt?$AAi?$AAb?$AAl?$AAe?$AA?$AA@ ; "list iterators incompatible"
.text$mn:000052FF                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00005304                 add     esp, 0Ch
.text$mn:00005307                 mov     eax, offset ??_C@_0CI@FNPHFCCM@Standard?5C?$CL?$CL?5Libraries?5Invalid?5A@ ; "Standard C++ Libraries Invalid Argument"
.text$mn:0000530C                 test    eax, eax
.text$mn:0000530E                 jz      short loc_5314
.text$mn:00005310                 xor     ecx, ecx
.text$mn:00005312                 jnz     short loc_533A
.text$mn:00005314
.text$mn:00005314 loc_5314:                               ; CODE XREF: std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>::operator==(std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>> const &)+4Aj
.text$mn:00005314                 push    offset ??_C@_1FO@GJIHNDLM@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5@ ; "\"Standard C++ Libraries Invalid Argume"...
.text$mn:00005319                 push    offset ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ ; "%s"
.text$mn:0000531E                 push    0
.text$mn:00005320                 push    122h
.text$mn:00005325                 push    offset ??_C@_1II@KCNBAEMF@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000532A                 push    2
.text$mn:0000532C                 call    __CrtDbgReportW
.text$mn:00005331                 add     esp, 18h
.text$mn:00005334                 cmp     eax, 1
.text$mn:00005337                 jnz     short loc_533A
.text$mn:00005339                 int     3               ; Trap to Debugger
.text$mn:0000533A
.text$mn:0000533A loc_533A:                               ; CODE XREF: std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>::operator==(std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>> const &)+4Ej
.text$mn:0000533A                                         ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>::operator==(std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>> const &)+73j
.text$mn:0000533A                 push    0
.text$mn:0000533C                 push    122h
.text$mn:00005341                 push    offset ??_C@_1II@KCNBAEMF@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00005346                 push    offset ??_C@_1BBG@MEFLKALA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAL?$AAi?$AAs?$AAt?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5@ ; "std::_List_const_iterator<class std::_L"...
.text$mn:0000534B                 push    offset ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@ ; "\"invalid argument\""
.text$mn:00005350                 call    __invalid_parameter
.text$mn:00005355                 add     esp, 14h
.text$mn:00005358
.text$mn:00005358 loc_5358:                               ; CODE XREF: std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>::operator==(std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>> const &)+2Aj
.text$mn:00005358                 mov     eax, [ebp+var_4]
.text$mn:0000535B                 mov     ecx, [ebp+arg_0]
.text$mn:0000535E                 mov     edx, [eax+8]
.text$mn:00005361                 cmp     edx, [ecx+8]
.text$mn:00005364                 jnz     short loc_536F
.text$mn:00005366                 mov     [ebp+var_8], 1
.text$mn:0000536D                 jmp     short loc_5376
.text$mn:0000536F ; ---------------------------------------------------------------------------
.text$mn:0000536F
.text$mn:0000536F loc_536F:                               ; CODE XREF: std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>::operator==(std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>> const &)+A0j
.text$mn:0000536F                 mov     [ebp+var_8], 0
.text$mn:00005376
.text$mn:00005376 loc_5376:                               ; CODE XREF: std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>::operator==(std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>> const &)+A9j
.text$mn:00005376                 mov     al, byte ptr [ebp+var_8]
.text$mn:00005379                 pop     esi
.text$mn:0000537A                 mov     esp, ebp
.text$mn:0000537C                 pop     ebp
.text$mn:0000537D                 retn    4
.text$mn:0000537D ??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z endp
.text$mn:0000537D
.text$mn:0000537D _text$mn        ends
.text$mn:0000537D
.text$mn:00005380 ; ===========================================================================
.text$mn:00005380
.text$mn:00005380 ; Segment type: Pure code
.text$mn:00005380 ; Segment permissions: Read/Execute
.text$mn:00005380 _text$mn        segment para public 'CODE' use32
.text$mn:00005380                 assume cs:_text$mn
.text$mn:00005380                 ;org 5380h
.text$mn:00005380 ; COMDAT (pick any)
.text$mn:00005380                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005380
.text$mn:00005380 ; =============== S U B R O U T I N E =======================================
.text$mn:00005380
.text$mn:00005380 ; Attributes: bp-based frame
.text$mn:00005380
.text$mn:00005380 ; int __stdcall std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::operator==(std::_Iterator_base12 *)
.text$mn:00005380                 public ??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z
.text$mn:00005380 ??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z proc near
.text$mn:00005380                                         ; CODE XREF: std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::operator!=(std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const &)+10p
.text$mn:00005380
.text$mn:00005380 var_8           = dword ptr -8
.text$mn:00005380 var_4           = dword ptr -4
.text$mn:00005380 arg_0           = dword ptr  8
.text$mn:00005380
.text$mn:00005380                 push    ebp
.text$mn:00005381                 mov     ebp, esp
.text$mn:00005383                 sub     esp, 8
.text$mn:00005386                 push    esi
.text$mn:00005387                 mov     [ebp+var_4], ecx
.text$mn:0000538A                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000538D                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:00005392                 test    eax, eax
.text$mn:00005394                 jz      short loc_53AC
.text$mn:00005396                 mov     ecx, [ebp+var_4] ; this
.text$mn:00005399                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:0000539E                 mov     esi, eax
.text$mn:000053A0                 mov     ecx, [ebp+arg_0] ; this
.text$mn:000053A3                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:000053A8                 cmp     esi, eax
.text$mn:000053AA                 jz      short loc_5414
.text$mn:000053AC
.text$mn:000053AC loc_53AC:                               ; CODE XREF: std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::operator==(std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const &)+14j
.text$mn:000053AC                 push    121h            ; unsigned int
.text$mn:000053B1                 push    offset ??_C@_1II@KCNBAEMF@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000053B6                 push    offset ??_C@_1DI@MDELDGPI@?$AAl?$AAi?$AAs?$AAt?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AAs?$AA?5?$AAi?$AAn?$AAc?$AAo?$AAm?$AAp?$AAa?$AAt?$AAi?$AAb?$AAl?$AAe?$AA?$AA@ ; "list iterators incompatible"
.text$mn:000053BB                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:000053C0                 add     esp, 0Ch
.text$mn:000053C3                 mov     eax, offset ??_C@_0CI@FNPHFCCM@Standard?5C?$CL?$CL?5Libraries?5Invalid?5A@ ; "Standard C++ Libraries Invalid Argument"
.text$mn:000053C8                 test    eax, eax
.text$mn:000053CA                 jz      short loc_53D0
.text$mn:000053CC                 xor     ecx, ecx
.text$mn:000053CE                 jnz     short loc_53F6
.text$mn:000053D0
.text$mn:000053D0 loc_53D0:                               ; CODE XREF: std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::operator==(std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const &)+4Aj
.text$mn:000053D0                 push    offset ??_C@_1FO@GJIHNDLM@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5@ ; "\"Standard C++ Libraries Invalid Argume"...
.text$mn:000053D5                 push    offset ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ ; "%s"
.text$mn:000053DA                 push    0
.text$mn:000053DC                 push    122h
.text$mn:000053E1                 push    offset ??_C@_1II@KCNBAEMF@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000053E6                 push    2
.text$mn:000053E8                 call    __CrtDbgReportW
.text$mn:000053ED                 add     esp, 18h
.text$mn:000053F0                 cmp     eax, 1
.text$mn:000053F3                 jnz     short loc_53F6
.text$mn:000053F5                 int     3               ; Trap to Debugger
.text$mn:000053F6
.text$mn:000053F6 loc_53F6:                               ; CODE XREF: std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::operator==(std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const &)+4Ej
.text$mn:000053F6                                         ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::operator==(std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const &)+73j
.text$mn:000053F6                 push    0
.text$mn:000053F8                 push    122h
.text$mn:000053FD                 push    offset ??_C@_1II@KCNBAEMF@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00005402                 push    offset ??_C@_1CEO@DJCOBHAB@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAL?$AAi?$AAs?$AAt?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5@ ; "std::_List_const_iterator<class std::_L"...
.text$mn:00005407                 push    offset ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@ ; "\"invalid argument\""
.text$mn:0000540C                 call    __invalid_parameter
.text$mn:00005411                 add     esp, 14h
.text$mn:00005414
.text$mn:00005414 loc_5414:                               ; CODE XREF: std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::operator==(std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const &)+2Aj
.text$mn:00005414                 mov     eax, [ebp+var_4]
.text$mn:00005417                 mov     ecx, [ebp+arg_0]
.text$mn:0000541A                 mov     edx, [eax+8]
.text$mn:0000541D                 cmp     edx, [ecx+8]
.text$mn:00005420                 jnz     short loc_542B
.text$mn:00005422                 mov     [ebp+var_8], 1
.text$mn:00005429                 jmp     short loc_5432
.text$mn:0000542B ; ---------------------------------------------------------------------------
.text$mn:0000542B
.text$mn:0000542B loc_542B:                               ; CODE XREF: std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::operator==(std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const &)+A0j
.text$mn:0000542B                 mov     [ebp+var_8], 0
.text$mn:00005432
.text$mn:00005432 loc_5432:                               ; CODE XREF: std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::operator==(std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const &)+A9j
.text$mn:00005432                 mov     al, byte ptr [ebp+var_8]
.text$mn:00005435                 pop     esi
.text$mn:00005436                 mov     esp, ebp
.text$mn:00005438                 pop     ebp
.text$mn:00005439                 retn    4
.text$mn:00005439 ??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z endp
.text$mn:00005439
.text$mn:00005439 _text$mn        ends
.text$mn:00005439
.text$mn:0000543C ; ===========================================================================
.text$mn:0000543C
.text$mn:0000543C ; Segment type: Pure code
.text$mn:0000543C ; Segment permissions: Read/Execute
.text$mn:0000543C _text$mn        segment para public 'CODE' use32
.text$mn:0000543C                 assume cs:_text$mn
.text$mn:0000543C                 ;org 543Ch
.text$mn:0000543C ; COMDAT (pick any)
.text$mn:0000543C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000543C
.text$mn:0000543C ; =============== S U B R O U T I N E =======================================
.text$mn:0000543C
.text$mn:0000543C ; Attributes: bp-based frame
.text$mn:0000543C
.text$mn:0000543C ; public: bool __thiscall std::error_category::operator==(class std::error_category const &)const
.text$mn:0000543C                 public ??8error_category@std@@QBE_NABV01@@Z
.text$mn:0000543C ??8error_category@std@@QBE_NABV01@@Z proc near
.text$mn:0000543C                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+1Dp
.text$mn:0000543C                                         ; std::error_category::equivalent(std::error_code const &,int)+15p
.text$mn:0000543C
.text$mn:0000543C var_8           = dword ptr -8
.text$mn:0000543C var_4           = dword ptr -4
.text$mn:0000543C arg_0           = dword ptr  8
.text$mn:0000543C
.text$mn:0000543C                 push    ebp
.text$mn:0000543D                 mov     ebp, esp
.text$mn:0000543F                 sub     esp, 8
.text$mn:00005442                 mov     [ebp+var_8], ecx
.text$mn:00005445                 mov     eax, [ebp+var_8]
.text$mn:00005448                 cmp     eax, [ebp+arg_0]
.text$mn:0000544B                 jnz     short loc_5456
.text$mn:0000544D                 mov     [ebp+var_4], 1
.text$mn:00005454                 jmp     short loc_545D
.text$mn:00005456 ; ---------------------------------------------------------------------------
.text$mn:00005456
.text$mn:00005456 loc_5456:                               ; CODE XREF: std::error_category::operator==(std::error_category const &)+Fj
.text$mn:00005456                 mov     [ebp+var_4], 0
.text$mn:0000545D
.text$mn:0000545D loc_545D:                               ; CODE XREF: std::error_category::operator==(std::error_category const &)+18j
.text$mn:0000545D                 mov     al, byte ptr [ebp+var_4]
.text$mn:00005460                 mov     esp, ebp
.text$mn:00005462                 pop     ebp
.text$mn:00005463                 retn    4
.text$mn:00005463 ??8error_category@std@@QBE_NABV01@@Z endp
.text$mn:00005463
.text$mn:00005463 ; ---------------------------------------------------------------------------
.text$mn:00005466                 align 4
.text$mn:00005466 _text$mn        ends
.text$mn:00005466
.text$mn:00005468 ; ===========================================================================
.text$mn:00005468
.text$mn:00005468 ; Segment type: Pure code
.text$mn:00005468 ; Segment permissions: Read/Execute
.text$mn:00005468 _text$mn        segment para public 'CODE' use32
.text$mn:00005468                 assume cs:_text$mn
.text$mn:00005468                 ;org 5468h
.text$mn:00005468 ; COMDAT (pick any)
.text$mn:00005468                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005468
.text$mn:00005468 ; =============== S U B R O U T I N E =======================================
.text$mn:00005468
.text$mn:00005468 ; Attributes: bp-based frame
.text$mn:00005468
.text$mn:00005468 ; int __stdcall std::error_condition::operator==(std::error_condition *)
.text$mn:00005468                 public ??8error_condition@std@@QBE_NABV01@@Z
.text$mn:00005468 ??8error_condition@std@@QBE_NABV01@@Z proc near
.text$mn:00005468                                         ; CODE XREF: std::error_category::equivalent(int,std::error_condition const &)+24p
.text$mn:00005468
.text$mn:00005468 var_8           = dword ptr -8
.text$mn:00005468 var_4           = dword ptr -4
.text$mn:00005468 arg_0           = dword ptr  8
.text$mn:00005468
.text$mn:00005468                 push    ebp
.text$mn:00005469                 mov     ebp, esp
.text$mn:0000546B                 sub     esp, 8
.text$mn:0000546E                 push    esi
.text$mn:0000546F                 mov     [ebp+var_4], ecx
.text$mn:00005472                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00005475                 call    ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
.text$mn:0000547A                 push    eax
.text$mn:0000547B                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000547E                 call    ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
.text$mn:00005483                 mov     ecx, eax
.text$mn:00005485                 call    ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
.text$mn:0000548A                 movzx   eax, al
.text$mn:0000548D                 test    eax, eax
.text$mn:0000548F                 jz      short loc_54B0
.text$mn:00005491                 mov     ecx, [ebp+var_4] ; this
.text$mn:00005494                 call    ?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
.text$mn:00005499                 mov     esi, eax
.text$mn:0000549B                 mov     ecx, [ebp+arg_0] ; this
.text$mn:0000549E                 call    ?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
.text$mn:000054A3                 cmp     esi, eax
.text$mn:000054A5                 jnz     short loc_54B0
.text$mn:000054A7                 mov     [ebp+var_8], 1
.text$mn:000054AE                 jmp     short loc_54B7
.text$mn:000054B0 ; ---------------------------------------------------------------------------
.text$mn:000054B0
.text$mn:000054B0 loc_54B0:                               ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+27j
.text$mn:000054B0                                         ; std::error_condition::operator==(std::error_condition const &)+3Dj
.text$mn:000054B0                 mov     [ebp+var_8], 0
.text$mn:000054B7
.text$mn:000054B7 loc_54B7:                               ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+46j
.text$mn:000054B7                 mov     al, byte ptr [ebp+var_8]
.text$mn:000054BA                 pop     esi
.text$mn:000054BB                 mov     esp, ebp
.text$mn:000054BD                 pop     ebp
.text$mn:000054BE                 retn    4
.text$mn:000054BE ??8error_condition@std@@QBE_NABV01@@Z endp
.text$mn:000054BE
.text$mn:000054BE ; ---------------------------------------------------------------------------
.text$mn:000054C1                 align 4
.text$mn:000054C1 _text$mn        ends
.text$mn:000054C1
.text$mn:000054C4 ; ===========================================================================
.text$mn:000054C4
.text$mn:000054C4 ; Segment type: Pure code
.text$mn:000054C4 ; Segment permissions: Read/Execute
.text$mn:000054C4 _text$mn        segment para public 'CODE' use32
.text$mn:000054C4                 assume cs:_text$mn
.text$mn:000054C4                 ;org 54C4h
.text$mn:000054C4 ; COMDAT (pick any)
.text$mn:000054C4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000054C4
.text$mn:000054C4 ; =============== S U B R O U T I N E =======================================
.text$mn:000054C4
.text$mn:000054C4 ; Attributes: bp-based frame
.text$mn:000054C4
.text$mn:000054C4 ; int __stdcall std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>::operator!=(std::_Iterator_base12 *)
.text$mn:000054C4                 public ??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z
.text$mn:000054C4 ??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z proc near
.text$mn:000054C4                                         ; CODE XREF: ScintillaEditView::~ScintillaEditView(void)+111p
.text$mn:000054C4
.text$mn:000054C4 var_8           = dword ptr -8
.text$mn:000054C4 var_4           = dword ptr -4
.text$mn:000054C4 arg_0           = dword ptr  8
.text$mn:000054C4
.text$mn:000054C4                 push    ebp
.text$mn:000054C5                 mov     ebp, esp
.text$mn:000054C7                 sub     esp, 8
.text$mn:000054CA                 mov     [ebp+var_8], ecx
.text$mn:000054CD                 mov     eax, [ebp+arg_0]
.text$mn:000054D0                 push    eax             ; std::_Iterator_base12 *
.text$mn:000054D1                 mov     ecx, [ebp+var_8]
.text$mn:000054D4                 call    ??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>::operator==(std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>> const &)
.text$mn:000054D9                 movzx   ecx, al
.text$mn:000054DC                 test    ecx, ecx
.text$mn:000054DE                 jnz     short loc_54E9
.text$mn:000054E0                 mov     [ebp+var_4], 1
.text$mn:000054E7                 jmp     short loc_54F0
.text$mn:000054E9 ; ---------------------------------------------------------------------------
.text$mn:000054E9
.text$mn:000054E9 loc_54E9:                               ; CODE XREF: std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>::operator!=(std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>> const &)+1Aj
.text$mn:000054E9                 mov     [ebp+var_4], 0
.text$mn:000054F0
.text$mn:000054F0 loc_54F0:                               ; CODE XREF: std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>::operator!=(std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>> const &)+23j
.text$mn:000054F0                 mov     al, byte ptr [ebp+var_4]
.text$mn:000054F3                 mov     esp, ebp
.text$mn:000054F5                 pop     ebp
.text$mn:000054F6                 retn    4
.text$mn:000054F6 ??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z endp
.text$mn:000054F6
.text$mn:000054F6 ; ---------------------------------------------------------------------------
.text$mn:000054F9                 align 4
.text$mn:000054F9 _text$mn        ends
.text$mn:000054F9
.text$mn:000054FC ; ===========================================================================
.text$mn:000054FC
.text$mn:000054FC ; Segment type: Pure code
.text$mn:000054FC ; Segment permissions: Read/Execute
.text$mn:000054FC _text$mn        segment para public 'CODE' use32
.text$mn:000054FC                 assume cs:_text$mn
.text$mn:000054FC                 ;org 54FCh
.text$mn:000054FC ; COMDAT (pick any)
.text$mn:000054FC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000054FC
.text$mn:000054FC ; =============== S U B R O U T I N E =======================================
.text$mn:000054FC
.text$mn:000054FC ; Attributes: bp-based frame
.text$mn:000054FC
.text$mn:000054FC ; int __stdcall std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::operator!=(std::_Iterator_base12 *)
.text$mn:000054FC                 public ??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z
.text$mn:000054FC ??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z proc near
.text$mn:000054FC                                         ; CODE XREF: ScintillaEditView::~ScintillaEditView(void)+A7p
.text$mn:000054FC
.text$mn:000054FC var_8           = dword ptr -8
.text$mn:000054FC var_4           = dword ptr -4
.text$mn:000054FC arg_0           = dword ptr  8
.text$mn:000054FC
.text$mn:000054FC                 push    ebp
.text$mn:000054FD                 mov     ebp, esp
.text$mn:000054FF                 sub     esp, 8
.text$mn:00005502                 mov     [ebp+var_8], ecx
.text$mn:00005505                 mov     eax, [ebp+arg_0]
.text$mn:00005508                 push    eax             ; std::_Iterator_base12 *
.text$mn:00005509                 mov     ecx, [ebp+var_8]
.text$mn:0000550C                 call    ??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::operator==(std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const &)
.text$mn:00005511                 movzx   ecx, al
.text$mn:00005514                 test    ecx, ecx
.text$mn:00005516                 jnz     short loc_5521
.text$mn:00005518                 mov     [ebp+var_4], 1
.text$mn:0000551F                 jmp     short loc_5528
.text$mn:00005521 ; ---------------------------------------------------------------------------
.text$mn:00005521
.text$mn:00005521 loc_5521:                               ; CODE XREF: std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::operator!=(std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const &)+1Aj
.text$mn:00005521                 mov     [ebp+var_4], 0
.text$mn:00005528
.text$mn:00005528 loc_5528:                               ; CODE XREF: std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::operator!=(std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const &)+23j
.text$mn:00005528                 mov     al, byte ptr [ebp+var_4]
.text$mn:0000552B                 mov     esp, ebp
.text$mn:0000552D                 pop     ebp
.text$mn:0000552E                 retn    4
.text$mn:0000552E ??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z endp
.text$mn:0000552E
.text$mn:0000552E ; ---------------------------------------------------------------------------
.text$mn:00005531                 align 4
.text$mn:00005531 _text$mn        ends
.text$mn:00005531
.text$mn:00005534 ; ===========================================================================
.text$mn:00005534
.text$mn:00005534 ; Segment type: Pure code
.text$mn:00005534 ; Segment permissions: Read/Execute
.text$mn:00005534 _text$mn        segment para public 'CODE' use32
.text$mn:00005534                 assume cs:_text$mn
.text$mn:00005534                 ;org 5534h
.text$mn:00005534 ; COMDAT (pick any)
.text$mn:00005534                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005534
.text$mn:00005534 ; =============== S U B R O U T I N E =======================================
.text$mn:00005534
.text$mn:00005534 ; Attributes: bp-based frame
.text$mn:00005534
.text$mn:00005534 ; public: class ScintillaEditView * & __thiscall std::vector<class ScintillaEditView *, class std::allocator<class ScintillaEditView *>>::operator[](unsigned int)
.text$mn:00005534                 public ??A?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@QAEAAPAVScintillaEditView@@I@Z
.text$mn:00005534 ??A?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@QAEAAPAVScintillaEditView@@I@Z proc near
.text$mn:00005534                                         ; CODE XREF: ScintillaCtrls::getScintillaEditViewFrom(HWND__ *)+36p
.text$mn:00005534                                         ; ScintillaCtrls::destroyScintilla(HWND__ *)+4Bp ...
.text$mn:00005534
.text$mn:00005534 var_4           = dword ptr -4
.text$mn:00005534 arg_0           = dword ptr  8
.text$mn:00005534
.text$mn:00005534                 push    ebp
.text$mn:00005535                 mov     ebp, esp
.text$mn:00005537                 push    ecx
.text$mn:00005538                 mov     [ebp+var_4], ecx
.text$mn:0000553B                 mov     ecx, [ebp+var_4]
.text$mn:0000553E                 call    ?size@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@QBEIXZ ; std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::size(void)
.text$mn:00005543                 cmp     eax, [ebp+arg_0]
.text$mn:00005546                 ja      short loc_55B0
.text$mn:00005548                 push    4B1h            ; unsigned int
.text$mn:0000554D                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00005552                 push    offset ??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "vector subscript out of range"
.text$mn:00005557                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:0000555C                 add     esp, 0Ch
.text$mn:0000555F                 mov     eax, offset ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ ; "Standard C++ Libraries Out of Range"
.text$mn:00005564                 test    eax, eax
.text$mn:00005566                 jz      short loc_556C
.text$mn:00005568                 xor     ecx, ecx
.text$mn:0000556A                 jnz     short loc_5592
.text$mn:0000556C
.text$mn:0000556C loc_556C:                               ; CODE XREF: std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::operator[](uint)+32j
.text$mn:0000556C                 push    offset ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@ ; "\"Standard C++ Libraries Out of Range\""...
.text$mn:00005571                 push    offset ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ ; "%s"
.text$mn:00005576                 push    0
.text$mn:00005578                 push    4B2h
.text$mn:0000557D                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00005582                 push    2
.text$mn:00005584                 call    __CrtDbgReportW
.text$mn:00005589                 add     esp, 18h
.text$mn:0000558C                 cmp     eax, 1
.text$mn:0000558F                 jnz     short loc_5592
.text$mn:00005591                 int     3               ; Trap to Debugger
.text$mn:00005592
.text$mn:00005592 loc_5592:                               ; CODE XREF: std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::operator[](uint)+36j
.text$mn:00005592                                         ; std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::operator[](uint)+5Bj
.text$mn:00005592                 push    0
.text$mn:00005594                 push    4B2h
.text$mn:00005599                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000559E                 push    offset ??_C@_1MK@HJPEJHDM@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAS?$AAc?$AAi?$AAn?$AAt?$AAi?$AAl?$AAl?$AAa?$AAE?$AAd?$AAi?$AAt?$AAV@ ; "std::vector<class ScintillaEditView *,c"...
.text$mn:000055A3                 push    offset ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@ ; "\"out of range\""
.text$mn:000055A8                 call    __invalid_parameter
.text$mn:000055AD                 add     esp, 14h
.text$mn:000055B0
.text$mn:000055B0 loc_55B0:                               ; CODE XREF: std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::operator[](uint)+12j
.text$mn:000055B0                 mov     eax, [ebp+var_4]
.text$mn:000055B3                 mov     ecx, [eax+4]
.text$mn:000055B6                 mov     edx, [ebp+arg_0]
.text$mn:000055B9                 lea     eax, [ecx+edx*4]
.text$mn:000055BC                 mov     esp, ebp
.text$mn:000055BE                 pop     ebp
.text$mn:000055BF                 retn    4
.text$mn:000055BF ??A?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@QAEAAPAVScintillaEditView@@I@Z endp
.text$mn:000055BF
.text$mn:000055BF ; ---------------------------------------------------------------------------
.text$mn:000055C2                 align 4
.text$mn:000055C2 _text$mn        ends
.text$mn:000055C2
.text$mn:000055C4 ; ===========================================================================
.text$mn:000055C4
.text$mn:000055C4 ; Segment type: Pure code
.text$mn:000055C4 ; Segment permissions: Read/Execute
.text$mn:000055C4 _text$mn        segment para public 'CODE' use32
.text$mn:000055C4                 assume cs:_text$mn
.text$mn:000055C4                 ;org 55C4h
.text$mn:000055C4 ; COMDAT (pick any)
.text$mn:000055C4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000055C4
.text$mn:000055C4 ; =============== S U B R O U T I N E =======================================
.text$mn:000055C4
.text$mn:000055C4 ; Attributes: bp-based frame
.text$mn:000055C4
.text$mn:000055C4 ; public: struct std::pair<int const, struct Style> * __thiscall std::_List_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<int const, struct Style>>>>::operator->(void)const
.text$mn:000055C4                 public ??C?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@QBEPAU?$pair@$$CBHUStyle@@@1@XZ
.text$mn:000055C4 ??C?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@QBEPAU?$pair@$$CBHUStyle@@@1@XZ proc near
.text$mn:000055C4                                         ; CODE XREF: ScintillaEditView::~ScintillaEditView(void)+130p
.text$mn:000055C4                                         ; ScintillaEditView::~ScintillaEditView(void)+13Ep
.text$mn:000055C4
.text$mn:000055C4 var_4           = dword ptr -4
.text$mn:000055C4
.text$mn:000055C4                 push    ebp
.text$mn:000055C5                 mov     ebp, esp
.text$mn:000055C7                 push    ecx
.text$mn:000055C8                 mov     [ebp+var_4], ecx
.text$mn:000055CB                 mov     ecx, [ebp+var_4]
.text$mn:000055CE                 call    ??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@QBEAAU?$pair@$$CBHUStyle@@@1@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>::operator*(void)
.text$mn:000055D3                 push    eax
.text$mn:000055D4                 call    ?pointer_to@?$pointer_traits@PAU?$pair@$$CBHUStyle@@@std@@@std@@SAPAU?$pair@$$CBHUStyle@@@2@AAU32@@Z ; std::pointer_traits<std::pair<int const,Style> *>::pointer_to(std::pair<int const,Style> &)
.text$mn:000055D9                 add     esp, 4
.text$mn:000055DC                 mov     esp, ebp
.text$mn:000055DE                 pop     ebp
.text$mn:000055DF                 retn
.text$mn:000055DF ??C?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@QBEPAU?$pair@$$CBHUStyle@@@1@XZ endp
.text$mn:000055DF
.text$mn:000055DF _text$mn        ends
.text$mn:000055DF
.text$mn:000055E0 ; ===========================================================================
.text$mn:000055E0
.text$mn:000055E0 ; Segment type: Pure code
.text$mn:000055E0 ; Segment permissions: Read/Execute
.text$mn:000055E0 _text$mn        segment para public 'CODE' use32
.text$mn:000055E0                 assume cs:_text$mn
.text$mn:000055E0                 ;org 55E0h
.text$mn:000055E0 ; COMDAT (pick any)
.text$mn:000055E0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000055E0
.text$mn:000055E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000055E0
.text$mn:000055E0 ; Attributes: bp-based frame
.text$mn:000055E0
.text$mn:000055E0 ; public: struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *> * __thiscall std::_List_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>::operator->(void)const
.text$mn:000055E0                 public ??C?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QBEPAU?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@1@XZ
.text$mn:000055E0 ??C?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QBEPAU?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@1@XZ proc near
.text$mn:000055E0                                         ; CODE XREF: ScintillaEditView::~ScintillaEditView(void)+CEp
.text$mn:000055E0                                         ; ScintillaEditView::~ScintillaEditView(void)+F0p ...
.text$mn:000055E0
.text$mn:000055E0 var_4           = dword ptr -4
.text$mn:000055E0
.text$mn:000055E0                 push    ebp
.text$mn:000055E1                 mov     ebp, esp
.text$mn:000055E3                 push    ecx
.text$mn:000055E4                 mov     [ebp+var_4], ecx
.text$mn:000055E7                 mov     ecx, [ebp+var_4]
.text$mn:000055EA                 call    ??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QBEAAU?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@1@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::operator*(void)
.text$mn:000055EF                 push    eax
.text$mn:000055F0                 call    ?pointer_to@?$pointer_traits@PAU?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@SAPAU?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@2@AAU32@@Z ; std::pointer_traits<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *> *>::pointer_to(std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *> &)
.text$mn:000055F5                 add     esp, 4
.text$mn:000055F8                 mov     esp, ebp
.text$mn:000055FA                 pop     ebp
.text$mn:000055FB                 retn
.text$mn:000055FB ??C?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QBEPAU?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@1@XZ endp
.text$mn:000055FB
.text$mn:000055FB _text$mn        ends
.text$mn:000055FB
.text$mn:000055FC ; ===========================================================================
.text$mn:000055FC
.text$mn:000055FC ; Segment type: Pure code
.text$mn:000055FC ; Segment permissions: Read/Execute
.text$mn:000055FC _text$mn        segment para public 'CODE' use32
.text$mn:000055FC                 assume cs:_text$mn
.text$mn:000055FC                 ;org 55FCh
.text$mn:000055FC ; COMDAT (pick any)
.text$mn:000055FC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000055FC
.text$mn:000055FC ; =============== S U B R O U T I N E =======================================
.text$mn:000055FC
.text$mn:000055FC ; Attributes: bp-based frame
.text$mn:000055FC
.text$mn:000055FC ; public: struct std::pair<int const, struct Style> const & __thiscall std::_List_const_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<int const, struct Style>>>>::operator*(void)const
.text$mn:000055FC                 public ??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@QBEABU?$pair@$$CBHUStyle@@@1@XZ
.text$mn:000055FC ??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@QBEABU?$pair@$$CBHUStyle@@@1@XZ proc near
.text$mn:000055FC                                         ; CODE XREF: std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>::operator*(void)+Ap
.text$mn:000055FC
.text$mn:000055FC var_4           = dword ptr -4
.text$mn:000055FC
.text$mn:000055FC                 push    ebp
.text$mn:000055FD                 mov     ebp, esp
.text$mn:000055FF                 push    ecx
.text$mn:00005600                 mov     [ebp+var_4], ecx
.text$mn:00005603                 mov     ecx, [ebp+var_4] ; this
.text$mn:00005606                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:0000560B                 test    eax, eax
.text$mn:0000560D                 jz      short loc_562B
.text$mn:0000560F                 mov     eax, [ebp+var_4]
.text$mn:00005612                 cmp     dword ptr [eax+8], 0
.text$mn:00005616                 jz      short loc_562B
.text$mn:00005618                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000561B                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:00005620                 mov     ecx, [ebp+var_4]
.text$mn:00005623                 mov     edx, [ecx+8]
.text$mn:00005626                 cmp     edx, [eax+4]
.text$mn:00005629                 jnz     short loc_5693
.text$mn:0000562B
.text$mn:0000562B loc_562B:                               ; CODE XREF: std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>::operator*(void)+11j
.text$mn:0000562B                                         ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>::operator*(void)+1Aj
.text$mn:0000562B                 push    0D2h ; '-'      ; unsigned int
.text$mn:00005630                 push    offset ??_C@_1II@KCNBAEMF@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00005635                 push    offset ??_C@_1EC@HILJLMMC@?$AAl?$AAi?$AAs?$AAt?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAa?$AAb?$AAl?$AAe@ ; "list iterator not dereferencable"
.text$mn:0000563A                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:0000563F                 add     esp, 0Ch
.text$mn:00005642                 mov     eax, offset ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ ; "Standard C++ Libraries Out of Range"
.text$mn:00005647                 test    eax, eax
.text$mn:00005649                 jz      short loc_564F
.text$mn:0000564B                 xor     ecx, ecx
.text$mn:0000564D                 jnz     short loc_5675
.text$mn:0000564F
.text$mn:0000564F loc_564F:                               ; CODE XREF: std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>::operator*(void)+4Dj
.text$mn:0000564F                 push    offset ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@ ; "\"Standard C++ Libraries Out of Range\""...
.text$mn:00005654                 push    offset ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ ; "%s"
.text$mn:00005659                 push    0
.text$mn:0000565B                 push    0D3h ; '+'
.text$mn:00005660                 push    offset ??_C@_1II@KCNBAEMF@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00005665                 push    2
.text$mn:00005667                 call    __CrtDbgReportW
.text$mn:0000566C                 add     esp, 18h
.text$mn:0000566F                 cmp     eax, 1
.text$mn:00005672                 jnz     short loc_5675
.text$mn:00005674                 int     3               ; Trap to Debugger
.text$mn:00005675
.text$mn:00005675 loc_5675:                               ; CODE XREF: std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>::operator*(void)+51j
.text$mn:00005675                                         ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>::operator*(void)+76j
.text$mn:00005675                 push    0
.text$mn:00005677                 push    0D3h ; '+'
.text$mn:0000567C                 push    offset ??_C@_1II@KCNBAEMF@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00005681                 push    offset ??_C@_1BBE@PIHPBAPJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAL?$AAi?$AAs?$AAt?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5@ ; "std::_List_const_iterator<class std::_L"...
.text$mn:00005686                 push    offset ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@ ; "\"out of range\""
.text$mn:0000568B                 call    __invalid_parameter
.text$mn:00005690                 add     esp, 14h
.text$mn:00005693
.text$mn:00005693 loc_5693:                               ; CODE XREF: std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>::operator*(void)+2Dj
.text$mn:00005693                 mov     eax, [ebp+var_4]
.text$mn:00005696                 mov     ecx, [eax+8]
.text$mn:00005699                 push    ecx
.text$mn:0000569A                 call    ?_Myval@?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@SAAAU?$pair@$$CBHUStyle@@@2@PAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@2@@Z ; std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>::_Myval(std::_List_node<std::pair<int const,Style>,void *> *)
.text$mn:0000569F                 add     esp, 4
.text$mn:000056A2                 mov     esp, ebp
.text$mn:000056A4                 pop     ebp
.text$mn:000056A5                 retn
.text$mn:000056A5 ??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@QBEABU?$pair@$$CBHUStyle@@@1@XZ endp
.text$mn:000056A5
.text$mn:000056A5 ; ---------------------------------------------------------------------------
.text$mn:000056A6                 align 4
.text$mn:000056A6 _text$mn        ends
.text$mn:000056A6
.text$mn:000056A8 ; ===========================================================================
.text$mn:000056A8
.text$mn:000056A8 ; Segment type: Pure code
.text$mn:000056A8 ; Segment permissions: Read/Execute
.text$mn:000056A8 _text$mn        segment para public 'CODE' use32
.text$mn:000056A8                 assume cs:_text$mn
.text$mn:000056A8                 ;org 56A8h
.text$mn:000056A8 ; COMDAT (pick any)
.text$mn:000056A8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000056A8
.text$mn:000056A8 ; =============== S U B R O U T I N E =======================================
.text$mn:000056A8
.text$mn:000056A8 ; Attributes: bp-based frame
.text$mn:000056A8
.text$mn:000056A8 ; public: struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *> const & __thiscall std::_List_const_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>::operator*(void)const
.text$mn:000056A8                 public ??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QBEABU?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@1@XZ
.text$mn:000056A8 ??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QBEABU?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@1@XZ proc near
.text$mn:000056A8                                         ; CODE XREF: std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::operator*(void)+Ap
.text$mn:000056A8
.text$mn:000056A8 var_4           = dword ptr -4
.text$mn:000056A8
.text$mn:000056A8                 push    ebp
.text$mn:000056A9                 mov     ebp, esp
.text$mn:000056AB                 push    ecx
.text$mn:000056AC                 mov     [ebp+var_4], ecx
.text$mn:000056AF                 mov     ecx, [ebp+var_4] ; this
.text$mn:000056B2                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:000056B7                 test    eax, eax
.text$mn:000056B9                 jz      short loc_56D7
.text$mn:000056BB                 mov     eax, [ebp+var_4]
.text$mn:000056BE                 cmp     dword ptr [eax+8], 0
.text$mn:000056C2                 jz      short loc_56D7
.text$mn:000056C4                 mov     ecx, [ebp+var_4] ; this
.text$mn:000056C7                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:000056CC                 mov     ecx, [ebp+var_4]
.text$mn:000056CF                 mov     edx, [ecx+8]
.text$mn:000056D2                 cmp     edx, [eax+4]
.text$mn:000056D5                 jnz     short loc_573F
.text$mn:000056D7
.text$mn:000056D7 loc_56D7:                               ; CODE XREF: std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::operator*(void)+11j
.text$mn:000056D7                                         ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::operator*(void)+1Aj
.text$mn:000056D7                 push    0D2h ; '-'      ; unsigned int
.text$mn:000056DC                 push    offset ??_C@_1II@KCNBAEMF@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000056E1                 push    offset ??_C@_1EC@HILJLMMC@?$AAl?$AAi?$AAs?$AAt?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAa?$AAb?$AAl?$AAe@ ; "list iterator not dereferencable"
.text$mn:000056E6                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:000056EB                 add     esp, 0Ch
.text$mn:000056EE                 mov     eax, offset ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ ; "Standard C++ Libraries Out of Range"
.text$mn:000056F3                 test    eax, eax
.text$mn:000056F5                 jz      short loc_56FB
.text$mn:000056F7                 xor     ecx, ecx
.text$mn:000056F9                 jnz     short loc_5721
.text$mn:000056FB
.text$mn:000056FB loc_56FB:                               ; CODE XREF: std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::operator*(void)+4Dj
.text$mn:000056FB                 push    offset ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@ ; "\"Standard C++ Libraries Out of Range\""...
.text$mn:00005700                 push    offset ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ ; "%s"
.text$mn:00005705                 push    0
.text$mn:00005707                 push    0D3h ; '+'
.text$mn:0000570C                 push    offset ??_C@_1II@KCNBAEMF@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00005711                 push    2
.text$mn:00005713                 call    __CrtDbgReportW
.text$mn:00005718                 add     esp, 18h
.text$mn:0000571B                 cmp     eax, 1
.text$mn:0000571E                 jnz     short loc_5721
.text$mn:00005720                 int     3               ; Trap to Debugger
.text$mn:00005721
.text$mn:00005721 loc_5721:                               ; CODE XREF: std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::operator*(void)+51j
.text$mn:00005721                                         ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::operator*(void)+76j
.text$mn:00005721                 push    0
.text$mn:00005723                 push    0D3h ; '+'
.text$mn:00005728                 push    offset ??_C@_1II@KCNBAEMF@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000572D                 push    offset ??_C@_1CEM@BAKEJGH@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAL?$AAi?$AAs?$AAt?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5@ ; "std::_List_const_iterator<class std::_L"...
.text$mn:00005732                 push    offset ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@ ; "\"out of range\""
.text$mn:00005737                 call    __invalid_parameter
.text$mn:0000573C                 add     esp, 14h
.text$mn:0000573F
.text$mn:0000573F loc_573F:                               ; CODE XREF: std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::operator*(void)+2Dj
.text$mn:0000573F                 mov     eax, [ebp+var_4]
.text$mn:00005742                 mov     ecx, [eax+8]
.text$mn:00005745                 push    ecx
.text$mn:00005746                 call    ?_Myval@?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@SAAAU?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@2@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@2@@Z ; std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>::_Myval(std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *)
.text$mn:0000574B                 add     esp, 4
.text$mn:0000574E                 mov     esp, ebp
.text$mn:00005750                 pop     ebp
.text$mn:00005751                 retn
.text$mn:00005751 ??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QBEABU?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@1@XZ endp
.text$mn:00005751
.text$mn:00005751 ; ---------------------------------------------------------------------------
.text$mn:00005752                 align 4
.text$mn:00005752 _text$mn        ends
.text$mn:00005752
.text$mn:00005754 ; ===========================================================================
.text$mn:00005754
.text$mn:00005754 ; Segment type: Pure code
.text$mn:00005754 ; Segment permissions: Read/Execute
.text$mn:00005754 _text$mn        segment para public 'CODE' use32
.text$mn:00005754                 assume cs:_text$mn
.text$mn:00005754                 ;org 5754h
.text$mn:00005754 ; COMDAT (pick any)
.text$mn:00005754                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005754
.text$mn:00005754 ; =============== S U B R O U T I N E =======================================
.text$mn:00005754
.text$mn:00005754 ; Attributes: bp-based frame
.text$mn:00005754
.text$mn:00005754 ; public: struct std::pair<int const, struct Style> & __thiscall std::_List_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<int const, struct Style>>>>::operator*(void)const
.text$mn:00005754                 public ??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@QBEAAU?$pair@$$CBHUStyle@@@1@XZ
.text$mn:00005754 ??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@QBEAAU?$pair@$$CBHUStyle@@@1@XZ proc near
.text$mn:00005754                                         ; CODE XREF: std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>::operator->(void)+Ap
.text$mn:00005754
.text$mn:00005754 var_4           = dword ptr -4
.text$mn:00005754
.text$mn:00005754                 push    ebp
.text$mn:00005755                 mov     ebp, esp
.text$mn:00005757                 push    ecx
.text$mn:00005758                 mov     [ebp+var_4], ecx
.text$mn:0000575B                 mov     ecx, [ebp+var_4]
.text$mn:0000575E                 call    ??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@QBEABU?$pair@$$CBHUStyle@@@1@XZ ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>::operator*(void)
.text$mn:00005763                 mov     esp, ebp
.text$mn:00005765                 pop     ebp
.text$mn:00005766                 retn
.text$mn:00005766 ??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@QBEAAU?$pair@$$CBHUStyle@@@1@XZ endp
.text$mn:00005766
.text$mn:00005766 ; ---------------------------------------------------------------------------
.text$mn:00005767                 align 4
.text$mn:00005767 _text$mn        ends
.text$mn:00005767
.text$mn:00005768 ; ===========================================================================
.text$mn:00005768
.text$mn:00005768 ; Segment type: Pure code
.text$mn:00005768 ; Segment permissions: Read/Execute
.text$mn:00005768 _text$mn        segment para public 'CODE' use32
.text$mn:00005768                 assume cs:_text$mn
.text$mn:00005768                 ;org 5768h
.text$mn:00005768 ; COMDAT (pick any)
.text$mn:00005768                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005768
.text$mn:00005768 ; =============== S U B R O U T I N E =======================================
.text$mn:00005768
.text$mn:00005768 ; Attributes: bp-based frame
.text$mn:00005768
.text$mn:00005768 ; public: struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *> & __thiscall std::_List_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>::operator*(void)const
.text$mn:00005768                 public ??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QBEAAU?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@1@XZ
.text$mn:00005768 ??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QBEAAU?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@1@XZ proc near
.text$mn:00005768                                         ; CODE XREF: std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::operator->(void)+Ap
.text$mn:00005768
.text$mn:00005768 var_4           = dword ptr -4
.text$mn:00005768
.text$mn:00005768                 push    ebp
.text$mn:00005769                 mov     ebp, esp
.text$mn:0000576B                 push    ecx
.text$mn:0000576C                 mov     [ebp+var_4], ecx
.text$mn:0000576F                 mov     ecx, [ebp+var_4]
.text$mn:00005772                 call    ??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QBEABU?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@1@XZ ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::operator*(void)
.text$mn:00005777                 mov     esp, ebp
.text$mn:00005779                 pop     ebp
.text$mn:0000577A                 retn
.text$mn:0000577A ??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QBEAAU?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@1@XZ endp
.text$mn:0000577A
.text$mn:0000577A ; ---------------------------------------------------------------------------
.text$mn:0000577B                 align 4
.text$mn:0000577B _text$mn        ends
.text$mn:0000577B
.text$mn:0000577C ; ===========================================================================
.text$mn:0000577C
.text$mn:0000577C ; Segment type: Pure code
.text$mn:0000577C ; Segment permissions: Read/Execute
.text$mn:0000577C _text$mn        segment para public 'CODE' use32
.text$mn:0000577C                 assume cs:_text$mn
.text$mn:0000577C                 ;org 577Ch
.text$mn:0000577C ; COMDAT (pick any)
.text$mn:0000577C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000577C
.text$mn:0000577C ; =============== S U B R O U T I N E =======================================
.text$mn:0000577C
.text$mn:0000577C ; Attributes: bp-based frame
.text$mn:0000577C
.text$mn:0000577C ; public: class std::_List_const_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<int const, struct Style>>>> & __thiscall std::_List_const_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<int const, struct Style>>>>::operator++(void)
.text$mn:0000577C                 public ??E?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@QAEAAV01@XZ
.text$mn:0000577C ??E?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@QAEAAV01@XZ proc near
.text$mn:0000577C                                         ; CODE XREF: std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>::operator++(void)+Ap
.text$mn:0000577C
.text$mn:0000577C var_4           = dword ptr -4
.text$mn:0000577C
.text$mn:0000577C                 push    ebp
.text$mn:0000577D                 mov     ebp, esp
.text$mn:0000577F                 push    ecx
.text$mn:00005780                 mov     [ebp+var_4], ecx
.text$mn:00005783                 mov     ecx, [ebp+var_4] ; this
.text$mn:00005786                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:0000578B                 test    eax, eax
.text$mn:0000578D                 jz      short loc_57AB
.text$mn:0000578F                 mov     eax, [ebp+var_4]
.text$mn:00005792                 cmp     dword ptr [eax+8], 0
.text$mn:00005796                 jz      short loc_57AB
.text$mn:00005798                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000579B                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:000057A0                 mov     ecx, [ebp+var_4]
.text$mn:000057A3                 mov     edx, [ecx+8]
.text$mn:000057A6                 cmp     edx, [eax+4]
.text$mn:000057A9                 jnz     short loc_5813
.text$mn:000057AB
.text$mn:000057AB loc_57AB:                               ; CODE XREF: std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>::operator++(void)+11j
.text$mn:000057AB                                         ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>::operator++(void)+1Aj
.text$mn:000057AB                 push    0E6h ; 'µ'      ; unsigned int
.text$mn:000057B0                 push    offset ??_C@_1II@KCNBAEMF@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000057B5                 push    offset ??_C@_1EA@DOGAGKDH@?$AAl?$AAi?$AAs?$AAt?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAi?$AAn?$AAc?$AAr?$AAe?$AAm?$AAe?$AAn?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?$AA@ ; "list iterator not incrementable"
.text$mn:000057BA                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:000057BF                 add     esp, 0Ch
.text$mn:000057C2                 mov     eax, offset ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ ; "Standard C++ Libraries Out of Range"
.text$mn:000057C7                 test    eax, eax
.text$mn:000057C9                 jz      short loc_57CF
.text$mn:000057CB                 xor     ecx, ecx
.text$mn:000057CD                 jnz     short loc_57F5
.text$mn:000057CF
.text$mn:000057CF loc_57CF:                               ; CODE XREF: std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>::operator++(void)+4Dj
.text$mn:000057CF                 push    offset ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@ ; "\"Standard C++ Libraries Out of Range\""...
.text$mn:000057D4                 push    offset ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ ; "%s"
.text$mn:000057D9                 push    0
.text$mn:000057DB                 push    0E7h ; 't'
.text$mn:000057E0                 push    offset ??_C@_1II@KCNBAEMF@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000057E5                 push    2
.text$mn:000057E7                 call    __CrtDbgReportW
.text$mn:000057EC                 add     esp, 18h
.text$mn:000057EF                 cmp     eax, 1
.text$mn:000057F2                 jnz     short loc_57F5
.text$mn:000057F4                 int     3               ; Trap to Debugger
.text$mn:000057F5
.text$mn:000057F5 loc_57F5:                               ; CODE XREF: std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>::operator++(void)+51j
.text$mn:000057F5                                         ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>::operator++(void)+76j
.text$mn:000057F5                 push    0
.text$mn:000057F7                 push    0E7h ; 't'
.text$mn:000057FC                 push    offset ??_C@_1II@KCNBAEMF@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00005801                 push    offset ??_C@_1BBG@GEKGEJHF@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAL?$AAi?$AAs?$AAt?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5@ ; "std::_List_const_iterator<class std::_L"...
.text$mn:00005806                 push    offset ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@ ; "\"out of range\""
.text$mn:0000580B                 call    __invalid_parameter
.text$mn:00005810                 add     esp, 14h
.text$mn:00005813
.text$mn:00005813 loc_5813:                               ; CODE XREF: std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>::operator++(void)+2Dj
.text$mn:00005813                 mov     eax, [ebp+var_4]
.text$mn:00005816                 mov     ecx, [eax+8]
.text$mn:00005819                 push    ecx
.text$mn:0000581A                 call    ?_Nextnode@?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@SAAAPAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@2@PAU32@@Z ; std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>::_Nextnode(std::_List_node<std::pair<int const,Style>,void *> *)
.text$mn:0000581F                 add     esp, 4
.text$mn:00005822                 mov     edx, [ebp+var_4]
.text$mn:00005825                 mov     eax, [eax]
.text$mn:00005827                 mov     [edx+8], eax
.text$mn:0000582A                 mov     eax, [ebp+var_4]
.text$mn:0000582D                 mov     esp, ebp
.text$mn:0000582F                 pop     ebp
.text$mn:00005830                 retn
.text$mn:00005830 ??E?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@QAEAAV01@XZ endp
.text$mn:00005830
.text$mn:00005830 ; ---------------------------------------------------------------------------
.text$mn:00005831                 align 4
.text$mn:00005831 _text$mn        ends
.text$mn:00005831
.text$mn:00005834 ; ===========================================================================
.text$mn:00005834
.text$mn:00005834 ; Segment type: Pure code
.text$mn:00005834 ; Segment permissions: Read/Execute
.text$mn:00005834 _text$mn        segment para public 'CODE' use32
.text$mn:00005834                 assume cs:_text$mn
.text$mn:00005834                 ;org 5834h
.text$mn:00005834 ; COMDAT (pick any)
.text$mn:00005834                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005834
.text$mn:00005834 ; =============== S U B R O U T I N E =======================================
.text$mn:00005834
.text$mn:00005834 ; Attributes: bp-based frame
.text$mn:00005834
.text$mn:00005834 ; public: class std::_List_const_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>> & __thiscall std::_List_const_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>::operator++(void)
.text$mn:00005834                 public ??E?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QAEAAV01@XZ
.text$mn:00005834 ??E?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QAEAAV01@XZ proc near
.text$mn:00005834                                         ; CODE XREF: std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::operator++(void)+Ap
.text$mn:00005834
.text$mn:00005834 var_4           = dword ptr -4
.text$mn:00005834
.text$mn:00005834                 push    ebp
.text$mn:00005835                 mov     ebp, esp
.text$mn:00005837                 push    ecx
.text$mn:00005838                 mov     [ebp+var_4], ecx
.text$mn:0000583B                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000583E                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:00005843                 test    eax, eax
.text$mn:00005845                 jz      short loc_5863
.text$mn:00005847                 mov     eax, [ebp+var_4]
.text$mn:0000584A                 cmp     dword ptr [eax+8], 0
.text$mn:0000584E                 jz      short loc_5863
.text$mn:00005850                 mov     ecx, [ebp+var_4] ; this
.text$mn:00005853                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:00005858                 mov     ecx, [ebp+var_4]
.text$mn:0000585B                 mov     edx, [ecx+8]
.text$mn:0000585E                 cmp     edx, [eax+4]
.text$mn:00005861                 jnz     short loc_58CB
.text$mn:00005863
.text$mn:00005863 loc_5863:                               ; CODE XREF: std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::operator++(void)+11j
.text$mn:00005863                                         ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::operator++(void)+1Aj
.text$mn:00005863                 push    0E6h ; 'µ'      ; unsigned int
.text$mn:00005868                 push    offset ??_C@_1II@KCNBAEMF@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000586D                 push    offset ??_C@_1EA@DOGAGKDH@?$AAl?$AAi?$AAs?$AAt?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAi?$AAn?$AAc?$AAr?$AAe?$AAm?$AAe?$AAn?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?$AA@ ; "list iterator not incrementable"
.text$mn:00005872                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00005877                 add     esp, 0Ch
.text$mn:0000587A                 mov     eax, offset ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ ; "Standard C++ Libraries Out of Range"
.text$mn:0000587F                 test    eax, eax
.text$mn:00005881                 jz      short loc_5887
.text$mn:00005883                 xor     ecx, ecx
.text$mn:00005885                 jnz     short loc_58AD
.text$mn:00005887
.text$mn:00005887 loc_5887:                               ; CODE XREF: std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::operator++(void)+4Dj
.text$mn:00005887                 push    offset ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@ ; "\"Standard C++ Libraries Out of Range\""...
.text$mn:0000588C                 push    offset ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ ; "%s"
.text$mn:00005891                 push    0
.text$mn:00005893                 push    0E7h ; 't'
.text$mn:00005898                 push    offset ??_C@_1II@KCNBAEMF@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000589D                 push    2
.text$mn:0000589F                 call    __CrtDbgReportW
.text$mn:000058A4                 add     esp, 18h
.text$mn:000058A7                 cmp     eax, 1
.text$mn:000058AA                 jnz     short loc_58AD
.text$mn:000058AC                 int     3               ; Trap to Debugger
.text$mn:000058AD
.text$mn:000058AD loc_58AD:                               ; CODE XREF: std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::operator++(void)+51j
.text$mn:000058AD                                         ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::operator++(void)+76j
.text$mn:000058AD                 push    0
.text$mn:000058AF                 push    0E7h ; 't'
.text$mn:000058B4                 push    offset ??_C@_1II@KCNBAEMF@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000058B9                 push    offset ??_C@_1CEO@JJNDPOME@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAL?$AAi?$AAs?$AAt?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5@ ; "std::_List_const_iterator<class std::_L"...
.text$mn:000058BE                 push    offset ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@ ; "\"out of range\""
.text$mn:000058C3                 call    __invalid_parameter
.text$mn:000058C8                 add     esp, 14h
.text$mn:000058CB
.text$mn:000058CB loc_58CB:                               ; CODE XREF: std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::operator++(void)+2Dj
.text$mn:000058CB                 mov     eax, [ebp+var_4]
.text$mn:000058CE                 mov     ecx, [eax+8]
.text$mn:000058D1                 push    ecx
.text$mn:000058D2                 call    ?_Nextnode@?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@SAAAPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@2@PAU32@@Z ; std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>::_Nextnode(std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *)
.text$mn:000058D7                 add     esp, 4
.text$mn:000058DA                 mov     edx, [ebp+var_4]
.text$mn:000058DD                 mov     eax, [eax]
.text$mn:000058DF                 mov     [edx+8], eax
.text$mn:000058E2                 mov     eax, [ebp+var_4]
.text$mn:000058E5                 mov     esp, ebp
.text$mn:000058E7                 pop     ebp
.text$mn:000058E8                 retn
.text$mn:000058E8 ??E?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QAEAAV01@XZ endp
.text$mn:000058E8
.text$mn:000058E8 ; ---------------------------------------------------------------------------
.text$mn:000058E9                 align 4
.text$mn:000058E9 _text$mn        ends
.text$mn:000058E9
.text$mn:000058EC ; ===========================================================================
.text$mn:000058EC
.text$mn:000058EC ; Segment type: Pure code
.text$mn:000058EC ; Segment permissions: Read/Execute
.text$mn:000058EC _text$mn        segment para public 'CODE' use32
.text$mn:000058EC                 assume cs:_text$mn
.text$mn:000058EC                 ;org 58ECh
.text$mn:000058EC ; COMDAT (pick any)
.text$mn:000058EC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000058EC
.text$mn:000058EC ; =============== S U B R O U T I N E =======================================
.text$mn:000058EC
.text$mn:000058EC ; Attributes: bp-based frame
.text$mn:000058EC
.text$mn:000058EC ; public: class std::_List_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<int const, struct Style>>>> & __thiscall std::_List_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<int const, struct Style>>>>::operator++(void)
.text$mn:000058EC                 public ??E?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@QAEAAV01@XZ
.text$mn:000058EC ??E?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@QAEAAV01@XZ proc near
.text$mn:000058EC                                         ; CODE XREF: ScintillaEditView::~ScintillaEditView(void)+E4p
.text$mn:000058EC
.text$mn:000058EC var_4           = dword ptr -4
.text$mn:000058EC
.text$mn:000058EC                 push    ebp
.text$mn:000058ED                 mov     ebp, esp
.text$mn:000058EF                 push    ecx
.text$mn:000058F0                 mov     [ebp+var_4], ecx
.text$mn:000058F3                 mov     ecx, [ebp+var_4]
.text$mn:000058F6                 call    ??E?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>::operator++(void)
.text$mn:000058FB                 mov     eax, [ebp+var_4]
.text$mn:000058FE                 mov     esp, ebp
.text$mn:00005900                 pop     ebp
.text$mn:00005901                 retn
.text$mn:00005901 ??E?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@QAEAAV01@XZ endp
.text$mn:00005901
.text$mn:00005901 ; ---------------------------------------------------------------------------
.text$mn:00005902                 align 4
.text$mn:00005902 _text$mn        ends
.text$mn:00005902
.text$mn:00005904 ; ===========================================================================
.text$mn:00005904
.text$mn:00005904 ; Segment type: Pure code
.text$mn:00005904 ; Segment permissions: Read/Execute
.text$mn:00005904 _text$mn        segment para public 'CODE' use32
.text$mn:00005904                 assume cs:_text$mn
.text$mn:00005904                 ;org 5904h
.text$mn:00005904 ; COMDAT (pick any)
.text$mn:00005904                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005904
.text$mn:00005904 ; =============== S U B R O U T I N E =======================================
.text$mn:00005904
.text$mn:00005904 ; Attributes: bp-based frame
.text$mn:00005904
.text$mn:00005904 ; public: class std::_List_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>> & __thiscall std::_List_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>::operator++(void)
.text$mn:00005904                 public ??E?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QAEAAV01@XZ
.text$mn:00005904 ??E?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QAEAAV01@XZ proc near
.text$mn:00005904                                         ; CODE XREF: ScintillaEditView::~ScintillaEditView(void)+7Fp
.text$mn:00005904
.text$mn:00005904 var_4           = dword ptr -4
.text$mn:00005904
.text$mn:00005904                 push    ebp
.text$mn:00005905                 mov     ebp, esp
.text$mn:00005907                 push    ecx
.text$mn:00005908                 mov     [ebp+var_4], ecx
.text$mn:0000590B                 mov     ecx, [ebp+var_4]
.text$mn:0000590E                 call    ??E?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::operator++(void)
.text$mn:00005913                 mov     eax, [ebp+var_4]
.text$mn:00005916                 mov     esp, ebp
.text$mn:00005918                 pop     ebp
.text$mn:00005919                 retn
.text$mn:00005919 ??E?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QAEAAV01@XZ endp
.text$mn:00005919
.text$mn:00005919 ; ---------------------------------------------------------------------------
.text$mn:0000591A                 align 4
.text$mn:0000591A _text$mn        ends
.text$mn:0000591A
.text$mn:0000591C ; ===========================================================================
.text$mn:0000591C
.text$mn:0000591C ; Segment type: Pure code
.text$mn:0000591C ; Segment permissions: Read/Execute
.text$mn:0000591C _text$mn        segment para public 'CODE' use32
.text$mn:0000591C                 assume cs:_text$mn
.text$mn:0000591C                 ;org 591Ch
.text$mn:0000591C ; COMDAT (pick any)
.text$mn:0000591C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000591C
.text$mn:0000591C ; =============== S U B R O U T I N E =======================================
.text$mn:0000591C
.text$mn:0000591C ; Attributes: bp-based frame
.text$mn:0000591C
.text$mn:0000591C ; public: class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<class ScintillaEditView *>>> __thiscall std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<class ScintillaEditView *>>>::operator+(int)const
.text$mn:0000591C                 public ??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QBE?AV01@H@Z
.text$mn:0000591C ??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QBE?AV01@H@Z proc near
.text$mn:0000591C                                         ; CODE XREF: ScintillaCtrls::destroyScintilla(HWND__ *)+C0p
.text$mn:0000591C
.text$mn:0000591C var_20          = byte ptr -20h
.text$mn:0000591C var_14          = dword ptr -14h
.text$mn:0000591C var_10          = dword ptr -10h
.text$mn:0000591C var_C           = dword ptr -0Ch
.text$mn:0000591C var_4           = dword ptr -4
.text$mn:0000591C arg_0           = dword ptr  8
.text$mn:0000591C arg_4           = dword ptr  0Ch
.text$mn:0000591C
.text$mn:0000591C                 push    ebp
.text$mn:0000591D                 mov     ebp, esp
.text$mn:0000591F                 push    0FFFFFFFFh
.text$mn:00005921                 push    offset __ehhandler$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QBE?AV01@H@Z
.text$mn:00005926                 mov     eax, large fs:0
.text$mn:0000592C                 push    eax
.text$mn:0000592D                 sub     esp, 14h
.text$mn:00005930                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005935                 xor     eax, ebp
.text$mn:00005937                 push    eax
.text$mn:00005938                 lea     eax, [ebp+var_C]
.text$mn:0000593B                 mov     large fs:0, eax
.text$mn:00005941                 mov     [ebp+var_14], ecx
.text$mn:00005944                 mov     [ebp+var_10], 0
.text$mn:0000594B                 mov     eax, [ebp+var_14]
.text$mn:0000594E                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:0000594F                 lea     ecx, [ebp+var_20]
.text$mn:00005952                 call    ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>> const &)
.text$mn:00005957                 mov     [ebp+var_4], 1
.text$mn:0000595E                 mov     ecx, [ebp+arg_4]
.text$mn:00005961                 push    ecx
.text$mn:00005962                 lea     ecx, [ebp+var_20]
.text$mn:00005965                 call    ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>::operator+=(int)
.text$mn:0000596A                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:0000596B                 mov     ecx, [ebp+arg_0]
.text$mn:0000596E                 call    ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>> const &)
.text$mn:00005973                 mov     edx, [ebp+var_10]
.text$mn:00005976                 or      edx, 1
.text$mn:00005979                 mov     [ebp+var_10], edx
.text$mn:0000597C                 mov     byte ptr [ebp+var_4], 0
.text$mn:00005980                 lea     ecx, [ebp+var_20]
.text$mn:00005983                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>(void)
.text$mn:00005988                 mov     eax, [ebp+arg_0]
.text$mn:0000598B                 mov     ecx, [ebp+var_C]
.text$mn:0000598E                 mov     large fs:0, ecx
.text$mn:00005995                 pop     ecx
.text$mn:00005996                 mov     esp, ebp
.text$mn:00005998                 pop     ebp
.text$mn:00005999                 retn    8
.text$mn:00005999 ??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QBE?AV01@H@Z endp
.text$mn:00005999
.text$mn:00005999 _text$mn        ends
.text$mn:00005999
.text$x:0000599C ; ===========================================================================
.text$x:0000599C
.text$x:0000599C ; Segment type: Pure code
.text$x:0000599C ; Segment permissions: Read/Execute
.text$x:0000599C _text$x         segment para public 'CODE' use32
.text$x:0000599C                 assume cs:_text$x
.text$x:0000599C                 ;org 599Ch
.text$x:0000599C ; COMDAT (pick associative to section at 591C)
.text$x:0000599C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000599C
.text$x:0000599C ; =============== S U B R O U T I N E =======================================
.text$x:0000599C
.text$x:0000599C
.text$x:0000599C __unwindfunclet$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QBE?AV01@H@Z$0 proc near
.text$x:0000599C                                         ; DATA XREF: .xdata$x:0000AA2Co
.text$x:0000599C                 lea     ecx, [ebp-20h]
.text$x:0000599F                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>(void)
.text$x:0000599F __unwindfunclet$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QBE?AV01@H@Z$0 endp
.text$x:0000599F
.text$x:000059A4
.text$x:000059A4 ; =============== S U B R O U T I N E =======================================
.text$x:000059A4
.text$x:000059A4
.text$x:000059A4 __unwindfunclet$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QBE?AV01@H@Z$1 proc near
.text$x:000059A4                                         ; DATA XREF: .xdata$x:0000AA24o
.text$x:000059A4                 mov     eax, [ebp-10h]
.text$x:000059A7                 and     eax, 1
.text$x:000059AA                 jz      $LN5_0
.text$x:000059B0                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:000059B4                 mov     ecx, [ebp+8]
.text$x:000059B7                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>(void)
.text$x:000059BC ; ---------------------------------------------------------------------------
.text$x:000059BC
.text$x:000059BC $LN5_0:                                 ; CODE XREF: __unwindfunclet$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QBE?AV01@H@Z$1+6j
.text$x:000059BC                 retn
.text$x:000059BC __unwindfunclet$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QBE?AV01@H@Z$1 endp
.text$x:000059BC
.text$x:000059BD
.text$x:000059BD ; =============== S U B R O U T I N E =======================================
.text$x:000059BD
.text$x:000059BD
.text$x:000059BD __ehhandler$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QBE?AV01@H@Z proc near
.text$x:000059BD                                         ; DATA XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>::operator+(int)+5o
.text$x:000059BD
.text$x:000059BD arg_4           = dword ptr  8
.text$x:000059BD
.text$x:000059BD                 mov     edx, [esp+arg_4]
.text$x:000059C1                 lea     eax, [edx+0Ch]
.text$x:000059C4                 mov     ecx, [edx-18h]
.text$x:000059C7                 xor     ecx, eax
.text$x:000059C9                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000059CE                 mov     eax, offset __ehfuncinfo$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QBE?AV01@H@Z
.text$x:000059D3                 jmp     ___CxxFrameHandler3
.text$x:000059D3 __ehhandler$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QBE?AV01@H@Z endp
.text$x:000059D3
.text$x:000059D3 _text$x         ends
.text$x:000059D3
.text$mn:000059D8 ; ===========================================================================
.text$mn:000059D8
.text$mn:000059D8 ; Segment type: Pure code
.text$mn:000059D8 ; Segment permissions: Read/Execute
.text$mn:000059D8 _text$mn        segment para public 'CODE' use32
.text$mn:000059D8                 assume cs:_text$mn
.text$mn:000059D8                 ;org 59D8h
.text$mn:000059D8 ; COMDAT (pick any)
.text$mn:000059D8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000059D8
.text$mn:000059D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000059D8
.text$mn:000059D8 ; Attributes: bp-based frame
.text$mn:000059D8
.text$mn:000059D8 ; public: class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>>>> __thiscall std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>>>>::operator+(int)const
.text$mn:000059D8                 public ??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QBE?AV01@H@Z
.text$mn:000059D8 ??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QBE?AV01@H@Z proc near
.text$mn:000059D8                                         ; CODE XREF: ?_Insert_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CB
.text$mn:000059D8
.text$mn:000059D8 var_20          = byte ptr -20h
.text$mn:000059D8 var_14          = dword ptr -14h
.text$mn:000059D8 var_10          = dword ptr -10h
.text$mn:000059D8 var_C           = dword ptr -0Ch
.text$mn:000059D8 var_4           = dword ptr -4
.text$mn:000059D8 arg_0           = dword ptr  8
.text$mn:000059D8 arg_4           = dword ptr  0Ch
.text$mn:000059D8
.text$mn:000059D8                 push    ebp
.text$mn:000059D9                 mov     ebp, esp
.text$mn:000059DB                 push    0FFFFFFFFh
.text$mn:000059DD                 push    offset __ehhandler$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QBE?AV01@H@Z
.text$mn:000059E2                 mov     eax, large fs:0
.text$mn:000059E8                 push    eax
.text$mn:000059E9                 sub     esp, 14h
.text$mn:000059EC                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000059F1                 xor     eax, ebp
.text$mn:000059F3                 push    eax
.text$mn:000059F4                 lea     eax, [ebp+var_C]
.text$mn:000059F7                 mov     large fs:0, eax
.text$mn:000059FD                 mov     [ebp+var_14], ecx
.text$mn:00005A00                 mov     [ebp+var_10], 0
.text$mn:00005A07                 mov     eax, [ebp+var_14]
.text$mn:00005A0A                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00005A0B                 lea     ecx, [ebp+var_20]
.text$mn:00005A0E                 call    ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>> const &)
.text$mn:00005A13                 mov     [ebp+var_4], 1
.text$mn:00005A1A                 mov     ecx, [ebp+arg_4]
.text$mn:00005A1D                 push    ecx
.text$mn:00005A1E                 lea     ecx, [ebp+var_20]
.text$mn:00005A21                 call    ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::operator+=(int)
.text$mn:00005A26                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00005A27                 mov     ecx, [ebp+arg_0]
.text$mn:00005A2A                 call    ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>> const &)
.text$mn:00005A2F                 mov     edx, [ebp+var_10]
.text$mn:00005A32                 or      edx, 1
.text$mn:00005A35                 mov     [ebp+var_10], edx
.text$mn:00005A38                 mov     byte ptr [ebp+var_4], 0
.text$mn:00005A3C                 lea     ecx, [ebp+var_20]
.text$mn:00005A3F                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>(void)
.text$mn:00005A44                 mov     eax, [ebp+arg_0]
.text$mn:00005A47                 mov     ecx, [ebp+var_C]
.text$mn:00005A4A                 mov     large fs:0, ecx
.text$mn:00005A51                 pop     ecx
.text$mn:00005A52                 mov     esp, ebp
.text$mn:00005A54                 pop     ebp
.text$mn:00005A55                 retn    8
.text$mn:00005A55 ??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QBE?AV01@H@Z endp
.text$mn:00005A55
.text$mn:00005A55 _text$mn        ends
.text$mn:00005A55
.text$x:00005A58 ; ===========================================================================
.text$x:00005A58
.text$x:00005A58 ; Segment type: Pure code
.text$x:00005A58 ; Segment permissions: Read/Execute
.text$x:00005A58 _text$x         segment para public 'CODE' use32
.text$x:00005A58                 assume cs:_text$x
.text$x:00005A58                 ;org 5A58h
.text$x:00005A58 ; COMDAT (pick associative to section at 59D8)
.text$x:00005A58                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00005A58
.text$x:00005A58 ; =============== S U B R O U T I N E =======================================
.text$x:00005A58
.text$x:00005A58
.text$x:00005A58 __unwindfunclet$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QBE?AV01@H@Z$0 proc near
.text$x:00005A58                                         ; DATA XREF: .xdata$x:0000AC18o
.text$x:00005A58                 lea     ecx, [ebp-20h]
.text$x:00005A5B                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>(void)
.text$x:00005A5B __unwindfunclet$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QBE?AV01@H@Z$0 endp
.text$x:00005A5B
.text$x:00005A60
.text$x:00005A60 ; =============== S U B R O U T I N E =======================================
.text$x:00005A60
.text$x:00005A60
.text$x:00005A60 __unwindfunclet$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QBE?AV01@H@Z$1 proc near
.text$x:00005A60                                         ; DATA XREF: .xdata$x:0000AC10o
.text$x:00005A60                 mov     eax, [ebp-10h]
.text$x:00005A63                 and     eax, 1
.text$x:00005A66                 jz      $LN5_1
.text$x:00005A6C                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:00005A70                 mov     ecx, [ebp+8]
.text$x:00005A73                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>(void)
.text$x:00005A78 ; ---------------------------------------------------------------------------
.text$x:00005A78
.text$x:00005A78 $LN5_1:                                 ; CODE XREF: __unwindfunclet$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QBE?AV01@H@Z$1+6j
.text$x:00005A78                 retn
.text$x:00005A78 __unwindfunclet$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QBE?AV01@H@Z$1 endp
.text$x:00005A78
.text$x:00005A79
.text$x:00005A79 ; =============== S U B R O U T I N E =======================================
.text$x:00005A79
.text$x:00005A79
.text$x:00005A79 __ehhandler$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QBE?AV01@H@Z proc near
.text$x:00005A79                                         ; DATA XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::operator+(int)+5o
.text$x:00005A79
.text$x:00005A79 arg_4           = dword ptr  8
.text$x:00005A79
.text$x:00005A79                 mov     edx, [esp+arg_4]
.text$x:00005A7D                 lea     eax, [edx+0Ch]
.text$x:00005A80                 mov     ecx, [edx-18h]
.text$x:00005A83                 xor     ecx, eax
.text$x:00005A85                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005A8A                 mov     eax, offset __ehfuncinfo$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QBE?AV01@H@Z
.text$x:00005A8F                 jmp     ___CxxFrameHandler3
.text$x:00005A8F __ehhandler$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QBE?AV01@H@Z endp
.text$x:00005A8F
.text$x:00005A8F _text$x         ends
.text$x:00005A8F
.text$mn:00005A94 ; ===========================================================================
.text$mn:00005A94
.text$mn:00005A94 ; Segment type: Pure code
.text$mn:00005A94 ; Segment permissions: Read/Execute
.text$mn:00005A94 _text$mn        segment para public 'CODE' use32
.text$mn:00005A94                 assume cs:_text$mn
.text$mn:00005A94                 ;org 5A94h
.text$mn:00005A94 ; COMDAT (pick any)
.text$mn:00005A94                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005A94
.text$mn:00005A94 ; =============== S U B R O U T I N E =======================================
.text$mn:00005A94
.text$mn:00005A94 ; Attributes: bp-based frame
.text$mn:00005A94
.text$mn:00005A94 ; public: class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<class ScintillaEditView *>>> & __thiscall std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<class ScintillaEditView *>>>::operator+=(int)
.text$mn:00005A94                 public ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAEAAV01@H@Z
.text$mn:00005A94 ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAEAAV01@H@Z proc near
.text$mn:00005A94                                         ; CODE XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>::operator+=(int)+Ep
.text$mn:00005A94
.text$mn:00005A94 var_4           = dword ptr -4
.text$mn:00005A94 arg_0           = dword ptr  8
.text$mn:00005A94
.text$mn:00005A94                 push    ebp
.text$mn:00005A95                 mov     ebp, esp
.text$mn:00005A97                 push    ecx
.text$mn:00005A98                 push    esi
.text$mn:00005A99                 mov     [ebp+var_4], ecx
.text$mn:00005A9C                 mov     ecx, [ebp+var_4] ; this
.text$mn:00005A9F                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:00005AA4                 test    eax, eax
.text$mn:00005AA6                 jz      short loc_5ADA
.text$mn:00005AA8                 mov     eax, [ebp+var_4]
.text$mn:00005AAB                 mov     ecx, [eax+8]
.text$mn:00005AAE                 mov     edx, [ebp+arg_0]
.text$mn:00005AB1                 lea     esi, [ecx+edx*4]
.text$mn:00005AB4                 mov     ecx, [ebp+var_4] ; this
.text$mn:00005AB7                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:00005ABC                 cmp     esi, [eax+4]
.text$mn:00005ABF                 jb      short loc_5ADA
.text$mn:00005AC1                 mov     ecx, [ebp+var_4] ; this
.text$mn:00005AC4                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:00005AC9                 mov     ecx, [ebp+var_4]
.text$mn:00005ACC                 mov     edx, [ecx+8]
.text$mn:00005ACF                 mov     ecx, [ebp+arg_0]
.text$mn:00005AD2                 lea     edx, [edx+ecx*4]
.text$mn:00005AD5                 cmp     [eax+8], edx
.text$mn:00005AD8                 jnb     short loc_5B42
.text$mn:00005ADA
.text$mn:00005ADA loc_5ADA:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>::operator+=(int)+12j
.text$mn:00005ADA                                         ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>::operator+=(int)+2Bj
.text$mn:00005ADA                 push    9Fh ; 'ƒ'       ; unsigned int
.text$mn:00005ADF                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00005AE4                 push    offset ??_C@_1EM@FKAOCOMF@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AA?$CL?$AA?5?$AAo?$AAf?$AAf?$AAs?$AAe?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5@ ; "vector iterator + offset out of range"
.text$mn:00005AE9                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00005AEE                 add     esp, 0Ch
.text$mn:00005AF1                 mov     eax, offset ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ ; "Standard C++ Libraries Out of Range"
.text$mn:00005AF6                 test    eax, eax
.text$mn:00005AF8                 jz      short loc_5AFE
.text$mn:00005AFA                 xor     ecx, ecx
.text$mn:00005AFC                 jnz     short loc_5B24
.text$mn:00005AFE
.text$mn:00005AFE loc_5AFE:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>::operator+=(int)+64j
.text$mn:00005AFE                 push    offset ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@ ; "\"Standard C++ Libraries Out of Range\""...
.text$mn:00005B03                 push    offset ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ ; "%s"
.text$mn:00005B08                 push    0
.text$mn:00005B0A                 push    0A0h ; 'á'
.text$mn:00005B0F                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00005B14                 push    2
.text$mn:00005B16                 call    __CrtDbgReportW
.text$mn:00005B1B                 add     esp, 18h
.text$mn:00005B1E                 cmp     eax, 1
.text$mn:00005B21                 jnz     short loc_5B24
.text$mn:00005B23                 int     3               ; Trap to Debugger
.text$mn:00005B24
.text$mn:00005B24 loc_5B24:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>::operator+=(int)+68j
.text$mn:00005B24                                         ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>::operator+=(int)+8Dj
.text$mn:00005B24                 push    0
.text$mn:00005B26                 push    0A0h ; 'á'
.text$mn:00005B2B                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00005B30                 push    offset ??_C@_1PC@LBPAGKOJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ ; "std::_Vector_const_iterator<class std::"...
.text$mn:00005B35                 push    offset ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@ ; "\"out of range\""
.text$mn:00005B3A                 call    __invalid_parameter
.text$mn:00005B3F                 add     esp, 14h
.text$mn:00005B42
.text$mn:00005B42 loc_5B42:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>::operator+=(int)+44j
.text$mn:00005B42                 mov     eax, [ebp+var_4]
.text$mn:00005B45                 mov     ecx, [eax+8]
.text$mn:00005B48                 mov     edx, [ebp+arg_0]
.text$mn:00005B4B                 lea     eax, [ecx+edx*4]
.text$mn:00005B4E                 mov     ecx, [ebp+var_4]
.text$mn:00005B51                 mov     [ecx+8], eax
.text$mn:00005B54                 mov     eax, [ebp+var_4]
.text$mn:00005B57                 pop     esi
.text$mn:00005B58                 mov     esp, ebp
.text$mn:00005B5A                 pop     ebp
.text$mn:00005B5B                 retn    4
.text$mn:00005B5B ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAEAAV01@H@Z endp
.text$mn:00005B5B
.text$mn:00005B5B ; ---------------------------------------------------------------------------
.text$mn:00005B5E                 align 10h
.text$mn:00005B5E _text$mn        ends
.text$mn:00005B5E
.text$mn:00005B60 ; ===========================================================================
.text$mn:00005B60
.text$mn:00005B60 ; Segment type: Pure code
.text$mn:00005B60 ; Segment permissions: Read/Execute
.text$mn:00005B60 _text$mn        segment para public 'CODE' use32
.text$mn:00005B60                 assume cs:_text$mn
.text$mn:00005B60                 ;org 5B60h
.text$mn:00005B60 ; COMDAT (pick any)
.text$mn:00005B60                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005B60
.text$mn:00005B60 ; =============== S U B R O U T I N E =======================================
.text$mn:00005B60
.text$mn:00005B60 ; Attributes: bp-based frame
.text$mn:00005B60
.text$mn:00005B60 ; public: class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>>>> & __thiscall std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>>>>::operator+=(int)
.text$mn:00005B60                 public ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAEAAV01@H@Z
.text$mn:00005B60 ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAEAAV01@H@Z proc near
.text$mn:00005B60                                         ; CODE XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::operator+=(int)+Ep
.text$mn:00005B60
.text$mn:00005B60 var_4           = dword ptr -4
.text$mn:00005B60 arg_0           = dword ptr  8
.text$mn:00005B60
.text$mn:00005B60                 push    ebp
.text$mn:00005B61                 mov     ebp, esp
.text$mn:00005B63                 push    ecx
.text$mn:00005B64                 push    esi
.text$mn:00005B65                 mov     [ebp+var_4], ecx
.text$mn:00005B68                 mov     ecx, [ebp+var_4] ; this
.text$mn:00005B6B                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:00005B70                 test    eax, eax
.text$mn:00005B72                 jz      short loc_5BA6
.text$mn:00005B74                 mov     eax, [ebp+var_4]
.text$mn:00005B77                 mov     ecx, [eax+8]
.text$mn:00005B7A                 mov     edx, [ebp+arg_0]
.text$mn:00005B7D                 lea     esi, [ecx+edx*4]
.text$mn:00005B80                 mov     ecx, [ebp+var_4] ; this
.text$mn:00005B83                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:00005B88                 cmp     esi, [eax+4]
.text$mn:00005B8B                 jb      short loc_5BA6
.text$mn:00005B8D                 mov     ecx, [ebp+var_4] ; this
.text$mn:00005B90                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:00005B95                 mov     ecx, [ebp+var_4]
.text$mn:00005B98                 mov     edx, [ecx+8]
.text$mn:00005B9B                 mov     ecx, [ebp+arg_0]
.text$mn:00005B9E                 lea     edx, [edx+ecx*4]
.text$mn:00005BA1                 cmp     [eax+8], edx
.text$mn:00005BA4                 jnb     short loc_5C0E
.text$mn:00005BA6
.text$mn:00005BA6 loc_5BA6:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::operator+=(int)+12j
.text$mn:00005BA6                                         ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::operator+=(int)+2Bj
.text$mn:00005BA6                 push    9Fh ; 'ƒ'       ; unsigned int
.text$mn:00005BAB                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00005BB0                 push    offset ??_C@_1EM@FKAOCOMF@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AA?$CL?$AA?5?$AAo?$AAf?$AAf?$AAs?$AAe?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5@ ; "vector iterator + offset out of range"
.text$mn:00005BB5                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00005BBA                 add     esp, 0Ch
.text$mn:00005BBD                 mov     eax, offset ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ ; "Standard C++ Libraries Out of Range"
.text$mn:00005BC2                 test    eax, eax
.text$mn:00005BC4                 jz      short loc_5BCA
.text$mn:00005BC6                 xor     ecx, ecx
.text$mn:00005BC8                 jnz     short loc_5BF0
.text$mn:00005BCA
.text$mn:00005BCA loc_5BCA:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::operator+=(int)+64j
.text$mn:00005BCA                 push    offset ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@ ; "\"Standard C++ Libraries Out of Range\""...
.text$mn:00005BCF                 push    offset ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ ; "%s"
.text$mn:00005BD4                 push    0
.text$mn:00005BD6                 push    0A0h ; 'á'
.text$mn:00005BDB                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00005BE0                 push    2
.text$mn:00005BE2                 call    __CrtDbgReportW
.text$mn:00005BE7                 add     esp, 18h
.text$mn:00005BEA                 cmp     eax, 1
.text$mn:00005BED                 jnz     short loc_5BF0
.text$mn:00005BEF                 int     3               ; Trap to Debugger
.text$mn:00005BF0
.text$mn:00005BF0 loc_5BF0:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::operator+=(int)+68j
.text$mn:00005BF0                                         ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::operator+=(int)+8Dj
.text$mn:00005BF0                 push    0
.text$mn:00005BF2                 push    0A0h ; 'á'
.text$mn:00005BF7                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00005BFC                 push    offset ??_C@_1DAI@BKGFFCGA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ ; "std::_Vector_const_iterator<class std::"...
.text$mn:00005C01                 push    offset ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@ ; "\"out of range\""
.text$mn:00005C06                 call    __invalid_parameter
.text$mn:00005C0B                 add     esp, 14h
.text$mn:00005C0E
.text$mn:00005C0E loc_5C0E:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::operator+=(int)+44j
.text$mn:00005C0E                 mov     eax, [ebp+var_4]
.text$mn:00005C11                 mov     ecx, [eax+8]
.text$mn:00005C14                 mov     edx, [ebp+arg_0]
.text$mn:00005C17                 lea     eax, [ecx+edx*4]
.text$mn:00005C1A                 mov     ecx, [ebp+var_4]
.text$mn:00005C1D                 mov     [ecx+8], eax
.text$mn:00005C20                 mov     eax, [ebp+var_4]
.text$mn:00005C23                 pop     esi
.text$mn:00005C24                 mov     esp, ebp
.text$mn:00005C26                 pop     ebp
.text$mn:00005C27                 retn    4
.text$mn:00005C27 ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAEAAV01@H@Z endp
.text$mn:00005C27
.text$mn:00005C27 ; ---------------------------------------------------------------------------
.text$mn:00005C2A                 align 4
.text$mn:00005C2A _text$mn        ends
.text$mn:00005C2A
.text$mn:00005C2C ; ===========================================================================
.text$mn:00005C2C
.text$mn:00005C2C ; Segment type: Pure code
.text$mn:00005C2C ; Segment permissions: Read/Execute
.text$mn:00005C2C _text$mn        segment para public 'CODE' use32
.text$mn:00005C2C                 assume cs:_text$mn
.text$mn:00005C2C                 ;org 5C2Ch
.text$mn:00005C2C ; COMDAT (pick any)
.text$mn:00005C2C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005C2C
.text$mn:00005C2C ; =============== S U B R O U T I N E =======================================
.text$mn:00005C2C
.text$mn:00005C2C ; Attributes: bp-based frame
.text$mn:00005C2C
.text$mn:00005C2C ; public: class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<class ScintillaEditView *>>> & __thiscall std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<class ScintillaEditView *>>>::operator+=(int)
.text$mn:00005C2C                 public ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAEAAV01@H@Z
.text$mn:00005C2C ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAEAAV01@H@Z proc near
.text$mn:00005C2C                                         ; CODE XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>::operator+(int)+49p
.text$mn:00005C2C
.text$mn:00005C2C var_4           = dword ptr -4
.text$mn:00005C2C arg_0           = dword ptr  8
.text$mn:00005C2C
.text$mn:00005C2C                 push    ebp
.text$mn:00005C2D                 mov     ebp, esp
.text$mn:00005C2F                 push    ecx
.text$mn:00005C30                 mov     [ebp+var_4], ecx
.text$mn:00005C33                 mov     eax, [ebp+arg_0]
.text$mn:00005C36                 push    eax
.text$mn:00005C37                 mov     ecx, [ebp+var_4]
.text$mn:00005C3A                 call    ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>::operator+=(int)
.text$mn:00005C3F                 mov     eax, [ebp+var_4]
.text$mn:00005C42                 mov     esp, ebp
.text$mn:00005C44                 pop     ebp
.text$mn:00005C45                 retn    4
.text$mn:00005C45 ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAEAAV01@H@Z endp
.text$mn:00005C45
.text$mn:00005C45 _text$mn        ends
.text$mn:00005C45
.text$mn:00005C48 ; ===========================================================================
.text$mn:00005C48
.text$mn:00005C48 ; Segment type: Pure code
.text$mn:00005C48 ; Segment permissions: Read/Execute
.text$mn:00005C48 _text$mn        segment para public 'CODE' use32
.text$mn:00005C48                 assume cs:_text$mn
.text$mn:00005C48                 ;org 5C48h
.text$mn:00005C48 ; COMDAT (pick any)
.text$mn:00005C48                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005C48
.text$mn:00005C48 ; =============== S U B R O U T I N E =======================================
.text$mn:00005C48
.text$mn:00005C48 ; Attributes: bp-based frame
.text$mn:00005C48
.text$mn:00005C48 ; public: class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>>>> & __thiscall std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>>>>::operator+=(int)
.text$mn:00005C48                 public ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAEAAV01@H@Z
.text$mn:00005C48 ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAEAAV01@H@Z proc near
.text$mn:00005C48                                         ; CODE XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::operator+(int)+49p
.text$mn:00005C48
.text$mn:00005C48 var_4           = dword ptr -4
.text$mn:00005C48 arg_0           = dword ptr  8
.text$mn:00005C48
.text$mn:00005C48                 push    ebp
.text$mn:00005C49                 mov     ebp, esp
.text$mn:00005C4B                 push    ecx
.text$mn:00005C4C                 mov     [ebp+var_4], ecx
.text$mn:00005C4F                 mov     eax, [ebp+arg_0]
.text$mn:00005C52                 push    eax
.text$mn:00005C53                 mov     ecx, [ebp+var_4]
.text$mn:00005C56                 call    ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::operator+=(int)
.text$mn:00005C5B                 mov     eax, [ebp+var_4]
.text$mn:00005C5E                 mov     esp, ebp
.text$mn:00005C60                 pop     ebp
.text$mn:00005C61                 retn    4
.text$mn:00005C61 ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAEAAV01@H@Z endp
.text$mn:00005C61
.text$mn:00005C61 _text$mn        ends
.text$mn:00005C61
.text$mn:00005C64 ; ===========================================================================
.text$mn:00005C64
.text$mn:00005C64 ; Segment type: Pure code
.text$mn:00005C64 ; Segment permissions: Read/Execute
.text$mn:00005C64 _text$mn        segment para public 'CODE' use32
.text$mn:00005C64                 assume cs:_text$mn
.text$mn:00005C64                 ;org 5C64h
.text$mn:00005C64 ; COMDAT (pick any)
.text$mn:00005C64                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005C64
.text$mn:00005C64 ; =============== S U B R O U T I N E =======================================
.text$mn:00005C64
.text$mn:00005C64 ; Attributes: bp-based frame
.text$mn:00005C64
.text$mn:00005C64 ; public: void * __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::`scalar deleting destructor'(unsigned int)
.text$mn:00005C64                 public ??_G?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEPAXI@Z
.text$mn:00005C64 ??_G?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEPAXI@Z proc near
.text$mn:00005C64                                         ; CODE XREF: Style::~Style(void)+2Cp
.text$mn:00005C64
.text$mn:00005C64 var_4           = dword ptr -4
.text$mn:00005C64 arg_0           = dword ptr  8
.text$mn:00005C64
.text$mn:00005C64                 push    ebp
.text$mn:00005C65                 mov     ebp, esp
.text$mn:00005C67                 push    ecx
.text$mn:00005C68                 mov     [ebp+var_4], ecx
.text$mn:00005C6B                 mov     ecx, [ebp+var_4]
.text$mn:00005C6E                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00005C73                 mov     eax, [ebp+arg_0]
.text$mn:00005C76                 and     eax, 1
.text$mn:00005C79                 jz      short loc_5C87
.text$mn:00005C7B                 mov     ecx, [ebp+var_4]
.text$mn:00005C7E                 push    ecx             ; void *
.text$mn:00005C7F                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00005C84                 add     esp, 4
.text$mn:00005C87
.text$mn:00005C87 loc_5C87:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::`scalar deleting destructor'(uint)+15j
.text$mn:00005C87                 mov     eax, [ebp+var_4]
.text$mn:00005C8A                 mov     esp, ebp
.text$mn:00005C8C                 pop     ebp
.text$mn:00005C8D                 retn    4
.text$mn:00005C8D ??_G?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEPAXI@Z endp
.text$mn:00005C8D
.text$mn:00005C8D _text$mn        ends
.text$mn:00005C8D
.text$mn:00005C90 ; ===========================================================================
.text$mn:00005C90
.text$mn:00005C90 ; Segment type: Pure code
.text$mn:00005C90 ; Segment permissions: Read/Execute
.text$mn:00005C90 _text$mn        segment para public 'CODE' use32
.text$mn:00005C90                 assume cs:_text$mn
.text$mn:00005C90                 ;org 5C90h
.text$mn:00005C90 ; COMDAT (pick any)
.text$mn:00005C90                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005C90
.text$mn:00005C90 ; =============== S U B R O U T I N E =======================================
.text$mn:00005C90
.text$mn:00005C90 ; Attributes: bp-based frame
.text$mn:00005C90
.text$mn:00005C90 ; public: void * __thiscall std::pair<int const, struct Style>::`scalar deleting destructor'(unsigned int)
.text$mn:00005C90                 public ??_G?$pair@$$CBHUStyle@@@std@@QAEPAXI@Z
.text$mn:00005C90 ??_G?$pair@$$CBHUStyle@@@std@@QAEPAXI@Z proc near
.text$mn:00005C90                                         ; CODE XREF: std::allocator<std::_List_node<std::pair<int const,Style>,void *>>::destroy<std::pair<int const,Style>>(std::pair<int const,Style> *)+Cp
.text$mn:00005C90
.text$mn:00005C90 var_4           = dword ptr -4
.text$mn:00005C90 arg_0           = dword ptr  8
.text$mn:00005C90
.text$mn:00005C90                 push    ebp
.text$mn:00005C91                 mov     ebp, esp
.text$mn:00005C93                 push    ecx
.text$mn:00005C94                 mov     [ebp+var_4], ecx
.text$mn:00005C97                 mov     ecx, [ebp+var_4]
.text$mn:00005C9A                 call    ??1?$pair@$$CBHUStyle@@@std@@QAE@XZ ; std::pair<int const,Style>::~pair<int const,Style>(void)
.text$mn:00005C9F                 mov     eax, [ebp+arg_0]
.text$mn:00005CA2                 and     eax, 1
.text$mn:00005CA5                 jz      short loc_5CB3
.text$mn:00005CA7                 mov     ecx, [ebp+var_4]
.text$mn:00005CAA                 push    ecx             ; void *
.text$mn:00005CAB                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00005CB0                 add     esp, 4
.text$mn:00005CB3
.text$mn:00005CB3 loc_5CB3:                               ; CODE XREF: std::pair<int const,Style>::`scalar deleting destructor'(uint)+15j
.text$mn:00005CB3                 mov     eax, [ebp+var_4]
.text$mn:00005CB6                 mov     esp, ebp
.text$mn:00005CB8                 pop     ebp
.text$mn:00005CB9                 retn    4
.text$mn:00005CB9 ??_G?$pair@$$CBHUStyle@@@std@@QAEPAXI@Z endp
.text$mn:00005CB9
.text$mn:00005CB9 _text$mn        ends
.text$mn:00005CB9
.text$mn:00005CBC ; ===========================================================================
.text$mn:00005CBC
.text$mn:00005CBC ; Segment type: Pure code
.text$mn:00005CBC ; Segment permissions: Read/Execute
.text$mn:00005CBC _text$mn        segment para public 'CODE' use32
.text$mn:00005CBC                 assume cs:_text$mn
.text$mn:00005CBC                 ;org 5CBCh
.text$mn:00005CBC ; COMDAT (pick any)
.text$mn:00005CBC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005CBC
.text$mn:00005CBC ; =============== S U B R O U T I N E =======================================
.text$mn:00005CBC
.text$mn:00005CBC ; Attributes: bp-based frame
.text$mn:00005CBC
.text$mn:00005CBC ; public: void * __thiscall std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>>::`scalar deleting destructor'(unsigned int)
.text$mn:00005CBC                 public ??_G?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@QAEPAXI@Z
.text$mn:00005CBC ??_G?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@QAEPAXI@Z proc near
.text$mn:00005CBC                                         ; CODE XREF: ScintillaEditView::~ScintillaEditView(void)+182p
.text$mn:00005CBC
.text$mn:00005CBC var_4           = dword ptr -4
.text$mn:00005CBC arg_0           = dword ptr  8
.text$mn:00005CBC
.text$mn:00005CBC                 push    ebp
.text$mn:00005CBD                 mov     ebp, esp
.text$mn:00005CBF                 push    ecx
.text$mn:00005CC0                 mov     [ebp+var_4], ecx
.text$mn:00005CC3                 mov     ecx, [ebp+var_4]
.text$mn:00005CC6                 call    ??1?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@QAE@XZ ; std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>>::~unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>>(void)
.text$mn:00005CCB                 mov     eax, [ebp+arg_0]
.text$mn:00005CCE                 and     eax, 1
.text$mn:00005CD1                 jz      short loc_5CDF
.text$mn:00005CD3                 mov     ecx, [ebp+var_4]
.text$mn:00005CD6                 push    ecx             ; void *
.text$mn:00005CD7                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00005CDC                 add     esp, 4
.text$mn:00005CDF
.text$mn:00005CDF loc_5CDF:                               ; CODE XREF: std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>>::`scalar deleting destructor'(uint)+15j
.text$mn:00005CDF                 mov     eax, [ebp+var_4]
.text$mn:00005CE2                 mov     esp, ebp
.text$mn:00005CE4                 pop     ebp
.text$mn:00005CE5                 retn    4
.text$mn:00005CE5 ??_G?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@QAEPAXI@Z endp
.text$mn:00005CE5
.text$mn:00005CE5 _text$mn        ends
.text$mn:00005CE5
.text$mn:00005CE8 ; ===========================================================================
.text$mn:00005CE8
.text$mn:00005CE8 ; Segment type: Pure code
.text$mn:00005CE8 ; Segment permissions: Read/Execute
.text$mn:00005CE8 _text$mn        segment para public 'CODE' use32
.text$mn:00005CE8                 assume cs:_text$mn
.text$mn:00005CE8                 ;org 5CE8h
.text$mn:00005CE8 ; COMDAT (pick any)
.text$mn:00005CE8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005CE8
.text$mn:00005CE8 ; =============== S U B R O U T I N E =======================================
.text$mn:00005CE8
.text$mn:00005CE8 ; Attributes: bp-based frame
.text$mn:00005CE8
.text$mn:00005CE8 ; public: virtual void * __thiscall ScintillaEditView::`scalar deleting destructor'(unsigned int)
.text$mn:00005CE8                 public ??_GScintillaEditView@@UAEPAXI@Z
.text$mn:00005CE8 ??_GScintillaEditView@@UAEPAXI@Z proc near
.text$mn:00005CE8
.text$mn:00005CE8 var_4           = dword ptr -4
.text$mn:00005CE8 arg_0           = dword ptr  8
.text$mn:00005CE8
.text$mn:00005CE8                 push    ebp
.text$mn:00005CE9                 mov     ebp, esp
.text$mn:00005CEB                 push    ecx
.text$mn:00005CEC                 mov     [ebp+var_4], ecx
.text$mn:00005CEF                 mov     ecx, [ebp+var_4] ; this
.text$mn:00005CF2                 call    ??1ScintillaEditView@@UAE@XZ ; ScintillaEditView::~ScintillaEditView(void)
.text$mn:00005CF7                 mov     eax, [ebp+arg_0]
.text$mn:00005CFA                 and     eax, 1
.text$mn:00005CFD                 jz      short loc_5D0B
.text$mn:00005CFF                 mov     ecx, [ebp+var_4]
.text$mn:00005D02                 push    ecx             ; void *
.text$mn:00005D03                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00005D08                 add     esp, 4
.text$mn:00005D0B
.text$mn:00005D0B loc_5D0B:                               ; CODE XREF: ScintillaEditView::`scalar deleting destructor'(uint)+15j
.text$mn:00005D0B                 mov     eax, [ebp+var_4]
.text$mn:00005D0E                 mov     esp, ebp
.text$mn:00005D10                 pop     ebp
.text$mn:00005D11                 retn    4
.text$mn:00005D11 ??_GScintillaEditView@@UAEPAXI@Z endp
.text$mn:00005D11
.text$mn:00005D11 _text$mn        ends
.text$mn:00005D11
.text$mn:00005D14 ; ===========================================================================
.text$mn:00005D14
.text$mn:00005D14 ; Segment type: Pure code
.text$mn:00005D14 ; Segment permissions: Read/Execute
.text$mn:00005D14 _text$mn        segment para public 'CODE' use32
.text$mn:00005D14                 assume cs:_text$mn
.text$mn:00005D14                 ;org 5D14h
.text$mn:00005D14 ; COMDAT (pick any)
.text$mn:00005D14                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005D14
.text$mn:00005D14 ; =============== S U B R O U T I N E =======================================
.text$mn:00005D14
.text$mn:00005D14 ; Attributes: bp-based frame
.text$mn:00005D14
.text$mn:00005D14 ; public: virtual void * __thiscall Window::`scalar deleting destructor'(unsigned int)
.text$mn:00005D14                 public ??_GWindow@@UAEPAXI@Z
.text$mn:00005D14 ??_GWindow@@UAEPAXI@Z proc near
.text$mn:00005D14
.text$mn:00005D14 var_4           = dword ptr -4
.text$mn:00005D14 arg_0           = dword ptr  8
.text$mn:00005D14
.text$mn:00005D14                 push    ebp
.text$mn:00005D15                 mov     ebp, esp
.text$mn:00005D17                 push    ecx
.text$mn:00005D18                 mov     [ebp+var_4], ecx
.text$mn:00005D1B                 mov     ecx, [ebp+var_4] ; this
.text$mn:00005D1E                 call    ??1Window@@UAE@XZ ; Window::~Window(void)
.text$mn:00005D23                 mov     eax, [ebp+arg_0]
.text$mn:00005D26                 and     eax, 1
.text$mn:00005D29                 jz      short loc_5D37
.text$mn:00005D2B                 mov     ecx, [ebp+var_4]
.text$mn:00005D2E                 push    ecx             ; void *
.text$mn:00005D2F                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00005D34                 add     esp, 4
.text$mn:00005D37
.text$mn:00005D37 loc_5D37:                               ; CODE XREF: Window::`scalar deleting destructor'(uint)+15j
.text$mn:00005D37                 mov     eax, [ebp+var_4]
.text$mn:00005D3A                 mov     esp, ebp
.text$mn:00005D3C                 pop     ebp
.text$mn:00005D3D                 retn    4
.text$mn:00005D3D ??_GWindow@@UAEPAXI@Z endp
.text$mn:00005D3D
.text$mn:00005D3D _text$mn        ends
.text$mn:00005D3D
.text$mn:00005D40 ; ===========================================================================
.text$mn:00005D40
.text$mn:00005D40 ; Segment type: Pure code
.text$mn:00005D40 ; Segment permissions: Read/Execute
.text$mn:00005D40 _text$mn        segment para public 'CODE' use32
.text$mn:00005D40                 assume cs:_text$mn
.text$mn:00005D40                 ;org 5D40h
.text$mn:00005D40 ; COMDAT (pick any)
.text$mn:00005D40                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005D40
.text$mn:00005D40 ; =============== S U B R O U T I N E =======================================
.text$mn:00005D40
.text$mn:00005D40 ; Attributes: bp-based frame
.text$mn:00005D40
.text$mn:00005D40 ; public: virtual void * __thiscall std::_Generic_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00005D40                 public ??_G_Generic_error_category@std@@UAEPAXI@Z
.text$mn:00005D40 ??_G_Generic_error_category@std@@UAEPAXI@Z proc near
.text$mn:00005D40
.text$mn:00005D40 var_4           = dword ptr -4
.text$mn:00005D40 arg_0           = dword ptr  8
.text$mn:00005D40
.text$mn:00005D40                 push    ebp
.text$mn:00005D41                 mov     ebp, esp
.text$mn:00005D43                 push    ecx
.text$mn:00005D44                 mov     [ebp+var_4], ecx
.text$mn:00005D47                 mov     ecx, [ebp+var_4] ; this
.text$mn:00005D4A                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:00005D4F                 mov     eax, [ebp+arg_0]
.text$mn:00005D52                 and     eax, 1
.text$mn:00005D55                 jz      short loc_5D63
.text$mn:00005D57                 mov     ecx, [ebp+var_4]
.text$mn:00005D5A                 push    ecx             ; void *
.text$mn:00005D5B                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00005D60                 add     esp, 4
.text$mn:00005D63
.text$mn:00005D63 loc_5D63:                               ; CODE XREF: std::_Generic_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00005D63                 mov     eax, [ebp+var_4]
.text$mn:00005D66                 mov     esp, ebp
.text$mn:00005D68                 pop     ebp
.text$mn:00005D69                 retn    4
.text$mn:00005D69 ??_G_Generic_error_category@std@@UAEPAXI@Z endp
.text$mn:00005D69
.text$mn:00005D69 _text$mn        ends
.text$mn:00005D69
.text$mn:00005D6C ; ===========================================================================
.text$mn:00005D6C
.text$mn:00005D6C ; Segment type: Pure code
.text$mn:00005D6C ; Segment permissions: Read/Execute
.text$mn:00005D6C _text$mn        segment para public 'CODE' use32
.text$mn:00005D6C                 assume cs:_text$mn
.text$mn:00005D6C                 ;org 5D6Ch
.text$mn:00005D6C ; COMDAT (pick any)
.text$mn:00005D6C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005D6C
.text$mn:00005D6C ; =============== S U B R O U T I N E =======================================
.text$mn:00005D6C
.text$mn:00005D6C ; Attributes: bp-based frame
.text$mn:00005D6C
.text$mn:00005D6C ; public: virtual void * __thiscall std::_Iostream_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00005D6C                 public ??_G_Iostream_error_category@std@@UAEPAXI@Z
.text$mn:00005D6C ??_G_Iostream_error_category@std@@UAEPAXI@Z proc near
.text$mn:00005D6C
.text$mn:00005D6C var_4           = dword ptr -4
.text$mn:00005D6C arg_0           = dword ptr  8
.text$mn:00005D6C
.text$mn:00005D6C                 push    ebp
.text$mn:00005D6D                 mov     ebp, esp
.text$mn:00005D6F                 push    ecx
.text$mn:00005D70                 mov     [ebp+var_4], ecx
.text$mn:00005D73                 mov     ecx, [ebp+var_4] ; this
.text$mn:00005D76                 call    ??1_Iostream_error_category@std@@UAE@XZ ; std::_Iostream_error_category::~_Iostream_error_category(void)
.text$mn:00005D7B                 mov     eax, [ebp+arg_0]
.text$mn:00005D7E                 and     eax, 1
.text$mn:00005D81                 jz      short loc_5D8F
.text$mn:00005D83                 mov     ecx, [ebp+var_4]
.text$mn:00005D86                 push    ecx             ; void *
.text$mn:00005D87                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00005D8C                 add     esp, 4
.text$mn:00005D8F
.text$mn:00005D8F loc_5D8F:                               ; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00005D8F                 mov     eax, [ebp+var_4]
.text$mn:00005D92                 mov     esp, ebp
.text$mn:00005D94                 pop     ebp
.text$mn:00005D95                 retn    4
.text$mn:00005D95 ??_G_Iostream_error_category@std@@UAEPAXI@Z endp
.text$mn:00005D95
.text$mn:00005D95 _text$mn        ends
.text$mn:00005D95
.text$mn:00005D98 ; ===========================================================================
.text$mn:00005D98
.text$mn:00005D98 ; Segment type: Pure code
.text$mn:00005D98 ; Segment permissions: Read/Execute
.text$mn:00005D98 _text$mn        segment para public 'CODE' use32
.text$mn:00005D98                 assume cs:_text$mn
.text$mn:00005D98                 ;org 5D98h
.text$mn:00005D98 ; COMDAT (pick any)
.text$mn:00005D98                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005D98
.text$mn:00005D98 ; =============== S U B R O U T I N E =======================================
.text$mn:00005D98
.text$mn:00005D98 ; Attributes: bp-based frame
.text$mn:00005D98
.text$mn:00005D98 ; public: virtual void * __thiscall std::_System_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00005D98                 public ??_G_System_error_category@std@@UAEPAXI@Z
.text$mn:00005D98 ??_G_System_error_category@std@@UAEPAXI@Z proc near
.text$mn:00005D98
.text$mn:00005D98 var_4           = dword ptr -4
.text$mn:00005D98 arg_0           = dword ptr  8
.text$mn:00005D98
.text$mn:00005D98                 push    ebp
.text$mn:00005D99                 mov     ebp, esp
.text$mn:00005D9B                 push    ecx
.text$mn:00005D9C                 mov     [ebp+var_4], ecx
.text$mn:00005D9F                 mov     ecx, [ebp+var_4] ; this
.text$mn:00005DA2                 call    ??1_System_error_category@std@@UAE@XZ ; std::_System_error_category::~_System_error_category(void)
.text$mn:00005DA7                 mov     eax, [ebp+arg_0]
.text$mn:00005DAA                 and     eax, 1
.text$mn:00005DAD                 jz      short loc_5DBB
.text$mn:00005DAF                 mov     ecx, [ebp+var_4]
.text$mn:00005DB2                 push    ecx             ; void *
.text$mn:00005DB3                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00005DB8                 add     esp, 4
.text$mn:00005DBB
.text$mn:00005DBB loc_5DBB:                               ; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00005DBB                 mov     eax, [ebp+var_4]
.text$mn:00005DBE                 mov     esp, ebp
.text$mn:00005DC0                 pop     ebp
.text$mn:00005DC1                 retn    4
.text$mn:00005DC1 ??_G_System_error_category@std@@UAEPAXI@Z endp
.text$mn:00005DC1
.text$mn:00005DC1 _text$mn        ends
.text$mn:00005DC1
.text$mn:00005DC4 ; ===========================================================================
.text$mn:00005DC4
.text$mn:00005DC4 ; Segment type: Pure code
.text$mn:00005DC4 ; Segment permissions: Read/Execute
.text$mn:00005DC4 _text$mn        segment para public 'CODE' use32
.text$mn:00005DC4                 assume cs:_text$mn
.text$mn:00005DC4                 ;org 5DC4h
.text$mn:00005DC4 ; COMDAT (pick any)
.text$mn:00005DC4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005DC4
.text$mn:00005DC4 ; =============== S U B R O U T I N E =======================================
.text$mn:00005DC4
.text$mn:00005DC4 ; Attributes: bp-based frame
.text$mn:00005DC4
.text$mn:00005DC4 ; public: virtual void * __thiscall std::error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00005DC4                 public ??_Gerror_category@std@@UAEPAXI@Z
.text$mn:00005DC4 ??_Gerror_category@std@@UAEPAXI@Z proc near
.text$mn:00005DC4
.text$mn:00005DC4 var_4           = dword ptr -4
.text$mn:00005DC4 arg_0           = dword ptr  8
.text$mn:00005DC4
.text$mn:00005DC4                 push    ebp
.text$mn:00005DC5                 mov     ebp, esp
.text$mn:00005DC7                 push    ecx
.text$mn:00005DC8                 mov     [ebp+var_4], ecx
.text$mn:00005DCB                 mov     ecx, [ebp+var_4] ; this
.text$mn:00005DCE                 call    ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$mn:00005DD3                 mov     eax, [ebp+arg_0]
.text$mn:00005DD6                 and     eax, 1
.text$mn:00005DD9                 jz      short loc_5DE7
.text$mn:00005DDB                 mov     ecx, [ebp+var_4]
.text$mn:00005DDE                 push    ecx             ; void *
.text$mn:00005DDF                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00005DE4                 add     esp, 4
.text$mn:00005DE7
.text$mn:00005DE7 loc_5DE7:                               ; CODE XREF: std::error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00005DE7                 mov     eax, [ebp+var_4]
.text$mn:00005DEA                 mov     esp, ebp
.text$mn:00005DEC                 pop     ebp
.text$mn:00005DED                 retn    4
.text$mn:00005DED ??_Gerror_category@std@@UAEPAXI@Z endp
.text$mn:00005DED
.text$mn:00005DED _text$mn        ends
.text$mn:00005DED
.text$di:00005DF0 ; ===========================================================================
.text$di:00005DF0
.text$di:00005DF0 ; Segment type: Pure code
.text$di:00005DF0 ; Segment permissions: Read/Execute
.text$di:00005DF0 _text$di        segment para public 'CODE' use32
.text$di:00005DF0                 assume cs:_text$di
.text$di:00005DF0                 ;org 5DF0h
.text$di:00005DF0 ; COMDAT (pick any)
.text$di:00005DF0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00005DF0
.text$di:00005DF0 ; =============== S U B R O U T I N E =======================================
.text$di:00005DF0
.text$di:00005DF0 ; Attributes: bp-based frame
.text$di:00005DF0
.text$di:00005DF0 ; void __cdecl `dynamic initializer for 'public: static class std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
.text$di:00005DF0 ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc near
.text$di:00005DF0                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Generic_object$initializer$)(void)o
.text$di:00005DF0                 push    ebp
.text$di:00005DF1                 mov     ebp, esp
.text$di:00005DF3                 mov     ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
.text$di:00005DF8                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$di:00005DFD                 push    offset ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:00005E02                 call    _atexit
.text$di:00005E07                 add     esp, 4
.text$di:00005E0A                 pop     ebp
.text$di:00005E0B                 retn
.text$di:00005E0B ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp
.text$di:00005E0B
.text$di:00005E0B _text$di        ends
.text$di:00005E0B
.text$di:00005E0C ; ===========================================================================
.text$di:00005E0C
.text$di:00005E0C ; Segment type: Pure code
.text$di:00005E0C ; Segment permissions: Read/Execute
.text$di:00005E0C _text$di        segment para public 'CODE' use32
.text$di:00005E0C                 assume cs:_text$di
.text$di:00005E0C                 ;org 5E0Ch
.text$di:00005E0C ; COMDAT (pick any)
.text$di:00005E0C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00005E0C
.text$di:00005E0C ; =============== S U B R O U T I N E =======================================
.text$di:00005E0C
.text$di:00005E0C ; Attributes: bp-based frame
.text$di:00005E0C
.text$di:00005E0C ; void __cdecl `dynamic initializer for 'public: static class std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
.text$di:00005E0C ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
.text$di:00005E0C                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Iostream_object$initializer$)(void)o
.text$di:00005E0C                 push    ebp
.text$di:00005E0D                 mov     ebp, esp
.text$di:00005E0F                 mov     ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
.text$di:00005E14                 call    ??0_Iostream_error_category@std@@QAE@XZ ; std::_Iostream_error_category::_Iostream_error_category(void)
.text$di:00005E19                 push    offset ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:00005E1E                 call    _atexit
.text$di:00005E23                 add     esp, 4
.text$di:00005E26                 pop     ebp
.text$di:00005E27                 retn
.text$di:00005E27 ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp
.text$di:00005E27
.text$di:00005E27 _text$di        ends
.text$di:00005E27
.text$di:00005E28 ; ===========================================================================
.text$di:00005E28
.text$di:00005E28 ; Segment type: Pure code
.text$di:00005E28 ; Segment permissions: Read/Execute
.text$di:00005E28 _text$di        segment para public 'CODE' use32
.text$di:00005E28                 assume cs:_text$di
.text$di:00005E28                 ;org 5E28h
.text$di:00005E28 ; COMDAT (pick any)
.text$di:00005E28                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00005E28
.text$di:00005E28 ; =============== S U B R O U T I N E =======================================
.text$di:00005E28
.text$di:00005E28 ; Attributes: bp-based frame
.text$di:00005E28
.text$di:00005E28 ; void __cdecl `dynamic initializer for 'public: static class std::_System_error_category std::_Error_objects<int>::_System_object''(void)
.text$di:00005E28 ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
.text$di:00005E28                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_System_object$initializer$)(void)o
.text$di:00005E28                 push    ebp
.text$di:00005E29                 mov     ebp, esp
.text$di:00005E2B                 mov     ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
.text$di:00005E30                 call    ??0_System_error_category@std@@QAE@XZ ; std::_System_error_category::_System_error_category(void)
.text$di:00005E35                 push    offset ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:00005E3A                 call    _atexit
.text$di:00005E3F                 add     esp, 4
.text$di:00005E42                 pop     ebp
.text$di:00005E43                 retn
.text$di:00005E43 ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp
.text$di:00005E43
.text$di:00005E43 _text$di        ends
.text$di:00005E43
.text$di:00005E44 ; ===========================================================================
.text$di:00005E44
.text$di:00005E44 ; Segment type: Pure code
.text$di:00005E44 ; Segment permissions: Read/Execute
.text$di:00005E44 _text$di        segment para public 'CODE' use32
.text$di:00005E44                 assume cs:_text$di
.text$di:00005E44                 ;org 5E44h
.text$di:00005E44 ; COMDAT (pick any)
.text$di:00005E44                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00005E44
.text$di:00005E44 ; =============== S U B R O U T I N E =======================================
.text$di:00005E44
.text$di:00005E44 ; Attributes: bp-based frame
.text$di:00005E44
.text$di:00005E44 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::num_put<char, class std::back_insert_iterator<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>::id''(void)
.text$di:00005E44 ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00005E44                                         ; DATA XREF: .CRT$XCU:void (*std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id$initializer$)(void)o
.text$di:00005E44                 push    ebp
.text$di:00005E45                 mov     ebp, esp
.text$di:00005E47                 push    0               ; unsigned int
.text$di:00005E49                 mov     ecx, offset ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; this
.text$di:00005E4E                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00005E53                 pop     ebp
.text$di:00005E54                 retn
.text$di:00005E54 ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00005E54
.text$di:00005E54 ; ---------------------------------------------------------------------------
.text$di:00005E55                 align 4
.text$di:00005E55 _text$di        ends
.text$di:00005E55
.text$di:00005E58 ; ===========================================================================
.text$di:00005E58
.text$di:00005E58 ; Segment type: Pure code
.text$di:00005E58 ; Segment permissions: Read/Execute
.text$di:00005E58 _text$di        segment para public 'CODE' use32
.text$di:00005E58                 assume cs:_text$di
.text$di:00005E58                 ;org 5E58h
.text$di:00005E58 ; COMDAT (pick any)
.text$di:00005E58                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00005E58
.text$di:00005E58 ; =============== S U B R O U T I N E =======================================
.text$di:00005E58
.text$di:00005E58 ; Attributes: bp-based frame
.text$di:00005E58
.text$di:00005E58 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::num_put<wchar_t, class std::back_insert_iterator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::id''(void)
.text$di:00005E58 ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00005E58                                         ; DATA XREF: .CRT$XCU:void (*std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id$initializer$)(void)o
.text$di:00005E58                 push    ebp
.text$di:00005E59                 mov     ebp, esp
.text$di:00005E5B                 push    0               ; unsigned int
.text$di:00005E5D                 mov     ecx, offset ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; this
.text$di:00005E62                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00005E67                 pop     ebp
.text$di:00005E68                 retn
.text$di:00005E68 ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00005E68
.text$di:00005E68 ; ---------------------------------------------------------------------------
.text$di:00005E69                 align 4
.text$di:00005E69 _text$di        ends
.text$di:00005E69
.text$di:00005E6C ; ===========================================================================
.text$di:00005E6C
.text$di:00005E6C ; Segment type: Pure code
.text$di:00005E6C ; Segment permissions: Read/Execute
.text$di:00005E6C _text$di        segment para public 'CODE' use32
.text$di:00005E6C                 assume cs:_text$di
.text$di:00005E6C                 ;org 5E6Ch
.text$di:00005E6C ; COMDAT (pick any)
.text$di:00005E6C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00005E6C
.text$di:00005E6C ; =============== S U B R O U T I N E =======================================
.text$di:00005E6C
.text$di:00005E6C ; Attributes: bp-based frame
.text$di:00005E6C
.text$di:00005E6C ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::numpunct<char>::id''(void)
.text$di:00005E6C ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00005E6C                                         ; DATA XREF: .CRT$XCU:void (*std::numpunct<char>::id$initializer$)(void)o
.text$di:00005E6C                 push    ebp
.text$di:00005E6D                 mov     ebp, esp
.text$di:00005E6F                 push    0               ; unsigned int
.text$di:00005E71                 mov     ecx, offset ?id@?$numpunct@D@std@@2V0locale@2@A ; this
.text$di:00005E76                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00005E7B                 pop     ebp
.text$di:00005E7C                 retn
.text$di:00005E7C ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00005E7C
.text$di:00005E7C ; ---------------------------------------------------------------------------
.text$di:00005E7D                 align 10h
.text$di:00005E7D _text$di        ends
.text$di:00005E7D
.text$di:00005E80 ; ===========================================================================
.text$di:00005E80
.text$di:00005E80 ; Segment type: Pure code
.text$di:00005E80 ; Segment permissions: Read/Execute
.text$di:00005E80 _text$di        segment para public 'CODE' use32
.text$di:00005E80                 assume cs:_text$di
.text$di:00005E80                 ;org 5E80h
.text$di:00005E80 ; COMDAT (pick any)
.text$di:00005E80                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00005E80
.text$di:00005E80 ; =============== S U B R O U T I N E =======================================
.text$di:00005E80
.text$di:00005E80 ; Attributes: bp-based frame
.text$di:00005E80
.text$di:00005E80 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::numpunct<wchar_t>::id''(void)
.text$di:00005E80 ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00005E80                                         ; DATA XREF: .CRT$XCU:void (*std::numpunct<wchar_t>::id$initializer$)(void)o
.text$di:00005E80                 push    ebp
.text$di:00005E81                 mov     ebp, esp
.text$di:00005E83                 push    0               ; unsigned int
.text$di:00005E85                 mov     ecx, offset ?id@?$numpunct@_W@std@@2V0locale@2@A ; this
.text$di:00005E8A                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00005E8F                 pop     ebp
.text$di:00005E90                 retn
.text$di:00005E90 ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00005E90
.text$di:00005E90 ; ---------------------------------------------------------------------------
.text$di:00005E91                 align 4
.text$di:00005E91 _text$di        ends
.text$di:00005E91
.text$di:00005E94 ; ===========================================================================
.text$di:00005E94
.text$di:00005E94 ; Segment type: Pure code
.text$di:00005E94 ; Segment permissions: Read/Execute
.text$di:00005E94 _text$di        segment para public 'CODE' use32
.text$di:00005E94                 assume cs:_text$di
.text$di:00005E94                 ;org 5E94h
.text$di:00005E94 ; COMDAT (pick any)
.text$di:00005E94                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00005E94
.text$di:00005E94 ; =============== S U B R O U T I N E =======================================
.text$di:00005E94
.text$di:00005E94 ; Attributes: bp-based frame
.text$di:00005E94
.text$di:00005E94 ; void __cdecl std::`dynamic initializer for '_Tuple_alloc''(void)
.text$di:00005E94 ??__E_Tuple_alloc@std@@YAXXZ proc near  ; DATA XREF: .CRT$XCU:__Tuple_alloc$initializer$o
.text$di:00005E94
.text$di:00005E94 var_1           = byte ptr -1
.text$di:00005E94
.text$di:00005E94                 push    ebp
.text$di:00005E95                 mov     ebp, esp
.text$di:00005E97                 push    ecx
.text$di:00005E98                 xor     eax, eax
.text$di:00005E9A                 mov     [ebp+var_1], al
.text$di:00005E9D                 mov     esp, ebp
.text$di:00005E9F                 pop     ebp
.text$di:00005EA0                 retn
.text$di:00005EA0 ??__E_Tuple_alloc@std@@YAXXZ endp
.text$di:00005EA0
.text$di:00005EA0 ; ---------------------------------------------------------------------------
.text$di:00005EA1                 align 4
.text$di:00005EA1 _text$di        ends
.text$di:00005EA1
.text$di:00005EA4 ; ===========================================================================
.text$di:00005EA4
.text$di:00005EA4 ; Segment type: Pure code
.text$di:00005EA4 ; Segment permissions: Read/Execute
.text$di:00005EA4 _text$di        segment para public 'CODE' use32
.text$di:00005EA4                 assume cs:_text$di
.text$di:00005EA4                 ;org 5EA4h
.text$di:00005EA4 ; COMDAT (pick any)
.text$di:00005EA4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00005EA4
.text$di:00005EA4 ; =============== S U B R O U T I N E =======================================
.text$di:00005EA4
.text$di:00005EA4 ; Attributes: bp-based frame
.text$di:00005EA4
.text$di:00005EA4 ; void __cdecl std::`dynamic initializer for 'allocator_arg''(void)
.text$di:00005EA4 ??__Eallocator_arg@std@@YAXXZ proc near ; DATA XREF: .CRT$XCU:_allocator_arg$initializer$o
.text$di:00005EA4
.text$di:00005EA4 var_1           = byte ptr -1
.text$di:00005EA4
.text$di:00005EA4                 push    ebp
.text$di:00005EA5                 mov     ebp, esp
.text$di:00005EA7                 push    ecx
.text$di:00005EA8                 xor     eax, eax
.text$di:00005EAA                 mov     [ebp+var_1], al
.text$di:00005EAD                 mov     esp, ebp
.text$di:00005EAF                 pop     ebp
.text$di:00005EB0                 retn
.text$di:00005EB0 ??__Eallocator_arg@std@@YAXXZ endp
.text$di:00005EB0
.text$di:00005EB0 ; ---------------------------------------------------------------------------
.text$di:00005EB1                 align 4
.text$di:00005EB1 _text$di        ends
.text$di:00005EB1
.text$di:00005EB4 ; ===========================================================================
.text$di:00005EB4
.text$di:00005EB4 ; Segment type: Pure code
.text$di:00005EB4 ; Segment permissions: Read/Execute
.text$di:00005EB4 _text$di        segment para public 'CODE' use32
.text$di:00005EB4                 assume cs:_text$di
.text$di:00005EB4                 ;org 5EB4h
.text$di:00005EB4 ; COMDAT (pick any)
.text$di:00005EB4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00005EB4
.text$di:00005EB4 ; =============== S U B R O U T I N E =======================================
.text$di:00005EB4
.text$di:00005EB4 ; Attributes: bp-based frame
.text$di:00005EB4
.text$di:00005EB4 ; void __cdecl std::`dynamic initializer for 'ignore''(void)
.text$di:00005EB4 ??__Eignore@std@@YAXXZ proc near        ; DATA XREF: .CRT$XCU:_ignore$initializer$o
.text$di:00005EB4                 push    ebp
.text$di:00005EB5                 mov     ebp, esp
.text$di:00005EB7                 mov     ecx, offset _ignore ; this
.text$di:00005EBC                 call    ??0_Ignore@std@@QAE@XZ ; std::_Ignore::_Ignore(void)
.text$di:00005EC1                 pop     ebp
.text$di:00005EC2                 retn
.text$di:00005EC2 ??__Eignore@std@@YAXXZ endp
.text$di:00005EC2
.text$di:00005EC2 ; ---------------------------------------------------------------------------
.text$di:00005EC3                 align 4
.text$di:00005EC3 _text$di        ends
.text$di:00005EC3
.text$di:00005EC4 ; ===========================================================================
.text$di:00005EC4
.text$di:00005EC4 ; Segment type: Pure code
.text$di:00005EC4 ; Segment permissions: Read/Execute
.text$di:00005EC4 _text$di        segment para public 'CODE' use32
.text$di:00005EC4                 assume cs:_text$di
.text$di:00005EC4                 ;org 5EC4h
.text$di:00005EC4 ; COMDAT (pick any)
.text$di:00005EC4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00005EC4
.text$di:00005EC4 ; =============== S U B R O U T I N E =======================================
.text$di:00005EC4
.text$di:00005EC4 ; Attributes: bp-based frame
.text$di:00005EC4
.text$di:00005EC4 ; void __cdecl std::`dynamic initializer for 'piecewise_construct''(void)
.text$di:00005EC4 ??__Epiecewise_construct@std@@YAXXZ proc near
.text$di:00005EC4                                         ; DATA XREF: .CRT$XCU:_piecewise_construct$initializer$o
.text$di:00005EC4
.text$di:00005EC4 var_1           = byte ptr -1
.text$di:00005EC4
.text$di:00005EC4                 push    ebp
.text$di:00005EC5                 mov     ebp, esp
.text$di:00005EC7                 push    ecx
.text$di:00005EC8                 xor     eax, eax
.text$di:00005ECA                 mov     [ebp+var_1], al
.text$di:00005ECD                 mov     esp, ebp
.text$di:00005ECF                 pop     ebp
.text$di:00005ED0                 retn
.text$di:00005ED0 ??__Epiecewise_construct@std@@YAXXZ endp
.text$di:00005ED0
.text$di:00005ED0 ; ---------------------------------------------------------------------------
.text$di:00005ED1                 align 4
.text$di:00005ED1 _text$di        ends
.text$di:00005ED1
.text$yd:00005ED4 ; ===========================================================================
.text$yd:00005ED4
.text$yd:00005ED4 ; Segment type: Pure code
.text$yd:00005ED4 ; Segment permissions: Read/Execute
.text$yd:00005ED4 _text$yd        segment para public 'CODE' use32
.text$yd:00005ED4                 assume cs:_text$yd
.text$yd:00005ED4                 ;org 5ED4h
.text$yd:00005ED4 ; COMDAT (pick any)
.text$yd:00005ED4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$yd:00005ED4
.text$yd:00005ED4 ; =============== S U B R O U T I N E =======================================
.text$yd:00005ED4
.text$yd:00005ED4 ; Attributes: bp-based frame
.text$yd:00005ED4
.text$yd:00005ED4 ; void __cdecl `dynamic atexit destructor for 'public: static std::_Generic_error_category std::_Error_objects<int>::_Generic_object''()
.text$yd:00005ED4 ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc near
.text$yd:00005ED4                                         ; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+Do
.text$yd:00005ED4                 push    ebp
.text$yd:00005ED5                 mov     ebp, esp
.text$yd:00005ED7                 mov     ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
.text$yd:00005EDC                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$yd:00005EE1                 pop     ebp
.text$yd:00005EE2                 retn
.text$yd:00005EE2 ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp
.text$yd:00005EE2
.text$yd:00005EE2 ; ---------------------------------------------------------------------------
.text$yd:00005EE3                 align 4
.text$yd:00005EE3 _text$yd        ends
.text$yd:00005EE3
.text$yd:00005EE4 ; ===========================================================================
.text$yd:00005EE4
.text$yd:00005EE4 ; Segment type: Pure code
.text$yd:00005EE4 ; Segment permissions: Read/Execute
.text$yd:00005EE4 _text$yd        segment para public 'CODE' use32
.text$yd:00005EE4                 assume cs:_text$yd
.text$yd:00005EE4                 ;org 5EE4h
.text$yd:00005EE4 ; COMDAT (pick any)
.text$yd:00005EE4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$yd:00005EE4
.text$yd:00005EE4 ; =============== S U B R O U T I N E =======================================
.text$yd:00005EE4
.text$yd:00005EE4 ; Attributes: bp-based frame
.text$yd:00005EE4
.text$yd:00005EE4 ; void __cdecl `dynamic atexit destructor for 'public: static std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''()
.text$yd:00005EE4 ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
.text$yd:00005EE4                                         ; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+Do
.text$yd:00005EE4                 push    ebp
.text$yd:00005EE5                 mov     ebp, esp
.text$yd:00005EE7                 mov     ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
.text$yd:00005EEC                 call    ??1_Iostream_error_category@std@@UAE@XZ ; std::_Iostream_error_category::~_Iostream_error_category(void)
.text$yd:00005EF1                 pop     ebp
.text$yd:00005EF2                 retn
.text$yd:00005EF2 ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp
.text$yd:00005EF2
.text$yd:00005EF2 ; ---------------------------------------------------------------------------
.text$yd:00005EF3                 align 4
.text$yd:00005EF3 _text$yd        ends
.text$yd:00005EF3
.text$yd:00005EF4 ; ===========================================================================
.text$yd:00005EF4
.text$yd:00005EF4 ; Segment type: Pure code
.text$yd:00005EF4 ; Segment permissions: Read/Execute
.text$yd:00005EF4 _text$yd        segment para public 'CODE' use32
.text$yd:00005EF4                 assume cs:_text$yd
.text$yd:00005EF4                 ;org 5EF4h
.text$yd:00005EF4 ; COMDAT (pick any)
.text$yd:00005EF4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$yd:00005EF4
.text$yd:00005EF4 ; =============== S U B R O U T I N E =======================================
.text$yd:00005EF4
.text$yd:00005EF4 ; Attributes: bp-based frame
.text$yd:00005EF4
.text$yd:00005EF4 ; void __cdecl `dynamic atexit destructor for 'public: static std::_System_error_category std::_Error_objects<int>::_System_object''()
.text$yd:00005EF4 ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
.text$yd:00005EF4                                         ; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+Do
.text$yd:00005EF4                 push    ebp
.text$yd:00005EF5                 mov     ebp, esp
.text$yd:00005EF7                 mov     ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
.text$yd:00005EFC                 call    ??1_System_error_category@std@@UAE@XZ ; std::_System_error_category::~_System_error_category(void)
.text$yd:00005F01                 pop     ebp
.text$yd:00005F02                 retn
.text$yd:00005F02 ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp
.text$yd:00005F02
.text$yd:00005F02 ; ---------------------------------------------------------------------------
.text$yd:00005F03                 align 4
.text$yd:00005F03 _text$yd        ends
.text$yd:00005F03
.text$mn:00005F04 ; ===========================================================================
.text$mn:00005F04
.text$mn:00005F04 ; Segment type: Pure code
.text$mn:00005F04 ; Segment permissions: Read/Execute
.text$mn:00005F04 _text$mn        segment para public 'CODE' use32
.text$mn:00005F04                 assume cs:_text$mn
.text$mn:00005F04                 ;org 5F04h
.text$mn:00005F04 ; COMDAT (pick any)
.text$mn:00005F04                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005F04
.text$mn:00005F04 ; =============== S U B R O U T I N E =======================================
.text$mn:00005F04
.text$mn:00005F04 ; Attributes: bp-based frame
.text$mn:00005F04
.text$mn:00005F04 ; void __thiscall std::_Iterator_base0::_Adopt(std::_Iterator_base0 *this, const void *)
.text$mn:00005F04                 public ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
.text$mn:00005F04 ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z proc near
.text$mn:00005F04                                         ; CODE XREF: std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>,std::_Iterator_base0>(std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *,std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>> const *)+16p
.text$mn:00005F04
.text$mn:00005F04 var_4           = dword ptr -4
.text$mn:00005F04
.text$mn:00005F04                 push    ebp
.text$mn:00005F05                 mov     ebp, esp
.text$mn:00005F07                 push    ecx
.text$mn:00005F08                 mov     [ebp+var_4], ecx
.text$mn:00005F0B                 mov     esp, ebp
.text$mn:00005F0D                 pop     ebp
.text$mn:00005F0E                 retn    4
.text$mn:00005F0E ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z endp
.text$mn:00005F0E
.text$mn:00005F0E ; ---------------------------------------------------------------------------
.text$mn:00005F11                 align 4
.text$mn:00005F11 _text$mn        ends
.text$mn:00005F11
.text$mn:00005F14 ; ===========================================================================
.text$mn:00005F14
.text$mn:00005F14 ; Segment type: Pure code
.text$mn:00005F14 ; Segment permissions: Read/Execute
.text$mn:00005F14 _text$mn        segment para public 'CODE' use32
.text$mn:00005F14                 assume cs:_text$mn
.text$mn:00005F14                 ;org 5F14h
.text$mn:00005F14 ; COMDAT (pick any)
.text$mn:00005F14                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005F14
.text$mn:00005F14 ; =============== S U B R O U T I N E =======================================
.text$mn:00005F14
.text$mn:00005F14 ; Attributes: bp-based frame
.text$mn:00005F14
.text$mn:00005F14 ; void __thiscall std::_Iterator_base12::_Adopt(std::_Iterator_base12 *this, const struct std::_Container_base12 *)
.text$mn:00005F14                 public ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
.text$mn:00005F14 ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z proc near
.text$mn:00005F14                                         ; CODE XREF: std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>,std::_Iterator_base12>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>,std::_Iterator_base12>(std::_List_node<std::pair<int const,Style>,void *> *,std::_List_val<std::_List_simple_types<std::pair<int const,Style>>> const *)+45p
.text$mn:00005F14                                         ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>,std::_Iterator_base12>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>,std::_Iterator_base12>(std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *,std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>> const *)+45p ...
.text$mn:00005F14
.text$mn:00005F14 var_1C          = byte ptr -1Ch
.text$mn:00005F14 var_18          = byte ptr -18h
.text$mn:00005F14 var_14          = dword ptr -14h
.text$mn:00005F14 var_10          = dword ptr -10h
.text$mn:00005F14 var_C           = dword ptr -0Ch
.text$mn:00005F14 var_4           = dword ptr -4
.text$mn:00005F14 arg_0           = dword ptr  8
.text$mn:00005F14
.text$mn:00005F14                 push    ebp
.text$mn:00005F15                 mov     ebp, esp
.text$mn:00005F17                 push    0FFFFFFFFh
.text$mn:00005F19                 push    offset __ehhandler$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
.text$mn:00005F1E                 mov     eax, large fs:0
.text$mn:00005F24                 push    eax
.text$mn:00005F25                 sub     esp, 10h
.text$mn:00005F28                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005F2D                 xor     eax, ebp
.text$mn:00005F2F                 push    eax
.text$mn:00005F30                 lea     eax, [ebp+var_C]
.text$mn:00005F33                 mov     large fs:0, eax
.text$mn:00005F39                 mov     [ebp+var_10], ecx
.text$mn:00005F3C                 cmp     [ebp+arg_0], 0
.text$mn:00005F40                 jnz     short loc_5F6C
.text$mn:00005F42                 push    3               ; int
.text$mn:00005F44                 lea     ecx, [ebp+var_18] ; this
.text$mn:00005F47                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:00005F4C                 mov     [ebp+var_4], 0
.text$mn:00005F53                 mov     ecx, [ebp+var_10] ; this
.text$mn:00005F56                 call    ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me(void)
.text$mn:00005F5B                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005F62                 lea     ecx, [ebp+var_18] ; this
.text$mn:00005F65                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:00005F6A                 jmp     short loc_5FC3
.text$mn:00005F6C ; ---------------------------------------------------------------------------
.text$mn:00005F6C
.text$mn:00005F6C loc_5F6C:                               ; CODE XREF: std::_Iterator_base12::_Adopt(std::_Container_base12 const *)+2Cj
.text$mn:00005F6C                 mov     eax, [ebp+arg_0]
.text$mn:00005F6F                 mov     ecx, [eax]
.text$mn:00005F71                 mov     [ebp+var_14], ecx
.text$mn:00005F74                 mov     edx, [ebp+var_10]
.text$mn:00005F77                 mov     eax, [edx]
.text$mn:00005F79                 cmp     eax, [ebp+var_14]
.text$mn:00005F7C                 jz      short loc_5FC3
.text$mn:00005F7E                 push    3               ; int
.text$mn:00005F80                 lea     ecx, [ebp+var_1C] ; this
.text$mn:00005F83                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:00005F88                 mov     [ebp+var_4], 1
.text$mn:00005F8F                 mov     ecx, [ebp+var_10] ; this
.text$mn:00005F92                 call    ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me(void)
.text$mn:00005F97                 mov     ecx, [ebp+var_10]
.text$mn:00005F9A                 mov     edx, [ebp+var_14]
.text$mn:00005F9D                 mov     eax, [edx+4]
.text$mn:00005FA0                 mov     [ecx+4], eax
.text$mn:00005FA3                 mov     ecx, [ebp+var_14]
.text$mn:00005FA6                 mov     edx, [ebp+var_10]
.text$mn:00005FA9                 mov     [ecx+4], edx
.text$mn:00005FAC                 mov     eax, [ebp+var_10]
.text$mn:00005FAF                 mov     ecx, [ebp+var_14]
.text$mn:00005FB2                 mov     [eax], ecx
.text$mn:00005FB4                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005FBB                 lea     ecx, [ebp+var_1C] ; this
.text$mn:00005FBE                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:00005FC3
.text$mn:00005FC3 loc_5FC3:                               ; CODE XREF: std::_Iterator_base12::_Adopt(std::_Container_base12 const *)+56j
.text$mn:00005FC3                                         ; std::_Iterator_base12::_Adopt(std::_Container_base12 const *)+68j
.text$mn:00005FC3                 mov     ecx, [ebp+var_C]
.text$mn:00005FC6                 mov     large fs:0, ecx
.text$mn:00005FCD                 pop     ecx
.text$mn:00005FCE                 mov     esp, ebp
.text$mn:00005FD0                 pop     ebp
.text$mn:00005FD1                 retn    4
.text$mn:00005FD1 ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z endp
.text$mn:00005FD1
.text$mn:00005FD1 _text$mn        ends
.text$mn:00005FD1
.text$x:00005FD4 ; ===========================================================================
.text$x:00005FD4
.text$x:00005FD4 ; Segment type: Pure code
.text$x:00005FD4 ; Segment permissions: Read/Execute
.text$x:00005FD4 _text$x         segment para public 'CODE' use32
.text$x:00005FD4                 assume cs:_text$x
.text$x:00005FD4                 ;org 5FD4h
.text$x:00005FD4 ; COMDAT (pick associative to section at 5F14)
.text$x:00005FD4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00005FD4
.text$x:00005FD4 ; =============== S U B R O U T I N E =======================================
.text$x:00005FD4
.text$x:00005FD4
.text$x:00005FD4 __unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$0 proc near
.text$x:00005FD4                                         ; DATA XREF: .xdata$x:000097A8o
.text$x:00005FD4                 lea     ecx, [ebp-18h]  ; this
.text$x:00005FD7                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:00005FD7 __unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$0 endp
.text$x:00005FD7
.text$x:00005FDC
.text$x:00005FDC ; =============== S U B R O U T I N E =======================================
.text$x:00005FDC
.text$x:00005FDC
.text$x:00005FDC __unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$1 proc near
.text$x:00005FDC                                         ; DATA XREF: .xdata$x:000097B0o
.text$x:00005FDC                 lea     ecx, [ebp-1Ch]  ; this
.text$x:00005FDF                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:00005FDF __unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$1 endp
.text$x:00005FDF
.text$x:00005FE4
.text$x:00005FE4 ; =============== S U B R O U T I N E =======================================
.text$x:00005FE4
.text$x:00005FE4
.text$x:00005FE4 __ehhandler$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z proc near
.text$x:00005FE4                                         ; DATA XREF: std::_Iterator_base12::_Adopt(std::_Container_base12 const *)+5o
.text$x:00005FE4
.text$x:00005FE4 arg_4           = dword ptr  8
.text$x:00005FE4
.text$x:00005FE4                 mov     edx, [esp+arg_4]
.text$x:00005FE8                 lea     eax, [edx+0Ch]
.text$x:00005FEB                 mov     ecx, [edx-14h]
.text$x:00005FEE                 xor     ecx, eax
.text$x:00005FF0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005FF5                 mov     eax, offset __ehfuncinfo$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
.text$x:00005FFA                 jmp     ___CxxFrameHandler3
.text$x:00005FFA __ehhandler$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z endp
.text$x:00005FFA
.text$x:00005FFA ; ---------------------------------------------------------------------------
.text$x:00005FFF                 align 10h
.text$x:00005FFF _text$x         ends
.text$x:00005FFF
.text$mn:00006000 ; ===========================================================================
.text$mn:00006000
.text$mn:00006000 ; Segment type: Pure code
.text$mn:00006000 ; Segment permissions: Read/Execute
.text$mn:00006000 _text$mn        segment para public 'CODE' use32
.text$mn:00006000                 assume cs:_text$mn
.text$mn:00006000                 ;org 6000h
.text$mn:00006000 ; COMDAT (pick any)
.text$mn:00006000                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006000
.text$mn:00006000 ; =============== S U B R O U T I N E =======================================
.text$mn:00006000
.text$mn:00006000 ; Attributes: bp-based frame
.text$mn:00006000
.text$mn:00006000 ; public: void __thiscall std::_List_alloc<0, struct std::_List_base_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>, class std::allocator<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>::_Alloc_proxy(void)
.text$mn:00006000                 public ?_Alloc_proxy@?$_List_alloc@$0A@U?$_List_base_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@@std@@QAEXXZ
.text$mn:00006000 ?_Alloc_proxy@?$_List_alloc@$0A@U?$_List_base_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@@std@@QAEXXZ proc near
.text$mn:00006000                                         ; CODE XREF: std::_List_alloc<0,std::_List_base_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::_List_alloc<0,std::_List_base_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>(std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>> const &)+51p
.text$mn:00006000
.text$mn:00006000 var_10          = byte ptr -10h
.text$mn:00006000 var_8           = dword ptr -8
.text$mn:00006000 var_1           = byte ptr -1
.text$mn:00006000
.text$mn:00006000                 push    ebp
.text$mn:00006001                 mov     ebp, esp
.text$mn:00006003                 sub     esp, 10h
.text$mn:00006006                 mov     [ebp+var_8], ecx
.text$mn:00006009                 lea     ecx, [ebp+var_1]
.text$mn:0000600C                 call    ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::_Wrap_alloc<std::allocator<std::_Container_proxy>>(void)
.text$mn:00006011                 push    1
.text$mn:00006013                 lea     ecx, [ebp+var_1]
.text$mn:00006016                 call    ?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::allocate(uint)
.text$mn:0000601B                 mov     ecx, [ebp+var_8]
.text$mn:0000601E                 mov     [ecx], eax
.text$mn:00006020                 lea     ecx, [ebp+var_10] ; this
.text$mn:00006023                 call    ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy(void)
.text$mn:00006028                 push    eax             ; int
.text$mn:00006029                 mov     edx, [ebp+var_8]
.text$mn:0000602C                 mov     eax, [edx]
.text$mn:0000602E                 push    eax             ; void *
.text$mn:0000602F                 lea     ecx, [ebp+var_1]
.text$mn:00006032                 call    ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:00006037                 mov     ecx, [ebp+var_8]
.text$mn:0000603A                 mov     edx, [ecx]
.text$mn:0000603C                 mov     eax, [ebp+var_8]
.text$mn:0000603F                 mov     [edx], eax
.text$mn:00006041                 mov     esp, ebp
.text$mn:00006043                 pop     ebp
.text$mn:00006044                 retn
.text$mn:00006044 ?_Alloc_proxy@?$_List_alloc@$0A@U?$_List_base_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@@std@@QAEXXZ endp
.text$mn:00006044
.text$mn:00006044 ; ---------------------------------------------------------------------------
.text$mn:00006045                 align 4
.text$mn:00006045 _text$mn        ends
.text$mn:00006045
.text$mn:00006048 ; ===========================================================================
.text$mn:00006048
.text$mn:00006048 ; Segment type: Pure code
.text$mn:00006048 ; Segment permissions: Read/Execute
.text$mn:00006048 _text$mn        segment para public 'CODE' use32
.text$mn:00006048                 assume cs:_text$mn
.text$mn:00006048                 ;org 6048h
.text$mn:00006048 ; COMDAT (pick any)
.text$mn:00006048                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006048
.text$mn:00006048 ; =============== S U B R O U T I N E =======================================
.text$mn:00006048
.text$mn:00006048 ; Attributes: bp-based frame
.text$mn:00006048
.text$mn:00006048 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Alloc_proxy(void)
.text$mn:00006048                 public ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
.text$mn:00006048 ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00006048                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+38p
.text$mn:00006048
.text$mn:00006048 var_10          = byte ptr -10h
.text$mn:00006048 var_8           = dword ptr -8
.text$mn:00006048 var_1           = byte ptr -1
.text$mn:00006048
.text$mn:00006048                 push    ebp
.text$mn:00006049                 mov     ebp, esp
.text$mn:0000604B                 sub     esp, 10h
.text$mn:0000604E                 mov     [ebp+var_8], ecx
.text$mn:00006051                 lea     ecx, [ebp+var_1]
.text$mn:00006054                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:00006059                 push    1
.text$mn:0000605B                 lea     ecx, [ebp+var_1]
.text$mn:0000605E                 call    ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate(uint)
.text$mn:00006063                 mov     ecx, [ebp+var_8]
.text$mn:00006066                 mov     [ecx], eax
.text$mn:00006068                 lea     ecx, [ebp+var_10] ; this
.text$mn:0000606B                 call    ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy(void)
.text$mn:00006070                 push    eax             ; int
.text$mn:00006071                 mov     edx, [ebp+var_8]
.text$mn:00006074                 mov     eax, [edx]
.text$mn:00006076                 push    eax             ; void *
.text$mn:00006077                 lea     ecx, [ebp+var_1]
.text$mn:0000607A                 call    ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:0000607F                 mov     ecx, [ebp+var_8]
.text$mn:00006082                 mov     edx, [ecx]
.text$mn:00006084                 mov     eax, [ebp+var_8]
.text$mn:00006087                 mov     [edx], eax
.text$mn:00006089                 mov     esp, ebp
.text$mn:0000608B                 pop     ebp
.text$mn:0000608C                 retn
.text$mn:0000608C ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp
.text$mn:0000608C
.text$mn:0000608C ; ---------------------------------------------------------------------------
.text$mn:0000608D                 align 10h
.text$mn:0000608D _text$mn        ends
.text$mn:0000608D
.text$mn:00006090 ; ===========================================================================
.text$mn:00006090
.text$mn:00006090 ; Segment type: Pure code
.text$mn:00006090 ; Segment permissions: Read/Execute
.text$mn:00006090 _text$mn        segment para public 'CODE' use32
.text$mn:00006090                 assume cs:_text$mn
.text$mn:00006090                 ;org 6090h
.text$mn:00006090 ; COMDAT (pick any)
.text$mn:00006090                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006090
.text$mn:00006090 ; =============== S U B R O U T I N E =======================================
.text$mn:00006090
.text$mn:00006090 ; Attributes: bp-based frame
.text$mn:00006090
.text$mn:00006090 ; public: void __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>, struct std::_Wrap_alloc<class std::allocator<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>>>>>::_Alloc_proxy(void)
.text$mn:00006090                 public ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QAEXXZ
.text$mn:00006090 ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QAEXXZ proc near
.text$mn:00006090                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>>::_Vector_alloc<0,std::_Vec_base_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>>(std::_Wrap_alloc<std:
.text$mn:00006090
.text$mn:00006090 var_10          = byte ptr -10h
.text$mn:00006090 var_8           = dword ptr -8
.text$mn:00006090 var_1           = byte ptr -1
.text$mn:00006090
.text$mn:00006090                 push    ebp
.text$mn:00006091                 mov     ebp, esp
.text$mn:00006093                 sub     esp, 10h
.text$mn:00006096                 mov     [ebp+var_8], ecx
.text$mn:00006099                 lea     ecx, [ebp+var_1]
.text$mn:0000609C                 call    ??0?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_Container_proxy>>>::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_Container_proxy>>>(void)
.text$mn:000060A1                 push    1
.text$mn:000060A3                 lea     ecx, [ebp+var_1]
.text$mn:000060A6                 call    ?allocate@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_Container_proxy>>>::allocate(uint)
.text$mn:000060AB                 mov     ecx, [ebp+var_8]
.text$mn:000060AE                 mov     [ecx], eax
.text$mn:000060B0                 lea     ecx, [ebp+var_10] ; this
.text$mn:000060B3                 call    ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy(void)
.text$mn:000060B8                 push    eax             ; int
.text$mn:000060B9                 mov     edx, [ebp+var_8]
.text$mn:000060BC                 mov     eax, [edx]
.text$mn:000060BE                 push    eax             ; void *
.text$mn:000060BF                 lea     ecx, [ebp+var_1]
.text$mn:000060C2                 call    ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_Container_proxy>>>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:000060C7                 mov     ecx, [ebp+var_8]
.text$mn:000060CA                 mov     edx, [ecx]
.text$mn:000060CC                 mov     eax, [ebp+var_8]
.text$mn:000060CF                 mov     [edx], eax
.text$mn:000060D1                 mov     esp, ebp
.text$mn:000060D3                 pop     ebp
.text$mn:000060D4                 retn
.text$mn:000060D4 ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QAEXXZ endp
.text$mn:000060D4
.text$mn:000060D4 ; ---------------------------------------------------------------------------
.text$mn:000060D5                 align 4
.text$mn:000060D5 _text$mn        ends
.text$mn:000060D5
.text$mn:000060D8 ; ===========================================================================
.text$mn:000060D8
.text$mn:000060D8 ; Segment type: Pure code
.text$mn:000060D8 ; Segment permissions: Read/Execute
.text$mn:000060D8 _text$mn        segment para public 'CODE' use32
.text$mn:000060D8                 assume cs:_text$mn
.text$mn:000060D8                 ;org 60D8h
.text$mn:000060D8 ; COMDAT (pick any)
.text$mn:000060D8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000060D8
.text$mn:000060D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000060D8
.text$mn:000060D8 ; Attributes: bp-based frame
.text$mn:000060D8
.text$mn:000060D8 ; public: struct std::_List_node<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>, void *> * __thiscall std::_List_alloc<0, struct std::_List_base_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>, class std::allocator<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>::_Buyheadnode(void)
.text$mn:000060D8                 public ?_Buyheadnode@?$_List_alloc@$0A@U?$_List_base_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@@std@@QAEPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@2@XZ
.text$mn:000060D8 ?_Buyheadnode@?$_List_alloc@$0A@U?$_List_base_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@@std@@QAEPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@2@XZ proc near
.text$mn:000060D8                                         ; CODE XREF: std::_List_alloc<0,std::_List_base_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::_List_alloc<0,std::_List_base_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>(std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>> const &)+3Fp
.text$mn:000060D8
.text$mn:000060D8 var_4           = dword ptr -4
.text$mn:000060D8
.text$mn:000060D8                 push    ebp
.text$mn:000060D9                 mov     ebp, esp
.text$mn:000060DB                 push    ecx
.text$mn:000060DC                 mov     [ebp+var_4], ecx
.text$mn:000060DF                 push    0
.text$mn:000060E1                 push    0
.text$mn:000060E3                 mov     ecx, [ebp+var_4]
.text$mn:000060E6                 call    ?_Buynode0@?$_List_alloc@$0A@U?$_List_base_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@@std@@QAEPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@2@PAU32@0@Z ; std::_List_alloc<0,std::_List_base_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::_Buynode0(std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *,std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *)
.text$mn:000060EB                 mov     esp, ebp
.text$mn:000060ED                 pop     ebp
.text$mn:000060EE                 retn
.text$mn:000060EE ?_Buyheadnode@?$_List_alloc@$0A@U?$_List_base_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@@std@@QAEPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@2@XZ endp
.text$mn:000060EE
.text$mn:000060EE ; ---------------------------------------------------------------------------
.text$mn:000060EF                 align 10h
.text$mn:000060EF _text$mn        ends
.text$mn:000060EF
.text$mn:000060F0 ; ===========================================================================
.text$mn:000060F0
.text$mn:000060F0 ; Segment type: Pure code
.text$mn:000060F0 ; Segment permissions: Read/Execute
.text$mn:000060F0 _text$mn        segment para public 'CODE' use32
.text$mn:000060F0                 assume cs:_text$mn
.text$mn:000060F0                 ;org 60F0h
.text$mn:000060F0 ; COMDAT (pick any)
.text$mn:000060F0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000060F0
.text$mn:000060F0 ; =============== S U B R O U T I N E =======================================
.text$mn:000060F0
.text$mn:000060F0 ; Attributes: bp-based frame
.text$mn:000060F0
.text$mn:000060F0 ; public: struct std::_List_node<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>, void *> * __thiscall std::_List_alloc<0, struct std::_List_base_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>, class std::allocator<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>::_Buynode0(struct std::_List_node<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>, void *> *, struct std::_List_node<struct std::pair<cl
.text$mn:000060F0                 public ?_Buynode0@?$_List_alloc@$0A@U?$_List_base_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@@std@@QAEPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@2@PAU32@0@Z
.text$mn:000060F0 ?_Buynode0@?$_List_alloc@$0A@U?$_List_base_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@@std@@QAEPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@2@PAU32@0@Z proc near
.text$mn:000060F0                                         ; CODE XREF: std::_List_alloc<0,std::_List_base_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::_Buyheadnode(void)+Ep
.text$mn:000060F0
.text$mn:000060F0 var_1C          = dword ptr -1Ch
.text$mn:000060F0 var_18          = dword ptr -18h
.text$mn:000060F0 var_13          = byte ptr -13h
.text$mn:000060F0 var_12          = byte ptr -12h
.text$mn:000060F0 var_11          = byte ptr -11h
.text$mn:000060F0 var_10          = dword ptr -10h
.text$mn:000060F0 var_C           = dword ptr -0Ch
.text$mn:000060F0 var_4           = dword ptr -4
.text$mn:000060F0 arg_0           = dword ptr  8
.text$mn:000060F0 arg_4           = dword ptr  0Ch
.text$mn:000060F0
.text$mn:000060F0 ; FUNCTION CHUNK AT .text$mn:000061D4 SIZE 00000009 BYTES
.text$mn:000060F0 ; FUNCTION CHUNK AT .text$mn:000061E4 SIZE 00000017 BYTES
.text$mn:000060F0
.text$mn:000060F0                 push    ebp
.text$mn:000060F1                 mov     ebp, esp
.text$mn:000060F3                 push    0FFFFFFFFh
.text$mn:000060F5                 push    offset __ehhandler$?_Buynode0@?$_List_alloc@$0A@U?$_List_base_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@@std@@QAEPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@2@PAU32@0@Z
.text$mn:000060FA                 mov     eax, large fs:0
.text$mn:00006100                 push    eax
.text$mn:00006101                 push    ecx
.text$mn:00006102                 sub     esp, 0Ch
.text$mn:00006105                 push    ebx
.text$mn:00006106                 push    esi
.text$mn:00006107                 push    edi
.text$mn:00006108                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000610D                 xor     eax, ebp
.text$mn:0000610F                 push    eax
.text$mn:00006110                 lea     eax, [ebp+var_C]
.text$mn:00006113                 mov     large fs:0, eax
.text$mn:00006119                 mov     [ebp+var_10], esp
.text$mn:0000611C                 mov     [ebp+var_1C], ecx
.text$mn:0000611F                 push    1
.text$mn:00006121                 lea     eax, [ebp+var_11]
.text$mn:00006124                 push    eax
.text$mn:00006125                 mov     ecx, [ebp+var_1C]
.text$mn:00006128                 call    ?_Getal@?$_List_alloc@$0A@U?$_List_base_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@@2@XZ ; std::_List_alloc<0,std::_List_base_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::_Getal(void)
.text$mn:0000612D                 mov     ecx, eax
.text$mn:0000612F                 call    ?allocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *>>>::allocate(uint)
.text$mn:00006134                 mov     [ebp+var_18], eax
.text$mn:00006137                 cmp     [ebp+arg_0], 0
.text$mn:0000613B                 jnz     short loc_6149
.text$mn:0000613D                 mov     ecx, [ebp+var_18]
.text$mn:00006140                 mov     [ebp+arg_0], ecx
.text$mn:00006143                 mov     edx, [ebp+var_18]
.text$mn:00006146                 mov     [ebp+arg_4], edx
.text$mn:00006149
.text$mn:00006149 loc_6149:                               ; CODE XREF: std::_List_alloc<0,std::_List_base_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::_Buynode0(std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *,std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *)+4Bj
.text$mn:00006149                 mov     [ebp+var_4], 0
.text$mn:00006150                 lea     eax, [ebp+arg_0]
.text$mn:00006153                 push    eax             ; int
.text$mn:00006154                 mov     ecx, [ebp+var_18]
.text$mn:00006157                 push    ecx
.text$mn:00006158                 call    ?_Nextnode@?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@SAAAPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@2@PAU32@@Z ; std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>::_Nextnode(std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *)
.text$mn:0000615D                 add     esp, 4
.text$mn:00006160                 push    eax
.text$mn:00006161                 call    ??$addressof@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@YAPAPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@0@AAPAU10@@Z ; std::addressof<std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *>(std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> * &)
.text$mn:00006166                 add     esp, 4
.text$mn:00006169                 push    eax             ; void *
.text$mn:0000616A                 lea     edx, [ebp+var_12]
.text$mn:0000616D                 push    edx
.text$mn:0000616E                 mov     ecx, [ebp+var_1C]
.text$mn:00006171                 call    ?_Getal@?$_List_alloc@$0A@U?$_List_base_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@@2@XZ ; std::_List_alloc<0,std::_List_base_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::_Getal(void)
.text$mn:00006176                 mov     ecx, eax
.text$mn:00006178                 call    ??$construct@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@1@AAPAU21@@Z ; std::_Wrap_alloc<std::allocator<std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *>>>::construct<std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *,std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> * &>(std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> * *,std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> * &)
.text$mn:0000617D                 lea     eax, [ebp+arg_4]
.text$mn:00006180                 push    eax             ; int
.text$mn:00006181                 mov     ecx, [ebp+var_18]
.text$mn:00006184                 push    ecx
.text$mn:00006185                 call    ?_Prevnode@?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@SAAAPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@2@PAU32@@Z ; std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>::_Prevnode(std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *)
.text$mn:0000618A                 add     esp, 4
.text$mn:0000618D                 push    eax
.text$mn:0000618E                 call    ??$addressof@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@YAPAPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@0@AAPAU10@@Z ; std::addressof<std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *>(std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> * &)
.text$mn:00006193                 add     esp, 4
.text$mn:00006196                 push    eax             ; void *
.text$mn:00006197                 lea     edx, [ebp+var_13]
.text$mn:0000619A                 push    edx
.text$mn:0000619B                 mov     ecx, [ebp+var_1C]
.text$mn:0000619E                 call    ?_Getal@?$_List_alloc@$0A@U?$_List_base_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@@2@XZ ; std::_List_alloc<0,std::_List_base_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::_Getal(void)
.text$mn:000061A3                 mov     ecx, eax
.text$mn:000061A5                 call    ??$construct@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@1@AAPAU21@@Z ; std::_Wrap_alloc<std::allocator<std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *>>>::construct<std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *,std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> * &>(std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> * *,std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> * &)
.text$mn:000061AA                 jmp     short loc_61D4
.text$mn:000061AA ?_Buynode0@?$_List_alloc@$0A@U?$_List_base_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@@std@@QAEPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@2@PAU32@0@Z endp
.text$mn:000061AA
.text$mn:000061AC
.text$mn:000061AC ; =============== S U B R O U T I N E =======================================
.text$mn:000061AC
.text$mn:000061AC ; Attributes: noreturn
.text$mn:000061AC
.text$mn:000061AC __catch$?_Buynode0@?$_List_alloc@$0A@U?$_List_base_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@@std@@QAEPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@2@PAU32@0@Z$0 proc near
.text$mn:000061AC                                         ; DATA XREF: .xdata$x:00009E84o
.text$mn:000061AC                 push    1               ; int
.text$mn:000061AE                 mov     eax, [ebp-18h]
.text$mn:000061B1                 push    eax             ; void *
.text$mn:000061B2                 lea     ecx, [ebp-14h]
.text$mn:000061B5                 push    ecx
.text$mn:000061B6                 mov     ecx, [ebp-1Ch]
.text$mn:000061B9                 call    ?_Getal@?$_List_alloc@$0A@U?$_List_base_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@@2@XZ ; std::_List_alloc<0,std::_List_base_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::_Getal(void)
.text$mn:000061BE                 mov     ecx, eax
.text$mn:000061C0                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *>>>::deallocate(std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *,uint)
.text$mn:000061C5                 push    0
.text$mn:000061C7                 push    0
.text$mn:000061C9                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:000061C9 __catch$?_Buynode0@?$_List_alloc@$0A@U?$_List_base_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@@std@@QAEPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@2@PAU32@0@Z$0 endp
.text$mn:000061C9
.text$mn:000061CE ; ---------------------------------------------------------------------------
.text$mn:000061CE                 mov     eax, offset $LN8_2
.text$mn:000061D3                 retn
.text$mn:000061D4 ; ---------------------------------------------------------------------------
.text$mn:000061D4 ; START OF FUNCTION CHUNK FOR ?_Buynode0@?$_List_alloc@$0A@U?$_List_base_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@@std@@QAEPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@2@PAU32@0@Z
.text$mn:000061D4
.text$mn:000061D4 loc_61D4:                               ; CODE XREF: std::_List_alloc<0,std::_List_base_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::_Buynode0(std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *,std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *)+BAj
.text$mn:000061D4                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000061DB                 jmp     short loc_61E4
.text$mn:000061DB ; END OF FUNCTION CHUNK FOR ?_Buynode0@?$_List_alloc@$0A@U?$_List_base_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@@std@@QAEPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@2@PAU32@0@Z
.text$mn:000061DD
.text$mn:000061DD ; =============== S U B R O U T I N E =======================================
.text$mn:000061DD
.text$mn:000061DD
.text$mn:000061DD $LN8_2          proc near               ; DATA XREF: .text$mn:000061CEo
.text$mn:000061DD                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:000061DD $LN8_2          endp ; sp-analysis failed
.text$mn:000061DD
.text$mn:000061E4 ; START OF FUNCTION CHUNK FOR ?_Buynode0@?$_List_alloc@$0A@U?$_List_base_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@@std@@QAEPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@2@PAU32@0@Z
.text$mn:000061E4
.text$mn:000061E4 loc_61E4:                               ; CODE XREF: std::_List_alloc<0,std::_List_base_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::_Buynode0(std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *,std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *)+EBj
.text$mn:000061E4                 mov     eax, [ebp+var_18]
.text$mn:000061E7                 mov     ecx, [ebp+var_C]
.text$mn:000061EA                 mov     large fs:0, ecx
.text$mn:000061F1                 pop     ecx
.text$mn:000061F2                 pop     edi
.text$mn:000061F3                 pop     esi
.text$mn:000061F4                 pop     ebx
.text$mn:000061F5                 mov     esp, ebp
.text$mn:000061F7                 pop     ebp
.text$mn:000061F8                 retn    8
.text$mn:000061F8 ; END OF FUNCTION CHUNK FOR ?_Buynode0@?$_List_alloc@$0A@U?$_List_base_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@@std@@QAEPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@2@PAU32@0@Z
.text$mn:000061F8 ; ---------------------------------------------------------------------------
.text$mn:000061FB                 align 4
.text$mn:000061FB _text$mn        ends
.text$mn:000061FB
.text$x:000061FC ; ===========================================================================
.text$x:000061FC
.text$x:000061FC ; Segment type: Pure code
.text$x:000061FC ; Segment permissions: Read/Execute
.text$x:000061FC _text$x         segment para public 'CODE' use32
.text$x:000061FC                 assume cs:_text$x
.text$x:000061FC                 ;org 61FCh
.text$x:000061FC ; COMDAT (pick associative to section at 60F0)
.text$x:000061FC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000061FC
.text$x:000061FC ; =============== S U B R O U T I N E =======================================
.text$x:000061FC
.text$x:000061FC
.text$x:000061FC __ehhandler$?_Buynode0@?$_List_alloc@$0A@U?$_List_base_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@@std@@QAEPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@2@PAU32@0@Z proc near
.text$x:000061FC                                         ; DATA XREF: std::_List_alloc<0,std::_List_base_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::_Buynode0(std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *,std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *)+5o
.text$x:000061FC
.text$x:000061FC arg_4           = dword ptr  8
.text$x:000061FC
.text$x:000061FC                 mov     edx, [esp+arg_4]
.text$x:00006200                 lea     eax, [edx+0Ch]
.text$x:00006203                 mov     ecx, [edx-20h]
.text$x:00006206                 xor     ecx, eax
.text$x:00006208                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000620D                 mov     eax, offset __ehfuncinfo$?_Buynode0@?$_List_alloc@$0A@U?$_List_base_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@@std@@QAEPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@2@PAU32@0@Z
.text$x:00006212                 jmp     ___CxxFrameHandler3
.text$x:00006212 __ehhandler$?_Buynode0@?$_List_alloc@$0A@U?$_List_base_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@@std@@QAEPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@2@PAU32@0@Z endp
.text$x:00006212
.text$x:00006212 ; ---------------------------------------------------------------------------
.text$x:00006217                 align 4
.text$x:00006217 _text$x         ends
.text$x:00006217
.text$mn:00006218 ; ===========================================================================
.text$mn:00006218
.text$mn:00006218 ; Segment type: Pure code
.text$mn:00006218 ; Segment permissions: Read/Execute
.text$mn:00006218 _text$mn        segment para public 'CODE' use32
.text$mn:00006218                 assume cs:_text$mn
.text$mn:00006218                 ;org 6218h
.text$mn:00006218 ; COMDAT (pick any)
.text$mn:00006218                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006218
.text$mn:00006218 ; =============== S U B R O U T I N E =======================================
.text$mn:00006218
.text$mn:00006218 ; Attributes: bp-based frame
.text$mn:00006218
.text$mn:00006218 ; void __thiscall std::_Iterator_base12::_Clrcont(std::_Iterator_base12 *__hidden this)
.text$mn:00006218                 public ?_Clrcont@_Iterator_base12@std@@QAEXXZ
.text$mn:00006218 ?_Clrcont@_Iterator_base12@std@@QAEXXZ proc near
.text$mn:00006218                                         ; CODE XREF: std::list<std::pair<int const,Style>,std::allocator<std::pair<int const,Style>>>::_Orphan_ptr(std::list<std::pair<int const,Style>,std::allocator<std::pair<int const,Style>>> &,std::_List_node<std::pair<int const,Style>,void *> *)+89p
.text$mn:00006218                                         ; std::list<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>::_Orphan_ptr(std::list<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>> &,std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *)+89p ...
.text$mn:00006218
.text$mn:00006218 var_4           = dword ptr -4
.text$mn:00006218
.text$mn:00006218                 push    ebp
.text$mn:00006219                 mov     ebp, esp
.text$mn:0000621B                 push    ecx
.text$mn:0000621C                 mov     [ebp+var_4], ecx
.text$mn:0000621F                 mov     eax, [ebp+var_4]
.text$mn:00006222                 mov     dword ptr [eax], 0
.text$mn:00006228                 mov     esp, ebp
.text$mn:0000622A                 pop     ebp
.text$mn:0000622B                 retn
.text$mn:0000622B ?_Clrcont@_Iterator_base12@std@@QAEXXZ endp
.text$mn:0000622B
.text$mn:0000622B _text$mn        ends
.text$mn:0000622B
.text$mn:0000622C ; ===========================================================================
.text$mn:0000622C
.text$mn:0000622C ; Segment type: Pure code
.text$mn:0000622C ; Segment permissions: Read/Execute
.text$mn:0000622C _text$mn        segment para public 'CODE' use32
.text$mn:0000622C                 assume cs:_text$mn
.text$mn:0000622C                 ;org 622Ch
.text$mn:0000622C ; COMDAT (pick any)
.text$mn:0000622C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000622C
.text$mn:0000622C ; =============== S U B R O U T I N E =======================================
.text$mn:0000622C
.text$mn:0000622C ; Attributes: bp-based frame
.text$mn:0000622C
.text$mn:0000622C ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Copy(unsigned int, unsigned int)
.text$mn:0000622C                 public ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:0000622C ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
.text$mn:0000622C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+37p
.text$mn:0000622C
.text$mn:0000622C var_20          = dword ptr -20h
.text$mn:0000622C var_1C          = dword ptr -1Ch
.text$mn:0000622C var_18          = dword ptr -18h
.text$mn:0000622C var_11          = byte ptr -11h
.text$mn:0000622C var_10          = dword ptr -10h
.text$mn:0000622C var_C           = byte ptr -0Ch
.text$mn:0000622C var_4           = dword ptr -4
.text$mn:0000622C arg_0           = dword ptr  8
.text$mn:0000622C
.text$mn:0000622C ; FUNCTION CHUNK AT .text$mn:0000634E SIZE 00000009 BYTES
.text$mn:0000622C
.text$mn:0000622C                 push    ebp
.text$mn:0000622D                 mov     ebp, esp
.text$mn:0000622F                 push    0FFFFFFFFh
.text$mn:00006231                 push    offset __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00006236                 mov     eax, large fs:0
.text$mn:0000623C                 push    eax
.text$mn:0000623D                 push    ecx
.text$mn:0000623E                 sub     esp, 10h
.text$mn:00006241                 push    ebx
.text$mn:00006242                 push    esi
.text$mn:00006243                 push    edi
.text$mn:00006244                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006249                 xor     eax, ebp
.text$mn:0000624B                 push    eax
.text$mn:0000624C                 lea     eax, [ebp+var_C]
.text$mn:0000624F                 mov     large fs:0, eax
.text$mn:00006255                 mov     [ebp+var_10], esp
.text$mn:00006258                 mov     [ebp+var_18], ecx
.text$mn:0000625B                 mov     eax, [ebp+arg_0]
.text$mn:0000625E                 or      eax, 0Fh
.text$mn:00006261                 mov     [ebp+var_1C], eax
.text$mn:00006264                 mov     ecx, [ebp+var_18]
.text$mn:00006267                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:0000626C                 cmp     eax, [ebp+var_1C]
.text$mn:0000626F                 jnb     short loc_6279
.text$mn:00006271                 mov     ecx, [ebp+arg_0]
.text$mn:00006274                 mov     [ebp+var_1C], ecx
.text$mn:00006277                 jmp     short loc_62CB
.text$mn:00006279 ; ---------------------------------------------------------------------------
.text$mn:00006279
.text$mn:00006279 loc_6279:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+43j
.text$mn:00006279                 mov     edx, [ebp+var_18]
.text$mn:0000627C                 mov     ecx, [edx+18h]
.text$mn:0000627F                 shr     ecx, 1
.text$mn:00006281                 mov     eax, [ebp+var_1C]
.text$mn:00006284                 xor     edx, edx
.text$mn:00006286                 mov     esi, 3
.text$mn:0000628B                 div     esi
.text$mn:0000628D                 cmp     ecx, eax
.text$mn:0000628F                 ja      short loc_6293
.text$mn:00006291                 jmp     short loc_62CB
.text$mn:00006293 ; ---------------------------------------------------------------------------
.text$mn:00006293
.text$mn:00006293 loc_6293:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+63j
.text$mn:00006293                 mov     ecx, [ebp+var_18]
.text$mn:00006296                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:0000629B                 mov     edx, [ebp+var_18]
.text$mn:0000629E                 mov     ecx, [edx+18h]
.text$mn:000062A1                 shr     ecx, 1
.text$mn:000062A3                 sub     eax, ecx
.text$mn:000062A5                 mov     edx, [ebp+var_18]
.text$mn:000062A8                 cmp     [edx+18h], eax
.text$mn:000062AB                 ja      short loc_62C0
.text$mn:000062AD                 mov     eax, [ebp+var_18]
.text$mn:000062B0                 mov     ecx, [eax+18h]
.text$mn:000062B3                 shr     ecx, 1
.text$mn:000062B5                 mov     edx, [ebp+var_18]
.text$mn:000062B8                 add     ecx, [edx+18h]
.text$mn:000062BB                 mov     [ebp+var_1C], ecx
.text$mn:000062BE                 jmp     short loc_62CB
.text$mn:000062C0 ; ---------------------------------------------------------------------------
.text$mn:000062C0
.text$mn:000062C0 loc_62C0:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+7Fj
.text$mn:000062C0                 mov     ecx, [ebp+var_18]
.text$mn:000062C3                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:000062C8                 mov     [ebp+var_1C], eax
.text$mn:000062CB
.text$mn:000062CB loc_62CB:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+4Bj
.text$mn:000062CB                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+65j ...
.text$mn:000062CB                 mov     [ebp+var_4], 0
.text$mn:000062D2                 mov     eax, [ebp+var_1C]
.text$mn:000062D5                 add     eax, 1
.text$mn:000062D8                 push    eax
.text$mn:000062D9                 lea     ecx, [ebp+var_11]
.text$mn:000062DC                 push    ecx
.text$mn:000062DD                 mov     ecx, [ebp+var_18]
.text$mn:000062E0                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:000062E5                 mov     ecx, eax
.text$mn:000062E7                 call    ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
.text$mn:000062EC                 mov     [ebp+var_20], eax
.text$mn:000062EF                 jmp     short loc_634E
.text$mn:000062EF ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp
.text$mn:000062EF
.text$mn:000062F1
.text$mn:000062F1 ; =============== S U B R O U T I N E =======================================
.text$mn:000062F1
.text$mn:000062F1
.text$mn:000062F1 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 proc near
.text$mn:000062F1                                         ; DATA XREF: .xdata$x:000098ECo
.text$mn:000062F1
.text$mn:000062F1 ; FUNCTION CHUNK AT .text$mn:00006338 SIZE 00000009 BYTES
.text$mn:000062F1 ; FUNCTION CHUNK AT .text$mn:00006348 SIZE 00000006 BYTES
.text$mn:000062F1
.text$mn:000062F1                 mov     [ebp-10h], esp
.text$mn:000062F4                 mov     edx, [ebp+8]
.text$mn:000062F7                 mov     [ebp-1Ch], edx
.text$mn:000062FA                 mov     byte ptr [ebp-4], 2
.text$mn:000062FE                 mov     eax, [ebp-1Ch]
.text$mn:00006301                 add     eax, 1
.text$mn:00006304                 push    eax
.text$mn:00006305                 lea     ecx, [ebp-12h]
.text$mn:00006308                 push    ecx
.text$mn:00006309                 mov     ecx, [ebp-18h]
.text$mn:0000630C                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00006311                 mov     ecx, eax
.text$mn:00006313                 call    ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
.text$mn:00006318                 mov     [ebp-20h], eax
.text$mn:0000631B                 jmp     short loc_6338
.text$mn:0000631B __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 endp
.text$mn:0000631B
.text$mn:0000631D
.text$mn:0000631D ; =============== S U B R O U T I N E =======================================
.text$mn:0000631D
.text$mn:0000631D ; Attributes: noreturn
.text$mn:0000631D
.text$mn:0000631D __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 proc near
.text$mn:0000631D                                         ; DATA XREF: .xdata$x:000098FCo
.text$mn:0000631D                 push    0               ; Size
.text$mn:0000631F                 push    1               ; char
.text$mn:00006321                 mov     ecx, [ebp-18h]
.text$mn:00006324                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00006329                 push    0
.text$mn:0000632B                 push    0
.text$mn:0000632D                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:0000632D __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 endp
.text$mn:0000632D
.text$mn:00006332 ; ---------------------------------------------------------------------------
.text$mn:00006332                 mov     eax, offset $LN17
.text$mn:00006337                 retn
.text$mn:00006338 ; ---------------------------------------------------------------------------
.text$mn:00006338 ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00006338
.text$mn:00006338 loc_6338:                               ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+2Aj
.text$mn:00006338                 mov     dword ptr [ebp-4], 1
.text$mn:0000633F                 jmp     short loc_6348
.text$mn:0000633F ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00006341
.text$mn:00006341 ; =============== S U B R O U T I N E =======================================
.text$mn:00006341
.text$mn:00006341
.text$mn:00006341 $LN17           proc near               ; DATA XREF: .text$mn:00006332o
.text$mn:00006341                 mov     dword ptr [ebp-4], 1
.text$mn:00006341 $LN17           endp ; sp-analysis failed
.text$mn:00006341
.text$mn:00006348 ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00006348
.text$mn:00006348 loc_6348:                               ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+4Ej
.text$mn:00006348                 mov     eax, offset $LN19
.text$mn:0000634D                 retn
.text$mn:0000634D ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:0000634E ; ---------------------------------------------------------------------------
.text$mn:0000634E ; START OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:0000634E
.text$mn:0000634E loc_634E:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+C3j
.text$mn:0000634E                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006355                 jmp     short loc_635E
.text$mn:00006355 ; END OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00006357
.text$mn:00006357 ; =============== S U B R O U T I N E =======================================
.text$mn:00006357
.text$mn:00006357
.text$mn:00006357 $LN19           proc near               ; DATA XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:loc_6348o
.text$mn:00006357                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:0000635E
.text$mn:0000635E loc_635E:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+129j
.text$mn:0000635E                 cmp     dword ptr [ebp+0Ch], 0
.text$mn:00006362                 jbe     short loc_637D
.text$mn:00006364                 mov     edx, [ebp+0Ch]
.text$mn:00006367                 push    edx             ; Size
.text$mn:00006368                 mov     ecx, [ebp-18h]
.text$mn:0000636B                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00006370                 push    eax             ; Src
.text$mn:00006371                 mov     eax, [ebp-20h]
.text$mn:00006374                 push    eax             ; Dst
.text$mn:00006375                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:0000637A                 add     esp, 0Ch
.text$mn:0000637D
.text$mn:0000637D loc_637D:                               ; CODE XREF: $LN19+Bj
.text$mn:0000637D                 push    0               ; Size
.text$mn:0000637F                 push    1               ; char
.text$mn:00006381                 mov     ecx, [ebp-18h]
.text$mn:00006384                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00006389                 lea     ecx, [ebp-20h]
.text$mn:0000638C                 push    ecx             ; int
.text$mn:0000638D                 mov     edx, [ebp-18h]
.text$mn:00006390                 add     edx, 4
.text$mn:00006393                 push    edx             ; void *
.text$mn:00006394                 lea     eax, [ebp-13h]
.text$mn:00006397                 push    eax
.text$mn:00006398                 mov     ecx, [ebp-18h]
.text$mn:0000639B                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:000063A0                 mov     ecx, eax
.text$mn:000063A2                 call    ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)
.text$mn:000063A7                 mov     ecx, [ebp-18h]
.text$mn:000063AA                 mov     edx, [ebp-1Ch]
.text$mn:000063AD                 mov     [ecx+18h], edx
.text$mn:000063B0                 mov     eax, [ebp+0Ch]
.text$mn:000063B3                 push    eax
.text$mn:000063B4                 mov     ecx, [ebp-18h]
.text$mn:000063B7                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000063BC                 mov     ecx, [ebp-0Ch]
.text$mn:000063BF                 mov     large fs:0, ecx
.text$mn:000063C6                 pop     ecx
.text$mn:000063C7                 pop     edi
.text$mn:000063C8                 pop     esi
.text$mn:000063C9                 pop     ebx
.text$mn:000063CA                 mov     esp, ebp
.text$mn:000063CC                 pop     ebp
.text$mn:000063CD                 retn    8
.text$mn:000063CD $LN19           endp ; sp-analysis failed
.text$mn:000063CD
.text$mn:000063CD _text$mn        ends
.text$mn:000063CD
.text$x:000063D0 ; ===========================================================================
.text$x:000063D0
.text$x:000063D0 ; Segment type: Pure code
.text$x:000063D0 ; Segment permissions: Read/Execute
.text$x:000063D0 _text$x         segment para public 'CODE' use32
.text$x:000063D0                 assume cs:_text$x
.text$x:000063D0                 ;org 63D0h
.text$x:000063D0 ; COMDAT (pick associative to section at 622C)
.text$x:000063D0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000063D0
.text$x:000063D0 ; =============== S U B R O U T I N E =======================================
.text$x:000063D0
.text$x:000063D0
.text$x:000063D0 __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
.text$x:000063D0                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+5o
.text$x:000063D0
.text$x:000063D0 arg_4           = dword ptr  8
.text$x:000063D0
.text$x:000063D0                 mov     edx, [esp+arg_4]
.text$x:000063D4                 lea     eax, [edx+0Ch]
.text$x:000063D7                 mov     ecx, [edx-24h]
.text$x:000063DA                 xor     ecx, eax
.text$x:000063DC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000063E1                 mov     eax, offset __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$x:000063E6                 jmp     ___CxxFrameHandler3
.text$x:000063E6 __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp
.text$x:000063E6
.text$x:000063E6 ; ---------------------------------------------------------------------------
.text$x:000063EB                 align 4
.text$x:000063EB _text$x         ends
.text$x:000063EB
.text$mn:000063EC ; ===========================================================================
.text$mn:000063EC
.text$mn:000063EC ; Segment type: Pure code
.text$mn:000063EC ; Segment permissions: Read/Execute
.text$mn:000063EC _text$mn        segment para public 'CODE' use32
.text$mn:000063EC                 assume cs:_text$mn
.text$mn:000063EC                 ;org 63ECh
.text$mn:000063EC ; COMDAT (pick any)
.text$mn:000063EC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000063EC
.text$mn:000063EC ; =============== S U B R O U T I N E =======================================
.text$mn:000063EC
.text$mn:000063EC ; Attributes: bp-based frame
.text$mn:000063EC
.text$mn:000063EC ; protected: void __thiscall std::vector<class ScintillaEditView *, class std::allocator<class ScintillaEditView *>>::_Destroy(class ScintillaEditView * *, class ScintillaEditView * *)
.text$mn:000063EC                 public ?_Destroy@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@IAEXPAPAVScintillaEditView@@0@Z
.text$mn:000063EC ?_Destroy@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@IAEXPAPAVScintillaEditView@@0@Z proc near
.text$mn:000063EC                                         ; CODE XREF: std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::_Reallocate(uint)+CBp
.text$mn:000063EC                                         ; std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::erase(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>)+9Ep
.text$mn:000063EC
.text$mn:000063EC var_8           = dword ptr -8
.text$mn:000063EC var_1           = byte ptr -1
.text$mn:000063EC arg_0           = dword ptr  8
.text$mn:000063EC arg_4           = dword ptr  0Ch
.text$mn:000063EC
.text$mn:000063EC                 push    ebp
.text$mn:000063ED                 mov     ebp, esp
.text$mn:000063EF                 sub     esp, 8
.text$mn:000063F2                 mov     [ebp+var_8], ecx
.text$mn:000063F5                 lea     eax, [ebp+var_1]
.text$mn:000063F8                 push    eax
.text$mn:000063F9                 mov     ecx, [ebp+var_8]
.text$mn:000063FC                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVScintillaEditView@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<ScintillaEditView *,std::allocator<ScintillaEditView *>>>::_Getal(void)
.text$mn:00006401                 lea     ecx, [ebp+var_1]
.text$mn:00006404                 push    ecx
.text$mn:00006405                 mov     edx, [ebp+arg_4]
.text$mn:00006408                 push    edx
.text$mn:00006409                 mov     eax, [ebp+arg_0]
.text$mn:0000640C                 push    eax
.text$mn:0000640D                 call    ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVScintillaEditView@@@std@@@std@@@std@@YAXPAPAVScintillaEditView@@0AAU?$_Wrap_alloc@V?$allocator@PAVScintillaEditView@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<ScintillaEditView *>>>(ScintillaEditView * *,ScintillaEditView * *,std::_Wrap_alloc<std::allocator<ScintillaEditView *>> &)
.text$mn:00006412                 add     esp, 0Ch
.text$mn:00006415                 mov     esp, ebp
.text$mn:00006417                 pop     ebp
.text$mn:00006418                 retn    8
.text$mn:00006418 ?_Destroy@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@IAEXPAPAVScintillaEditView@@0@Z endp
.text$mn:00006418
.text$mn:00006418 ; ---------------------------------------------------------------------------
.text$mn:0000641B                 align 4
.text$mn:0000641B _text$mn        ends
.text$mn:0000641B
.text$mn:0000641C ; ===========================================================================
.text$mn:0000641C
.text$mn:0000641C ; Segment type: Pure code
.text$mn:0000641C ; Segment permissions: Read/Execute
.text$mn:0000641C _text$mn        segment para public 'CODE' use32
.text$mn:0000641C                 assume cs:_text$mn
.text$mn:0000641C                 ;org 641Ch
.text$mn:0000641C ; COMDAT (pick any)
.text$mn:0000641C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000641C
.text$mn:0000641C ; =============== S U B R O U T I N E =======================================
.text$mn:0000641C
.text$mn:0000641C ; Attributes: bp-based frame
.text$mn:0000641C
.text$mn:0000641C ; protected: void __thiscall std::vector<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<int const, struct Style>>>>, struct std::_Wrap_alloc<class std::allocator<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<int const, struct Style>>>>>>>::_Destroy(class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<int const, struct Style>>>> *, class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<int const, struct Style>>>> *)
.text$mn:0000641C                 public ?_Destroy@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@2@0@Z
.text$mn:0000641C ?_Destroy@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@2@0@Z proc near
.text$mn:0000641C                                         ; CODE XREF: std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>>>>::_Tidy(void)+2Bp
.text$mn:0000641C
.text$mn:0000641C var_8           = dword ptr -8
.text$mn:0000641C var_1           = byte ptr -1
.text$mn:0000641C arg_0           = dword ptr  8
.text$mn:0000641C arg_4           = dword ptr  0Ch
.text$mn:0000641C
.text$mn:0000641C                 push    ebp
.text$mn:0000641D                 mov     ebp, esp
.text$mn:0000641F                 sub     esp, 8
.text$mn:00006422                 mov     [ebp+var_8], ecx
.text$mn:00006425                 lea     eax, [ebp+var_1]
.text$mn:00006428                 push    eax
.text$mn:00006429                 mov     ecx, [ebp+var_8]
.text$mn:0000642C                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>>>>>::_Getal(void)
.text$mn:00006431                 lea     ecx, [ebp+var_1]
.text$mn:00006434                 push    ecx
.text$mn:00006435                 mov     edx, [ebp+arg_4]
.text$mn:00006438                 push    edx
.text$mn:00006439                 mov     eax, [ebp+arg_0]
.text$mn:0000643C                 push    eax
.text$mn:0000643D                 call    ??$_Destroy_range@U?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@0@0AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>>>>>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>> *,std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>>>> &)
.text$mn:00006442                 add     esp, 0Ch
.text$mn:00006445                 mov     esp, ebp
.text$mn:00006447                 pop     ebp
.text$mn:00006448                 retn    8
.text$mn:00006448 ?_Destroy@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@2@0@Z endp
.text$mn:00006448
.text$mn:00006448 ; ---------------------------------------------------------------------------
.text$mn:0000644B                 align 4
.text$mn:0000644B _text$mn        ends
.text$mn:0000644B
.text$mn:0000644C ; ===========================================================================
.text$mn:0000644C
.text$mn:0000644C ; Segment type: Pure code
.text$mn:0000644C ; Segment permissions: Read/Execute
.text$mn:0000644C _text$mn        segment para public 'CODE' use32
.text$mn:0000644C                 assume cs:_text$mn
.text$mn:0000644C                 ;org 644Ch
.text$mn:0000644C ; COMDAT (pick any)
.text$mn:0000644C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000644C
.text$mn:0000644C ; =============== S U B R O U T I N E =======================================
.text$mn:0000644C
.text$mn:0000644C ; Attributes: bp-based frame
.text$mn:0000644C
.text$mn:0000644C ; protected: void __thiscall std::vector<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>, struct std::_Wrap_alloc<class std::allocator<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>>>>::_Destroy(class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>> *, class std::_List_unchecked_iterator<class
.text$mn:0000644C                 public ?_Destroy@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@0@Z
.text$mn:0000644C ?_Destroy@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@0@Z proc near
.text$mn:0000644C                                         ; CODE XREF: __catch$?_Insert_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$p
.text$mn:0000644C                                         ; __catch$?_Insert_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUS ...
.text$mn:0000644C
.text$mn:0000644C var_8           = dword ptr -8
.text$mn:0000644C var_1           = byte ptr -1
.text$mn:0000644C arg_0           = dword ptr  8
.text$mn:0000644C arg_4           = dword ptr  0Ch
.text$mn:0000644C
.text$mn:0000644C                 push    ebp
.text$mn:0000644D                 mov     ebp, esp
.text$mn:0000644F                 sub     esp, 8
.text$mn:00006452                 mov     [ebp+var_8], ecx
.text$mn:00006455                 lea     eax, [ebp+var_1]
.text$mn:00006458                 push    eax
.text$mn:00006459                 mov     ecx, [ebp+var_8]
.text$mn:0000645C                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>>::_Getal(void)
.text$mn:00006461                 lea     ecx, [ebp+var_1]
.text$mn:00006464                 push    ecx
.text$mn:00006465                 mov     edx, [ebp+arg_4]
.text$mn:00006468                 push    edx
.text$mn:00006469                 mov     eax, [ebp+arg_0]
.text$mn:0000646C                 push    eax
.text$mn:0000646D                 call    ??$_Destroy_range@U?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@0AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>> &)
.text$mn:00006472                 add     esp, 0Ch
.text$mn:00006475                 mov     esp, ebp
.text$mn:00006477                 pop     ebp
.text$mn:00006478                 retn    8
.text$mn:00006478 ?_Destroy@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@0@Z endp
.text$mn:00006478
.text$mn:00006478 ; ---------------------------------------------------------------------------
.text$mn:0000647B                 align 4
.text$mn:0000647B _text$mn        ends
.text$mn:0000647B
.text$mn:0000647C ; ===========================================================================
.text$mn:0000647C
.text$mn:0000647C ; Segment type: Pure code
.text$mn:0000647C ; Segment permissions: Read/Execute
.text$mn:0000647C _text$mn        segment para public 'CODE' use32
.text$mn:0000647C                 assume cs:_text$mn
.text$mn:0000647C                 ;org 647Ch
.text$mn:0000647C ; COMDAT (pick any)
.text$mn:0000647C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000647C
.text$mn:0000647C ; =============== S U B R O U T I N E =======================================
.text$mn:0000647C
.text$mn:0000647C ; Attributes: bp-based frame
.text$mn:0000647C
.text$mn:0000647C ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Eos(unsigned int)
.text$mn:0000647C                 public ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
.text$mn:0000647C ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z proc near
.text$mn:0000647C                                         ; CODE XREF: $LN19+60p
.text$mn:0000647C                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+83p ...
.text$mn:0000647C
.text$mn:0000647C var_8           = dword ptr -8
.text$mn:0000647C var_1           = byte ptr -1
.text$mn:0000647C arg_0           = dword ptr  8
.text$mn:0000647C
.text$mn:0000647C                 push    ebp
.text$mn:0000647D                 mov     ebp, esp
.text$mn:0000647F                 sub     esp, 8
.text$mn:00006482                 mov     [ebp+var_8], ecx
.text$mn:00006485                 mov     [ebp+var_1], 0
.text$mn:00006489                 mov     eax, [ebp+var_8]
.text$mn:0000648C                 mov     ecx, [ebp+arg_0]
.text$mn:0000648F                 mov     [eax+14h], ecx
.text$mn:00006492                 lea     edx, [ebp+var_1]
.text$mn:00006495                 push    edx
.text$mn:00006496                 mov     ecx, [ebp+var_8]
.text$mn:00006499                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000649E                 add     eax, [ebp+arg_0]
.text$mn:000064A1                 push    eax
.text$mn:000064A2                 call    ?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign(char &,char const &)
.text$mn:000064A7                 add     esp, 8
.text$mn:000064AA                 mov     esp, ebp
.text$mn:000064AC                 pop     ebp
.text$mn:000064AD                 retn    4
.text$mn:000064AD ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z endp
.text$mn:000064AD
.text$mn:000064AD _text$mn        ends
.text$mn:000064AD
.text$mn:000064B0 ; ===========================================================================
.text$mn:000064B0
.text$mn:000064B0 ; Segment type: Pure code
.text$mn:000064B0 ; Segment permissions: Read/Execute
.text$mn:000064B0 _text$mn        segment para public 'CODE' use32
.text$mn:000064B0                 assume cs:_text$mn
.text$mn:000064B0                 ;org 64B0h
.text$mn:000064B0 ; COMDAT (pick any)
.text$mn:000064B0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000064B0
.text$mn:000064B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000064B0
.text$mn:000064B0 ; Attributes: bp-based frame
.text$mn:000064B0
.text$mn:000064B0 ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Eos(unsigned int)
.text$mn:000064B0                 public ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z
.text$mn:000064B0 ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z proc near
.text$mn:000064B0                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+97p
.text$mn:000064B0
.text$mn:000064B0 var_8           = dword ptr -8
.text$mn:000064B0 var_2           = word ptr -2
.text$mn:000064B0 arg_0           = dword ptr  8
.text$mn:000064B0
.text$mn:000064B0                 push    ebp
.text$mn:000064B1                 mov     ebp, esp
.text$mn:000064B3                 sub     esp, 8
.text$mn:000064B6                 mov     [ebp+var_8], ecx
.text$mn:000064B9                 xor     eax, eax
.text$mn:000064BB                 mov     [ebp+var_2], ax
.text$mn:000064BF                 mov     ecx, [ebp+var_8]
.text$mn:000064C2                 mov     edx, [ebp+arg_0]
.text$mn:000064C5                 mov     [ecx+14h], edx
.text$mn:000064C8                 lea     eax, [ebp+var_2]
.text$mn:000064CB                 push    eax
.text$mn:000064CC                 mov     ecx, [ebp+var_8]
.text$mn:000064CF                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:000064D4                 mov     ecx, [ebp+arg_0]
.text$mn:000064D7                 lea     edx, [eax+ecx*2]
.text$mn:000064DA                 push    edx
.text$mn:000064DB                 call    ?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z ; std::char_traits<wchar_t>::assign(wchar_t &,wchar_t const &)
.text$mn:000064E0                 add     esp, 8
.text$mn:000064E3                 mov     esp, ebp
.text$mn:000064E5                 pop     ebp
.text$mn:000064E6                 retn    4
.text$mn:000064E6 ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z endp
.text$mn:000064E6
.text$mn:000064E6 ; ---------------------------------------------------------------------------
.text$mn:000064E9                 align 4
.text$mn:000064E9 _text$mn        ends
.text$mn:000064E9
.text$mn:000064EC ; ===========================================================================
.text$mn:000064EC
.text$mn:000064EC ; Segment type: Pure code
.text$mn:000064EC ; Segment permissions: Read/Execute
.text$mn:000064EC _text$mn        segment para public 'CODE' use32
.text$mn:000064EC                 assume cs:_text$mn
.text$mn:000064EC                 ;org 64ECh
.text$mn:000064EC ; COMDAT (pick any)
.text$mn:000064EC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000064EC
.text$mn:000064EC ; =============== S U B R O U T I N E =======================================
.text$mn:000064EC
.text$mn:000064EC ; Attributes: bp-based frame
.text$mn:000064EC
.text$mn:000064EC ; public: void __thiscall std::_List_alloc<0, struct std::_List_base_types<struct std::pair<int const, struct Style>, class std::allocator<struct std::pair<int const, struct Style>>>>::_Free_proxy(void)
.text$mn:000064EC                 public ?_Free_proxy@?$_List_alloc@$0A@U?$_List_base_types@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@@std@@QAEXXZ
.text$mn:000064EC ?_Free_proxy@?$_List_alloc@$0A@U?$_List_base_types@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@@std@@QAEXXZ proc near
.text$mn:000064EC                                         ; CODE XREF: std::_List_alloc<0,std::_List_base_types<std::pair<int const,Style>,std::allocator<std::pair<int const,Style>>>>::~_List_alloc<0,std::_List_base_types<std::pair<int const,Style>,std::allocator<std::pair<int const,Style>>>>(void)+3Fp
.text$mn:000064EC
.text$mn:000064EC var_8           = dword ptr -8
.text$mn:000064EC var_1           = byte ptr -1
.text$mn:000064EC
.text$mn:000064EC                 push    ebp
.text$mn:000064ED                 mov     ebp, esp
.text$mn:000064EF                 sub     esp, 8
.text$mn:000064F2                 mov     [ebp+var_8], ecx
.text$mn:000064F5                 lea     ecx, [ebp+var_1]
.text$mn:000064F8                 call    ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::_Wrap_alloc<std::allocator<std::_Container_proxy>>(void)
.text$mn:000064FD                 mov     ecx, [ebp+var_8] ; this
.text$mn:00006500                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00006505                 mov     eax, [ebp+var_8]
.text$mn:00006508                 mov     ecx, [eax]
.text$mn:0000650A                 push    ecx
.text$mn:0000650B                 lea     ecx, [ebp+var_1]
.text$mn:0000650E                 call    ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:00006513                 push    1               ; int
.text$mn:00006515                 mov     edx, [ebp+var_8]
.text$mn:00006518                 mov     eax, [edx]
.text$mn:0000651A                 push    eax             ; void *
.text$mn:0000651B                 lea     ecx, [ebp+var_1]
.text$mn:0000651E                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::deallocate(std::_Container_proxy *,uint)
.text$mn:00006523                 mov     ecx, [ebp+var_8]
.text$mn:00006526                 mov     dword ptr [ecx], 0
.text$mn:0000652C                 mov     esp, ebp
.text$mn:0000652E                 pop     ebp
.text$mn:0000652F                 retn
.text$mn:0000652F ?_Free_proxy@?$_List_alloc@$0A@U?$_List_base_types@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@@std@@QAEXXZ endp
.text$mn:0000652F
.text$mn:0000652F _text$mn        ends
.text$mn:0000652F
.text$mn:00006530 ; ===========================================================================
.text$mn:00006530
.text$mn:00006530 ; Segment type: Pure code
.text$mn:00006530 ; Segment permissions: Read/Execute
.text$mn:00006530 _text$mn        segment para public 'CODE' use32
.text$mn:00006530                 assume cs:_text$mn
.text$mn:00006530                 ;org 6530h
.text$mn:00006530 ; COMDAT (pick any)
.text$mn:00006530                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006530
.text$mn:00006530 ; =============== S U B R O U T I N E =======================================
.text$mn:00006530
.text$mn:00006530 ; Attributes: bp-based frame
.text$mn:00006530
.text$mn:00006530 ; public: void __thiscall std::_List_alloc<0, struct std::_List_base_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>, class std::allocator<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>::_Free_proxy(void)
.text$mn:00006530                 public ?_Free_proxy@?$_List_alloc@$0A@U?$_List_base_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@@std@@QAEXXZ
.text$mn:00006530 ?_Free_proxy@?$_List_alloc@$0A@U?$_List_base_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@@std@@QAEXXZ proc near
.text$mn:00006530                                         ; CODE XREF: std::_List_alloc<0,std::_List_base_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::~_List_alloc<0,std::_List_base_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>(void)+3Fp
.text$mn:00006530
.text$mn:00006530 var_8           = dword ptr -8
.text$mn:00006530 var_1           = byte ptr -1
.text$mn:00006530
.text$mn:00006530                 push    ebp
.text$mn:00006531                 mov     ebp, esp
.text$mn:00006533                 sub     esp, 8
.text$mn:00006536                 mov     [ebp+var_8], ecx
.text$mn:00006539                 lea     ecx, [ebp+var_1]
.text$mn:0000653C                 call    ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::_Wrap_alloc<std::allocator<std::_Container_proxy>>(void)
.text$mn:00006541                 mov     ecx, [ebp+var_8] ; this
.text$mn:00006544                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00006549                 mov     eax, [ebp+var_8]
.text$mn:0000654C                 mov     ecx, [eax]
.text$mn:0000654E                 push    ecx
.text$mn:0000654F                 lea     ecx, [ebp+var_1]
.text$mn:00006552                 call    ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:00006557                 push    1               ; int
.text$mn:00006559                 mov     edx, [ebp+var_8]
.text$mn:0000655C                 mov     eax, [edx]
.text$mn:0000655E                 push    eax             ; void *
.text$mn:0000655F                 lea     ecx, [ebp+var_1]
.text$mn:00006562                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::deallocate(std::_Container_proxy *,uint)
.text$mn:00006567                 mov     ecx, [ebp+var_8]
.text$mn:0000656A                 mov     dword ptr [ecx], 0
.text$mn:00006570                 mov     esp, ebp
.text$mn:00006572                 pop     ebp
.text$mn:00006573                 retn
.text$mn:00006573 ?_Free_proxy@?$_List_alloc@$0A@U?$_List_base_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@@std@@QAEXXZ endp
.text$mn:00006573
.text$mn:00006573 _text$mn        ends
.text$mn:00006573
.text$mn:00006574 ; ===========================================================================
.text$mn:00006574
.text$mn:00006574 ; Segment type: Pure code
.text$mn:00006574 ; Segment permissions: Read/Execute
.text$mn:00006574 _text$mn        segment para public 'CODE' use32
.text$mn:00006574                 assume cs:_text$mn
.text$mn:00006574                 ;org 6574h
.text$mn:00006574 ; COMDAT (pick any)
.text$mn:00006574                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006574
.text$mn:00006574 ; =============== S U B R O U T I N E =======================================
.text$mn:00006574
.text$mn:00006574 ; Attributes: bp-based frame
.text$mn:00006574
.text$mn:00006574 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Free_proxy(void)
.text$mn:00006574                 public ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
.text$mn:00006574 ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00006574                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+30p
.text$mn:00006574
.text$mn:00006574 var_8           = dword ptr -8
.text$mn:00006574 var_1           = byte ptr -1
.text$mn:00006574
.text$mn:00006574                 push    ebp
.text$mn:00006575                 mov     ebp, esp
.text$mn:00006577                 sub     esp, 8
.text$mn:0000657A                 mov     [ebp+var_8], ecx
.text$mn:0000657D                 lea     ecx, [ebp+var_1]
.text$mn:00006580                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:00006585                 mov     ecx, [ebp+var_8] ; this
.text$mn:00006588                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:0000658D                 mov     eax, [ebp+var_8]
.text$mn:00006590                 mov     ecx, [eax]
.text$mn:00006592                 push    ecx
.text$mn:00006593                 lea     ecx, [ebp+var_1]
.text$mn:00006596                 call    ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:0000659B                 push    1               ; int
.text$mn:0000659D                 mov     edx, [ebp+var_8]
.text$mn:000065A0                 mov     eax, [edx]
.text$mn:000065A2                 push    eax             ; void *
.text$mn:000065A3                 lea     ecx, [ebp+var_1]
.text$mn:000065A6                 call    ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate(std::_Container_proxy *,uint)
.text$mn:000065AB                 mov     ecx, [ebp+var_8]
.text$mn:000065AE                 mov     dword ptr [ecx], 0
.text$mn:000065B4                 mov     esp, ebp
.text$mn:000065B6                 pop     ebp
.text$mn:000065B7                 retn
.text$mn:000065B7 ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp
.text$mn:000065B7
.text$mn:000065B7 _text$mn        ends
.text$mn:000065B7
.text$mn:000065B8 ; ===========================================================================
.text$mn:000065B8
.text$mn:000065B8 ; Segment type: Pure code
.text$mn:000065B8 ; Segment permissions: Read/Execute
.text$mn:000065B8 _text$mn        segment para public 'CODE' use32
.text$mn:000065B8                 assume cs:_text$mn
.text$mn:000065B8                 ;org 65B8h
.text$mn:000065B8 ; COMDAT (pick any)
.text$mn:000065B8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000065B8
.text$mn:000065B8 ; =============== S U B R O U T I N E =======================================
.text$mn:000065B8
.text$mn:000065B8 ; Attributes: bp-based frame
.text$mn:000065B8
.text$mn:000065B8 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>::_Free_proxy(void)
.text$mn:000065B8                 public ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ
.text$mn:000065B8 ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ proc near
.text$mn:000065B8                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)+30p
.text$mn:000065B8
.text$mn:000065B8 var_8           = dword ptr -8
.text$mn:000065B8 var_1           = byte ptr -1
.text$mn:000065B8
.text$mn:000065B8                 push    ebp
.text$mn:000065B9                 mov     ebp, esp
.text$mn:000065BB                 sub     esp, 8
.text$mn:000065BE                 mov     [ebp+var_8], ecx
.text$mn:000065C1                 lea     ecx, [ebp+var_1]
.text$mn:000065C4                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:000065C9                 mov     ecx, [ebp+var_8] ; this
.text$mn:000065CC                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:000065D1                 mov     eax, [ebp+var_8]
.text$mn:000065D4                 mov     ecx, [eax]
.text$mn:000065D6                 push    ecx
.text$mn:000065D7                 lea     ecx, [ebp+var_1]
.text$mn:000065DA                 call    ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:000065DF                 push    1               ; int
.text$mn:000065E1                 mov     edx, [ebp+var_8]
.text$mn:000065E4                 mov     eax, [edx]
.text$mn:000065E6                 push    eax             ; void *
.text$mn:000065E7                 lea     ecx, [ebp+var_1]
.text$mn:000065EA                 call    ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate(std::_Container_proxy *,uint)
.text$mn:000065EF                 mov     ecx, [ebp+var_8]
.text$mn:000065F2                 mov     dword ptr [ecx], 0
.text$mn:000065F8                 mov     esp, ebp
.text$mn:000065FA                 pop     ebp
.text$mn:000065FB                 retn
.text$mn:000065FB ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ endp
.text$mn:000065FB
.text$mn:000065FB _text$mn        ends
.text$mn:000065FB
.text$mn:000065FC ; ===========================================================================
.text$mn:000065FC
.text$mn:000065FC ; Segment type: Pure code
.text$mn:000065FC ; Segment permissions: Read/Execute
.text$mn:000065FC _text$mn        segment para public 'CODE' use32
.text$mn:000065FC                 assume cs:_text$mn
.text$mn:000065FC                 ;org 65FCh
.text$mn:000065FC ; COMDAT (pick any)
.text$mn:000065FC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000065FC
.text$mn:000065FC ; =============== S U B R O U T I N E =======================================
.text$mn:000065FC
.text$mn:000065FC ; Attributes: bp-based frame
.text$mn:000065FC
.text$mn:000065FC ; public: void __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<int const, struct Style>>>>, struct std::_Wrap_alloc<class std::allocator<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<int const, struct Style>>>>>>>>::_Free_proxy(void)
.text$mn:000065FC                 public ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QAEXXZ
.text$mn:000065FC ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QAEXXZ proc near
.text$mn:000065FC                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>>>>>::~_Vector_alloc<0,std::_Vec_base_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>>>>>(void)+30p
.text$mn:000065FC
.text$mn:000065FC var_8           = dword ptr -8
.text$mn:000065FC var_1           = byte ptr -1
.text$mn:000065FC
.text$mn:000065FC                 push    ebp
.text$mn:000065FD                 mov     ebp, esp
.text$mn:000065FF                 sub     esp, 8
.text$mn:00006602                 mov     [ebp+var_8], ecx
.text$mn:00006605                 lea     ecx, [ebp+var_1]
.text$mn:00006608                 call    ??0?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_Container_proxy>>>::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_Container_proxy>>>(void)
.text$mn:0000660D                 mov     ecx, [ebp+var_8] ; this
.text$mn:00006610                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00006615                 mov     eax, [ebp+var_8]
.text$mn:00006618                 mov     ecx, [eax]
.text$mn:0000661A                 push    ecx
.text$mn:0000661B                 lea     ecx, [ebp+var_1]
.text$mn:0000661E                 call    ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_Container_proxy>>>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:00006623                 push    1               ; int
.text$mn:00006625                 mov     edx, [ebp+var_8]
.text$mn:00006628                 mov     eax, [edx]
.text$mn:0000662A                 push    eax             ; void *
.text$mn:0000662B                 lea     ecx, [ebp+var_1]
.text$mn:0000662E                 call    ?deallocate@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_Container_proxy>>>::deallocate(std::_Container_proxy *,uint)
.text$mn:00006633                 mov     ecx, [ebp+var_8]
.text$mn:00006636                 mov     dword ptr [ecx], 0
.text$mn:0000663C                 mov     esp, ebp
.text$mn:0000663E                 pop     ebp
.text$mn:0000663F                 retn
.text$mn:0000663F ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QAEXXZ endp
.text$mn:0000663F
.text$mn:0000663F _text$mn        ends
.text$mn:0000663F
.text$mn:00006640 ; ===========================================================================
.text$mn:00006640
.text$mn:00006640 ; Segment type: Pure code
.text$mn:00006640 ; Segment permissions: Read/Execute
.text$mn:00006640 _text$mn        segment para public 'CODE' use32
.text$mn:00006640                 assume cs:_text$mn
.text$mn:00006640                 ;org 6640h
.text$mn:00006640 ; COMDAT (pick any)
.text$mn:00006640                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006640
.text$mn:00006640 ; =============== S U B R O U T I N E =======================================
.text$mn:00006640
.text$mn:00006640 ; Attributes: bp-based frame
.text$mn:00006640
.text$mn:00006640 ; public: void __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>, struct std::_Wrap_alloc<class std::allocator<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>>>>>::_Free_proxy(void)
.text$mn:00006640                 public ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QAEXXZ
.text$mn:00006640 ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QAEXXZ proc near
.text$mn:00006640                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>>::~_Vector_alloc<0,std::_Vec_base_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>>(void)+30p
.text$mn:00006640
.text$mn:00006640 var_8           = dword ptr -8
.text$mn:00006640 var_1           = byte ptr -1
.text$mn:00006640
.text$mn:00006640                 push    ebp
.text$mn:00006641                 mov     ebp, esp
.text$mn:00006643                 sub     esp, 8
.text$mn:00006646                 mov     [ebp+var_8], ecx
.text$mn:00006649                 lea     ecx, [ebp+var_1]
.text$mn:0000664C                 call    ??0?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_Container_proxy>>>::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_Container_proxy>>>(void)
.text$mn:00006651                 mov     ecx, [ebp+var_8] ; this
.text$mn:00006654                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00006659                 mov     eax, [ebp+var_8]
.text$mn:0000665C                 mov     ecx, [eax]
.text$mn:0000665E                 push    ecx
.text$mn:0000665F                 lea     ecx, [ebp+var_1]
.text$mn:00006662                 call    ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_Container_proxy>>>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:00006667                 push    1               ; int
.text$mn:00006669                 mov     edx, [ebp+var_8]
.text$mn:0000666C                 mov     eax, [edx]
.text$mn:0000666E                 push    eax             ; void *
.text$mn:0000666F                 lea     ecx, [ebp+var_1]
.text$mn:00006672                 call    ?deallocate@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_Container_proxy>>>::deallocate(std::_Container_proxy *,uint)
.text$mn:00006677                 mov     ecx, [ebp+var_8]
.text$mn:0000667A                 mov     dword ptr [ecx], 0
.text$mn:00006680                 mov     esp, ebp
.text$mn:00006682                 pop     ebp
.text$mn:00006683                 retn
.text$mn:00006683 ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QAEXXZ endp
.text$mn:00006683
.text$mn:00006683 _text$mn        ends
.text$mn:00006683
.text$mn:00006684 ; ===========================================================================
.text$mn:00006684
.text$mn:00006684 ; Segment type: Pure code
.text$mn:00006684 ; Segment permissions: Read/Execute
.text$mn:00006684 _text$mn        segment para public 'CODE' use32
.text$mn:00006684                 assume cs:_text$mn
.text$mn:00006684                 ;org 6684h
.text$mn:00006684 ; COMDAT (pick any)
.text$mn:00006684                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006684
.text$mn:00006684 ; =============== S U B R O U T I N E =======================================
.text$mn:00006684
.text$mn:00006684 ; Attributes: bp-based frame
.text$mn:00006684
.text$mn:00006684 ; int __stdcall std::_List_alloc<0,std::_List_base_types<std::pair<int const,Style>,std::allocator<std::pair<int const,Style>>>>::_Freeheadnode(void *)
.text$mn:00006684                 public ?_Freeheadnode@?$_List_alloc@$0A@U?$_List_base_types@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@@std@@QAEXPAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@2@@Z
.text$mn:00006684 ?_Freeheadnode@?$_List_alloc@$0A@U?$_List_base_types@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@@std@@QAEXPAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@2@@Z proc near
.text$mn:00006684                                         ; CODE XREF: std::_List_alloc<0,std::_List_base_types<std::pair<int const,Style>,std::allocator<std::pair<int const,Style>>>>::~_List_alloc<0,std::_List_base_types<std::pair<int const,Style>,std::allocator<std::pair<int const,Style>>>>(void)+37p
.text$mn:00006684
.text$mn:00006684 var_8           = dword ptr -8
.text$mn:00006684 var_3           = byte ptr -3
.text$mn:00006684 var_2           = byte ptr -2
.text$mn:00006684 var_1           = byte ptr -1
.text$mn:00006684 arg_0           = dword ptr  8
.text$mn:00006684
.text$mn:00006684                 push    ebp
.text$mn:00006685                 mov     ebp, esp
.text$mn:00006687                 sub     esp, 8
.text$mn:0000668A                 mov     [ebp+var_8], ecx
.text$mn:0000668D                 mov     eax, [ebp+arg_0]
.text$mn:00006690                 push    eax
.text$mn:00006691                 call    ?_Nextnode@?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@SAAAPAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@2@PAU32@@Z ; std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>::_Nextnode(std::_List_node<std::pair<int const,Style>,void *> *)
.text$mn:00006696                 add     esp, 4
.text$mn:00006699                 push    eax
.text$mn:0000669A                 call    ??$addressof@PAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@std@@@std@@YAPAPAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@0@AAPAU10@@Z ; std::addressof<std::_List_node<std::pair<int const,Style>,void *> *>(std::_List_node<std::pair<int const,Style>,void *> * &)
.text$mn:0000669F                 add     esp, 4
.text$mn:000066A2                 push    eax
.text$mn:000066A3                 lea     ecx, [ebp+var_1]
.text$mn:000066A6                 push    ecx
.text$mn:000066A7                 mov     ecx, [ebp+var_8]
.text$mn:000066AA                 call    ?_Getal@?$_List_alloc@$0A@U?$_List_base_types@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@std@@@std@@@2@XZ ; std::_List_alloc<0,std::_List_base_types<std::pair<int const,Style>,std::allocator<std::pair<int const,Style>>>>::_Getal(void)
.text$mn:000066AF                 mov     ecx, eax
.text$mn:000066B1                 call    ??$destroy@PAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@1@@Z ; std::_Wrap_alloc<std::allocator<std::_List_node<std::pair<int const,Style>,void *>>>::destroy<std::_List_node<std::pair<int const,Style>,void *> *>(std::_List_node<std::pair<int const,Style>,void *> * *)
.text$mn:000066B6                 mov     edx, [ebp+arg_0]
.text$mn:000066B9                 push    edx
.text$mn:000066BA                 call    ?_Prevnode@?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@SAAAPAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@2@PAU32@@Z ; std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>::_Prevnode(std::_List_node<std::pair<int const,Style>,void *> *)
.text$mn:000066BF                 add     esp, 4
.text$mn:000066C2                 push    eax
.text$mn:000066C3                 call    ??$addressof@PAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@std@@@std@@YAPAPAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@0@AAPAU10@@Z ; std::addressof<std::_List_node<std::pair<int const,Style>,void *> *>(std::_List_node<std::pair<int const,Style>,void *> * &)
.text$mn:000066C8                 add     esp, 4
.text$mn:000066CB                 push    eax
.text$mn:000066CC                 lea     eax, [ebp+var_2]
.text$mn:000066CF                 push    eax
.text$mn:000066D0                 mov     ecx, [ebp+var_8]
.text$mn:000066D3                 call    ?_Getal@?$_List_alloc@$0A@U?$_List_base_types@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@std@@@std@@@2@XZ ; std::_List_alloc<0,std::_List_base_types<std::pair<int const,Style>,std::allocator<std::pair<int const,Style>>>>::_Getal(void)
.text$mn:000066D8                 mov     ecx, eax
.text$mn:000066DA                 call    ??$destroy@PAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@1@@Z ; std::_Wrap_alloc<std::allocator<std::_List_node<std::pair<int const,Style>,void *>>>::destroy<std::_List_node<std::pair<int const,Style>,void *> *>(std::_List_node<std::pair<int const,Style>,void *> * *)
.text$mn:000066DF                 push    1               ; int
.text$mn:000066E1                 mov     ecx, [ebp+arg_0]
.text$mn:000066E4                 push    ecx             ; void *
.text$mn:000066E5                 lea     edx, [ebp+var_3]
.text$mn:000066E8                 push    edx
.text$mn:000066E9                 mov     ecx, [ebp+var_8]
.text$mn:000066EC                 call    ?_Getal@?$_List_alloc@$0A@U?$_List_base_types@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@std@@@std@@@2@XZ ; std::_List_alloc<0,std::_List_base_types<std::pair<int const,Style>,std::allocator<std::pair<int const,Style>>>>::_Getal(void)
.text$mn:000066F1                 mov     ecx, eax
.text$mn:000066F3                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_List_node<std::pair<int const,Style>,void *>>>::deallocate(std::_List_node<std::pair<int const,Style>,void *> *,uint)
.text$mn:000066F8                 mov     esp, ebp
.text$mn:000066FA                 pop     ebp
.text$mn:000066FB                 retn    4
.text$mn:000066FB ?_Freeheadnode@?$_List_alloc@$0A@U?$_List_base_types@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@@std@@QAEXPAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@2@@Z endp
.text$mn:000066FB
.text$mn:000066FB ; ---------------------------------------------------------------------------
.text$mn:000066FE                 align 10h
.text$mn:000066FE _text$mn        ends
.text$mn:000066FE
.text$mn:00006700 ; ===========================================================================
.text$mn:00006700
.text$mn:00006700 ; Segment type: Pure code
.text$mn:00006700 ; Segment permissions: Read/Execute
.text$mn:00006700 _text$mn        segment para public 'CODE' use32
.text$mn:00006700                 assume cs:_text$mn
.text$mn:00006700                 ;org 6700h
.text$mn:00006700 ; COMDAT (pick any)
.text$mn:00006700                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006700
.text$mn:00006700 ; =============== S U B R O U T I N E =======================================
.text$mn:00006700
.text$mn:00006700 ; Attributes: bp-based frame
.text$mn:00006700
.text$mn:00006700 ; int __stdcall std::_List_alloc<0,std::_List_base_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::_Freeheadnode(void *)
.text$mn:00006700                 public ?_Freeheadnode@?$_List_alloc@$0A@U?$_List_base_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@@std@@QAEXPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@2@@Z
.text$mn:00006700 ?_Freeheadnode@?$_List_alloc@$0A@U?$_List_base_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@@std@@QAEXPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@2@@Z proc near
.text$mn:00006700                                         ; CODE XREF: __catch$??0?$_List_alloc@$0A@U?$_List_base_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@1@@Z$0+Ap
.text$mn:00006700                                         ; std::_List_alloc<0,std::_List_base_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::~_List_alloc<0,std::_List_base_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>(void)+37p
.text$mn:00006700
.text$mn:00006700 var_8           = dword ptr -8
.text$mn:00006700 var_3           = byte ptr -3
.text$mn:00006700 var_2           = byte ptr -2
.text$mn:00006700 var_1           = byte ptr -1
.text$mn:00006700 arg_0           = dword ptr  8
.text$mn:00006700
.text$mn:00006700                 push    ebp
.text$mn:00006701                 mov     ebp, esp
.text$mn:00006703                 sub     esp, 8
.text$mn:00006706                 mov     [ebp+var_8], ecx
.text$mn:00006709                 mov     eax, [ebp+arg_0]
.text$mn:0000670C                 push    eax
.text$mn:0000670D                 call    ?_Nextnode@?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@SAAAPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@2@PAU32@@Z ; std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>::_Nextnode(std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *)
.text$mn:00006712                 add     esp, 4
.text$mn:00006715                 push    eax
.text$mn:00006716                 call    ??$addressof@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@YAPAPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@0@AAPAU10@@Z ; std::addressof<std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *>(std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> * &)
.text$mn:0000671B                 add     esp, 4
.text$mn:0000671E                 push    eax
.text$mn:0000671F                 lea     ecx, [ebp+var_1]
.text$mn:00006722                 push    ecx
.text$mn:00006723                 mov     ecx, [ebp+var_8]
.text$mn:00006726                 call    ?_Getal@?$_List_alloc@$0A@U?$_List_base_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@@2@XZ ; std::_List_alloc<0,std::_List_base_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::_Getal(void)
.text$mn:0000672B                 mov     ecx, eax
.text$mn:0000672D                 call    ??$destroy@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@1@@Z ; std::_Wrap_alloc<std::allocator<std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *>>>::destroy<std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *>(std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> * *)
.text$mn:00006732                 mov     edx, [ebp+arg_0]
.text$mn:00006735                 push    edx
.text$mn:00006736                 call    ?_Prevnode@?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@SAAAPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@2@PAU32@@Z ; std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>::_Prevnode(std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *)
.text$mn:0000673B                 add     esp, 4
.text$mn:0000673E                 push    eax
.text$mn:0000673F                 call    ??$addressof@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@YAPAPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@0@AAPAU10@@Z ; std::addressof<std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *>(std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> * &)
.text$mn:00006744                 add     esp, 4
.text$mn:00006747                 push    eax
.text$mn:00006748                 lea     eax, [ebp+var_2]
.text$mn:0000674B                 push    eax
.text$mn:0000674C                 mov     ecx, [ebp+var_8]
.text$mn:0000674F                 call    ?_Getal@?$_List_alloc@$0A@U?$_List_base_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@@2@XZ ; std::_List_alloc<0,std::_List_base_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::_Getal(void)
.text$mn:00006754                 mov     ecx, eax
.text$mn:00006756                 call    ??$destroy@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@1@@Z ; std::_Wrap_alloc<std::allocator<std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *>>>::destroy<std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *>(std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> * *)
.text$mn:0000675B                 push    1               ; int
.text$mn:0000675D                 mov     ecx, [ebp+arg_0]
.text$mn:00006760                 push    ecx             ; void *
.text$mn:00006761                 lea     edx, [ebp+var_3]
.text$mn:00006764                 push    edx
.text$mn:00006765                 mov     ecx, [ebp+var_8]
.text$mn:00006768                 call    ?_Getal@?$_List_alloc@$0A@U?$_List_base_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@@2@XZ ; std::_List_alloc<0,std::_List_base_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::_Getal(void)
.text$mn:0000676D                 mov     ecx, eax
.text$mn:0000676F                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *>>>::deallocate(std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *,uint)
.text$mn:00006774                 mov     esp, ebp
.text$mn:00006776                 pop     ebp
.text$mn:00006777                 retn    4
.text$mn:00006777 ?_Freeheadnode@?$_List_alloc@$0A@U?$_List_base_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@@std@@QAEXPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@2@@Z endp
.text$mn:00006777
.text$mn:00006777 ; ---------------------------------------------------------------------------
.text$mn:0000677A                 align 4
.text$mn:0000677A _text$mn        ends
.text$mn:0000677A
.text$mn:0000677C ; ===========================================================================
.text$mn:0000677C
.text$mn:0000677C ; Segment type: Pure code
.text$mn:0000677C ; Segment permissions: Read/Execute
.text$mn:0000677C _text$mn        segment para public 'CODE' use32
.text$mn:0000677C                 assume cs:_text$mn
.text$mn:0000677C                 ;org 677Ch
.text$mn:0000677C ; COMDAT (pick any)
.text$mn:0000677C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000677C
.text$mn:0000677C ; =============== S U B R O U T I N E =======================================
.text$mn:0000677C
.text$mn:0000677C ; Attributes: bp-based frame
.text$mn:0000677C
.text$mn:0000677C ; int __stdcall std::_List_buy<std::pair<int const,Style>,std::allocator<std::pair<int const,Style>>>::_Freenode(void *)
.text$mn:0000677C                 public ?_Freenode@?$_List_buy@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@QAEXPAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@2@@Z
.text$mn:0000677C ?_Freenode@?$_List_buy@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@QAEXPAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@2@@Z proc near
.text$mn:0000677C                                         ; CODE XREF: std::list<std::pair<int const,Style>,std::allocator<std::pair<int const,Style>>>::clear(void)+8Ep
.text$mn:0000677C
.text$mn:0000677C var_8           = dword ptr -8
.text$mn:0000677C var_4           = byte ptr -4
.text$mn:0000677C var_3           = byte ptr -3
.text$mn:0000677C var_2           = byte ptr -2
.text$mn:0000677C var_1           = byte ptr -1
.text$mn:0000677C arg_0           = dword ptr  8
.text$mn:0000677C
.text$mn:0000677C                 push    ebp
.text$mn:0000677D                 mov     ebp, esp
.text$mn:0000677F                 sub     esp, 8
.text$mn:00006782                 mov     [ebp+var_8], ecx
.text$mn:00006785                 mov     eax, [ebp+arg_0]
.text$mn:00006788                 push    eax
.text$mn:00006789                 call    ?_Nextnode@?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@SAAAPAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@2@PAU32@@Z ; std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>::_Nextnode(std::_List_node<std::pair<int const,Style>,void *> *)
.text$mn:0000678E                 add     esp, 4
.text$mn:00006791                 push    eax
.text$mn:00006792                 call    ??$addressof@PAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@std@@@std@@YAPAPAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@0@AAPAU10@@Z ; std::addressof<std::_List_node<std::pair<int const,Style>,void *> *>(std::_List_node<std::pair<int const,Style>,void *> * &)
.text$mn:00006797                 add     esp, 4
.text$mn:0000679A                 push    eax
.text$mn:0000679B                 lea     ecx, [ebp+var_1]
.text$mn:0000679E                 push    ecx
.text$mn:0000679F                 mov     ecx, [ebp+var_8]
.text$mn:000067A2                 call    ?_Getal@?$_List_alloc@$0A@U?$_List_base_types@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@std@@@std@@@2@XZ ; std::_List_alloc<0,std::_List_base_types<std::pair<int const,Style>,std::allocator<std::pair<int const,Style>>>>::_Getal(void)
.text$mn:000067A7                 mov     ecx, eax
.text$mn:000067A9                 call    ??$destroy@PAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@1@@Z ; std::_Wrap_alloc<std::allocator<std::_List_node<std::pair<int const,Style>,void *>>>::destroy<std::_List_node<std::pair<int const,Style>,void *> *>(std::_List_node<std::pair<int const,Style>,void *> * *)
.text$mn:000067AE                 mov     edx, [ebp+arg_0]
.text$mn:000067B1                 push    edx
.text$mn:000067B2                 call    ?_Prevnode@?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@SAAAPAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@2@PAU32@@Z ; std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>::_Prevnode(std::_List_node<std::pair<int const,Style>,void *> *)
.text$mn:000067B7                 add     esp, 4
.text$mn:000067BA                 push    eax
.text$mn:000067BB                 call    ??$addressof@PAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@std@@@std@@YAPAPAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@0@AAPAU10@@Z ; std::addressof<std::_List_node<std::pair<int const,Style>,void *> *>(std::_List_node<std::pair<int const,Style>,void *> * &)
.text$mn:000067C0                 add     esp, 4
.text$mn:000067C3                 push    eax
.text$mn:000067C4                 lea     eax, [ebp+var_2]
.text$mn:000067C7                 push    eax
.text$mn:000067C8                 mov     ecx, [ebp+var_8]
.text$mn:000067CB                 call    ?_Getal@?$_List_alloc@$0A@U?$_List_base_types@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@std@@@std@@@2@XZ ; std::_List_alloc<0,std::_List_base_types<std::pair<int const,Style>,std::allocator<std::pair<int const,Style>>>>::_Getal(void)
.text$mn:000067D0                 mov     ecx, eax
.text$mn:000067D2                 call    ??$destroy@PAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@1@@Z ; std::_Wrap_alloc<std::allocator<std::_List_node<std::pair<int const,Style>,void *>>>::destroy<std::_List_node<std::pair<int const,Style>,void *> *>(std::_List_node<std::pair<int const,Style>,void *> * *)
.text$mn:000067D7                 mov     ecx, [ebp+arg_0]
.text$mn:000067DA                 push    ecx
.text$mn:000067DB                 call    ?_Myval@?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@SAAAU?$pair@$$CBHUStyle@@@2@PAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@2@@Z ; std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>::_Myval(std::_List_node<std::pair<int const,Style>,void *> *)
.text$mn:000067E0                 add     esp, 4
.text$mn:000067E3                 push    eax
.text$mn:000067E4                 call    ??$addressof@U?$pair@$$CBHUStyle@@@std@@@std@@YAPAU?$pair@$$CBHUStyle@@@0@AAU10@@Z ; std::addressof<std::pair<int const,Style>>(std::pair<int const,Style> &)
.text$mn:000067E9                 add     esp, 4
.text$mn:000067EC                 push    eax
.text$mn:000067ED                 lea     edx, [ebp+var_3]
.text$mn:000067F0                 push    edx
.text$mn:000067F1                 mov     ecx, [ebp+var_8]
.text$mn:000067F4                 call    ?_Getal@?$_List_alloc@$0A@U?$_List_base_types@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@std@@@std@@@2@XZ ; std::_List_alloc<0,std::_List_base_types<std::pair<int const,Style>,std::allocator<std::pair<int const,Style>>>>::_Getal(void)
.text$mn:000067F9                 mov     ecx, eax
.text$mn:000067FB                 call    ??$destroy@U?$pair@$$CBHUStyle@@@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBHUStyle@@@1@@Z ; std::_Wrap_alloc<std::allocator<std::_List_node<std::pair<int const,Style>,void *>>>::destroy<std::pair<int const,Style>>(std::pair<int const,Style> *)
.text$mn:00006800                 push    1               ; int
.text$mn:00006802                 mov     eax, [ebp+arg_0]
.text$mn:00006805                 push    eax             ; void *
.text$mn:00006806                 lea     ecx, [ebp+var_4]
.text$mn:00006809                 push    ecx
.text$mn:0000680A                 mov     ecx, [ebp+var_8]
.text$mn:0000680D                 call    ?_Getal@?$_List_alloc@$0A@U?$_List_base_types@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@std@@@std@@@2@XZ ; std::_List_alloc<0,std::_List_base_types<std::pair<int const,Style>,std::allocator<std::pair<int const,Style>>>>::_Getal(void)
.text$mn:00006812                 mov     ecx, eax
.text$mn:00006814                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_List_node<std::pair<int const,Style>,void *>>>::deallocate(std::_List_node<std::pair<int const,Style>,void *> *,uint)
.text$mn:00006819                 mov     esp, ebp
.text$mn:0000681B                 pop     ebp
.text$mn:0000681C                 retn    4
.text$mn:0000681C ?_Freenode@?$_List_buy@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@QAEXPAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@2@@Z endp
.text$mn:0000681C
.text$mn:0000681C ; ---------------------------------------------------------------------------
.text$mn:0000681F                 align 10h
.text$mn:0000681F _text$mn        ends
.text$mn:0000681F
.text$mn:00006820 ; ===========================================================================
.text$mn:00006820
.text$mn:00006820 ; Segment type: Pure code
.text$mn:00006820 ; Segment permissions: Read/Execute
.text$mn:00006820 _text$mn        segment para public 'CODE' use32
.text$mn:00006820                 assume cs:_text$mn
.text$mn:00006820                 ;org 6820h
.text$mn:00006820 ; COMDAT (pick any)
.text$mn:00006820                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006820
.text$mn:00006820 ; =============== S U B R O U T I N E =======================================
.text$mn:00006820
.text$mn:00006820 ; Attributes: bp-based frame
.text$mn:00006820
.text$mn:00006820 ; int __stdcall std::_List_buy<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>::_Freenode(void *)
.text$mn:00006820                 public ?_Freenode@?$_List_buy@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAEXPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@2@@Z
.text$mn:00006820 ?_Freenode@?$_List_buy@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAEXPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@2@@Z proc near
.text$mn:00006820                                         ; CODE XREF: std::list<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>::clear(void)+8Ep
.text$mn:00006820
.text$mn:00006820 var_8           = dword ptr -8
.text$mn:00006820 var_4           = byte ptr -4
.text$mn:00006820 var_3           = byte ptr -3
.text$mn:00006820 var_2           = byte ptr -2
.text$mn:00006820 var_1           = byte ptr -1
.text$mn:00006820 arg_0           = dword ptr  8
.text$mn:00006820
.text$mn:00006820                 push    ebp
.text$mn:00006821                 mov     ebp, esp
.text$mn:00006823                 sub     esp, 8
.text$mn:00006826                 mov     [ebp+var_8], ecx
.text$mn:00006829                 mov     eax, [ebp+arg_0]
.text$mn:0000682C                 push    eax
.text$mn:0000682D                 call    ?_Nextnode@?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@SAAAPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@2@PAU32@@Z ; std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>::_Nextnode(std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *)
.text$mn:00006832                 add     esp, 4
.text$mn:00006835                 push    eax
.text$mn:00006836                 call    ??$addressof@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@YAPAPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@0@AAPAU10@@Z ; std::addressof<std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *>(std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> * &)
.text$mn:0000683B                 add     esp, 4
.text$mn:0000683E                 push    eax
.text$mn:0000683F                 lea     ecx, [ebp+var_1]
.text$mn:00006842                 push    ecx
.text$mn:00006843                 mov     ecx, [ebp+var_8]
.text$mn:00006846                 call    ?_Getal@?$_List_alloc@$0A@U?$_List_base_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@@2@XZ ; std::_List_alloc<0,std::_List_base_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::_Getal(void)
.text$mn:0000684B                 mov     ecx, eax
.text$mn:0000684D                 call    ??$destroy@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@1@@Z ; std::_Wrap_alloc<std::allocator<std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *>>>::destroy<std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *>(std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> * *)
.text$mn:00006852                 mov     edx, [ebp+arg_0]
.text$mn:00006855                 push    edx
.text$mn:00006856                 call    ?_Prevnode@?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@SAAAPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@2@PAU32@@Z ; std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>::_Prevnode(std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *)
.text$mn:0000685B                 add     esp, 4
.text$mn:0000685E                 push    eax
.text$mn:0000685F                 call    ??$addressof@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@YAPAPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@0@AAPAU10@@Z ; std::addressof<std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *>(std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> * &)
.text$mn:00006864                 add     esp, 4
.text$mn:00006867                 push    eax
.text$mn:00006868                 lea     eax, [ebp+var_2]
.text$mn:0000686B                 push    eax
.text$mn:0000686C                 mov     ecx, [ebp+var_8]
.text$mn:0000686F                 call    ?_Getal@?$_List_alloc@$0A@U?$_List_base_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@@2@XZ ; std::_List_alloc<0,std::_List_base_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::_Getal(void)
.text$mn:00006874                 mov     ecx, eax
.text$mn:00006876                 call    ??$destroy@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@1@@Z ; std::_Wrap_alloc<std::allocator<std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *>>>::destroy<std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *>(std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> * *)
.text$mn:0000687B                 mov     ecx, [ebp+arg_0]
.text$mn:0000687E                 push    ecx
.text$mn:0000687F                 call    ?_Myval@?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@SAAAU?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@2@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@2@@Z ; std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>::_Myval(std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *)
.text$mn:00006884                 add     esp, 4
.text$mn:00006887                 push    eax
.text$mn:00006888                 call    ??$addressof@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@YAPAU?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@0@AAU10@@Z ; std::addressof<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>(std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *> &)
.text$mn:0000688D                 add     esp, 4
.text$mn:00006890                 push    eax
.text$mn:00006891                 lea     edx, [ebp+var_3]
.text$mn:00006894                 push    edx
.text$mn:00006895                 mov     ecx, [ebp+var_8]
.text$mn:00006898                 call    ?_Getal@?$_List_alloc@$0A@U?$_List_base_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@@2@XZ ; std::_List_alloc<0,std::_List_base_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::_Getal(void)
.text$mn:0000689D                 mov     ecx, eax
.text$mn:0000689F                 call    ??$destroy@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@1@@Z ; std::_Wrap_alloc<std::allocator<std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *>>>::destroy<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>(std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *> *)
.text$mn:000068A4                 push    1               ; int
.text$mn:000068A6                 mov     eax, [ebp+arg_0]
.text$mn:000068A9                 push    eax             ; void *
.text$mn:000068AA                 lea     ecx, [ebp+var_4]
.text$mn:000068AD                 push    ecx
.text$mn:000068AE                 mov     ecx, [ebp+var_8]
.text$mn:000068B1                 call    ?_Getal@?$_List_alloc@$0A@U?$_List_base_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@@2@XZ ; std::_List_alloc<0,std::_List_base_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::_Getal(void)
.text$mn:000068B6                 mov     ecx, eax
.text$mn:000068B8                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *>>>::deallocate(std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *,uint)
.text$mn:000068BD                 mov     esp, ebp
.text$mn:000068BF                 pop     ebp
.text$mn:000068C0                 retn    4
.text$mn:000068C0 ?_Freenode@?$_List_buy@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAEXPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@2@@Z endp
.text$mn:000068C0
.text$mn:000068C0 ; ---------------------------------------------------------------------------
.text$mn:000068C3                 align 4
.text$mn:000068C3 _text$mn        ends
.text$mn:000068C3
.text$mn:000068C4 ; ===========================================================================
.text$mn:000068C4
.text$mn:000068C4 ; Segment type: Pure code
.text$mn:000068C4 ; Segment permissions: Read/Execute
.text$mn:000068C4 _text$mn        segment para public 'CODE' use32
.text$mn:000068C4                 assume cs:_text$mn
.text$mn:000068C4                 ;org 68C4h
.text$mn:000068C4 ; COMDAT (pick any)
.text$mn:000068C4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000068C4
.text$mn:000068C4 ; =============== S U B R O U T I N E =======================================
.text$mn:000068C4
.text$mn:000068C4 ; Attributes: bp-based frame
.text$mn:000068C4
.text$mn:000068C4 ; public: struct std::_Wrap_alloc<class std::allocator<struct std::_List_node<struct std::pair<int const, struct Style>, void *>>> __thiscall std::_List_alloc<0, struct std::_List_base_types<struct std::pair<int const, struct Style>, class std::allocator<struct std::pair<int const, struct Style>>>>::_Getal(void)const
.text$mn:000068C4                 public ?_Getal@?$_List_alloc@$0A@U?$_List_base_types@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@std@@@std@@@2@XZ
.text$mn:000068C4 ?_Getal@?$_List_alloc@$0A@U?$_List_base_types@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@std@@@std@@@2@XZ proc near
.text$mn:000068C4                                         ; CODE XREF: std::_List_alloc<0,std::_List_base_types<std::pair<int const,Style>,std::allocator<std::pair<int const,Style>>>>::_Freeheadnode(std::_List_node<std::pair<int const,Style>,void *> *)+26p
.text$mn:000068C4                                         ; std::_List_alloc<0,std::_List_base_types<std::pair<int const,Style>,std::allocator<std::pair<int const,Style>>>>::_Freeheadnode(std::_List_node<std::pair<int const,Style>,void *> *)+4Fp ...
.text$mn:000068C4
.text$mn:000068C4 var_4           = dword ptr -4
.text$mn:000068C4 arg_0           = dword ptr  8
.text$mn:000068C4
.text$mn:000068C4                 push    ebp
.text$mn:000068C5                 mov     ebp, esp
.text$mn:000068C7                 push    ecx
.text$mn:000068C8                 mov     [ebp+var_4], ecx
.text$mn:000068CB                 mov     ecx, [ebp+arg_0]
.text$mn:000068CE                 call    ??0?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_List_node<std::pair<int const,Style>,void *>>>::_Wrap_alloc<std::allocator<std::_List_node<std::pair<int const,Style>,void *>>>(void)
.text$mn:000068D3                 mov     eax, [ebp+arg_0]
.text$mn:000068D6                 mov     esp, ebp
.text$mn:000068D8                 pop     ebp
.text$mn:000068D9                 retn    4
.text$mn:000068D9 ?_Getal@?$_List_alloc@$0A@U?$_List_base_types@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@std@@@std@@@2@XZ endp
.text$mn:000068D9
.text$mn:000068D9 _text$mn        ends
.text$mn:000068D9
.text$mn:000068DC ; ===========================================================================
.text$mn:000068DC
.text$mn:000068DC ; Segment type: Pure code
.text$mn:000068DC ; Segment permissions: Read/Execute
.text$mn:000068DC _text$mn        segment para public 'CODE' use32
.text$mn:000068DC                 assume cs:_text$mn
.text$mn:000068DC                 ;org 68DCh
.text$mn:000068DC ; COMDAT (pick any)
.text$mn:000068DC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000068DC
.text$mn:000068DC ; =============== S U B R O U T I N E =======================================
.text$mn:000068DC
.text$mn:000068DC ; Attributes: bp-based frame
.text$mn:000068DC
.text$mn:000068DC ; public: struct std::_Wrap_alloc<class std::allocator<struct std::_List_node<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>, void *>>> __thiscall std::_List_alloc<0, struct std::_List_base_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>, class std::allocator<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>::_Getal(void)const
.text$mn:000068DC                 public ?_Getal@?$_List_alloc@$0A@U?$_List_base_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@@2@XZ
.text$mn:000068DC ?_Getal@?$_List_alloc@$0A@U?$_List_base_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@@2@XZ proc near
.text$mn:000068DC                                         ; CODE XREF: std::_List_alloc<0,std::_List_base_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::_Buynode0(std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *,std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *)+38p
.text$mn:000068DC                                         ; std::_List_alloc<0,std::_List_base_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::_Buynode0(std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *,std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *)+81p ...
.text$mn:000068DC
.text$mn:000068DC var_4           = dword ptr -4
.text$mn:000068DC arg_0           = dword ptr  8
.text$mn:000068DC
.text$mn:000068DC                 push    ebp
.text$mn:000068DD                 mov     ebp, esp
.text$mn:000068DF                 push    ecx
.text$mn:000068E0                 mov     [ebp+var_4], ecx
.text$mn:000068E3                 mov     ecx, [ebp+arg_0]
.text$mn:000068E6                 call    ??0?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *>>>::_Wrap_alloc<std::allocator<std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *>>>(void)
.text$mn:000068EB                 mov     eax, [ebp+arg_0]
.text$mn:000068EE                 mov     esp, ebp
.text$mn:000068F0                 pop     ebp
.text$mn:000068F1                 retn    4
.text$mn:000068F1 ?_Getal@?$_List_alloc@$0A@U?$_List_base_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@@2@XZ endp
.text$mn:000068F1
.text$mn:000068F1 _text$mn        ends
.text$mn:000068F1
.text$mn:000068F4 ; ===========================================================================
.text$mn:000068F4
.text$mn:000068F4 ; Segment type: Pure code
.text$mn:000068F4 ; Segment permissions: Read/Execute
.text$mn:000068F4 _text$mn        segment para public 'CODE' use32
.text$mn:000068F4                 assume cs:_text$mn
.text$mn:000068F4                 ;org 68F4h
.text$mn:000068F4 ; COMDAT (pick any)
.text$mn:000068F4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000068F4
.text$mn:000068F4 ; =============== S U B R O U T I N E =======================================
.text$mn:000068F4
.text$mn:000068F4 ; Attributes: bp-based frame
.text$mn:000068F4
.text$mn:000068F4 ; public: struct std::_Wrap_alloc<class std::allocator<char>> __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Getal(void)const
.text$mn:000068F4                 public ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
.text$mn:000068F4 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ proc near
.text$mn:000068F4                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+B4p
.text$mn:000068F4                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+1Bp ...
.text$mn:000068F4
.text$mn:000068F4 var_4           = dword ptr -4
.text$mn:000068F4 arg_0           = dword ptr  8
.text$mn:000068F4
.text$mn:000068F4                 push    ebp
.text$mn:000068F5                 mov     ebp, esp
.text$mn:000068F7                 push    ecx
.text$mn:000068F8                 mov     [ebp+var_4], ecx
.text$mn:000068FB                 mov     ecx, [ebp+arg_0]
.text$mn:000068FE                 call    ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)
.text$mn:00006903                 mov     eax, [ebp+arg_0]
.text$mn:00006906                 mov     esp, ebp
.text$mn:00006908                 pop     ebp
.text$mn:00006909                 retn    4
.text$mn:00006909 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ endp
.text$mn:00006909
.text$mn:00006909 _text$mn        ends
.text$mn:00006909
.text$mn:0000690C ; ===========================================================================
.text$mn:0000690C
.text$mn:0000690C ; Segment type: Pure code
.text$mn:0000690C ; Segment permissions: Read/Execute
.text$mn:0000690C _text$mn        segment para public 'CODE' use32
.text$mn:0000690C                 assume cs:_text$mn
.text$mn:0000690C                 ;org 690Ch
.text$mn:0000690C ; COMDAT (pick any)
.text$mn:0000690C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000690C
.text$mn:0000690C ; =============== S U B R O U T I N E =======================================
.text$mn:0000690C
.text$mn:0000690C ; Attributes: bp-based frame
.text$mn:0000690C
.text$mn:0000690C ; public: struct std::_Wrap_alloc<class std::allocator<wchar_t>> __thiscall std::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>::_Getal(void)const
.text$mn:0000690C                 public ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ
.text$mn:0000690C ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ proc near
.text$mn:0000690C                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+33p
.text$mn:0000690C                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+7Ap
.text$mn:0000690C
.text$mn:0000690C var_4           = dword ptr -4
.text$mn:0000690C arg_0           = dword ptr  8
.text$mn:0000690C
.text$mn:0000690C                 push    ebp
.text$mn:0000690D                 mov     ebp, esp
.text$mn:0000690F                 push    ecx
.text$mn:00006910                 mov     [ebp+var_4], ecx
.text$mn:00006913                 mov     ecx, [ebp+arg_0]
.text$mn:00006916                 call    ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<wchar_t>>::_Wrap_alloc<std::allocator<wchar_t>>(void)
.text$mn:0000691B                 mov     eax, [ebp+arg_0]
.text$mn:0000691E                 mov     esp, ebp
.text$mn:00006920                 pop     ebp
.text$mn:00006921                 retn    4
.text$mn:00006921 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ endp
.text$mn:00006921
.text$mn:00006921 _text$mn        ends
.text$mn:00006921
.text$mn:00006924 ; ===========================================================================
.text$mn:00006924
.text$mn:00006924 ; Segment type: Pure code
.text$mn:00006924 ; Segment permissions: Read/Execute
.text$mn:00006924 _text$mn        segment para public 'CODE' use32
.text$mn:00006924                 assume cs:_text$mn
.text$mn:00006924                 ;org 6924h
.text$mn:00006924 ; COMDAT (pick any)
.text$mn:00006924                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006924
.text$mn:00006924 ; =============== S U B R O U T I N E =======================================
.text$mn:00006924
.text$mn:00006924 ; Attributes: bp-based frame
.text$mn:00006924
.text$mn:00006924 ; public: struct std::_Wrap_alloc<class std::allocator<class ScintillaEditView *>> __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<class ScintillaEditView *, class std::allocator<class ScintillaEditView *>>>::_Getal(void)const
.text$mn:00006924                 public ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVScintillaEditView@@@std@@@2@XZ
.text$mn:00006924 ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVScintillaEditView@@@std@@@2@XZ proc near
.text$mn:00006924                                         ; CODE XREF: std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::_Umove<ScintillaEditView * *>(ScintillaEditView * *,ScintillaEditView * *,ScintillaEditView * *)+10p
.text$mn:00006924                                         ; std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::_Destroy(ScintillaEditView * *,ScintillaEditView * *)+10p ...
.text$mn:00006924
.text$mn:00006924 var_4           = dword ptr -4
.text$mn:00006924 arg_0           = dword ptr  8
.text$mn:00006924
.text$mn:00006924                 push    ebp
.text$mn:00006925                 mov     ebp, esp
.text$mn:00006927                 push    ecx
.text$mn:00006928                 mov     [ebp+var_4], ecx
.text$mn:0000692B                 mov     ecx, [ebp+arg_0]
.text$mn:0000692E                 call    ??0?$_Wrap_alloc@V?$allocator@PAVScintillaEditView@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<ScintillaEditView *>>::_Wrap_alloc<std::allocator<ScintillaEditView *>>(void)
.text$mn:00006933                 mov     eax, [ebp+arg_0]
.text$mn:00006936                 mov     esp, ebp
.text$mn:00006938                 pop     ebp
.text$mn:00006939                 retn    4
.text$mn:00006939 ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVScintillaEditView@@@std@@@2@XZ endp
.text$mn:00006939
.text$mn:00006939 _text$mn        ends
.text$mn:00006939
.text$mn:0000693C ; ===========================================================================
.text$mn:0000693C
.text$mn:0000693C ; Segment type: Pure code
.text$mn:0000693C ; Segment permissions: Read/Execute
.text$mn:0000693C _text$mn        segment para public 'CODE' use32
.text$mn:0000693C                 assume cs:_text$mn
.text$mn:0000693C                 ;org 693Ch
.text$mn:0000693C ; COMDAT (pick any)
.text$mn:0000693C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000693C
.text$mn:0000693C ; =============== S U B R O U T I N E =======================================
.text$mn:0000693C
.text$mn:0000693C ; Attributes: bp-based frame
.text$mn:0000693C
.text$mn:0000693C ; public: struct std::_Wrap_alloc<struct std::_Wrap_alloc<class std::allocator<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<int const, struct Style>>>>>>> __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<int const, struct Style>>>>, struct std::_Wrap_alloc<class std::allocator<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<int const, struct Style>>>>>>>>::_Getal(void)const
.text$mn:0000693C                 public ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@std@@@2@XZ
.text$mn:0000693C ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@std@@@2@XZ proc near
.text$mn:0000693C                                         ; CODE XREF: std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>>>>::_Destroy(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>> *)+10p
.text$mn:0000693C                                         ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>>>>::_Tidy(void)+4Ep
.text$mn:0000693C
.text$mn:0000693C var_4           = dword ptr -4
.text$mn:0000693C arg_0           = dword ptr  8
.text$mn:0000693C
.text$mn:0000693C                 push    ebp
.text$mn:0000693D                 mov     ebp, esp
.text$mn:0000693F                 push    ecx
.text$mn:00006940                 mov     [ebp+var_4], ecx
.text$mn:00006943                 mov     ecx, [ebp+arg_0]
.text$mn:00006946                 call    ??0?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>>>>::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>>>>(void)
.text$mn:0000694B                 mov     eax, [ebp+arg_0]
.text$mn:0000694E                 mov     esp, ebp
.text$mn:00006950                 pop     ebp
.text$mn:00006951                 retn    4
.text$mn:00006951 ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@std@@@2@XZ endp
.text$mn:00006951
.text$mn:00006951 _text$mn        ends
.text$mn:00006951
.text$mn:00006954 ; ===========================================================================
.text$mn:00006954
.text$mn:00006954 ; Segment type: Pure code
.text$mn:00006954 ; Segment permissions: Read/Execute
.text$mn:00006954 _text$mn        segment para public 'CODE' use32
.text$mn:00006954                 assume cs:_text$mn
.text$mn:00006954                 ;org 6954h
.text$mn:00006954 ; COMDAT (pick any)
.text$mn:00006954                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006954
.text$mn:00006954 ; =============== S U B R O U T I N E =======================================
.text$mn:00006954
.text$mn:00006954 ; Attributes: bp-based frame
.text$mn:00006954
.text$mn:00006954 ; public: struct std::_Wrap_alloc<struct std::_Wrap_alloc<class std::allocator<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>>>> __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>, struct std::_Wrap_alloc<class std::allocator<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct
.text$mn:00006954                 public ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@XZ
.text$mn:00006954 ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@XZ proc near
.text$mn:00006954                                         ; CODE XREF: std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::_Umove<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<
.text$mn:00006954                                         ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::_Destroy(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *)+10p ...
.text$mn:00006954
.text$mn:00006954 var_4           = dword ptr -4
.text$mn:00006954 arg_0           = dword ptr  8
.text$mn:00006954
.text$mn:00006954                 push    ebp
.text$mn:00006955                 mov     ebp, esp
.text$mn:00006957                 push    ecx
.text$mn:00006958                 mov     [ebp+var_4], ecx
.text$mn:0000695B                 mov     ecx, [ebp+arg_0]
.text$mn:0000695E                 call    ??0?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>(void)
.text$mn:00006963                 mov     eax, [ebp+arg_0]
.text$mn:00006966                 mov     esp, ebp
.text$mn:00006968                 pop     ebp
.text$mn:00006969                 retn    4
.text$mn:00006969 ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@XZ endp
.text$mn:00006969
.text$mn:00006969 _text$mn        ends
.text$mn:00006969
.text$mn:0000696C ; ===========================================================================
.text$mn:0000696C
.text$mn:0000696C ; Segment type: Pure code
.text$mn:0000696C ; Segment permissions: Read/Execute
.text$mn:0000696C _text$mn        segment para public 'CODE' use32
.text$mn:0000696C                 assume cs:_text$mn
.text$mn:0000696C                 ;org 696Ch
.text$mn:0000696C ; COMDAT (pick any)
.text$mn:0000696C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000696C
.text$mn:0000696C ; =============== S U B R O U T I N E =======================================
.text$mn:0000696C
.text$mn:0000696C ; Attributes: bp-based frame
.text$mn:0000696C
.text$mn:0000696C ; const struct std::_Container_base12 *__thiscall std::_Iterator_base12::_Getcont(std::_Iterator_base12 *__hidden this)
.text$mn:0000696C                 public ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ
.text$mn:0000696C ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ proc near
.text$mn:0000696C                                         ; CODE XREF: std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>::operator==(std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>> const &)+Dp
.text$mn:0000696C                                         ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>::operator==(std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>> const &)+19p ...
.text$mn:0000696C
.text$mn:0000696C var_8           = dword ptr -8
.text$mn:0000696C var_4           = dword ptr -4
.text$mn:0000696C
.text$mn:0000696C                 push    ebp
.text$mn:0000696D                 mov     ebp, esp
.text$mn:0000696F                 sub     esp, 8
.text$mn:00006972                 mov     [ebp+var_4], ecx
.text$mn:00006975                 mov     eax, [ebp+var_4]
.text$mn:00006978                 cmp     dword ptr [eax], 0
.text$mn:0000697B                 jnz     short loc_6986
.text$mn:0000697D                 mov     [ebp+var_8], 0
.text$mn:00006984                 jmp     short loc_6990
.text$mn:00006986 ; ---------------------------------------------------------------------------
.text$mn:00006986
.text$mn:00006986 loc_6986:                               ; CODE XREF: std::_Iterator_base12::_Getcont(void)+Fj
.text$mn:00006986                 mov     ecx, [ebp+var_4]
.text$mn:00006989                 mov     edx, [ecx]
.text$mn:0000698B                 mov     eax, [edx]
.text$mn:0000698D                 mov     [ebp+var_8], eax
.text$mn:00006990
.text$mn:00006990 loc_6990:                               ; CODE XREF: std::_Iterator_base12::_Getcont(void)+18j
.text$mn:00006990                 mov     eax, [ebp+var_8]
.text$mn:00006993                 mov     esp, ebp
.text$mn:00006995                 pop     ebp
.text$mn:00006996                 retn
.text$mn:00006996 ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ endp
.text$mn:00006996
.text$mn:00006996 ; ---------------------------------------------------------------------------
.text$mn:00006997                 align 4
.text$mn:00006997 _text$mn        ends
.text$mn:00006997
.text$mn:00006998 ; ===========================================================================
.text$mn:00006998
.text$mn:00006998 ; Segment type: Pure code
.text$mn:00006998 ; Segment permissions: Read/Execute
.text$mn:00006998 _text$mn        segment para public 'CODE' use32
.text$mn:00006998                 assume cs:_text$mn
.text$mn:00006998                 ;org 6998h
.text$mn:00006998 ; COMDAT (pick any)
.text$mn:00006998                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006998
.text$mn:00006998 ; =============== S U B R O U T I N E =======================================
.text$mn:00006998
.text$mn:00006998 ; Attributes: bp-based frame
.text$mn:00006998
.text$mn:00006998 ; struct std::_Iterator_base12 **__thiscall std::_Container_base12::_Getpfirst(std::_Container_base12 *__hidden this)
.text$mn:00006998                 public ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ
.text$mn:00006998 ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ proc near
.text$mn:00006998                                         ; CODE XREF: std::list<std::pair<int const,Style>,std::allocator<std::pair<int const,Style>>>::_Orphan_ptr(std::list<std::pair<int const,Style>,std::allocator<std::pair<int const,Style>>> &,std::_List_node<std::pair<int const,Style>,void *> *)+3Cp
.text$mn:00006998                                         ; std::list<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>::_Orphan_ptr(std::list<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>> &,std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *)+3Cp ...
.text$mn:00006998
.text$mn:00006998 var_8           = dword ptr -8
.text$mn:00006998 var_4           = dword ptr -4
.text$mn:00006998
.text$mn:00006998                 push    ebp
.text$mn:00006999                 mov     ebp, esp
.text$mn:0000699B                 sub     esp, 8
.text$mn:0000699E                 mov     [ebp+var_4], ecx
.text$mn:000069A1                 mov     eax, [ebp+var_4]
.text$mn:000069A4                 cmp     dword ptr [eax], 0
.text$mn:000069A7                 jnz     short loc_69B2
.text$mn:000069A9                 mov     [ebp+var_8], 0
.text$mn:000069B0                 jmp     short loc_69BD
.text$mn:000069B2 ; ---------------------------------------------------------------------------
.text$mn:000069B2
.text$mn:000069B2 loc_69B2:                               ; CODE XREF: std::_Container_base12::_Getpfirst(void)+Fj
.text$mn:000069B2                 mov     ecx, [ebp+var_4]
.text$mn:000069B5                 mov     edx, [ecx]
.text$mn:000069B7                 add     edx, 4
.text$mn:000069BA                 mov     [ebp+var_8], edx
.text$mn:000069BD
.text$mn:000069BD loc_69BD:                               ; CODE XREF: std::_Container_base12::_Getpfirst(void)+18j
.text$mn:000069BD                 mov     eax, [ebp+var_8]
.text$mn:000069C0                 mov     esp, ebp
.text$mn:000069C2                 pop     ebp
.text$mn:000069C3                 retn
.text$mn:000069C3 ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ endp
.text$mn:000069C3
.text$mn:000069C3 _text$mn        ends
.text$mn:000069C3
.text$mn:000069C4 ; ===========================================================================
.text$mn:000069C4
.text$mn:000069C4 ; Segment type: Pure code
.text$mn:000069C4 ; Segment permissions: Read/Execute
.text$mn:000069C4 _text$mn        segment para public 'CODE' use32
.text$mn:000069C4                 assume cs:_text$mn
.text$mn:000069C4                 ;org 69C4h
.text$mn:000069C4 ; COMDAT (pick any)
.text$mn:000069C4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000069C4
.text$mn:000069C4 ; =============== S U B R O U T I N E =======================================
.text$mn:000069C4
.text$mn:000069C4 ; Attributes: bp-based frame
.text$mn:000069C4
.text$mn:000069C4 ; struct std::_Iterator_base12 **__thiscall std::_Iterator_base12::_Getpnext(std::_Iterator_base12 *__hidden this)
.text$mn:000069C4                 public ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ
.text$mn:000069C4 ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ proc near
.text$mn:000069C4                                         ; CODE XREF: std::list<std::pair<int const,Style>,std::allocator<std::pair<int const,Style>>>::_Orphan_ptr(std::list<std::pair<int const,Style>,std::allocator<std::pair<int const,Style>>> &,std::_List_node<std::pair<int const,Style>,void *> *)+7Ap
.text$mn:000069C4                                         ; std::list<std::pair<int const,Style>,std::allocator<std::pair<int const,Style>>>::_Orphan_ptr(std::list<std::pair<int const,Style>,std::allocator<std::pair<int const,Style>>> &,std::_List_node<std::pair<int const,Style>,void *> *)+93p ...
.text$mn:000069C4
.text$mn:000069C4 var_4           = dword ptr -4
.text$mn:000069C4
.text$mn:000069C4                 push    ebp
.text$mn:000069C5                 mov     ebp, esp
.text$mn:000069C7                 push    ecx
.text$mn:000069C8                 mov     [ebp+var_4], ecx
.text$mn:000069CB                 mov     eax, [ebp+var_4]
.text$mn:000069CE                 add     eax, 4
.text$mn:000069D1                 mov     esp, ebp
.text$mn:000069D3                 pop     ebp
.text$mn:000069D4                 retn
.text$mn:000069D4 ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ endp
.text$mn:000069D4
.text$mn:000069D4 ; ---------------------------------------------------------------------------
.text$mn:000069D5                 align 4
.text$mn:000069D5 _text$mn        ends
.text$mn:000069D5
.text$mn:000069D8 ; ===========================================================================
.text$mn:000069D8
.text$mn:000069D8 ; Segment type: Pure code
.text$mn:000069D8 ; Segment permissions: Read/Execute
.text$mn:000069D8 _text$mn        segment para public 'CODE' use32
.text$mn:000069D8                 assume cs:_text$mn
.text$mn:000069D8                 ;org 69D8h
.text$mn:000069D8 ; COMDAT (pick any)
.text$mn:000069D8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000069D8
.text$mn:000069D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000069D8
.text$mn:000069D8 ; Attributes: bp-based frame
.text$mn:000069D8
.text$mn:000069D8 ; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Grow(unsigned int, bool)
.text$mn:000069D8                 public ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
.text$mn:000069D8 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z proc near
.text$mn:000069D8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+6Ap
.text$mn:000069D8                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+5Fp
.text$mn:000069D8
.text$mn:000069D8 var_C           = dword ptr -0Ch
.text$mn:000069D8 Size            = dword ptr -8
.text$mn:000069D8 var_4           = dword ptr -4
.text$mn:000069D8 arg_0           = dword ptr  8
.text$mn:000069D8 arg_4           = byte ptr  0Ch
.text$mn:000069D8
.text$mn:000069D8                 push    ebp
.text$mn:000069D9                 mov     ebp, esp
.text$mn:000069DB                 sub     esp, 0Ch
.text$mn:000069DE                 mov     [ebp+var_4], ecx
.text$mn:000069E1                 mov     ecx, [ebp+var_4]
.text$mn:000069E4                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:000069E9                 cmp     eax, [ebp+arg_0]
.text$mn:000069EC                 jnb     short loc_69F6
.text$mn:000069EE                 mov     ecx, [ebp+var_4]
.text$mn:000069F1                 call    ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)
.text$mn:000069F6
.text$mn:000069F6 loc_69F6:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+14j
.text$mn:000069F6                 mov     eax, [ebp+var_4]
.text$mn:000069F9                 mov     ecx, [eax+18h]
.text$mn:000069FC                 cmp     ecx, [ebp+arg_0]
.text$mn:000069FF                 jnb     short loc_6A16
.text$mn:00006A01                 mov     edx, [ebp+var_4]
.text$mn:00006A04                 mov     eax, [edx+14h]
.text$mn:00006A07                 push    eax
.text$mn:00006A08                 mov     ecx, [ebp+arg_0]
.text$mn:00006A0B                 push    ecx
.text$mn:00006A0C                 mov     ecx, [ebp+var_4]
.text$mn:00006A0F                 call    ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)
.text$mn:00006A14                 jmp     short loc_6A60
.text$mn:00006A16 ; ---------------------------------------------------------------------------
.text$mn:00006A16
.text$mn:00006A16 loc_6A16:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+27j
.text$mn:00006A16                 movzx   edx, [ebp+arg_4]
.text$mn:00006A1A                 test    edx, edx
.text$mn:00006A1C                 jz      short loc_6A50
.text$mn:00006A1E                 cmp     [ebp+arg_0], 10h
.text$mn:00006A22                 jnb     short loc_6A50
.text$mn:00006A24                 mov     eax, [ebp+var_4]
.text$mn:00006A27                 mov     ecx, [ebp+arg_0]
.text$mn:00006A2A                 cmp     ecx, [eax+14h]
.text$mn:00006A2D                 jnb     short loc_6A37
.text$mn:00006A2F                 mov     edx, [ebp+arg_0]
.text$mn:00006A32                 mov     [ebp+Size], edx
.text$mn:00006A35                 jmp     short loc_6A40
.text$mn:00006A37 ; ---------------------------------------------------------------------------
.text$mn:00006A37
.text$mn:00006A37 loc_6A37:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+55j
.text$mn:00006A37                 mov     eax, [ebp+var_4]
.text$mn:00006A3A                 mov     ecx, [eax+14h]
.text$mn:00006A3D                 mov     [ebp+Size], ecx
.text$mn:00006A40
.text$mn:00006A40 loc_6A40:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+5Dj
.text$mn:00006A40                 mov     edx, [ebp+Size]
.text$mn:00006A43                 push    edx             ; Size
.text$mn:00006A44                 push    1               ; char
.text$mn:00006A46                 mov     ecx, [ebp+var_4]
.text$mn:00006A49                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00006A4E                 jmp     short loc_6A60
.text$mn:00006A50 ; ---------------------------------------------------------------------------
.text$mn:00006A50
.text$mn:00006A50 loc_6A50:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+44j
.text$mn:00006A50                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+4Aj
.text$mn:00006A50                 cmp     [ebp+arg_0], 0
.text$mn:00006A54                 jnz     short loc_6A60
.text$mn:00006A56                 push    0
.text$mn:00006A58                 mov     ecx, [ebp+var_4]
.text$mn:00006A5B                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00006A60
.text$mn:00006A60 loc_6A60:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+3Cj
.text$mn:00006A60                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+76j ...
.text$mn:00006A60                 cmp     [ebp+arg_0], 0
.text$mn:00006A64                 jbe     short loc_6A6F
.text$mn:00006A66                 mov     [ebp+var_C], 1
.text$mn:00006A6D                 jmp     short loc_6A76
.text$mn:00006A6F ; ---------------------------------------------------------------------------
.text$mn:00006A6F
.text$mn:00006A6F loc_6A6F:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+8Cj
.text$mn:00006A6F                 mov     [ebp+var_C], 0
.text$mn:00006A76
.text$mn:00006A76 loc_6A76:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+95j
.text$mn:00006A76                 mov     al, byte ptr [ebp+var_C]
.text$mn:00006A79                 mov     esp, ebp
.text$mn:00006A7B                 pop     ebp
.text$mn:00006A7C                 retn    8
.text$mn:00006A7C ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z endp
.text$mn:00006A7C
.text$mn:00006A7C ; ---------------------------------------------------------------------------
.text$mn:00006A7F                 align 10h
.text$mn:00006A7F _text$mn        ends
.text$mn:00006A7F
.text$mn:00006A80 ; ===========================================================================
.text$mn:00006A80
.text$mn:00006A80 ; Segment type: Pure code
.text$mn:00006A80 ; Segment permissions: Read/Execute
.text$mn:00006A80 _text$mn        segment para public 'CODE' use32
.text$mn:00006A80                 assume cs:_text$mn
.text$mn:00006A80                 ;org 6A80h
.text$mn:00006A80 ; COMDAT (pick any)
.text$mn:00006A80                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006A80
.text$mn:00006A80 ; =============== S U B R O U T I N E =======================================
.text$mn:00006A80
.text$mn:00006A80 ; Attributes: bp-based frame
.text$mn:00006A80
.text$mn:00006A80 ; protected: unsigned int __thiscall std::vector<class ScintillaEditView *, class std::allocator<class ScintillaEditView *>>::_Grow_to(unsigned int)const
.text$mn:00006A80                 public ?_Grow_to@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@IBEII@Z
.text$mn:00006A80 ?_Grow_to@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@IBEII@Z proc near
.text$mn:00006A80                                         ; CODE XREF: std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::_Reserve(uint)+45p
.text$mn:00006A80
.text$mn:00006A80 var_C           = dword ptr -0Ch
.text$mn:00006A80 var_8           = dword ptr -8
.text$mn:00006A80 var_4           = dword ptr -4
.text$mn:00006A80 arg_0           = dword ptr  8
.text$mn:00006A80
.text$mn:00006A80                 push    ebp
.text$mn:00006A81                 mov     ebp, esp
.text$mn:00006A83                 sub     esp, 0Ch
.text$mn:00006A86                 mov     [ebp+var_8], ecx
.text$mn:00006A89                 mov     ecx, [ebp+var_8]
.text$mn:00006A8C                 call    ?capacity@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@QBEIXZ ; std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::capacity(void)
.text$mn:00006A91                 mov     [ebp+var_4], eax
.text$mn:00006A94                 mov     ecx, [ebp+var_8]
.text$mn:00006A97                 call    ?max_size@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@QBEIXZ ; std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::max_size(void)
.text$mn:00006A9C                 mov     ecx, [ebp+var_4]
.text$mn:00006A9F                 shr     ecx, 1
.text$mn:00006AA1                 sub     eax, ecx
.text$mn:00006AA3                 cmp     eax, [ebp+var_4]
.text$mn:00006AA6                 jnb     short loc_6AB1
.text$mn:00006AA8                 mov     [ebp+var_C], 0
.text$mn:00006AAF                 jmp     short loc_6ABC
.text$mn:00006AB1 ; ---------------------------------------------------------------------------
.text$mn:00006AB1
.text$mn:00006AB1 loc_6AB1:                               ; CODE XREF: std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::_Grow_to(uint)+26j
.text$mn:00006AB1                 mov     edx, [ebp+var_4]
.text$mn:00006AB4                 shr     edx, 1
.text$mn:00006AB6                 add     edx, [ebp+var_4]
.text$mn:00006AB9                 mov     [ebp+var_C], edx
.text$mn:00006ABC
.text$mn:00006ABC loc_6ABC:                               ; CODE XREF: std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::_Grow_to(uint)+2Fj
.text$mn:00006ABC                 mov     eax, [ebp+var_C]
.text$mn:00006ABF                 mov     [ebp+var_4], eax
.text$mn:00006AC2                 mov     ecx, [ebp+var_4]
.text$mn:00006AC5                 cmp     ecx, [ebp+arg_0]
.text$mn:00006AC8                 jnb     short loc_6AD0
.text$mn:00006ACA                 mov     edx, [ebp+arg_0]
.text$mn:00006ACD                 mov     [ebp+var_4], edx
.text$mn:00006AD0
.text$mn:00006AD0 loc_6AD0:                               ; CODE XREF: std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::_Grow_to(uint)+48j
.text$mn:00006AD0                 mov     eax, [ebp+var_4]
.text$mn:00006AD3                 mov     esp, ebp
.text$mn:00006AD5                 pop     ebp
.text$mn:00006AD6                 retn    4
.text$mn:00006AD6 ?_Grow_to@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@IBEII@Z endp
.text$mn:00006AD6
.text$mn:00006AD6 ; ---------------------------------------------------------------------------
.text$mn:00006AD9                 align 4
.text$mn:00006AD9 _text$mn        ends
.text$mn:00006AD9
.text$mn:00006ADC ; ===========================================================================
.text$mn:00006ADC
.text$mn:00006ADC ; Segment type: Pure code
.text$mn:00006ADC ; Segment permissions: Read/Execute
.text$mn:00006ADC _text$mn        segment para public 'CODE' use32
.text$mn:00006ADC                 assume cs:_text$mn
.text$mn:00006ADC                 ;org 6ADCh
.text$mn:00006ADC ; COMDAT (pick any)
.text$mn:00006ADC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006ADC
.text$mn:00006ADC ; =============== S U B R O U T I N E =======================================
.text$mn:00006ADC
.text$mn:00006ADC ; Attributes: bp-based frame
.text$mn:00006ADC
.text$mn:00006ADC ; protected: unsigned int __thiscall std::vector<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>, struct std::_Wrap_alloc<class std::allocator<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>>>>::_Grow_to(unsigned int)const
.text$mn:00006ADC                 public ?_Grow_to@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IBEII@Z
.text$mn:00006ADC ?_Grow_to@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IBEII@Z proc near
.text$mn:00006ADC                                         ; CODE XREF: ?_Insert_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CB
.text$mn:00006ADC
.text$mn:00006ADC var_C           = dword ptr -0Ch
.text$mn:00006ADC var_8           = dword ptr -8
.text$mn:00006ADC var_4           = dword ptr -4
.text$mn:00006ADC arg_0           = dword ptr  8
.text$mn:00006ADC
.text$mn:00006ADC                 push    ebp
.text$mn:00006ADD                 mov     ebp, esp
.text$mn:00006ADF                 sub     esp, 0Ch
.text$mn:00006AE2                 mov     [ebp+var_8], ecx
.text$mn:00006AE5                 mov     ecx, [ebp+var_8]
.text$mn:00006AE8                 call    ?capacity@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QBEIXZ ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::capacity(void)
.text$mn:00006AED                 mov     [ebp+var_4], eax
.text$mn:00006AF0                 mov     ecx, [ebp+var_8]
.text$mn:00006AF3                 call    ?max_size@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QBEIXZ ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::max_size(void)
.text$mn:00006AF8                 mov     ecx, [ebp+var_4]
.text$mn:00006AFB                 shr     ecx, 1
.text$mn:00006AFD                 sub     eax, ecx
.text$mn:00006AFF                 cmp     eax, [ebp+var_4]
.text$mn:00006B02                 jnb     short loc_6B0D
.text$mn:00006B04                 mov     [ebp+var_C], 0
.text$mn:00006B0B                 jmp     short loc_6B18
.text$mn:00006B0D ; ---------------------------------------------------------------------------
.text$mn:00006B0D
.text$mn:00006B0D loc_6B0D:                               ; CODE XREF: std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::_Grow_to(uint)+26j
.text$mn:00006B0D                 mov     edx, [ebp+var_4]
.text$mn:00006B10                 shr     edx, 1
.text$mn:00006B12                 add     edx, [ebp+var_4]
.text$mn:00006B15                 mov     [ebp+var_C], edx
.text$mn:00006B18
.text$mn:00006B18 loc_6B18:                               ; CODE XREF: std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::_Grow_to(uint)+2Fj
.text$mn:00006B18                 mov     eax, [ebp+var_C]
.text$mn:00006B1B                 mov     [ebp+var_4], eax
.text$mn:00006B1E                 mov     ecx, [ebp+var_4]
.text$mn:00006B21                 cmp     ecx, [ebp+arg_0]
.text$mn:00006B24                 jnb     short loc_6B2C
.text$mn:00006B26                 mov     edx, [ebp+arg_0]
.text$mn:00006B29                 mov     [ebp+var_4], edx
.text$mn:00006B2C
.text$mn:00006B2C loc_6B2C:                               ; CODE XREF: std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::_Grow_to(uint)+48j
.text$mn:00006B2C                 mov     eax, [ebp+var_4]
.text$mn:00006B2F                 mov     esp, ebp
.text$mn:00006B31                 pop     ebp
.text$mn:00006B32                 retn    4
.text$mn:00006B32 ?_Grow_to@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IBEII@Z endp
.text$mn:00006B32
.text$mn:00006B32 ; ---------------------------------------------------------------------------
.text$mn:00006B35                 align 4
.text$mn:00006B35 _text$mn        ends
.text$mn:00006B35
.text$mn:00006B38 ; ===========================================================================
.text$mn:00006B38
.text$mn:00006B38 ; Segment type: Pure code
.text$mn:00006B38 ; Segment permissions: Read/Execute
.text$mn:00006B38 _text$mn        segment para public 'CODE' use32
.text$mn:00006B38                 assume cs:_text$mn
.text$mn:00006B38                 ;org 6B38h
.text$mn:00006B38 ; COMDAT (pick any)
.text$mn:00006B38                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006B38
.text$mn:00006B38 ; =============== S U B R O U T I N E =======================================
.text$mn:00006B38
.text$mn:00006B38 ; Attributes: bp-based frame
.text$mn:00006B38
.text$mn:00006B38 ; protected: void __thiscall std::_Hash<class std::_Umap_traits<class Buffer *, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *, class std::_Uhash_compare<class Buffer *, struct std::hash<class Buffer *>, struct std::equal_to<class Buffer *>>, class std::allocator<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>, 0>>::_Init(unsigned int)
.text$mn:00006B38                 public ?_Init@?$_Hash@V?$_Umap_traits@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@V?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@$0A@@std@@@std@@IAEXI@Z
.text$mn:00006B38 ?_Init@?$_Hash@V?$_Umap_traits@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@V?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@$0A@@std@@@std@@IAEXI@Z proc near
.text$mn:00006B38                                         ; CODE XREF: std::_Hash<std::_Umap_traits<Buffer *,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *,std::_Uhash_compare<Buffer *,std::hash<Buffer *>,std::equal_to<Buffer *>>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>,0>>::_Hash<std::_Umap_traits<Buffer *,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *,std::_Uhash_compare<Buffer *,std::hash<Buffer *>,std::equal_to<Buffer *>>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>,0>>(std::_Uhash_compare<Buffer *,std::hash<Buffer *>,std::equal_to<Buffer *>> const &,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>> const &)+7Bp
.text$mn:00006B38
.text$mn:00006B38 var_8           = byte ptr -8
.text$mn:00006B38 var_4           = dword ptr -4
.text$mn:00006B38 arg_0           = dword ptr  8
.text$mn:00006B38
.text$mn:00006B38                 push    ebp
.text$mn:00006B39                 mov     ebp, esp
.text$mn:00006B3B                 sub     esp, 8
.text$mn:00006B3E                 mov     [ebp+var_4], ecx
.text$mn:00006B41                 lea     eax, [ebp+var_8]
.text$mn:00006B44                 push    eax
.text$mn:00006B45                 mov     ecx, [ebp+var_4]
.text$mn:00006B48                 call    ?_Unchecked_end@?$_Hash@V?$_Umap_traits@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@V?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@XZ ; std::_Hash<std::_Umap_traits<Buffer *,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *,std::_Uhash_compare<Buffer *,std::hash<Buffer *>,std::equal_to<Buffer *>>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>,0>>::_Unchecked_end(void)
.text$mn:00006B4D                 push    eax
.text$mn:00006B4E                 mov     ecx, [ebp+arg_0]
.text$mn:00006B51                 shl     ecx, 1
.text$mn:00006B53                 push    ecx
.text$mn:00006B54                 mov     ecx, [ebp+var_4]
.text$mn:00006B57                 add     ecx, 0Ch
.text$mn:00006B5A                 call    ?assign@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAEXIABV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@@Z ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::assign(uint,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const &)
.text$mn:00006B5F                 mov     edx, [ebp+arg_0]
.text$mn:00006B62                 sub     edx, 1
.text$mn:00006B65                 mov     eax, [ebp+var_4]
.text$mn:00006B68                 mov     [eax+1Ch], edx
.text$mn:00006B6B                 mov     ecx, [ebp+var_4]
.text$mn:00006B6E                 mov     edx, [ebp+arg_0]
.text$mn:00006B71                 mov     [ecx+20h], edx
.text$mn:00006B74                 mov     esp, ebp
.text$mn:00006B76                 pop     ebp
.text$mn:00006B77                 retn    4
.text$mn:00006B77 ?_Init@?$_Hash@V?$_Umap_traits@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@V?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@$0A@@std@@@std@@IAEXI@Z endp
.text$mn:00006B77
.text$mn:00006B77 ; ---------------------------------------------------------------------------
.text$mn:00006B7A                 align 4
.text$mn:00006B7A _text$mn        ends
.text$mn:00006B7A
.text$mn:00006B7C ; ===========================================================================
.text$mn:00006B7C
.text$mn:00006B7C ; Segment type: Pure code
.text$mn:00006B7C ; Segment permissions: Read/Execute
.text$mn:00006B7C _text$mn        segment para public 'CODE' use32
.text$mn:00006B7C                 assume cs:_text$mn
.text$mn:00006B7C                 ;org 6B7Ch
.text$mn:00006B7C ; COMDAT (pick any)
.text$mn:00006B7C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006B7C
.text$mn:00006B7C ; =============== S U B R O U T I N E =======================================
.text$mn:00006B7C
.text$mn:00006B7C ; Attributes: bp-based frame
.text$mn:00006B7C
.text$mn:00006B7C                 public ?_Insert_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUS
.text$mn:00006B7C ?_Insert_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std proc near
.text$mn:00006B7C                                         ; CODE XREF: ?insert@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUS
.text$mn:00006B7C
.text$mn:00006B7C var_50          = byte ptr -50h
.text$mn:00006B7C var_44          = dword ptr -44h
.text$mn:00006B7C var_40          = dword ptr -40h
.text$mn:00006B7C var_3C          = dword ptr -3Ch
.text$mn:00006B7C var_38          = dword ptr -38h
.text$mn:00006B7C var_34          = dword ptr -34h
.text$mn:00006B7C var_30          = dword ptr -30h
.text$mn:00006B7C var_2C          = dword ptr -2Ch
.text$mn:00006B7C var_28          = dword ptr -28h
.text$mn:00006B7C var_24          = dword ptr -24h
.text$mn:00006B7C var_20          = dword ptr -20h
.text$mn:00006B7C var_1C          = dword ptr -1Ch
.text$mn:00006B7C var_18          = dword ptr -18h
.text$mn:00006B7C var_13          = byte ptr -13h
.text$mn:00006B7C var_11          = byte ptr -11h
.text$mn:00006B7C var_10          = dword ptr -10h
.text$mn:00006B7C var_C           = dword ptr -0Ch
.text$mn:00006B7C var_4           = dword ptr -4
.text$mn:00006B7C arg_0           = dword ptr  8
.text$mn:00006B7C arg_4           = byte ptr  0Ch
.text$mn:00006B7C arg_C           = dword ptr  14h
.text$mn:00006B7C arg_10          = dword ptr  18h
.text$mn:00006B7C arg_14          = dword ptr  1Ch
.text$mn:00006B7C
.text$mn:00006B7C ; FUNCTION CHUNK AT .text$mn:00006D66 SIZE 00000009 BYTES
.text$mn:00006B7C ; FUNCTION CHUNK AT .text$mn:00006D76 SIZE 000000F9 BYTES
.text$mn:00006B7C ; FUNCTION CHUNK AT .text$mn:00006E9D SIZE 00000009 BYTES
.text$mn:00006B7C ; FUNCTION CHUNK AT .text$mn:00006EAD SIZE 00000126 BYTES
.text$mn:00006B7C
.text$mn:00006B7C                 push    ebp
.text$mn:00006B7D                 mov     ebp, esp
.text$mn:00006B7F                 push    0FFFFFFFFh
.text$mn:00006B81                 push    offset __ehhandler$?_Insert_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@
.text$mn:00006B86                 mov     eax, large fs:0
.text$mn:00006B8C                 push    eax
.text$mn:00006B8D                 push    ecx
.text$mn:00006B8E                 sub     esp, 40h
.text$mn:00006B91                 push    ebx
.text$mn:00006B92                 push    esi
.text$mn:00006B93                 push    edi
.text$mn:00006B94                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006B99                 xor     eax, ebp
.text$mn:00006B9B                 push    eax
.text$mn:00006B9C                 lea     eax, [ebp+var_C]
.text$mn:00006B9F                 mov     large fs:0, eax
.text$mn:00006BA5                 mov     [ebp+var_10], esp
.text$mn:00006BA8                 mov     [ebp+var_18], ecx
.text$mn:00006BAB                 mov     [ebp+var_34], 0
.text$mn:00006BB2                 mov     [ebp+var_4], 1
.text$mn:00006BB9                 lea     ecx, [ebp+arg_4] ; this
.text$mn:00006BBC                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:00006BC1                 cmp     eax, [ebp+var_18]
.text$mn:00006BC4                 jnz     short loc_6BDC
.text$mn:00006BC6                 mov     eax, [ebp+var_18]
.text$mn:00006BC9                 mov     ecx, [ebp+arg_C]
.text$mn:00006BCC                 cmp     ecx, [eax+4]
.text$mn:00006BCF                 jb      short loc_6BDC
.text$mn:00006BD1                 mov     edx, [ebp+var_18]
.text$mn:00006BD4                 mov     eax, [edx+8]
.text$mn:00006BD7                 cmp     eax, [ebp+arg_C]
.text$mn:00006BDA                 jnb     short loc_6BF3
.text$mn:00006BDC
.text$mn:00006BDC loc_6BDC:                               ; CODE XREF: ?_Insert_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CB
.text$mn:00006BDC                                         ; ?_Insert_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@s
.text$mn:00006BDC                 push    67Ah            ; unsigned int
.text$mn:00006BE1                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00006BE6                 push    offset ??_C@_1EK@EEHFMKDC@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAn?$AAs?$AAe?$AAr?$AAt?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAo?$AAu?$AAt?$AAs?$AAi?$AAd?$AAe?$AA?5?$AAr@ ; "vector insert iterator outside range"
.text$mn:00006BEB                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00006BF0                 add     esp, 0Ch
.text$mn:00006BF3
.text$mn:00006BF3 loc_6BF3:                               ; CODE XREF: ?_Insert_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CB
.text$mn:00006BF3                 mov     ecx, [ebp+var_18]
.text$mn:00006BF6                 mov     edx, [ebp+arg_C]
.text$mn:00006BF9                 sub     edx, [ecx+4]
.text$mn:00006BFC                 sar     edx, 2
.text$mn:00006BFF                 mov     [ebp+var_3C], edx
.text$mn:00006C02                 cmp     [ebp+arg_10], 0
.text$mn:00006C06                 jnz     short loc_6C0D
.text$mn:00006C08                 jmp     loc_6F72
.text$mn:00006C0D ; ---------------------------------------------------------------------------
.text$mn:00006C0D
.text$mn:00006C0D loc_6C0D:                               ; CODE XREF: ?_Insert_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CB
.text$mn:00006C0D                 mov     ecx, [ebp+var_18]
.text$mn:00006C10                 call    ?_Unused_capacity@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QBEIXZ ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::_Unused_capacity(void)
.text$mn:00006C15                 cmp     eax, [ebp+arg_10]
.text$mn:00006C18                 jnb     loc_6E01
.text$mn:00006C1E                 mov     ecx, [ebp+var_18]
.text$mn:00006C21                 call    ?max_size@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QBEIXZ ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::max_size(void)
.text$mn:00006C26                 mov     esi, eax
.text$mn:00006C28                 mov     ecx, [ebp+var_18]
.text$mn:00006C2B                 call    ?size@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QBEIXZ ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::size(void)
.text$mn:00006C30                 sub     esi, eax
.text$mn:00006C32                 cmp     esi, [ebp+arg_10]
.text$mn:00006C35                 jnb     short loc_6C3F
.text$mn:00006C37                 mov     ecx, [ebp+var_18]
.text$mn:00006C3A                 call    ?_Xlen@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IBEXXZ ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::_Xlen(void)
.text$mn:00006C3F
.text$mn:00006C3F loc_6C3F:                               ; CODE XREF: ?_Insert_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CB
.text$mn:00006C3F                 mov     ecx, [ebp+var_18]
.text$mn:00006C42                 call    ?size@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QBEIXZ ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::size(void)
.text$mn:00006C47                 add     eax, [ebp+arg_10]
.text$mn:00006C4A                 push    eax
.text$mn:00006C4B                 mov     ecx, [ebp+var_18]
.text$mn:00006C4E                 call    ?_Grow_to@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IBEII@Z ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::_Grow_to(uint)
.text$mn:00006C53                 mov     [ebp+var_2C], eax
.text$mn:00006C56                 mov     eax, [ebp+var_2C]
.text$mn:00006C59                 push    eax
.text$mn:00006C5A                 lea     ecx, [ebp+var_11]
.text$mn:00006C5D                 push    ecx
.text$mn:00006C5E                 mov     ecx, [ebp+var_18]
.text$mn:00006C61                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>>::_Getal(void)
.text$mn:00006C66                 mov     ecx, eax
.text$mn:00006C68                 call    ?allocate@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAEPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@I@Z ; std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::allocate(uint)
.text$mn:00006C6D                 mov     [ebp+var_1C], eax
.text$mn:00006C70                 mov     edx, [ebp+var_18]
.text$mn:00006C73                 mov     eax, [ebp+arg_C]
.text$mn:00006C76                 sub     eax, [edx+4]
.text$mn:00006C79                 sar     eax, 2
.text$mn:00006C7C                 mov     [ebp+var_24], eax
.text$mn:00006C7F                 mov     [ebp+var_20], 0
.text$mn:00006C86                 mov     byte ptr [ebp+var_4], 2
.text$mn:00006C8A                 mov     ecx, [ebp+arg_14]
.text$mn:00006C8D                 push    ecx
.text$mn:00006C8E                 call    ??$addressof@$$CBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@YAPBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@ABV10@@Z ; std::addressof<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const &)
.text$mn:00006C93                 add     esp, 4
.text$mn:00006C96                 push    eax             ; int
.text$mn:00006C97                 mov     edx, [ebp+arg_10]
.text$mn:00006C9A                 push    edx             ; int
.text$mn:00006C9B                 mov     eax, [ebp+var_24]
.text$mn:00006C9E                 mov     ecx, [ebp+var_1C]
.text$mn:00006CA1                 lea     edx, [ecx+eax*4]
.text$mn:00006CA4                 push    edx             ; void *
.text$mn:00006CA5                 mov     ecx, [ebp+var_18]
.text$mn:00006CA8                 call    ?_Ufill@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAEPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@PAV32@IPBV32@@Z ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::_Ufill(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,uint,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const *)
.text$mn:00006CAD                 mov     eax, [ebp+var_20]
.text$mn:00006CB0                 add     eax, 1
.text$mn:00006CB3                 mov     [ebp+var_20], eax
.text$mn:00006CB6                 mov     ecx, [ebp+var_1C]
.text$mn:00006CB9                 push    ecx
.text$mn:00006CBA                 mov     edx, [ebp+arg_C]
.text$mn:00006CBD                 push    edx
.text$mn:00006CBE                 mov     eax, [ebp+var_18]
.text$mn:00006CC1                 mov     ecx, [eax+4]
.text$mn:00006CC4                 push    ecx
.text$mn:00006CC5                 mov     ecx, [ebp+var_18]
.text$mn:00006CC8                 call    ??$_Umove@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAEPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@PAV21@00@Z ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::_Umove<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *)
.text$mn:00006CCD                 mov     edx, [ebp+var_20]
.text$mn:00006CD0                 add     edx, 1
.text$mn:00006CD3                 mov     [ebp+var_20], edx
.text$mn:00006CD6                 mov     eax, [ebp+var_24]
.text$mn:00006CD9                 add     eax, [ebp+arg_10]
.text$mn:00006CDC                 mov     ecx, [ebp+var_1C]
.text$mn:00006CDF                 lea     edx, [ecx+eax*4]
.text$mn:00006CE2                 push    edx
.text$mn:00006CE3                 mov     eax, [ebp+var_18]
.text$mn:00006CE6                 mov     ecx, [eax+8]
.text$mn:00006CE9                 push    ecx
.text$mn:00006CEA                 mov     edx, [ebp+arg_C]
.text$mn:00006CED                 push    edx
.text$mn:00006CEE                 mov     ecx, [ebp+var_18]
.text$mn:00006CF1                 call    ??$_Umove@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAEPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@PAV21@00@Z ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::_Umove<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *)
.text$mn:00006CF6                 jmp     short loc_6D66
.text$mn:00006CF6 ?_Insert_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@
.text$mn:00006CF6
.text$mn:00006CF8
.text$mn:00006CF8 ; =============== S U B R O U T I N E =======================================
.text$mn:00006CF8
.text$mn:00006CF8 ; Attributes: noreturn
.text$mn:00006CF8
.text$mn:00006CF8 __catch$?_Insert_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@ proc near
.text$mn:00006CF8                                         ; DATA XREF: .xdata$x:0000A284o
.text$mn:00006CF8                 cmp     dword ptr [ebp-20h], 1
.text$mn:00006CFC                 jle     short loc_6D14
.text$mn:00006CFE                 mov     eax, [ebp-24h]
.text$mn:00006D01                 mov     ecx, [ebp-1Ch]
.text$mn:00006D04                 lea     edx, [ecx+eax*4]
.text$mn:00006D07                 push    edx
.text$mn:00006D08                 mov     eax, [ebp-1Ch]
.text$mn:00006D0B                 push    eax
.text$mn:00006D0C                 mov     ecx, [ebp-18h]
.text$mn:00006D0F                 call    ?_Destroy@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@0@Z ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::_Destroy(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *)
.text$mn:00006D14
.text$mn:00006D14 loc_6D14:                               ; CODE XREF: __catch$?_Insert_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$p
.text$mn:00006D14                 cmp     dword ptr [ebp-20h], 0
.text$mn:00006D18                 jle     short loc_6D3C
.text$mn:00006D1A                 mov     ecx, [ebp-24h]
.text$mn:00006D1D                 mov     edx, [ebp-1Ch]
.text$mn:00006D20                 lea     eax, [edx+ecx*4]
.text$mn:00006D23                 mov     ecx, [ebp+18h]
.text$mn:00006D26                 lea     edx, [eax+ecx*4]
.text$mn:00006D29                 push    edx
.text$mn:00006D2A                 mov     eax, [ebp-24h]
.text$mn:00006D2D                 mov     ecx, [ebp-1Ch]
.text$mn:00006D30                 lea     edx, [ecx+eax*4]
.text$mn:00006D33                 push    edx
.text$mn:00006D34                 mov     ecx, [ebp-18h]
.text$mn:00006D37                 call    ?_Destroy@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@0@Z ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::_Destroy(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *)
.text$mn:00006D3C
.text$mn:00006D3C loc_6D3C:                               ; CODE XREF: __catch$?_Insert_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$p
.text$mn:00006D3C                 mov     eax, [ebp-2Ch]
.text$mn:00006D3F                 push    eax             ; int
.text$mn:00006D40                 mov     ecx, [ebp-1Ch]
.text$mn:00006D43                 push    ecx             ; void *
.text$mn:00006D44                 lea     edx, [ebp-12h]
.text$mn:00006D47                 push    edx
.text$mn:00006D48                 mov     ecx, [ebp-18h]
.text$mn:00006D4B                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>>::_Getal(void)
.text$mn:00006D50                 mov     ecx, eax
.text$mn:00006D52                 call    ?deallocate@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@I@Z ; std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::deallocate(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,uint)
.text$mn:00006D57                 push    0
.text$mn:00006D59                 push    0
.text$mn:00006D5B                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00006D5B __catch$?_Insert_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHU
.text$mn:00006D5B
.text$mn:00006D60 ; ---------------------------------------------------------------------------
.text$mn:00006D60                 mov     eax, offset $LN26
.text$mn:00006D65                 retn
.text$mn:00006D66 ; ---------------------------------------------------------------------------
.text$mn:00006D66 ; START OF FUNCTION CHUNK FOR ?_Insert_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std
.text$mn:00006D66
.text$mn:00006D66 loc_6D66:                               ; CODE XREF: ?_Insert_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CB
.text$mn:00006D66                 mov     [ebp+var_4], 1
.text$mn:00006D6D                 jmp     short loc_6D76
.text$mn:00006D6D ; END OF FUNCTION CHUNK FOR ?_Insert_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std
.text$mn:00006D6F
.text$mn:00006D6F ; =============== S U B R O U T I N E =======================================
.text$mn:00006D6F
.text$mn:00006D6F
.text$mn:00006D6F $LN26           proc near               ; DATA XREF: .text$mn:00006D60o
.text$mn:00006D6F                 mov     dword ptr [ebp-4], 1
.text$mn:00006D6F $LN26           endp ; sp-analysis failed
.text$mn:00006D6F
.text$mn:00006D76 ; START OF FUNCTION CHUNK FOR ?_Insert_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std
.text$mn:00006D76
.text$mn:00006D76 loc_6D76:                               ; CODE XREF: ?_Insert_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CB
.text$mn:00006D76                 mov     ecx, [ebp+var_18]
.text$mn:00006D79                 call    ?size@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QBEIXZ ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::size(void)
.text$mn:00006D7E                 add     eax, [ebp+arg_10]
.text$mn:00006D81                 mov     [ebp+arg_10], eax
.text$mn:00006D84                 mov     eax, [ebp+var_18]
.text$mn:00006D87                 cmp     dword ptr [eax+4], 0
.text$mn:00006D8B                 jz      short loc_6DCD
.text$mn:00006D8D                 mov     ecx, [ebp+var_18]
.text$mn:00006D90                 mov     edx, [ecx+8]
.text$mn:00006D93                 push    edx
.text$mn:00006D94                 mov     eax, [ebp+var_18]
.text$mn:00006D97                 mov     ecx, [eax+4]
.text$mn:00006D9A                 push    ecx
.text$mn:00006D9B                 mov     ecx, [ebp+var_18]
.text$mn:00006D9E                 call    ?_Destroy@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@0@Z ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::_Destroy(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *)
.text$mn:00006DA3                 mov     edx, [ebp+var_18]
.text$mn:00006DA6                 mov     eax, [ebp+var_18]
.text$mn:00006DA9                 mov     ecx, [edx+0Ch]
.text$mn:00006DAC                 sub     ecx, [eax+4]
.text$mn:00006DAF                 sar     ecx, 2
.text$mn:00006DB2                 push    ecx             ; int
.text$mn:00006DB3                 mov     edx, [ebp+var_18]
.text$mn:00006DB6                 mov     eax, [edx+4]
.text$mn:00006DB9                 push    eax             ; void *
.text$mn:00006DBA                 lea     ecx, [ebp+var_13]
.text$mn:00006DBD                 push    ecx
.text$mn:00006DBE                 mov     ecx, [ebp+var_18]
.text$mn:00006DC1                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>>::_Getal(void)
.text$mn:00006DC6                 mov     ecx, eax
.text$mn:00006DC8                 call    ?deallocate@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@I@Z ; std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::deallocate(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,uint)
.text$mn:00006DCD
.text$mn:00006DCD loc_6DCD:                               ; CODE XREF: ?_Insert_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CB
.text$mn:00006DCD                 mov     ecx, [ebp+var_18] ; this
.text$mn:00006DD0                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00006DD5                 mov     edx, [ebp+var_2C]
.text$mn:00006DD8                 mov     eax, [ebp+var_1C]
.text$mn:00006DDB                 lea     ecx, [eax+edx*4]
.text$mn:00006DDE                 mov     edx, [ebp+var_18]
.text$mn:00006DE1                 mov     [edx+0Ch], ecx
.text$mn:00006DE4                 mov     eax, [ebp+arg_10]
.text$mn:00006DE7                 mov     ecx, [ebp+var_1C]
.text$mn:00006DEA                 lea     edx, [ecx+eax*4]
.text$mn:00006DED                 mov     eax, [ebp+var_18]
.text$mn:00006DF0                 mov     [eax+8], edx
.text$mn:00006DF3                 mov     ecx, [ebp+var_18]
.text$mn:00006DF6                 mov     edx, [ebp+var_1C]
.text$mn:00006DF9                 mov     [ecx+4], edx
.text$mn:00006DFC                 jmp     loc_6F72
.text$mn:00006E01 ; ---------------------------------------------------------------------------
.text$mn:00006E01
.text$mn:00006E01 loc_6E01:                               ; CODE XREF: ?_Insert_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CB
.text$mn:00006E01                 mov     eax, [ebp+var_18]
.text$mn:00006E04                 mov     ecx, [eax+8]
.text$mn:00006E07                 sub     ecx, [ebp+arg_C]
.text$mn:00006E0A                 sar     ecx, 2
.text$mn:00006E0D                 cmp     ecx, [ebp+arg_10]
.text$mn:00006E10                 jnb     loc_6EF3
.text$mn:00006E16                 mov     edx, [ebp+arg_14]
.text$mn:00006E19                 mov     eax, [edx]
.text$mn:00006E1B                 mov     [ebp+var_30], eax
.text$mn:00006E1E                 mov     ecx, [ebp+arg_10]
.text$mn:00006E21                 mov     edx, [ebp+arg_C]
.text$mn:00006E24                 lea     eax, [edx+ecx*4]
.text$mn:00006E27                 push    eax
.text$mn:00006E28                 mov     ecx, [ebp+var_18]
.text$mn:00006E2B                 mov     edx, [ecx+8]
.text$mn:00006E2E                 push    edx
.text$mn:00006E2F                 mov     eax, [ebp+arg_C]
.text$mn:00006E32                 push    eax
.text$mn:00006E33                 mov     ecx, [ebp+var_18]
.text$mn:00006E36                 call    ??$_Umove@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAEPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@PAV21@00@Z ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::_Umove<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *)
.text$mn:00006E3B                 mov     byte ptr [ebp+var_4], 4
.text$mn:00006E3F                 lea     ecx, [ebp+var_30]
.text$mn:00006E42                 push    ecx
.text$mn:00006E43                 call    ??$addressof@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@AAV10@@Z ; std::addressof<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> &)
.text$mn:00006E48                 add     esp, 4
.text$mn:00006E4B                 push    eax             ; int
.text$mn:00006E4C                 mov     edx, [ebp+var_18]
.text$mn:00006E4F                 mov     eax, [edx+8]
.text$mn:00006E52                 sub     eax, [ebp+arg_C]
.text$mn:00006E55                 sar     eax, 2
.text$mn:00006E58                 mov     ecx, [ebp+arg_10]
.text$mn:00006E5B                 sub     ecx, eax
.text$mn:00006E5D                 push    ecx             ; int
.text$mn:00006E5E                 mov     edx, [ebp+var_18]
.text$mn:00006E61                 mov     eax, [edx+8]
.text$mn:00006E64                 push    eax             ; void *
.text$mn:00006E65                 mov     ecx, [ebp+var_18]
.text$mn:00006E68                 call    ?_Ufill@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAEPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@PAV32@IPBV32@@Z ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::_Ufill(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,uint,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const *)
.text$mn:00006E6D                 jmp     short loc_6E9D
.text$mn:00006E6D ; END OF FUNCTION CHUNK FOR ?_Insert_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std
.text$mn:00006E6F
.text$mn:00006E6F ; =============== S U B R O U T I N E =======================================
.text$mn:00006E6F
.text$mn:00006E6F ; Attributes: noreturn
.text$mn:00006E6F
.text$mn:00006E6F __catch$?_Insert_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@_0 proc near
.text$mn:00006E6F                                         ; DATA XREF: .xdata$x:0000A274o
.text$mn:00006E6F                 mov     ecx, [ebp-18h]
.text$mn:00006E72                 mov     edx, [ecx+8]
.text$mn:00006E75                 mov     eax, [ebp+18h]
.text$mn:00006E78                 lea     ecx, [edx+eax*4]
.text$mn:00006E7B                 push    ecx
.text$mn:00006E7C                 mov     edx, [ebp+18h]
.text$mn:00006E7F                 mov     eax, [ebp+14h]
.text$mn:00006E82                 lea     ecx, [eax+edx*4]
.text$mn:00006E85                 push    ecx
.text$mn:00006E86                 mov     ecx, [ebp-18h]
.text$mn:00006E89                 call    ?_Destroy@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@0@Z ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::_Destroy(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *)
.text$mn:00006E8E                 push    0
.text$mn:00006E90                 push    0
.text$mn:00006E92                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00006E92 __catch$?_Insert_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHU
.text$mn:00006E92
.text$mn:00006E97 ; ---------------------------------------------------------------------------
.text$mn:00006E97                 mov     eax, offset $LN28
.text$mn:00006E9C                 retn
.text$mn:00006E9D ; ---------------------------------------------------------------------------
.text$mn:00006E9D ; START OF FUNCTION CHUNK FOR ?_Insert_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std
.text$mn:00006E9D
.text$mn:00006E9D loc_6E9D:                               ; CODE XREF: ?_Insert_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CB
.text$mn:00006E9D                 mov     [ebp+var_4], 1
.text$mn:00006EA4                 jmp     short loc_6EAD
.text$mn:00006EA4 ; END OF FUNCTION CHUNK FOR ?_Insert_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std
.text$mn:00006EA6
.text$mn:00006EA6 ; =============== S U B R O U T I N E =======================================
.text$mn:00006EA6
.text$mn:00006EA6
.text$mn:00006EA6 $LN28           proc near               ; DATA XREF: .text$mn:00006E97o
.text$mn:00006EA6                 mov     dword ptr [ebp-4], 1
.text$mn:00006EA6 $LN28           endp ; sp-analysis failed
.text$mn:00006EA6
.text$mn:00006EAD ; START OF FUNCTION CHUNK FOR ?_Insert_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std
.text$mn:00006EAD
.text$mn:00006EAD loc_6EAD:                               ; CODE XREF: ?_Insert_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CB
.text$mn:00006EAD                 mov     edx, [ebp+var_18]
.text$mn:00006EB0                 mov     eax, [edx+8]
.text$mn:00006EB3                 mov     ecx, [ebp+arg_10]
.text$mn:00006EB6                 lea     edx, [eax+ecx*4]
.text$mn:00006EB9                 mov     eax, [ebp+var_18]
.text$mn:00006EBC                 mov     [eax+8], edx
.text$mn:00006EBF                 mov     ecx, [ebp+var_18]
.text$mn:00006EC2                 mov     edx, [ecx+8]
.text$mn:00006EC5                 push    edx
.text$mn:00006EC6                 mov     eax, [ebp+arg_C]
.text$mn:00006EC9                 push    eax
.text$mn:00006ECA                 mov     ecx, [ebp+var_18]
.text$mn:00006ECD                 call    ?_Orphan_range@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IBEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@0@Z ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::_Orphan_range(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *)
.text$mn:00006ED2                 lea     ecx, [ebp+var_30]
.text$mn:00006ED5                 push    ecx
.text$mn:00006ED6                 mov     edx, [ebp+arg_10]
.text$mn:00006ED9                 shl     edx, 2
.text$mn:00006EDC                 mov     eax, [ebp+var_18]
.text$mn:00006EDF                 mov     ecx, [eax+8]
.text$mn:00006EE2                 sub     ecx, edx
.text$mn:00006EE4                 push    ecx
.text$mn:00006EE5                 mov     edx, [ebp+arg_C]
.text$mn:00006EE8                 push    edx
.text$mn:00006EE9                 call    ??$fill@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@0ABV10@@Z ; std::fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const &)
.text$mn:00006EEE                 add     esp, 0Ch
.text$mn:00006EF1                 jmp     short loc_6F72
.text$mn:00006EF3 ; ---------------------------------------------------------------------------
.text$mn:00006EF3
.text$mn:00006EF3 loc_6EF3:                               ; CODE XREF: ?_Insert_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CB
.text$mn:00006EF3                 mov     eax, [ebp+arg_14]
.text$mn:00006EF6                 mov     ecx, [eax]
.text$mn:00006EF8                 mov     [ebp+var_38], ecx
.text$mn:00006EFB                 mov     edx, [ebp+var_18]
.text$mn:00006EFE                 mov     eax, [edx+8]
.text$mn:00006F01                 mov     [ebp+var_28], eax
.text$mn:00006F04                 mov     ecx, [ebp+var_18]
.text$mn:00006F07                 mov     edx, [ecx+8]
.text$mn:00006F0A                 push    edx
.text$mn:00006F0B                 mov     eax, [ebp+var_28]
.text$mn:00006F0E                 push    eax
.text$mn:00006F0F                 mov     ecx, [ebp+arg_10]
.text$mn:00006F12                 shl     ecx, 2
.text$mn:00006F15                 mov     edx, [ebp+var_28]
.text$mn:00006F18                 sub     edx, ecx
.text$mn:00006F1A                 push    edx
.text$mn:00006F1B                 mov     ecx, [ebp+var_18]
.text$mn:00006F1E                 call    ??$_Umove@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAEPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@PAV21@00@Z ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::_Umove<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *)
.text$mn:00006F23                 mov     ecx, [ebp+var_18]
.text$mn:00006F26                 mov     [ecx+8], eax
.text$mn:00006F29                 mov     edx, [ebp+var_18]
.text$mn:00006F2C                 mov     eax, [edx+8]
.text$mn:00006F2F                 push    eax
.text$mn:00006F30                 mov     ecx, [ebp+arg_C]
.text$mn:00006F33                 push    ecx
.text$mn:00006F34                 mov     ecx, [ebp+var_18]
.text$mn:00006F37                 call    ?_Orphan_range@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IBEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@0@Z ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::_Orphan_range(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *)
.text$mn:00006F3C                 mov     edx, [ebp+var_28]
.text$mn:00006F3F                 push    edx
.text$mn:00006F40                 mov     eax, [ebp+arg_10]
.text$mn:00006F43                 shl     eax, 2
.text$mn:00006F46                 mov     ecx, [ebp+var_28]
.text$mn:00006F49                 sub     ecx, eax
.text$mn:00006F4B                 push    ecx
.text$mn:00006F4C                 mov     edx, [ebp+arg_C]
.text$mn:00006F4F                 push    edx
.text$mn:00006F50                 call    ??$_Copy_backward@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@PAV12@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@PAV10@00@Z ; std::_Copy_backward<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *)
.text$mn:00006F55                 add     esp, 0Ch
.text$mn:00006F58                 lea     eax, [ebp+var_38]
.text$mn:00006F5B                 push    eax
.text$mn:00006F5C                 mov     ecx, [ebp+arg_10]
.text$mn:00006F5F                 mov     edx, [ebp+arg_C]
.text$mn:00006F62                 lea     eax, [edx+ecx*4]
.text$mn:00006F65                 push    eax
.text$mn:00006F66                 mov     ecx, [ebp+arg_C]
.text$mn:00006F69                 push    ecx
.text$mn:00006F6A                 call    ??$fill@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@0ABV10@@Z ; std::fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const &)
.text$mn:00006F6F                 add     esp, 0Ch
.text$mn:00006F72
.text$mn:00006F72 loc_6F72:                               ; CODE XREF: ?_Insert_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CB
.text$mn:00006F72                                         ; ?_Insert_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@s ...
.text$mn:00006F72                 mov     edx, [ebp+var_3C]
.text$mn:00006F75                 push    edx
.text$mn:00006F76                 mov     eax, [ebp+arg_0]
.text$mn:00006F79                 push    eax
.text$mn:00006F7A                 lea     ecx, [ebp+var_50]
.text$mn:00006F7D                 push    ecx
.text$mn:00006F7E                 mov     ecx, [ebp+var_18]
.text$mn:00006F81                 call    ?begin@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@XZ ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::begin(void)
.text$mn:00006F86                 mov     [ebp+var_40], eax
.text$mn:00006F89                 mov     edx, [ebp+var_40]
.text$mn:00006F8C                 mov     [ebp+var_44], edx
.text$mn:00006F8F                 mov     byte ptr [ebp+var_4], 6
.text$mn:00006F93                 mov     ecx, [ebp+var_44]
.text$mn:00006F96                 call    ??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::operator+(int)
.text$mn:00006F9B                 mov     eax, [ebp+var_34]
.text$mn:00006F9E                 or      eax, 1
.text$mn:00006FA1                 mov     [ebp+var_34], eax
.text$mn:00006FA4                 mov     byte ptr [ebp+var_4], 1
.text$mn:00006FA8                 lea     ecx, [ebp+var_50]
.text$mn:00006FAB                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>(void)
.text$mn:00006FB0                 mov     byte ptr [ebp+var_4], 0
.text$mn:00006FB4                 lea     ecx, [ebp+arg_4]
.text$mn:00006FB7                 call    ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>(void)
.text$mn:00006FBC                 mov     eax, [ebp+arg_0]
.text$mn:00006FBF                 mov     ecx, [ebp+var_C]
.text$mn:00006FC2                 mov     large fs:0, ecx
.text$mn:00006FC9                 pop     ecx
.text$mn:00006FCA                 pop     edi
.text$mn:00006FCB                 pop     esi
.text$mn:00006FCC                 pop     ebx
.text$mn:00006FCD                 mov     esp, ebp
.text$mn:00006FCF                 pop     ebp
.text$mn:00006FD0                 retn    18h
.text$mn:00006FD0 ; END OF FUNCTION CHUNK FOR ?_Insert_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std
.text$mn:00006FD0 ; ---------------------------------------------------------------------------
.text$mn:00006FD3                 align 4
.text$mn:00006FD3 _text$mn        ends
.text$mn:00006FD3
.text$x:00006FD4 ; ===========================================================================
.text$x:00006FD4
.text$x:00006FD4 ; Segment type: Pure code
.text$x:00006FD4 ; Segment permissions: Read/Execute
.text$x:00006FD4 _text$x         segment para public 'CODE' use32
.text$x:00006FD4                 assume cs:_text$x
.text$x:00006FD4                 ;org 6FD4h
.text$x:00006FD4 ; COMDAT (pick associative to section at 6B7C)
.text$x:00006FD4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00006FD4
.text$x:00006FD4 ; =============== S U B R O U T I N E =======================================
.text$x:00006FD4
.text$x:00006FD4
.text$x:00006FD4 __unwindfunclet$?_Insert_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyl proc near
.text$x:00006FD4                                         ; DATA XREF: .xdata$x:0000A2E0o
.text$x:00006FD4                 lea     ecx, [ebp+0Ch]
.text$x:00006FD7                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>(void)
.text$x:00006FD7 __unwindfunclet$?_Insert_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pai
.text$x:00006FD7
.text$x:00006FDC
.text$x:00006FDC ; =============== S U B R O U T I N E =======================================
.text$x:00006FDC
.text$x:00006FDC
.text$x:00006FDC __unwindfunclet$?_Insert_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyl_0 proc near
.text$x:00006FDC                                         ; DATA XREF: .xdata$x:0000A308o
.text$x:00006FDC                 lea     ecx, [ebp-50h]
.text$x:00006FDF                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>(void)
.text$x:00006FDF __unwindfunclet$?_Insert_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pai
.text$x:00006FDF
.text$x:00006FE4
.text$x:00006FE4 ; =============== S U B R O U T I N E =======================================
.text$x:00006FE4
.text$x:00006FE4
.text$x:00006FE4 __unwindfunclet$?_Insert_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyl_1 proc near
.text$x:00006FE4                                         ; DATA XREF: .xdata$x:0000A2D8o
.text$x:00006FE4                 mov     eax, [ebp-34h]
.text$x:00006FE7                 and     eax, 1
.text$x:00006FEA                 jz      $LN24
.text$x:00006FF0                 and     dword ptr [ebp-34h], 0FFFFFFFEh
.text$x:00006FF4                 mov     ecx, [ebp+8]
.text$x:00006FF7                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>(void)
.text$x:00006FFC ; ---------------------------------------------------------------------------
.text$x:00006FFC
.text$x:00006FFC $LN24:                                  ; CODE XREF: __unwindfunclet$?_Insert_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$alloca
.text$x:00006FFC                 retn
.text$x:00006FFC __unwindfunclet$?_Insert_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pai
.text$x:00006FFC
.text$x:00006FFD
.text$x:00006FFD ; =============== S U B R O U T I N E =======================================
.text$x:00006FFD
.text$x:00006FFD
.text$x:00006FFD __ehhandler$?_Insert_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@ proc near
.text$x:00006FFD                                         ; DATA XREF: ?_Insert_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CB
.text$x:00006FFD
.text$x:00006FFD arg_4           = dword ptr  8
.text$x:00006FFD
.text$x:00006FFD                 mov     edx, [esp+arg_4]
.text$x:00007001                 lea     eax, [edx+0Ch]
.text$x:00007004                 mov     ecx, [edx-54h]
.text$x:00007007                 xor     ecx, eax
.text$x:00007009                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000700E                 mov     eax, offset __ehfuncinfo$?_Insert_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@s
.text$x:00007013                 jmp     ___CxxFrameHandler3
.text$x:00007013 __ehhandler$?_Insert_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$
.text$x:00007013
.text$x:00007013 _text$x         ends
.text$x:00007013
.text$mn:00007018 ; ===========================================================================
.text$mn:00007018
.text$mn:00007018 ; Segment type: Pure code
.text$mn:00007018 ; Segment permissions: Read/Execute
.text$mn:00007018 _text$mn        segment para public 'CODE' use32
.text$mn:00007018                 assume cs:_text$mn
.text$mn:00007018                 ;org 7018h
.text$mn:00007018 ; COMDAT (pick any)
.text$mn:00007018                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007018
.text$mn:00007018 ; =============== S U B R O U T I N E =======================================
.text$mn:00007018
.text$mn:00007018 ; Attributes: bp-based frame
.text$mn:00007018
.text$mn:00007018 ; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Inside(char const *)
.text$mn:00007018                 public ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
.text$mn:00007018 ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z proc near
.text$mn:00007018                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+2Ap
.text$mn:00007018
.text$mn:00007018 var_4           = dword ptr -4
.text$mn:00007018 arg_0           = dword ptr  8
.text$mn:00007018
.text$mn:00007018                 push    ebp
.text$mn:00007019                 mov     ebp, esp
.text$mn:0000701B                 push    ecx
.text$mn:0000701C                 mov     [ebp+var_4], ecx
.text$mn:0000701F                 cmp     [ebp+arg_0], 0
.text$mn:00007023                 jz      short loc_7045
.text$mn:00007025                 mov     ecx, [ebp+var_4]
.text$mn:00007028                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000702D                 cmp     [ebp+arg_0], eax
.text$mn:00007030                 jb      short loc_7045
.text$mn:00007032                 mov     ecx, [ebp+var_4]
.text$mn:00007035                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000703A                 mov     ecx, [ebp+var_4]
.text$mn:0000703D                 add     eax, [ecx+14h]
.text$mn:00007040                 cmp     eax, [ebp+arg_0]
.text$mn:00007043                 ja      short loc_704B
.text$mn:00007045
.text$mn:00007045 loc_7045:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+Bj
.text$mn:00007045                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+18j
.text$mn:00007045                 xor     al, al
.text$mn:00007047                 jmp     short loc_704D
.text$mn:00007049 ; ---------------------------------------------------------------------------
.text$mn:00007049                 jmp     short loc_704D
.text$mn:0000704B ; ---------------------------------------------------------------------------
.text$mn:0000704B
.text$mn:0000704B loc_704B:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+2Bj
.text$mn:0000704B                 mov     al, 1
.text$mn:0000704D
.text$mn:0000704D loc_704D:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+2Fj
.text$mn:0000704D                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+31j
.text$mn:0000704D                 mov     esp, ebp
.text$mn:0000704F                 pop     ebp
.text$mn:00007050                 retn    4
.text$mn:00007050 ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z endp
.text$mn:00007050
.text$mn:00007050 ; ---------------------------------------------------------------------------
.text$mn:00007053                 align 4
.text$mn:00007053 _text$mn        ends
.text$mn:00007053
.text$mn:00007054 ; ===========================================================================
.text$mn:00007054
.text$mn:00007054 ; Segment type: Pure code
.text$mn:00007054 ; Segment permissions: Read/Execute
.text$mn:00007054 _text$mn        segment para public 'CODE' use32
.text$mn:00007054                 assume cs:_text$mn
.text$mn:00007054                 ;org 7054h
.text$mn:00007054 ; COMDAT (pick any)
.text$mn:00007054                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007054
.text$mn:00007054 ; =============== S U B R O U T I N E =======================================
.text$mn:00007054
.text$mn:00007054 ; Attributes: bp-based frame
.text$mn:00007054
.text$mn:00007054 ; protected: bool __thiscall std::vector<class ScintillaEditView *, class std::allocator<class ScintillaEditView *>>::_Inside(class ScintillaEditView * const *)const
.text$mn:00007054                 public ?_Inside@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@IBE_NPBQAVScintillaEditView@@@Z
.text$mn:00007054 ?_Inside@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@IBE_NPBQAVScintillaEditView@@@Z proc near
.text$mn:00007054                                         ; CODE XREF: std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::push_back(ScintillaEditView * const &)+19p
.text$mn:00007054
.text$mn:00007054 var_8           = dword ptr -8
.text$mn:00007054 var_4           = dword ptr -4
.text$mn:00007054 arg_0           = dword ptr  8
.text$mn:00007054
.text$mn:00007054                 push    ebp
.text$mn:00007055                 mov     ebp, esp
.text$mn:00007057                 sub     esp, 8
.text$mn:0000705A                 mov     [ebp+var_4], ecx
.text$mn:0000705D                 mov     eax, [ebp+var_4]
.text$mn:00007060                 mov     ecx, [ebp+arg_0]
.text$mn:00007063                 cmp     ecx, [eax+8]
.text$mn:00007066                 jnb     short loc_707C
.text$mn:00007068                 mov     edx, [ebp+var_4]
.text$mn:0000706B                 mov     eax, [edx+4]
.text$mn:0000706E                 cmp     eax, [ebp+arg_0]
.text$mn:00007071                 ja      short loc_707C
.text$mn:00007073                 mov     [ebp+var_8], 1
.text$mn:0000707A                 jmp     short loc_7083
.text$mn:0000707C ; ---------------------------------------------------------------------------
.text$mn:0000707C
.text$mn:0000707C loc_707C:                               ; CODE XREF: std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::_Inside(ScintillaEditView * const *)+12j
.text$mn:0000707C                                         ; std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::_Inside(ScintillaEditView * const *)+1Dj
.text$mn:0000707C                 mov     [ebp+var_8], 0
.text$mn:00007083
.text$mn:00007083 loc_7083:                               ; CODE XREF: std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::_Inside(ScintillaEditView * const *)+26j
.text$mn:00007083                 mov     al, byte ptr [ebp+var_8]
.text$mn:00007086                 mov     esp, ebp
.text$mn:00007088                 pop     ebp
.text$mn:00007089                 retn    4
.text$mn:00007089 ?_Inside@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@IBE_NPBQAVScintillaEditView@@@Z endp
.text$mn:00007089
.text$mn:00007089 _text$mn        ends
.text$mn:00007089
.text$mn:0000708C ; ===========================================================================
.text$mn:0000708C
.text$mn:0000708C ; Segment type: Pure code
.text$mn:0000708C ; Segment permissions: Read/Execute
.text$mn:0000708C _text$mn        segment para public 'CODE' use32
.text$mn:0000708C                 assume cs:_text$mn
.text$mn:0000708C                 ;org 708Ch
.text$mn:0000708C ; COMDAT (pick any)
.text$mn:0000708C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000708C
.text$mn:0000708C ; =============== S U B R O U T I N E =======================================
.text$mn:0000708C
.text$mn:0000708C ; Attributes: bp-based frame
.text$mn:0000708C
.text$mn:0000708C ; public: class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<class ScintillaEditView *>>> __thiscall std::vector<class ScintillaEditView *, class std::allocator<class ScintillaEditView *>>::_Make_iter(class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<class ScintillaEditView *>>>)const
.text$mn:0000708C                 public ?_Make_iter@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@2@@Z
.text$mn:0000708C ?_Make_iter@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@2@@Z proc near
.text$mn:0000708C                                         ; CODE XREF: std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::erase(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>)+EEp
.text$mn:0000708C
.text$mn:0000708C var_14          = dword ptr -14h
.text$mn:0000708C var_10          = dword ptr -10h
.text$mn:0000708C var_C           = dword ptr -0Ch
.text$mn:0000708C var_4           = dword ptr -4
.text$mn:0000708C arg_0           = dword ptr  8
.text$mn:0000708C arg_4           = byte ptr  0Ch
.text$mn:0000708C arg_C           = dword ptr  14h
.text$mn:0000708C
.text$mn:0000708C                 push    ebp
.text$mn:0000708D                 mov     ebp, esp
.text$mn:0000708F                 push    0FFFFFFFFh
.text$mn:00007091                 push    offset __ehhandler$?_Make_iter@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@2@@Z
.text$mn:00007096                 mov     eax, large fs:0
.text$mn:0000709C                 push    eax
.text$mn:0000709D                 sub     esp, 8
.text$mn:000070A0                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000070A5                 xor     eax, ebp
.text$mn:000070A7                 push    eax
.text$mn:000070A8                 lea     eax, [ebp+var_C]
.text$mn:000070AB                 mov     large fs:0, eax
.text$mn:000070B1                 mov     [ebp+var_14], ecx
.text$mn:000070B4                 mov     [ebp+var_10], 0
.text$mn:000070BB                 mov     [ebp+var_4], 1
.text$mn:000070C2                 mov     eax, [ebp+var_14]
.text$mn:000070C5                 push    eax             ; struct std::_Container_base12 *
.text$mn:000070C6                 mov     ecx, [ebp+arg_C]
.text$mn:000070C9                 push    ecx             ; int
.text$mn:000070CA                 mov     ecx, [ebp+arg_0]
.text$mn:000070CD                 call    ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@PAPAVScintillaEditView@@PBU_Container_base12@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>(ScintillaEditView * *,std::_Container_base12 const *)
.text$mn:000070D2                 mov     edx, [ebp+var_10]
.text$mn:000070D5                 or      edx, 1
.text$mn:000070D8                 mov     [ebp+var_10], edx
.text$mn:000070DB                 mov     byte ptr [ebp+var_4], 0
.text$mn:000070DF                 lea     ecx, [ebp+arg_4]
.text$mn:000070E2                 call    ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>(void)
.text$mn:000070E7                 mov     eax, [ebp+arg_0]
.text$mn:000070EA                 mov     ecx, [ebp+var_C]
.text$mn:000070ED                 mov     large fs:0, ecx
.text$mn:000070F4                 pop     ecx
.text$mn:000070F5                 mov     esp, ebp
.text$mn:000070F7                 pop     ebp
.text$mn:000070F8                 retn    10h
.text$mn:000070F8 ?_Make_iter@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@2@@Z endp
.text$mn:000070F8
.text$mn:000070F8 ; ---------------------------------------------------------------------------
.text$mn:000070FB                 align 4
.text$mn:000070FB _text$mn        ends
.text$mn:000070FB
.text$x:000070FC ; ===========================================================================
.text$x:000070FC
.text$x:000070FC ; Segment type: Pure code
.text$x:000070FC ; Segment permissions: Read/Execute
.text$x:000070FC _text$x         segment para public 'CODE' use32
.text$x:000070FC                 assume cs:_text$x
.text$x:000070FC                 ;org 70FCh
.text$x:000070FC ; COMDAT (pick associative to section at 708C)
.text$x:000070FC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000070FC
.text$x:000070FC ; =============== S U B R O U T I N E =======================================
.text$x:000070FC
.text$x:000070FC
.text$x:000070FC __unwindfunclet$?_Make_iter@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@2@@Z$0 proc near
.text$x:000070FC                                         ; DATA XREF: .xdata$x:00009A14o
.text$x:000070FC                 lea     ecx, [ebp+0Ch]
.text$x:000070FF                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>(void)
.text$x:000070FF __unwindfunclet$?_Make_iter@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@2@@Z$0 endp
.text$x:000070FF
.text$x:00007104
.text$x:00007104 ; =============== S U B R O U T I N E =======================================
.text$x:00007104
.text$x:00007104
.text$x:00007104 __unwindfunclet$?_Make_iter@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@2@@Z$1 proc near
.text$x:00007104                                         ; DATA XREF: .xdata$x:00009A0Co
.text$x:00007104                 mov     eax, [ebp-10h]
.text$x:00007107                 and     eax, 1
.text$x:0000710A                 jz      $LN5
.text$x:00007110                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:00007114                 mov     ecx, [ebp+8]
.text$x:00007117                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>(void)
.text$x:0000711C ; ---------------------------------------------------------------------------
.text$x:0000711C
.text$x:0000711C $LN5:                                   ; CODE XREF: __unwindfunclet$?_Make_iter@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@2@@Z$1+6j
.text$x:0000711C                 retn
.text$x:0000711C __unwindfunclet$?_Make_iter@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@2@@Z$1 endp
.text$x:0000711C
.text$x:0000711D
.text$x:0000711D ; =============== S U B R O U T I N E =======================================
.text$x:0000711D
.text$x:0000711D
.text$x:0000711D __ehhandler$?_Make_iter@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@2@@Z proc near
.text$x:0000711D                                         ; DATA XREF: std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::_Make_iter(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>)+5o
.text$x:0000711D
.text$x:0000711D arg_4           = dword ptr  8
.text$x:0000711D
.text$x:0000711D                 mov     edx, [esp+arg_4]
.text$x:00007121                 lea     eax, [edx+0Ch]
.text$x:00007124                 mov     ecx, [edx-0Ch]
.text$x:00007127                 xor     ecx, eax
.text$x:00007129                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000712E                 mov     eax, offset __ehfuncinfo$?_Make_iter@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@2@@Z
.text$x:00007133                 jmp     ___CxxFrameHandler3
.text$x:00007133 __ehhandler$?_Make_iter@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@2@@Z endp
.text$x:00007133
.text$x:00007133 _text$x         ends
.text$x:00007133
.text$mn:00007138 ; ===========================================================================
.text$mn:00007138
.text$mn:00007138 ; Segment type: Pure code
.text$mn:00007138 ; Segment permissions: Read/Execute
.text$mn:00007138 _text$mn        segment para public 'CODE' use32
.text$mn:00007138                 assume cs:_text$mn
.text$mn:00007138                 ;org 7138h
.text$mn:00007138 ; COMDAT (pick any)
.text$mn:00007138                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007138
.text$mn:00007138 ; =============== S U B R O U T I N E =======================================
.text$mn:00007138
.text$mn:00007138 ; Attributes: bp-based frame
.text$mn:00007138
.text$mn:00007138 ; public: char * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)
.text$mn:00007138                 public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
.text$mn:00007138 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ proc near
.text$mn:00007138                                         ; CODE XREF: $LN19+14p
.text$mn:00007138                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+1Dp ...
.text$mn:00007138
.text$mn:00007138 var_8           = dword ptr -8
.text$mn:00007138 var_4           = dword ptr -4
.text$mn:00007138
.text$mn:00007138                 push    ebp
.text$mn:00007139                 mov     ebp, esp
.text$mn:0000713B                 sub     esp, 8
.text$mn:0000713E                 mov     [ebp+var_4], ecx
.text$mn:00007141                 mov     eax, [ebp+var_4]
.text$mn:00007144                 cmp     dword ptr [eax+18h], 10h
.text$mn:00007148                 jb      short loc_715E
.text$mn:0000714A                 mov     ecx, [ebp+var_4]
.text$mn:0000714D                 mov     edx, [ecx+4]
.text$mn:00007150                 push    edx
.text$mn:00007151                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:00007156                 add     esp, 4
.text$mn:00007159                 mov     [ebp+var_8], eax
.text$mn:0000715C                 jmp     short loc_7167
.text$mn:0000715E ; ---------------------------------------------------------------------------
.text$mn:0000715E
.text$mn:0000715E loc_715E:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+10j
.text$mn:0000715E                 mov     eax, [ebp+var_4]
.text$mn:00007161                 add     eax, 4
.text$mn:00007164                 mov     [ebp+var_8], eax
.text$mn:00007167
.text$mn:00007167 loc_7167:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+24j
.text$mn:00007167                 mov     eax, [ebp+var_8]
.text$mn:0000716A                 mov     esp, ebp
.text$mn:0000716C                 pop     ebp
.text$mn:0000716D                 retn
.text$mn:0000716D ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ endp
.text$mn:0000716D
.text$mn:0000716D ; ---------------------------------------------------------------------------
.text$mn:0000716E                 align 10h
.text$mn:0000716E _text$mn        ends
.text$mn:0000716E
.text$mn:00007170 ; ===========================================================================
.text$mn:00007170
.text$mn:00007170 ; Segment type: Pure code
.text$mn:00007170 ; Segment permissions: Read/Execute
.text$mn:00007170 _text$mn        segment para public 'CODE' use32
.text$mn:00007170                 assume cs:_text$mn
.text$mn:00007170                 ;org 7170h
.text$mn:00007170 ; COMDAT (pick any)
.text$mn:00007170                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007170
.text$mn:00007170 ; =============== S U B R O U T I N E =======================================
.text$mn:00007170
.text$mn:00007170 ; Attributes: bp-based frame
.text$mn:00007170
.text$mn:00007170 ; public: char const * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)const
.text$mn:00007170                 public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
.text$mn:00007170 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ proc near
.text$mn:00007170                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+7Dp
.text$mn:00007170
.text$mn:00007170 var_8           = dword ptr -8
.text$mn:00007170 var_4           = dword ptr -4
.text$mn:00007170
.text$mn:00007170                 push    ebp
.text$mn:00007171                 mov     ebp, esp
.text$mn:00007173                 sub     esp, 8
.text$mn:00007176                 mov     [ebp+var_4], ecx
.text$mn:00007179                 mov     eax, [ebp+var_4]
.text$mn:0000717C                 cmp     dword ptr [eax+18h], 10h
.text$mn:00007180                 jb      short loc_7196
.text$mn:00007182                 mov     ecx, [ebp+var_4]
.text$mn:00007185                 mov     edx, [ecx+4]
.text$mn:00007188                 push    edx
.text$mn:00007189                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:0000718E                 add     esp, 4
.text$mn:00007191                 mov     [ebp+var_8], eax
.text$mn:00007194                 jmp     short loc_719F
.text$mn:00007196 ; ---------------------------------------------------------------------------
.text$mn:00007196
.text$mn:00007196 loc_7196:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+10j
.text$mn:00007196                 mov     eax, [ebp+var_4]
.text$mn:00007199                 add     eax, 4
.text$mn:0000719C                 mov     [ebp+var_8], eax
.text$mn:0000719F
.text$mn:0000719F loc_719F:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+24j
.text$mn:0000719F                 mov     eax, [ebp+var_8]
.text$mn:000071A2                 mov     esp, ebp
.text$mn:000071A4                 pop     ebp
.text$mn:000071A5                 retn
.text$mn:000071A5 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ endp
.text$mn:000071A5
.text$mn:000071A5 ; ---------------------------------------------------------------------------
.text$mn:000071A6                 align 4
.text$mn:000071A6 _text$mn        ends
.text$mn:000071A6
.text$mn:000071A8 ; ===========================================================================
.text$mn:000071A8
.text$mn:000071A8 ; Segment type: Pure code
.text$mn:000071A8 ; Segment permissions: Read/Execute
.text$mn:000071A8 _text$mn        segment para public 'CODE' use32
.text$mn:000071A8                 assume cs:_text$mn
.text$mn:000071A8                 ;org 71A8h
.text$mn:000071A8 ; COMDAT (pick any)
.text$mn:000071A8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000071A8
.text$mn:000071A8 ; =============== S U B R O U T I N E =======================================
.text$mn:000071A8
.text$mn:000071A8 ; Attributes: bp-based frame
.text$mn:000071A8
.text$mn:000071A8 ; public: wchar_t * __thiscall std::_String_val<struct std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:000071A8                 public ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ
.text$mn:000071A8 ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ proc near
.text$mn:000071A8                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)+1Fp
.text$mn:000071A8
.text$mn:000071A8 var_8           = dword ptr -8
.text$mn:000071A8 var_4           = dword ptr -4
.text$mn:000071A8
.text$mn:000071A8                 push    ebp
.text$mn:000071A9                 mov     ebp, esp
.text$mn:000071AB                 sub     esp, 8
.text$mn:000071AE                 mov     [ebp+var_4], ecx
.text$mn:000071B1                 mov     eax, [ebp+var_4]
.text$mn:000071B4                 cmp     dword ptr [eax+18h], 8
.text$mn:000071B8                 jb      short loc_71CE
.text$mn:000071BA                 mov     ecx, [ebp+var_4]
.text$mn:000071BD                 mov     edx, [ecx+4]
.text$mn:000071C0                 push    edx
.text$mn:000071C1                 call    ??$addressof@_W@std@@YAPA_WAA_W@Z ; std::addressof<wchar_t>(wchar_t &)
.text$mn:000071C6                 add     esp, 4
.text$mn:000071C9                 mov     [ebp+var_8], eax
.text$mn:000071CC                 jmp     short loc_71D7
.text$mn:000071CE ; ---------------------------------------------------------------------------
.text$mn:000071CE
.text$mn:000071CE loc_71CE:                               ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+10j
.text$mn:000071CE                 mov     eax, [ebp+var_4]
.text$mn:000071D1                 add     eax, 4
.text$mn:000071D4                 mov     [ebp+var_8], eax
.text$mn:000071D7
.text$mn:000071D7 loc_71D7:                               ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+24j
.text$mn:000071D7                 mov     eax, [ebp+var_8]
.text$mn:000071DA                 mov     esp, ebp
.text$mn:000071DC                 pop     ebp
.text$mn:000071DD                 retn
.text$mn:000071DD ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ endp
.text$mn:000071DD
.text$mn:000071DD ; ---------------------------------------------------------------------------
.text$mn:000071DE                 align 10h
.text$mn:000071DE _text$mn        ends
.text$mn:000071DE
.text$mn:000071E0 ; ===========================================================================
.text$mn:000071E0
.text$mn:000071E0 ; Segment type: Pure code
.text$mn:000071E0 ; Segment permissions: Read/Execute
.text$mn:000071E0 _text$mn        segment para public 'CODE' use32
.text$mn:000071E0                 assume cs:_text$mn
.text$mn:000071E0                 ;org 71E0h
.text$mn:000071E0 ; COMDAT (pick any)
.text$mn:000071E0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000071E0
.text$mn:000071E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000071E0
.text$mn:000071E0 ; Attributes: bp-based frame
.text$mn:000071E0
.text$mn:000071E0 ; public: static struct std::pair<int const, struct Style> & __cdecl std::_List_val<struct std::_List_simple_types<struct std::pair<int const, struct Style>>>::_Myval(struct std::_List_node<struct std::pair<int const, struct Style>, void *> *)
.text$mn:000071E0                 public ?_Myval@?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@SAAAU?$pair@$$CBHUStyle@@@2@PAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@2@@Z
.text$mn:000071E0 ?_Myval@?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@SAAAU?$pair@$$CBHUStyle@@@2@PAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@2@@Z proc near
.text$mn:000071E0                                         ; CODE XREF: std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>::operator*(void)+9Ep
.text$mn:000071E0                                         ; std::_List_buy<std::pair<int const,Style>,std::allocator<std::pair<int const,Style>>>::_Freenode(std::_List_node<std::pair<int const,Style>,void *> *)+5Fp
.text$mn:000071E0
.text$mn:000071E0 arg_0           = dword ptr  8
.text$mn:000071E0
.text$mn:000071E0                 push    ebp
.text$mn:000071E1                 mov     ebp, esp
.text$mn:000071E3                 mov     eax, [ebp+arg_0]
.text$mn:000071E6                 add     eax, 8
.text$mn:000071E9                 pop     ebp
.text$mn:000071EA                 retn
.text$mn:000071EA ?_Myval@?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@SAAAU?$pair@$$CBHUStyle@@@2@PAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@2@@Z endp
.text$mn:000071EA
.text$mn:000071EA ; ---------------------------------------------------------------------------
.text$mn:000071EB                 align 4
.text$mn:000071EB _text$mn        ends
.text$mn:000071EB
.text$mn:000071EC ; ===========================================================================
.text$mn:000071EC
.text$mn:000071EC ; Segment type: Pure code
.text$mn:000071EC ; Segment permissions: Read/Execute
.text$mn:000071EC _text$mn        segment para public 'CODE' use32
.text$mn:000071EC                 assume cs:_text$mn
.text$mn:000071EC                 ;org 71ECh
.text$mn:000071EC ; COMDAT (pick any)
.text$mn:000071EC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000071EC
.text$mn:000071EC ; =============== S U B R O U T I N E =======================================
.text$mn:000071EC
.text$mn:000071EC ; Attributes: bp-based frame
.text$mn:000071EC
.text$mn:000071EC ; public: static struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *> & __cdecl std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>::_Myval(struct std::_List_node<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>, void *> *)
.text$mn:000071EC                 public ?_Myval@?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@SAAAU?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@2@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@2@@Z
.text$mn:000071EC ?_Myval@?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@SAAAU?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@2@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@2@@Z proc near
.text$mn:000071EC                                         ; CODE XREF: std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::operator*(void)+9Ep
.text$mn:000071EC                                         ; std::_List_buy<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>::_Freenode(std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *)+5Fp
.text$mn:000071EC
.text$mn:000071EC arg_0           = dword ptr  8
.text$mn:000071EC
.text$mn:000071EC                 push    ebp
.text$mn:000071ED                 mov     ebp, esp
.text$mn:000071EF                 mov     eax, [ebp+arg_0]
.text$mn:000071F2                 add     eax, 8
.text$mn:000071F5                 pop     ebp
.text$mn:000071F6                 retn
.text$mn:000071F6 ?_Myval@?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@SAAAU?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@2@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@2@@Z endp
.text$mn:000071F6
.text$mn:000071F6 ; ---------------------------------------------------------------------------
.text$mn:000071F7                 align 4
.text$mn:000071F7 _text$mn        ends
.text$mn:000071F7
.text$mn:000071F8 ; ===========================================================================
.text$mn:000071F8
.text$mn:000071F8 ; Segment type: Pure code
.text$mn:000071F8 ; Segment permissions: Read/Execute
.text$mn:000071F8 _text$mn        segment para public 'CODE' use32
.text$mn:000071F8                 assume cs:_text$mn
.text$mn:000071F8                 ;org 71F8h
.text$mn:000071F8 ; COMDAT (pick any)
.text$mn:000071F8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000071F8
.text$mn:000071F8 ; =============== S U B R O U T I N E =======================================
.text$mn:000071F8
.text$mn:000071F8 ; Attributes: bp-based frame
.text$mn:000071F8
.text$mn:000071F8 ; public: static struct std::_List_node<struct std::pair<int const, struct Style>, void *> * & __cdecl std::_List_val<struct std::_List_simple_types<struct std::pair<int const, struct Style>>>::_Nextnode(struct std::_List_node<struct std::pair<int const, struct Style>, void *> *)
.text$mn:000071F8                 public ?_Nextnode@?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@SAAAPAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@2@PAU32@@Z
.text$mn:000071F8 ?_Nextnode@?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@SAAAPAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@2@PAU32@@Z proc near
.text$mn:000071F8                                         ; CODE XREF: std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>::operator++(void)+9Ep
.text$mn:000071F8                                         ; std::_List_alloc<0,std::_List_base_types<std::pair<int const,Style>,std::allocator<std::pair<int const,Style>>>>::_Freeheadnode(std::_List_node<std::pair<int const,Style>,void *> *)+Dp ...
.text$mn:000071F8
.text$mn:000071F8 arg_0           = dword ptr  8
.text$mn:000071F8
.text$mn:000071F8                 push    ebp
.text$mn:000071F9                 mov     ebp, esp
.text$mn:000071FB                 mov     eax, [ebp+arg_0]
.text$mn:000071FE                 pop     ebp
.text$mn:000071FF                 retn
.text$mn:000071FF ?_Nextnode@?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@SAAAPAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@2@PAU32@@Z endp
.text$mn:000071FF
.text$mn:000071FF _text$mn        ends
.text$mn:000071FF
.text$mn:00007200 ; ===========================================================================
.text$mn:00007200
.text$mn:00007200 ; Segment type: Pure code
.text$mn:00007200 ; Segment permissions: Read/Execute
.text$mn:00007200 _text$mn        segment para public 'CODE' use32
.text$mn:00007200                 assume cs:_text$mn
.text$mn:00007200                 ;org 7200h
.text$mn:00007200 ; COMDAT (pick any)
.text$mn:00007200                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007200
.text$mn:00007200 ; =============== S U B R O U T I N E =======================================
.text$mn:00007200
.text$mn:00007200 ; Attributes: bp-based frame
.text$mn:00007200
.text$mn:00007200 ; public: static struct std::_List_node<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>, void *> * & __cdecl std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>::_Nextnode(struct std::_List_node<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>, void *> *)
.text$mn:00007200                 public ?_Nextnode@?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@SAAAPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@2@PAU32@@Z
.text$mn:00007200 ?_Nextnode@?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@SAAAPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@2@PAU32@@Z proc near
.text$mn:00007200                                         ; CODE XREF: std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::operator++(void)+9Ep
.text$mn:00007200                                         ; std::_List_alloc<0,std::_List_base_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::_Buynode0(std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *,std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *)+68p ...
.text$mn:00007200
.text$mn:00007200 arg_0           = dword ptr  8
.text$mn:00007200
.text$mn:00007200                 push    ebp
.text$mn:00007201                 mov     ebp, esp
.text$mn:00007203                 mov     eax, [ebp+arg_0]
.text$mn:00007206                 pop     ebp
.text$mn:00007207                 retn
.text$mn:00007207 ?_Nextnode@?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@SAAAPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@2@PAU32@@Z endp
.text$mn:00007207
.text$mn:00007207 _text$mn        ends
.text$mn:00007207
.text$mn:00007208 ; ===========================================================================
.text$mn:00007208
.text$mn:00007208 ; Segment type: Pure code
.text$mn:00007208 ; Segment permissions: Read/Execute
.text$mn:00007208 _text$mn        segment para public 'CODE' use32
.text$mn:00007208                 assume cs:_text$mn
.text$mn:00007208                 ;org 7208h
.text$mn:00007208 ; COMDAT (pick any)
.text$mn:00007208                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007208
.text$mn:00007208 ; =============== S U B R O U T I N E =======================================
.text$mn:00007208
.text$mn:00007208 ; Attributes: bp-based frame
.text$mn:00007208
.text$mn:00007208 ; void __thiscall std::_Container_base12::_Orphan_all(std::_Container_base12 *__hidden this)
.text$mn:00007208                 public ?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$mn:00007208 ?_Orphan_all@_Container_base12@std@@QAEXXZ proc near
.text$mn:00007208                                         ; CODE XREF: std::_Container_base12::~_Container_base12(void)+Ap
.text$mn:00007208                                         ; std::_List_alloc<0,std::_List_base_types<std::pair<int const,Style>,std::allocator<std::pair<int const,Style>>>>::_Free_proxy(void)+14p ...
.text$mn:00007208
.text$mn:00007208 var_18          = byte ptr -18h
.text$mn:00007208 var_14          = dword ptr -14h
.text$mn:00007208 var_10          = dword ptr -10h
.text$mn:00007208 var_C           = dword ptr -0Ch
.text$mn:00007208 var_4           = dword ptr -4
.text$mn:00007208
.text$mn:00007208                 push    ebp
.text$mn:00007209                 mov     ebp, esp
.text$mn:0000720B                 push    0FFFFFFFFh
.text$mn:0000720D                 push    offset __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$mn:00007212                 mov     eax, large fs:0
.text$mn:00007218                 push    eax
.text$mn:00007219                 sub     esp, 0Ch
.text$mn:0000721C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00007221                 xor     eax, ebp
.text$mn:00007223                 push    eax
.text$mn:00007224                 lea     eax, [ebp+var_C]
.text$mn:00007227                 mov     large fs:0, eax
.text$mn:0000722D                 mov     [ebp+var_14], ecx
.text$mn:00007230                 mov     eax, [ebp+var_14]
.text$mn:00007233                 cmp     dword ptr [eax], 0
.text$mn:00007236                 jz      short loc_7293
.text$mn:00007238                 push    3               ; int
.text$mn:0000723A                 lea     ecx, [ebp+var_18] ; this
.text$mn:0000723D                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:00007242                 mov     [ebp+var_4], 0
.text$mn:00007249                 mov     ecx, [ebp+var_14]
.text$mn:0000724C                 mov     edx, [ecx]
.text$mn:0000724E                 add     edx, 4
.text$mn:00007251                 mov     [ebp+var_10], edx
.text$mn:00007254                 jmp     short loc_7263
.text$mn:00007256 ; ---------------------------------------------------------------------------
.text$mn:00007256
.text$mn:00007256 loc_7256:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+6Ej
.text$mn:00007256                 mov     eax, [ebp+var_10]
.text$mn:00007259                 mov     ecx, [eax]
.text$mn:0000725B                 mov     edx, [ebp+var_10]
.text$mn:0000725E                 mov     eax, [ecx+4]
.text$mn:00007261                 mov     [edx], eax
.text$mn:00007263
.text$mn:00007263 loc_7263:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+4Cj
.text$mn:00007263                 mov     ecx, [ebp+var_10]
.text$mn:00007266                 cmp     dword ptr [ecx], 0
.text$mn:00007269                 jz      short loc_7278
.text$mn:0000726B                 mov     edx, [ebp+var_10]
.text$mn:0000726E                 mov     eax, [edx]
.text$mn:00007270                 mov     dword ptr [eax], 0
.text$mn:00007276                 jmp     short loc_7256
.text$mn:00007278 ; ---------------------------------------------------------------------------
.text$mn:00007278
.text$mn:00007278 loc_7278:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+61j
.text$mn:00007278                 mov     ecx, [ebp+var_14]
.text$mn:0000727B                 mov     edx, [ecx]
.text$mn:0000727D                 mov     dword ptr [edx+4], 0
.text$mn:00007284                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000728B                 lea     ecx, [ebp+var_18] ; this
.text$mn:0000728E                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:00007293
.text$mn:00007293 loc_7293:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+2Ej
.text$mn:00007293                 mov     ecx, [ebp+var_C]
.text$mn:00007296                 mov     large fs:0, ecx
.text$mn:0000729D                 pop     ecx
.text$mn:0000729E                 mov     esp, ebp
.text$mn:000072A0                 pop     ebp
.text$mn:000072A1                 retn
.text$mn:000072A1 ?_Orphan_all@_Container_base12@std@@QAEXXZ endp
.text$mn:000072A1
.text$mn:000072A1 ; ---------------------------------------------------------------------------
.text$mn:000072A2                 align 4
.text$mn:000072A2 _text$mn        ends
.text$mn:000072A2
.text$x:000072A4 ; ===========================================================================
.text$x:000072A4
.text$x:000072A4 ; Segment type: Pure code
.text$x:000072A4 ; Segment permissions: Read/Execute
.text$x:000072A4 _text$x         segment para public 'CODE' use32
.text$x:000072A4                 assume cs:_text$x
.text$x:000072A4                 ;org 72A4h
.text$x:000072A4 ; COMDAT (pick associative to section at 7208)
.text$x:000072A4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000072A4
.text$x:000072A4 ; =============== S U B R O U T I N E =======================================
.text$x:000072A4
.text$x:000072A4
.text$x:000072A4 __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0 proc near
.text$x:000072A4                                         ; DATA XREF: .xdata$x:00009724o
.text$x:000072A4                 lea     ecx, [ebp-18h]  ; this
.text$x:000072A7                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:000072A7 __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0 endp
.text$x:000072A7
.text$x:000072AC
.text$x:000072AC ; =============== S U B R O U T I N E =======================================
.text$x:000072AC
.text$x:000072AC
.text$x:000072AC __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ proc near
.text$x:000072AC                                         ; DATA XREF: std::_Container_base12::_Orphan_all(void)+5o
.text$x:000072AC
.text$x:000072AC arg_4           = dword ptr  8
.text$x:000072AC
.text$x:000072AC                 mov     edx, [esp+arg_4]
.text$x:000072B0                 lea     eax, [edx+0Ch]
.text$x:000072B3                 mov     ecx, [edx-10h]
.text$x:000072B6                 xor     ecx, eax
.text$x:000072B8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000072BD                 mov     eax, offset __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$x:000072C2                 jmp     ___CxxFrameHandler3
.text$x:000072C2 __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ endp
.text$x:000072C2
.text$x:000072C2 ; ---------------------------------------------------------------------------
.text$x:000072C7                 align 4
.text$x:000072C7 _text$x         ends
.text$x:000072C7
.text$mn:000072C8 ; ===========================================================================
.text$mn:000072C8
.text$mn:000072C8 ; Segment type: Pure code
.text$mn:000072C8 ; Segment permissions: Read/Execute
.text$mn:000072C8 _text$mn        segment para public 'CODE' use32
.text$mn:000072C8                 assume cs:_text$mn
.text$mn:000072C8                 ;org 72C8h
.text$mn:000072C8 ; COMDAT (pick any)
.text$mn:000072C8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000072C8
.text$mn:000072C8 ; =============== S U B R O U T I N E =======================================
.text$mn:000072C8
.text$mn:000072C8 ; Attributes: bp-based frame
.text$mn:000072C8
.text$mn:000072C8 ; void __thiscall std::_Iterator_base12::_Orphan_me(std::_Iterator_base12 *__hidden this)
.text$mn:000072C8                 public ?_Orphan_me@_Iterator_base12@std@@QAEXXZ
.text$mn:000072C8 ?_Orphan_me@_Iterator_base12@std@@QAEXXZ proc near
.text$mn:000072C8                                         ; CODE XREF: std::_Iterator_base12::~_Iterator_base12(void)+3Cp
.text$mn:000072C8                                         ; std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+64p ...
.text$mn:000072C8
.text$mn:000072C8 var_8           = dword ptr -8
.text$mn:000072C8 var_4           = dword ptr -4
.text$mn:000072C8
.text$mn:000072C8                 push    ebp
.text$mn:000072C9                 mov     ebp, esp
.text$mn:000072CB                 sub     esp, 8
.text$mn:000072CE                 mov     [ebp+var_8], ecx
.text$mn:000072D1                 mov     eax, [ebp+var_8]
.text$mn:000072D4                 cmp     dword ptr [eax], 0
.text$mn:000072D7                 jz      short loc_7336
.text$mn:000072D9                 mov     ecx, [ebp+var_8]
.text$mn:000072DC                 mov     edx, [ecx]
.text$mn:000072DE                 add     edx, 4
.text$mn:000072E1                 mov     [ebp+var_4], edx
.text$mn:000072E4
.text$mn:000072E4 loc_72E4:                               ; CODE XREF: std::_Iterator_base12::_Orphan_me(void)+39j
.text$mn:000072E4                 mov     eax, [ebp+var_4]
.text$mn:000072E7                 cmp     dword ptr [eax], 0
.text$mn:000072EA                 jz      short loc_7303
.text$mn:000072EC                 mov     ecx, [ebp+var_4]
.text$mn:000072EF                 mov     edx, [ecx]
.text$mn:000072F1                 cmp     edx, [ebp+var_8]
.text$mn:000072F4                 jz      short loc_7303
.text$mn:000072F6                 mov     eax, [ebp+var_4]
.text$mn:000072F9                 mov     ecx, [eax]
.text$mn:000072FB                 add     ecx, 4
.text$mn:000072FE                 mov     [ebp+var_4], ecx
.text$mn:00007301                 jmp     short loc_72E4
.text$mn:00007303 ; ---------------------------------------------------------------------------
.text$mn:00007303
.text$mn:00007303 loc_7303:                               ; CODE XREF: std::_Iterator_base12::_Orphan_me(void)+22j
.text$mn:00007303                                         ; std::_Iterator_base12::_Orphan_me(void)+2Cj
.text$mn:00007303                 mov     edx, [ebp+var_4]
.text$mn:00007306                 cmp     dword ptr [edx], 0
.text$mn:00007309                 jnz     short loc_7322
.text$mn:0000730B                 push    0C9h ; '+'      ; unsigned int
.text$mn:00007310                 push    offset ??_C@_1JA@EADLBAJ@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00007315                 push    offset ??_C@_1DC@POOIKBAO@?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5?$AAC?$AAO?$AAR?$AAR?$AAU?$AAP?$AAT?$AAE?$AAD?$AA?$CB?$AA?$AA@ ; "ITERATOR LIST CORRUPTED!"
.text$mn:0000731A                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:0000731F                 add     esp, 0Ch
.text$mn:00007322
.text$mn:00007322 loc_7322:                               ; CODE XREF: std::_Iterator_base12::_Orphan_me(void)+41j
.text$mn:00007322                 mov     eax, [ebp+var_4]
.text$mn:00007325                 mov     ecx, [ebp+var_8]
.text$mn:00007328                 mov     edx, [ecx+4]
.text$mn:0000732B                 mov     [eax], edx
.text$mn:0000732D                 mov     eax, [ebp+var_8]
.text$mn:00007330                 mov     dword ptr [eax], 0
.text$mn:00007336
.text$mn:00007336 loc_7336:                               ; CODE XREF: std::_Iterator_base12::_Orphan_me(void)+Fj
.text$mn:00007336                 mov     esp, ebp
.text$mn:00007338                 pop     ebp
.text$mn:00007339                 retn
.text$mn:00007339 ?_Orphan_me@_Iterator_base12@std@@QAEXXZ endp
.text$mn:00007339
.text$mn:00007339 ; ---------------------------------------------------------------------------
.text$mn:0000733A                 align 4
.text$mn:0000733A _text$mn        ends
.text$mn:0000733A
.text$mn:0000733C ; ===========================================================================
.text$mn:0000733C
.text$mn:0000733C ; Segment type: Pure code
.text$mn:0000733C ; Segment permissions: Read/Execute
.text$mn:0000733C _text$mn        segment para public 'CODE' use32
.text$mn:0000733C                 assume cs:_text$mn
.text$mn:0000733C                 ;org 733Ch
.text$mn:0000733C ; COMDAT (pick any)
.text$mn:0000733C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000733C
.text$mn:0000733C ; =============== S U B R O U T I N E =======================================
.text$mn:0000733C
.text$mn:0000733C ; Attributes: bp-based frame
.text$mn:0000733C
.text$mn:0000733C ; int __stdcall std::list<std::pair<int const,Style>,std::allocator<std::pair<int const,Style>>>::_Orphan_ptr(std::_Container_base12 *, int)
.text$mn:0000733C                 public ?_Orphan_ptr@?$list@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@QBEXAAV12@PAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@2@@Z
.text$mn:0000733C ?_Orphan_ptr@?$list@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@QBEXAAV12@PAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@2@@Z proc near
.text$mn:0000733C                                         ; CODE XREF: std::list<std::pair<int const,Style>,std::allocator<std::pair<int const,Style>>>::clear(void)+12p
.text$mn:0000733C
.text$mn:0000733C var_18          = byte ptr -18h
.text$mn:0000733C var_14          = dword ptr -14h
.text$mn:0000733C var_10          = dword ptr -10h
.text$mn:0000733C var_C           = dword ptr -0Ch
.text$mn:0000733C var_4           = dword ptr -4
.text$mn:0000733C arg_0           = dword ptr  8
.text$mn:0000733C arg_4           = dword ptr  0Ch
.text$mn:0000733C
.text$mn:0000733C                 push    ebp
.text$mn:0000733D                 mov     ebp, esp
.text$mn:0000733F                 push    0FFFFFFFFh
.text$mn:00007341                 push    offset __ehhandler$?_Orphan_ptr@?$list@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@QBEXAAV12@PAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@2@@Z
.text$mn:00007346                 mov     eax, large fs:0
.text$mn:0000734C                 push    eax
.text$mn:0000734D                 sub     esp, 0Ch
.text$mn:00007350                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00007355                 xor     eax, ebp
.text$mn:00007357                 push    eax
.text$mn:00007358                 lea     eax, [ebp+var_C]
.text$mn:0000735B                 mov     large fs:0, eax
.text$mn:00007361                 mov     [ebp+var_14], ecx
.text$mn:00007364                 push    3               ; int
.text$mn:00007366                 lea     ecx, [ebp+var_18] ; this
.text$mn:00007369                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:0000736E                 mov     [ebp+var_4], 0
.text$mn:00007375                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00007378                 call    ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ ; std::_Container_base12::_Getpfirst(void)
.text$mn:0000737D                 mov     [ebp+var_10], eax
.text$mn:00007380                 cmp     [ebp+var_10], 0
.text$mn:00007384                 jz      short loc_73DD
.text$mn:00007386
.text$mn:00007386 loc_7386:                               ; CODE XREF: std::list<std::pair<int const,Style>,std::allocator<std::pair<int const,Style>>>::_Orphan_ptr(std::list<std::pair<int const,Style>,std::allocator<std::pair<int const,Style>>> &,std::_List_node<std::pair<int const,Style>,void *> *):loc_73DBj
.text$mn:00007386                 mov     eax, [ebp+var_10]
.text$mn:00007389                 cmp     dword ptr [eax], 0
.text$mn:0000738C                 jz      short loc_73DD
.text$mn:0000738E                 mov     ecx, [ebp+var_10]
.text$mn:00007391                 mov     edx, [ecx]
.text$mn:00007393                 mov     eax, [ebp+var_14]
.text$mn:00007396                 mov     ecx, [edx+8]
.text$mn:00007399                 cmp     ecx, [eax+4]
.text$mn:0000739C                 jz      short loc_73B1
.text$mn:0000739E                 cmp     [ebp+arg_4], 0
.text$mn:000073A2                 jz      short loc_73C0
.text$mn:000073A4                 mov     edx, [ebp+var_10]
.text$mn:000073A7                 mov     eax, [edx]
.text$mn:000073A9                 mov     ecx, [eax+8]
.text$mn:000073AC                 cmp     ecx, [ebp+arg_4]
.text$mn:000073AF                 jz      short loc_73C0
.text$mn:000073B1
.text$mn:000073B1 loc_73B1:                               ; CODE XREF: std::list<std::pair<int const,Style>,std::allocator<std::pair<int const,Style>>>::_Orphan_ptr(std::list<std::pair<int const,Style>,std::allocator<std::pair<int const,Style>>> &,std::_List_node<std::pair<int const,Style>,void *> *)+60j
.text$mn:000073B1                 mov     edx, [ebp+var_10]
.text$mn:000073B4                 mov     ecx, [edx]      ; this
.text$mn:000073B6                 call    ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext(void)
.text$mn:000073BB                 mov     [ebp+var_10], eax
.text$mn:000073BE                 jmp     short loc_73DB
.text$mn:000073C0 ; ---------------------------------------------------------------------------
.text$mn:000073C0
.text$mn:000073C0 loc_73C0:                               ; CODE XREF: std::list<std::pair<int const,Style>,std::allocator<std::pair<int const,Style>>>::_Orphan_ptr(std::list<std::pair<int const,Style>,std::allocator<std::pair<int const,Style>>> &,std::_List_node<std::pair<int const,Style>,void *> *)+66j
.text$mn:000073C0                                         ; std::list<std::pair<int const,Style>,std::allocator<std::pair<int const,Style>>>::_Orphan_ptr(std::list<std::pair<int const,Style>,std::allocator<std::pair<int const,Style>>> &,std::_List_node<std::pair<int const,Style>,void *> *)+73j
.text$mn:000073C0                 mov     eax, [ebp+var_10]
.text$mn:000073C3                 mov     ecx, [eax]      ; this
.text$mn:000073C5                 call    ?_Clrcont@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Clrcont(void)
.text$mn:000073CA                 mov     ecx, [ebp+var_10]
.text$mn:000073CD                 mov     ecx, [ecx]      ; this
.text$mn:000073CF                 call    ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext(void)
.text$mn:000073D4                 mov     edx, [ebp+var_10]
.text$mn:000073D7                 mov     eax, [eax]
.text$mn:000073D9                 mov     [edx], eax
.text$mn:000073DB
.text$mn:000073DB loc_73DB:                               ; CODE XREF: std::list<std::pair<int const,Style>,std::allocator<std::pair<int const,Style>>>::_Orphan_ptr(std::list<std::pair<int const,Style>,std::allocator<std::pair<int const,Style>>> &,std::_List_node<std::pair<int const,Style>,void *> *)+82j
.text$mn:000073DB                 jmp     short loc_7386
.text$mn:000073DD ; ---------------------------------------------------------------------------
.text$mn:000073DD
.text$mn:000073DD loc_73DD:                               ; CODE XREF: std::list<std::pair<int const,Style>,std::allocator<std::pair<int const,Style>>>::_Orphan_ptr(std::list<std::pair<int const,Style>,std::allocator<std::pair<int const,Style>>> &,std::_List_node<std::pair<int const,Style>,void *> *)+48j
.text$mn:000073DD                                         ; std::list<std::pair<int const,Style>,std::allocator<std::pair<int const,Style>>>::_Orphan_ptr(std::list<std::pair<int const,Style>,std::allocator<std::pair<int const,Style>>> &,std::_List_node<std::pair<int const,Style>,void *> *)+50j
.text$mn:000073DD                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000073E4                 lea     ecx, [ebp+var_18] ; this
.text$mn:000073E7                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:000073EC                 mov     ecx, [ebp+var_C]
.text$mn:000073EF                 mov     large fs:0, ecx
.text$mn:000073F6                 pop     ecx
.text$mn:000073F7                 mov     esp, ebp
.text$mn:000073F9                 pop     ebp
.text$mn:000073FA                 retn    8
.text$mn:000073FA ?_Orphan_ptr@?$list@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@QBEXAAV12@PAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@2@@Z endp
.text$mn:000073FA
.text$mn:000073FA ; ---------------------------------------------------------------------------
.text$mn:000073FD                 align 10h
.text$mn:000073FD _text$mn        ends
.text$mn:000073FD
.text$x:00007400 ; ===========================================================================
.text$x:00007400
.text$x:00007400 ; Segment type: Pure code
.text$x:00007400 ; Segment permissions: Read/Execute
.text$x:00007400 _text$x         segment para public 'CODE' use32
.text$x:00007400                 assume cs:_text$x
.text$x:00007400                 ;org 7400h
.text$x:00007400 ; COMDAT (pick associative to section at 733C)
.text$x:00007400                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00007400
.text$x:00007400 ; =============== S U B R O U T I N E =======================================
.text$x:00007400
.text$x:00007400
.text$x:00007400 __unwindfunclet$?_Orphan_ptr@?$list@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@QBEXAAV12@PAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@2@@Z$0 proc near
.text$x:00007400                                         ; DATA XREF: .xdata$x:0000A5FCo
.text$x:00007400                 lea     ecx, [ebp-18h]  ; this
.text$x:00007403                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:00007403 __unwindfunclet$?_Orphan_ptr@?$list@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@QBEXAAV12@PAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@2@@Z$0 endp
.text$x:00007403
.text$x:00007408
.text$x:00007408 ; =============== S U B R O U T I N E =======================================
.text$x:00007408
.text$x:00007408
.text$x:00007408 __ehhandler$?_Orphan_ptr@?$list@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@QBEXAAV12@PAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@2@@Z proc near
.text$x:00007408                                         ; DATA XREF: std::list<std::pair<int const,Style>,std::allocator<std::pair<int const,Style>>>::_Orphan_ptr(std::list<std::pair<int const,Style>,std::allocator<std::pair<int const,Style>>> &,std::_List_node<std::pair<int const,Style>,void *> *)+5o
.text$x:00007408
.text$x:00007408 arg_4           = dword ptr  8
.text$x:00007408
.text$x:00007408                 mov     edx, [esp+arg_4]
.text$x:0000740C                 lea     eax, [edx+0Ch]
.text$x:0000740F                 mov     ecx, [edx-10h]
.text$x:00007412                 xor     ecx, eax
.text$x:00007414                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00007419                 mov     eax, offset __ehfuncinfo$?_Orphan_ptr@?$list@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@QBEXAAV12@PAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@2@@Z
.text$x:0000741E                 jmp     ___CxxFrameHandler3
.text$x:0000741E __ehhandler$?_Orphan_ptr@?$list@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@QBEXAAV12@PAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@2@@Z endp
.text$x:0000741E
.text$x:0000741E ; ---------------------------------------------------------------------------
.text$x:00007423                 align 4
.text$x:00007423 _text$x         ends
.text$x:00007423
.text$mn:00007424 ; ===========================================================================
.text$mn:00007424
.text$mn:00007424 ; Segment type: Pure code
.text$mn:00007424 ; Segment permissions: Read/Execute
.text$mn:00007424 _text$mn        segment para public 'CODE' use32
.text$mn:00007424                 assume cs:_text$mn
.text$mn:00007424                 ;org 7424h
.text$mn:00007424 ; COMDAT (pick any)
.text$mn:00007424                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007424
.text$mn:00007424 ; =============== S U B R O U T I N E =======================================
.text$mn:00007424
.text$mn:00007424 ; Attributes: bp-based frame
.text$mn:00007424
.text$mn:00007424 ; int __stdcall std::list<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>::_Orphan_ptr(std::_Container_base12 *, int)
.text$mn:00007424                 public ?_Orphan_ptr@?$list@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QBEXAAV12@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@2@@Z
.text$mn:00007424 ?_Orphan_ptr@?$list@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QBEXAAV12@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@2@@Z proc near
.text$mn:00007424                                         ; CODE XREF: std::list<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>::clear(void)+12p
.text$mn:00007424
.text$mn:00007424 var_18          = byte ptr -18h
.text$mn:00007424 var_14          = dword ptr -14h
.text$mn:00007424 var_10          = dword ptr -10h
.text$mn:00007424 var_C           = dword ptr -0Ch
.text$mn:00007424 var_4           = dword ptr -4
.text$mn:00007424 arg_0           = dword ptr  8
.text$mn:00007424 arg_4           = dword ptr  0Ch
.text$mn:00007424
.text$mn:00007424                 push    ebp
.text$mn:00007425                 mov     ebp, esp
.text$mn:00007427                 push    0FFFFFFFFh
.text$mn:00007429                 push    offset __ehhandler$?_Orphan_ptr@?$list@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QBEXAAV12@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@2@@Z
.text$mn:0000742E                 mov     eax, large fs:0
.text$mn:00007434                 push    eax
.text$mn:00007435                 sub     esp, 0Ch
.text$mn:00007438                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000743D                 xor     eax, ebp
.text$mn:0000743F                 push    eax
.text$mn:00007440                 lea     eax, [ebp+var_C]
.text$mn:00007443                 mov     large fs:0, eax
.text$mn:00007449                 mov     [ebp+var_14], ecx
.text$mn:0000744C                 push    3               ; int
.text$mn:0000744E                 lea     ecx, [ebp+var_18] ; this
.text$mn:00007451                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:00007456                 mov     [ebp+var_4], 0
.text$mn:0000745D                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00007460                 call    ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ ; std::_Container_base12::_Getpfirst(void)
.text$mn:00007465                 mov     [ebp+var_10], eax
.text$mn:00007468                 cmp     [ebp+var_10], 0
.text$mn:0000746C                 jz      short loc_74C5
.text$mn:0000746E
.text$mn:0000746E loc_746E:                               ; CODE XREF: std::list<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>::_Orphan_ptr(std::list<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>> &,std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *):loc_74C3j
.text$mn:0000746E                 mov     eax, [ebp+var_10]
.text$mn:00007471                 cmp     dword ptr [eax], 0
.text$mn:00007474                 jz      short loc_74C5
.text$mn:00007476                 mov     ecx, [ebp+var_10]
.text$mn:00007479                 mov     edx, [ecx]
.text$mn:0000747B                 mov     eax, [ebp+var_14]
.text$mn:0000747E                 mov     ecx, [edx+8]
.text$mn:00007481                 cmp     ecx, [eax+4]
.text$mn:00007484                 jz      short loc_7499
.text$mn:00007486                 cmp     [ebp+arg_4], 0
.text$mn:0000748A                 jz      short loc_74A8
.text$mn:0000748C                 mov     edx, [ebp+var_10]
.text$mn:0000748F                 mov     eax, [edx]
.text$mn:00007491                 mov     ecx, [eax+8]
.text$mn:00007494                 cmp     ecx, [ebp+arg_4]
.text$mn:00007497                 jz      short loc_74A8
.text$mn:00007499
.text$mn:00007499 loc_7499:                               ; CODE XREF: std::list<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>::_Orphan_ptr(std::list<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>> &,std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *)+60j
.text$mn:00007499                 mov     edx, [ebp+var_10]
.text$mn:0000749C                 mov     ecx, [edx]      ; this
.text$mn:0000749E                 call    ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext(void)
.text$mn:000074A3                 mov     [ebp+var_10], eax
.text$mn:000074A6                 jmp     short loc_74C3
.text$mn:000074A8 ; ---------------------------------------------------------------------------
.text$mn:000074A8
.text$mn:000074A8 loc_74A8:                               ; CODE XREF: std::list<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>::_Orphan_ptr(std::list<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>> &,std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *)+66j
.text$mn:000074A8                                         ; std::list<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>::_Orphan_ptr(std::list<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>> &,std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *)+73j
.text$mn:000074A8                 mov     eax, [ebp+var_10]
.text$mn:000074AB                 mov     ecx, [eax]      ; this
.text$mn:000074AD                 call    ?_Clrcont@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Clrcont(void)
.text$mn:000074B2                 mov     ecx, [ebp+var_10]
.text$mn:000074B5                 mov     ecx, [ecx]      ; this
.text$mn:000074B7                 call    ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext(void)
.text$mn:000074BC                 mov     edx, [ebp+var_10]
.text$mn:000074BF                 mov     eax, [eax]
.text$mn:000074C1                 mov     [edx], eax
.text$mn:000074C3
.text$mn:000074C3 loc_74C3:                               ; CODE XREF: std::list<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>::_Orphan_ptr(std::list<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>> &,std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *)+82j
.text$mn:000074C3                 jmp     short loc_746E
.text$mn:000074C5 ; ---------------------------------------------------------------------------
.text$mn:000074C5
.text$mn:000074C5 loc_74C5:                               ; CODE XREF: std::list<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>::_Orphan_ptr(std::list<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>> &,std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *)+48j
.text$mn:000074C5                                         ; std::list<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>::_Orphan_ptr(std::list<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>> &,std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *)+50j
.text$mn:000074C5                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000074CC                 lea     ecx, [ebp+var_18] ; this
.text$mn:000074CF                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:000074D4                 mov     ecx, [ebp+var_C]
.text$mn:000074D7                 mov     large fs:0, ecx
.text$mn:000074DE                 pop     ecx
.text$mn:000074DF                 mov     esp, ebp
.text$mn:000074E1                 pop     ebp
.text$mn:000074E2                 retn    8
.text$mn:000074E2 ?_Orphan_ptr@?$list@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QBEXAAV12@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@2@@Z endp
.text$mn:000074E2
.text$mn:000074E2 ; ---------------------------------------------------------------------------
.text$mn:000074E5                 align 4
.text$mn:000074E5 _text$mn        ends
.text$mn:000074E5
.text$x:000074E8 ; ===========================================================================
.text$x:000074E8
.text$x:000074E8 ; Segment type: Pure code
.text$x:000074E8 ; Segment permissions: Read/Execute
.text$x:000074E8 _text$x         segment para public 'CODE' use32
.text$x:000074E8                 assume cs:_text$x
.text$x:000074E8                 ;org 74E8h
.text$x:000074E8 ; COMDAT (pick associative to section at 7424)
.text$x:000074E8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000074E8
.text$x:000074E8 ; =============== S U B R O U T I N E =======================================
.text$x:000074E8
.text$x:000074E8
.text$x:000074E8 __unwindfunclet$?_Orphan_ptr@?$list@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QBEXAAV12@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@2@@Z$0 proc near
.text$x:000074E8                                         ; DATA XREF: .xdata$x:00009FDCo
.text$x:000074E8                 lea     ecx, [ebp-18h]  ; this
.text$x:000074EB                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:000074EB __unwindfunclet$?_Orphan_ptr@?$list@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QBEXAAV12@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@2@@Z$0 endp
.text$x:000074EB
.text$x:000074F0
.text$x:000074F0 ; =============== S U B R O U T I N E =======================================
.text$x:000074F0
.text$x:000074F0
.text$x:000074F0 __ehhandler$?_Orphan_ptr@?$list@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QBEXAAV12@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@2@@Z proc near
.text$x:000074F0                                         ; DATA XREF: std::list<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>::_Orphan_ptr(std::list<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>> &,std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *)+5o
.text$x:000074F0
.text$x:000074F0 arg_4           = dword ptr  8
.text$x:000074F0
.text$x:000074F0                 mov     edx, [esp+arg_4]
.text$x:000074F4                 lea     eax, [edx+0Ch]
.text$x:000074F7                 mov     ecx, [edx-10h]
.text$x:000074FA                 xor     ecx, eax
.text$x:000074FC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00007501                 mov     eax, offset __ehfuncinfo$?_Orphan_ptr@?$list@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QBEXAAV12@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@2@@Z
.text$x:00007506                 jmp     ___CxxFrameHandler3
.text$x:00007506 __ehhandler$?_Orphan_ptr@?$list@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QBEXAAV12@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@2@@Z endp
.text$x:00007506
.text$x:00007506 ; ---------------------------------------------------------------------------
.text$x:0000750B                 align 4
.text$x:0000750B _text$x         ends
.text$x:0000750B
.text$mn:0000750C ; ===========================================================================
.text$mn:0000750C
.text$mn:0000750C ; Segment type: Pure code
.text$mn:0000750C ; Segment permissions: Read/Execute
.text$mn:0000750C _text$mn        segment para public 'CODE' use32
.text$mn:0000750C                 assume cs:_text$mn
.text$mn:0000750C                 ;org 750Ch
.text$mn:0000750C ; COMDAT (pick any)
.text$mn:0000750C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000750C
.text$mn:0000750C ; =============== S U B R O U T I N E =======================================
.text$mn:0000750C
.text$mn:0000750C ; Attributes: bp-based frame
.text$mn:0000750C
.text$mn:0000750C ; protected: void __thiscall std::vector<class ScintillaEditView *, class std::allocator<class ScintillaEditView *>>::_Orphan_range(class ScintillaEditView * *, class ScintillaEditView * *)const
.text$mn:0000750C                 public ?_Orphan_range@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@IBEXPAPAVScintillaEditView@@0@Z
.text$mn:0000750C ?_Orphan_range@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@IBEXPAPAVScintillaEditView@@0@Z proc near
.text$mn:0000750C                                         ; CODE XREF: std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::erase(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>)+B1p
.text$mn:0000750C                                         ; std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::push_back(ScintillaEditView * const &)+66p ...
.text$mn:0000750C
.text$mn:0000750C var_18          = byte ptr -18h
.text$mn:0000750C var_14          = dword ptr -14h
.text$mn:0000750C var_10          = dword ptr -10h
.text$mn:0000750C var_C           = dword ptr -0Ch
.text$mn:0000750C var_4           = dword ptr -4
.text$mn:0000750C arg_0           = dword ptr  8
.text$mn:0000750C arg_4           = dword ptr  0Ch
.text$mn:0000750C
.text$mn:0000750C                 push    ebp
.text$mn:0000750D                 mov     ebp, esp
.text$mn:0000750F                 push    0FFFFFFFFh
.text$mn:00007511                 push    offset __ehhandler$?_Orphan_range@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@IBEXPAPAVScintillaEditView@@0@Z
.text$mn:00007516                 mov     eax, large fs:0
.text$mn:0000751C                 push    eax
.text$mn:0000751D                 sub     esp, 0Ch
.text$mn:00007520                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00007525                 xor     eax, ebp
.text$mn:00007527                 push    eax
.text$mn:00007528                 lea     eax, [ebp+var_C]
.text$mn:0000752B                 mov     large fs:0, eax
.text$mn:00007531                 mov     [ebp+var_14], ecx
.text$mn:00007534                 push    3               ; int
.text$mn:00007536                 lea     ecx, [ebp+var_18] ; this
.text$mn:00007539                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:0000753E                 mov     [ebp+var_4], 0
.text$mn:00007545                 mov     ecx, [ebp+var_14] ; this
.text$mn:00007548                 call    ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ ; std::_Container_base12::_Getpfirst(void)
.text$mn:0000754D                 mov     [ebp+var_10], eax
.text$mn:00007550                 cmp     [ebp+var_10], 0
.text$mn:00007554                 jz      short loc_75A4
.text$mn:00007556
.text$mn:00007556 loc_7556:                               ; CODE XREF: std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::_Orphan_range(ScintillaEditView * *,ScintillaEditView * *):loc_75A2j
.text$mn:00007556                 mov     eax, [ebp+var_10]
.text$mn:00007559                 cmp     dword ptr [eax], 0
.text$mn:0000755C                 jz      short loc_75A4
.text$mn:0000755E                 mov     ecx, [ebp+var_10]
.text$mn:00007561                 mov     edx, [ecx]
.text$mn:00007563                 mov     eax, [edx+8]
.text$mn:00007566                 cmp     eax, [ebp+arg_0]
.text$mn:00007569                 jb      short loc_7578
.text$mn:0000756B                 mov     ecx, [ebp+var_10]
.text$mn:0000756E                 mov     edx, [ecx]
.text$mn:00007570                 mov     eax, [ebp+arg_4]
.text$mn:00007573                 cmp     eax, [edx+8]
.text$mn:00007576                 jnb     short loc_7587
.text$mn:00007578
.text$mn:00007578 loc_7578:                               ; CODE XREF: std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::_Orphan_range(ScintillaEditView * *,ScintillaEditView * *)+5Dj
.text$mn:00007578                 mov     ecx, [ebp+var_10]
.text$mn:0000757B                 mov     ecx, [ecx]      ; this
.text$mn:0000757D                 call    ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext(void)
.text$mn:00007582                 mov     [ebp+var_10], eax
.text$mn:00007585                 jmp     short loc_75A2
.text$mn:00007587 ; ---------------------------------------------------------------------------
.text$mn:00007587
.text$mn:00007587 loc_7587:                               ; CODE XREF: std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::_Orphan_range(ScintillaEditView * *,ScintillaEditView * *)+6Aj
.text$mn:00007587                 mov     edx, [ebp+var_10]
.text$mn:0000758A                 mov     ecx, [edx]      ; this
.text$mn:0000758C                 call    ?_Clrcont@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Clrcont(void)
.text$mn:00007591                 mov     eax, [ebp+var_10]
.text$mn:00007594                 mov     ecx, [eax]      ; this
.text$mn:00007596                 call    ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext(void)
.text$mn:0000759B                 mov     ecx, [ebp+var_10]
.text$mn:0000759E                 mov     edx, [eax]
.text$mn:000075A0                 mov     [ecx], edx
.text$mn:000075A2
.text$mn:000075A2 loc_75A2:                               ; CODE XREF: std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::_Orphan_range(ScintillaEditView * *,ScintillaEditView * *)+79j
.text$mn:000075A2                 jmp     short loc_7556
.text$mn:000075A4 ; ---------------------------------------------------------------------------
.text$mn:000075A4
.text$mn:000075A4 loc_75A4:                               ; CODE XREF: std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::_Orphan_range(ScintillaEditView * *,ScintillaEditView * *)+48j
.text$mn:000075A4                                         ; std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::_Orphan_range(ScintillaEditView * *,ScintillaEditView * *)+50j
.text$mn:000075A4                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000075AB                 lea     ecx, [ebp+var_18] ; this
.text$mn:000075AE                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:000075B3                 mov     ecx, [ebp+var_C]
.text$mn:000075B6                 mov     large fs:0, ecx
.text$mn:000075BD                 pop     ecx
.text$mn:000075BE                 mov     esp, ebp
.text$mn:000075C0                 pop     ebp
.text$mn:000075C1                 retn    8
.text$mn:000075C1 ?_Orphan_range@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@IBEXPAPAVScintillaEditView@@0@Z endp
.text$mn:000075C1
.text$mn:000075C1 _text$mn        ends
.text$mn:000075C1
.text$x:000075C4 ; ===========================================================================
.text$x:000075C4
.text$x:000075C4 ; Segment type: Pure code
.text$x:000075C4 ; Segment permissions: Read/Execute
.text$x:000075C4 _text$x         segment para public 'CODE' use32
.text$x:000075C4                 assume cs:_text$x
.text$x:000075C4                 ;org 75C4h
.text$x:000075C4 ; COMDAT (pick associative to section at 750C)
.text$x:000075C4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000075C4
.text$x:000075C4 ; =============== S U B R O U T I N E =======================================
.text$x:000075C4
.text$x:000075C4
.text$x:000075C4 __unwindfunclet$?_Orphan_range@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@IBEXPAPAVScintillaEditView@@0@Z$0 proc near
.text$x:000075C4                                         ; DATA XREF: .xdata$x:00009AD4o
.text$x:000075C4                 lea     ecx, [ebp-18h]  ; this
.text$x:000075C7                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:000075C7 __unwindfunclet$?_Orphan_range@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@IBEXPAPAVScintillaEditView@@0@Z$0 endp
.text$x:000075C7
.text$x:000075CC
.text$x:000075CC ; =============== S U B R O U T I N E =======================================
.text$x:000075CC
.text$x:000075CC
.text$x:000075CC __ehhandler$?_Orphan_range@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@IBEXPAPAVScintillaEditView@@0@Z proc near
.text$x:000075CC                                         ; DATA XREF: std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::_Orphan_range(ScintillaEditView * *,ScintillaEditView * *)+5o
.text$x:000075CC
.text$x:000075CC arg_4           = dword ptr  8
.text$x:000075CC
.text$x:000075CC                 mov     edx, [esp+arg_4]
.text$x:000075D0                 lea     eax, [edx+0Ch]
.text$x:000075D3                 mov     ecx, [edx-10h]
.text$x:000075D6                 xor     ecx, eax
.text$x:000075D8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000075DD                 mov     eax, offset __ehfuncinfo$?_Orphan_range@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@IBEXPAPAVScintillaEditView@@0@Z
.text$x:000075E2                 jmp     ___CxxFrameHandler3
.text$x:000075E2 __ehhandler$?_Orphan_range@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@IBEXPAPAVScintillaEditView@@0@Z endp
.text$x:000075E2
.text$x:000075E2 ; ---------------------------------------------------------------------------
.text$x:000075E7                 align 4
.text$x:000075E7 _text$x         ends
.text$x:000075E7
.text$mn:000075E8 ; ===========================================================================
.text$mn:000075E8
.text$mn:000075E8 ; Segment type: Pure code
.text$mn:000075E8 ; Segment permissions: Read/Execute
.text$mn:000075E8 _text$mn        segment para public 'CODE' use32
.text$mn:000075E8                 assume cs:_text$mn
.text$mn:000075E8                 ;org 75E8h
.text$mn:000075E8 ; COMDAT (pick any)
.text$mn:000075E8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000075E8
.text$mn:000075E8 ; =============== S U B R O U T I N E =======================================
.text$mn:000075E8
.text$mn:000075E8 ; Attributes: bp-based frame
.text$mn:000075E8
.text$mn:000075E8 ; protected: void __thiscall std::vector<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>, struct std::_Wrap_alloc<class std::allocator<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>>>>::_Orphan_range(class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>> *, class std::_List_unchecked_iterator<c
.text$mn:000075E8                 public ?_Orphan_range@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IBEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@0@Z
.text$mn:000075E8 ?_Orphan_range@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IBEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@0@Z proc near
.text$mn:000075E8                                         ; CODE XREF: ?_Insert_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CB
.text$mn:000075E8                                         ; ?_Insert_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@s
.text$mn:000075E8
.text$mn:000075E8 var_18          = byte ptr -18h
.text$mn:000075E8 var_14          = dword ptr -14h
.text$mn:000075E8 var_10          = dword ptr -10h
.text$mn:000075E8 var_C           = dword ptr -0Ch
.text$mn:000075E8 var_4           = dword ptr -4
.text$mn:000075E8 arg_0           = dword ptr  8
.text$mn:000075E8 arg_4           = dword ptr  0Ch
.text$mn:000075E8
.text$mn:000075E8                 push    ebp
.text$mn:000075E9                 mov     ebp, esp
.text$mn:000075EB                 push    0FFFFFFFFh
.text$mn:000075ED                 push    offset __ehhandler$?_Orphan_range@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IBEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@0@Z
.text$mn:000075F2                 mov     eax, large fs:0
.text$mn:000075F8                 push    eax
.text$mn:000075F9                 sub     esp, 0Ch
.text$mn:000075FC                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00007601                 xor     eax, ebp
.text$mn:00007603                 push    eax
.text$mn:00007604                 lea     eax, [ebp+var_C]
.text$mn:00007607                 mov     large fs:0, eax
.text$mn:0000760D                 mov     [ebp+var_14], ecx
.text$mn:00007610                 push    3               ; int
.text$mn:00007612                 lea     ecx, [ebp+var_18] ; this
.text$mn:00007615                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:0000761A                 mov     [ebp+var_4], 0
.text$mn:00007621                 mov     ecx, [ebp+var_14] ; this
.text$mn:00007624                 call    ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ ; std::_Container_base12::_Getpfirst(void)
.text$mn:00007629                 mov     [ebp+var_10], eax
.text$mn:0000762C                 cmp     [ebp+var_10], 0
.text$mn:00007630                 jz      short loc_7680
.text$mn:00007632
.text$mn:00007632 loc_7632:                               ; CODE XREF: std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::_Orphan_range(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *):loc_767Ej
.text$mn:00007632                 mov     eax, [ebp+var_10]
.text$mn:00007635                 cmp     dword ptr [eax], 0
.text$mn:00007638                 jz      short loc_7680
.text$mn:0000763A                 mov     ecx, [ebp+var_10]
.text$mn:0000763D                 mov     edx, [ecx]
.text$mn:0000763F                 mov     eax, [edx+8]
.text$mn:00007642                 cmp     eax, [ebp+arg_0]
.text$mn:00007645                 jb      short loc_7654
.text$mn:00007647                 mov     ecx, [ebp+var_10]
.text$mn:0000764A                 mov     edx, [ecx]
.text$mn:0000764C                 mov     eax, [ebp+arg_4]
.text$mn:0000764F                 cmp     eax, [edx+8]
.text$mn:00007652                 jnb     short loc_7663
.text$mn:00007654
.text$mn:00007654 loc_7654:                               ; CODE XREF: std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::_Orphan_range(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *)+5Dj
.text$mn:00007654                 mov     ecx, [ebp+var_10]
.text$mn:00007657                 mov     ecx, [ecx]      ; this
.text$mn:00007659                 call    ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext(void)
.text$mn:0000765E                 mov     [ebp+var_10], eax
.text$mn:00007661                 jmp     short loc_767E
.text$mn:00007663 ; ---------------------------------------------------------------------------
.text$mn:00007663
.text$mn:00007663 loc_7663:                               ; CODE XREF: std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::_Orphan_range(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *)+6Aj
.text$mn:00007663                 mov     edx, [ebp+var_10]
.text$mn:00007666                 mov     ecx, [edx]      ; this
.text$mn:00007668                 call    ?_Clrcont@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Clrcont(void)
.text$mn:0000766D                 mov     eax, [ebp+var_10]
.text$mn:00007670                 mov     ecx, [eax]      ; this
.text$mn:00007672                 call    ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext(void)
.text$mn:00007677                 mov     ecx, [ebp+var_10]
.text$mn:0000767A                 mov     edx, [eax]
.text$mn:0000767C                 mov     [ecx], edx
.text$mn:0000767E
.text$mn:0000767E loc_767E:                               ; CODE XREF: std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::_Orphan_range(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *)+79j
.text$mn:0000767E                 jmp     short loc_7632
.text$mn:00007680 ; ---------------------------------------------------------------------------
.text$mn:00007680
.text$mn:00007680 loc_7680:                               ; CODE XREF: std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::_Orphan_range(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *)+48j
.text$mn:00007680                                         ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::_Orphan_range(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *)+50j
.text$mn:00007680                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00007687                 lea     ecx, [ebp+var_18] ; this
.text$mn:0000768A                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:0000768F                 mov     ecx, [ebp+var_C]
.text$mn:00007692                 mov     large fs:0, ecx
.text$mn:00007699                 pop     ecx
.text$mn:0000769A                 mov     esp, ebp
.text$mn:0000769C                 pop     ebp
.text$mn:0000769D                 retn    8
.text$mn:0000769D ?_Orphan_range@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IBEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@0@Z endp
.text$mn:0000769D
.text$mn:0000769D _text$mn        ends
.text$mn:0000769D
.text$x:000076A0 ; ===========================================================================
.text$x:000076A0
.text$x:000076A0 ; Segment type: Pure code
.text$x:000076A0 ; Segment permissions: Read/Execute
.text$x:000076A0 _text$x         segment para public 'CODE' use32
.text$x:000076A0                 assume cs:_text$x
.text$x:000076A0                 ;org 76A0h
.text$x:000076A0 ; COMDAT (pick associative to section at 75E8)
.text$x:000076A0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000076A0
.text$x:000076A0 ; =============== S U B R O U T I N E =======================================
.text$x:000076A0
.text$x:000076A0
.text$x:000076A0 __unwindfunclet$?_Orphan_range@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IBEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@0@Z$0 proc near
.text$x:000076A0                                         ; DATA XREF: .xdata$x:0000A310o
.text$x:000076A0                 lea     ecx, [ebp-18h]  ; this
.text$x:000076A3                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:000076A3 __unwindfunclet$?_Orphan_range@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IBEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@0@Z$0 endp
.text$x:000076A3
.text$x:000076A8
.text$x:000076A8 ; =============== S U B R O U T I N E =======================================
.text$x:000076A8
.text$x:000076A8
.text$x:000076A8 __ehhandler$?_Orphan_range@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IBEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@0@Z proc near
.text$x:000076A8                                         ; DATA XREF: std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::_Orphan_range(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *)+5o
.text$x:000076A8
.text$x:000076A8 arg_4           = dword ptr  8
.text$x:000076A8
.text$x:000076A8                 mov     edx, [esp+arg_4]
.text$x:000076AC                 lea     eax, [edx+0Ch]
.text$x:000076AF                 mov     ecx, [edx-10h]
.text$x:000076B2                 xor     ecx, eax
.text$x:000076B4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000076B9                 mov     eax, offset __ehfuncinfo$?_Orphan_range@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IBEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@0@Z
.text$x:000076BE                 jmp     ___CxxFrameHandler3
.text$x:000076BE __ehhandler$?_Orphan_range@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IBEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@0@Z endp
.text$x:000076BE
.text$x:000076BE ; ---------------------------------------------------------------------------
.text$x:000076C3                 align 4
.text$x:000076C3 _text$x         ends
.text$x:000076C3
.text$mn:000076C4 ; ===========================================================================
.text$mn:000076C4
.text$mn:000076C4 ; Segment type: Pure code
.text$mn:000076C4 ; Segment permissions: Read/Execute
.text$mn:000076C4 _text$mn        segment para public 'CODE' use32
.text$mn:000076C4                 assume cs:_text$mn
.text$mn:000076C4                 ;org 76C4h
.text$mn:000076C4 ; COMDAT (pick any)
.text$mn:000076C4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000076C4
.text$mn:000076C4 ; =============== S U B R O U T I N E =======================================
.text$mn:000076C4
.text$mn:000076C4 ; Attributes: bp-based frame
.text$mn:000076C4
.text$mn:000076C4 ; public: static struct std::_List_node<struct std::pair<int const, struct Style>, void *> * & __cdecl std::_List_val<struct std::_List_simple_types<struct std::pair<int const, struct Style>>>::_Prevnode(struct std::_List_node<struct std::pair<int const, struct Style>, void *> *)
.text$mn:000076C4                 public ?_Prevnode@?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@SAAAPAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@2@PAU32@@Z
.text$mn:000076C4 ?_Prevnode@?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@SAAAPAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@2@PAU32@@Z proc near
.text$mn:000076C4                                         ; CODE XREF: std::_List_alloc<0,std::_List_base_types<std::pair<int const,Style>,std::allocator<std::pair<int const,Style>>>>::_Freeheadnode(std::_List_node<std::pair<int const,Style>,void *> *)+36p
.text$mn:000076C4                                         ; std::_List_buy<std::pair<int const,Style>,std::allocator<std::pair<int const,Style>>>::_Freenode(std::_List_node<std::pair<int const,Style>,void *> *)+36p ...
.text$mn:000076C4
.text$mn:000076C4 arg_0           = dword ptr  8
.text$mn:000076C4
.text$mn:000076C4                 push    ebp
.text$mn:000076C5                 mov     ebp, esp
.text$mn:000076C7                 mov     eax, [ebp+arg_0]
.text$mn:000076CA                 add     eax, 4
.text$mn:000076CD                 pop     ebp
.text$mn:000076CE                 retn
.text$mn:000076CE ?_Prevnode@?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@SAAAPAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@2@PAU32@@Z endp
.text$mn:000076CE
.text$mn:000076CE ; ---------------------------------------------------------------------------
.text$mn:000076CF                 align 10h
.text$mn:000076CF _text$mn        ends
.text$mn:000076CF
.text$mn:000076D0 ; ===========================================================================
.text$mn:000076D0
.text$mn:000076D0 ; Segment type: Pure code
.text$mn:000076D0 ; Segment permissions: Read/Execute
.text$mn:000076D0 _text$mn        segment para public 'CODE' use32
.text$mn:000076D0                 assume cs:_text$mn
.text$mn:000076D0                 ;org 76D0h
.text$mn:000076D0 ; COMDAT (pick any)
.text$mn:000076D0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000076D0
.text$mn:000076D0 ; =============== S U B R O U T I N E =======================================
.text$mn:000076D0
.text$mn:000076D0 ; Attributes: bp-based frame
.text$mn:000076D0
.text$mn:000076D0 ; public: static struct std::_List_node<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>, void *> * & __cdecl std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>::_Prevnode(struct std::_List_node<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>, void *> *)
.text$mn:000076D0                 public ?_Prevnode@?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@SAAAPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@2@PAU32@@Z
.text$mn:000076D0 ?_Prevnode@?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@SAAAPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@2@PAU32@@Z proc near
.text$mn:000076D0                                         ; CODE XREF: std::_List_alloc<0,std::_List_base_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::_Buynode0(std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *,std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *)+95p
.text$mn:000076D0                                         ; std::_List_alloc<0,std::_List_base_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::_Freeheadnode(std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *)+36p ...
.text$mn:000076D0
.text$mn:000076D0 arg_0           = dword ptr  8
.text$mn:000076D0
.text$mn:000076D0                 push    ebp
.text$mn:000076D1                 mov     ebp, esp
.text$mn:000076D3                 mov     eax, [ebp+arg_0]
.text$mn:000076D6                 add     eax, 4
.text$mn:000076D9                 pop     ebp
.text$mn:000076DA                 retn
.text$mn:000076DA ?_Prevnode@?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@SAAAPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@2@PAU32@@Z endp
.text$mn:000076DA
.text$mn:000076DA ; ---------------------------------------------------------------------------
.text$mn:000076DB                 align 4
.text$mn:000076DB _text$mn        ends
.text$mn:000076DB
.text$mn:000076DC ; ===========================================================================
.text$mn:000076DC
.text$mn:000076DC ; Segment type: Pure code
.text$mn:000076DC ; Segment permissions: Read/Execute
.text$mn:000076DC _text$mn        segment para public 'CODE' use32
.text$mn:000076DC                 assume cs:_text$mn
.text$mn:000076DC                 ;org 76DCh
.text$mn:000076DC ; COMDAT (pick any)
.text$mn:000076DC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000076DC
.text$mn:000076DC ; =============== S U B R O U T I N E =======================================
.text$mn:000076DC
.text$mn:000076DC ; Attributes: bp-based frame
.text$mn:000076DC
.text$mn:000076DC ; protected: void __thiscall std::vector<class ScintillaEditView *, class std::allocator<class ScintillaEditView *>>::_Reallocate(unsigned int)
.text$mn:000076DC                 public ?_Reallocate@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@IAEXI@Z
.text$mn:000076DC ?_Reallocate@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@IAEXI@Z proc near
.text$mn:000076DC                                         ; CODE XREF: std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::_Reserve(uint)+4Ep
.text$mn:000076DC
.text$mn:000076DC var_20          = dword ptr -20h
.text$mn:000076DC var_1C          = dword ptr -1Ch
.text$mn:000076DC var_18          = dword ptr -18h
.text$mn:000076DC var_13          = byte ptr -13h
.text$mn:000076DC var_11          = byte ptr -11h
.text$mn:000076DC var_10          = dword ptr -10h
.text$mn:000076DC var_C           = dword ptr -0Ch
.text$mn:000076DC var_4           = dword ptr -4
.text$mn:000076DC arg_0           = dword ptr  8
.text$mn:000076DC
.text$mn:000076DC ; FUNCTION CHUNK AT .text$mn:00007772 SIZE 00000009 BYTES
.text$mn:000076DC ; FUNCTION CHUNK AT .text$mn:00007782 SIZE 00000097 BYTES
.text$mn:000076DC
.text$mn:000076DC                 push    ebp
.text$mn:000076DD                 mov     ebp, esp
.text$mn:000076DF                 push    0FFFFFFFFh
.text$mn:000076E1                 push    offset __ehhandler$?_Reallocate@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@IAEXI@Z
.text$mn:000076E6                 mov     eax, large fs:0
.text$mn:000076EC                 push    eax
.text$mn:000076ED                 push    ecx
.text$mn:000076EE                 sub     esp, 10h
.text$mn:000076F1                 push    ebx
.text$mn:000076F2                 push    esi
.text$mn:000076F3                 push    edi
.text$mn:000076F4                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000076F9                 xor     eax, ebp
.text$mn:000076FB                 push    eax
.text$mn:000076FC                 lea     eax, [ebp+var_C]
.text$mn:000076FF                 mov     large fs:0, eax
.text$mn:00007705                 mov     [ebp+var_10], esp
.text$mn:00007708                 mov     [ebp+var_18], ecx
.text$mn:0000770B                 mov     eax, [ebp+arg_0]
.text$mn:0000770E                 push    eax
.text$mn:0000770F                 lea     ecx, [ebp+var_11]
.text$mn:00007712                 push    ecx
.text$mn:00007713                 mov     ecx, [ebp+var_18]
.text$mn:00007716                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVScintillaEditView@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<ScintillaEditView *,std::allocator<ScintillaEditView *>>>::_Getal(void)
.text$mn:0000771B                 mov     ecx, eax
.text$mn:0000771D                 call    ?allocate@?$_Wrap_alloc@V?$allocator@PAVScintillaEditView@@@std@@@std@@QAEPAPAVScintillaEditView@@I@Z ; std::_Wrap_alloc<std::allocator<ScintillaEditView *>>::allocate(uint)
.text$mn:00007722                 mov     [ebp+var_1C], eax
.text$mn:00007725                 mov     [ebp+var_4], 0
.text$mn:0000772C                 mov     edx, [ebp+var_1C]
.text$mn:0000772F                 push    edx
.text$mn:00007730                 mov     eax, [ebp+var_18]
.text$mn:00007733                 mov     ecx, [eax+8]
.text$mn:00007736                 push    ecx
.text$mn:00007737                 mov     edx, [ebp+var_18]
.text$mn:0000773A                 mov     eax, [edx+4]
.text$mn:0000773D                 push    eax
.text$mn:0000773E                 mov     ecx, [ebp+var_18]
.text$mn:00007741                 call    ??$_Umove@PAPAVScintillaEditView@@@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@IAEPAPAVScintillaEditView@@PAPAV2@00@Z ; std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::_Umove<ScintillaEditView * *>(ScintillaEditView * *,ScintillaEditView * *,ScintillaEditView * *)
.text$mn:00007746                 jmp     short loc_7772
.text$mn:00007746 ?_Reallocate@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@IAEXI@Z endp
.text$mn:00007746
.text$mn:00007748
.text$mn:00007748 ; =============== S U B R O U T I N E =======================================
.text$mn:00007748
.text$mn:00007748 ; Attributes: noreturn
.text$mn:00007748
.text$mn:00007748 __catch$?_Reallocate@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@IAEXI@Z$0 proc near
.text$mn:00007748                                         ; DATA XREF: .xdata$x:00009A84o
.text$mn:00007748                 mov     ecx, [ebp+8]
.text$mn:0000774B                 push    ecx             ; int
.text$mn:0000774C                 mov     edx, [ebp-1Ch]
.text$mn:0000774F                 push    edx             ; void *
.text$mn:00007750                 lea     eax, [ebp-12h]
.text$mn:00007753                 push    eax
.text$mn:00007754                 mov     ecx, [ebp-18h]
.text$mn:00007757                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVScintillaEditView@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<ScintillaEditView *,std::allocator<ScintillaEditView *>>>::_Getal(void)
.text$mn:0000775C                 mov     ecx, eax
.text$mn:0000775E                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@PAVScintillaEditView@@@std@@@std@@QAEXPAPAVScintillaEditView@@I@Z ; std::_Wrap_alloc<std::allocator<ScintillaEditView *>>::deallocate(ScintillaEditView * *,uint)
.text$mn:00007763                 push    0
.text$mn:00007765                 push    0
.text$mn:00007767                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00007767 __catch$?_Reallocate@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@IAEXI@Z$0 endp
.text$mn:00007767
.text$mn:0000776C ; ---------------------------------------------------------------------------
.text$mn:0000776C                 mov     eax, offset $LN8_0
.text$mn:00007771                 retn
.text$mn:00007772 ; ---------------------------------------------------------------------------
.text$mn:00007772 ; START OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@IAEXI@Z
.text$mn:00007772
.text$mn:00007772 loc_7772:                               ; CODE XREF: std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::_Reallocate(uint)+6Aj
.text$mn:00007772                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00007779                 jmp     short loc_7782
.text$mn:00007779 ; END OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@IAEXI@Z
.text$mn:0000777B
.text$mn:0000777B ; =============== S U B R O U T I N E =======================================
.text$mn:0000777B
.text$mn:0000777B
.text$mn:0000777B $LN8_0          proc near               ; DATA XREF: .text$mn:0000776Co
.text$mn:0000777B                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:0000777B $LN8_0          endp ; sp-analysis failed
.text$mn:0000777B
.text$mn:00007782 ; START OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@IAEXI@Z
.text$mn:00007782
.text$mn:00007782 loc_7782:                               ; CODE XREF: std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::_Reallocate(uint)+9Dj
.text$mn:00007782                 mov     ecx, [ebp+var_18]
.text$mn:00007785                 call    ?size@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@QBEIXZ ; std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::size(void)
.text$mn:0000778A                 mov     [ebp+var_20], eax
.text$mn:0000778D                 mov     ecx, [ebp+var_18]
.text$mn:00007790                 cmp     dword ptr [ecx+4], 0
.text$mn:00007794                 jz      short loc_77D6
.text$mn:00007796                 mov     edx, [ebp+var_18]
.text$mn:00007799                 mov     eax, [edx+8]
.text$mn:0000779C                 push    eax
.text$mn:0000779D                 mov     ecx, [ebp+var_18]
.text$mn:000077A0                 mov     edx, [ecx+4]
.text$mn:000077A3                 push    edx
.text$mn:000077A4                 mov     ecx, [ebp+var_18]
.text$mn:000077A7                 call    ?_Destroy@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@IAEXPAPAVScintillaEditView@@0@Z ; std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::_Destroy(ScintillaEditView * *,ScintillaEditView * *)
.text$mn:000077AC                 mov     eax, [ebp+var_18]
.text$mn:000077AF                 mov     ecx, [ebp+var_18]
.text$mn:000077B2                 mov     edx, [eax+0Ch]
.text$mn:000077B5                 sub     edx, [ecx+4]
.text$mn:000077B8                 sar     edx, 2
.text$mn:000077BB                 push    edx             ; int
.text$mn:000077BC                 mov     eax, [ebp+var_18]
.text$mn:000077BF                 mov     ecx, [eax+4]
.text$mn:000077C2                 push    ecx             ; void *
.text$mn:000077C3                 lea     edx, [ebp+var_13]
.text$mn:000077C6                 push    edx
.text$mn:000077C7                 mov     ecx, [ebp+var_18]
.text$mn:000077CA                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVScintillaEditView@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<ScintillaEditView *,std::allocator<ScintillaEditView *>>>::_Getal(void)
.text$mn:000077CF                 mov     ecx, eax
.text$mn:000077D1                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@PAVScintillaEditView@@@std@@@std@@QAEXPAPAVScintillaEditView@@I@Z ; std::_Wrap_alloc<std::allocator<ScintillaEditView *>>::deallocate(ScintillaEditView * *,uint)
.text$mn:000077D6
.text$mn:000077D6 loc_77D6:                               ; CODE XREF: std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::_Reallocate(uint)+B8j
.text$mn:000077D6                 mov     ecx, [ebp+var_18] ; this
.text$mn:000077D9                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:000077DE                 mov     eax, [ebp+arg_0]
.text$mn:000077E1                 mov     ecx, [ebp+var_1C]
.text$mn:000077E4                 lea     edx, [ecx+eax*4]
.text$mn:000077E7                 mov     eax, [ebp+var_18]
.text$mn:000077EA                 mov     [eax+0Ch], edx
.text$mn:000077ED                 mov     ecx, [ebp+var_20]
.text$mn:000077F0                 mov     edx, [ebp+var_1C]
.text$mn:000077F3                 lea     eax, [edx+ecx*4]
.text$mn:000077F6                 mov     ecx, [ebp+var_18]
.text$mn:000077F9                 mov     [ecx+8], eax
.text$mn:000077FC                 mov     edx, [ebp+var_18]
.text$mn:000077FF                 mov     eax, [ebp+var_1C]
.text$mn:00007802                 mov     [edx+4], eax
.text$mn:00007805                 mov     ecx, [ebp+var_C]
.text$mn:00007808                 mov     large fs:0, ecx
.text$mn:0000780F                 pop     ecx
.text$mn:00007810                 pop     edi
.text$mn:00007811                 pop     esi
.text$mn:00007812                 pop     ebx
.text$mn:00007813                 mov     esp, ebp
.text$mn:00007815                 pop     ebp
.text$mn:00007816                 retn    4
.text$mn:00007816 ; END OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@IAEXI@Z
.text$mn:00007816 ; ---------------------------------------------------------------------------
.text$mn:00007819                 align 4
.text$mn:00007819 _text$mn        ends
.text$mn:00007819
.text$x:0000781C ; ===========================================================================
.text$x:0000781C
.text$x:0000781C ; Segment type: Pure code
.text$x:0000781C ; Segment permissions: Read/Execute
.text$x:0000781C _text$x         segment para public 'CODE' use32
.text$x:0000781C                 assume cs:_text$x
.text$x:0000781C                 ;org 781Ch
.text$x:0000781C ; COMDAT (pick associative to section at 76DC)
.text$x:0000781C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000781C
.text$x:0000781C ; =============== S U B R O U T I N E =======================================
.text$x:0000781C
.text$x:0000781C
.text$x:0000781C __ehhandler$?_Reallocate@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@IAEXI@Z proc near
.text$x:0000781C                                         ; DATA XREF: std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::_Reallocate(uint)+5o
.text$x:0000781C
.text$x:0000781C arg_4           = dword ptr  8
.text$x:0000781C
.text$x:0000781C                 mov     edx, [esp+arg_4]
.text$x:00007820                 lea     eax, [edx+0Ch]
.text$x:00007823                 mov     ecx, [edx-24h]
.text$x:00007826                 xor     ecx, eax
.text$x:00007828                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000782D                 mov     eax, offset __ehfuncinfo$?_Reallocate@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@IAEXI@Z
.text$x:00007832                 jmp     ___CxxFrameHandler3
.text$x:00007832 __ehhandler$?_Reallocate@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@IAEXI@Z endp
.text$x:00007832
.text$x:00007832 ; ---------------------------------------------------------------------------
.text$x:00007837                 align 4
.text$x:00007837 _text$x         ends
.text$x:00007837
.text$mn:00007838 ; ===========================================================================
.text$mn:00007838
.text$mn:00007838 ; Segment type: Pure code
.text$mn:00007838 ; Segment permissions: Read/Execute
.text$mn:00007838 _text$mn        segment para public 'CODE' use32
.text$mn:00007838                 assume cs:_text$mn
.text$mn:00007838                 ;org 7838h
.text$mn:00007838 ; COMDAT (pick any)
.text$mn:00007838                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007838
.text$mn:00007838 ; =============== S U B R O U T I N E =======================================
.text$mn:00007838
.text$mn:00007838 ; Attributes: bp-based frame
.text$mn:00007838
.text$mn:00007838 ; protected: void __thiscall std::vector<class ScintillaEditView *, class std::allocator<class ScintillaEditView *>>::_Reserve(unsigned int)
.text$mn:00007838                 public ?_Reserve@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@IAEXI@Z
.text$mn:00007838 ?_Reserve@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@IAEXI@Z proc near
.text$mn:00007838                                         ; CODE XREF: std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::push_back(ScintillaEditView * const &)+50p
.text$mn:00007838                                         ; std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::push_back(ScintillaEditView * const &)+B6p
.text$mn:00007838
.text$mn:00007838 var_4           = dword ptr -4
.text$mn:00007838 arg_0           = dword ptr  8
.text$mn:00007838
.text$mn:00007838                 push    ebp
.text$mn:00007839                 mov     ebp, esp
.text$mn:0000783B                 push    ecx
.text$mn:0000783C                 push    esi
.text$mn:0000783D                 mov     [ebp+var_4], ecx
.text$mn:00007840                 mov     ecx, [ebp+var_4]
.text$mn:00007843                 call    ?_Unused_capacity@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@QBEIXZ ; std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::_Unused_capacity(void)
.text$mn:00007848                 cmp     eax, [ebp+arg_0]
.text$mn:0000784B                 jnb     short loc_788B
.text$mn:0000784D                 mov     ecx, [ebp+var_4]
.text$mn:00007850                 call    ?max_size@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@QBEIXZ ; std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::max_size(void)
.text$mn:00007855                 mov     esi, eax
.text$mn:00007857                 mov     ecx, [ebp+var_4]
.text$mn:0000785A                 call    ?size@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@QBEIXZ ; std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::size(void)
.text$mn:0000785F                 sub     esi, eax
.text$mn:00007861                 cmp     esi, [ebp+arg_0]
.text$mn:00007864                 jnb     short loc_786E
.text$mn:00007866                 mov     ecx, [ebp+var_4]
.text$mn:00007869                 call    ?_Xlen@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@IBEXXZ ; std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::_Xlen(void)
.text$mn:0000786E
.text$mn:0000786E loc_786E:                               ; CODE XREF: std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::_Reserve(uint)+2Cj
.text$mn:0000786E                 mov     ecx, [ebp+var_4]
.text$mn:00007871                 call    ?size@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@QBEIXZ ; std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::size(void)
.text$mn:00007876                 add     eax, [ebp+arg_0]
.text$mn:00007879                 push    eax
.text$mn:0000787A                 mov     ecx, [ebp+var_4]
.text$mn:0000787D                 call    ?_Grow_to@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@IBEII@Z ; std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::_Grow_to(uint)
.text$mn:00007882                 push    eax
.text$mn:00007883                 mov     ecx, [ebp+var_4]
.text$mn:00007886                 call    ?_Reallocate@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@IAEXI@Z ; std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::_Reallocate(uint)
.text$mn:0000788B
.text$mn:0000788B loc_788B:                               ; CODE XREF: std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::_Reserve(uint)+13j
.text$mn:0000788B                 pop     esi
.text$mn:0000788C                 mov     esp, ebp
.text$mn:0000788E                 pop     ebp
.text$mn:0000788F                 retn    4
.text$mn:0000788F ?_Reserve@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@IAEXI@Z endp
.text$mn:0000788F
.text$mn:0000788F ; ---------------------------------------------------------------------------
.text$mn:00007892                 align 4
.text$mn:00007892 _text$mn        ends
.text$mn:00007892
.text$mn:00007894 ; ===========================================================================
.text$mn:00007894
.text$mn:00007894 ; Segment type: Pure code
.text$mn:00007894 ; Segment permissions: Read/Execute
.text$mn:00007894 _text$mn        segment para public 'CODE' use32
.text$mn:00007894                 assume cs:_text$mn
.text$mn:00007894                 ;org 7894h
.text$mn:00007894 ; COMDAT (pick any)
.text$mn:00007894                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007894
.text$mn:00007894 ; =============== S U B R O U T I N E =======================================
.text$mn:00007894
.text$mn:00007894 ; Attributes: bp-based frame
.text$mn:00007894
.text$mn:00007894 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(char, size_t Size)
.text$mn:00007894                 public ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
.text$mn:00007894 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z proc near
.text$mn:00007894                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+47p
.text$mn:00007894                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+34p ...
.text$mn:00007894
.text$mn:00007894 var_C           = dword ptr -0Ch
.text$mn:00007894 var_8           = dword ptr -8
.text$mn:00007894 var_2           = byte ptr -2
.text$mn:00007894 var_1           = byte ptr -1
.text$mn:00007894 arg_0           = byte ptr  8
.text$mn:00007894 Size            = dword ptr  0Ch
.text$mn:00007894
.text$mn:00007894                 push    ebp
.text$mn:00007895                 mov     ebp, esp
.text$mn:00007897                 sub     esp, 0Ch
.text$mn:0000789A                 mov     [ebp+var_8], ecx
.text$mn:0000789D                 movzx   eax, [ebp+arg_0]
.text$mn:000078A1                 test    eax, eax
.text$mn:000078A3                 jnz     short loc_78A7
.text$mn:000078A5                 jmp     short loc_791A
.text$mn:000078A7 ; ---------------------------------------------------------------------------
.text$mn:000078A7
.text$mn:000078A7 loc_78A7:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+Fj
.text$mn:000078A7                 mov     ecx, [ebp+var_8]
.text$mn:000078AA                 cmp     dword ptr [ecx+18h], 10h
.text$mn:000078AE                 jb      short loc_791A
.text$mn:000078B0                 mov     edx, [ebp+var_8]
.text$mn:000078B3                 mov     eax, [edx+4]
.text$mn:000078B6                 mov     [ebp+var_C], eax
.text$mn:000078B9                 mov     ecx, [ebp+var_8]
.text$mn:000078BC                 add     ecx, 4
.text$mn:000078BF                 push    ecx
.text$mn:000078C0                 lea     edx, [ebp+var_1]
.text$mn:000078C3                 push    edx
.text$mn:000078C4                 mov     ecx, [ebp+var_8]
.text$mn:000078C7                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:000078CC                 mov     ecx, eax
.text$mn:000078CE                 call    ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)
.text$mn:000078D3                 cmp     [ebp+Size], 0
.text$mn:000078D7                 jbe     short loc_78F9
.text$mn:000078D9                 mov     eax, [ebp+Size]
.text$mn:000078DC                 push    eax             ; Size
.text$mn:000078DD                 mov     ecx, [ebp+var_C]
.text$mn:000078E0                 push    ecx
.text$mn:000078E1                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:000078E6                 add     esp, 4
.text$mn:000078E9                 push    eax             ; Src
.text$mn:000078EA                 mov     edx, [ebp+var_8]
.text$mn:000078ED                 add     edx, 4
.text$mn:000078F0                 push    edx             ; Dst
.text$mn:000078F1                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:000078F6                 add     esp, 0Ch
.text$mn:000078F9
.text$mn:000078F9 loc_78F9:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+43j
.text$mn:000078F9                 mov     eax, [ebp+var_8]
.text$mn:000078FC                 mov     ecx, [eax+18h]
.text$mn:000078FF                 add     ecx, 1
.text$mn:00007902                 push    ecx             ; int
.text$mn:00007903                 mov     edx, [ebp+var_C]
.text$mn:00007906                 push    edx             ; void *
.text$mn:00007907                 lea     eax, [ebp+var_2]
.text$mn:0000790A                 push    eax
.text$mn:0000790B                 mov     ecx, [ebp+var_8]
.text$mn:0000790E                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00007913                 mov     ecx, eax
.text$mn:00007915                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)
.text$mn:0000791A
.text$mn:0000791A loc_791A:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+11j
.text$mn:0000791A                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+1Aj
.text$mn:0000791A                 mov     ecx, [ebp+var_8]
.text$mn:0000791D                 mov     dword ptr [ecx+18h], 0Fh
.text$mn:00007924                 mov     edx, [ebp+Size]
.text$mn:00007927                 push    edx
.text$mn:00007928                 mov     ecx, [ebp+var_8]
.text$mn:0000792B                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00007930                 mov     esp, ebp
.text$mn:00007932                 pop     ebp
.text$mn:00007933                 retn    8
.text$mn:00007933 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z endp
.text$mn:00007933
.text$mn:00007933 ; ---------------------------------------------------------------------------
.text$mn:00007936                 align 4
.text$mn:00007936 _text$mn        ends
.text$mn:00007936
.text$mn:00007938 ; ===========================================================================
.text$mn:00007938
.text$mn:00007938 ; Segment type: Pure code
.text$mn:00007938 ; Segment permissions: Read/Execute
.text$mn:00007938 _text$mn        segment para public 'CODE' use32
.text$mn:00007938                 assume cs:_text$mn
.text$mn:00007938                 ;org 7938h
.text$mn:00007938 ; COMDAT (pick any)
.text$mn:00007938                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007938
.text$mn:00007938 ; =============== S U B R O U T I N E =======================================
.text$mn:00007938
.text$mn:00007938 ; Attributes: bp-based frame
.text$mn:00007938
.text$mn:00007938 ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Tidy(bool, unsigned int)
.text$mn:00007938                 public ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z
.text$mn:00007938 ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z proc near
.text$mn:00007938                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)+34p
.text$mn:00007938
.text$mn:00007938 var_C           = dword ptr -0Ch
.text$mn:00007938 var_8           = dword ptr -8
.text$mn:00007938 var_2           = byte ptr -2
.text$mn:00007938 var_1           = byte ptr -1
.text$mn:00007938 arg_0           = byte ptr  8
.text$mn:00007938 arg_4           = dword ptr  0Ch
.text$mn:00007938
.text$mn:00007938                 push    ebp
.text$mn:00007939                 mov     ebp, esp
.text$mn:0000793B                 sub     esp, 0Ch
.text$mn:0000793E                 mov     [ebp+var_8], ecx
.text$mn:00007941                 movzx   eax, [ebp+arg_0]
.text$mn:00007945                 test    eax, eax
.text$mn:00007947                 jnz     short loc_794B
.text$mn:00007949                 jmp     short loc_79BE
.text$mn:0000794B ; ---------------------------------------------------------------------------
.text$mn:0000794B
.text$mn:0000794B loc_794B:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+Fj
.text$mn:0000794B                 mov     ecx, [ebp+var_8]
.text$mn:0000794E                 cmp     dword ptr [ecx+18h], 8
.text$mn:00007952                 jb      short loc_79BE
.text$mn:00007954                 mov     edx, [ebp+var_8]
.text$mn:00007957                 mov     eax, [edx+4]
.text$mn:0000795A                 mov     [ebp+var_C], eax
.text$mn:0000795D                 mov     ecx, [ebp+var_8]
.text$mn:00007960                 add     ecx, 4
.text$mn:00007963                 push    ecx
.text$mn:00007964                 lea     edx, [ebp+var_1]
.text$mn:00007967                 push    edx
.text$mn:00007968                 mov     ecx, [ebp+var_8]
.text$mn:0000796B                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:00007970                 mov     ecx, eax
.text$mn:00007972                 call    ??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::destroy<wchar_t *>(wchar_t * *)
.text$mn:00007977                 cmp     [ebp+arg_4], 0
.text$mn:0000797B                 jbe     short loc_799D
.text$mn:0000797D                 mov     eax, [ebp+arg_4]
.text$mn:00007980                 push    eax             ; int
.text$mn:00007981                 mov     ecx, [ebp+var_C]
.text$mn:00007984                 push    ecx
.text$mn:00007985                 call    ??$addressof@_W@std@@YAPA_WAA_W@Z ; std::addressof<wchar_t>(wchar_t &)
.text$mn:0000798A                 add     esp, 4
.text$mn:0000798D                 push    eax             ; Src
.text$mn:0000798E                 mov     edx, [ebp+var_8]
.text$mn:00007991                 add     edx, 4
.text$mn:00007994                 push    edx             ; Dst
.text$mn:00007995                 call    ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)
.text$mn:0000799A                 add     esp, 0Ch
.text$mn:0000799D
.text$mn:0000799D loc_799D:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+43j
.text$mn:0000799D                 mov     eax, [ebp+var_8]
.text$mn:000079A0                 mov     ecx, [eax+18h]
.text$mn:000079A3                 add     ecx, 1
.text$mn:000079A6                 push    ecx             ; int
.text$mn:000079A7                 mov     edx, [ebp+var_C]
.text$mn:000079AA                 push    edx             ; void *
.text$mn:000079AB                 lea     eax, [ebp+var_2]
.text$mn:000079AE                 push    eax
.text$mn:000079AF                 mov     ecx, [ebp+var_8]
.text$mn:000079B2                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:000079B7                 mov     ecx, eax
.text$mn:000079B9                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::deallocate(wchar_t *,uint)
.text$mn:000079BE
.text$mn:000079BE loc_79BE:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+11j
.text$mn:000079BE                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+1Aj
.text$mn:000079BE                 mov     ecx, [ebp+var_8]
.text$mn:000079C1                 mov     dword ptr [ecx+18h], 7
.text$mn:000079C8                 mov     edx, [ebp+arg_4]
.text$mn:000079CB                 push    edx
.text$mn:000079CC                 mov     ecx, [ebp+var_8]
.text$mn:000079CF                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:000079D4                 mov     esp, ebp
.text$mn:000079D6                 pop     ebp
.text$mn:000079D7                 retn    8
.text$mn:000079D7 ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z endp
.text$mn:000079D7
.text$mn:000079D7 ; ---------------------------------------------------------------------------
.text$mn:000079DA                 align 4
.text$mn:000079DA _text$mn        ends
.text$mn:000079DA
.text$mn:000079DC ; ===========================================================================
.text$mn:000079DC
.text$mn:000079DC ; Segment type: Pure code
.text$mn:000079DC ; Segment permissions: Read/Execute
.text$mn:000079DC _text$mn        segment para public 'CODE' use32
.text$mn:000079DC                 assume cs:_text$mn
.text$mn:000079DC                 ;org 79DCh
.text$mn:000079DC ; COMDAT (pick any)
.text$mn:000079DC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000079DC
.text$mn:000079DC ; =============== S U B R O U T I N E =======================================
.text$mn:000079DC
.text$mn:000079DC ; Attributes: bp-based frame
.text$mn:000079DC
.text$mn:000079DC ; public: void __thiscall std::list<struct std::pair<int const, struct Style>, class std::allocator<struct std::pair<int const, struct Style>>>::_Tidy(void)
.text$mn:000079DC                 public ?_Tidy@?$list@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@QAEXXZ
.text$mn:000079DC ?_Tidy@?$list@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@QAEXXZ proc near
.text$mn:000079DC                                         ; CODE XREF: std::list<std::pair<int const,Style>,std::allocator<std::pair<int const,Style>>>::~list<std::pair<int const,Style>,std::allocator<std::pair<int const,Style>>>(void)+30p
.text$mn:000079DC
.text$mn:000079DC var_4           = dword ptr -4
.text$mn:000079DC
.text$mn:000079DC                 push    ebp
.text$mn:000079DD                 mov     ebp, esp
.text$mn:000079DF                 push    ecx
.text$mn:000079E0                 mov     [ebp+var_4], ecx
.text$mn:000079E3                 mov     ecx, [ebp+var_4]
.text$mn:000079E6                 call    ?clear@?$list@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@QAEXXZ ; std::list<std::pair<int const,Style>,std::allocator<std::pair<int const,Style>>>::clear(void)
.text$mn:000079EB                 mov     esp, ebp
.text$mn:000079ED                 pop     ebp
.text$mn:000079EE                 retn
.text$mn:000079EE ?_Tidy@?$list@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@QAEXXZ endp
.text$mn:000079EE
.text$mn:000079EE ; ---------------------------------------------------------------------------
.text$mn:000079EF                 align 10h
.text$mn:000079EF _text$mn        ends
.text$mn:000079EF
.text$mn:000079F0 ; ===========================================================================
.text$mn:000079F0
.text$mn:000079F0 ; Segment type: Pure code
.text$mn:000079F0 ; Segment permissions: Read/Execute
.text$mn:000079F0 _text$mn        segment para public 'CODE' use32
.text$mn:000079F0                 assume cs:_text$mn
.text$mn:000079F0                 ;org 79F0h
.text$mn:000079F0 ; COMDAT (pick any)
.text$mn:000079F0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000079F0
.text$mn:000079F0 ; =============== S U B R O U T I N E =======================================
.text$mn:000079F0
.text$mn:000079F0 ; Attributes: bp-based frame
.text$mn:000079F0
.text$mn:000079F0 ; public: void __thiscall std::list<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>, class std::allocator<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>::_Tidy(void)
.text$mn:000079F0                 public ?_Tidy@?$list@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAEXXZ
.text$mn:000079F0 ?_Tidy@?$list@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAEXXZ proc near
.text$mn:000079F0                                         ; CODE XREF: std::list<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>::~list<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>(void)+30p
.text$mn:000079F0
.text$mn:000079F0 var_4           = dword ptr -4
.text$mn:000079F0
.text$mn:000079F0                 push    ebp
.text$mn:000079F1                 mov     ebp, esp
.text$mn:000079F3                 push    ecx
.text$mn:000079F4                 mov     [ebp+var_4], ecx
.text$mn:000079F7                 mov     ecx, [ebp+var_4]
.text$mn:000079FA                 call    ?clear@?$list@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAEXXZ ; std::list<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>::clear(void)
.text$mn:000079FF                 mov     esp, ebp
.text$mn:00007A01                 pop     ebp
.text$mn:00007A02                 retn
.text$mn:00007A02 ?_Tidy@?$list@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAEXXZ endp
.text$mn:00007A02
.text$mn:00007A02 ; ---------------------------------------------------------------------------
.text$mn:00007A03                 align 4
.text$mn:00007A03 _text$mn        ends
.text$mn:00007A03
.text$mn:00007A04 ; ===========================================================================
.text$mn:00007A04
.text$mn:00007A04 ; Segment type: Pure code
.text$mn:00007A04 ; Segment permissions: Read/Execute
.text$mn:00007A04 _text$mn        segment para public 'CODE' use32
.text$mn:00007A04                 assume cs:_text$mn
.text$mn:00007A04                 ;org 7A04h
.text$mn:00007A04 ; COMDAT (pick any)
.text$mn:00007A04                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007A04
.text$mn:00007A04 ; =============== S U B R O U T I N E =======================================
.text$mn:00007A04
.text$mn:00007A04 ; Attributes: bp-based frame
.text$mn:00007A04
.text$mn:00007A04 ; protected: void __thiscall std::vector<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<int const, struct Style>>>>, struct std::_Wrap_alloc<class std::allocator<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<int const, struct Style>>>>>>>::_Tidy(void)
.text$mn:00007A04                 public ?_Tidy@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAEXXZ
.text$mn:00007A04 ?_Tidy@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAEXXZ proc near
.text$mn:00007A04                                         ; CODE XREF: std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>>>>::~vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>>>>(void)+30p
.text$mn:00007A04
.text$mn:00007A04 var_8           = dword ptr -8
.text$mn:00007A04 var_1           = byte ptr -1
.text$mn:00007A04
.text$mn:00007A04                 push    ebp
.text$mn:00007A05                 mov     ebp, esp
.text$mn:00007A07                 sub     esp, 8
.text$mn:00007A0A                 mov     [ebp+var_8], ecx
.text$mn:00007A0D                 mov     eax, [ebp+var_8]
.text$mn:00007A10                 cmp     dword ptr [eax+4], 0
.text$mn:00007A14                 jz      short loc_7A7C
.text$mn:00007A16                 mov     ecx, [ebp+var_8] ; this
.text$mn:00007A19                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00007A1E                 mov     ecx, [ebp+var_8]
.text$mn:00007A21                 mov     edx, [ecx+8]
.text$mn:00007A24                 push    edx
.text$mn:00007A25                 mov     eax, [ebp+var_8]
.text$mn:00007A28                 mov     ecx, [eax+4]
.text$mn:00007A2B                 push    ecx
.text$mn:00007A2C                 mov     ecx, [ebp+var_8]
.text$mn:00007A2F                 call    ?_Destroy@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@2@0@Z ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>>>>::_Destroy(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>> *)
.text$mn:00007A34                 mov     edx, [ebp+var_8]
.text$mn:00007A37                 mov     eax, [ebp+var_8]
.text$mn:00007A3A                 mov     ecx, [edx+0Ch]
.text$mn:00007A3D                 sub     ecx, [eax+4]
.text$mn:00007A40                 sar     ecx, 2
.text$mn:00007A43                 push    ecx             ; int
.text$mn:00007A44                 mov     edx, [ebp+var_8]
.text$mn:00007A47                 mov     eax, [edx+4]
.text$mn:00007A4A                 push    eax             ; void *
.text$mn:00007A4B                 lea     ecx, [ebp+var_1]
.text$mn:00007A4E                 push    ecx
.text$mn:00007A4F                 mov     ecx, [ebp+var_8]
.text$mn:00007A52                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>>>>>::_Getal(void)
.text$mn:00007A57                 mov     ecx, eax
.text$mn:00007A59                 call    ?deallocate@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@2@I@Z ; std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>>>>::deallocate(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>> *,uint)
.text$mn:00007A5E                 mov     edx, [ebp+var_8]
.text$mn:00007A61                 mov     dword ptr [edx+4], 0
.text$mn:00007A68                 mov     eax, [ebp+var_8]
.text$mn:00007A6B                 mov     dword ptr [eax+8], 0
.text$mn:00007A72                 mov     ecx, [ebp+var_8]
.text$mn:00007A75                 mov     dword ptr [ecx+0Ch], 0
.text$mn:00007A7C
.text$mn:00007A7C loc_7A7C:                               ; CODE XREF: std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>>>>::_Tidy(void)+10j
.text$mn:00007A7C                 mov     esp, ebp
.text$mn:00007A7E                 pop     ebp
.text$mn:00007A7F                 retn
.text$mn:00007A7F ?_Tidy@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAEXXZ endp
.text$mn:00007A7F
.text$mn:00007A7F _text$mn        ends
.text$mn:00007A7F
.text$mn:00007A80 ; ===========================================================================
.text$mn:00007A80
.text$mn:00007A80 ; Segment type: Pure code
.text$mn:00007A80 ; Segment permissions: Read/Execute
.text$mn:00007A80 _text$mn        segment para public 'CODE' use32
.text$mn:00007A80                 assume cs:_text$mn
.text$mn:00007A80                 ;org 7A80h
.text$mn:00007A80 ; COMDAT (pick any)
.text$mn:00007A80                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007A80
.text$mn:00007A80 ; =============== S U B R O U T I N E =======================================
.text$mn:00007A80
.text$mn:00007A80 ; Attributes: bp-based frame
.text$mn:00007A80
.text$mn:00007A80 ; protected: void __thiscall std::vector<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>, struct std::_Wrap_alloc<class std::allocator<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>>>>::_Tidy(void)
.text$mn:00007A80                 public ?_Tidy@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAEXXZ
.text$mn:00007A80 ?_Tidy@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAEXXZ proc near
.text$mn:00007A80                                         ; CODE XREF: std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::~vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>(void)+30p
.text$mn:00007A80
.text$mn:00007A80 var_8           = dword ptr -8
.text$mn:00007A80 var_1           = byte ptr -1
.text$mn:00007A80
.text$mn:00007A80                 push    ebp
.text$mn:00007A81                 mov     ebp, esp
.text$mn:00007A83                 sub     esp, 8
.text$mn:00007A86                 mov     [ebp+var_8], ecx
.text$mn:00007A89                 mov     eax, [ebp+var_8]
.text$mn:00007A8C                 cmp     dword ptr [eax+4], 0
.text$mn:00007A90                 jz      short loc_7AF8
.text$mn:00007A92                 mov     ecx, [ebp+var_8] ; this
.text$mn:00007A95                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00007A9A                 mov     ecx, [ebp+var_8]
.text$mn:00007A9D                 mov     edx, [ecx+8]
.text$mn:00007AA0                 push    edx
.text$mn:00007AA1                 mov     eax, [ebp+var_8]
.text$mn:00007AA4                 mov     ecx, [eax+4]
.text$mn:00007AA7                 push    ecx
.text$mn:00007AA8                 mov     ecx, [ebp+var_8]
.text$mn:00007AAB                 call    ?_Destroy@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@0@Z ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::_Destroy(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *)
.text$mn:00007AB0                 mov     edx, [ebp+var_8]
.text$mn:00007AB3                 mov     eax, [ebp+var_8]
.text$mn:00007AB6                 mov     ecx, [edx+0Ch]
.text$mn:00007AB9                 sub     ecx, [eax+4]
.text$mn:00007ABC                 sar     ecx, 2
.text$mn:00007ABF                 push    ecx             ; int
.text$mn:00007AC0                 mov     edx, [ebp+var_8]
.text$mn:00007AC3                 mov     eax, [edx+4]
.text$mn:00007AC6                 push    eax             ; void *
.text$mn:00007AC7                 lea     ecx, [ebp+var_1]
.text$mn:00007ACA                 push    ecx
.text$mn:00007ACB                 mov     ecx, [ebp+var_8]
.text$mn:00007ACE                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>>::_Getal(void)
.text$mn:00007AD3                 mov     ecx, eax
.text$mn:00007AD5                 call    ?deallocate@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@I@Z ; std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::deallocate(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,uint)
.text$mn:00007ADA                 mov     edx, [ebp+var_8]
.text$mn:00007ADD                 mov     dword ptr [edx+4], 0
.text$mn:00007AE4                 mov     eax, [ebp+var_8]
.text$mn:00007AE7                 mov     dword ptr [eax+8], 0
.text$mn:00007AEE                 mov     ecx, [ebp+var_8]
.text$mn:00007AF1                 mov     dword ptr [ecx+0Ch], 0
.text$mn:00007AF8
.text$mn:00007AF8 loc_7AF8:                               ; CODE XREF: std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::_Tidy(void)+10j
.text$mn:00007AF8                 mov     esp, ebp
.text$mn:00007AFA                 pop     ebp
.text$mn:00007AFB                 retn
.text$mn:00007AFB ?_Tidy@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAEXXZ endp
.text$mn:00007AFB
.text$mn:00007AFB _text$mn        ends
.text$mn:00007AFB
.text$mn:00007AFC ; ===========================================================================
.text$mn:00007AFC
.text$mn:00007AFC ; Segment type: Pure code
.text$mn:00007AFC ; Segment permissions: Read/Execute
.text$mn:00007AFC _text$mn        segment para public 'CODE' use32
.text$mn:00007AFC                 assume cs:_text$mn
.text$mn:00007AFC                 ;org 7AFCh
.text$mn:00007AFC ; COMDAT (pick any)
.text$mn:00007AFC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007AFC
.text$mn:00007AFC ; =============== S U B R O U T I N E =======================================
.text$mn:00007AFC
.text$mn:00007AFC ; Attributes: bp-based frame
.text$mn:00007AFC
.text$mn:00007AFC ; int __stdcall std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::_Ufill(void *, int, int)
.text$mn:00007AFC                 public ?_Ufill@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAEPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@PAV32@IPBV32@@Z
.text$mn:00007AFC ?_Ufill@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAEPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@PAV32@IPBV32@@Z proc near
.text$mn:00007AFC                                         ; CODE XREF: ?_Insert_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CB
.text$mn:00007AFC                                         ; ?_Insert_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@s
.text$mn:00007AFC
.text$mn:00007AFC var_8           = dword ptr -8
.text$mn:00007AFC var_1           = dword ptr -1
.text$mn:00007AFC arg_0           = dword ptr  8
.text$mn:00007AFC arg_4           = dword ptr  0Ch
.text$mn:00007AFC arg_8           = dword ptr  10h
.text$mn:00007AFC
.text$mn:00007AFC                 push    ebp
.text$mn:00007AFD                 mov     ebp, esp
.text$mn:00007AFF                 sub     esp, 8
.text$mn:00007B02                 mov     [ebp+var_8], ecx
.text$mn:00007B05                 lea     eax, [ebp+var_1]
.text$mn:00007B08                 push    eax
.text$mn:00007B09                 mov     ecx, [ebp+var_8]
.text$mn:00007B0C                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>>::_Getal(void)
.text$mn:00007B11                 lea     ecx, [ebp+var_1]
.text$mn:00007B14                 push    ecx             ; int
.text$mn:00007B15                 mov     edx, [ebp+arg_8]
.text$mn:00007B18                 push    edx             ; int
.text$mn:00007B19                 mov     eax, [ebp+arg_4]
.text$mn:00007B1C                 push    eax             ; int
.text$mn:00007B1D                 mov     ecx, [ebp+arg_0]
.text$mn:00007B20                 push    ecx             ; void *
.text$mn:00007B21                 call    ??$_Uninitialized_fill_n@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@IV12@U?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@IPBV10@AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@st ; std::_Uninitialized_fill_n<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,uint,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,uint,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const *,std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>> &)
.text$mn:00007B26                 add     esp, 10h
.text$mn:00007B29                 mov     edx, [ebp+arg_4]
.text$mn:00007B2C                 mov     eax, [ebp+arg_0]
.text$mn:00007B2F                 lea     eax, [eax+edx*4]
.text$mn:00007B32                 mov     esp, ebp
.text$mn:00007B34                 pop     ebp
.text$mn:00007B35                 retn    0Ch
.text$mn:00007B35 ?_Ufill@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAEPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@PAV32@IPBV32@@Z endp
.text$mn:00007B35
.text$mn:00007B35 _text$mn        ends
.text$mn:00007B35
.text$mn:00007B38 ; ===========================================================================
.text$mn:00007B38
.text$mn:00007B38 ; Segment type: Pure code
.text$mn:00007B38 ; Segment permissions: Read/Execute
.text$mn:00007B38 _text$mn        segment para public 'CODE' use32
.text$mn:00007B38                 assume cs:_text$mn
.text$mn:00007B38                 ;org 7B38h
.text$mn:00007B38 ; COMDAT (pick any)
.text$mn:00007B38                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007B38
.text$mn:00007B38 ; =============== S U B R O U T I N E =======================================
.text$mn:00007B38
.text$mn:00007B38 ; Attributes: bp-based frame
.text$mn:00007B38
.text$mn:00007B38 ; public: class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>> __thiscall std::_Hash<class std::_Umap_traits<class Buffer *, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *, class std::_Uhash_compare<class Buffer *, struct std::hash<class Buffer *>, struct std::equal_to<class Buffer *>>, class std::allocator<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>, 0>>::_Unchecked_end(void)
.text$mn:00007B38                 public ?_Unchecked_end@?$_Hash@V?$_Umap_traits@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@V?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@XZ
.text$mn:00007B38 ?_Unchecked_end@?$_Hash@V?$_Umap_traits@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@V?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@XZ proc near
.text$mn:00007B38                                         ; CODE XREF: std::_Hash<std::_Umap_traits<Buffer *,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *,std::_Uhash_compare<Buffer *,std::hash<Buffer *>,std::equal_to<Buffer *>>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>,0>>::_Init(uint)+10p
.text$mn:00007B38
.text$mn:00007B38 var_4           = dword ptr -4
.text$mn:00007B38 arg_0           = dword ptr  8
.text$mn:00007B38
.text$mn:00007B38                 push    ebp
.text$mn:00007B39                 mov     ebp, esp
.text$mn:00007B3B                 push    ecx
.text$mn:00007B3C                 mov     [ebp+var_4], ecx
.text$mn:00007B3F                 mov     eax, [ebp+arg_0]
.text$mn:00007B42                 push    eax
.text$mn:00007B43                 mov     ecx, [ebp+var_4]
.text$mn:00007B46                 call    ?_Unchecked_end@?$list@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@XZ ; std::list<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>::_Unchecked_end(void)
.text$mn:00007B4B                 mov     eax, [ebp+arg_0]
.text$mn:00007B4E                 mov     esp, ebp
.text$mn:00007B50                 pop     ebp
.text$mn:00007B51                 retn    4
.text$mn:00007B51 ?_Unchecked_end@?$_Hash@V?$_Umap_traits@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@V?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@XZ endp
.text$mn:00007B51
.text$mn:00007B51 _text$mn        ends
.text$mn:00007B51
.text$mn:00007B54 ; ===========================================================================
.text$mn:00007B54
.text$mn:00007B54 ; Segment type: Pure code
.text$mn:00007B54 ; Segment permissions: Read/Execute
.text$mn:00007B54 _text$mn        segment para public 'CODE' use32
.text$mn:00007B54                 assume cs:_text$mn
.text$mn:00007B54                 ;org 7B54h
.text$mn:00007B54 ; COMDAT (pick any)
.text$mn:00007B54                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007B54
.text$mn:00007B54 ; =============== S U B R O U T I N E =======================================
.text$mn:00007B54
.text$mn:00007B54 ; Attributes: bp-based frame
.text$mn:00007B54
.text$mn:00007B54 ; public: class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>> __thiscall std::list<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>, class std::allocator<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>::_Unchecked_end(void)
.text$mn:00007B54                 public ?_Unchecked_end@?$list@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@XZ
.text$mn:00007B54 ?_Unchecked_end@?$list@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@XZ proc near
.text$mn:00007B54                                         ; CODE XREF: std::_Hash<std::_Umap_traits<Buffer *,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *,std::_Uhash_compare<Buffer *,std::hash<Buffer *>,std::equal_to<Buffer *>>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>,0>>::_Unchecked_end(void)+Ep
.text$mn:00007B54
.text$mn:00007B54 var_4           = dword ptr -4
.text$mn:00007B54 arg_0           = dword ptr  8
.text$mn:00007B54
.text$mn:00007B54                 push    ebp
.text$mn:00007B55                 mov     ebp, esp
.text$mn:00007B57                 push    ecx
.text$mn:00007B58                 mov     [ebp+var_4], ecx
.text$mn:00007B5B                 mov     eax, [ebp+var_4]
.text$mn:00007B5E                 push    eax             ; void *
.text$mn:00007B5F                 mov     ecx, [ebp+var_4]
.text$mn:00007B62                 mov     edx, [ecx+4]
.text$mn:00007B65                 push    edx             ; int
.text$mn:00007B66                 mov     ecx, [ebp+arg_0]
.text$mn:00007B69                 call    ??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@1@@Z ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>(std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *,std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>> const *)
.text$mn:00007B6E                 mov     eax, [ebp+arg_0]
.text$mn:00007B71                 mov     esp, ebp
.text$mn:00007B73                 pop     ebp
.text$mn:00007B74                 retn    4
.text$mn:00007B74 ?_Unchecked_end@?$list@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@XZ endp
.text$mn:00007B74
.text$mn:00007B74 ; ---------------------------------------------------------------------------
.text$mn:00007B77                 align 4
.text$mn:00007B77 _text$mn        ends
.text$mn:00007B77
.text$mn:00007B78 ; ===========================================================================
.text$mn:00007B78
.text$mn:00007B78 ; Segment type: Pure code
.text$mn:00007B78 ; Segment permissions: Read/Execute
.text$mn:00007B78 _text$mn        segment para public 'CODE' use32
.text$mn:00007B78                 assume cs:_text$mn
.text$mn:00007B78                 ;org 7B78h
.text$mn:00007B78 ; COMDAT (pick any)
.text$mn:00007B78                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007B78
.text$mn:00007B78 ; =============== S U B R O U T I N E =======================================
.text$mn:00007B78
.text$mn:00007B78 ; Attributes: bp-based frame
.text$mn:00007B78
.text$mn:00007B78 ; public: unsigned int __thiscall std::vector<class ScintillaEditView *, class std::allocator<class ScintillaEditView *>>::_Unused_capacity(void)const
.text$mn:00007B78                 public ?_Unused_capacity@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@QBEIXZ
.text$mn:00007B78 ?_Unused_capacity@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@QBEIXZ proc near
.text$mn:00007B78                                         ; CODE XREF: std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::_Reserve(uint)+Bp
.text$mn:00007B78
.text$mn:00007B78 var_4           = dword ptr -4
.text$mn:00007B78
.text$mn:00007B78                 push    ebp
.text$mn:00007B79                 mov     ebp, esp
.text$mn:00007B7B                 push    ecx
.text$mn:00007B7C                 mov     [ebp+var_4], ecx
.text$mn:00007B7F                 mov     eax, [ebp+var_4]
.text$mn:00007B82                 mov     ecx, [ebp+var_4]
.text$mn:00007B85                 mov     eax, [eax+0Ch]
.text$mn:00007B88                 sub     eax, [ecx+8]
.text$mn:00007B8B                 sar     eax, 2
.text$mn:00007B8E                 mov     esp, ebp
.text$mn:00007B90                 pop     ebp
.text$mn:00007B91                 retn
.text$mn:00007B91 ?_Unused_capacity@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@QBEIXZ endp
.text$mn:00007B91
.text$mn:00007B91 ; ---------------------------------------------------------------------------
.text$mn:00007B92                 align 4
.text$mn:00007B92 _text$mn        ends
.text$mn:00007B92
.text$mn:00007B94 ; ===========================================================================
.text$mn:00007B94
.text$mn:00007B94 ; Segment type: Pure code
.text$mn:00007B94 ; Segment permissions: Read/Execute
.text$mn:00007B94 _text$mn        segment para public 'CODE' use32
.text$mn:00007B94                 assume cs:_text$mn
.text$mn:00007B94                 ;org 7B94h
.text$mn:00007B94 ; COMDAT (pick any)
.text$mn:00007B94                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007B94
.text$mn:00007B94 ; =============== S U B R O U T I N E =======================================
.text$mn:00007B94
.text$mn:00007B94 ; Attributes: bp-based frame
.text$mn:00007B94
.text$mn:00007B94 ; public: unsigned int __thiscall std::vector<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>, struct std::_Wrap_alloc<class std::allocator<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>>>>::_Unused_capacity(void)const
.text$mn:00007B94                 public ?_Unused_capacity@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QBEIXZ
.text$mn:00007B94 ?_Unused_capacity@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QBEIXZ proc near
.text$mn:00007B94                                         ; CODE XREF: ?_Insert_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CB
.text$mn:00007B94
.text$mn:00007B94 var_4           = dword ptr -4
.text$mn:00007B94
.text$mn:00007B94                 push    ebp
.text$mn:00007B95                 mov     ebp, esp
.text$mn:00007B97                 push    ecx
.text$mn:00007B98                 mov     [ebp+var_4], ecx
.text$mn:00007B9B                 mov     eax, [ebp+var_4]
.text$mn:00007B9E                 mov     ecx, [ebp+var_4]
.text$mn:00007BA1                 mov     eax, [eax+0Ch]
.text$mn:00007BA4                 sub     eax, [ecx+8]
.text$mn:00007BA7                 sar     eax, 2
.text$mn:00007BAA                 mov     esp, ebp
.text$mn:00007BAC                 pop     ebp
.text$mn:00007BAD                 retn
.text$mn:00007BAD ?_Unused_capacity@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QBEIXZ endp
.text$mn:00007BAD
.text$mn:00007BAD ; ---------------------------------------------------------------------------
.text$mn:00007BAE                 align 10h
.text$mn:00007BAE _text$mn        ends
.text$mn:00007BAE
.text$mn:00007BB0 ; ===========================================================================
.text$mn:00007BB0
.text$mn:00007BB0 ; Segment type: Pure code
.text$mn:00007BB0 ; Segment permissions: Read/Execute
.text$mn:00007BB0 _text$mn        segment para public 'CODE' use32
.text$mn:00007BB0                 assume cs:_text$mn
.text$mn:00007BB0                 ;org 7BB0h
.text$mn:00007BB0 ; COMDAT (pick any)
.text$mn:00007BB0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007BB0
.text$mn:00007BB0 ; =============== S U B R O U T I N E =======================================
.text$mn:00007BB0
.text$mn:00007BB0 ; Attributes: bp-based frame
.text$mn:00007BB0
.text$mn:00007BB0 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xlen(void)const
.text$mn:00007BB0                 public ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
.text$mn:00007BB0 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc near
.text$mn:00007BB0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+19p
.text$mn:00007BB0
.text$mn:00007BB0 var_4           = dword ptr -4
.text$mn:00007BB0
.text$mn:00007BB0                 push    ebp
.text$mn:00007BB1                 mov     ebp, esp
.text$mn:00007BB3                 push    ecx
.text$mn:00007BB4                 mov     [ebp+var_4], ecx
.text$mn:00007BB7                 push    offset ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ ; "string too long"
.text$mn:00007BBC                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:00007BC1                 mov     esp, ebp
.text$mn:00007BC3                 pop     ebp
.text$mn:00007BC4                 retn
.text$mn:00007BC4 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp
.text$mn:00007BC4
.text$mn:00007BC4 ; ---------------------------------------------------------------------------
.text$mn:00007BC5                 align 4
.text$mn:00007BC5 _text$mn        ends
.text$mn:00007BC5
.text$mn:00007BC8 ; ===========================================================================
.text$mn:00007BC8
.text$mn:00007BC8 ; Segment type: Pure code
.text$mn:00007BC8 ; Segment permissions: Read/Execute
.text$mn:00007BC8 _text$mn        segment para public 'CODE' use32
.text$mn:00007BC8                 assume cs:_text$mn
.text$mn:00007BC8                 ;org 7BC8h
.text$mn:00007BC8 ; COMDAT (pick any)
.text$mn:00007BC8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007BC8
.text$mn:00007BC8 ; =============== S U B R O U T I N E =======================================
.text$mn:00007BC8
.text$mn:00007BC8 ; Attributes: bp-based frame
.text$mn:00007BC8
.text$mn:00007BC8 ; protected: void __thiscall std::vector<class ScintillaEditView *, class std::allocator<class ScintillaEditView *>>::_Xlen(void)const
.text$mn:00007BC8                 public ?_Xlen@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@IBEXXZ
.text$mn:00007BC8 ?_Xlen@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@IBEXXZ proc near
.text$mn:00007BC8                                         ; CODE XREF: std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::_Reserve(uint)+31p
.text$mn:00007BC8
.text$mn:00007BC8 var_4           = dword ptr -4
.text$mn:00007BC8
.text$mn:00007BC8                 push    ebp
.text$mn:00007BC9                 mov     ebp, esp
.text$mn:00007BCB                 push    ecx
.text$mn:00007BCC                 mov     [ebp+var_4], ecx
.text$mn:00007BCF                 push    offset ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; "vector<T> too long"
.text$mn:00007BD4                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:00007BD9                 mov     esp, ebp
.text$mn:00007BDB                 pop     ebp
.text$mn:00007BDC                 retn
.text$mn:00007BDC ?_Xlen@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@IBEXXZ endp
.text$mn:00007BDC
.text$mn:00007BDC ; ---------------------------------------------------------------------------
.text$mn:00007BDD                 align 10h
.text$mn:00007BDD _text$mn        ends
.text$mn:00007BDD
.text$mn:00007BE0 ; ===========================================================================
.text$mn:00007BE0
.text$mn:00007BE0 ; Segment type: Pure code
.text$mn:00007BE0 ; Segment permissions: Read/Execute
.text$mn:00007BE0 _text$mn        segment para public 'CODE' use32
.text$mn:00007BE0                 assume cs:_text$mn
.text$mn:00007BE0                 ;org 7BE0h
.text$mn:00007BE0 ; COMDAT (pick any)
.text$mn:00007BE0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007BE0
.text$mn:00007BE0 ; =============== S U B R O U T I N E =======================================
.text$mn:00007BE0
.text$mn:00007BE0 ; Attributes: bp-based frame
.text$mn:00007BE0
.text$mn:00007BE0 ; protected: void __thiscall std::vector<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>, struct std::_Wrap_alloc<class std::allocator<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>>>>::_Xlen(void)const
.text$mn:00007BE0                 public ?_Xlen@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IBEXXZ
.text$mn:00007BE0 ?_Xlen@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IBEXXZ proc near
.text$mn:00007BE0                                         ; CODE XREF: ?_Insert_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CB
.text$mn:00007BE0
.text$mn:00007BE0 var_4           = dword ptr -4
.text$mn:00007BE0
.text$mn:00007BE0                 push    ebp
.text$mn:00007BE1                 mov     ebp, esp
.text$mn:00007BE3                 push    ecx
.text$mn:00007BE4                 mov     [ebp+var_4], ecx
.text$mn:00007BE7                 push    offset ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; "vector<T> too long"
.text$mn:00007BEC                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:00007BF1                 mov     esp, ebp
.text$mn:00007BF3                 pop     ebp
.text$mn:00007BF4                 retn
.text$mn:00007BF4 ?_Xlen@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IBEXXZ endp
.text$mn:00007BF4
.text$mn:00007BF4 ; ---------------------------------------------------------------------------
.text$mn:00007BF5                 align 4
.text$mn:00007BF5 _text$mn        ends
.text$mn:00007BF5
.text$mn:00007BF8 ; ===========================================================================
.text$mn:00007BF8
.text$mn:00007BF8 ; Segment type: Pure code
.text$mn:00007BF8 ; Segment permissions: Read/Execute
.text$mn:00007BF8 _text$mn        segment para public 'CODE' use32
.text$mn:00007BF8                 assume cs:_text$mn
.text$mn:00007BF8                 ;org 7BF8h
.text$mn:00007BF8 ; COMDAT (pick any)
.text$mn:00007BF8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007BF8
.text$mn:00007BF8 ; =============== S U B R O U T I N E =======================================
.text$mn:00007BF8
.text$mn:00007BF8 ; Attributes: bp-based frame
.text$mn:00007BF8
.text$mn:00007BF8 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xran(void)const
.text$mn:00007BF8                 public ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
.text$mn:00007BF8 ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc near
.text$mn:00007BF8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+19p
.text$mn:00007BF8                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)+15p ...
.text$mn:00007BF8
.text$mn:00007BF8 var_4           = dword ptr -4
.text$mn:00007BF8
.text$mn:00007BF8                 push    ebp
.text$mn:00007BF9                 mov     ebp, esp
.text$mn:00007BFB                 push    ecx
.text$mn:00007BFC                 mov     [ebp+var_4], ecx
.text$mn:00007BFF                 push    offset ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; "invalid string position"
.text$mn:00007C04                 call    ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range(char const *)
.text$mn:00007C09                 mov     esp, ebp
.text$mn:00007C0B                 pop     ebp
.text$mn:00007C0C                 retn
.text$mn:00007C0C ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp
.text$mn:00007C0C
.text$mn:00007C0C ; ---------------------------------------------------------------------------
.text$mn:00007C0D                 align 10h
.text$mn:00007C0D _text$mn        ends
.text$mn:00007C0D
.text$mn:00007C10 ; ===========================================================================
.text$mn:00007C10
.text$mn:00007C10 ; Segment type: Pure code
.text$mn:00007C10 ; Segment permissions: Read/Execute
.text$mn:00007C10 _text$mn        segment para public 'CODE' use32
.text$mn:00007C10                 assume cs:_text$mn
.text$mn:00007C10                 ;org 7C10h
.text$mn:00007C10 ; COMDAT (pick any)
.text$mn:00007C10                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007C10
.text$mn:00007C10 ; =============== S U B R O U T I N E =======================================
.text$mn:00007C10
.text$mn:00007C10 ; Attributes: bp-based frame
.text$mn:00007C10
.text$mn:00007C10 ; public: struct std::_Container_proxy * __thiscall std::_Wrap_alloc<struct std::_Wrap_alloc<class std::allocator<struct std::_Container_proxy>>>::allocate(unsigned int)
.text$mn:00007C10                 public ?allocate@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z
.text$mn:00007C10 ?allocate@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z proc near
.text$mn:00007C10                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>>::_Alloc_proxy(void)+16p
.text$mn:00007C10
.text$mn:00007C10 var_4           = dword ptr -4
.text$mn:00007C10 arg_0           = dword ptr  8
.text$mn:00007C10
.text$mn:00007C10                 push    ebp
.text$mn:00007C11                 mov     ebp, esp
.text$mn:00007C13                 push    ecx
.text$mn:00007C14                 mov     [ebp+var_4], ecx
.text$mn:00007C17                 mov     eax, [ebp+arg_0]
.text$mn:00007C1A                 push    eax
.text$mn:00007C1B                 mov     ecx, [ebp+var_4]
.text$mn:00007C1E                 call    ?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::allocate(uint)
.text$mn:00007C23                 mov     esp, ebp
.text$mn:00007C25                 pop     ebp
.text$mn:00007C26                 retn    4
.text$mn:00007C26 ?allocate@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z endp
.text$mn:00007C26
.text$mn:00007C26 ; ---------------------------------------------------------------------------
.text$mn:00007C29                 align 4
.text$mn:00007C29 _text$mn        ends
.text$mn:00007C29
.text$mn:00007C2C ; ===========================================================================
.text$mn:00007C2C
.text$mn:00007C2C ; Segment type: Pure code
.text$mn:00007C2C ; Segment permissions: Read/Execute
.text$mn:00007C2C _text$mn        segment para public 'CODE' use32
.text$mn:00007C2C                 assume cs:_text$mn
.text$mn:00007C2C                 ;org 7C2Ch
.text$mn:00007C2C ; COMDAT (pick any)
.text$mn:00007C2C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007C2C
.text$mn:00007C2C ; =============== S U B R O U T I N E =======================================
.text$mn:00007C2C
.text$mn:00007C2C ; Attributes: bp-based frame
.text$mn:00007C2C
.text$mn:00007C2C ; public: class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>> * __thiscall std::_Wrap_alloc<struct std::_Wrap_alloc<class std::allocator<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>>>>::allocate(unsigned int)
.text$mn:00007C2C                 public ?allocate@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAEPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@I@Z
.text$mn:00007C2C ?allocate@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAEPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@I@Z proc near
.text$mn:00007C2C                                         ; CODE XREF: ?_Insert_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CB
.text$mn:00007C2C
.text$mn:00007C2C var_4           = dword ptr -4
.text$mn:00007C2C arg_0           = dword ptr  8
.text$mn:00007C2C
.text$mn:00007C2C                 push    ebp
.text$mn:00007C2D                 mov     ebp, esp
.text$mn:00007C2F                 push    ecx
.text$mn:00007C30                 mov     [ebp+var_4], ecx
.text$mn:00007C33                 mov     eax, [ebp+arg_0]
.text$mn:00007C36                 push    eax
.text$mn:00007C37                 mov     ecx, [ebp+var_4]
.text$mn:00007C3A                 call    ?allocate@?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAEPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>::allocate(uint)
.text$mn:00007C3F                 mov     esp, ebp
.text$mn:00007C41                 pop     ebp
.text$mn:00007C42                 retn    4
.text$mn:00007C42 ?allocate@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAEPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@I@Z endp
.text$mn:00007C42
.text$mn:00007C42 ; ---------------------------------------------------------------------------
.text$mn:00007C45                 align 4
.text$mn:00007C45 _text$mn        ends
.text$mn:00007C45
.text$mn:00007C48 ; ===========================================================================
.text$mn:00007C48
.text$mn:00007C48 ; Segment type: Pure code
.text$mn:00007C48 ; Segment permissions: Read/Execute
.text$mn:00007C48 _text$mn        segment para public 'CODE' use32
.text$mn:00007C48                 assume cs:_text$mn
.text$mn:00007C48                 ;org 7C48h
.text$mn:00007C48 ; COMDAT (pick any)
.text$mn:00007C48                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007C48
.text$mn:00007C48 ; =============== S U B R O U T I N E =======================================
.text$mn:00007C48
.text$mn:00007C48 ; Attributes: bp-based frame
.text$mn:00007C48
.text$mn:00007C48 ; public: char * __thiscall std::_Wrap_alloc<class std::allocator<char>>::allocate(unsigned int)
.text$mn:00007C48                 public ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
.text$mn:00007C48 ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z proc near
.text$mn:00007C48                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+BBp
.text$mn:00007C48                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+22p
.text$mn:00007C48
.text$mn:00007C48 var_4           = dword ptr -4
.text$mn:00007C48 arg_0           = dword ptr  8
.text$mn:00007C48
.text$mn:00007C48                 push    ebp
.text$mn:00007C49                 mov     ebp, esp
.text$mn:00007C4B                 push    ecx
.text$mn:00007C4C                 mov     [ebp+var_4], ecx
.text$mn:00007C4F                 mov     eax, [ebp+arg_0]
.text$mn:00007C52                 push    eax
.text$mn:00007C53                 mov     ecx, [ebp+var_4]
.text$mn:00007C56                 call    ?allocate@?$allocator@D@std@@QAEPADI@Z ; std::allocator<char>::allocate(uint)
.text$mn:00007C5B                 mov     esp, ebp
.text$mn:00007C5D                 pop     ebp
.text$mn:00007C5E                 retn    4
.text$mn:00007C5E ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z endp
.text$mn:00007C5E
.text$mn:00007C5E ; ---------------------------------------------------------------------------
.text$mn:00007C61                 align 4
.text$mn:00007C61 _text$mn        ends
.text$mn:00007C61
.text$mn:00007C64 ; ===========================================================================
.text$mn:00007C64
.text$mn:00007C64 ; Segment type: Pure code
.text$mn:00007C64 ; Segment permissions: Read/Execute
.text$mn:00007C64 _text$mn        segment para public 'CODE' use32
.text$mn:00007C64                 assume cs:_text$mn
.text$mn:00007C64                 ;org 7C64h
.text$mn:00007C64 ; COMDAT (pick any)
.text$mn:00007C64                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007C64
.text$mn:00007C64 ; =============== S U B R O U T I N E =======================================
.text$mn:00007C64
.text$mn:00007C64 ; Attributes: bp-based frame
.text$mn:00007C64
.text$mn:00007C64 ; public: class ScintillaEditView * * __thiscall std::_Wrap_alloc<class std::allocator<class ScintillaEditView *>>::allocate(unsigned int)
.text$mn:00007C64                 public ?allocate@?$_Wrap_alloc@V?$allocator@PAVScintillaEditView@@@std@@@std@@QAEPAPAVScintillaEditView@@I@Z
.text$mn:00007C64 ?allocate@?$_Wrap_alloc@V?$allocator@PAVScintillaEditView@@@std@@@std@@QAEPAPAVScintillaEditView@@I@Z proc near
.text$mn:00007C64                                         ; CODE XREF: std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::_Reallocate(uint)+41p
.text$mn:00007C64
.text$mn:00007C64 var_4           = dword ptr -4
.text$mn:00007C64 arg_0           = dword ptr  8
.text$mn:00007C64
.text$mn:00007C64                 push    ebp
.text$mn:00007C65                 mov     ebp, esp
.text$mn:00007C67                 push    ecx
.text$mn:00007C68                 mov     [ebp+var_4], ecx
.text$mn:00007C6B                 mov     eax, [ebp+arg_0]
.text$mn:00007C6E                 push    eax
.text$mn:00007C6F                 mov     ecx, [ebp+var_4]
.text$mn:00007C72                 call    ?allocate@?$allocator@PAVScintillaEditView@@@std@@QAEPAPAVScintillaEditView@@I@Z ; std::allocator<ScintillaEditView *>::allocate(uint)
.text$mn:00007C77                 mov     esp, ebp
.text$mn:00007C79                 pop     ebp
.text$mn:00007C7A                 retn    4
.text$mn:00007C7A ?allocate@?$_Wrap_alloc@V?$allocator@PAVScintillaEditView@@@std@@@std@@QAEPAPAVScintillaEditView@@I@Z endp
.text$mn:00007C7A
.text$mn:00007C7A ; ---------------------------------------------------------------------------
.text$mn:00007C7D                 align 10h
.text$mn:00007C7D _text$mn        ends
.text$mn:00007C7D
.text$mn:00007C80 ; ===========================================================================
.text$mn:00007C80
.text$mn:00007C80 ; Segment type: Pure code
.text$mn:00007C80 ; Segment permissions: Read/Execute
.text$mn:00007C80 _text$mn        segment para public 'CODE' use32
.text$mn:00007C80                 assume cs:_text$mn
.text$mn:00007C80                 ;org 7C80h
.text$mn:00007C80 ; COMDAT (pick any)
.text$mn:00007C80                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007C80
.text$mn:00007C80 ; =============== S U B R O U T I N E =======================================
.text$mn:00007C80
.text$mn:00007C80 ; Attributes: bp-based frame
.text$mn:00007C80
.text$mn:00007C80 ; public: struct std::_List_node<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>, void *> * __thiscall std::_Wrap_alloc<class std::allocator<struct std::_List_node<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>, void *>>>::allocate(unsigned int)
.text$mn:00007C80                 public ?allocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@2@I@Z
.text$mn:00007C80 ?allocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@2@I@Z proc near
.text$mn:00007C80                                         ; CODE XREF: std::_List_alloc<0,std::_List_base_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::_Buynode0(std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *,std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *)+3Fp
.text$mn:00007C80
.text$mn:00007C80 var_4           = dword ptr -4
.text$mn:00007C80 arg_0           = dword ptr  8
.text$mn:00007C80
.text$mn:00007C80                 push    ebp
.text$mn:00007C81                 mov     ebp, esp
.text$mn:00007C83                 push    ecx
.text$mn:00007C84                 mov     [ebp+var_4], ecx
.text$mn:00007C87                 mov     eax, [ebp+arg_0]
.text$mn:00007C8A                 push    eax
.text$mn:00007C8B                 mov     ecx, [ebp+var_4]
.text$mn:00007C8E                 call    ?allocate@?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@QAEPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@2@I@Z ; std::allocator<std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *>>::allocate(uint)
.text$mn:00007C93                 mov     esp, ebp
.text$mn:00007C95                 pop     ebp
.text$mn:00007C96                 retn    4
.text$mn:00007C96 ?allocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@2@I@Z endp
.text$mn:00007C96
.text$mn:00007C96 ; ---------------------------------------------------------------------------
.text$mn:00007C99                 align 4
.text$mn:00007C99 _text$mn        ends
.text$mn:00007C99
.text$mn:00007C9C ; ===========================================================================
.text$mn:00007C9C
.text$mn:00007C9C ; Segment type: Pure code
.text$mn:00007C9C ; Segment permissions: Read/Execute
.text$mn:00007C9C _text$mn        segment para public 'CODE' use32
.text$mn:00007C9C                 assume cs:_text$mn
.text$mn:00007C9C                 ;org 7C9Ch
.text$mn:00007C9C ; COMDAT (pick any)
.text$mn:00007C9C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007C9C
.text$mn:00007C9C ; =============== S U B R O U T I N E =======================================
.text$mn:00007C9C
.text$mn:00007C9C ; Attributes: bp-based frame
.text$mn:00007C9C
.text$mn:00007C9C ; public: struct std::_Container_proxy * __thiscall std::_Wrap_alloc<class std::allocator<struct std::_Container_proxy>>::allocate(unsigned int)
.text$mn:00007C9C                 public ?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z
.text$mn:00007C9C ?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z proc near
.text$mn:00007C9C                                         ; CODE XREF: std::_List_alloc<0,std::_List_base_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::_Alloc_proxy(void)+16p
.text$mn:00007C9C                                         ; std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_Container_proxy>>>::allocate(uint)+Ep
.text$mn:00007C9C
.text$mn:00007C9C var_4           = dword ptr -4
.text$mn:00007C9C arg_0           = dword ptr  8
.text$mn:00007C9C
.text$mn:00007C9C                 push    ebp
.text$mn:00007C9D                 mov     ebp, esp
.text$mn:00007C9F                 push    ecx
.text$mn:00007CA0                 mov     [ebp+var_4], ecx
.text$mn:00007CA3                 mov     eax, [ebp+arg_0]
.text$mn:00007CA6                 push    eax
.text$mn:00007CA7                 mov     ecx, [ebp+var_4]
.text$mn:00007CAA                 call    ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate(uint)
.text$mn:00007CAF                 mov     esp, ebp
.text$mn:00007CB1                 pop     ebp
.text$mn:00007CB2                 retn    4
.text$mn:00007CB2 ?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z endp
.text$mn:00007CB2
.text$mn:00007CB2 ; ---------------------------------------------------------------------------
.text$mn:00007CB5                 align 4
.text$mn:00007CB5 _text$mn        ends
.text$mn:00007CB5
.text$mn:00007CB8 ; ===========================================================================
.text$mn:00007CB8
.text$mn:00007CB8 ; Segment type: Pure code
.text$mn:00007CB8 ; Segment permissions: Read/Execute
.text$mn:00007CB8 _text$mn        segment para public 'CODE' use32
.text$mn:00007CB8                 assume cs:_text$mn
.text$mn:00007CB8                 ;org 7CB8h
.text$mn:00007CB8 ; COMDAT (pick any)
.text$mn:00007CB8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007CB8
.text$mn:00007CB8 ; =============== S U B R O U T I N E =======================================
.text$mn:00007CB8
.text$mn:00007CB8 ; Attributes: bp-based frame
.text$mn:00007CB8
.text$mn:00007CB8 ; public: class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>> * __thiscall std::_Wrap_alloc<class std::allocator<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>>>::allocate(unsigned int)
.text$mn:00007CB8                 public ?allocate@?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAEPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@I@Z
.text$mn:00007CB8 ?allocate@?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAEPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@I@Z proc near
.text$mn:00007CB8                                         ; CODE XREF: std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::allocate(uint)+Ep
.text$mn:00007CB8
.text$mn:00007CB8 var_4           = dword ptr -4
.text$mn:00007CB8 arg_0           = dword ptr  8
.text$mn:00007CB8
.text$mn:00007CB8                 push    ebp
.text$mn:00007CB9                 mov     ebp, esp
.text$mn:00007CBB                 push    ecx
.text$mn:00007CBC                 mov     [ebp+var_4], ecx
.text$mn:00007CBF                 mov     eax, [ebp+arg_0]
.text$mn:00007CC2                 push    eax
.text$mn:00007CC3                 mov     ecx, [ebp+var_4]
.text$mn:00007CC6                 call    ?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@QAEPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@I@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>::allocate(uint)
.text$mn:00007CCB                 mov     esp, ebp
.text$mn:00007CCD                 pop     ebp
.text$mn:00007CCE                 retn    4
.text$mn:00007CCE ?allocate@?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAEPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@I@Z endp
.text$mn:00007CCE
.text$mn:00007CCE ; ---------------------------------------------------------------------------
.text$mn:00007CD1                 align 4
.text$mn:00007CD1 _text$mn        ends
.text$mn:00007CD1
.text$mn:00007CD4 ; ===========================================================================
.text$mn:00007CD4
.text$mn:00007CD4 ; Segment type: Pure code
.text$mn:00007CD4 ; Segment permissions: Read/Execute
.text$mn:00007CD4 _text$mn        segment para public 'CODE' use32
.text$mn:00007CD4                 assume cs:_text$mn
.text$mn:00007CD4                 ;org 7CD4h
.text$mn:00007CD4 ; COMDAT (pick any)
.text$mn:00007CD4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007CD4
.text$mn:00007CD4 ; =============== S U B R O U T I N E =======================================
.text$mn:00007CD4
.text$mn:00007CD4 ; Attributes: bp-based frame
.text$mn:00007CD4
.text$mn:00007CD4 ; public: char * __thiscall std::allocator<char>::allocate(unsigned int)
.text$mn:00007CD4                 public ?allocate@?$allocator@D@std@@QAEPADI@Z
.text$mn:00007CD4 ?allocate@?$allocator@D@std@@QAEPADI@Z proc near
.text$mn:00007CD4                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::allocate(uint)+Ep
.text$mn:00007CD4
.text$mn:00007CD4 var_4           = dword ptr -4
.text$mn:00007CD4 arg_0           = dword ptr  8
.text$mn:00007CD4
.text$mn:00007CD4                 push    ebp
.text$mn:00007CD5                 mov     ebp, esp
.text$mn:00007CD7                 push    ecx
.text$mn:00007CD8                 mov     [ebp+var_4], ecx
.text$mn:00007CDB                 push    0
.text$mn:00007CDD                 mov     eax, [ebp+arg_0]
.text$mn:00007CE0                 push    eax
.text$mn:00007CE1                 call    ??$_Allocate@D@std@@YAPADIPAD@Z ; std::_Allocate<char>(uint,char *)
.text$mn:00007CE6                 add     esp, 8
.text$mn:00007CE9                 mov     esp, ebp
.text$mn:00007CEB                 pop     ebp
.text$mn:00007CEC                 retn    4
.text$mn:00007CEC ?allocate@?$allocator@D@std@@QAEPADI@Z endp
.text$mn:00007CEC
.text$mn:00007CEC ; ---------------------------------------------------------------------------
.text$mn:00007CEF                 align 10h
.text$mn:00007CEF _text$mn        ends
.text$mn:00007CEF
.text$mn:00007CF0 ; ===========================================================================
.text$mn:00007CF0
.text$mn:00007CF0 ; Segment type: Pure code
.text$mn:00007CF0 ; Segment permissions: Read/Execute
.text$mn:00007CF0 _text$mn        segment para public 'CODE' use32
.text$mn:00007CF0                 assume cs:_text$mn
.text$mn:00007CF0                 ;org 7CF0h
.text$mn:00007CF0 ; COMDAT (pick any)
.text$mn:00007CF0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007CF0
.text$mn:00007CF0 ; =============== S U B R O U T I N E =======================================
.text$mn:00007CF0
.text$mn:00007CF0 ; Attributes: bp-based frame
.text$mn:00007CF0
.text$mn:00007CF0 ; public: class ScintillaEditView * * __thiscall std::allocator<class ScintillaEditView *>::allocate(unsigned int)
.text$mn:00007CF0                 public ?allocate@?$allocator@PAVScintillaEditView@@@std@@QAEPAPAVScintillaEditView@@I@Z
.text$mn:00007CF0 ?allocate@?$allocator@PAVScintillaEditView@@@std@@QAEPAPAVScintillaEditView@@I@Z proc near
.text$mn:00007CF0                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<ScintillaEditView *>>::allocate(uint)+Ep
.text$mn:00007CF0
.text$mn:00007CF0 var_4           = dword ptr -4
.text$mn:00007CF0 arg_0           = dword ptr  8
.text$mn:00007CF0
.text$mn:00007CF0                 push    ebp
.text$mn:00007CF1                 mov     ebp, esp
.text$mn:00007CF3                 push    ecx
.text$mn:00007CF4                 mov     [ebp+var_4], ecx
.text$mn:00007CF7                 push    0
.text$mn:00007CF9                 mov     eax, [ebp+arg_0]
.text$mn:00007CFC                 push    eax
.text$mn:00007CFD                 call    ??$_Allocate@PAVScintillaEditView@@@std@@YAPAPAVScintillaEditView@@IPAPAV1@@Z ; std::_Allocate<ScintillaEditView *>(uint,ScintillaEditView * *)
.text$mn:00007D02                 add     esp, 8
.text$mn:00007D05                 mov     esp, ebp
.text$mn:00007D07                 pop     ebp
.text$mn:00007D08                 retn    4
.text$mn:00007D08 ?allocate@?$allocator@PAVScintillaEditView@@@std@@QAEPAPAVScintillaEditView@@I@Z endp
.text$mn:00007D08
.text$mn:00007D08 ; ---------------------------------------------------------------------------
.text$mn:00007D0B                 align 4
.text$mn:00007D0B _text$mn        ends
.text$mn:00007D0B
.text$mn:00007D0C ; ===========================================================================
.text$mn:00007D0C
.text$mn:00007D0C ; Segment type: Pure code
.text$mn:00007D0C ; Segment permissions: Read/Execute
.text$mn:00007D0C _text$mn        segment para public 'CODE' use32
.text$mn:00007D0C                 assume cs:_text$mn
.text$mn:00007D0C                 ;org 7D0Ch
.text$mn:00007D0C ; COMDAT (pick any)
.text$mn:00007D0C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007D0C
.text$mn:00007D0C ; =============== S U B R O U T I N E =======================================
.text$mn:00007D0C
.text$mn:00007D0C ; Attributes: bp-based frame
.text$mn:00007D0C
.text$mn:00007D0C ; public: struct std::_List_node<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>, void *> * __thiscall std::allocator<struct std::_List_node<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>, void *>>::allocate(unsigned int)
.text$mn:00007D0C                 public ?allocate@?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@QAEPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@2@I@Z
.text$mn:00007D0C ?allocate@?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@QAEPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@2@I@Z proc near
.text$mn:00007D0C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *>>>::allocate(uint)+Ep
.text$mn:00007D0C
.text$mn:00007D0C var_4           = dword ptr -4
.text$mn:00007D0C arg_0           = dword ptr  8
.text$mn:00007D0C
.text$mn:00007D0C                 push    ebp
.text$mn:00007D0D                 mov     ebp, esp
.text$mn:00007D0F                 push    ecx
.text$mn:00007D10                 mov     [ebp+var_4], ecx
.text$mn:00007D13                 push    0
.text$mn:00007D15                 mov     eax, [ebp+arg_0]
.text$mn:00007D18                 push    eax
.text$mn:00007D19                 call    ??$_Allocate@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@YAPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@0@IPAU10@@Z ; std::_Allocate<std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *>>(uint,std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *)
.text$mn:00007D1E                 add     esp, 8
.text$mn:00007D21                 mov     esp, ebp
.text$mn:00007D23                 pop     ebp
.text$mn:00007D24                 retn    4
.text$mn:00007D24 ?allocate@?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@QAEPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@2@I@Z endp
.text$mn:00007D24
.text$mn:00007D24 ; ---------------------------------------------------------------------------
.text$mn:00007D27                 align 4
.text$mn:00007D27 _text$mn        ends
.text$mn:00007D27
.text$mn:00007D28 ; ===========================================================================
.text$mn:00007D28
.text$mn:00007D28 ; Segment type: Pure code
.text$mn:00007D28 ; Segment permissions: Read/Execute
.text$mn:00007D28 _text$mn        segment para public 'CODE' use32
.text$mn:00007D28                 assume cs:_text$mn
.text$mn:00007D28                 ;org 7D28h
.text$mn:00007D28 ; COMDAT (pick any)
.text$mn:00007D28                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007D28
.text$mn:00007D28 ; =============== S U B R O U T I N E =======================================
.text$mn:00007D28
.text$mn:00007D28 ; Attributes: bp-based frame
.text$mn:00007D28
.text$mn:00007D28 ; public: struct std::_Container_proxy * __thiscall std::allocator<struct std::_Container_proxy>::allocate(unsigned int)
.text$mn:00007D28                 public ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z
.text$mn:00007D28 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z proc near
.text$mn:00007D28                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+16p
.text$mn:00007D28                                         ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::allocate(uint)+Ep
.text$mn:00007D28
.text$mn:00007D28 var_4           = dword ptr -4
.text$mn:00007D28 arg_0           = dword ptr  8
.text$mn:00007D28
.text$mn:00007D28                 push    ebp
.text$mn:00007D29                 mov     ebp, esp
.text$mn:00007D2B                 push    ecx
.text$mn:00007D2C                 mov     [ebp+var_4], ecx
.text$mn:00007D2F                 push    0
.text$mn:00007D31                 mov     eax, [ebp+arg_0]
.text$mn:00007D34                 push    eax
.text$mn:00007D35                 call    ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)
.text$mn:00007D3A                 add     esp, 8
.text$mn:00007D3D                 mov     esp, ebp
.text$mn:00007D3F                 pop     ebp
.text$mn:00007D40                 retn    4
.text$mn:00007D40 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z endp
.text$mn:00007D40
.text$mn:00007D40 ; ---------------------------------------------------------------------------
.text$mn:00007D43                 align 4
.text$mn:00007D43 _text$mn        ends
.text$mn:00007D43
.text$mn:00007D44 ; ===========================================================================
.text$mn:00007D44
.text$mn:00007D44 ; Segment type: Pure code
.text$mn:00007D44 ; Segment permissions: Read/Execute
.text$mn:00007D44 _text$mn        segment para public 'CODE' use32
.text$mn:00007D44                 assume cs:_text$mn
.text$mn:00007D44                 ;org 7D44h
.text$mn:00007D44 ; COMDAT (pick any)
.text$mn:00007D44                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007D44
.text$mn:00007D44 ; =============== S U B R O U T I N E =======================================
.text$mn:00007D44
.text$mn:00007D44 ; Attributes: bp-based frame
.text$mn:00007D44
.text$mn:00007D44 ; public: class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>> * __thiscall std::allocator<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>>::allocate(unsigned int)
.text$mn:00007D44                 public ?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@QAEPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@I@Z
.text$mn:00007D44 ?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@QAEPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@I@Z proc near
.text$mn:00007D44                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>::allocate(uint)+Ep
.text$mn:00007D44
.text$mn:00007D44 var_4           = dword ptr -4
.text$mn:00007D44 arg_0           = dword ptr  8
.text$mn:00007D44
.text$mn:00007D44                 push    ebp
.text$mn:00007D45                 mov     ebp, esp
.text$mn:00007D47                 push    ecx
.text$mn:00007D48                 mov     [ebp+var_4], ecx
.text$mn:00007D4B                 push    0
.text$mn:00007D4D                 mov     eax, [ebp+arg_0]
.text$mn:00007D50                 push    eax
.text$mn:00007D51                 call    ??$_Allocate@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@IPAV10@@Z ; std::_Allocate<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>(uint,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *)
.text$mn:00007D56                 add     esp, 8
.text$mn:00007D59                 mov     esp, ebp
.text$mn:00007D5B                 pop     ebp
.text$mn:00007D5C                 retn    4
.text$mn:00007D5C ?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@QAEPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@I@Z endp
.text$mn:00007D5C
.text$mn:00007D5C ; ---------------------------------------------------------------------------
.text$mn:00007D5F                 align 10h
.text$mn:00007D5F _text$mn        ends
.text$mn:00007D5F
.text$mn:00007D60 ; ===========================================================================
.text$mn:00007D60
.text$mn:00007D60 ; Segment type: Pure code
.text$mn:00007D60 ; Segment permissions: Read/Execute
.text$mn:00007D60 _text$mn        segment para public 'CODE' use32
.text$mn:00007D60                 assume cs:_text$mn
.text$mn:00007D60                 ;org 7D60h
.text$mn:00007D60 ; COMDAT (pick any)
.text$mn:00007D60                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007D60
.text$mn:00007D60 ; =============== S U B R O U T I N E =======================================
.text$mn:00007D60
.text$mn:00007D60 ; Attributes: bp-based frame
.text$mn:00007D60
.text$mn:00007D60 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::assign(class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> const &, unsigned int, unsigned int)
.text$mn:00007D60                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
.text$mn:00007D60 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z proc near
.text$mn:00007D60                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+4Fp
.text$mn:00007D60
.text$mn:00007D60 Size            = dword ptr -8
.text$mn:00007D60 var_4           = dword ptr -4
.text$mn:00007D60 arg_0           = dword ptr  8
.text$mn:00007D60 arg_4           = dword ptr  0Ch
.text$mn:00007D60 arg_8           = dword ptr  10h
.text$mn:00007D60
.text$mn:00007D60                 push    ebp
.text$mn:00007D61                 mov     ebp, esp
.text$mn:00007D63                 sub     esp, 8
.text$mn:00007D66                 mov     [ebp+var_4], ecx
.text$mn:00007D69                 mov     ecx, [ebp+arg_0]
.text$mn:00007D6C                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:00007D71                 cmp     eax, [ebp+arg_4]
.text$mn:00007D74                 jnb     short loc_7D7E
.text$mn:00007D76                 mov     ecx, [ebp+var_4]
.text$mn:00007D79                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:00007D7E
.text$mn:00007D7E loc_7D7E:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+14j
.text$mn:00007D7E                 mov     ecx, [ebp+arg_0]
.text$mn:00007D81                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:00007D86                 sub     eax, [ebp+arg_4]
.text$mn:00007D89                 mov     [ebp+Size], eax
.text$mn:00007D8C                 mov     eax, [ebp+arg_8]
.text$mn:00007D8F                 cmp     eax, [ebp+Size]
.text$mn:00007D92                 jnb     short loc_7D9A
.text$mn:00007D94                 mov     ecx, [ebp+arg_8]
.text$mn:00007D97                 mov     [ebp+Size], ecx
.text$mn:00007D9A
.text$mn:00007D9A loc_7D9A:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+32j
.text$mn:00007D9A                 mov     edx, [ebp+var_4]
.text$mn:00007D9D                 cmp     edx, [ebp+arg_0]
.text$mn:00007DA0                 jnz     short loc_7DC1
.text$mn:00007DA2                 mov     eax, [ebp+arg_4]
.text$mn:00007DA5                 add     eax, [ebp+Size]
.text$mn:00007DA8                 push    eax
.text$mn:00007DA9                 mov     ecx, [ebp+var_4]
.text$mn:00007DAC                 call    ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)
.text$mn:00007DB1                 mov     ecx, [ebp+arg_4]
.text$mn:00007DB4                 push    ecx
.text$mn:00007DB5                 push    0
.text$mn:00007DB7                 mov     ecx, [ebp+var_4]
.text$mn:00007DBA                 call    ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)
.text$mn:00007DBF                 jmp     short loc_7E03
.text$mn:00007DC1 ; ---------------------------------------------------------------------------
.text$mn:00007DC1
.text$mn:00007DC1 loc_7DC1:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+40j
.text$mn:00007DC1                 push    0
.text$mn:00007DC3                 mov     edx, [ebp+Size]
.text$mn:00007DC6                 push    edx
.text$mn:00007DC7                 mov     ecx, [ebp+var_4]
.text$mn:00007DCA                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:00007DCF                 movzx   eax, al
.text$mn:00007DD2                 test    eax, eax
.text$mn:00007DD4                 jz      short loc_7E03
.text$mn:00007DD6                 mov     ecx, [ebp+Size]
.text$mn:00007DD9                 push    ecx             ; Size
.text$mn:00007DDA                 mov     ecx, [ebp+arg_0]
.text$mn:00007DDD                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00007DE2                 add     eax, [ebp+arg_4]
.text$mn:00007DE5                 push    eax             ; Src
.text$mn:00007DE6                 mov     ecx, [ebp+var_4]
.text$mn:00007DE9                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00007DEE                 push    eax             ; Dst
.text$mn:00007DEF                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00007DF4                 add     esp, 0Ch
.text$mn:00007DF7                 mov     edx, [ebp+Size]
.text$mn:00007DFA                 push    edx
.text$mn:00007DFB                 mov     ecx, [ebp+var_4]
.text$mn:00007DFE                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00007E03
.text$mn:00007E03 loc_7E03:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+5Fj
.text$mn:00007E03                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+74j
.text$mn:00007E03                 mov     eax, [ebp+var_4]
.text$mn:00007E06                 mov     esp, ebp
.text$mn:00007E08                 pop     ebp
.text$mn:00007E09                 retn    0Ch
.text$mn:00007E09 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z endp
.text$mn:00007E09
.text$mn:00007E09 _text$mn        ends
.text$mn:00007E09
.text$mn:00007E0C ; ===========================================================================
.text$mn:00007E0C
.text$mn:00007E0C ; Segment type: Pure code
.text$mn:00007E0C ; Segment permissions: Read/Execute
.text$mn:00007E0C _text$mn        segment para public 'CODE' use32
.text$mn:00007E0C                 assume cs:_text$mn
.text$mn:00007E0C                 ;org 7E0Ch
.text$mn:00007E0C ; COMDAT (pick any)
.text$mn:00007E0C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007E0C
.text$mn:00007E0C ; =============== S U B R O U T I N E =======================================
.text$mn:00007E0C
.text$mn:00007E0C ; Attributes: bp-based frame
.text$mn:00007E0C
.text$mn:00007E0C ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char *Str)
.text$mn:00007E0C                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
.text$mn:00007E0C ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z proc near
.text$mn:00007E0C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+53p
.text$mn:00007E0C
.text$mn:00007E0C var_4           = dword ptr -4
.text$mn:00007E0C Str             = dword ptr  8
.text$mn:00007E0C
.text$mn:00007E0C                 push    ebp
.text$mn:00007E0D                 mov     ebp, esp
.text$mn:00007E0F                 push    ecx
.text$mn:00007E10                 mov     [ebp+var_4], ecx
.text$mn:00007E13                 push    490h            ; unsigned int
.text$mn:00007E18                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00007E1D                 mov     eax, [ebp+Str]
.text$mn:00007E20                 push    eax             ; int
.text$mn:00007E21                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:00007E26                 add     esp, 0Ch
.text$mn:00007E29                 mov     ecx, [ebp+Str]
.text$mn:00007E2C                 push    ecx             ; Str
.text$mn:00007E2D                 call    ?length@?$char_traits@D@std@@SAIPBD@Z ; std::char_traits<char>::length(char const *)
.text$mn:00007E32                 add     esp, 4
.text$mn:00007E35                 push    eax             ; Size
.text$mn:00007E36                 mov     edx, [ebp+Str]
.text$mn:00007E39                 push    edx             ; Src
.text$mn:00007E3A                 mov     ecx, [ebp+var_4]
.text$mn:00007E3D                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)
.text$mn:00007E42                 mov     esp, ebp
.text$mn:00007E44                 pop     ebp
.text$mn:00007E45                 retn    4
.text$mn:00007E45 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z endp
.text$mn:00007E45
.text$mn:00007E45 _text$mn        ends
.text$mn:00007E45
.text$mn:00007E48 ; ===========================================================================
.text$mn:00007E48
.text$mn:00007E48 ; Segment type: Pure code
.text$mn:00007E48 ; Segment permissions: Read/Execute
.text$mn:00007E48 _text$mn        segment para public 'CODE' use32
.text$mn:00007E48                 assume cs:_text$mn
.text$mn:00007E48                 ;org 7E48h
.text$mn:00007E48 ; COMDAT (pick any)
.text$mn:00007E48                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007E48
.text$mn:00007E48 ; =============== S U B R O U T I N E =======================================
.text$mn:00007E48
.text$mn:00007E48 ; Attributes: bp-based frame
.text$mn:00007E48
.text$mn:00007E48 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(void *Src, size_t Size)
.text$mn:00007E48                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
.text$mn:00007E48 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z proc near
.text$mn:00007E48                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+31p
.text$mn:00007E48
.text$mn:00007E48 var_4           = dword ptr -4
.text$mn:00007E48 Src             = dword ptr  8
.text$mn:00007E48 Size            = dword ptr  0Ch
.text$mn:00007E48
.text$mn:00007E48                 push    ebp
.text$mn:00007E49                 mov     ebp, esp
.text$mn:00007E4B                 push    ecx
.text$mn:00007E4C                 mov     [ebp+var_4], ecx
.text$mn:00007E4F                 cmp     [ebp+Size], 0
.text$mn:00007E53                 jz      short loc_7E6B
.text$mn:00007E55                 push    47Fh            ; unsigned int
.text$mn:00007E5A                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00007E5F                 mov     eax, [ebp+Src]
.text$mn:00007E62                 push    eax             ; int
.text$mn:00007E63                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:00007E68                 add     esp, 0Ch
.text$mn:00007E6B
.text$mn:00007E6B loc_7E6B:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+Bj
.text$mn:00007E6B                 mov     ecx, [ebp+Src]
.text$mn:00007E6E                 push    ecx
.text$mn:00007E6F                 mov     ecx, [ebp+var_4]
.text$mn:00007E72                 call    ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)
.text$mn:00007E77                 movzx   edx, al
.text$mn:00007E7A                 test    edx, edx
.text$mn:00007E7C                 jz      short loc_7E9E
.text$mn:00007E7E                 mov     eax, [ebp+Size]
.text$mn:00007E81                 push    eax
.text$mn:00007E82                 mov     ecx, [ebp+var_4]
.text$mn:00007E85                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00007E8A                 mov     ecx, [ebp+Src]
.text$mn:00007E8D                 sub     ecx, eax
.text$mn:00007E8F                 push    ecx
.text$mn:00007E90                 mov     edx, [ebp+var_4]
.text$mn:00007E93                 push    edx
.text$mn:00007E94                 mov     ecx, [ebp+var_4]
.text$mn:00007E97                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)
.text$mn:00007E9C                 jmp     short loc_7EDB
.text$mn:00007E9E ; ---------------------------------------------------------------------------
.text$mn:00007E9E
.text$mn:00007E9E loc_7E9E:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+34j
.text$mn:00007E9E                 push    0
.text$mn:00007EA0                 mov     eax, [ebp+Size]
.text$mn:00007EA3                 push    eax
.text$mn:00007EA4                 mov     ecx, [ebp+var_4]
.text$mn:00007EA7                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:00007EAC                 movzx   ecx, al
.text$mn:00007EAF                 test    ecx, ecx
.text$mn:00007EB1                 jz      short loc_7ED8
.text$mn:00007EB3                 mov     edx, [ebp+Size]
.text$mn:00007EB6                 push    edx             ; Size
.text$mn:00007EB7                 mov     eax, [ebp+Src]
.text$mn:00007EBA                 push    eax             ; Src
.text$mn:00007EBB                 mov     ecx, [ebp+var_4]
.text$mn:00007EBE                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00007EC3                 push    eax             ; Dst
.text$mn:00007EC4                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00007EC9                 add     esp, 0Ch
.text$mn:00007ECC                 mov     ecx, [ebp+Size]
.text$mn:00007ECF                 push    ecx
.text$mn:00007ED0                 mov     ecx, [ebp+var_4]
.text$mn:00007ED3                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00007ED8
.text$mn:00007ED8 loc_7ED8:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+69j
.text$mn:00007ED8                 mov     eax, [ebp+var_4]
.text$mn:00007EDB
.text$mn:00007EDB loc_7EDB:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+54j
.text$mn:00007EDB                 mov     esp, ebp
.text$mn:00007EDD                 pop     ebp
.text$mn:00007EDE                 retn    8
.text$mn:00007EDE ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z endp
.text$mn:00007EDE
.text$mn:00007EDE ; ---------------------------------------------------------------------------
.text$mn:00007EE1                 align 4
.text$mn:00007EE1 _text$mn        ends
.text$mn:00007EE1
.text$mn:00007EE4 ; ===========================================================================
.text$mn:00007EE4
.text$mn:00007EE4 ; Segment type: Pure code
.text$mn:00007EE4 ; Segment permissions: Read/Execute
.text$mn:00007EE4 _text$mn        segment para public 'CODE' use32
.text$mn:00007EE4                 assume cs:_text$mn
.text$mn:00007EE4                 ;org 7EE4h
.text$mn:00007EE4 ; COMDAT (pick any)
.text$mn:00007EE4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007EE4
.text$mn:00007EE4 ; =============== S U B R O U T I N E =======================================
.text$mn:00007EE4
.text$mn:00007EE4 ; Attributes: bp-based frame
.text$mn:00007EE4
.text$mn:00007EE4 ; public: static void __cdecl std::char_traits<char>::assign(char &, char const &)
.text$mn:00007EE4                 public ?assign@?$char_traits@D@std@@SAXAADABD@Z
.text$mn:00007EE4 ?assign@?$char_traits@D@std@@SAXAADABD@Z proc near
.text$mn:00007EE4                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+26p
.text$mn:00007EE4
.text$mn:00007EE4 arg_0           = dword ptr  8
.text$mn:00007EE4 arg_4           = dword ptr  0Ch
.text$mn:00007EE4
.text$mn:00007EE4                 push    ebp
.text$mn:00007EE5                 mov     ebp, esp
.text$mn:00007EE7                 mov     eax, [ebp+arg_0]
.text$mn:00007EEA                 mov     ecx, [ebp+arg_4]
.text$mn:00007EED                 mov     dl, [ecx]
.text$mn:00007EEF                 mov     [eax], dl
.text$mn:00007EF1                 pop     ebp
.text$mn:00007EF2                 retn
.text$mn:00007EF2 ?assign@?$char_traits@D@std@@SAXAADABD@Z endp
.text$mn:00007EF2
.text$mn:00007EF2 ; ---------------------------------------------------------------------------
.text$mn:00007EF3                 align 4
.text$mn:00007EF3 _text$mn        ends
.text$mn:00007EF3
.text$mn:00007EF4 ; ===========================================================================
.text$mn:00007EF4
.text$mn:00007EF4 ; Segment type: Pure code
.text$mn:00007EF4 ; Segment permissions: Read/Execute
.text$mn:00007EF4 _text$mn        segment para public 'CODE' use32
.text$mn:00007EF4                 assume cs:_text$mn
.text$mn:00007EF4                 ;org 7EF4h
.text$mn:00007EF4 ; COMDAT (pick any)
.text$mn:00007EF4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007EF4
.text$mn:00007EF4 ; =============== S U B R O U T I N E =======================================
.text$mn:00007EF4
.text$mn:00007EF4 ; Attributes: bp-based frame
.text$mn:00007EF4
.text$mn:00007EF4 ; public: static void __cdecl std::char_traits<wchar_t>::assign(wchar_t &, wchar_t const &)
.text$mn:00007EF4                 public ?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z
.text$mn:00007EF4 ?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z proc near
.text$mn:00007EF4                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)+2Bp
.text$mn:00007EF4
.text$mn:00007EF4 arg_0           = dword ptr  8
.text$mn:00007EF4 arg_4           = dword ptr  0Ch
.text$mn:00007EF4
.text$mn:00007EF4                 push    ebp
.text$mn:00007EF5                 mov     ebp, esp
.text$mn:00007EF7                 mov     eax, [ebp+arg_0]
.text$mn:00007EFA                 mov     ecx, [ebp+arg_4]
.text$mn:00007EFD                 mov     dx, [ecx]
.text$mn:00007F00                 mov     [eax], dx
.text$mn:00007F03                 pop     ebp
.text$mn:00007F04                 retn
.text$mn:00007F04 ?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z endp
.text$mn:00007F04
.text$mn:00007F04 ; ---------------------------------------------------------------------------
.text$mn:00007F05                 align 4
.text$mn:00007F05 _text$mn        ends
.text$mn:00007F05
.text$mn:00007F08 ; ===========================================================================
.text$mn:00007F08
.text$mn:00007F08 ; Segment type: Pure code
.text$mn:00007F08 ; Segment permissions: Read/Execute
.text$mn:00007F08 _text$mn        segment para public 'CODE' use32
.text$mn:00007F08                 assume cs:_text$mn
.text$mn:00007F08                 ;org 7F08h
.text$mn:00007F08 ; COMDAT (pick any)
.text$mn:00007F08                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007F08
.text$mn:00007F08 ; =============== S U B R O U T I N E =======================================
.text$mn:00007F08
.text$mn:00007F08 ; Attributes: bp-based frame
.text$mn:00007F08
.text$mn:00007F08 ; public: void __thiscall std::vector<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>, struct std::_Wrap_alloc<class std::allocator<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>>>>::assign(unsigned int, class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>> const &)
.text$mn:00007F08                 public ?assign@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAEXIABV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@@Z
.text$mn:00007F08 ?assign@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAEXIABV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@@Z proc near
.text$mn:00007F08                                         ; CODE XREF: std::_Hash<std::_Umap_traits<Buffer *,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *,std::_Uhash_compare<Buffer *,std::hash<Buffer *>,std::equal_to<Buffer *>>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>,0>>::_Init(uint)+22p
.text$mn:00007F08
.text$mn:00007F08 var_40          = byte ptr -40h
.text$mn:00007F08 var_34          = byte ptr -34h
.text$mn:00007F08 var_28          = dword ptr -28h
.text$mn:00007F08 var_24          = dword ptr -24h
.text$mn:00007F08 var_20          = dword ptr -20h
.text$mn:00007F08 var_1C          = dword ptr -1Ch
.text$mn:00007F08 var_18          = dword ptr -18h
.text$mn:00007F08 var_14          = dword ptr -14h
.text$mn:00007F08 var_10          = dword ptr -10h
.text$mn:00007F08 var_C           = dword ptr -0Ch
.text$mn:00007F08 var_4           = dword ptr -4
.text$mn:00007F08 arg_0           = dword ptr  8
.text$mn:00007F08 arg_4           = dword ptr  0Ch
.text$mn:00007F08
.text$mn:00007F08                 push    ebp
.text$mn:00007F09                 mov     ebp, esp
.text$mn:00007F0B                 push    0FFFFFFFFh
.text$mn:00007F0D                 push    offset __ehhandler$?assign@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAEXIABV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@@Z
.text$mn:00007F12                 mov     eax, large fs:0
.text$mn:00007F18                 push    eax
.text$mn:00007F19                 sub     esp, 34h
.text$mn:00007F1C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00007F21                 xor     eax, ebp
.text$mn:00007F23                 push    eax
.text$mn:00007F24                 lea     eax, [ebp+var_C]
.text$mn:00007F27                 mov     large fs:0, eax
.text$mn:00007F2D                 mov     [ebp+var_10], ecx
.text$mn:00007F30                 mov     ecx, [ebp+var_10]
.text$mn:00007F33                 call    ?clear@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAEXXZ ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::clear(void)
.text$mn:00007F38                 mov     eax, [ebp+arg_4]
.text$mn:00007F3B                 push    eax
.text$mn:00007F3C                 mov     ecx, [ebp+arg_0]
.text$mn:00007F3F                 push    ecx
.text$mn:00007F40                 lea     edx, [ebp+var_40]
.text$mn:00007F43                 push    edx
.text$mn:00007F44                 mov     ecx, [ebp+var_10]
.text$mn:00007F47                 call    ?begin@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@XZ ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::begin(void)
.text$mn:00007F4C                 mov     [ebp+var_14], eax
.text$mn:00007F4F                 mov     eax, [ebp+var_14]
.text$mn:00007F52                 mov     [ebp+var_18], eax
.text$mn:00007F55                 mov     [ebp+var_4], 0
.text$mn:00007F5C                 sub     esp, 0Ch
.text$mn:00007F5F                 mov     ecx, esp
.text$mn:00007F61                 mov     [ebp+var_20], esp
.text$mn:00007F64                 mov     edx, [ebp+var_18]
.text$mn:00007F67                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:00007F68                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>> const &)
.text$mn:00007F6D                 mov     [ebp+var_1C], eax
.text$mn:00007F70                 mov     eax, [ebp+var_1C]
.text$mn:00007F73                 mov     [ebp+var_24], eax
.text$mn:00007F76                 mov     byte ptr [ebp+var_4], 1
.text$mn:00007F7A                 lea     ecx, [ebp+var_34]
.text$mn:00007F7D                 push    ecx
.text$mn:00007F7E                 mov     byte ptr [ebp+var_4], 0
.text$mn:00007F82                 mov     ecx, [ebp+var_10]
.text$mn:00007F85                 call    ?insert@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$C
.text$mn:00007F8A                 mov     [ebp+var_28], eax
.text$mn:00007F8D                 lea     ecx, [ebp+var_34]
.text$mn:00007F90                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>(void)
.text$mn:00007F95                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00007F9C                 lea     ecx, [ebp+var_40]
.text$mn:00007F9F                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>(void)
.text$mn:00007FA4                 mov     ecx, [ebp+var_C]
.text$mn:00007FA7                 mov     large fs:0, ecx
.text$mn:00007FAE                 pop     ecx
.text$mn:00007FAF                 mov     esp, ebp
.text$mn:00007FB1                 pop     ebp
.text$mn:00007FB2                 retn    8
.text$mn:00007FB2 ?assign@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAEXIABV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@@Z endp
.text$mn:00007FB2
.text$mn:00007FB2 ; ---------------------------------------------------------------------------
.text$mn:00007FB5                 align 4
.text$mn:00007FB5 _text$mn        ends
.text$mn:00007FB5
.text$x:00007FB8 ; ===========================================================================
.text$x:00007FB8
.text$x:00007FB8 ; Segment type: Pure code
.text$x:00007FB8 ; Segment permissions: Read/Execute
.text$x:00007FB8 _text$x         segment para public 'CODE' use32
.text$x:00007FB8                 assume cs:_text$x
.text$x:00007FB8                 ;org 7FB8h
.text$x:00007FB8 ; COMDAT (pick associative to section at 7F08)
.text$x:00007FB8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00007FB8
.text$x:00007FB8 ; =============== S U B R O U T I N E =======================================
.text$x:00007FB8
.text$x:00007FB8
.text$x:00007FB8 __unwindfunclet$?assign@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAEXIABV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@@Z$0 proc near
.text$x:00007FB8                                         ; DATA XREF: .xdata$x:0000A1FCo
.text$x:00007FB8                 lea     ecx, [ebp-40h]
.text$x:00007FBB                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>(void)
.text$x:00007FBB __unwindfunclet$?assign@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAEXIABV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@@Z$0 endp
.text$x:00007FBB
.text$x:00007FC0
.text$x:00007FC0 ; =============== S U B R O U T I N E =======================================
.text$x:00007FC0
.text$x:00007FC0
.text$x:00007FC0 __unwindfunclet$?assign@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAEXIABV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@@Z$1 proc near
.text$x:00007FC0                                         ; DATA XREF: .xdata$x:0000A204o
.text$x:00007FC0                 mov     ecx, [ebp-20h]
.text$x:00007FC3                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>(void)
.text$x:00007FC3 __unwindfunclet$?assign@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAEXIABV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@@Z$1 endp
.text$x:00007FC3
.text$x:00007FC8
.text$x:00007FC8 ; =============== S U B R O U T I N E =======================================
.text$x:00007FC8
.text$x:00007FC8
.text$x:00007FC8 __ehhandler$?assign@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAEXIABV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@@Z proc near
.text$x:00007FC8                                         ; DATA XREF: std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::assign(uint,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const &)+5o
.text$x:00007FC8
.text$x:00007FC8 arg_4           = dword ptr  8
.text$x:00007FC8
.text$x:00007FC8                 mov     edx, [esp+arg_4]
.text$x:00007FCC                 lea     eax, [edx+0Ch]
.text$x:00007FCF                 mov     ecx, [edx-38h]
.text$x:00007FD2                 xor     ecx, eax
.text$x:00007FD4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00007FD9                 mov     eax, offset __ehfuncinfo$?assign@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAEXIABV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@@Z
.text$x:00007FDE                 jmp     ___CxxFrameHandler3
.text$x:00007FDE __ehhandler$?assign@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAEXIABV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@@Z endp
.text$x:00007FDE
.text$x:00007FDE ; ---------------------------------------------------------------------------
.text$x:00007FE3                 align 4
.text$x:00007FE3 _text$x         ends
.text$x:00007FE3
.text$mn:00007FE4 ; ===========================================================================
.text$mn:00007FE4
.text$mn:00007FE4 ; Segment type: Pure code
.text$mn:00007FE4 ; Segment permissions: Read/Execute
.text$mn:00007FE4 _text$mn        segment para public 'CODE' use32
.text$mn:00007FE4                 assume cs:_text$mn
.text$mn:00007FE4                 ;org 7FE4h
.text$mn:00007FE4 ; COMDAT (pick any)
.text$mn:00007FE4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007FE4
.text$mn:00007FE4 ; =============== S U B R O U T I N E =======================================
.text$mn:00007FE4
.text$mn:00007FE4 ; Attributes: bp-based frame
.text$mn:00007FE4
.text$mn:00007FE4 ; public: class std::_List_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<int const, struct Style>>>> __thiscall std::_Hash<class std::_Umap_traits<int, struct Style, class std::_Uhash_compare<int, struct std::hash<int>, struct std::equal_to<int>>, class std::allocator<struct std::pair<int const, struct Style>>, 0>>::begin(void)
.text$mn:00007FE4                 public ?begin@?$_Hash@V?$_Umap_traits@HUStyle@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@2@XZ
.text$mn:00007FE4 ?begin@?$_Hash@V?$_Umap_traits@HUStyle@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@2@XZ proc near
.text$mn:00007FE4                                         ; CODE XREF: ScintillaEditView::~ScintillaEditView(void)+D6p
.text$mn:00007FE4
.text$mn:00007FE4 var_14          = dword ptr -14h
.text$mn:00007FE4 var_10          = dword ptr -10h
.text$mn:00007FE4 var_C           = dword ptr -0Ch
.text$mn:00007FE4 var_4           = dword ptr -4
.text$mn:00007FE4 arg_0           = dword ptr  8
.text$mn:00007FE4
.text$mn:00007FE4                 push    ebp
.text$mn:00007FE5                 mov     ebp, esp
.text$mn:00007FE7                 push    0FFFFFFFFh
.text$mn:00007FE9                 push    offset __ehhandler$?begin@?$_Hash@V?$_Umap_traits@HUStyle@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@2@XZ
.text$mn:00007FEE                 mov     eax, large fs:0
.text$mn:00007FF4                 push    eax
.text$mn:00007FF5                 sub     esp, 8
.text$mn:00007FF8                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00007FFD                 xor     eax, ebp
.text$mn:00007FFF                 push    eax
.text$mn:00008000                 lea     eax, [ebp+var_C]
.text$mn:00008003                 mov     large fs:0, eax
.text$mn:00008009                 mov     [ebp+var_14], ecx
.text$mn:0000800C                 mov     [ebp+var_10], 0
.text$mn:00008013                 mov     eax, [ebp+arg_0]
.text$mn:00008016                 push    eax
.text$mn:00008017                 mov     ecx, [ebp+var_14]
.text$mn:0000801A                 call    ?begin@?$list@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@2@XZ ; std::list<std::pair<int const,Style>,std::allocator<std::pair<int const,Style>>>::begin(void)
.text$mn:0000801F                 mov     [ebp+var_4], 0
.text$mn:00008026                 mov     ecx, [ebp+var_10]
.text$mn:00008029                 or      ecx, 1
.text$mn:0000802C                 mov     [ebp+var_10], ecx
.text$mn:0000802F                 mov     eax, [ebp+arg_0]
.text$mn:00008032                 mov     ecx, [ebp+var_C]
.text$mn:00008035                 mov     large fs:0, ecx
.text$mn:0000803C                 pop     ecx
.text$mn:0000803D                 mov     esp, ebp
.text$mn:0000803F                 pop     ebp
.text$mn:00008040                 retn    4
.text$mn:00008040 ?begin@?$_Hash@V?$_Umap_traits@HUStyle@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@2@XZ endp
.text$mn:00008040
.text$mn:00008040 ; ---------------------------------------------------------------------------
.text$mn:00008043                 align 4
.text$mn:00008043 _text$mn        ends
.text$mn:00008043
.text$x:00008044 ; ===========================================================================
.text$x:00008044
.text$x:00008044 ; Segment type: Pure code
.text$x:00008044 ; Segment permissions: Read/Execute
.text$x:00008044 _text$x         segment para public 'CODE' use32
.text$x:00008044                 assume cs:_text$x
.text$x:00008044                 ;org 8044h
.text$x:00008044 ; COMDAT (pick associative to section at 7FE4)
.text$x:00008044                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00008044
.text$x:00008044 ; =============== S U B R O U T I N E =======================================
.text$x:00008044
.text$x:00008044
.text$x:00008044 __unwindfunclet$?begin@?$_Hash@V?$_Umap_traits@HUStyle@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@2@XZ$0 proc near
.text$x:00008044                                         ; DATA XREF: .xdata$x:0000A65Co
.text$x:00008044                 mov     eax, [ebp-10h]
.text$x:00008047                 and     eax, 1
.text$x:0000804A                 jz      $LN4_7
.text$x:00008050                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:00008054                 mov     ecx, [ebp+8]
.text$x:00008057                 jmp     ??1?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>::~_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>(void)
.text$x:0000805C ; ---------------------------------------------------------------------------
.text$x:0000805C
.text$x:0000805C $LN4_7:                                 ; CODE XREF: __unwindfunclet$?begin@?$_Hash@V?$_Umap_traits@HUStyle@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@2@XZ$0+6j
.text$x:0000805C                 retn
.text$x:0000805C __unwindfunclet$?begin@?$_Hash@V?$_Umap_traits@HUStyle@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@2@XZ$0 endp
.text$x:0000805C
.text$x:0000805D
.text$x:0000805D ; =============== S U B R O U T I N E =======================================
.text$x:0000805D
.text$x:0000805D
.text$x:0000805D __ehhandler$?begin@?$_Hash@V?$_Umap_traits@HUStyle@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@2@XZ proc near
.text$x:0000805D                                         ; DATA XREF: std::_Hash<std::_Umap_traits<int,Style,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int>>,std::allocator<std::pair<int const,Style>>,0>>::begin(void)+5o
.text$x:0000805D
.text$x:0000805D arg_4           = dword ptr  8
.text$x:0000805D
.text$x:0000805D                 mov     edx, [esp+arg_4]
.text$x:00008061                 lea     eax, [edx+0Ch]
.text$x:00008064                 mov     ecx, [edx-0Ch]
.text$x:00008067                 xor     ecx, eax
.text$x:00008069                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000806E                 mov     eax, offset __ehfuncinfo$?begin@?$_Hash@V?$_Umap_traits@HUStyle@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@2@XZ
.text$x:00008073                 jmp     ___CxxFrameHandler3
.text$x:00008073 __ehhandler$?begin@?$_Hash@V?$_Umap_traits@HUStyle@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@2@XZ endp
.text$x:00008073
.text$x:00008073 _text$x         ends
.text$x:00008073
.text$mn:00008078 ; ===========================================================================
.text$mn:00008078
.text$mn:00008078 ; Segment type: Pure code
.text$mn:00008078 ; Segment permissions: Read/Execute
.text$mn:00008078 _text$mn        segment para public 'CODE' use32
.text$mn:00008078                 assume cs:_text$mn
.text$mn:00008078                 ;org 8078h
.text$mn:00008078 ; COMDAT (pick any)
.text$mn:00008078                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008078
.text$mn:00008078 ; =============== S U B R O U T I N E =======================================
.text$mn:00008078
.text$mn:00008078 ; Attributes: bp-based frame
.text$mn:00008078
.text$mn:00008078 ; public: class std::_List_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>> __thiscall std::_Hash<class std::_Umap_traits<class Buffer *, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *, class std::_Uhash_compare<class Buffer *, struct std::hash<class Buffer *>, struct std::equal_to<class Buffer *>>, class std::allocator<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>, 0>>::begin(void)
.text$mn:00008078                 public ?begin@?$_Hash@V?$_Umap_traits@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@V?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@XZ
.text$mn:00008078 ?begin@?$_Hash@V?$_Umap_traits@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@V?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@XZ proc near
.text$mn:00008078                                         ; CODE XREF: ScintillaEditView::~ScintillaEditView(void)+71p
.text$mn:00008078
.text$mn:00008078 var_14          = dword ptr -14h
.text$mn:00008078 var_10          = dword ptr -10h
.text$mn:00008078 var_C           = dword ptr -0Ch
.text$mn:00008078 var_4           = dword ptr -4
.text$mn:00008078 arg_0           = dword ptr  8
.text$mn:00008078
.text$mn:00008078                 push    ebp
.text$mn:00008079                 mov     ebp, esp
.text$mn:0000807B                 push    0FFFFFFFFh
.text$mn:0000807D                 push    offset __ehhandler$?begin@?$_Hash@V?$_Umap_traits@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@V?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@XZ
.text$mn:00008082                 mov     eax, large fs:0
.text$mn:00008088                 push    eax
.text$mn:00008089                 sub     esp, 8
.text$mn:0000808C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00008091                 xor     eax, ebp
.text$mn:00008093                 push    eax
.text$mn:00008094                 lea     eax, [ebp+var_C]
.text$mn:00008097                 mov     large fs:0, eax
.text$mn:0000809D                 mov     [ebp+var_14], ecx
.text$mn:000080A0                 mov     [ebp+var_10], 0
.text$mn:000080A7                 mov     eax, [ebp+arg_0]
.text$mn:000080AA                 push    eax
.text$mn:000080AB                 mov     ecx, [ebp+var_14]
.text$mn:000080AE                 call    ?begin@?$list@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@XZ ; std::list<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>::begin(void)
.text$mn:000080B3                 mov     [ebp+var_4], 0
.text$mn:000080BA                 mov     ecx, [ebp+var_10]
.text$mn:000080BD                 or      ecx, 1
.text$mn:000080C0                 mov     [ebp+var_10], ecx
.text$mn:000080C3                 mov     eax, [ebp+arg_0]
.text$mn:000080C6                 mov     ecx, [ebp+var_C]
.text$mn:000080C9                 mov     large fs:0, ecx
.text$mn:000080D0                 pop     ecx
.text$mn:000080D1                 mov     esp, ebp
.text$mn:000080D3                 pop     ebp
.text$mn:000080D4                 retn    4
.text$mn:000080D4 ?begin@?$_Hash@V?$_Umap_traits@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@V?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@XZ endp
.text$mn:000080D4
.text$mn:000080D4 ; ---------------------------------------------------------------------------
.text$mn:000080D7                 align 4
.text$mn:000080D7 _text$mn        ends
.text$mn:000080D7
.text$x:000080D8 ; ===========================================================================
.text$x:000080D8
.text$x:000080D8 ; Segment type: Pure code
.text$x:000080D8 ; Segment permissions: Read/Execute
.text$x:000080D8 _text$x         segment para public 'CODE' use32
.text$x:000080D8                 assume cs:_text$x
.text$x:000080D8                 ;org 80D8h
.text$x:000080D8 ; COMDAT (pick associative to section at 8078)
.text$x:000080D8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000080D8
.text$x:000080D8 ; =============== S U B R O U T I N E =======================================
.text$x:000080D8
.text$x:000080D8
.text$x:000080D8 __unwindfunclet$?begin@?$_Hash@V?$_Umap_traits@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@V?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@XZ$0 proc near
.text$x:000080D8                                         ; DATA XREF: .xdata$x:0000A070o
.text$x:000080D8                 mov     eax, [ebp-10h]
.text$x:000080DB                 and     eax, 1
.text$x:000080DE                 jz      $LN4_2
.text$x:000080E4                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:000080E8                 mov     ecx, [ebp+8]
.text$x:000080EB                 jmp     ??1?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::~_List_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>(void)
.text$x:000080F0 ; ---------------------------------------------------------------------------
.text$x:000080F0
.text$x:000080F0 $LN4_2:                                 ; CODE XREF: __unwindfunclet$?begin@?$_Hash@V?$_Umap_traits@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@V?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@XZ$0+6j
.text$x:000080F0                 retn
.text$x:000080F0 __unwindfunclet$?begin@?$_Hash@V?$_Umap_traits@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@V?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@XZ$0 endp
.text$x:000080F0
.text$x:000080F1
.text$x:000080F1 ; =============== S U B R O U T I N E =======================================
.text$x:000080F1
.text$x:000080F1
.text$x:000080F1 __ehhandler$?begin@?$_Hash@V?$_Umap_traits@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@V?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@XZ proc near
.text$x:000080F1                                         ; DATA XREF: std::_Hash<std::_Umap_traits<Buffer *,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *,std::_Uhash_compare<Buffer *,std::hash<Buffer *>,std::equal_to<Buffer *>>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>,0>>::begin(void)+5o
.text$x:000080F1
.text$x:000080F1 arg_4           = dword ptr  8
.text$x:000080F1
.text$x:000080F1                 mov     edx, [esp+arg_4]
.text$x:000080F5                 lea     eax, [edx+0Ch]
.text$x:000080F8                 mov     ecx, [edx-0Ch]
.text$x:000080FB                 xor     ecx, eax
.text$x:000080FD                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00008102                 mov     eax, offset __ehfuncinfo$?begin@?$_Hash@V?$_Umap_traits@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@V?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@XZ
.text$x:00008107                 jmp     ___CxxFrameHandler3
.text$x:00008107 __ehhandler$?begin@?$_Hash@V?$_Umap_traits@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@V?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@XZ endp
.text$x:00008107
.text$x:00008107 _text$x         ends
.text$x:00008107
.text$mn:0000810C ; ===========================================================================
.text$mn:0000810C
.text$mn:0000810C ; Segment type: Pure code
.text$mn:0000810C ; Segment permissions: Read/Execute
.text$mn:0000810C _text$mn        segment para public 'CODE' use32
.text$mn:0000810C                 assume cs:_text$mn
.text$mn:0000810C                 ;org 810Ch
.text$mn:0000810C ; COMDAT (pick any)
.text$mn:0000810C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000810C
.text$mn:0000810C ; =============== S U B R O U T I N E =======================================
.text$mn:0000810C
.text$mn:0000810C ; Attributes: bp-based frame
.text$mn:0000810C
.text$mn:0000810C ; public: class std::_List_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<int const, struct Style>>>> __thiscall std::list<struct std::pair<int const, struct Style>, class std::allocator<struct std::pair<int const, struct Style>>>::begin(void)
.text$mn:0000810C                 public ?begin@?$list@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@2@XZ
.text$mn:0000810C ?begin@?$list@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@2@XZ proc near
.text$mn:0000810C                                         ; CODE XREF: std::_Hash<std::_Umap_traits<int,Style,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int>>,std::allocator<std::pair<int const,Style>>,0>>::begin(void)+36p
.text$mn:0000810C
.text$mn:0000810C var_14          = dword ptr -14h
.text$mn:0000810C var_10          = dword ptr -10h
.text$mn:0000810C var_C           = dword ptr -0Ch
.text$mn:0000810C var_4           = dword ptr -4
.text$mn:0000810C arg_0           = dword ptr  8
.text$mn:0000810C
.text$mn:0000810C                 push    ebp
.text$mn:0000810D                 mov     ebp, esp
.text$mn:0000810F                 push    0FFFFFFFFh
.text$mn:00008111                 push    offset __ehhandler$?begin@?$list@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@2@XZ
.text$mn:00008116                 mov     eax, large fs:0
.text$mn:0000811C                 push    eax
.text$mn:0000811D                 sub     esp, 8
.text$mn:00008120                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00008125                 xor     eax, ebp
.text$mn:00008127                 push    eax
.text$mn:00008128                 lea     eax, [ebp+var_C]
.text$mn:0000812B                 mov     large fs:0, eax
.text$mn:00008131                 mov     [ebp+var_10], ecx
.text$mn:00008134                 mov     [ebp+var_14], 0
.text$mn:0000813B                 mov     eax, [ebp+var_10]
.text$mn:0000813E                 push    eax             ; struct std::_Container_base12 *
.text$mn:0000813F                 mov     ecx, [ebp+var_10]
.text$mn:00008142                 mov     edx, [ecx+4]
.text$mn:00008145                 push    edx
.text$mn:00008146                 call    ?_Nextnode@?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@SAAAPAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@2@PAU32@@Z ; std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>::_Nextnode(std::_List_node<std::pair<int const,Style>,void *> *)
.text$mn:0000814B                 add     esp, 4
.text$mn:0000814E                 mov     eax, [eax]
.text$mn:00008150                 push    eax             ; int
.text$mn:00008151                 mov     ecx, [ebp+arg_0]
.text$mn:00008154                 call    ??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@1@@Z ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>(std::_List_node<std::pair<int const,Style>,void *> *,std::_List_val<std::_List_simple_types<std::pair<int const,Style>>> const *)
.text$mn:00008159                 mov     [ebp+var_4], 0
.text$mn:00008160                 mov     ecx, [ebp+var_14]
.text$mn:00008163                 or      ecx, 1
.text$mn:00008166                 mov     [ebp+var_14], ecx
.text$mn:00008169                 mov     eax, [ebp+arg_0]
.text$mn:0000816C                 mov     ecx, [ebp+var_C]
.text$mn:0000816F                 mov     large fs:0, ecx
.text$mn:00008176                 pop     ecx
.text$mn:00008177                 mov     esp, ebp
.text$mn:00008179                 pop     ebp
.text$mn:0000817A                 retn    4
.text$mn:0000817A ?begin@?$list@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@2@XZ endp
.text$mn:0000817A
.text$mn:0000817A ; ---------------------------------------------------------------------------
.text$mn:0000817D                 align 10h
.text$mn:0000817D _text$mn        ends
.text$mn:0000817D
.text$x:00008180 ; ===========================================================================
.text$x:00008180
.text$x:00008180 ; Segment type: Pure code
.text$x:00008180 ; Segment permissions: Read/Execute
.text$x:00008180 _text$x         segment para public 'CODE' use32
.text$x:00008180                 assume cs:_text$x
.text$x:00008180                 ;org 8180h
.text$x:00008180 ; COMDAT (pick associative to section at 810C)
.text$x:00008180                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00008180
.text$x:00008180 ; =============== S U B R O U T I N E =======================================
.text$x:00008180
.text$x:00008180
.text$x:00008180 __unwindfunclet$?begin@?$list@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@2@XZ$0 proc near
.text$x:00008180                                         ; DATA XREF: .xdata$x:0000A5A4o
.text$x:00008180                 mov     eax, [ebp-14h]
.text$x:00008183                 and     eax, 1
.text$x:00008186                 jz      $LN4_5
.text$x:0000818C                 and     dword ptr [ebp-14h], 0FFFFFFFEh
.text$x:00008190                 mov     ecx, [ebp+8]
.text$x:00008193                 jmp     ??1?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>::~_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>(void)
.text$x:00008198 ; ---------------------------------------------------------------------------
.text$x:00008198
.text$x:00008198 $LN4_5:                                 ; CODE XREF: __unwindfunclet$?begin@?$list@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@2@XZ$0+6j
.text$x:00008198                 retn
.text$x:00008198 __unwindfunclet$?begin@?$list@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@2@XZ$0 endp
.text$x:00008198
.text$x:00008199
.text$x:00008199 ; =============== S U B R O U T I N E =======================================
.text$x:00008199
.text$x:00008199
.text$x:00008199 __ehhandler$?begin@?$list@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@2@XZ proc near
.text$x:00008199                                         ; DATA XREF: std::list<std::pair<int const,Style>,std::allocator<std::pair<int const,Style>>>::begin(void)+5o
.text$x:00008199
.text$x:00008199 arg_4           = dword ptr  8
.text$x:00008199
.text$x:00008199                 mov     edx, [esp+arg_4]
.text$x:0000819D                 lea     eax, [edx+0Ch]
.text$x:000081A0                 mov     ecx, [edx-0Ch]
.text$x:000081A3                 xor     ecx, eax
.text$x:000081A5                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000081AA                 mov     eax, offset __ehfuncinfo$?begin@?$list@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@2@XZ
.text$x:000081AF                 jmp     ___CxxFrameHandler3
.text$x:000081AF __ehhandler$?begin@?$list@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@2@XZ endp
.text$x:000081AF
.text$x:000081AF _text$x         ends
.text$x:000081AF
.text$mn:000081B4 ; ===========================================================================
.text$mn:000081B4
.text$mn:000081B4 ; Segment type: Pure code
.text$mn:000081B4 ; Segment permissions: Read/Execute
.text$mn:000081B4 _text$mn        segment para public 'CODE' use32
.text$mn:000081B4                 assume cs:_text$mn
.text$mn:000081B4                 ;org 81B4h
.text$mn:000081B4 ; COMDAT (pick any)
.text$mn:000081B4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000081B4
.text$mn:000081B4 ; =============== S U B R O U T I N E =======================================
.text$mn:000081B4
.text$mn:000081B4 ; Attributes: bp-based frame
.text$mn:000081B4
.text$mn:000081B4 ; public: class std::_List_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>> __thiscall std::list<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>, class std::allocator<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>::begin(void)
.text$mn:000081B4                 public ?begin@?$list@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@XZ
.text$mn:000081B4 ?begin@?$list@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@XZ proc near
.text$mn:000081B4                                         ; CODE XREF: std::_Hash<std::_Umap_traits<Buffer *,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *,std::_Uhash_compare<Buffer *,std::hash<Buffer *>,std::equal_to<Buffer *>>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>,0>>::begin(void)+36p
.text$mn:000081B4
.text$mn:000081B4 var_14          = dword ptr -14h
.text$mn:000081B4 var_10          = dword ptr -10h
.text$mn:000081B4 var_C           = dword ptr -0Ch
.text$mn:000081B4 var_4           = dword ptr -4
.text$mn:000081B4 arg_0           = dword ptr  8
.text$mn:000081B4
.text$mn:000081B4                 push    ebp
.text$mn:000081B5                 mov     ebp, esp
.text$mn:000081B7                 push    0FFFFFFFFh
.text$mn:000081B9                 push    offset __ehhandler$?begin@?$list@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@XZ
.text$mn:000081BE                 mov     eax, large fs:0
.text$mn:000081C4                 push    eax
.text$mn:000081C5                 sub     esp, 8
.text$mn:000081C8                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000081CD                 xor     eax, ebp
.text$mn:000081CF                 push    eax
.text$mn:000081D0                 lea     eax, [ebp+var_C]
.text$mn:000081D3                 mov     large fs:0, eax
.text$mn:000081D9                 mov     [ebp+var_10], ecx
.text$mn:000081DC                 mov     [ebp+var_14], 0
.text$mn:000081E3                 mov     eax, [ebp+var_10]
.text$mn:000081E6                 push    eax             ; struct std::_Container_base12 *
.text$mn:000081E7                 mov     ecx, [ebp+var_10]
.text$mn:000081EA                 mov     edx, [ecx+4]
.text$mn:000081ED                 push    edx
.text$mn:000081EE                 call    ?_Nextnode@?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@SAAAPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@2@PAU32@@Z ; std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>::_Nextnode(std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *)
.text$mn:000081F3                 add     esp, 4
.text$mn:000081F6                 mov     eax, [eax]
.text$mn:000081F8                 push    eax             ; int
.text$mn:000081F9                 mov     ecx, [ebp+arg_0]
.text$mn:000081FC                 call    ??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@1@@Z ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>(std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *,std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>> const *)
.text$mn:00008201                 mov     [ebp+var_4], 0
.text$mn:00008208                 mov     ecx, [ebp+var_14]
.text$mn:0000820B                 or      ecx, 1
.text$mn:0000820E                 mov     [ebp+var_14], ecx
.text$mn:00008211                 mov     eax, [ebp+arg_0]
.text$mn:00008214                 mov     ecx, [ebp+var_C]
.text$mn:00008217                 mov     large fs:0, ecx
.text$mn:0000821E                 pop     ecx
.text$mn:0000821F                 mov     esp, ebp
.text$mn:00008221                 pop     ebp
.text$mn:00008222                 retn    4
.text$mn:00008222 ?begin@?$list@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@XZ endp
.text$mn:00008222
.text$mn:00008222 ; ---------------------------------------------------------------------------
.text$mn:00008225                 align 4
.text$mn:00008225 _text$mn        ends
.text$mn:00008225
.text$x:00008228 ; ===========================================================================
.text$x:00008228
.text$x:00008228 ; Segment type: Pure code
.text$x:00008228 ; Segment permissions: Read/Execute
.text$x:00008228 _text$x         segment para public 'CODE' use32
.text$x:00008228                 assume cs:_text$x
.text$x:00008228                 ;org 8228h
.text$x:00008228 ; COMDAT (pick associative to section at 81B4)
.text$x:00008228                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00008228
.text$x:00008228 ; =============== S U B R O U T I N E =======================================
.text$x:00008228
.text$x:00008228
.text$x:00008228 __unwindfunclet$?begin@?$list@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@XZ$0 proc near
.text$x:00008228                                         ; DATA XREF: .xdata$x:00009F84o
.text$x:00008228                 mov     eax, [ebp-14h]
.text$x:0000822B                 and     eax, 1
.text$x:0000822E                 jz      $LN4_0
.text$x:00008234                 and     dword ptr [ebp-14h], 0FFFFFFFEh
.text$x:00008238                 mov     ecx, [ebp+8]
.text$x:0000823B                 jmp     ??1?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::~_List_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>(void)
.text$x:00008240 ; ---------------------------------------------------------------------------
.text$x:00008240
.text$x:00008240 $LN4_0:                                 ; CODE XREF: __unwindfunclet$?begin@?$list@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@XZ$0+6j
.text$x:00008240                 retn
.text$x:00008240 __unwindfunclet$?begin@?$list@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@XZ$0 endp
.text$x:00008240
.text$x:00008241
.text$x:00008241 ; =============== S U B R O U T I N E =======================================
.text$x:00008241
.text$x:00008241
.text$x:00008241 __ehhandler$?begin@?$list@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@XZ proc near
.text$x:00008241                                         ; DATA XREF: std::list<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>::begin(void)+5o
.text$x:00008241
.text$x:00008241 arg_4           = dword ptr  8
.text$x:00008241
.text$x:00008241                 mov     edx, [esp+arg_4]
.text$x:00008245                 lea     eax, [edx+0Ch]
.text$x:00008248                 mov     ecx, [edx-0Ch]
.text$x:0000824B                 xor     ecx, eax
.text$x:0000824D                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00008252                 mov     eax, offset __ehfuncinfo$?begin@?$list@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@XZ
.text$x:00008257                 jmp     ___CxxFrameHandler3
.text$x:00008257 __ehhandler$?begin@?$list@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@XZ endp
.text$x:00008257
.text$x:00008257 _text$x         ends
.text$x:00008257
.text$mn:0000825C ; ===========================================================================
.text$mn:0000825C
.text$mn:0000825C ; Segment type: Pure code
.text$mn:0000825C ; Segment permissions: Read/Execute
.text$mn:0000825C _text$mn        segment para public 'CODE' use32
.text$mn:0000825C                 assume cs:_text$mn
.text$mn:0000825C                 ;org 825Ch
.text$mn:0000825C ; COMDAT (pick any)
.text$mn:0000825C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000825C
.text$mn:0000825C ; =============== S U B R O U T I N E =======================================
.text$mn:0000825C
.text$mn:0000825C ; Attributes: bp-based frame
.text$mn:0000825C
.text$mn:0000825C ; public: class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<class ScintillaEditView *>>> __thiscall std::vector<class ScintillaEditView *, class std::allocator<class ScintillaEditView *>>::begin(void)
.text$mn:0000825C                 public ?begin@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@2@XZ
.text$mn:0000825C ?begin@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@2@XZ proc near
.text$mn:0000825C                                         ; CODE XREF: ScintillaCtrls::destroyScintilla(HWND__ *)+A8p
.text$mn:0000825C
.text$mn:0000825C var_14          = dword ptr -14h
.text$mn:0000825C var_10          = dword ptr -10h
.text$mn:0000825C var_C           = dword ptr -0Ch
.text$mn:0000825C var_4           = dword ptr -4
.text$mn:0000825C arg_0           = dword ptr  8
.text$mn:0000825C
.text$mn:0000825C                 push    ebp
.text$mn:0000825D                 mov     ebp, esp
.text$mn:0000825F                 push    0FFFFFFFFh
.text$mn:00008261                 push    offset __ehhandler$?begin@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@2@XZ
.text$mn:00008266                 mov     eax, large fs:0
.text$mn:0000826C                 push    eax
.text$mn:0000826D                 sub     esp, 8
.text$mn:00008270                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00008275                 xor     eax, ebp
.text$mn:00008277                 push    eax
.text$mn:00008278                 lea     eax, [ebp+var_C]
.text$mn:0000827B                 mov     large fs:0, eax
.text$mn:00008281                 mov     [ebp+var_10], ecx
.text$mn:00008284                 mov     [ebp+var_14], 0
.text$mn:0000828B                 mov     eax, [ebp+var_10]
.text$mn:0000828E                 push    eax             ; struct std::_Container_base12 *
.text$mn:0000828F                 mov     ecx, [ebp+var_10]
.text$mn:00008292                 mov     edx, [ecx+4]
.text$mn:00008295                 push    edx             ; int
.text$mn:00008296                 mov     ecx, [ebp+arg_0]
.text$mn:00008299                 call    ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@PAPAVScintillaEditView@@PBU_Container_base12@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>(ScintillaEditView * *,std::_Container_base12 const *)
.text$mn:0000829E                 mov     [ebp+var_4], 0
.text$mn:000082A5                 mov     eax, [ebp+var_14]
.text$mn:000082A8                 or      eax, 1
.text$mn:000082AB                 mov     [ebp+var_14], eax
.text$mn:000082AE                 mov     eax, [ebp+arg_0]
.text$mn:000082B1                 mov     ecx, [ebp+var_C]
.text$mn:000082B4                 mov     large fs:0, ecx
.text$mn:000082BB                 pop     ecx
.text$mn:000082BC                 mov     esp, ebp
.text$mn:000082BE                 pop     ebp
.text$mn:000082BF                 retn    4
.text$mn:000082BF ?begin@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@2@XZ endp
.text$mn:000082BF
.text$mn:000082BF ; ---------------------------------------------------------------------------
.text$mn:000082C2                 align 4
.text$mn:000082C2 _text$mn        ends
.text$mn:000082C2
.text$x:000082C4 ; ===========================================================================
.text$x:000082C4
.text$x:000082C4 ; Segment type: Pure code
.text$x:000082C4 ; Segment permissions: Read/Execute
.text$x:000082C4 _text$x         segment para public 'CODE' use32
.text$x:000082C4                 assume cs:_text$x
.text$x:000082C4                 ;org 82C4h
.text$x:000082C4 ; COMDAT (pick associative to section at 825C)
.text$x:000082C4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000082C4
.text$x:000082C4 ; =============== S U B R O U T I N E =======================================
.text$x:000082C4
.text$x:000082C4
.text$x:000082C4 __unwindfunclet$?begin@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@2@XZ$0 proc near
.text$x:000082C4                                         ; DATA XREF: .xdata$x:000099E0o
.text$x:000082C4                 mov     eax, [ebp-14h]
.text$x:000082C7                 and     eax, 1
.text$x:000082CA                 jz      $LN4
.text$x:000082D0                 and     dword ptr [ebp-14h], 0FFFFFFFEh
.text$x:000082D4                 mov     ecx, [ebp+8]
.text$x:000082D7                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>(void)
.text$x:000082DC ; ---------------------------------------------------------------------------
.text$x:000082DC
.text$x:000082DC $LN4:                                   ; CODE XREF: __unwindfunclet$?begin@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@2@XZ$0+6j
.text$x:000082DC                 retn
.text$x:000082DC __unwindfunclet$?begin@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@2@XZ$0 endp
.text$x:000082DC
.text$x:000082DD
.text$x:000082DD ; =============== S U B R O U T I N E =======================================
.text$x:000082DD
.text$x:000082DD
.text$x:000082DD __ehhandler$?begin@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@2@XZ proc near
.text$x:000082DD                                         ; DATA XREF: std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::begin(void)+5o
.text$x:000082DD
.text$x:000082DD arg_4           = dword ptr  8
.text$x:000082DD
.text$x:000082DD                 mov     edx, [esp+arg_4]
.text$x:000082E1                 lea     eax, [edx+0Ch]
.text$x:000082E4                 mov     ecx, [edx-0Ch]
.text$x:000082E7                 xor     ecx, eax
.text$x:000082E9                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000082EE                 mov     eax, offset __ehfuncinfo$?begin@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@2@XZ
.text$x:000082F3                 jmp     ___CxxFrameHandler3
.text$x:000082F3 __ehhandler$?begin@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@2@XZ endp
.text$x:000082F3
.text$x:000082F3 _text$x         ends
.text$x:000082F3
.text$mn:000082F8 ; ===========================================================================
.text$mn:000082F8
.text$mn:000082F8 ; Segment type: Pure code
.text$mn:000082F8 ; Segment permissions: Read/Execute
.text$mn:000082F8 _text$mn        segment para public 'CODE' use32
.text$mn:000082F8                 assume cs:_text$mn
.text$mn:000082F8                 ;org 82F8h
.text$mn:000082F8 ; COMDAT (pick any)
.text$mn:000082F8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000082F8
.text$mn:000082F8 ; =============== S U B R O U T I N E =======================================
.text$mn:000082F8
.text$mn:000082F8 ; Attributes: bp-based frame
.text$mn:000082F8
.text$mn:000082F8 ; public: class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>>>> __thiscall std::vector<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>, struct std::_Wrap_alloc<class std::allocator<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct S
.text$mn:000082F8                 public ?begin@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@XZ
.text$mn:000082F8 ?begin@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@XZ proc near
.text$mn:000082F8                                         ; CODE XREF: ?_Insert_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CB
.text$mn:000082F8                                         ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::assign(uint,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const &)+3Fp
.text$mn:000082F8
.text$mn:000082F8 var_14          = dword ptr -14h
.text$mn:000082F8 var_10          = dword ptr -10h
.text$mn:000082F8 var_C           = dword ptr -0Ch
.text$mn:000082F8 var_4           = dword ptr -4
.text$mn:000082F8 arg_0           = dword ptr  8
.text$mn:000082F8
.text$mn:000082F8                 push    ebp
.text$mn:000082F9                 mov     ebp, esp
.text$mn:000082FB                 push    0FFFFFFFFh
.text$mn:000082FD                 push    offset __ehhandler$?begin@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@XZ
.text$mn:00008302                 mov     eax, large fs:0
.text$mn:00008308                 push    eax
.text$mn:00008309                 sub     esp, 8
.text$mn:0000830C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00008311                 xor     eax, ebp
.text$mn:00008313                 push    eax
.text$mn:00008314                 lea     eax, [ebp+var_C]
.text$mn:00008317                 mov     large fs:0, eax
.text$mn:0000831D                 mov     [ebp+var_10], ecx
.text$mn:00008320                 mov     [ebp+var_14], 0
.text$mn:00008327                 mov     eax, [ebp+var_10]
.text$mn:0000832A                 push    eax             ; struct std::_Container_base12 *
.text$mn:0000832B                 mov     ecx, [ebp+var_10]
.text$mn:0000832E                 mov     edx, [ecx+4]
.text$mn:00008331                 push    edx             ; int
.text$mn:00008332                 mov     ecx, [ebp+arg_0]
.text$mn:00008335                 call    ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@PBU_Container_base12@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_Container_base12 const *)
.text$mn:0000833A                 mov     [ebp+var_4], 0
.text$mn:00008341                 mov     eax, [ebp+var_14]
.text$mn:00008344                 or      eax, 1
.text$mn:00008347                 mov     [ebp+var_14], eax
.text$mn:0000834A                 mov     eax, [ebp+arg_0]
.text$mn:0000834D                 mov     ecx, [ebp+var_C]
.text$mn:00008350                 mov     large fs:0, ecx
.text$mn:00008357                 pop     ecx
.text$mn:00008358                 mov     esp, ebp
.text$mn:0000835A                 pop     ebp
.text$mn:0000835B                 retn    4
.text$mn:0000835B ?begin@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@XZ endp
.text$mn:0000835B
.text$mn:0000835B ; ---------------------------------------------------------------------------
.text$mn:0000835E                 align 10h
.text$mn:0000835E _text$mn        ends
.text$mn:0000835E
.text$x:00008360 ; ===========================================================================
.text$x:00008360
.text$x:00008360 ; Segment type: Pure code
.text$x:00008360 ; Segment permissions: Read/Execute
.text$x:00008360 _text$x         segment para public 'CODE' use32
.text$x:00008360                 assume cs:_text$x
.text$x:00008360                 ;org 8360h
.text$x:00008360 ; COMDAT (pick associative to section at 82F8)
.text$x:00008360                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00008360
.text$x:00008360 ; =============== S U B R O U T I N E =======================================
.text$x:00008360
.text$x:00008360
.text$x:00008360 __unwindfunclet$?begin@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@XZ$0 proc near
.text$x:00008360                                         ; DATA XREF: .xdata$x:0000A1D0o
.text$x:00008360                 mov     eax, [ebp-14h]
.text$x:00008363                 and     eax, 1
.text$x:00008366                 jz      $LN4_4
.text$x:0000836C                 and     dword ptr [ebp-14h], 0FFFFFFFEh
.text$x:00008370                 mov     ecx, [ebp+8]
.text$x:00008373                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>(void)
.text$x:00008378 ; ---------------------------------------------------------------------------
.text$x:00008378
.text$x:00008378 $LN4_4:                                 ; CODE XREF: __unwindfunclet$?begin@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@XZ$0+6j
.text$x:00008378                 retn
.text$x:00008378 __unwindfunclet$?begin@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@XZ$0 endp
.text$x:00008378
.text$x:00008379
.text$x:00008379 ; =============== S U B R O U T I N E =======================================
.text$x:00008379
.text$x:00008379
.text$x:00008379 __ehhandler$?begin@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@XZ proc near
.text$x:00008379                                         ; DATA XREF: std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::begin(void)+5o
.text$x:00008379
.text$x:00008379 arg_4           = dword ptr  8
.text$x:00008379
.text$x:00008379                 mov     edx, [esp+arg_4]
.text$x:0000837D                 lea     eax, [edx+0Ch]
.text$x:00008380                 mov     ecx, [edx-0Ch]
.text$x:00008383                 xor     ecx, eax
.text$x:00008385                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000838A                 mov     eax, offset __ehfuncinfo$?begin@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@XZ
.text$x:0000838F                 jmp     ___CxxFrameHandler3
.text$x:0000838F __ehhandler$?begin@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@XZ endp
.text$x:0000838F
.text$x:0000838F _text$x         ends
.text$x:0000838F
.text$mn:00008394 ; ===========================================================================
.text$mn:00008394
.text$mn:00008394 ; Segment type: Pure code
.text$mn:00008394 ; Segment permissions: Read/Execute
.text$mn:00008394 _text$mn        segment para public 'CODE' use32
.text$mn:00008394                 assume cs:_text$mn
.text$mn:00008394                 ;org 8394h
.text$mn:00008394 ; COMDAT (pick any)
.text$mn:00008394                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008394
.text$mn:00008394 ; =============== S U B R O U T I N E =======================================
.text$mn:00008394
.text$mn:00008394 ; Attributes: bp-based frame
.text$mn:00008394
.text$mn:00008394 ; public: unsigned int __thiscall std::vector<class ScintillaEditView *, class std::allocator<class ScintillaEditView *>>::capacity(void)const
.text$mn:00008394                 public ?capacity@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@QBEIXZ
.text$mn:00008394 ?capacity@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@QBEIXZ proc near
.text$mn:00008394                                         ; CODE XREF: std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::_Grow_to(uint)+Cp
.text$mn:00008394
.text$mn:00008394 var_4           = dword ptr -4
.text$mn:00008394
.text$mn:00008394                 push    ebp
.text$mn:00008395                 mov     ebp, esp
.text$mn:00008397                 push    ecx
.text$mn:00008398                 mov     [ebp+var_4], ecx
.text$mn:0000839B                 mov     eax, [ebp+var_4]
.text$mn:0000839E                 mov     ecx, [ebp+var_4]
.text$mn:000083A1                 mov     eax, [eax+0Ch]
.text$mn:000083A4                 sub     eax, [ecx+4]
.text$mn:000083A7                 sar     eax, 2
.text$mn:000083AA                 mov     esp, ebp
.text$mn:000083AC                 pop     ebp
.text$mn:000083AD                 retn
.text$mn:000083AD ?capacity@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@QBEIXZ endp
.text$mn:000083AD
.text$mn:000083AD ; ---------------------------------------------------------------------------
.text$mn:000083AE                 align 10h
.text$mn:000083AE _text$mn        ends
.text$mn:000083AE
.text$mn:000083B0 ; ===========================================================================
.text$mn:000083B0
.text$mn:000083B0 ; Segment type: Pure code
.text$mn:000083B0 ; Segment permissions: Read/Execute
.text$mn:000083B0 _text$mn        segment para public 'CODE' use32
.text$mn:000083B0                 assume cs:_text$mn
.text$mn:000083B0                 ;org 83B0h
.text$mn:000083B0 ; COMDAT (pick any)
.text$mn:000083B0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000083B0
.text$mn:000083B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000083B0
.text$mn:000083B0 ; Attributes: bp-based frame
.text$mn:000083B0
.text$mn:000083B0 ; public: unsigned int __thiscall std::vector<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>, struct std::_Wrap_alloc<class std::allocator<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>>>>::capacity(void)const
.text$mn:000083B0                 public ?capacity@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QBEIXZ
.text$mn:000083B0 ?capacity@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QBEIXZ proc near
.text$mn:000083B0                                         ; CODE XREF: std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::_Grow_to(uint)+Cp
.text$mn:000083B0
.text$mn:000083B0 var_4           = dword ptr -4
.text$mn:000083B0
.text$mn:000083B0                 push    ebp
.text$mn:000083B1                 mov     ebp, esp
.text$mn:000083B3                 push    ecx
.text$mn:000083B4                 mov     [ebp+var_4], ecx
.text$mn:000083B7                 mov     eax, [ebp+var_4]
.text$mn:000083BA                 mov     ecx, [ebp+var_4]
.text$mn:000083BD                 mov     eax, [eax+0Ch]
.text$mn:000083C0                 sub     eax, [ecx+4]
.text$mn:000083C3                 sar     eax, 2
.text$mn:000083C6                 mov     esp, ebp
.text$mn:000083C8                 pop     ebp
.text$mn:000083C9                 retn
.text$mn:000083C9 ?capacity@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QBEIXZ endp
.text$mn:000083C9
.text$mn:000083C9 ; ---------------------------------------------------------------------------
.text$mn:000083CA                 align 4
.text$mn:000083CA _text$mn        ends
.text$mn:000083CA
.text$mn:000083CC ; ===========================================================================
.text$mn:000083CC
.text$mn:000083CC ; Segment type: Pure code
.text$mn:000083CC ; Segment permissions: Read/Execute
.text$mn:000083CC _text$mn        segment para public 'CODE' use32
.text$mn:000083CC                 assume cs:_text$mn
.text$mn:000083CC                 ;org 83CCh
.text$mn:000083CC ; COMDAT (pick any)
.text$mn:000083CC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000083CC
.text$mn:000083CC ; =============== S U B R O U T I N E =======================================
.text$mn:000083CC
.text$mn:000083CC ; Attributes: bp-based frame
.text$mn:000083CC
.text$mn:000083CC ; const struct std::error_category *__thiscall std::error_code::category(std::error_code *__hidden this)
.text$mn:000083CC                 public ?category@error_code@std@@QBEABVerror_category@2@XZ
.text$mn:000083CC ?category@error_code@std@@QBEABVerror_category@2@XZ proc near
.text$mn:000083CC                                         ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+Cp
.text$mn:000083CC
.text$mn:000083CC var_4           = dword ptr -4
.text$mn:000083CC
.text$mn:000083CC                 push    ebp
.text$mn:000083CD                 mov     ebp, esp
.text$mn:000083CF                 push    ecx
.text$mn:000083D0                 mov     [ebp+var_4], ecx
.text$mn:000083D3                 mov     eax, [ebp+var_4]
.text$mn:000083D6                 mov     eax, [eax+4]
.text$mn:000083D9                 mov     esp, ebp
.text$mn:000083DB                 pop     ebp
.text$mn:000083DC                 retn
.text$mn:000083DC ?category@error_code@std@@QBEABVerror_category@2@XZ endp
.text$mn:000083DC
.text$mn:000083DC ; ---------------------------------------------------------------------------
.text$mn:000083DD                 align 10h
.text$mn:000083DD _text$mn        ends
.text$mn:000083DD
.text$mn:000083E0 ; ===========================================================================
.text$mn:000083E0
.text$mn:000083E0 ; Segment type: Pure code
.text$mn:000083E0 ; Segment permissions: Read/Execute
.text$mn:000083E0 _text$mn        segment para public 'CODE' use32
.text$mn:000083E0                 assume cs:_text$mn
.text$mn:000083E0                 ;org 83E0h
.text$mn:000083E0 ; COMDAT (pick any)
.text$mn:000083E0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000083E0
.text$mn:000083E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000083E0
.text$mn:000083E0 ; Attributes: bp-based frame
.text$mn:000083E0
.text$mn:000083E0 ; const struct std::error_category *__thiscall std::error_condition::category(std::error_condition *__hidden this)
.text$mn:000083E0                 public ?category@error_condition@std@@QBEABVerror_category@2@XZ
.text$mn:000083E0 ?category@error_condition@std@@QBEABVerror_category@2@XZ proc near
.text$mn:000083E0                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+Dp
.text$mn:000083E0                                         ; std::error_condition::operator==(std::error_condition const &)+16p
.text$mn:000083E0
.text$mn:000083E0 var_4           = dword ptr -4
.text$mn:000083E0
.text$mn:000083E0                 push    ebp
.text$mn:000083E1                 mov     ebp, esp
.text$mn:000083E3                 push    ecx
.text$mn:000083E4                 mov     [ebp+var_4], ecx
.text$mn:000083E7                 mov     eax, [ebp+var_4]
.text$mn:000083EA                 mov     eax, [eax+4]
.text$mn:000083ED                 mov     esp, ebp
.text$mn:000083EF                 pop     ebp
.text$mn:000083F0                 retn
.text$mn:000083F0 ?category@error_condition@std@@QBEABVerror_category@2@XZ endp
.text$mn:000083F0
.text$mn:000083F0 ; ---------------------------------------------------------------------------
.text$mn:000083F1                 align 4
.text$mn:000083F1 _text$mn        ends
.text$mn:000083F1
.text$mn:000083F4 ; ===========================================================================
.text$mn:000083F4
.text$mn:000083F4 ; Segment type: Pure code
.text$mn:000083F4 ; Segment permissions: Read/Execute
.text$mn:000083F4 _text$mn        segment para public 'CODE' use32
.text$mn:000083F4                 assume cs:_text$mn
.text$mn:000083F4                 ;org 83F4h
.text$mn:000083F4 ; COMDAT (pick any)
.text$mn:000083F4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000083F4
.text$mn:000083F4 ; =============== S U B R O U T I N E =======================================
.text$mn:000083F4
.text$mn:000083F4 ; Attributes: bp-based frame
.text$mn:000083F4
.text$mn:000083F4 ; public: void __thiscall std::list<struct std::pair<int const, struct Style>, class std::allocator<struct std::pair<int const, struct Style>>>::clear(void)
.text$mn:000083F4                 public ?clear@?$list@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@QAEXXZ
.text$mn:000083F4 ?clear@?$list@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@QAEXXZ proc near
.text$mn:000083F4                                         ; CODE XREF: std::list<std::pair<int const,Style>,std::allocator<std::pair<int const,Style>>>::_Tidy(void)+Ap
.text$mn:000083F4
.text$mn:000083F4 var_C           = dword ptr -0Ch
.text$mn:000083F4 var_8           = dword ptr -8
.text$mn:000083F4 var_4           = dword ptr -4
.text$mn:000083F4
.text$mn:000083F4                 push    ebp
.text$mn:000083F5                 mov     ebp, esp
.text$mn:000083F7                 sub     esp, 0Ch
.text$mn:000083FA                 mov     [ebp+var_4], ecx
.text$mn:000083FD                 push    0               ; int
.text$mn:000083FF                 mov     eax, [ebp+var_4]
.text$mn:00008402                 push    eax             ; std::_Container_base12 *
.text$mn:00008403                 mov     ecx, [ebp+var_4]
.text$mn:00008406                 call    ?_Orphan_ptr@?$list@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@QBEXAAV12@PAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@2@@Z ; std::list<std::pair<int const,Style>,std::allocator<std::pair<int const,Style>>>::_Orphan_ptr(std::list<std::pair<int const,Style>,std::allocator<std::pair<int const,Style>>> &,std::_List_node<std::pair<int const,Style>,void *> *)
.text$mn:0000840B                 mov     ecx, [ebp+var_4]
.text$mn:0000840E                 mov     edx, [ecx+4]
.text$mn:00008411                 push    edx
.text$mn:00008412                 call    ?_Nextnode@?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@SAAAPAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@2@PAU32@@Z ; std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>::_Nextnode(std::_List_node<std::pair<int const,Style>,void *> *)
.text$mn:00008417                 add     esp, 4
.text$mn:0000841A                 mov     eax, [eax]
.text$mn:0000841C                 mov     [ebp+var_8], eax
.text$mn:0000841F                 mov     ecx, [ebp+var_4]
.text$mn:00008422                 mov     edx, [ecx+4]
.text$mn:00008425                 push    edx
.text$mn:00008426                 call    ?_Nextnode@?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@SAAAPAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@2@PAU32@@Z ; std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>::_Nextnode(std::_List_node<std::pair<int const,Style>,void *> *)
.text$mn:0000842B                 add     esp, 4
.text$mn:0000842E                 mov     ecx, [ebp+var_4]
.text$mn:00008431                 mov     edx, [ecx+4]
.text$mn:00008434                 mov     [eax], edx
.text$mn:00008436                 mov     eax, [ebp+var_4]
.text$mn:00008439                 mov     ecx, [eax+4]
.text$mn:0000843C                 push    ecx
.text$mn:0000843D                 call    ?_Prevnode@?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@SAAAPAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@2@PAU32@@Z ; std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>::_Prevnode(std::_List_node<std::pair<int const,Style>,void *> *)
.text$mn:00008442                 add     esp, 4
.text$mn:00008445                 mov     edx, [ebp+var_4]
.text$mn:00008448                 mov     ecx, [edx+4]
.text$mn:0000844B                 mov     [eax], ecx
.text$mn:0000844D                 mov     edx, [ebp+var_4]
.text$mn:00008450                 mov     dword ptr [edx+8], 0
.text$mn:00008457                 jmp     short loc_845F
.text$mn:00008459 ; ---------------------------------------------------------------------------
.text$mn:00008459
.text$mn:00008459 loc_8459:                               ; CODE XREF: std::list<std::pair<int const,Style>,std::allocator<std::pair<int const,Style>>>::clear(void)+93j
.text$mn:00008459                 mov     eax, [ebp+var_C]
.text$mn:0000845C                 mov     [ebp+var_8], eax
.text$mn:0000845F
.text$mn:0000845F loc_845F:                               ; CODE XREF: std::list<std::pair<int const,Style>,std::allocator<std::pair<int const,Style>>>::clear(void)+63j
.text$mn:0000845F                 mov     ecx, [ebp+var_4]
.text$mn:00008462                 mov     edx, [ebp+var_8]
.text$mn:00008465                 cmp     edx, [ecx+4]
.text$mn:00008468                 jz      short loc_8489
.text$mn:0000846A                 mov     eax, [ebp+var_8]
.text$mn:0000846D                 push    eax
.text$mn:0000846E                 call    ?_Nextnode@?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@SAAAPAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@2@PAU32@@Z ; std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>::_Nextnode(std::_List_node<std::pair<int const,Style>,void *> *)
.text$mn:00008473                 add     esp, 4
.text$mn:00008476                 mov     ecx, [eax]
.text$mn:00008478                 mov     [ebp+var_C], ecx
.text$mn:0000847B                 mov     edx, [ebp+var_8]
.text$mn:0000847E                 push    edx             ; void *
.text$mn:0000847F                 mov     ecx, [ebp+var_4]
.text$mn:00008482                 call    ?_Freenode@?$_List_buy@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@QAEXPAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@2@@Z ; std::_List_buy<std::pair<int const,Style>,std::allocator<std::pair<int const,Style>>>::_Freenode(std::_List_node<std::pair<int const,Style>,void *> *)
.text$mn:00008487                 jmp     short loc_8459
.text$mn:00008489 ; ---------------------------------------------------------------------------
.text$mn:00008489
.text$mn:00008489 loc_8489:                               ; CODE XREF: std::list<std::pair<int const,Style>,std::allocator<std::pair<int const,Style>>>::clear(void)+74j
.text$mn:00008489                 mov     esp, ebp
.text$mn:0000848B                 pop     ebp
.text$mn:0000848C                 retn
.text$mn:0000848C ?clear@?$list@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@QAEXXZ endp
.text$mn:0000848C
.text$mn:0000848C ; ---------------------------------------------------------------------------
.text$mn:0000848D                 align 10h
.text$mn:0000848D _text$mn        ends
.text$mn:0000848D
.text$mn:00008490 ; ===========================================================================
.text$mn:00008490
.text$mn:00008490 ; Segment type: Pure code
.text$mn:00008490 ; Segment permissions: Read/Execute
.text$mn:00008490 _text$mn        segment para public 'CODE' use32
.text$mn:00008490                 assume cs:_text$mn
.text$mn:00008490                 ;org 8490h
.text$mn:00008490 ; COMDAT (pick any)
.text$mn:00008490                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008490
.text$mn:00008490 ; =============== S U B R O U T I N E =======================================
.text$mn:00008490
.text$mn:00008490 ; Attributes: bp-based frame
.text$mn:00008490
.text$mn:00008490 ; public: void __thiscall std::list<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>, class std::allocator<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>::clear(void)
.text$mn:00008490                 public ?clear@?$list@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAEXXZ
.text$mn:00008490 ?clear@?$list@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAEXXZ proc near
.text$mn:00008490                                         ; CODE XREF: std::list<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>::_Tidy(void)+Ap
.text$mn:00008490
.text$mn:00008490 var_C           = dword ptr -0Ch
.text$mn:00008490 var_8           = dword ptr -8
.text$mn:00008490 var_4           = dword ptr -4
.text$mn:00008490
.text$mn:00008490                 push    ebp
.text$mn:00008491                 mov     ebp, esp
.text$mn:00008493                 sub     esp, 0Ch
.text$mn:00008496                 mov     [ebp+var_4], ecx
.text$mn:00008499                 push    0               ; int
.text$mn:0000849B                 mov     eax, [ebp+var_4]
.text$mn:0000849E                 push    eax             ; std::_Container_base12 *
.text$mn:0000849F                 mov     ecx, [ebp+var_4]
.text$mn:000084A2                 call    ?_Orphan_ptr@?$list@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QBEXAAV12@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@2@@Z ; std::list<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>::_Orphan_ptr(std::list<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>> &,std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *)
.text$mn:000084A7                 mov     ecx, [ebp+var_4]
.text$mn:000084AA                 mov     edx, [ecx+4]
.text$mn:000084AD                 push    edx
.text$mn:000084AE                 call    ?_Nextnode@?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@SAAAPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@2@PAU32@@Z ; std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>::_Nextnode(std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *)
.text$mn:000084B3                 add     esp, 4
.text$mn:000084B6                 mov     eax, [eax]
.text$mn:000084B8                 mov     [ebp+var_8], eax
.text$mn:000084BB                 mov     ecx, [ebp+var_4]
.text$mn:000084BE                 mov     edx, [ecx+4]
.text$mn:000084C1                 push    edx
.text$mn:000084C2                 call    ?_Nextnode@?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@SAAAPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@2@PAU32@@Z ; std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>::_Nextnode(std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *)
.text$mn:000084C7                 add     esp, 4
.text$mn:000084CA                 mov     ecx, [ebp+var_4]
.text$mn:000084CD                 mov     edx, [ecx+4]
.text$mn:000084D0                 mov     [eax], edx
.text$mn:000084D2                 mov     eax, [ebp+var_4]
.text$mn:000084D5                 mov     ecx, [eax+4]
.text$mn:000084D8                 push    ecx
.text$mn:000084D9                 call    ?_Prevnode@?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@SAAAPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@2@PAU32@@Z ; std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>::_Prevnode(std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *)
.text$mn:000084DE                 add     esp, 4
.text$mn:000084E1                 mov     edx, [ebp+var_4]
.text$mn:000084E4                 mov     ecx, [edx+4]
.text$mn:000084E7                 mov     [eax], ecx
.text$mn:000084E9                 mov     edx, [ebp+var_4]
.text$mn:000084EC                 mov     dword ptr [edx+8], 0
.text$mn:000084F3                 jmp     short loc_84FB
.text$mn:000084F5 ; ---------------------------------------------------------------------------
.text$mn:000084F5
.text$mn:000084F5 loc_84F5:                               ; CODE XREF: std::list<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>::clear(void)+93j
.text$mn:000084F5                 mov     eax, [ebp+var_C]
.text$mn:000084F8                 mov     [ebp+var_8], eax
.text$mn:000084FB
.text$mn:000084FB loc_84FB:                               ; CODE XREF: std::list<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>::clear(void)+63j
.text$mn:000084FB                 mov     ecx, [ebp+var_4]
.text$mn:000084FE                 mov     edx, [ebp+var_8]
.text$mn:00008501                 cmp     edx, [ecx+4]
.text$mn:00008504                 jz      short loc_8525
.text$mn:00008506                 mov     eax, [ebp+var_8]
.text$mn:00008509                 push    eax
.text$mn:0000850A                 call    ?_Nextnode@?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@SAAAPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@2@PAU32@@Z ; std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>::_Nextnode(std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *)
.text$mn:0000850F                 add     esp, 4
.text$mn:00008512                 mov     ecx, [eax]
.text$mn:00008514                 mov     [ebp+var_C], ecx
.text$mn:00008517                 mov     edx, [ebp+var_8]
.text$mn:0000851A                 push    edx             ; void *
.text$mn:0000851B                 mov     ecx, [ebp+var_4]
.text$mn:0000851E                 call    ?_Freenode@?$_List_buy@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAEXPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@2@@Z ; std::_List_buy<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>::_Freenode(std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *)
.text$mn:00008523                 jmp     short loc_84F5
.text$mn:00008525 ; ---------------------------------------------------------------------------
.text$mn:00008525
.text$mn:00008525 loc_8525:                               ; CODE XREF: std::list<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>::clear(void)+74j
.text$mn:00008525                 mov     esp, ebp
.text$mn:00008527                 pop     ebp
.text$mn:00008528                 retn
.text$mn:00008528 ?clear@?$list@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAEXXZ endp
.text$mn:00008528
.text$mn:00008528 ; ---------------------------------------------------------------------------
.text$mn:00008529                 align 4
.text$mn:00008529 _text$mn        ends
.text$mn:00008529
.text$mn:0000852C ; ===========================================================================
.text$mn:0000852C
.text$mn:0000852C ; Segment type: Pure code
.text$mn:0000852C ; Segment permissions: Read/Execute
.text$mn:0000852C _text$mn        segment para public 'CODE' use32
.text$mn:0000852C                 assume cs:_text$mn
.text$mn:0000852C                 ;org 852Ch
.text$mn:0000852C ; COMDAT (pick any)
.text$mn:0000852C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000852C
.text$mn:0000852C ; =============== S U B R O U T I N E =======================================
.text$mn:0000852C
.text$mn:0000852C ; Attributes: bp-based frame
.text$mn:0000852C
.text$mn:0000852C ; public: void __thiscall std::vector<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>, struct std::_Wrap_alloc<class std::allocator<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>>>>::clear(void)
.text$mn:0000852C                 public ?clear@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAEXXZ
.text$mn:0000852C ?clear@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAEXXZ proc near
.text$mn:0000852C                                         ; CODE XREF: std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::assign(uint,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const &)+2Bp
.text$mn:0000852C
.text$mn:0000852C var_4           = dword ptr -4
.text$mn:0000852C
.text$mn:0000852C                 push    ebp
.text$mn:0000852D                 mov     ebp, esp
.text$mn:0000852F                 push    ecx
.text$mn:00008530                 mov     [ebp+var_4], ecx
.text$mn:00008533                 mov     ecx, [ebp+var_4] ; this
.text$mn:00008536                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:0000853B                 mov     eax, [ebp+var_4]
.text$mn:0000853E                 mov     ecx, [eax+8]
.text$mn:00008541                 push    ecx
.text$mn:00008542                 mov     edx, [ebp+var_4]
.text$mn:00008545                 mov     eax, [edx+4]
.text$mn:00008548                 push    eax
.text$mn:00008549                 mov     ecx, [ebp+var_4]
.text$mn:0000854C                 call    ?_Destroy@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@0@Z ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::_Destroy(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *)
.text$mn:00008551                 mov     ecx, [ebp+var_4]
.text$mn:00008554                 mov     edx, [ebp+var_4]
.text$mn:00008557                 mov     eax, [edx+4]
.text$mn:0000855A                 mov     [ecx+8], eax
.text$mn:0000855D                 mov     esp, ebp
.text$mn:0000855F                 pop     ebp
.text$mn:00008560                 retn
.text$mn:00008560 ?clear@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAEXXZ endp
.text$mn:00008560
.text$mn:00008560 ; ---------------------------------------------------------------------------
.text$mn:00008561                 align 4
.text$mn:00008561 _text$mn        ends
.text$mn:00008561
.text$mn:00008564 ; ===========================================================================
.text$mn:00008564
.text$mn:00008564 ; Segment type: Pure code
.text$mn:00008564 ; Segment permissions: Read/Execute
.text$mn:00008564 _text$mn        segment para public 'CODE' use32
.text$mn:00008564                 assume cs:_text$mn
.text$mn:00008564                 ;org 8564h
.text$mn:00008564 ; COMDAT (pick any)
.text$mn:00008564                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008564
.text$mn:00008564 ; =============== S U B R O U T I N E =======================================
.text$mn:00008564
.text$mn:00008564 ; Attributes: bp-based frame
.text$mn:00008564
.text$mn:00008564 ; int __stdcall std::allocator<ScintillaEditView *>::construct(void *, int)
.text$mn:00008564                 public ?construct@?$allocator@PAVScintillaEditView@@@std@@QAEXPAPAVScintillaEditView@@ABQAV3@@Z
.text$mn:00008564 ?construct@?$allocator@PAVScintillaEditView@@@std@@QAEXPAPAVScintillaEditView@@ABQAV3@@Z proc near
.text$mn:00008564                                         ; CODE XREF: std::allocator_traits<std::allocator<ScintillaEditView *>>::construct<ScintillaEditView *,ScintillaEditView * const &>(std::allocator<ScintillaEditView *> &,ScintillaEditView * *,ScintillaEditView * const &)+17p
.text$mn:00008564
.text$mn:00008564 var_C           = dword ptr -0Ch
.text$mn:00008564 var_8           = dword ptr -8
.text$mn:00008564 var_4           = dword ptr -4
.text$mn:00008564 arg_0           = dword ptr  8
.text$mn:00008564 arg_4           = dword ptr  0Ch
.text$mn:00008564
.text$mn:00008564                 push    ebp
.text$mn:00008565                 mov     ebp, esp
.text$mn:00008567                 sub     esp, 0Ch
.text$mn:0000856A                 mov     [ebp+var_C], ecx
.text$mn:0000856D                 mov     eax, [ebp+arg_0]
.text$mn:00008570                 push    eax             ; void *
.text$mn:00008571                 push    4               ; unsigned int
.text$mn:00008573                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00008578                 add     esp, 8
.text$mn:0000857B                 mov     [ebp+var_4], eax
.text$mn:0000857E                 cmp     [ebp+var_4], 0
.text$mn:00008582                 jz      short loc_8596
.text$mn:00008584                 mov     ecx, [ebp+var_4]
.text$mn:00008587                 mov     edx, [ebp+arg_4]
.text$mn:0000858A                 mov     eax, [edx]
.text$mn:0000858C                 mov     [ecx], eax
.text$mn:0000858E                 mov     ecx, [ebp+var_4]
.text$mn:00008591                 mov     [ebp+var_8], ecx
.text$mn:00008594                 jmp     short loc_859D
.text$mn:00008596 ; ---------------------------------------------------------------------------
.text$mn:00008596
.text$mn:00008596 loc_8596:                               ; CODE XREF: std::allocator<ScintillaEditView *>::construct(ScintillaEditView * *,ScintillaEditView * const &)+1Ej
.text$mn:00008596                 mov     [ebp+var_8], 0
.text$mn:0000859D
.text$mn:0000859D loc_859D:                               ; CODE XREF: std::allocator<ScintillaEditView *>::construct(ScintillaEditView * *,ScintillaEditView * const &)+30j
.text$mn:0000859D                 mov     esp, ebp
.text$mn:0000859F                 pop     ebp
.text$mn:000085A0                 retn    8
.text$mn:000085A0 ?construct@?$allocator@PAVScintillaEditView@@@std@@QAEXPAPAVScintillaEditView@@ABQAV3@@Z endp
.text$mn:000085A0
.text$mn:000085A0 ; ---------------------------------------------------------------------------
.text$mn:000085A3                 align 4
.text$mn:000085A3 _text$mn        ends
.text$mn:000085A3
.text$mn:000085A4 ; ===========================================================================
.text$mn:000085A4
.text$mn:000085A4 ; Segment type: Pure code
.text$mn:000085A4 ; Segment permissions: Read/Execute
.text$mn:000085A4 _text$mn        segment para public 'CODE' use32
.text$mn:000085A4                 assume cs:_text$mn
.text$mn:000085A4                 ;org 85A4h
.text$mn:000085A4 ; COMDAT (pick any)
.text$mn:000085A4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000085A4
.text$mn:000085A4 ; =============== S U B R O U T I N E =======================================
.text$mn:000085A4
.text$mn:000085A4 ; Attributes: bp-based frame
.text$mn:000085A4
.text$mn:000085A4 ; int __stdcall std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>::construct(void *, int)
.text$mn:000085A4                 public ?construct@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@ABV32@@Z
.text$mn:000085A4 ?construct@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@ABV32@@Z proc near
.text$mn:000085A4                                         ; CODE XREF: std::allocator_traits<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>::construct<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const &>(std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>> &,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,st
.text$mn:000085A4
.text$mn:000085A4 var_C           = dword ptr -0Ch
.text$mn:000085A4 var_8           = dword ptr -8
.text$mn:000085A4 var_4           = dword ptr -4
.text$mn:000085A4 arg_0           = dword ptr  8
.text$mn:000085A4 arg_4           = dword ptr  0Ch
.text$mn:000085A4
.text$mn:000085A4                 push    ebp
.text$mn:000085A5                 mov     ebp, esp
.text$mn:000085A7                 sub     esp, 0Ch
.text$mn:000085AA                 mov     [ebp+var_C], ecx
.text$mn:000085AD                 mov     eax, [ebp+arg_0]
.text$mn:000085B0                 push    eax             ; void *
.text$mn:000085B1                 push    4               ; unsigned int
.text$mn:000085B3                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:000085B8                 add     esp, 8
.text$mn:000085BB                 mov     [ebp+var_4], eax
.text$mn:000085BE                 cmp     [ebp+var_4], 0
.text$mn:000085C2                 jz      short loc_85D6
.text$mn:000085C4                 mov     ecx, [ebp+arg_4]
.text$mn:000085C7                 mov     edx, [ecx]
.text$mn:000085C9                 mov     eax, [ebp+var_4]
.text$mn:000085CC                 mov     [eax], edx
.text$mn:000085CE                 mov     ecx, [ebp+var_4]
.text$mn:000085D1                 mov     [ebp+var_8], ecx
.text$mn:000085D4                 jmp     short loc_85DD
.text$mn:000085D6 ; ---------------------------------------------------------------------------
.text$mn:000085D6
.text$mn:000085D6 loc_85D6:                               ; CODE XREF: std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>::construct(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const &)+1Ej
.text$mn:000085D6                 mov     [ebp+var_8], 0
.text$mn:000085DD
.text$mn:000085DD loc_85DD:                               ; CODE XREF: std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>::construct(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const &)+30j
.text$mn:000085DD                 mov     esp, ebp
.text$mn:000085DF                 pop     ebp
.text$mn:000085E0                 retn    8
.text$mn:000085E0 ?construct@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@ABV32@@Z endp
.text$mn:000085E0
.text$mn:000085E0 ; ---------------------------------------------------------------------------
.text$mn:000085E3                 align 4
.text$mn:000085E3 _text$mn        ends
.text$mn:000085E3
.text$mn:000085E4 ; ===========================================================================
.text$mn:000085E4
.text$mn:000085E4 ; Segment type: Pure code
.text$mn:000085E4 ; Segment permissions: Read/Execute
.text$mn:000085E4 _text$mn        segment para public 'CODE' use32
.text$mn:000085E4                 assume cs:_text$mn
.text$mn:000085E4                 ;org 85E4h
.text$mn:000085E4 ; COMDAT (pick any)
.text$mn:000085E4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000085E4
.text$mn:000085E4 ; =============== S U B R O U T I N E =======================================
.text$mn:000085E4
.text$mn:000085E4 ; Attributes: bp-based frame
.text$mn:000085E4
.text$mn:000085E4 ; int __cdecl std::char_traits<char>::copy(void *Dst, void *Src, size_t Size)
.text$mn:000085E4                 public ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
.text$mn:000085E4 ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z proc near ; CODE XREF: $LN19+1Ep
.text$mn:000085E4                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+5Dp ...
.text$mn:000085E4
.text$mn:000085E4 var_4           = dword ptr -4
.text$mn:000085E4 Dst             = dword ptr  8
.text$mn:000085E4 Src             = dword ptr  0Ch
.text$mn:000085E4 Size            = dword ptr  10h
.text$mn:000085E4
.text$mn:000085E4                 push    ebp
.text$mn:000085E5                 mov     ebp, esp
.text$mn:000085E7                 push    ecx
.text$mn:000085E8                 cmp     [ebp+Size], 0
.text$mn:000085EC                 jnz     short loc_85F6
.text$mn:000085EE                 mov     eax, [ebp+Dst]
.text$mn:000085F1                 mov     [ebp+var_4], eax
.text$mn:000085F4                 jmp     short loc_860D
.text$mn:000085F6 ; ---------------------------------------------------------------------------
.text$mn:000085F6
.text$mn:000085F6 loc_85F6:                               ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+8j
.text$mn:000085F6                 mov     ecx, [ebp+Size]
.text$mn:000085F9                 push    ecx             ; Size
.text$mn:000085FA                 mov     edx, [ebp+Src]
.text$mn:000085FD                 push    edx             ; Src
.text$mn:000085FE                 mov     eax, [ebp+Dst]
.text$mn:00008601                 push    eax             ; Dst
.text$mn:00008602                 call    _memcpy
.text$mn:00008607                 add     esp, 0Ch
.text$mn:0000860A                 mov     [ebp+var_4], eax
.text$mn:0000860D
.text$mn:0000860D loc_860D:                               ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+10j
.text$mn:0000860D                 mov     eax, [ebp+var_4]
.text$mn:00008610                 mov     esp, ebp
.text$mn:00008612                 pop     ebp
.text$mn:00008613                 retn
.text$mn:00008613 ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z endp
.text$mn:00008613
.text$mn:00008613 _text$mn        ends
.text$mn:00008613
.text$mn:00008614 ; ===========================================================================
.text$mn:00008614
.text$mn:00008614 ; Segment type: Pure code
.text$mn:00008614 ; Segment permissions: Read/Execute
.text$mn:00008614 _text$mn        segment para public 'CODE' use32
.text$mn:00008614                 assume cs:_text$mn
.text$mn:00008614                 ;org 8614h
.text$mn:00008614 ; COMDAT (pick any)
.text$mn:00008614                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008614
.text$mn:00008614 ; =============== S U B R O U T I N E =======================================
.text$mn:00008614
.text$mn:00008614 ; Attributes: bp-based frame
.text$mn:00008614
.text$mn:00008614 ; int __cdecl std::char_traits<wchar_t>::copy(void *Dst, void *Src, int)
.text$mn:00008614                 public ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z
.text$mn:00008614 ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z proc near
.text$mn:00008614                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+5Dp
.text$mn:00008614
.text$mn:00008614 var_4           = dword ptr -4
.text$mn:00008614 Dst             = dword ptr  8
.text$mn:00008614 Src             = dword ptr  0Ch
.text$mn:00008614 arg_8           = dword ptr  10h
.text$mn:00008614
.text$mn:00008614                 push    ebp
.text$mn:00008615                 mov     ebp, esp
.text$mn:00008617                 push    ecx
.text$mn:00008618                 cmp     [ebp+arg_8], 0
.text$mn:0000861C                 jnz     short loc_8626
.text$mn:0000861E                 mov     eax, [ebp+Dst]
.text$mn:00008621                 mov     [ebp+var_4], eax
.text$mn:00008624                 jmp     short loc_863D
.text$mn:00008626 ; ---------------------------------------------------------------------------
.text$mn:00008626
.text$mn:00008626 loc_8626:                               ; CODE XREF: std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)+8j
.text$mn:00008626                 mov     ecx, [ebp+arg_8]
.text$mn:00008629                 push    ecx             ; int
.text$mn:0000862A                 mov     edx, [ebp+Src]
.text$mn:0000862D                 push    edx             ; Src
.text$mn:0000862E                 mov     eax, [ebp+Dst]
.text$mn:00008631                 push    eax             ; Dst
.text$mn:00008632                 call    _wmemcpy
.text$mn:00008637                 add     esp, 0Ch
.text$mn:0000863A                 mov     [ebp+var_4], eax
.text$mn:0000863D
.text$mn:0000863D loc_863D:                               ; CODE XREF: std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)+10j
.text$mn:0000863D                 mov     eax, [ebp+var_4]
.text$mn:00008640                 mov     esp, ebp
.text$mn:00008642                 pop     ebp
.text$mn:00008643                 retn
.text$mn:00008643 ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z endp
.text$mn:00008643
.text$mn:00008643 _text$mn        ends
.text$mn:00008643
.text$mn:00008644 ; ===========================================================================
.text$mn:00008644
.text$mn:00008644 ; Segment type: Pure code
.text$mn:00008644 ; Segment permissions: Read/Execute
.text$mn:00008644 _text$mn        segment para public 'CODE' use32
.text$mn:00008644                 assume cs:_text$mn
.text$mn:00008644                 ;org 8644h
.text$mn:00008644 ; COMDAT (pick any)
.text$mn:00008644                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008644
.text$mn:00008644 ; =============== S U B R O U T I N E =======================================
.text$mn:00008644
.text$mn:00008644 ; Attributes: bp-based frame
.text$mn:00008644
.text$mn:00008644 ; int __stdcall std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_Container_proxy>>>::deallocate(void *, int)
.text$mn:00008644                 public ?deallocate@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z
.text$mn:00008644 ?deallocate@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z proc near
.text$mn:00008644                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>>>>>::_Free_proxy(void)+32p
.text$mn:00008644                                         ; std::_Vector_alloc<0,std::_Vec_base_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>>::_Free_proxy(void)+32p
.text$mn:00008644
.text$mn:00008644 var_4           = dword ptr -4
.text$mn:00008644 arg_0           = dword ptr  8
.text$mn:00008644 arg_4           = dword ptr  0Ch
.text$mn:00008644
.text$mn:00008644                 push    ebp
.text$mn:00008645                 mov     ebp, esp
.text$mn:00008647                 push    ecx
.text$mn:00008648                 mov     [ebp+var_4], ecx
.text$mn:0000864B                 mov     eax, [ebp+arg_4]
.text$mn:0000864E                 push    eax             ; int
.text$mn:0000864F                 mov     ecx, [ebp+arg_0]
.text$mn:00008652                 push    ecx             ; void *
.text$mn:00008653                 mov     ecx, [ebp+var_4]
.text$mn:00008656                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::deallocate(std::_Container_proxy *,uint)
.text$mn:0000865B                 mov     esp, ebp
.text$mn:0000865D                 pop     ebp
.text$mn:0000865E                 retn    8
.text$mn:0000865E ?deallocate@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z endp
.text$mn:0000865E
.text$mn:0000865E ; ---------------------------------------------------------------------------
.text$mn:00008661                 align 4
.text$mn:00008661 _text$mn        ends
.text$mn:00008661
.text$mn:00008664 ; ===========================================================================
.text$mn:00008664
.text$mn:00008664 ; Segment type: Pure code
.text$mn:00008664 ; Segment permissions: Read/Execute
.text$mn:00008664 _text$mn        segment para public 'CODE' use32
.text$mn:00008664                 assume cs:_text$mn
.text$mn:00008664                 ;org 8664h
.text$mn:00008664 ; COMDAT (pick any)
.text$mn:00008664                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008664
.text$mn:00008664 ; =============== S U B R O U T I N E =======================================
.text$mn:00008664
.text$mn:00008664 ; Attributes: bp-based frame
.text$mn:00008664
.text$mn:00008664 ; int __stdcall std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>>>>::deallocate(void *, int)
.text$mn:00008664                 public ?deallocate@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@2@I@Z
.text$mn:00008664 ?deallocate@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@2@I@Z proc near
.text$mn:00008664                                         ; CODE XREF: std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>>>>::_Tidy(void)+55p
.text$mn:00008664
.text$mn:00008664 var_4           = dword ptr -4
.text$mn:00008664 arg_0           = dword ptr  8
.text$mn:00008664 arg_4           = dword ptr  0Ch
.text$mn:00008664
.text$mn:00008664                 push    ebp
.text$mn:00008665                 mov     ebp, esp
.text$mn:00008667                 push    ecx
.text$mn:00008668                 mov     [ebp+var_4], ecx
.text$mn:0000866B                 mov     eax, [ebp+arg_4]
.text$mn:0000866E                 push    eax             ; int
.text$mn:0000866F                 mov     ecx, [ebp+arg_0]
.text$mn:00008672                 push    ecx             ; void *
.text$mn:00008673                 mov     ecx, [ebp+var_4]
.text$mn:00008676                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>>>::deallocate(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>> *,uint)
.text$mn:0000867B                 mov     esp, ebp
.text$mn:0000867D                 pop     ebp
.text$mn:0000867E                 retn    8
.text$mn:0000867E ?deallocate@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@2@I@Z endp
.text$mn:0000867E
.text$mn:0000867E ; ---------------------------------------------------------------------------
.text$mn:00008681                 align 4
.text$mn:00008681 _text$mn        ends
.text$mn:00008681
.text$mn:00008684 ; ===========================================================================
.text$mn:00008684
.text$mn:00008684 ; Segment type: Pure code
.text$mn:00008684 ; Segment permissions: Read/Execute
.text$mn:00008684 _text$mn        segment para public 'CODE' use32
.text$mn:00008684                 assume cs:_text$mn
.text$mn:00008684                 ;org 8684h
.text$mn:00008684 ; COMDAT (pick any)
.text$mn:00008684                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008684
.text$mn:00008684 ; =============== S U B R O U T I N E =======================================
.text$mn:00008684
.text$mn:00008684 ; Attributes: bp-based frame
.text$mn:00008684
.text$mn:00008684 ; int __stdcall std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::deallocate(void *, int)
.text$mn:00008684                 public ?deallocate@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@I@Z
.text$mn:00008684 ?deallocate@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@I@Z proc near
.text$mn:00008684                                         ; CODE XREF: __catch$?_Insert_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$p
.text$mn:00008684                                         ; ?_Insert_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@s ...
.text$mn:00008684
.text$mn:00008684 var_4           = dword ptr -4
.text$mn:00008684 arg_0           = dword ptr  8
.text$mn:00008684 arg_4           = dword ptr  0Ch
.text$mn:00008684
.text$mn:00008684                 push    ebp
.text$mn:00008685                 mov     ebp, esp
.text$mn:00008687                 push    ecx
.text$mn:00008688                 mov     [ebp+var_4], ecx
.text$mn:0000868B                 mov     eax, [ebp+arg_4]
.text$mn:0000868E                 push    eax             ; int
.text$mn:0000868F                 mov     ecx, [ebp+arg_0]
.text$mn:00008692                 push    ecx             ; void *
.text$mn:00008693                 mov     ecx, [ebp+var_4]
.text$mn:00008696                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>::deallocate(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,uint)
.text$mn:0000869B                 mov     esp, ebp
.text$mn:0000869D                 pop     ebp
.text$mn:0000869E                 retn    8
.text$mn:0000869E ?deallocate@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@I@Z endp
.text$mn:0000869E
.text$mn:0000869E ; ---------------------------------------------------------------------------
.text$mn:000086A1                 align 4
.text$mn:000086A1 _text$mn        ends
.text$mn:000086A1
.text$mn:000086A4 ; ===========================================================================
.text$mn:000086A4
.text$mn:000086A4 ; Segment type: Pure code
.text$mn:000086A4 ; Segment permissions: Read/Execute
.text$mn:000086A4 _text$mn        segment para public 'CODE' use32
.text$mn:000086A4                 assume cs:_text$mn
.text$mn:000086A4                 ;org 86A4h
.text$mn:000086A4 ; COMDAT (pick any)
.text$mn:000086A4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000086A4
.text$mn:000086A4 ; =============== S U B R O U T I N E =======================================
.text$mn:000086A4
.text$mn:000086A4 ; Attributes: bp-based frame
.text$mn:000086A4
.text$mn:000086A4 ; int __stdcall std::_Wrap_alloc<std::allocator<char>>::deallocate(void *, int)
.text$mn:000086A4                 public ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
.text$mn:000086A4 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z proc near
.text$mn:000086A4                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+81p
.text$mn:000086A4
.text$mn:000086A4 var_4           = dword ptr -4
.text$mn:000086A4 arg_0           = dword ptr  8
.text$mn:000086A4 arg_4           = dword ptr  0Ch
.text$mn:000086A4
.text$mn:000086A4                 push    ebp
.text$mn:000086A5                 mov     ebp, esp
.text$mn:000086A7                 push    ecx
.text$mn:000086A8                 mov     [ebp+var_4], ecx
.text$mn:000086AB                 mov     eax, [ebp+arg_4]
.text$mn:000086AE                 push    eax             ; int
.text$mn:000086AF                 mov     ecx, [ebp+arg_0]
.text$mn:000086B2                 push    ecx             ; void *
.text$mn:000086B3                 mov     ecx, [ebp+var_4]
.text$mn:000086B6                 call    ?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate(char *,uint)
.text$mn:000086BB                 mov     esp, ebp
.text$mn:000086BD                 pop     ebp
.text$mn:000086BE                 retn    8
.text$mn:000086BE ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z endp
.text$mn:000086BE
.text$mn:000086BE ; ---------------------------------------------------------------------------
.text$mn:000086C1                 align 4
.text$mn:000086C1 _text$mn        ends
.text$mn:000086C1
.text$mn:000086C4 ; ===========================================================================
.text$mn:000086C4
.text$mn:000086C4 ; Segment type: Pure code
.text$mn:000086C4 ; Segment permissions: Read/Execute
.text$mn:000086C4 _text$mn        segment para public 'CODE' use32
.text$mn:000086C4                 assume cs:_text$mn
.text$mn:000086C4                 ;org 86C4h
.text$mn:000086C4 ; COMDAT (pick any)
.text$mn:000086C4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000086C4
.text$mn:000086C4 ; =============== S U B R O U T I N E =======================================
.text$mn:000086C4
.text$mn:000086C4 ; Attributes: bp-based frame
.text$mn:000086C4
.text$mn:000086C4 ; int __stdcall std::_Wrap_alloc<std::allocator<ScintillaEditView *>>::deallocate(void *, int)
.text$mn:000086C4                 public ?deallocate@?$_Wrap_alloc@V?$allocator@PAVScintillaEditView@@@std@@@std@@QAEXPAPAVScintillaEditView@@I@Z
.text$mn:000086C4 ?deallocate@?$_Wrap_alloc@V?$allocator@PAVScintillaEditView@@@std@@@std@@QAEXPAPAVScintillaEditView@@I@Z proc near
.text$mn:000086C4                                         ; CODE XREF: __catch$?_Reallocate@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@IAEXI@Z$0+16p
.text$mn:000086C4                                         ; std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::_Reallocate(uint)+F5p
.text$mn:000086C4
.text$mn:000086C4 var_4           = dword ptr -4
.text$mn:000086C4 arg_0           = dword ptr  8
.text$mn:000086C4 arg_4           = dword ptr  0Ch
.text$mn:000086C4
.text$mn:000086C4                 push    ebp
.text$mn:000086C5                 mov     ebp, esp
.text$mn:000086C7                 push    ecx
.text$mn:000086C8                 mov     [ebp+var_4], ecx
.text$mn:000086CB                 mov     eax, [ebp+arg_4]
.text$mn:000086CE                 push    eax             ; int
.text$mn:000086CF                 mov     ecx, [ebp+arg_0]
.text$mn:000086D2                 push    ecx             ; void *
.text$mn:000086D3                 mov     ecx, [ebp+var_4]
.text$mn:000086D6                 call    ?deallocate@?$allocator@PAVScintillaEditView@@@std@@QAEXPAPAVScintillaEditView@@I@Z ; std::allocator<ScintillaEditView *>::deallocate(ScintillaEditView * *,uint)
.text$mn:000086DB                 mov     esp, ebp
.text$mn:000086DD                 pop     ebp
.text$mn:000086DE                 retn    8
.text$mn:000086DE ?deallocate@?$_Wrap_alloc@V?$allocator@PAVScintillaEditView@@@std@@@std@@QAEXPAPAVScintillaEditView@@I@Z endp
.text$mn:000086DE
.text$mn:000086DE ; ---------------------------------------------------------------------------
.text$mn:000086E1                 align 4
.text$mn:000086E1 _text$mn        ends
.text$mn:000086E1
.text$mn:000086E4 ; ===========================================================================
.text$mn:000086E4
.text$mn:000086E4 ; Segment type: Pure code
.text$mn:000086E4 ; Segment permissions: Read/Execute
.text$mn:000086E4 _text$mn        segment para public 'CODE' use32
.text$mn:000086E4                 assume cs:_text$mn
.text$mn:000086E4                 ;org 86E4h
.text$mn:000086E4 ; COMDAT (pick any)
.text$mn:000086E4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000086E4
.text$mn:000086E4 ; =============== S U B R O U T I N E =======================================
.text$mn:000086E4
.text$mn:000086E4 ; Attributes: bp-based frame
.text$mn:000086E4
.text$mn:000086E4 ; int __stdcall std::_Wrap_alloc<std::allocator<std::_List_node<std::pair<int const,Style>,void *>>>::deallocate(void *, int)
.text$mn:000086E4                 public ?deallocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@2@I@Z
.text$mn:000086E4 ?deallocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@2@I@Z proc near
.text$mn:000086E4                                         ; CODE XREF: std::_List_alloc<0,std::_List_base_types<std::pair<int const,Style>,std::allocator<std::pair<int const,Style>>>>::_Freeheadnode(std::_List_node<std::pair<int const,Style>,void *> *)+6Fp
.text$mn:000086E4                                         ; std::_List_buy<std::pair<int const,Style>,std::allocator<std::pair<int const,Style>>>::_Freenode(std::_List_node<std::pair<int const,Style>,void *> *)+98p
.text$mn:000086E4
.text$mn:000086E4 var_4           = dword ptr -4
.text$mn:000086E4 arg_0           = dword ptr  8
.text$mn:000086E4 arg_4           = dword ptr  0Ch
.text$mn:000086E4
.text$mn:000086E4                 push    ebp
.text$mn:000086E5                 mov     ebp, esp
.text$mn:000086E7                 push    ecx
.text$mn:000086E8                 mov     [ebp+var_4], ecx
.text$mn:000086EB                 mov     eax, [ebp+arg_4]
.text$mn:000086EE                 push    eax             ; int
.text$mn:000086EF                 mov     ecx, [ebp+arg_0]
.text$mn:000086F2                 push    ecx             ; void *
.text$mn:000086F3                 mov     ecx, [ebp+var_4]
.text$mn:000086F6                 call    ?deallocate@?$allocator@U?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@std@@@std@@QAEXPAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@2@I@Z ; std::allocator<std::_List_node<std::pair<int const,Style>,void *>>::deallocate(std::_List_node<std::pair<int const,Style>,void *> *,uint)
.text$mn:000086FB                 mov     esp, ebp
.text$mn:000086FD                 pop     ebp
.text$mn:000086FE                 retn    8
.text$mn:000086FE ?deallocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@2@I@Z endp
.text$mn:000086FE
.text$mn:000086FE ; ---------------------------------------------------------------------------
.text$mn:00008701                 align 4
.text$mn:00008701 _text$mn        ends
.text$mn:00008701
.text$mn:00008704 ; ===========================================================================
.text$mn:00008704
.text$mn:00008704 ; Segment type: Pure code
.text$mn:00008704 ; Segment permissions: Read/Execute
.text$mn:00008704 _text$mn        segment para public 'CODE' use32
.text$mn:00008704                 assume cs:_text$mn
.text$mn:00008704                 ;org 8704h
.text$mn:00008704 ; COMDAT (pick any)
.text$mn:00008704                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008704
.text$mn:00008704 ; =============== S U B R O U T I N E =======================================
.text$mn:00008704
.text$mn:00008704 ; Attributes: bp-based frame
.text$mn:00008704
.text$mn:00008704 ; int __stdcall std::_Wrap_alloc<std::allocator<std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *>>>::deallocate(void *, int)
.text$mn:00008704                 public ?deallocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@2@I@Z
.text$mn:00008704 ?deallocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@2@I@Z proc near
.text$mn:00008704                                         ; CODE XREF: __catch$?_Buynode0@?$_List_alloc@$0A@U?$_List_base_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@@std@@QAEPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@2@PAU32@0@Z$0+14p
.text$mn:00008704                                         ; std::_List_alloc<0,std::_List_base_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::_Freeheadnode(std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *)+6Fp ...
.text$mn:00008704
.text$mn:00008704 var_4           = dword ptr -4
.text$mn:00008704 arg_0           = dword ptr  8
.text$mn:00008704 arg_4           = dword ptr  0Ch
.text$mn:00008704
.text$mn:00008704                 push    ebp
.text$mn:00008705                 mov     ebp, esp
.text$mn:00008707                 push    ecx
.text$mn:00008708                 mov     [ebp+var_4], ecx
.text$mn:0000870B                 mov     eax, [ebp+arg_4]
.text$mn:0000870E                 push    eax             ; int
.text$mn:0000870F                 mov     ecx, [ebp+arg_0]
.text$mn:00008712                 push    ecx             ; void *
.text$mn:00008713                 mov     ecx, [ebp+var_4]
.text$mn:00008716                 call    ?deallocate@?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@QAEXPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@2@I@Z ; std::allocator<std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *>>::deallocate(std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *,uint)
.text$mn:0000871B                 mov     esp, ebp
.text$mn:0000871D                 pop     ebp
.text$mn:0000871E                 retn    8
.text$mn:0000871E ?deallocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@2@I@Z endp
.text$mn:0000871E
.text$mn:0000871E ; ---------------------------------------------------------------------------
.text$mn:00008721                 align 4
.text$mn:00008721 _text$mn        ends
.text$mn:00008721
.text$mn:00008724 ; ===========================================================================
.text$mn:00008724
.text$mn:00008724 ; Segment type: Pure code
.text$mn:00008724 ; Segment permissions: Read/Execute
.text$mn:00008724 _text$mn        segment para public 'CODE' use32
.text$mn:00008724                 assume cs:_text$mn
.text$mn:00008724                 ;org 8724h
.text$mn:00008724 ; COMDAT (pick any)
.text$mn:00008724                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008724
.text$mn:00008724 ; =============== S U B R O U T I N E =======================================
.text$mn:00008724
.text$mn:00008724 ; Attributes: bp-based frame
.text$mn:00008724
.text$mn:00008724 ; int __stdcall std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::deallocate(void *, int)
.text$mn:00008724                 public ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z
.text$mn:00008724 ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z proc near
.text$mn:00008724                                         ; CODE XREF: std::_List_alloc<0,std::_List_base_types<std::pair<int const,Style>,std::allocator<std::pair<int const,Style>>>>::_Free_proxy(void)+32p
.text$mn:00008724                                         ; std::_List_alloc<0,std::_List_base_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::_Free_proxy(void)+32p ...
.text$mn:00008724
.text$mn:00008724 var_4           = dword ptr -4
.text$mn:00008724 arg_0           = dword ptr  8
.text$mn:00008724 arg_4           = dword ptr  0Ch
.text$mn:00008724
.text$mn:00008724                 push    ebp
.text$mn:00008725                 mov     ebp, esp
.text$mn:00008727                 push    ecx
.text$mn:00008728                 mov     [ebp+var_4], ecx
.text$mn:0000872B                 mov     eax, [ebp+arg_4]
.text$mn:0000872E                 push    eax             ; int
.text$mn:0000872F                 mov     ecx, [ebp+arg_0]
.text$mn:00008732                 push    ecx             ; void *
.text$mn:00008733                 mov     ecx, [ebp+var_4]
.text$mn:00008736                 call    ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate(std::_Container_proxy *,uint)
.text$mn:0000873B                 mov     esp, ebp
.text$mn:0000873D                 pop     ebp
.text$mn:0000873E                 retn    8
.text$mn:0000873E ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z endp
.text$mn:0000873E
.text$mn:0000873E ; ---------------------------------------------------------------------------
.text$mn:00008741                 align 4
.text$mn:00008741 _text$mn        ends
.text$mn:00008741
.text$mn:00008744 ; ===========================================================================
.text$mn:00008744
.text$mn:00008744 ; Segment type: Pure code
.text$mn:00008744 ; Segment permissions: Read/Execute
.text$mn:00008744 _text$mn        segment para public 'CODE' use32
.text$mn:00008744                 assume cs:_text$mn
.text$mn:00008744                 ;org 8744h
.text$mn:00008744 ; COMDAT (pick any)
.text$mn:00008744                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008744
.text$mn:00008744 ; =============== S U B R O U T I N E =======================================
.text$mn:00008744
.text$mn:00008744 ; Attributes: bp-based frame
.text$mn:00008744
.text$mn:00008744 ; int __stdcall std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>>>::deallocate(void *, int)
.text$mn:00008744                 public ?deallocate@?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@2@I@Z
.text$mn:00008744 ?deallocate@?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@2@I@Z proc near
.text$mn:00008744                                         ; CODE XREF: std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>>>>::deallocate(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>> *,uint)+12p
.text$mn:00008744
.text$mn:00008744 var_4           = dword ptr -4
.text$mn:00008744 arg_0           = dword ptr  8
.text$mn:00008744 arg_4           = dword ptr  0Ch
.text$mn:00008744
.text$mn:00008744                 push    ebp
.text$mn:00008745                 mov     ebp, esp
.text$mn:00008747                 push    ecx
.text$mn:00008748                 mov     [ebp+var_4], ecx
.text$mn:0000874B                 mov     eax, [ebp+arg_4]
.text$mn:0000874E                 push    eax             ; int
.text$mn:0000874F                 mov     ecx, [ebp+arg_0]
.text$mn:00008752                 push    ecx             ; void *
.text$mn:00008753                 mov     ecx, [ebp+var_4]
.text$mn:00008756                 call    ?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@2@I@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>>::deallocate(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>> *,uint)
.text$mn:0000875B                 mov     esp, ebp
.text$mn:0000875D                 pop     ebp
.text$mn:0000875E                 retn    8
.text$mn:0000875E ?deallocate@?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@2@I@Z endp
.text$mn:0000875E
.text$mn:0000875E ; ---------------------------------------------------------------------------
.text$mn:00008761                 align 4
.text$mn:00008761 _text$mn        ends
.text$mn:00008761
.text$mn:00008764 ; ===========================================================================
.text$mn:00008764
.text$mn:00008764 ; Segment type: Pure code
.text$mn:00008764 ; Segment permissions: Read/Execute
.text$mn:00008764 _text$mn        segment para public 'CODE' use32
.text$mn:00008764                 assume cs:_text$mn
.text$mn:00008764                 ;org 8764h
.text$mn:00008764 ; COMDAT (pick any)
.text$mn:00008764                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008764
.text$mn:00008764 ; =============== S U B R O U T I N E =======================================
.text$mn:00008764
.text$mn:00008764 ; Attributes: bp-based frame
.text$mn:00008764
.text$mn:00008764 ; int __stdcall std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>::deallocate(void *, int)
.text$mn:00008764                 public ?deallocate@?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@I@Z
.text$mn:00008764 ?deallocate@?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@I@Z proc near
.text$mn:00008764                                         ; CODE XREF: std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::deallocate(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,uint)+12p
.text$mn:00008764
.text$mn:00008764 var_4           = dword ptr -4
.text$mn:00008764 arg_0           = dword ptr  8
.text$mn:00008764 arg_4           = dword ptr  0Ch
.text$mn:00008764
.text$mn:00008764                 push    ebp
.text$mn:00008765                 mov     ebp, esp
.text$mn:00008767                 push    ecx
.text$mn:00008768                 mov     [ebp+var_4], ecx
.text$mn:0000876B                 mov     eax, [ebp+arg_4]
.text$mn:0000876E                 push    eax             ; int
.text$mn:0000876F                 mov     ecx, [ebp+arg_0]
.text$mn:00008772                 push    ecx             ; void *
.text$mn:00008773                 mov     ecx, [ebp+var_4]
.text$mn:00008776                 call    ?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@I@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>::deallocate(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,uint)
.text$mn:0000877B                 mov     esp, ebp
.text$mn:0000877D                 pop     ebp
.text$mn:0000877E                 retn    8
.text$mn:0000877E ?deallocate@?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@I@Z endp
.text$mn:0000877E
.text$mn:0000877E ; ---------------------------------------------------------------------------
.text$mn:00008781                 align 4
.text$mn:00008781 _text$mn        ends
.text$mn:00008781
.text$mn:00008784 ; ===========================================================================
.text$mn:00008784
.text$mn:00008784 ; Segment type: Pure code
.text$mn:00008784 ; Segment permissions: Read/Execute
.text$mn:00008784 _text$mn        segment para public 'CODE' use32
.text$mn:00008784                 assume cs:_text$mn
.text$mn:00008784                 ;org 8784h
.text$mn:00008784 ; COMDAT (pick any)
.text$mn:00008784                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008784
.text$mn:00008784 ; =============== S U B R O U T I N E =======================================
.text$mn:00008784
.text$mn:00008784 ; Attributes: bp-based frame
.text$mn:00008784
.text$mn:00008784 ; int __stdcall std::_Wrap_alloc<std::allocator<wchar_t>>::deallocate(void *, int)
.text$mn:00008784                 public ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z
.text$mn:00008784 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z proc near
.text$mn:00008784                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+81p
.text$mn:00008784
.text$mn:00008784 var_4           = dword ptr -4
.text$mn:00008784 arg_0           = dword ptr  8
.text$mn:00008784 arg_4           = dword ptr  0Ch
.text$mn:00008784
.text$mn:00008784                 push    ebp
.text$mn:00008785                 mov     ebp, esp
.text$mn:00008787                 push    ecx
.text$mn:00008788                 mov     [ebp+var_4], ecx
.text$mn:0000878B                 mov     eax, [ebp+arg_4]
.text$mn:0000878E                 push    eax             ; int
.text$mn:0000878F                 mov     ecx, [ebp+arg_0]
.text$mn:00008792                 push    ecx             ; void *
.text$mn:00008793                 mov     ecx, [ebp+var_4]
.text$mn:00008796                 call    ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z ; std::allocator<wchar_t>::deallocate(wchar_t *,uint)
.text$mn:0000879B                 mov     esp, ebp
.text$mn:0000879D                 pop     ebp
.text$mn:0000879E                 retn    8
.text$mn:0000879E ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z endp
.text$mn:0000879E
.text$mn:0000879E ; ---------------------------------------------------------------------------
.text$mn:000087A1                 align 4
.text$mn:000087A1 _text$mn        ends
.text$mn:000087A1
.text$mn:000087A4 ; ===========================================================================
.text$mn:000087A4
.text$mn:000087A4 ; Segment type: Pure code
.text$mn:000087A4 ; Segment permissions: Read/Execute
.text$mn:000087A4 _text$mn        segment para public 'CODE' use32
.text$mn:000087A4                 assume cs:_text$mn
.text$mn:000087A4                 ;org 87A4h
.text$mn:000087A4 ; COMDAT (pick any)
.text$mn:000087A4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000087A4
.text$mn:000087A4 ; =============== S U B R O U T I N E =======================================
.text$mn:000087A4
.text$mn:000087A4 ; Attributes: bp-based frame
.text$mn:000087A4
.text$mn:000087A4 ; int __stdcall std::allocator<char>::deallocate(void *, int)
.text$mn:000087A4                 public ?deallocate@?$allocator@D@std@@QAEXPADI@Z
.text$mn:000087A4 ?deallocate@?$allocator@D@std@@QAEXPADI@Z proc near
.text$mn:000087A4                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)+12p
.text$mn:000087A4
.text$mn:000087A4 var_4           = dword ptr -4
.text$mn:000087A4 arg_0           = dword ptr  8
.text$mn:000087A4
.text$mn:000087A4                 push    ebp
.text$mn:000087A5                 mov     ebp, esp
.text$mn:000087A7                 push    ecx
.text$mn:000087A8                 mov     [ebp+var_4], ecx
.text$mn:000087AB                 mov     eax, [ebp+arg_0]
.text$mn:000087AE                 push    eax             ; void *
.text$mn:000087AF                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:000087B4                 add     esp, 4
.text$mn:000087B7                 mov     esp, ebp
.text$mn:000087B9                 pop     ebp
.text$mn:000087BA                 retn    8
.text$mn:000087BA ?deallocate@?$allocator@D@std@@QAEXPADI@Z endp
.text$mn:000087BA
.text$mn:000087BA ; ---------------------------------------------------------------------------
.text$mn:000087BD                 align 10h
.text$mn:000087BD _text$mn        ends
.text$mn:000087BD
.text$mn:000087C0 ; ===========================================================================
.text$mn:000087C0
.text$mn:000087C0 ; Segment type: Pure code
.text$mn:000087C0 ; Segment permissions: Read/Execute
.text$mn:000087C0 _text$mn        segment para public 'CODE' use32
.text$mn:000087C0                 assume cs:_text$mn
.text$mn:000087C0                 ;org 87C0h
.text$mn:000087C0 ; COMDAT (pick any)
.text$mn:000087C0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000087C0
.text$mn:000087C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000087C0
.text$mn:000087C0 ; Attributes: bp-based frame
.text$mn:000087C0
.text$mn:000087C0 ; int __stdcall std::allocator<ScintillaEditView *>::deallocate(void *, int)
.text$mn:000087C0                 public ?deallocate@?$allocator@PAVScintillaEditView@@@std@@QAEXPAPAVScintillaEditView@@I@Z
.text$mn:000087C0 ?deallocate@?$allocator@PAVScintillaEditView@@@std@@QAEXPAPAVScintillaEditView@@I@Z proc near
.text$mn:000087C0                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<ScintillaEditView *>>::deallocate(ScintillaEditView * *,uint)+12p
.text$mn:000087C0
.text$mn:000087C0 var_4           = dword ptr -4
.text$mn:000087C0 arg_0           = dword ptr  8
.text$mn:000087C0
.text$mn:000087C0                 push    ebp
.text$mn:000087C1                 mov     ebp, esp
.text$mn:000087C3                 push    ecx
.text$mn:000087C4                 mov     [ebp+var_4], ecx
.text$mn:000087C7                 mov     eax, [ebp+arg_0]
.text$mn:000087CA                 push    eax             ; void *
.text$mn:000087CB                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:000087D0                 add     esp, 4
.text$mn:000087D3                 mov     esp, ebp
.text$mn:000087D5                 pop     ebp
.text$mn:000087D6                 retn    8
.text$mn:000087D6 ?deallocate@?$allocator@PAVScintillaEditView@@@std@@QAEXPAPAVScintillaEditView@@I@Z endp
.text$mn:000087D6
.text$mn:000087D6 ; ---------------------------------------------------------------------------
.text$mn:000087D9                 align 4
.text$mn:000087D9 _text$mn        ends
.text$mn:000087D9
.text$mn:000087DC ; ===========================================================================
.text$mn:000087DC
.text$mn:000087DC ; Segment type: Pure code
.text$mn:000087DC ; Segment permissions: Read/Execute
.text$mn:000087DC _text$mn        segment para public 'CODE' use32
.text$mn:000087DC                 assume cs:_text$mn
.text$mn:000087DC                 ;org 87DCh
.text$mn:000087DC ; COMDAT (pick any)
.text$mn:000087DC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000087DC
.text$mn:000087DC ; =============== S U B R O U T I N E =======================================
.text$mn:000087DC
.text$mn:000087DC ; Attributes: bp-based frame
.text$mn:000087DC
.text$mn:000087DC ; int __stdcall std::allocator<std::_List_node<std::pair<int const,Style>,void *>>::deallocate(void *, int)
.text$mn:000087DC                 public ?deallocate@?$allocator@U?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@std@@@std@@QAEXPAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@2@I@Z
.text$mn:000087DC ?deallocate@?$allocator@U?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@std@@@std@@QAEXPAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@2@I@Z proc near
.text$mn:000087DC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::_List_node<std::pair<int const,Style>,void *>>>::deallocate(std::_List_node<std::pair<int const,Style>,void *> *,uint)+12p
.text$mn:000087DC
.text$mn:000087DC var_4           = dword ptr -4
.text$mn:000087DC arg_0           = dword ptr  8
.text$mn:000087DC
.text$mn:000087DC                 push    ebp
.text$mn:000087DD                 mov     ebp, esp
.text$mn:000087DF                 push    ecx
.text$mn:000087E0                 mov     [ebp+var_4], ecx
.text$mn:000087E3                 mov     eax, [ebp+arg_0]
.text$mn:000087E6                 push    eax             ; void *
.text$mn:000087E7                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:000087EC                 add     esp, 4
.text$mn:000087EF                 mov     esp, ebp
.text$mn:000087F1                 pop     ebp
.text$mn:000087F2                 retn    8
.text$mn:000087F2 ?deallocate@?$allocator@U?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@std@@@std@@QAEXPAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@2@I@Z endp
.text$mn:000087F2
.text$mn:000087F2 ; ---------------------------------------------------------------------------
.text$mn:000087F5                 align 4
.text$mn:000087F5 _text$mn        ends
.text$mn:000087F5
.text$mn:000087F8 ; ===========================================================================
.text$mn:000087F8
.text$mn:000087F8 ; Segment type: Pure code
.text$mn:000087F8 ; Segment permissions: Read/Execute
.text$mn:000087F8 _text$mn        segment para public 'CODE' use32
.text$mn:000087F8                 assume cs:_text$mn
.text$mn:000087F8                 ;org 87F8h
.text$mn:000087F8 ; COMDAT (pick any)
.text$mn:000087F8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000087F8
.text$mn:000087F8 ; =============== S U B R O U T I N E =======================================
.text$mn:000087F8
.text$mn:000087F8 ; Attributes: bp-based frame
.text$mn:000087F8
.text$mn:000087F8 ; int __stdcall std::allocator<std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *>>::deallocate(void *, int)
.text$mn:000087F8                 public ?deallocate@?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@QAEXPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@2@I@Z
.text$mn:000087F8 ?deallocate@?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@QAEXPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@2@I@Z proc near
.text$mn:000087F8                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *>>>::deallocate(std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *,uint)+12p
.text$mn:000087F8
.text$mn:000087F8 var_4           = dword ptr -4
.text$mn:000087F8 arg_0           = dword ptr  8
.text$mn:000087F8
.text$mn:000087F8                 push    ebp
.text$mn:000087F9                 mov     ebp, esp
.text$mn:000087FB                 push    ecx
.text$mn:000087FC                 mov     [ebp+var_4], ecx
.text$mn:000087FF                 mov     eax, [ebp+arg_0]
.text$mn:00008802                 push    eax             ; void *
.text$mn:00008803                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00008808                 add     esp, 4
.text$mn:0000880B                 mov     esp, ebp
.text$mn:0000880D                 pop     ebp
.text$mn:0000880E                 retn    8
.text$mn:0000880E ?deallocate@?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@QAEXPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@2@I@Z endp
.text$mn:0000880E
.text$mn:0000880E ; ---------------------------------------------------------------------------
.text$mn:00008811                 align 4
.text$mn:00008811 _text$mn        ends
.text$mn:00008811
.text$mn:00008814 ; ===========================================================================
.text$mn:00008814
.text$mn:00008814 ; Segment type: Pure code
.text$mn:00008814 ; Segment permissions: Read/Execute
.text$mn:00008814 _text$mn        segment para public 'CODE' use32
.text$mn:00008814                 assume cs:_text$mn
.text$mn:00008814                 ;org 8814h
.text$mn:00008814 ; COMDAT (pick any)
.text$mn:00008814                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008814
.text$mn:00008814 ; =============== S U B R O U T I N E =======================================
.text$mn:00008814
.text$mn:00008814 ; Attributes: bp-based frame
.text$mn:00008814
.text$mn:00008814 ; int __stdcall std::allocator<std::_Container_proxy>::deallocate(void *, int)
.text$mn:00008814                 public ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z
.text$mn:00008814 ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z proc near
.text$mn:00008814                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+32p
.text$mn:00008814                                         ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Free_proxy(void)+32p ...
.text$mn:00008814
.text$mn:00008814 var_4           = dword ptr -4
.text$mn:00008814 arg_0           = dword ptr  8
.text$mn:00008814
.text$mn:00008814                 push    ebp
.text$mn:00008815                 mov     ebp, esp
.text$mn:00008817                 push    ecx
.text$mn:00008818                 mov     [ebp+var_4], ecx
.text$mn:0000881B                 mov     eax, [ebp+arg_0]
.text$mn:0000881E                 push    eax             ; void *
.text$mn:0000881F                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00008824                 add     esp, 4
.text$mn:00008827                 mov     esp, ebp
.text$mn:00008829                 pop     ebp
.text$mn:0000882A                 retn    8
.text$mn:0000882A ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z endp
.text$mn:0000882A
.text$mn:0000882A ; ---------------------------------------------------------------------------
.text$mn:0000882D                 align 10h
.text$mn:0000882D _text$mn        ends
.text$mn:0000882D
.text$mn:00008830 ; ===========================================================================
.text$mn:00008830
.text$mn:00008830 ; Segment type: Pure code
.text$mn:00008830 ; Segment permissions: Read/Execute
.text$mn:00008830 _text$mn        segment para public 'CODE' use32
.text$mn:00008830                 assume cs:_text$mn
.text$mn:00008830                 ;org 8830h
.text$mn:00008830 ; COMDAT (pick any)
.text$mn:00008830                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008830
.text$mn:00008830 ; =============== S U B R O U T I N E =======================================
.text$mn:00008830
.text$mn:00008830 ; Attributes: bp-based frame
.text$mn:00008830
.text$mn:00008830 ; int __stdcall std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>>::deallocate(void *, int)
.text$mn:00008830                 public ?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@2@I@Z
.text$mn:00008830 ?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@2@I@Z proc near
.text$mn:00008830                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>>>::deallocate(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>> *,uint)+12p
.text$mn:00008830
.text$mn:00008830 var_4           = dword ptr -4
.text$mn:00008830 arg_0           = dword ptr  8
.text$mn:00008830
.text$mn:00008830                 push    ebp
.text$mn:00008831                 mov     ebp, esp
.text$mn:00008833                 push    ecx
.text$mn:00008834                 mov     [ebp+var_4], ecx
.text$mn:00008837                 mov     eax, [ebp+arg_0]
.text$mn:0000883A                 push    eax             ; void *
.text$mn:0000883B                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00008840                 add     esp, 4
.text$mn:00008843                 mov     esp, ebp
.text$mn:00008845                 pop     ebp
.text$mn:00008846                 retn    8
.text$mn:00008846 ?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@2@I@Z endp
.text$mn:00008846
.text$mn:00008846 ; ---------------------------------------------------------------------------
.text$mn:00008849                 align 4
.text$mn:00008849 _text$mn        ends
.text$mn:00008849
.text$mn:0000884C ; ===========================================================================
.text$mn:0000884C
.text$mn:0000884C ; Segment type: Pure code
.text$mn:0000884C ; Segment permissions: Read/Execute
.text$mn:0000884C _text$mn        segment para public 'CODE' use32
.text$mn:0000884C                 assume cs:_text$mn
.text$mn:0000884C                 ;org 884Ch
.text$mn:0000884C ; COMDAT (pick any)
.text$mn:0000884C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000884C
.text$mn:0000884C ; =============== S U B R O U T I N E =======================================
.text$mn:0000884C
.text$mn:0000884C ; Attributes: bp-based frame
.text$mn:0000884C
.text$mn:0000884C ; int __stdcall std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>::deallocate(void *, int)
.text$mn:0000884C                 public ?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@I@Z
.text$mn:0000884C ?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@I@Z proc near
.text$mn:0000884C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>::deallocate(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,uint)+12p
.text$mn:0000884C
.text$mn:0000884C var_4           = dword ptr -4
.text$mn:0000884C arg_0           = dword ptr  8
.text$mn:0000884C
.text$mn:0000884C                 push    ebp
.text$mn:0000884D                 mov     ebp, esp
.text$mn:0000884F                 push    ecx
.text$mn:00008850                 mov     [ebp+var_4], ecx
.text$mn:00008853                 mov     eax, [ebp+arg_0]
.text$mn:00008856                 push    eax             ; void *
.text$mn:00008857                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:0000885C                 add     esp, 4
.text$mn:0000885F                 mov     esp, ebp
.text$mn:00008861                 pop     ebp
.text$mn:00008862                 retn    8
.text$mn:00008862 ?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@I@Z endp
.text$mn:00008862
.text$mn:00008862 ; ---------------------------------------------------------------------------
.text$mn:00008865                 align 4
.text$mn:00008865 _text$mn        ends
.text$mn:00008865
.text$mn:00008868 ; ===========================================================================
.text$mn:00008868
.text$mn:00008868 ; Segment type: Pure code
.text$mn:00008868 ; Segment permissions: Read/Execute
.text$mn:00008868 _text$mn        segment para public 'CODE' use32
.text$mn:00008868                 assume cs:_text$mn
.text$mn:00008868                 ;org 8868h
.text$mn:00008868 ; COMDAT (pick any)
.text$mn:00008868                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008868
.text$mn:00008868 ; =============== S U B R O U T I N E =======================================
.text$mn:00008868
.text$mn:00008868 ; Attributes: bp-based frame
.text$mn:00008868
.text$mn:00008868 ; int __stdcall std::allocator<wchar_t>::deallocate(void *, int)
.text$mn:00008868                 public ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z
.text$mn:00008868 ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z proc near
.text$mn:00008868                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::deallocate(wchar_t *,uint)+12p
.text$mn:00008868
.text$mn:00008868 var_4           = dword ptr -4
.text$mn:00008868 arg_0           = dword ptr  8
.text$mn:00008868
.text$mn:00008868                 push    ebp
.text$mn:00008869                 mov     ebp, esp
.text$mn:0000886B                 push    ecx
.text$mn:0000886C                 mov     [ebp+var_4], ecx
.text$mn:0000886F                 mov     eax, [ebp+arg_0]
.text$mn:00008872                 push    eax             ; void *
.text$mn:00008873                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00008878                 add     esp, 4
.text$mn:0000887B                 mov     esp, ebp
.text$mn:0000887D                 pop     ebp
.text$mn:0000887E                 retn    8
.text$mn:0000887E ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z endp
.text$mn:0000887E
.text$mn:0000887E ; ---------------------------------------------------------------------------
.text$mn:00008881                 align 4
.text$mn:00008881 _text$mn        ends
.text$mn:00008881
.text$mn:00008884 ; ===========================================================================
.text$mn:00008884
.text$mn:00008884 ; Segment type: Pure code
.text$mn:00008884 ; Segment permissions: Read/Execute
.text$mn:00008884 _text$mn        segment para public 'CODE' use32
.text$mn:00008884                 assume cs:_text$mn
.text$mn:00008884                 ;org 8884h
.text$mn:00008884 ; COMDAT (pick any)
.text$mn:00008884                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008884
.text$mn:00008884 ; =============== S U B R O U T I N E =======================================
.text$mn:00008884
.text$mn:00008884 ; Attributes: bp-based frame
.text$mn:00008884
.text$mn:00008884 ; public: virtual class std::error_condition __thiscall std::_System_error_category::default_error_condition(int)const
.text$mn:00008884                 public ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
.text$mn:00008884 ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z proc near
.text$mn:00008884                                         ; DATA XREF: .rdata:0000AF60o
.text$mn:00008884
.text$mn:00008884 var_4           = dword ptr -4
.text$mn:00008884 arg_0           = dword ptr  8
.text$mn:00008884 arg_4           = dword ptr  0Ch
.text$mn:00008884
.text$mn:00008884                 push    ebp
.text$mn:00008885                 mov     ebp, esp
.text$mn:00008887                 push    ecx
.text$mn:00008888                 mov     [ebp+var_4], ecx
.text$mn:0000888B                 mov     eax, [ebp+arg_4]
.text$mn:0000888E                 push    eax             ; int
.text$mn:0000888F                 call    ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map(int)
.text$mn:00008894                 add     esp, 4
.text$mn:00008897                 test    eax, eax
.text$mn:00008899                 jz      short loc_88B4
.text$mn:0000889B                 call    ?generic_category@std@@YAABVerror_category@1@XZ ; std::generic_category(void)
.text$mn:000088A0                 push    eax             ; struct std::error_category *
.text$mn:000088A1                 mov     ecx, [ebp+arg_4]
.text$mn:000088A4                 push    ecx             ; int
.text$mn:000088A5                 mov     ecx, [ebp+arg_0] ; this
.text$mn:000088A8                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:000088AD                 mov     eax, [ebp+arg_0]
.text$mn:000088B0                 jmp     short loc_88C9
.text$mn:000088B2 ; ---------------------------------------------------------------------------
.text$mn:000088B2                 jmp     short loc_88C9
.text$mn:000088B4 ; ---------------------------------------------------------------------------
.text$mn:000088B4
.text$mn:000088B4 loc_88B4:                               ; CODE XREF: std::_System_error_category::default_error_condition(int)+15j
.text$mn:000088B4                 call    ?system_category@std@@YAABVerror_category@1@XZ ; std::system_category(void)
.text$mn:000088B9                 push    eax             ; struct std::error_category *
.text$mn:000088BA                 mov     edx, [ebp+arg_4]
.text$mn:000088BD                 push    edx             ; int
.text$mn:000088BE                 mov     ecx, [ebp+arg_0] ; this
.text$mn:000088C1                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:000088C6                 mov     eax, [ebp+arg_0]
.text$mn:000088C9
.text$mn:000088C9 loc_88C9:                               ; CODE XREF: std::_System_error_category::default_error_condition(int)+2Cj
.text$mn:000088C9                                         ; std::_System_error_category::default_error_condition(int)+2Ej
.text$mn:000088C9                 mov     esp, ebp
.text$mn:000088CB                 pop     ebp
.text$mn:000088CC                 retn    8
.text$mn:000088CC ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z endp
.text$mn:000088CC
.text$mn:000088CC ; ---------------------------------------------------------------------------
.text$mn:000088CF                 align 10h
.text$mn:000088CF _text$mn        ends
.text$mn:000088CF
.text$mn:000088D0 ; ===========================================================================
.text$mn:000088D0
.text$mn:000088D0 ; Segment type: Pure code
.text$mn:000088D0 ; Segment permissions: Read/Execute
.text$mn:000088D0 _text$mn        segment para public 'CODE' use32
.text$mn:000088D0                 assume cs:_text$mn
.text$mn:000088D0                 ;org 88D0h
.text$mn:000088D0 ; COMDAT (pick any)
.text$mn:000088D0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000088D0
.text$mn:000088D0 ; =============== S U B R O U T I N E =======================================
.text$mn:000088D0
.text$mn:000088D0 ; Attributes: bp-based frame
.text$mn:000088D0
.text$mn:000088D0 ; public: virtual class std::error_condition __thiscall std::error_category::default_error_condition(int)const
.text$mn:000088D0                 public ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
.text$mn:000088D0 ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z proc near
.text$mn:000088D0                                         ; DATA XREF: .rdata:0000AED0o
.text$mn:000088D0                                         ; .rdata:0000AEECo ...
.text$mn:000088D0
.text$mn:000088D0 var_4           = dword ptr -4
.text$mn:000088D0 arg_0           = dword ptr  8
.text$mn:000088D0 arg_4           = dword ptr  0Ch
.text$mn:000088D0
.text$mn:000088D0                 push    ebp
.text$mn:000088D1                 mov     ebp, esp
.text$mn:000088D3                 push    ecx
.text$mn:000088D4                 mov     [ebp+var_4], ecx
.text$mn:000088D7                 mov     eax, [ebp+var_4]
.text$mn:000088DA                 push    eax             ; struct std::error_category *
.text$mn:000088DB                 mov     ecx, [ebp+arg_4]
.text$mn:000088DE                 push    ecx             ; int
.text$mn:000088DF                 mov     ecx, [ebp+arg_0] ; this
.text$mn:000088E2                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:000088E7                 mov     eax, [ebp+arg_0]
.text$mn:000088EA                 mov     esp, ebp
.text$mn:000088EC                 pop     ebp
.text$mn:000088ED                 retn    8
.text$mn:000088ED ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z endp
.text$mn:000088ED
.text$mn:000088ED _text$mn        ends
.text$mn:000088ED
.text$mn:000088F0 ; ===========================================================================
.text$mn:000088F0
.text$mn:000088F0 ; Segment type: Pure code
.text$mn:000088F0 ; Segment permissions: Read/Execute
.text$mn:000088F0 _text$mn        segment para public 'CODE' use32
.text$mn:000088F0                 assume cs:_text$mn
.text$mn:000088F0                 ;org 88F0h
.text$mn:000088F0 ; COMDAT (pick any)
.text$mn:000088F0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000088F0
.text$mn:000088F0 ; =============== S U B R O U T I N E =======================================
.text$mn:000088F0
.text$mn:000088F0 ; Attributes: bp-based frame
.text$mn:000088F0
.text$mn:000088F0 ; void __thiscall ScintillaEditView::destroy(ScintillaEditView *__hidden this)
.text$mn:000088F0                 public ?destroy@ScintillaEditView@@UAEXXZ
.text$mn:000088F0 ?destroy@ScintillaEditView@@UAEXXZ proc near ; DATA XREF: .rdata:0000AFC8o
.text$mn:000088F0
.text$mn:000088F0 var_4           = dword ptr -4
.text$mn:000088F0
.text$mn:000088F0                 push    ebp
.text$mn:000088F1                 mov     ebp, esp
.text$mn:000088F3                 push    ecx
.text$mn:000088F4                 mov     [ebp+var_4], ecx
.text$mn:000088F7                 mov     eax, [ebp+var_4]
.text$mn:000088FA                 mov     ecx, [eax+0Ch]
.text$mn:000088FD                 push    ecx             ; hWnd
.text$mn:000088FE                 call    dword ptr ds:__imp__DestroyWindow@4 ; DestroyWindow(x)
.text$mn:00008904                 mov     edx, [ebp+var_4]
.text$mn:00008907                 mov     dword ptr [edx+0Ch], 0
.text$mn:0000890E                 mov     esp, ebp
.text$mn:00008910                 pop     ebp
.text$mn:00008911                 retn
.text$mn:00008911 ?destroy@ScintillaEditView@@UAEXXZ endp
.text$mn:00008911
.text$mn:00008911 ; ---------------------------------------------------------------------------
.text$mn:00008912                 align 4
.text$mn:00008912 _text$mn        ends
.text$mn:00008912
.text$mn:00008914 ; ===========================================================================
.text$mn:00008914
.text$mn:00008914 ; Segment type: Pure code
.text$mn:00008914 ; Segment permissions: Read/Execute
.text$mn:00008914 _text$mn        segment para public 'CODE' use32
.text$mn:00008914                 assume cs:_text$mn
.text$mn:00008914                 ;org 8914h
.text$mn:00008914 ; COMDAT (pick any)
.text$mn:00008914                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008914
.text$mn:00008914 ; =============== S U B R O U T I N E =======================================
.text$mn:00008914
.text$mn:00008914 ; Attributes: bp-based frame
.text$mn:00008914
.text$mn:00008914 ; void __thiscall Window::display(Window *this, bool)
.text$mn:00008914                 public ?display@Window@@UBEX_N@Z
.text$mn:00008914 ?display@Window@@UBEX_N@Z proc near     ; DATA XREF: .rdata:0000AF98o
.text$mn:00008914                                         ; .rdata:0000AFCCo
.text$mn:00008914
.text$mn:00008914 var_8           = dword ptr -8
.text$mn:00008914 nCmdShow        = dword ptr -4
.text$mn:00008914 arg_0           = byte ptr  8
.text$mn:00008914
.text$mn:00008914                 push    ebp
.text$mn:00008915                 mov     ebp, esp
.text$mn:00008917                 sub     esp, 8
.text$mn:0000891A                 mov     [ebp+var_8], ecx
.text$mn:0000891D                 movzx   eax, [ebp+arg_0]
.text$mn:00008921                 test    eax, eax
.text$mn:00008923                 jz      short loc_892E
.text$mn:00008925                 mov     [ebp+nCmdShow], 5
.text$mn:0000892C                 jmp     short loc_8935
.text$mn:0000892E ; ---------------------------------------------------------------------------
.text$mn:0000892E
.text$mn:0000892E loc_892E:                               ; CODE XREF: Window::display(bool)+Fj
.text$mn:0000892E                 mov     [ebp+nCmdShow], 0
.text$mn:00008935
.text$mn:00008935 loc_8935:                               ; CODE XREF: Window::display(bool)+18j
.text$mn:00008935                 mov     ecx, [ebp+nCmdShow]
.text$mn:00008938                 push    ecx             ; nCmdShow
.text$mn:00008939                 mov     edx, [ebp+var_8]
.text$mn:0000893C                 mov     eax, [edx+0Ch]
.text$mn:0000893F                 push    eax             ; hWnd
.text$mn:00008940                 call    dword ptr ds:__imp__ShowWindow@8 ; ShowWindow(x,x)
.text$mn:00008946                 mov     esp, ebp
.text$mn:00008948                 pop     ebp
.text$mn:00008949                 retn    4
.text$mn:00008949 ?display@Window@@UBEX_N@Z endp
.text$mn:00008949
.text$mn:00008949 _text$mn        ends
.text$mn:00008949
.text$mn:0000894C ; ===========================================================================
.text$mn:0000894C
.text$mn:0000894C ; Segment type: Pure code
.text$mn:0000894C ; Segment permissions: Read/Execute
.text$mn:0000894C _text$mn        segment para public 'CODE' use32
.text$mn:0000894C                 assume cs:_text$mn
.text$mn:0000894C                 ;org 894Ch
.text$mn:0000894C ; COMDAT (pick any)
.text$mn:0000894C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000894C
.text$mn:0000894C ; =============== S U B R O U T I N E =======================================
.text$mn:0000894C
.text$mn:0000894C ; Attributes: bp-based frame
.text$mn:0000894C
.text$mn:0000894C ; public: class std::_List_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<int const, struct Style>>>> __thiscall std::_Hash<class std::_Umap_traits<int, struct Style, class std::_Uhash_compare<int, struct std::hash<int>, struct std::equal_to<int>>, class std::allocator<struct std::pair<int const, struct Style>>, 0>>::end(void)
.text$mn:0000894C                 public ?end@?$_Hash@V?$_Umap_traits@HUStyle@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@2@XZ
.text$mn:0000894C ?end@?$_Hash@V?$_Umap_traits@HUStyle@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@2@XZ proc near
.text$mn:0000894C                                         ; CODE XREF: ScintillaEditView::~ScintillaEditView(void)+F8p
.text$mn:0000894C
.text$mn:0000894C var_14          = dword ptr -14h
.text$mn:0000894C var_10          = dword ptr -10h
.text$mn:0000894C var_C           = dword ptr -0Ch
.text$mn:0000894C var_4           = dword ptr -4
.text$mn:0000894C arg_0           = dword ptr  8
.text$mn:0000894C
.text$mn:0000894C                 push    ebp
.text$mn:0000894D                 mov     ebp, esp
.text$mn:0000894F                 push    0FFFFFFFFh
.text$mn:00008951                 push    offset __ehhandler$?end@?$_Hash@V?$_Umap_traits@HUStyle@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@2@XZ
.text$mn:00008956                 mov     eax, large fs:0
.text$mn:0000895C                 push    eax
.text$mn:0000895D                 sub     esp, 8
.text$mn:00008960                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00008965                 xor     eax, ebp
.text$mn:00008967                 push    eax
.text$mn:00008968                 lea     eax, [ebp+var_C]
.text$mn:0000896B                 mov     large fs:0, eax
.text$mn:00008971                 mov     [ebp+var_14], ecx
.text$mn:00008974                 mov     [ebp+var_10], 0
.text$mn:0000897B                 mov     eax, [ebp+arg_0]
.text$mn:0000897E                 push    eax
.text$mn:0000897F                 mov     ecx, [ebp+var_14]
.text$mn:00008982                 call    ?end@?$list@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@2@XZ ; std::list<std::pair<int const,Style>,std::allocator<std::pair<int const,Style>>>::end(void)
.text$mn:00008987                 mov     [ebp+var_4], 0
.text$mn:0000898E                 mov     ecx, [ebp+var_10]
.text$mn:00008991                 or      ecx, 1
.text$mn:00008994                 mov     [ebp+var_10], ecx
.text$mn:00008997                 mov     eax, [ebp+arg_0]
.text$mn:0000899A                 mov     ecx, [ebp+var_C]
.text$mn:0000899D                 mov     large fs:0, ecx
.text$mn:000089A4                 pop     ecx
.text$mn:000089A5                 mov     esp, ebp
.text$mn:000089A7                 pop     ebp
.text$mn:000089A8                 retn    4
.text$mn:000089A8 ?end@?$_Hash@V?$_Umap_traits@HUStyle@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@2@XZ endp
.text$mn:000089A8
.text$mn:000089A8 ; ---------------------------------------------------------------------------
.text$mn:000089AB                 align 4
.text$mn:000089AB _text$mn        ends
.text$mn:000089AB
.text$x:000089AC ; ===========================================================================
.text$x:000089AC
.text$x:000089AC ; Segment type: Pure code
.text$x:000089AC ; Segment permissions: Read/Execute
.text$x:000089AC _text$x         segment para public 'CODE' use32
.text$x:000089AC                 assume cs:_text$x
.text$x:000089AC                 ;org 89ACh
.text$x:000089AC ; COMDAT (pick associative to section at 894C)
.text$x:000089AC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000089AC
.text$x:000089AC ; =============== S U B R O U T I N E =======================================
.text$x:000089AC
.text$x:000089AC
.text$x:000089AC __unwindfunclet$?end@?$_Hash@V?$_Umap_traits@HUStyle@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@2@XZ$0 proc near
.text$x:000089AC                                         ; DATA XREF: .xdata$x:0000A688o
.text$x:000089AC                 mov     eax, [ebp-10h]
.text$x:000089AF                 and     eax, 1
.text$x:000089B2                 jz      $LN4_8
.text$x:000089B8                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:000089BC                 mov     ecx, [ebp+8]
.text$x:000089BF                 jmp     ??1?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>::~_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>(void)
.text$x:000089C4 ; ---------------------------------------------------------------------------
.text$x:000089C4
.text$x:000089C4 $LN4_8:                                 ; CODE XREF: __unwindfunclet$?end@?$_Hash@V?$_Umap_traits@HUStyle@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@2@XZ$0+6j
.text$x:000089C4                 retn
.text$x:000089C4 __unwindfunclet$?end@?$_Hash@V?$_Umap_traits@HUStyle@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@2@XZ$0 endp
.text$x:000089C4
.text$x:000089C5
.text$x:000089C5 ; =============== S U B R O U T I N E =======================================
.text$x:000089C5
.text$x:000089C5
.text$x:000089C5 __ehhandler$?end@?$_Hash@V?$_Umap_traits@HUStyle@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@2@XZ proc near
.text$x:000089C5                                         ; DATA XREF: std::_Hash<std::_Umap_traits<int,Style,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int>>,std::allocator<std::pair<int const,Style>>,0>>::end(void)+5o
.text$x:000089C5
.text$x:000089C5 arg_4           = dword ptr  8
.text$x:000089C5
.text$x:000089C5                 mov     edx, [esp+arg_4]
.text$x:000089C9                 lea     eax, [edx+0Ch]
.text$x:000089CC                 mov     ecx, [edx-0Ch]
.text$x:000089CF                 xor     ecx, eax
.text$x:000089D1                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000089D6                 mov     eax, offset __ehfuncinfo$?end@?$_Hash@V?$_Umap_traits@HUStyle@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@2@XZ
.text$x:000089DB                 jmp     ___CxxFrameHandler3
.text$x:000089DB __ehhandler$?end@?$_Hash@V?$_Umap_traits@HUStyle@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@2@XZ endp
.text$x:000089DB
.text$x:000089DB _text$x         ends
.text$x:000089DB
.text$mn:000089E0 ; ===========================================================================
.text$mn:000089E0
.text$mn:000089E0 ; Segment type: Pure code
.text$mn:000089E0 ; Segment permissions: Read/Execute
.text$mn:000089E0 _text$mn        segment para public 'CODE' use32
.text$mn:000089E0                 assume cs:_text$mn
.text$mn:000089E0                 ;org 89E0h
.text$mn:000089E0 ; COMDAT (pick any)
.text$mn:000089E0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000089E0
.text$mn:000089E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000089E0
.text$mn:000089E0 ; Attributes: bp-based frame
.text$mn:000089E0
.text$mn:000089E0 ; public: class std::_List_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>> __thiscall std::_Hash<class std::_Umap_traits<class Buffer *, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *, class std::_Uhash_compare<class Buffer *, struct std::hash<class Buffer *>, struct std::equal_to<class Buffer *>>, class std::allocator<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>, 0>>::end(void)
.text$mn:000089E0                 public ?end@?$_Hash@V?$_Umap_traits@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@V?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@XZ
.text$mn:000089E0 ?end@?$_Hash@V?$_Umap_traits@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@V?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@XZ proc near
.text$mn:000089E0                                         ; CODE XREF: ScintillaEditView::~ScintillaEditView(void)+8Ep
.text$mn:000089E0
.text$mn:000089E0 var_14          = dword ptr -14h
.text$mn:000089E0 var_10          = dword ptr -10h
.text$mn:000089E0 var_C           = dword ptr -0Ch
.text$mn:000089E0 var_4           = dword ptr -4
.text$mn:000089E0 arg_0           = dword ptr  8
.text$mn:000089E0
.text$mn:000089E0                 push    ebp
.text$mn:000089E1                 mov     ebp, esp
.text$mn:000089E3                 push    0FFFFFFFFh
.text$mn:000089E5                 push    offset __ehhandler$?end@?$_Hash@V?$_Umap_traits@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@V?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@XZ
.text$mn:000089EA                 mov     eax, large fs:0
.text$mn:000089F0                 push    eax
.text$mn:000089F1                 sub     esp, 8
.text$mn:000089F4                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000089F9                 xor     eax, ebp
.text$mn:000089FB                 push    eax
.text$mn:000089FC                 lea     eax, [ebp+var_C]
.text$mn:000089FF                 mov     large fs:0, eax
.text$mn:00008A05                 mov     [ebp+var_14], ecx
.text$mn:00008A08                 mov     [ebp+var_10], 0
.text$mn:00008A0F                 mov     eax, [ebp+arg_0]
.text$mn:00008A12                 push    eax
.text$mn:00008A13                 mov     ecx, [ebp+var_14]
.text$mn:00008A16                 call    ?end@?$list@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@XZ ; std::list<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>::end(void)
.text$mn:00008A1B                 mov     [ebp+var_4], 0
.text$mn:00008A22                 mov     ecx, [ebp+var_10]
.text$mn:00008A25                 or      ecx, 1
.text$mn:00008A28                 mov     [ebp+var_10], ecx
.text$mn:00008A2B                 mov     eax, [ebp+arg_0]
.text$mn:00008A2E                 mov     ecx, [ebp+var_C]
.text$mn:00008A31                 mov     large fs:0, ecx
.text$mn:00008A38                 pop     ecx
.text$mn:00008A39                 mov     esp, ebp
.text$mn:00008A3B                 pop     ebp
.text$mn:00008A3C                 retn    4
.text$mn:00008A3C ?end@?$_Hash@V?$_Umap_traits@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@V?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@XZ endp
.text$mn:00008A3C
.text$mn:00008A3C ; ---------------------------------------------------------------------------
.text$mn:00008A3F                 align 10h
.text$mn:00008A3F _text$mn        ends
.text$mn:00008A3F
.text$x:00008A40 ; ===========================================================================
.text$x:00008A40
.text$x:00008A40 ; Segment type: Pure code
.text$x:00008A40 ; Segment permissions: Read/Execute
.text$x:00008A40 _text$x         segment para public 'CODE' use32
.text$x:00008A40                 assume cs:_text$x
.text$x:00008A40                 ;org 8A40h
.text$x:00008A40 ; COMDAT (pick associative to section at 89E0)
.text$x:00008A40                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00008A40
.text$x:00008A40 ; =============== S U B R O U T I N E =======================================
.text$x:00008A40
.text$x:00008A40
.text$x:00008A40 __unwindfunclet$?end@?$_Hash@V?$_Umap_traits@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@V?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@XZ$0 proc near
.text$x:00008A40                                         ; DATA XREF: .xdata$x:0000A09Co
.text$x:00008A40                 mov     eax, [ebp-10h]
.text$x:00008A43                 and     eax, 1
.text$x:00008A46                 jz      $LN4_3
.text$x:00008A4C                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:00008A50                 mov     ecx, [ebp+8]
.text$x:00008A53                 jmp     ??1?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::~_List_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>(void)
.text$x:00008A58 ; ---------------------------------------------------------------------------
.text$x:00008A58
.text$x:00008A58 $LN4_3:                                 ; CODE XREF: __unwindfunclet$?end@?$_Hash@V?$_Umap_traits@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@V?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@XZ$0+6j
.text$x:00008A58                 retn
.text$x:00008A58 __unwindfunclet$?end@?$_Hash@V?$_Umap_traits@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@V?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@XZ$0 endp
.text$x:00008A58
.text$x:00008A59
.text$x:00008A59 ; =============== S U B R O U T I N E =======================================
.text$x:00008A59
.text$x:00008A59
.text$x:00008A59 __ehhandler$?end@?$_Hash@V?$_Umap_traits@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@V?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@XZ proc near
.text$x:00008A59                                         ; DATA XREF: std::_Hash<std::_Umap_traits<Buffer *,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *,std::_Uhash_compare<Buffer *,std::hash<Buffer *>,std::equal_to<Buffer *>>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>,0>>::end(void)+5o
.text$x:00008A59
.text$x:00008A59 arg_4           = dword ptr  8
.text$x:00008A59
.text$x:00008A59                 mov     edx, [esp+arg_4]
.text$x:00008A5D                 lea     eax, [edx+0Ch]
.text$x:00008A60                 mov     ecx, [edx-0Ch]
.text$x:00008A63                 xor     ecx, eax
.text$x:00008A65                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00008A6A                 mov     eax, offset __ehfuncinfo$?end@?$_Hash@V?$_Umap_traits@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@V?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@XZ
.text$x:00008A6F                 jmp     ___CxxFrameHandler3
.text$x:00008A6F __ehhandler$?end@?$_Hash@V?$_Umap_traits@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@V?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@XZ endp
.text$x:00008A6F
.text$x:00008A6F _text$x         ends
.text$x:00008A6F
.text$mn:00008A74 ; ===========================================================================
.text$mn:00008A74
.text$mn:00008A74 ; Segment type: Pure code
.text$mn:00008A74 ; Segment permissions: Read/Execute
.text$mn:00008A74 _text$mn        segment para public 'CODE' use32
.text$mn:00008A74                 assume cs:_text$mn
.text$mn:00008A74                 ;org 8A74h
.text$mn:00008A74 ; COMDAT (pick any)
.text$mn:00008A74                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008A74
.text$mn:00008A74 ; =============== S U B R O U T I N E =======================================
.text$mn:00008A74
.text$mn:00008A74 ; Attributes: bp-based frame
.text$mn:00008A74
.text$mn:00008A74 ; public: class std::_List_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<int const, struct Style>>>> __thiscall std::list<struct std::pair<int const, struct Style>, class std::allocator<struct std::pair<int const, struct Style>>>::end(void)
.text$mn:00008A74                 public ?end@?$list@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@2@XZ
.text$mn:00008A74 ?end@?$list@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@2@XZ proc near
.text$mn:00008A74                                         ; CODE XREF: std::_Hash<std::_Umap_traits<int,Style,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int>>,std::allocator<std::pair<int const,Style>>,0>>::end(void)+36p
.text$mn:00008A74
.text$mn:00008A74 var_14          = dword ptr -14h
.text$mn:00008A74 var_10          = dword ptr -10h
.text$mn:00008A74 var_C           = dword ptr -0Ch
.text$mn:00008A74 var_4           = dword ptr -4
.text$mn:00008A74 arg_0           = dword ptr  8
.text$mn:00008A74
.text$mn:00008A74                 push    ebp
.text$mn:00008A75                 mov     ebp, esp
.text$mn:00008A77                 push    0FFFFFFFFh
.text$mn:00008A79                 push    offset __ehhandler$?end@?$list@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@2@XZ
.text$mn:00008A7E                 mov     eax, large fs:0
.text$mn:00008A84                 push    eax
.text$mn:00008A85                 sub     esp, 8
.text$mn:00008A88                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00008A8D                 xor     eax, ebp
.text$mn:00008A8F                 push    eax
.text$mn:00008A90                 lea     eax, [ebp+var_C]
.text$mn:00008A93                 mov     large fs:0, eax
.text$mn:00008A99                 mov     [ebp+var_10], ecx
.text$mn:00008A9C                 mov     [ebp+var_14], 0
.text$mn:00008AA3                 mov     eax, [ebp+var_10]
.text$mn:00008AA6                 push    eax             ; struct std::_Container_base12 *
.text$mn:00008AA7                 mov     ecx, [ebp+var_10]
.text$mn:00008AAA                 mov     edx, [ecx+4]
.text$mn:00008AAD                 push    edx             ; int
.text$mn:00008AAE                 mov     ecx, [ebp+arg_0]
.text$mn:00008AB1                 call    ??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@1@@Z ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>(std::_List_node<std::pair<int const,Style>,void *> *,std::_List_val<std::_List_simple_types<std::pair<int const,Style>>> const *)
.text$mn:00008AB6                 mov     [ebp+var_4], 0
.text$mn:00008ABD                 mov     eax, [ebp+var_14]
.text$mn:00008AC0                 or      eax, 1
.text$mn:00008AC3                 mov     [ebp+var_14], eax
.text$mn:00008AC6                 mov     eax, [ebp+arg_0]
.text$mn:00008AC9                 mov     ecx, [ebp+var_C]
.text$mn:00008ACC                 mov     large fs:0, ecx
.text$mn:00008AD3                 pop     ecx
.text$mn:00008AD4                 mov     esp, ebp
.text$mn:00008AD6                 pop     ebp
.text$mn:00008AD7                 retn    4
.text$mn:00008AD7 ?end@?$list@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@2@XZ endp
.text$mn:00008AD7
.text$mn:00008AD7 ; ---------------------------------------------------------------------------
.text$mn:00008ADA                 align 4
.text$mn:00008ADA _text$mn        ends
.text$mn:00008ADA
.text$x:00008ADC ; ===========================================================================
.text$x:00008ADC
.text$x:00008ADC ; Segment type: Pure code
.text$x:00008ADC ; Segment permissions: Read/Execute
.text$x:00008ADC _text$x         segment para public 'CODE' use32
.text$x:00008ADC                 assume cs:_text$x
.text$x:00008ADC                 ;org 8ADCh
.text$x:00008ADC ; COMDAT (pick associative to section at 8A74)
.text$x:00008ADC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00008ADC
.text$x:00008ADC ; =============== S U B R O U T I N E =======================================
.text$x:00008ADC
.text$x:00008ADC
.text$x:00008ADC __unwindfunclet$?end@?$list@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@2@XZ$0 proc near
.text$x:00008ADC                                         ; DATA XREF: .xdata$x:0000A5D0o
.text$x:00008ADC                 mov     eax, [ebp-14h]
.text$x:00008ADF                 and     eax, 1
.text$x:00008AE2                 jz      $LN4_6
.text$x:00008AE8                 and     dword ptr [ebp-14h], 0FFFFFFFEh
.text$x:00008AEC                 mov     ecx, [ebp+8]
.text$x:00008AEF                 jmp     ??1?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>::~_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>(void)
.text$x:00008AF4 ; ---------------------------------------------------------------------------
.text$x:00008AF4
.text$x:00008AF4 $LN4_6:                                 ; CODE XREF: __unwindfunclet$?end@?$list@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@2@XZ$0+6j
.text$x:00008AF4                 retn
.text$x:00008AF4 __unwindfunclet$?end@?$list@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@2@XZ$0 endp
.text$x:00008AF4
.text$x:00008AF5
.text$x:00008AF5 ; =============== S U B R O U T I N E =======================================
.text$x:00008AF5
.text$x:00008AF5
.text$x:00008AF5 __ehhandler$?end@?$list@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@2@XZ proc near
.text$x:00008AF5                                         ; DATA XREF: std::list<std::pair<int const,Style>,std::allocator<std::pair<int const,Style>>>::end(void)+5o
.text$x:00008AF5
.text$x:00008AF5 arg_4           = dword ptr  8
.text$x:00008AF5
.text$x:00008AF5                 mov     edx, [esp+arg_4]
.text$x:00008AF9                 lea     eax, [edx+0Ch]
.text$x:00008AFC                 mov     ecx, [edx-0Ch]
.text$x:00008AFF                 xor     ecx, eax
.text$x:00008B01                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00008B06                 mov     eax, offset __ehfuncinfo$?end@?$list@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@2@XZ
.text$x:00008B0B                 jmp     ___CxxFrameHandler3
.text$x:00008B0B __ehhandler$?end@?$list@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@2@XZ endp
.text$x:00008B0B
.text$x:00008B0B _text$x         ends
.text$x:00008B0B
.text$mn:00008B10 ; ===========================================================================
.text$mn:00008B10
.text$mn:00008B10 ; Segment type: Pure code
.text$mn:00008B10 ; Segment permissions: Read/Execute
.text$mn:00008B10 _text$mn        segment para public 'CODE' use32
.text$mn:00008B10                 assume cs:_text$mn
.text$mn:00008B10                 ;org 8B10h
.text$mn:00008B10 ; COMDAT (pick any)
.text$mn:00008B10                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008B10
.text$mn:00008B10 ; =============== S U B R O U T I N E =======================================
.text$mn:00008B10
.text$mn:00008B10 ; Attributes: bp-based frame
.text$mn:00008B10
.text$mn:00008B10 ; public: class std::_List_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>> __thiscall std::list<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>, class std::allocator<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>::end(void)
.text$mn:00008B10                 public ?end@?$list@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@XZ
.text$mn:00008B10 ?end@?$list@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@XZ proc near
.text$mn:00008B10                                         ; CODE XREF: std::_Hash<std::_Umap_traits<Buffer *,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *,std::_Uhash_compare<Buffer *,std::hash<Buffer *>,std::equal_to<Buffer *>>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>,0>>::end(void)+36p
.text$mn:00008B10
.text$mn:00008B10 var_14          = dword ptr -14h
.text$mn:00008B10 var_10          = dword ptr -10h
.text$mn:00008B10 var_C           = dword ptr -0Ch
.text$mn:00008B10 var_4           = dword ptr -4
.text$mn:00008B10 arg_0           = dword ptr  8
.text$mn:00008B10
.text$mn:00008B10                 push    ebp
.text$mn:00008B11                 mov     ebp, esp
.text$mn:00008B13                 push    0FFFFFFFFh
.text$mn:00008B15                 push    offset __ehhandler$?end@?$list@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@XZ
.text$mn:00008B1A                 mov     eax, large fs:0
.text$mn:00008B20                 push    eax
.text$mn:00008B21                 sub     esp, 8
.text$mn:00008B24                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00008B29                 xor     eax, ebp
.text$mn:00008B2B                 push    eax
.text$mn:00008B2C                 lea     eax, [ebp+var_C]
.text$mn:00008B2F                 mov     large fs:0, eax
.text$mn:00008B35                 mov     [ebp+var_10], ecx
.text$mn:00008B38                 mov     [ebp+var_14], 0
.text$mn:00008B3F                 mov     eax, [ebp+var_10]
.text$mn:00008B42                 push    eax             ; struct std::_Container_base12 *
.text$mn:00008B43                 mov     ecx, [ebp+var_10]
.text$mn:00008B46                 mov     edx, [ecx+4]
.text$mn:00008B49                 push    edx             ; int
.text$mn:00008B4A                 mov     ecx, [ebp+arg_0]
.text$mn:00008B4D                 call    ??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@1@@Z ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>(std::_List_node<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,void *> *,std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>> const *)
.text$mn:00008B52                 mov     [ebp+var_4], 0
.text$mn:00008B59                 mov     eax, [ebp+var_14]
.text$mn:00008B5C                 or      eax, 1
.text$mn:00008B5F                 mov     [ebp+var_14], eax
.text$mn:00008B62                 mov     eax, [ebp+arg_0]
.text$mn:00008B65                 mov     ecx, [ebp+var_C]
.text$mn:00008B68                 mov     large fs:0, ecx
.text$mn:00008B6F                 pop     ecx
.text$mn:00008B70                 mov     esp, ebp
.text$mn:00008B72                 pop     ebp
.text$mn:00008B73                 retn    4
.text$mn:00008B73 ?end@?$list@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@XZ endp
.text$mn:00008B73
.text$mn:00008B73 ; ---------------------------------------------------------------------------
.text$mn:00008B76                 align 4
.text$mn:00008B76 _text$mn        ends
.text$mn:00008B76
.text$x:00008B78 ; ===========================================================================
.text$x:00008B78
.text$x:00008B78 ; Segment type: Pure code
.text$x:00008B78 ; Segment permissions: Read/Execute
.text$x:00008B78 _text$x         segment para public 'CODE' use32
.text$x:00008B78                 assume cs:_text$x
.text$x:00008B78                 ;org 8B78h
.text$x:00008B78 ; COMDAT (pick associative to section at 8B10)
.text$x:00008B78                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00008B78
.text$x:00008B78 ; =============== S U B R O U T I N E =======================================
.text$x:00008B78
.text$x:00008B78
.text$x:00008B78 __unwindfunclet$?end@?$list@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@XZ$0 proc near
.text$x:00008B78                                         ; DATA XREF: .xdata$x:00009FB0o
.text$x:00008B78                 mov     eax, [ebp-14h]
.text$x:00008B7B                 and     eax, 1
.text$x:00008B7E                 jz      $LN4_1
.text$x:00008B84                 and     dword ptr [ebp-14h], 0FFFFFFFEh
.text$x:00008B88                 mov     ecx, [ebp+8]
.text$x:00008B8B                 jmp     ??1?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::~_List_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>(void)
.text$x:00008B90 ; ---------------------------------------------------------------------------
.text$x:00008B90
.text$x:00008B90 $LN4_1:                                 ; CODE XREF: __unwindfunclet$?end@?$list@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@XZ$0+6j
.text$x:00008B90                 retn
.text$x:00008B90 __unwindfunclet$?end@?$list@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@XZ$0 endp
.text$x:00008B90
.text$x:00008B91
.text$x:00008B91 ; =============== S U B R O U T I N E =======================================
.text$x:00008B91
.text$x:00008B91
.text$x:00008B91 __ehhandler$?end@?$list@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@XZ proc near
.text$x:00008B91                                         ; DATA XREF: std::list<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>::end(void)+5o
.text$x:00008B91
.text$x:00008B91 arg_4           = dword ptr  8
.text$x:00008B91
.text$x:00008B91                 mov     edx, [esp+arg_4]
.text$x:00008B95                 lea     eax, [edx+0Ch]
.text$x:00008B98                 mov     ecx, [edx-0Ch]
.text$x:00008B9B                 xor     ecx, eax
.text$x:00008B9D                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00008BA2                 mov     eax, offset __ehfuncinfo$?end@?$list@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@XZ
.text$x:00008BA7                 jmp     ___CxxFrameHandler3
.text$x:00008BA7 __ehhandler$?end@?$list@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@XZ endp
.text$x:00008BA7
.text$x:00008BA7 _text$x         ends
.text$x:00008BA7
.text$mn:00008BAC ; ===========================================================================
.text$mn:00008BAC
.text$mn:00008BAC ; Segment type: Pure code
.text$mn:00008BAC ; Segment permissions: Read/Execute
.text$mn:00008BAC _text$mn        segment para public 'CODE' use32
.text$mn:00008BAC                 assume cs:_text$mn
.text$mn:00008BAC                 ;org 8BACh
.text$mn:00008BAC ; COMDAT (pick any)
.text$mn:00008BAC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008BAC
.text$mn:00008BAC ; =============== S U B R O U T I N E =======================================
.text$mn:00008BAC
.text$mn:00008BAC ; Attributes: bp-based frame
.text$mn:00008BAC
.text$mn:00008BAC ; bool __thiscall std::error_category::equivalent(std::error_category *this, const struct std::error_code *, int)
.text$mn:00008BAC                 public ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
.text$mn:00008BAC ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z proc near
.text$mn:00008BAC                                         ; DATA XREF: .rdata:0000AED4o
.text$mn:00008BAC                                         ; .rdata:0000AEF0o ...
.text$mn:00008BAC
.text$mn:00008BAC var_8           = dword ptr -8
.text$mn:00008BAC var_4           = dword ptr -4
.text$mn:00008BAC arg_0           = dword ptr  8
.text$mn:00008BAC arg_4           = dword ptr  0Ch
.text$mn:00008BAC
.text$mn:00008BAC                 push    ebp
.text$mn:00008BAD                 mov     ebp, esp
.text$mn:00008BAF                 sub     esp, 8
.text$mn:00008BB2                 mov     [ebp+var_8], ecx
.text$mn:00008BB5                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00008BB8                 call    ?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category(void)
.text$mn:00008BBD                 push    eax
.text$mn:00008BBE                 mov     ecx, [ebp+var_8]
.text$mn:00008BC1                 call    ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
.text$mn:00008BC6                 movzx   eax, al
.text$mn:00008BC9                 test    eax, eax
.text$mn:00008BCB                 jz      short loc_8BE3
.text$mn:00008BCD                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00008BD0                 call    ?value@error_code@std@@QBEHXZ ; std::error_code::value(void)
.text$mn:00008BD5                 cmp     eax, [ebp+arg_4]
.text$mn:00008BD8                 jnz     short loc_8BE3
.text$mn:00008BDA                 mov     [ebp+var_4], 1
.text$mn:00008BE1                 jmp     short loc_8BEA
.text$mn:00008BE3 ; ---------------------------------------------------------------------------
.text$mn:00008BE3
.text$mn:00008BE3 loc_8BE3:                               ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+1Fj
.text$mn:00008BE3                                         ; std::error_category::equivalent(std::error_code const &,int)+2Cj
.text$mn:00008BE3                 mov     [ebp+var_4], 0
.text$mn:00008BEA
.text$mn:00008BEA loc_8BEA:                               ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+35j
.text$mn:00008BEA                 mov     al, byte ptr [ebp+var_4]
.text$mn:00008BED                 mov     esp, ebp
.text$mn:00008BEF                 pop     ebp
.text$mn:00008BF0                 retn    8
.text$mn:00008BF0 ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z endp
.text$mn:00008BF0
.text$mn:00008BF0 ; ---------------------------------------------------------------------------
.text$mn:00008BF3                 align 4
.text$mn:00008BF3 _text$mn        ends
.text$mn:00008BF3
.text$mn:00008BF4 ; ===========================================================================
.text$mn:00008BF4
.text$mn:00008BF4 ; Segment type: Pure code
.text$mn:00008BF4 ; Segment permissions: Read/Execute
.text$mn:00008BF4 _text$mn        segment para public 'CODE' use32
.text$mn:00008BF4                 assume cs:_text$mn
.text$mn:00008BF4                 ;org 8BF4h
.text$mn:00008BF4 ; COMDAT (pick any)
.text$mn:00008BF4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008BF4
.text$mn:00008BF4 ; =============== S U B R O U T I N E =======================================
.text$mn:00008BF4
.text$mn:00008BF4 ; Attributes: bp-based frame
.text$mn:00008BF4
.text$mn:00008BF4 ; bool __thiscall std::error_category::equivalent(std::error_category *this, int, const struct std::error_condition *)
.text$mn:00008BF4                 public ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
.text$mn:00008BF4 ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z proc near
.text$mn:00008BF4                                         ; DATA XREF: .rdata:0000AED8o
.text$mn:00008BF4                                         ; .rdata:0000AEF4o ...
.text$mn:00008BF4
.text$mn:00008BF4 var_C           = byte ptr -0Ch
.text$mn:00008BF4 var_4           = dword ptr -4
.text$mn:00008BF4 arg_0           = dword ptr  8
.text$mn:00008BF4 arg_4           = dword ptr  0Ch
.text$mn:00008BF4
.text$mn:00008BF4                 push    ebp
.text$mn:00008BF5                 mov     ebp, esp
.text$mn:00008BF7                 sub     esp, 0Ch
.text$mn:00008BFA                 mov     [ebp+var_4], ecx
.text$mn:00008BFD                 mov     eax, [ebp+arg_4]
.text$mn:00008C00                 push    eax             ; std::error_condition *
.text$mn:00008C01                 mov     ecx, [ebp+arg_0]
.text$mn:00008C04                 push    ecx
.text$mn:00008C05                 lea     edx, [ebp+var_C]
.text$mn:00008C08                 push    edx
.text$mn:00008C09                 mov     eax, [ebp+var_4]
.text$mn:00008C0C                 mov     edx, [eax]
.text$mn:00008C0E                 mov     ecx, [ebp+var_4]
.text$mn:00008C11                 mov     eax, [edx+0Ch]
.text$mn:00008C14                 call    eax
.text$mn:00008C16                 mov     ecx, eax
.text$mn:00008C18                 call    ??8error_condition@std@@QBE_NABV01@@Z ; std::error_condition::operator==(std::error_condition const &)
.text$mn:00008C1D                 mov     esp, ebp
.text$mn:00008C1F                 pop     ebp
.text$mn:00008C20                 retn    8
.text$mn:00008C20 ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z endp
.text$mn:00008C20
.text$mn:00008C20 ; ---------------------------------------------------------------------------
.text$mn:00008C23                 align 4
.text$mn:00008C23 _text$mn        ends
.text$mn:00008C23
.text$mn:00008C24 ; ===========================================================================
.text$mn:00008C24
.text$mn:00008C24 ; Segment type: Pure code
.text$mn:00008C24 ; Segment permissions: Read/Execute
.text$mn:00008C24 _text$mn        segment para public 'CODE' use32
.text$mn:00008C24                 assume cs:_text$mn
.text$mn:00008C24                 ;org 8C24h
.text$mn:00008C24 ; COMDAT (pick any)
.text$mn:00008C24                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008C24
.text$mn:00008C24 ; =============== S U B R O U T I N E =======================================
.text$mn:00008C24
.text$mn:00008C24 ; Attributes: bp-based frame
.text$mn:00008C24
.text$mn:00008C24 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int)
.text$mn:00008C24                 public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
.text$mn:00008C24 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z proc near
.text$mn:00008C24                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+4Cp
.text$mn:00008C24
.text$mn:00008C24 var_4           = dword ptr -4
.text$mn:00008C24 arg_0           = dword ptr  8
.text$mn:00008C24
.text$mn:00008C24                 push    ebp
.text$mn:00008C25                 mov     ebp, esp
.text$mn:00008C27                 push    ecx
.text$mn:00008C28                 mov     [ebp+var_4], ecx
.text$mn:00008C2B                 mov     eax, [ebp+var_4]
.text$mn:00008C2E                 mov     ecx, [eax+14h]
.text$mn:00008C31                 cmp     ecx, [ebp+arg_0]
.text$mn:00008C34                 jnb     short loc_8C3E
.text$mn:00008C36                 mov     ecx, [ebp+var_4]
.text$mn:00008C39                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:00008C3E
.text$mn:00008C3E loc_8C3E:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)+10j
.text$mn:00008C3E                 mov     edx, [ebp+arg_0]
.text$mn:00008C41                 push    edx
.text$mn:00008C42                 mov     ecx, [ebp+var_4]
.text$mn:00008C45                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00008C4A                 mov     eax, [ebp+var_4]
.text$mn:00008C4D                 mov     esp, ebp
.text$mn:00008C4F                 pop     ebp
.text$mn:00008C50                 retn    4
.text$mn:00008C50 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z endp
.text$mn:00008C50
.text$mn:00008C50 ; ---------------------------------------------------------------------------
.text$mn:00008C53                 align 4
.text$mn:00008C53 _text$mn        ends
.text$mn:00008C53
.text$mn:00008C54 ; ===========================================================================
.text$mn:00008C54
.text$mn:00008C54 ; Segment type: Pure code
.text$mn:00008C54 ; Segment permissions: Read/Execute
.text$mn:00008C54 _text$mn        segment para public 'CODE' use32
.text$mn:00008C54                 assume cs:_text$mn
.text$mn:00008C54                 ;org 8C54h
.text$mn:00008C54 ; COMDAT (pick any)
.text$mn:00008C54                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008C54
.text$mn:00008C54 ; =============== S U B R O U T I N E =======================================
.text$mn:00008C54
.text$mn:00008C54 ; Attributes: bp-based frame
.text$mn:00008C54
.text$mn:00008C54 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int, unsigned int)
.text$mn:00008C54                 public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
.text$mn:00008C54 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z proc near
.text$mn:00008C54                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+5Ap
.text$mn:00008C54
.text$mn:00008C54 var_C           = dword ptr -0Ch
.text$mn:00008C54 Dst             = dword ptr -8
.text$mn:00008C54 var_4           = dword ptr -4
.text$mn:00008C54 arg_0           = dword ptr  8
.text$mn:00008C54 arg_4           = dword ptr  0Ch
.text$mn:00008C54
.text$mn:00008C54                 push    ebp
.text$mn:00008C55                 mov     ebp, esp
.text$mn:00008C57                 sub     esp, 0Ch
.text$mn:00008C5A                 mov     [ebp+var_4], ecx
.text$mn:00008C5D                 mov     eax, [ebp+var_4]
.text$mn:00008C60                 mov     ecx, [eax+14h]
.text$mn:00008C63                 cmp     ecx, [ebp+arg_0]
.text$mn:00008C66                 jnb     short loc_8C70
.text$mn:00008C68                 mov     ecx, [ebp+var_4]
.text$mn:00008C6B                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:00008C70
.text$mn:00008C70 loc_8C70:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+12j
.text$mn:00008C70                 mov     edx, [ebp+var_4]
.text$mn:00008C73                 mov     eax, [edx+14h]
.text$mn:00008C76                 sub     eax, [ebp+arg_0]
.text$mn:00008C79                 cmp     eax, [ebp+arg_4]
.text$mn:00008C7C                 ja      short loc_8C8C
.text$mn:00008C7E                 mov     ecx, [ebp+arg_0]
.text$mn:00008C81                 push    ecx
.text$mn:00008C82                 mov     ecx, [ebp+var_4]
.text$mn:00008C85                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00008C8A                 jmp     short loc_8CD2
.text$mn:00008C8C ; ---------------------------------------------------------------------------
.text$mn:00008C8C
.text$mn:00008C8C loc_8C8C:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+28j
.text$mn:00008C8C                 cmp     [ebp+arg_4], 0
.text$mn:00008C90                 jbe     short loc_8CD2
.text$mn:00008C92                 mov     ecx, [ebp+var_4]
.text$mn:00008C95                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00008C9A                 add     eax, [ebp+arg_0]
.text$mn:00008C9D                 mov     [ebp+Dst], eax
.text$mn:00008CA0                 mov     edx, [ebp+var_4]
.text$mn:00008CA3                 mov     eax, [edx+14h]
.text$mn:00008CA6                 sub     eax, [ebp+arg_4]
.text$mn:00008CA9                 mov     [ebp+var_C], eax
.text$mn:00008CAC                 mov     ecx, [ebp+var_C]
.text$mn:00008CAF                 sub     ecx, [ebp+arg_0]
.text$mn:00008CB2                 push    ecx             ; Size
.text$mn:00008CB3                 mov     edx, [ebp+Dst]
.text$mn:00008CB6                 add     edx, [ebp+arg_4]
.text$mn:00008CB9                 push    edx             ; Src
.text$mn:00008CBA                 mov     eax, [ebp+Dst]
.text$mn:00008CBD                 push    eax             ; Dst
.text$mn:00008CBE                 call    ?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move(char *,char const *,uint)
.text$mn:00008CC3                 add     esp, 0Ch
.text$mn:00008CC6                 mov     ecx, [ebp+var_C]
.text$mn:00008CC9                 push    ecx
.text$mn:00008CCA                 mov     ecx, [ebp+var_4]
.text$mn:00008CCD                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00008CD2
.text$mn:00008CD2 loc_8CD2:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+36j
.text$mn:00008CD2                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+3Cj
.text$mn:00008CD2                 mov     eax, [ebp+var_4]
.text$mn:00008CD5                 mov     esp, ebp
.text$mn:00008CD7                 pop     ebp
.text$mn:00008CD8                 retn    8
.text$mn:00008CD8 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z endp
.text$mn:00008CD8
.text$mn:00008CD8 ; ---------------------------------------------------------------------------
.text$mn:00008CDB                 align 4
.text$mn:00008CDB _text$mn        ends
.text$mn:00008CDB
.text$mn:00008CDC ; ===========================================================================
.text$mn:00008CDC
.text$mn:00008CDC ; Segment type: Pure code
.text$mn:00008CDC ; Segment permissions: Read/Execute
.text$mn:00008CDC _text$mn        segment para public 'CODE' use32
.text$mn:00008CDC                 assume cs:_text$mn
.text$mn:00008CDC                 ;org 8CDCh
.text$mn:00008CDC ; COMDAT (pick any)
.text$mn:00008CDC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008CDC
.text$mn:00008CDC ; =============== S U B R O U T I N E =======================================
.text$mn:00008CDC
.text$mn:00008CDC ; Attributes: bp-based frame
.text$mn:00008CDC
.text$mn:00008CDC ; int __stdcall std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::erase(int, char, int, void *Dst)
.text$mn:00008CDC                 public ?erase@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@2@@Z
.text$mn:00008CDC ?erase@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@2@@Z proc near
.text$mn:00008CDC                                         ; CODE XREF: ScintillaCtrls::destroyScintilla(HWND__ *)+FAp
.text$mn:00008CDC
.text$mn:00008CDC var_24          = dword ptr -24h
.text$mn:00008CDC var_20          = dword ptr -20h
.text$mn:00008CDC var_1C          = dword ptr -1Ch
.text$mn:00008CDC var_18          = dword ptr -18h
.text$mn:00008CDC var_14          = dword ptr -14h
.text$mn:00008CDC var_10          = dword ptr -10h
.text$mn:00008CDC var_C           = dword ptr -0Ch
.text$mn:00008CDC var_4           = dword ptr -4
.text$mn:00008CDC arg_0           = dword ptr  8
.text$mn:00008CDC arg_4           = byte ptr  0Ch
.text$mn:00008CDC Dst             = dword ptr  14h
.text$mn:00008CDC
.text$mn:00008CDC                 push    ebp
.text$mn:00008CDD                 mov     ebp, esp
.text$mn:00008CDF                 push    0FFFFFFFFh
.text$mn:00008CE1                 push    offset __ehhandler$?erase@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@2@@Z
.text$mn:00008CE6                 mov     eax, large fs:0
.text$mn:00008CEC                 push    eax
.text$mn:00008CED                 sub     esp, 18h
.text$mn:00008CF0                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00008CF5                 xor     eax, ebp
.text$mn:00008CF7                 push    eax
.text$mn:00008CF8                 lea     eax, [ebp+var_C]
.text$mn:00008CFB                 mov     large fs:0, eax
.text$mn:00008D01                 mov     [ebp+var_10], ecx
.text$mn:00008D04                 mov     [ebp+var_14], 0
.text$mn:00008D0B                 mov     [ebp+var_4], 1
.text$mn:00008D12                 lea     ecx, [ebp+arg_4] ; this
.text$mn:00008D15                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:00008D1A                 cmp     eax, [ebp+var_10]
.text$mn:00008D1D                 jnz     short loc_8D35
.text$mn:00008D1F                 mov     eax, [ebp+var_10]
.text$mn:00008D22                 mov     ecx, [ebp+Dst]
.text$mn:00008D25                 cmp     ecx, [eax+4]
.text$mn:00008D28                 jb      short loc_8D35
.text$mn:00008D2A                 mov     edx, [ebp+var_10]
.text$mn:00008D2D                 mov     eax, [edx+8]
.text$mn:00008D30                 cmp     eax, [ebp+Dst]
.text$mn:00008D33                 ja      short loc_8D4C
.text$mn:00008D35
.text$mn:00008D35 loc_8D35:                               ; CODE XREF: std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::erase(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>)+41j
.text$mn:00008D35                                         ; std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::erase(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>)+4Cj
.text$mn:00008D35                 push    5A2h            ; unsigned int
.text$mn:00008D3A                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00008D3F                 push    offset ??_C@_1EI@HGIDLLCM@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAe?$AAr?$AAa?$AAs?$AAe?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAo?$AAu?$AAt?$AAs?$AAi?$AAd?$AAe?$AA?5?$AAr?$AAa@ ; "vector erase iterator outside range"
.text$mn:00008D44                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00008D49                 add     esp, 0Ch
.text$mn:00008D4C
.text$mn:00008D4C loc_8D4C:                               ; CODE XREF: std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::erase(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>)+57j
.text$mn:00008D4C                 mov     ecx, [ebp+Dst]
.text$mn:00008D4F                 push    ecx             ; Dst
.text$mn:00008D50                 mov     edx, [ebp+var_10]
.text$mn:00008D53                 mov     eax, [edx+8]
.text$mn:00008D56                 push    eax             ; int
.text$mn:00008D57                 mov     ecx, [ebp+Dst]
.text$mn:00008D5A                 add     ecx, 4
.text$mn:00008D5D                 push    ecx             ; Src
.text$mn:00008D5E                 call    ??$_Move@PAPAVScintillaEditView@@PAPAV1@@std@@YAPAPAVScintillaEditView@@PAPAV1@00@Z ; std::_Move<ScintillaEditView * *,ScintillaEditView * *>(ScintillaEditView * *,ScintillaEditView * *,ScintillaEditView * *)
.text$mn:00008D63                 add     esp, 0Ch
.text$mn:00008D66                 mov     edx, [ebp+var_10]
.text$mn:00008D69                 mov     eax, [edx+8]
.text$mn:00008D6C                 push    eax
.text$mn:00008D6D                 mov     ecx, [ebp+var_10]
.text$mn:00008D70                 mov     edx, [ecx+8]
.text$mn:00008D73                 sub     edx, 4
.text$mn:00008D76                 push    edx
.text$mn:00008D77                 mov     ecx, [ebp+var_10]
.text$mn:00008D7A                 call    ?_Destroy@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@IAEXPAPAVScintillaEditView@@0@Z ; std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::_Destroy(ScintillaEditView * *,ScintillaEditView * *)
.text$mn:00008D7F                 mov     eax, [ebp+var_10]
.text$mn:00008D82                 mov     ecx, [eax+8]
.text$mn:00008D85                 push    ecx
.text$mn:00008D86                 mov     edx, [ebp+Dst]
.text$mn:00008D89                 push    edx
.text$mn:00008D8A                 mov     ecx, [ebp+var_10]
.text$mn:00008D8D                 call    ?_Orphan_range@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@IBEXPAPAVScintillaEditView@@0@Z ; std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::_Orphan_range(ScintillaEditView * *,ScintillaEditView * *)
.text$mn:00008D92                 mov     eax, [ebp+var_10]
.text$mn:00008D95                 mov     ecx, [eax+8]
.text$mn:00008D98                 sub     ecx, 4
.text$mn:00008D9B                 mov     edx, [ebp+var_10]
.text$mn:00008D9E                 mov     [edx+8], ecx
.text$mn:00008DA1                 sub     esp, 0Ch
.text$mn:00008DA4                 mov     ecx, esp
.text$mn:00008DA6                 mov     [ebp+var_1C], esp
.text$mn:00008DA9                 lea     eax, [ebp+arg_4]
.text$mn:00008DAC                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00008DAD                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>> const &)
.text$mn:00008DB2                 mov     [ebp+var_18], eax
.text$mn:00008DB5                 mov     ecx, [ebp+var_18]
.text$mn:00008DB8                 mov     [ebp+var_20], ecx
.text$mn:00008DBB                 mov     byte ptr [ebp+var_4], 2
.text$mn:00008DBF                 mov     edx, [ebp+arg_0]
.text$mn:00008DC2                 push    edx
.text$mn:00008DC3                 mov     byte ptr [ebp+var_4], 1
.text$mn:00008DC7                 mov     ecx, [ebp+var_10]
.text$mn:00008DCA                 call    ?_Make_iter@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@2@@Z ; std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::_Make_iter(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>)
.text$mn:00008DCF                 mov     [ebp+var_24], eax
.text$mn:00008DD2                 mov     eax, [ebp+var_14]
.text$mn:00008DD5                 or      eax, 1
.text$mn:00008DD8                 mov     [ebp+var_14], eax
.text$mn:00008DDB                 mov     byte ptr [ebp+var_4], 0
.text$mn:00008DDF                 lea     ecx, [ebp+arg_4]
.text$mn:00008DE2                 call    ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>(void)
.text$mn:00008DE7                 mov     eax, [ebp+arg_0]
.text$mn:00008DEA                 mov     ecx, [ebp+var_C]
.text$mn:00008DED                 mov     large fs:0, ecx
.text$mn:00008DF4                 pop     ecx
.text$mn:00008DF5                 mov     esp, ebp
.text$mn:00008DF7                 pop     ebp
.text$mn:00008DF8                 retn    10h
.text$mn:00008DF8 ?erase@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@2@@Z endp
.text$mn:00008DF8
.text$mn:00008DF8 ; ---------------------------------------------------------------------------
.text$mn:00008DFB                 align 4
.text$mn:00008DFB _text$mn        ends
.text$mn:00008DFB
.text$x:00008DFC ; ===========================================================================
.text$x:00008DFC
.text$x:00008DFC ; Segment type: Pure code
.text$x:00008DFC ; Segment permissions: Read/Execute
.text$x:00008DFC _text$x         segment para public 'CODE' use32
.text$x:00008DFC                 assume cs:_text$x
.text$x:00008DFC                 ;org 8DFCh
.text$x:00008DFC ; COMDAT (pick associative to section at 8CDC)
.text$x:00008DFC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00008DFC
.text$x:00008DFC ; =============== S U B R O U T I N E =======================================
.text$x:00008DFC
.text$x:00008DFC
.text$x:00008DFC __unwindfunclet$?erase@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@2@@Z$0 proc near
.text$x:00008DFC                                         ; DATA XREF: .xdata$x:00009A48o
.text$x:00008DFC                 lea     ecx, [ebp+0Ch]
.text$x:00008DFF                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>(void)
.text$x:00008DFF __unwindfunclet$?erase@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@2@@Z$0 endp
.text$x:00008DFF
.text$x:00008E04
.text$x:00008E04 ; =============== S U B R O U T I N E =======================================
.text$x:00008E04
.text$x:00008E04
.text$x:00008E04 __unwindfunclet$?erase@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@2@@Z$1 proc near
.text$x:00008E04                                         ; DATA XREF: .xdata$x:00009A50o
.text$x:00008E04                 mov     ecx, [ebp-1Ch]
.text$x:00008E07                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>(void)
.text$x:00008E07 __unwindfunclet$?erase@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@2@@Z$1 endp
.text$x:00008E07
.text$x:00008E0C
.text$x:00008E0C ; =============== S U B R O U T I N E =======================================
.text$x:00008E0C
.text$x:00008E0C
.text$x:00008E0C __unwindfunclet$?erase@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@2@@Z$2 proc near
.text$x:00008E0C                                         ; DATA XREF: .xdata$x:00009A40o
.text$x:00008E0C                 mov     eax, [ebp-14h]
.text$x:00008E0F                 and     eax, 1
.text$x:00008E12                 jz      $LN8
.text$x:00008E18                 and     dword ptr [ebp-14h], 0FFFFFFFEh
.text$x:00008E1C                 mov     ecx, [ebp+8]
.text$x:00008E1F                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>(void)
.text$x:00008E24 ; ---------------------------------------------------------------------------
.text$x:00008E24
.text$x:00008E24 $LN8:                                   ; CODE XREF: __unwindfunclet$?erase@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@2@@Z$2+6j
.text$x:00008E24                 retn
.text$x:00008E24 __unwindfunclet$?erase@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@2@@Z$2 endp
.text$x:00008E24
.text$x:00008E25
.text$x:00008E25 ; =============== S U B R O U T I N E =======================================
.text$x:00008E25
.text$x:00008E25
.text$x:00008E25 __ehhandler$?erase@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@2@@Z proc near
.text$x:00008E25                                         ; DATA XREF: std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::erase(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>)+5o
.text$x:00008E25
.text$x:00008E25 arg_4           = dword ptr  8
.text$x:00008E25
.text$x:00008E25                 mov     edx, [esp+arg_4]
.text$x:00008E29                 lea     eax, [edx+0Ch]
.text$x:00008E2C                 mov     ecx, [edx-1Ch]
.text$x:00008E2F                 xor     ecx, eax
.text$x:00008E31                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00008E36                 mov     eax, offset __ehfuncinfo$?erase@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@2@@Z
.text$x:00008E3B                 jmp     ___CxxFrameHandler3
.text$x:00008E3B __ehhandler$?erase@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@2@@Z endp
.text$x:00008E3B
.text$x:00008E3B _text$x         ends
.text$x:00008E3B
.text$mn:00008E40 ; ===========================================================================
.text$mn:00008E40
.text$mn:00008E40 ; Segment type: Pure code
.text$mn:00008E40 ; Segment permissions: Read/Execute
.text$mn:00008E40 _text$mn        segment para public 'CODE' use32
.text$mn:00008E40                 assume cs:_text$mn
.text$mn:00008E40                 ;org 8E40h
.text$mn:00008E40 ; COMDAT (pick any)
.text$mn:00008E40                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008E40
.text$mn:00008E40 ; =============== S U B R O U T I N E =======================================
.text$mn:00008E40
.text$mn:00008E40 ; Attributes: bp-based frame
.text$mn:00008E40
.text$mn:00008E40 ; const struct std::error_category *__cdecl std::generic_category()
.text$mn:00008E40                 public ?generic_category@std@@YAABVerror_category@1@XZ
.text$mn:00008E40 ?generic_category@std@@YAABVerror_category@1@XZ proc near
.text$mn:00008E40                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+17p
.text$mn:00008E40                 push    ebp
.text$mn:00008E41                 mov     ebp, esp
.text$mn:00008E43                 mov     eax, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
.text$mn:00008E48                 pop     ebp
.text$mn:00008E49                 retn
.text$mn:00008E49 ?generic_category@std@@YAABVerror_category@1@XZ endp
.text$mn:00008E49
.text$mn:00008E49 ; ---------------------------------------------------------------------------
.text$mn:00008E4A                 align 4
.text$mn:00008E4A _text$mn        ends
.text$mn:00008E4A
.text$mn:00008E4C ; ===========================================================================
.text$mn:00008E4C
.text$mn:00008E4C ; Segment type: Pure code
.text$mn:00008E4C ; Segment permissions: Read/Execute
.text$mn:00008E4C _text$mn        segment para public 'CODE' use32
.text$mn:00008E4C                 assume cs:_text$mn
.text$mn:00008E4C                 ;org 8E4Ch
.text$mn:00008E4C ; COMDAT (pick any)
.text$mn:00008E4C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008E4C
.text$mn:00008E4C ; =============== S U B R O U T I N E =======================================
.text$mn:00008E4C
.text$mn:00008E4C ; Attributes: bp-based frame
.text$mn:00008E4C
.text$mn:00008E4C ; void __thiscall Window::getClientRect(Window *this, struct tagRECT *)
.text$mn:00008E4C                 public ?getClientRect@Window@@UBEXAAUtagRECT@@@Z
.text$mn:00008E4C ?getClientRect@Window@@UBEXAAUtagRECT@@@Z proc near
.text$mn:00008E4C                                         ; DATA XREF: .rdata:0000AFA8o
.text$mn:00008E4C                                         ; .rdata:0000AFDCo
.text$mn:00008E4C
.text$mn:00008E4C var_4           = dword ptr -4
.text$mn:00008E4C lpRect          = dword ptr  8
.text$mn:00008E4C
.text$mn:00008E4C                 push    ebp
.text$mn:00008E4D                 mov     ebp, esp
.text$mn:00008E4F                 push    ecx
.text$mn:00008E50                 mov     [ebp+var_4], ecx
.text$mn:00008E53                 mov     eax, [ebp+lpRect]
.text$mn:00008E56                 push    eax             ; lpRect
.text$mn:00008E57                 mov     ecx, [ebp+var_4]
.text$mn:00008E5A                 mov     edx, [ecx+0Ch]
.text$mn:00008E5D                 push    edx             ; hWnd
.text$mn:00008E5E                 call    dword ptr ds:__imp__GetClientRect@8 ; GetClientRect(x,x)
.text$mn:00008E64                 mov     esp, ebp
.text$mn:00008E66                 pop     ebp
.text$mn:00008E67                 retn    4
.text$mn:00008E67 ?getClientRect@Window@@UBEXAAUtagRECT@@@Z endp
.text$mn:00008E67
.text$mn:00008E67 ; ---------------------------------------------------------------------------
.text$mn:00008E6A                 align 4
.text$mn:00008E6A _text$mn        ends
.text$mn:00008E6A
.text$mn:00008E6C ; ===========================================================================
.text$mn:00008E6C
.text$mn:00008E6C ; Segment type: Pure code
.text$mn:00008E6C ; Segment permissions: Read/Execute
.text$mn:00008E6C _text$mn        segment para public 'CODE' use32
.text$mn:00008E6C                 assume cs:_text$mn
.text$mn:00008E6C                 ;org 8E6Ch
.text$mn:00008E6C ; COMDAT (pick any)
.text$mn:00008E6C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008E6C
.text$mn:00008E6C ; =============== S U B R O U T I N E =======================================
.text$mn:00008E6C
.text$mn:00008E6C ; Attributes: bp-based frame
.text$mn:00008E6C
.text$mn:00008E6C ; HWND __thiscall Window::getHSelf(Window *__hidden this)
.text$mn:00008E6C                 public ?getHSelf@Window@@QBEPAUHWND__@@XZ
.text$mn:00008E6C ?getHSelf@Window@@QBEPAUHWND__@@XZ proc near
.text$mn:00008E6C                                         ; CODE XREF: ScintillaCtrls::createSintilla(HWND__ *)+9Cp
.text$mn:00008E6C                                         ; ScintillaCtrls::getIndexFrom(HWND__ *)+3Cp
.text$mn:00008E6C
.text$mn:00008E6C var_4           = dword ptr -4
.text$mn:00008E6C
.text$mn:00008E6C                 push    ebp
.text$mn:00008E6D                 mov     ebp, esp
.text$mn:00008E6F                 push    ecx
.text$mn:00008E70                 mov     [ebp+var_4], ecx
.text$mn:00008E73                 mov     eax, [ebp+var_4]
.text$mn:00008E76                 mov     eax, [eax+0Ch]
.text$mn:00008E79                 mov     esp, ebp
.text$mn:00008E7B                 pop     ebp
.text$mn:00008E7C                 retn
.text$mn:00008E7C ?getHSelf@Window@@QBEPAUHWND__@@XZ endp
.text$mn:00008E7C
.text$mn:00008E7C ; ---------------------------------------------------------------------------
.text$mn:00008E7D                 align 10h
.text$mn:00008E7D _text$mn        ends
.text$mn:00008E7D
.text$mn:00008E80 ; ===========================================================================
.text$mn:00008E80
.text$mn:00008E80 ; Segment type: Pure code
.text$mn:00008E80 ; Segment permissions: Read/Execute
.text$mn:00008E80 _text$mn        segment para public 'CODE' use32
.text$mn:00008E80                 assume cs:_text$mn
.text$mn:00008E80                 ;org 8E80h
.text$mn:00008E80 ; COMDAT (pick any)
.text$mn:00008E80                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008E80
.text$mn:00008E80 ; =============== S U B R O U T I N E =======================================
.text$mn:00008E80
.text$mn:00008E80 ; Attributes: bp-based frame
.text$mn:00008E80
.text$mn:00008E80 ; int __thiscall Window::getHeight(Window *__hidden this)
.text$mn:00008E80                 public ?getHeight@Window@@UBEHXZ
.text$mn:00008E80 ?getHeight@Window@@UBEHXZ proc near     ; DATA XREF: .rdata:0000AFB4o
.text$mn:00008E80                                         ; .rdata:0000AFE8o
.text$mn:00008E80
.text$mn:00008E80 var_18          = dword ptr -18h
.text$mn:00008E80 Rect            = tagRECT ptr -14h
.text$mn:00008E80 var_4           = dword ptr -4
.text$mn:00008E80
.text$mn:00008E80                 push    ebp
.text$mn:00008E81                 mov     ebp, esp
.text$mn:00008E83                 sub     esp, 18h
.text$mn:00008E86                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00008E8B                 xor     eax, ebp
.text$mn:00008E8D                 mov     [ebp+var_4], eax
.text$mn:00008E90                 mov     [ebp+var_18], ecx
.text$mn:00008E93                 lea     eax, [ebp+Rect]
.text$mn:00008E96                 push    eax             ; lpRect
.text$mn:00008E97                 mov     ecx, [ebp+var_18]
.text$mn:00008E9A                 mov     edx, [ecx+0Ch]
.text$mn:00008E9D                 push    edx             ; hWnd
.text$mn:00008E9E                 call    dword ptr ds:__imp__GetClientRect@8 ; GetClientRect(x,x)
.text$mn:00008EA4                 mov     eax, [ebp+var_18]
.text$mn:00008EA7                 mov     ecx, [eax+0Ch]
.text$mn:00008EAA                 push    ecx             ; hWnd
.text$mn:00008EAB                 call    dword ptr ds:__imp__IsWindowVisible@4 ; IsWindowVisible(x)
.text$mn:00008EB1                 cmp     eax, 1
.text$mn:00008EB4                 jnz     short loc_8EBE
.text$mn:00008EB6                 mov     eax, [ebp+Rect.bottom]
.text$mn:00008EB9                 sub     eax, [ebp+Rect.top]
.text$mn:00008EBC                 jmp     short loc_8EC0
.text$mn:00008EBE ; ---------------------------------------------------------------------------
.text$mn:00008EBE
.text$mn:00008EBE loc_8EBE:                               ; CODE XREF: Window::getHeight(void)+34j
.text$mn:00008EBE                 xor     eax, eax
.text$mn:00008EC0
.text$mn:00008EC0 loc_8EC0:                               ; CODE XREF: Window::getHeight(void)+3Cj
.text$mn:00008EC0                 mov     ecx, [ebp+var_4]
.text$mn:00008EC3                 xor     ecx, ebp
.text$mn:00008EC5                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00008ECA                 mov     esp, ebp
.text$mn:00008ECC                 pop     ebp
.text$mn:00008ECD                 retn
.text$mn:00008ECD ?getHeight@Window@@UBEHXZ endp
.text$mn:00008ECD
.text$mn:00008ECD ; ---------------------------------------------------------------------------
.text$mn:00008ECE                 align 10h
.text$mn:00008ECE _text$mn        ends
.text$mn:00008ECE
.text$mn:00008ED0 ; ===========================================================================
.text$mn:00008ED0
.text$mn:00008ED0 ; Segment type: Pure code
.text$mn:00008ED0 ; Segment permissions: Read/Execute
.text$mn:00008ED0 _text$mn        segment para public 'CODE' use32
.text$mn:00008ED0                 assume cs:_text$mn
.text$mn:00008ED0                 ;org 8ED0h
.text$mn:00008ED0 ; COMDAT (pick any)
.text$mn:00008ED0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008ED0
.text$mn:00008ED0 ; =============== S U B R O U T I N E =======================================
.text$mn:00008ED0
.text$mn:00008ED0 ; Attributes: bp-based frame
.text$mn:00008ED0
.text$mn:00008ED0 ; int __thiscall Window::getWidth(Window *__hidden this)
.text$mn:00008ED0                 public ?getWidth@Window@@UBEHXZ
.text$mn:00008ED0 ?getWidth@Window@@UBEHXZ proc near      ; DATA XREF: .rdata:0000AFB0o
.text$mn:00008ED0                                         ; .rdata:0000AFE4o
.text$mn:00008ED0
.text$mn:00008ED0 var_18          = dword ptr -18h
.text$mn:00008ED0 Rect            = tagRECT ptr -14h
.text$mn:00008ED0 var_4           = dword ptr -4
.text$mn:00008ED0
.text$mn:00008ED0                 push    ebp
.text$mn:00008ED1                 mov     ebp, esp
.text$mn:00008ED3                 sub     esp, 18h
.text$mn:00008ED6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00008EDB                 xor     eax, ebp
.text$mn:00008EDD                 mov     [ebp+var_4], eax
.text$mn:00008EE0                 mov     [ebp+var_18], ecx
.text$mn:00008EE3                 lea     eax, [ebp+Rect]
.text$mn:00008EE6                 push    eax             ; lpRect
.text$mn:00008EE7                 mov     ecx, [ebp+var_18]
.text$mn:00008EEA                 mov     edx, [ecx+0Ch]
.text$mn:00008EED                 push    edx             ; hWnd
.text$mn:00008EEE                 call    dword ptr ds:__imp__GetClientRect@8 ; GetClientRect(x,x)
.text$mn:00008EF4                 mov     eax, [ebp+Rect.right]
.text$mn:00008EF7                 sub     eax, [ebp+Rect.left]
.text$mn:00008EFA                 mov     ecx, [ebp+var_4]
.text$mn:00008EFD                 xor     ecx, ebp
.text$mn:00008EFF                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00008F04                 mov     esp, ebp
.text$mn:00008F06                 pop     ebp
.text$mn:00008F07                 retn
.text$mn:00008F07 ?getWidth@Window@@UBEHXZ endp
.text$mn:00008F07
.text$mn:00008F07 _text$mn        ends
.text$mn:00008F07
.text$mn:00008F08 ; ===========================================================================
.text$mn:00008F08
.text$mn:00008F08 ; Segment type: Pure code
.text$mn:00008F08 ; Segment permissions: Read/Execute
.text$mn:00008F08 _text$mn        segment para public 'CODE' use32
.text$mn:00008F08                 assume cs:_text$mn
.text$mn:00008F08                 ;org 8F08h
.text$mn:00008F08 ; COMDAT (pick any)
.text$mn:00008F08                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008F08
.text$mn:00008F08 ; =============== S U B R O U T I N E =======================================
.text$mn:00008F08
.text$mn:00008F08 ; Attributes: bp-based frame
.text$mn:00008F08
.text$mn:00008F08 ; void __thiscall Window::getWindowRect(Window *this, struct tagRECT *)
.text$mn:00008F08                 public ?getWindowRect@Window@@UBEXAAUtagRECT@@@Z
.text$mn:00008F08 ?getWindowRect@Window@@UBEXAAUtagRECT@@@Z proc near
.text$mn:00008F08                                         ; DATA XREF: .rdata:0000AFACo
.text$mn:00008F08                                         ; .rdata:0000AFE0o
.text$mn:00008F08
.text$mn:00008F08 var_4           = dword ptr -4
.text$mn:00008F08 lpRect          = dword ptr  8
.text$mn:00008F08
.text$mn:00008F08                 push    ebp
.text$mn:00008F09                 mov     ebp, esp
.text$mn:00008F0B                 push    ecx
.text$mn:00008F0C                 mov     [ebp+var_4], ecx
.text$mn:00008F0F                 mov     eax, [ebp+lpRect]
.text$mn:00008F12                 push    eax             ; lpRect
.text$mn:00008F13                 mov     ecx, [ebp+var_4]
.text$mn:00008F16                 mov     edx, [ecx+0Ch]
.text$mn:00008F19                 push    edx             ; hWnd
.text$mn:00008F1A                 call    dword ptr ds:__imp__GetWindowRect@8 ; GetWindowRect(x,x)
.text$mn:00008F20                 mov     esp, ebp
.text$mn:00008F22                 pop     ebp
.text$mn:00008F23                 retn    4
.text$mn:00008F23 ?getWindowRect@Window@@UBEXAAUtagRECT@@@Z endp
.text$mn:00008F23
.text$mn:00008F23 ; ---------------------------------------------------------------------------
.text$mn:00008F26                 align 4
.text$mn:00008F26 _text$mn        ends
.text$mn:00008F26
.text$mn:00008F28 ; ===========================================================================
.text$mn:00008F28
.text$mn:00008F28 ; Segment type: Pure code
.text$mn:00008F28 ; Segment permissions: Read/Execute
.text$mn:00008F28 _text$mn        segment para public 'CODE' use32
.text$mn:00008F28                 assume cs:_text$mn
.text$mn:00008F28                 ;org 8F28h
.text$mn:00008F28 ; COMDAT (pick any)
.text$mn:00008F28                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008F28
.text$mn:00008F28 ; =============== S U B R O U T I N E =======================================
.text$mn:00008F28
.text$mn:00008F28 ; Attributes: bp-based frame
.text$mn:00008F28
.text$mn:00008F28 ; void __thiscall Window::init(Window *this, HINSTANCE, HWND)
.text$mn:00008F28                 public ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z
.text$mn:00008F28 ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z proc near
.text$mn:00008F28                                         ; DATA XREF: .rdata:0000AF90o
.text$mn:00008F28
.text$mn:00008F28 var_4           = dword ptr -4
.text$mn:00008F28 arg_0           = dword ptr  8
.text$mn:00008F28 arg_4           = dword ptr  0Ch
.text$mn:00008F28
.text$mn:00008F28                 push    ebp
.text$mn:00008F29                 mov     ebp, esp
.text$mn:00008F2B                 push    ecx
.text$mn:00008F2C                 mov     [ebp+var_4], ecx
.text$mn:00008F2F                 mov     eax, [ebp+var_4]
.text$mn:00008F32                 mov     ecx, [ebp+arg_0]
.text$mn:00008F35                 mov     [eax+4], ecx
.text$mn:00008F38                 mov     edx, [ebp+var_4]
.text$mn:00008F3B                 mov     eax, [ebp+arg_4]
.text$mn:00008F3E                 mov     [edx+8], eax
.text$mn:00008F41                 mov     esp, ebp
.text$mn:00008F43                 pop     ebp
.text$mn:00008F44                 retn    8
.text$mn:00008F44 ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z endp
.text$mn:00008F44
.text$mn:00008F44 ; ---------------------------------------------------------------------------
.text$mn:00008F47                 align 4
.text$mn:00008F47 _text$mn        ends
.text$mn:00008F47
.text$mn:00008F48 ; ===========================================================================
.text$mn:00008F48
.text$mn:00008F48 ; Segment type: Pure code
.text$mn:00008F48 ; Segment permissions: Read/Execute
.text$mn:00008F48 _text$mn        segment para public 'CODE' use32
.text$mn:00008F48                 assume cs:_text$mn
.text$mn:00008F48                 ;org 8F48h
.text$mn:00008F48 ; COMDAT (pick any)
.text$mn:00008F48                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008F48
.text$mn:00008F48 ; =============== S U B R O U T I N E =======================================
.text$mn:00008F48
.text$mn:00008F48 ; Attributes: bp-based frame
.text$mn:00008F48
.text$mn:00008F48                 public ?insert@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyl
.text$mn:00008F48 ?insert@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@ proc near
.text$mn:00008F48                                         ; CODE XREF: std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::assign(uint,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const &)+7Dp
.text$mn:00008F48
.text$mn:00008F48 var_24          = dword ptr -24h
.text$mn:00008F48 var_20          = dword ptr -20h
.text$mn:00008F48 var_1C          = dword ptr -1Ch
.text$mn:00008F48 var_18          = dword ptr -18h
.text$mn:00008F48 var_14          = dword ptr -14h
.text$mn:00008F48 var_10          = dword ptr -10h
.text$mn:00008F48 var_C           = dword ptr -0Ch
.text$mn:00008F48 var_4           = dword ptr -4
.text$mn:00008F48 arg_0           = dword ptr  8
.text$mn:00008F48 arg_4           = byte ptr  0Ch
.text$mn:00008F48 arg_10          = dword ptr  18h
.text$mn:00008F48 arg_14          = dword ptr  1Ch
.text$mn:00008F48
.text$mn:00008F48                 push    ebp
.text$mn:00008F49                 mov     ebp, esp
.text$mn:00008F4B                 push    0FFFFFFFFh
.text$mn:00008F4D                 push    offset __ehhandler$?insert@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V
.text$mn:00008F52                 mov     eax, large fs:0
.text$mn:00008F58                 push    eax
.text$mn:00008F59                 sub     esp, 18h
.text$mn:00008F5C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00008F61                 xor     eax, ebp
.text$mn:00008F63                 push    eax
.text$mn:00008F64                 lea     eax, [ebp+var_C]
.text$mn:00008F67                 mov     large fs:0, eax
.text$mn:00008F6D                 mov     [ebp+var_18], ecx
.text$mn:00008F70                 mov     [ebp+var_10], 0
.text$mn:00008F77                 mov     [ebp+var_4], 1
.text$mn:00008F7E                 mov     eax, [ebp+arg_14]
.text$mn:00008F81                 push    eax
.text$mn:00008F82                 mov     ecx, [ebp+arg_10]
.text$mn:00008F85                 push    ecx
.text$mn:00008F86                 sub     esp, 0Ch
.text$mn:00008F89                 mov     ecx, esp
.text$mn:00008F8B                 mov     [ebp+var_1C], esp
.text$mn:00008F8E                 lea     edx, [ebp+arg_4]
.text$mn:00008F91                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:00008F92                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>> const &)
.text$mn:00008F97                 mov     [ebp+var_14], eax
.text$mn:00008F9A                 mov     eax, [ebp+var_14]
.text$mn:00008F9D                 mov     [ebp+var_20], eax
.text$mn:00008FA0                 mov     byte ptr [ebp+var_4], 2
.text$mn:00008FA4                 mov     ecx, [ebp+arg_0]
.text$mn:00008FA7                 push    ecx
.text$mn:00008FA8                 mov     byte ptr [ebp+var_4], 1
.text$mn:00008FAC                 mov     ecx, [ebp+var_18]
.text$mn:00008FAF                 call    ?_Insert_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@
.text$mn:00008FB4                 mov     [ebp+var_24], eax
.text$mn:00008FB7                 mov     edx, [ebp+var_10]
.text$mn:00008FBA                 or      edx, 1
.text$mn:00008FBD                 mov     [ebp+var_10], edx
.text$mn:00008FC0                 mov     byte ptr [ebp+var_4], 0
.text$mn:00008FC4                 lea     ecx, [ebp+arg_4]
.text$mn:00008FC7                 call    ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>(void)
.text$mn:00008FCC                 mov     eax, [ebp+arg_0]
.text$mn:00008FCF                 mov     ecx, [ebp+var_C]
.text$mn:00008FD2                 mov     large fs:0, ecx
.text$mn:00008FD9                 pop     ecx
.text$mn:00008FDA                 mov     esp, ebp
.text$mn:00008FDC                 pop     ebp
.text$mn:00008FDD                 retn    18h
.text$mn:00008FDD ?insert@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std
.text$mn:00008FDD
.text$mn:00008FDD _text$mn        ends
.text$mn:00008FDD
.text$x:00008FE0 ; ===========================================================================
.text$x:00008FE0
.text$x:00008FE0 ; Segment type: Pure code
.text$x:00008FE0 ; Segment permissions: Read/Execute
.text$x:00008FE0 _text$x         segment para public 'CODE' use32
.text$x:00008FE0                 assume cs:_text$x
.text$x:00008FE0                 ;org 8FE0h
.text$x:00008FE0 ; COMDAT (pick associative to section at 8F48)
.text$x:00008FE0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00008FE0
.text$x:00008FE0 ; =============== S U B R O U T I N E =======================================
.text$x:00008FE0
.text$x:00008FE0
.text$x:00008FE0 __unwindfunclet$?insert@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@ proc near
.text$x:00008FE0                                         ; DATA XREF: .xdata$x:0000A238o
.text$x:00008FE0                 lea     ecx, [ebp+0Ch]
.text$x:00008FE3                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>(void)
.text$x:00008FE3 __unwindfunclet$?insert@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$
.text$x:00008FE3
.text$x:00008FE8
.text$x:00008FE8 ; =============== S U B R O U T I N E =======================================
.text$x:00008FE8
.text$x:00008FE8
.text$x:00008FE8 __unwindfunclet$?insert@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@_0 proc near
.text$x:00008FE8                                         ; DATA XREF: .xdata$x:0000A240o
.text$x:00008FE8                 mov     ecx, [ebp-1Ch]
.text$x:00008FEB                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>(void)
.text$x:00008FEB __unwindfunclet$?insert@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$
.text$x:00008FEB
.text$x:00008FF0
.text$x:00008FF0 ; =============== S U B R O U T I N E =======================================
.text$x:00008FF0
.text$x:00008FF0
.text$x:00008FF0 __unwindfunclet$?insert@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@_1 proc near
.text$x:00008FF0                                         ; DATA XREF: .xdata$x:0000A230o
.text$x:00008FF0                 mov     eax, [ebp-10h]
.text$x:00008FF3                 and     eax, 1
.text$x:00008FF6                 jz      $LN6_2
.text$x:00008FFC                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:00009000                 mov     ecx, [ebp+8]
.text$x:00009003                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>(void)
.text$x:00009008 ; ---------------------------------------------------------------------------
.text$x:00009008
.text$x:00009008 $LN6_2:                                 ; CODE XREF: __unwindfunclet$?insert@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator
.text$x:00009008                 retn
.text$x:00009008 __unwindfunclet$?insert@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$
.text$x:00009008
.text$x:00009009
.text$x:00009009 ; =============== S U B R O U T I N E =======================================
.text$x:00009009
.text$x:00009009
.text$x:00009009 __ehhandler$?insert@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std proc near
.text$x:00009009                                         ; DATA XREF: ?insert@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUS
.text$x:00009009
.text$x:00009009 arg_4           = dword ptr  8
.text$x:00009009
.text$x:00009009                 mov     edx, [esp+arg_4]
.text$x:0000900D                 lea     eax, [edx+0Ch]
.text$x:00009010                 mov     ecx, [edx-1Ch]
.text$x:00009013                 xor     ecx, eax
.text$x:00009015                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000901A                 mov     eax, offset __ehfuncinfo$?insert@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@
.text$x:0000901F                 jmp     ___CxxFrameHandler3
.text$x:0000901F __ehhandler$?insert@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBH
.text$x:0000901F
.text$x:0000901F _text$x         ends
.text$x:0000901F
.text$mn:00009024 ; ===========================================================================
.text$mn:00009024
.text$mn:00009024 ; Segment type: Pure code
.text$mn:00009024 ; Segment permissions: Read/Execute
.text$mn:00009024 _text$mn        segment para public 'CODE' use32
.text$mn:00009024                 assume cs:_text$mn
.text$mn:00009024                 ;org 9024h
.text$mn:00009024 ; COMDAT (pick any)
.text$mn:00009024                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009024
.text$mn:00009024 ; =============== S U B R O U T I N E =======================================
.text$mn:00009024
.text$mn:00009024 ; Attributes: bp-based frame
.text$mn:00009024
.text$mn:00009024 ; bool __thiscall Window::isVisible(Window *__hidden this)
.text$mn:00009024                 public ?isVisible@Window@@UBE_NXZ
.text$mn:00009024 ?isVisible@Window@@UBE_NXZ proc near    ; DATA XREF: .rdata:0000AFB8o
.text$mn:00009024                                         ; .rdata:0000AFECo
.text$mn:00009024
.text$mn:00009024 var_8           = dword ptr -8
.text$mn:00009024 var_1           = byte ptr -1
.text$mn:00009024
.text$mn:00009024                 push    ebp
.text$mn:00009025                 mov     ebp, esp
.text$mn:00009027                 sub     esp, 8
.text$mn:0000902A                 mov     [ebp+var_8], ecx
.text$mn:0000902D                 mov     eax, [ebp+var_8]
.text$mn:00009030                 mov     ecx, [eax+0Ch]
.text$mn:00009033                 push    ecx             ; hWnd
.text$mn:00009034                 call    dword ptr ds:__imp__IsWindowVisible@4 ; IsWindowVisible(x)
.text$mn:0000903A                 test    eax, eax
.text$mn:0000903C                 jz      short loc_9044
.text$mn:0000903E                 mov     [ebp+var_1], 1
.text$mn:00009042                 jmp     short loc_9048
.text$mn:00009044 ; ---------------------------------------------------------------------------
.text$mn:00009044
.text$mn:00009044 loc_9044:                               ; CODE XREF: Window::isVisible(void)+18j
.text$mn:00009044                 mov     [ebp+var_1], 0
.text$mn:00009048
.text$mn:00009048 loc_9048:                               ; CODE XREF: Window::isVisible(void)+1Ej
.text$mn:00009048                 mov     al, [ebp+var_1]
.text$mn:0000904B                 mov     esp, ebp
.text$mn:0000904D                 pop     ebp
.text$mn:0000904E                 retn
.text$mn:0000904E ?isVisible@Window@@UBE_NXZ endp
.text$mn:0000904E
.text$mn:0000904E ; ---------------------------------------------------------------------------
.text$mn:0000904F                 align 10h
.text$mn:0000904F _text$mn        ends
.text$mn:0000904F
.text$mn:00009050 ; ===========================================================================
.text$mn:00009050
.text$mn:00009050 ; Segment type: Pure code
.text$mn:00009050 ; Segment permissions: Read/Execute
.text$mn:00009050 _text$mn        segment para public 'CODE' use32
.text$mn:00009050                 assume cs:_text$mn
.text$mn:00009050                 ;org 9050h
.text$mn:00009050 ; COMDAT (pick any)
.text$mn:00009050                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009050
.text$mn:00009050 ; =============== S U B R O U T I N E =======================================
.text$mn:00009050
.text$mn:00009050 ; Attributes: bp-based frame
.text$mn:00009050
.text$mn:00009050 ; int __cdecl std::char_traits<char>::length(char *Str)
.text$mn:00009050                 public ?length@?$char_traits@D@std@@SAIPBD@Z
.text$mn:00009050 ?length@?$char_traits@D@std@@SAIPBD@Z proc near
.text$mn:00009050                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+21p
.text$mn:00009050
.text$mn:00009050 var_4           = dword ptr -4
.text$mn:00009050 Str             = dword ptr  8
.text$mn:00009050
.text$mn:00009050                 push    ebp
.text$mn:00009051                 mov     ebp, esp
.text$mn:00009053                 push    ecx
.text$mn:00009054                 mov     eax, [ebp+Str]
.text$mn:00009057                 movsx   ecx, byte ptr [eax]
.text$mn:0000905A                 test    ecx, ecx
.text$mn:0000905C                 jnz     short loc_9067
.text$mn:0000905E                 mov     [ebp+var_4], 0
.text$mn:00009065                 jmp     short loc_9076
.text$mn:00009067 ; ---------------------------------------------------------------------------
.text$mn:00009067
.text$mn:00009067 loc_9067:                               ; CODE XREF: std::char_traits<char>::length(char const *)+Cj
.text$mn:00009067                 mov     edx, [ebp+Str]
.text$mn:0000906A                 push    edx             ; Str
.text$mn:0000906B                 call    _strlen
.text$mn:00009070                 add     esp, 4
.text$mn:00009073                 mov     [ebp+var_4], eax
.text$mn:00009076
.text$mn:00009076 loc_9076:                               ; CODE XREF: std::char_traits<char>::length(char const *)+15j
.text$mn:00009076                 mov     eax, [ebp+var_4]
.text$mn:00009079                 mov     esp, ebp
.text$mn:0000907B                 pop     ebp
.text$mn:0000907C                 retn
.text$mn:0000907C ?length@?$char_traits@D@std@@SAIPBD@Z endp
.text$mn:0000907C
.text$mn:0000907C ; ---------------------------------------------------------------------------
.text$mn:0000907D                 align 10h
.text$mn:0000907D _text$mn        ends
.text$mn:0000907D
.text$mn:00009080 ; ===========================================================================
.text$mn:00009080
.text$mn:00009080 ; Segment type: Pure code
.text$mn:00009080 ; Segment permissions: Read/Execute
.text$mn:00009080 _text$mn        segment para public 'CODE' use32
.text$mn:00009080                 assume cs:_text$mn
.text$mn:00009080                 ;org 9080h
.text$mn:00009080 ; COMDAT (pick any)
.text$mn:00009080                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009080
.text$mn:00009080 ; =============== S U B R O U T I N E =======================================
.text$mn:00009080
.text$mn:00009080 ; Attributes: bp-based frame
.text$mn:00009080
.text$mn:00009080 ; public: unsigned int __thiscall std::_Wrap_alloc<struct std::_Wrap_alloc<class std::allocator<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>>>>::max_size(void)const
.text$mn:00009080                 public ?max_size@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QBEIXZ
.text$mn:00009080 ?max_size@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QBEIXZ proc near
.text$mn:00009080                                         ; CODE XREF: std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::max_size(void)+17p
.text$mn:00009080
.text$mn:00009080 var_4           = dword ptr -4
.text$mn:00009080
.text$mn:00009080                 push    ebp
.text$mn:00009081                 mov     ebp, esp
.text$mn:00009083                 push    ecx
.text$mn:00009084                 mov     [ebp+var_4], ecx
.text$mn:00009087                 mov     eax, [ebp+var_4]
.text$mn:0000908A                 push    eax
.text$mn:0000908B                 call    ?max_size@?$allocator_traits@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SAIABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@Z ; std::allocator_traits<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::max_size(std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>> const &)
.text$mn:00009090                 add     esp, 4
.text$mn:00009093                 mov     esp, ebp
.text$mn:00009095                 pop     ebp
.text$mn:00009096                 retn
.text$mn:00009096 ?max_size@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QBEIXZ endp
.text$mn:00009096
.text$mn:00009096 ; ---------------------------------------------------------------------------
.text$mn:00009097                 align 4
.text$mn:00009097 _text$mn        ends
.text$mn:00009097
.text$mn:00009098 ; ===========================================================================
.text$mn:00009098
.text$mn:00009098 ; Segment type: Pure code
.text$mn:00009098 ; Segment permissions: Read/Execute
.text$mn:00009098 _text$mn        segment para public 'CODE' use32
.text$mn:00009098                 assume cs:_text$mn
.text$mn:00009098                 ;org 9098h
.text$mn:00009098 ; COMDAT (pick any)
.text$mn:00009098                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009098
.text$mn:00009098 ; =============== S U B R O U T I N E =======================================
.text$mn:00009098
.text$mn:00009098 ; Attributes: bp-based frame
.text$mn:00009098
.text$mn:00009098 ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<char>>::max_size(void)const
.text$mn:00009098                 public ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
.text$mn:00009098 ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ proc near
.text$mn:00009098                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+17p
.text$mn:00009098
.text$mn:00009098 var_4           = dword ptr -4
.text$mn:00009098
.text$mn:00009098                 push    ebp
.text$mn:00009099                 mov     ebp, esp
.text$mn:0000909B                 push    ecx
.text$mn:0000909C                 mov     [ebp+var_4], ecx
.text$mn:0000909F                 mov     eax, [ebp+var_4]
.text$mn:000090A2                 push    eax
.text$mn:000090A3                 call    ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char> const &)
.text$mn:000090A8                 add     esp, 4
.text$mn:000090AB                 mov     esp, ebp
.text$mn:000090AD                 pop     ebp
.text$mn:000090AE                 retn
.text$mn:000090AE ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ endp
.text$mn:000090AE
.text$mn:000090AE ; ---------------------------------------------------------------------------
.text$mn:000090AF                 align 10h
.text$mn:000090AF _text$mn        ends
.text$mn:000090AF
.text$mn:000090B0 ; ===========================================================================
.text$mn:000090B0
.text$mn:000090B0 ; Segment type: Pure code
.text$mn:000090B0 ; Segment permissions: Read/Execute
.text$mn:000090B0 _text$mn        segment para public 'CODE' use32
.text$mn:000090B0                 assume cs:_text$mn
.text$mn:000090B0                 ;org 90B0h
.text$mn:000090B0 ; COMDAT (pick any)
.text$mn:000090B0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000090B0
.text$mn:000090B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000090B0
.text$mn:000090B0 ; Attributes: bp-based frame
.text$mn:000090B0
.text$mn:000090B0 ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<class ScintillaEditView *>>::max_size(void)const
.text$mn:000090B0                 public ?max_size@?$_Wrap_alloc@V?$allocator@PAVScintillaEditView@@@std@@@std@@QBEIXZ
.text$mn:000090B0 ?max_size@?$_Wrap_alloc@V?$allocator@PAVScintillaEditView@@@std@@@std@@QBEIXZ proc near
.text$mn:000090B0                                         ; CODE XREF: std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::max_size(void)+17p
.text$mn:000090B0
.text$mn:000090B0 var_4           = dword ptr -4
.text$mn:000090B0
.text$mn:000090B0                 push    ebp
.text$mn:000090B1                 mov     ebp, esp
.text$mn:000090B3                 push    ecx
.text$mn:000090B4                 mov     [ebp+var_4], ecx
.text$mn:000090B7                 mov     eax, [ebp+var_4]
.text$mn:000090BA                 push    eax
.text$mn:000090BB                 call    ?max_size@?$allocator_traits@V?$allocator@PAVScintillaEditView@@@std@@@std@@SAIABV?$allocator@PAVScintillaEditView@@@2@@Z ; std::allocator_traits<std::allocator<ScintillaEditView *>>::max_size(std::allocator<ScintillaEditView *> const &)
.text$mn:000090C0                 add     esp, 4
.text$mn:000090C3                 mov     esp, ebp
.text$mn:000090C5                 pop     ebp
.text$mn:000090C6                 retn
.text$mn:000090C6 ?max_size@?$_Wrap_alloc@V?$allocator@PAVScintillaEditView@@@std@@@std@@QBEIXZ endp
.text$mn:000090C6
.text$mn:000090C6 ; ---------------------------------------------------------------------------
.text$mn:000090C7                 align 4
.text$mn:000090C7 _text$mn        ends
.text$mn:000090C7
.text$mn:000090C8 ; ===========================================================================
.text$mn:000090C8
.text$mn:000090C8 ; Segment type: Pure code
.text$mn:000090C8 ; Segment permissions: Read/Execute
.text$mn:000090C8 _text$mn        segment para public 'CODE' use32
.text$mn:000090C8                 assume cs:_text$mn
.text$mn:000090C8                 ;org 90C8h
.text$mn:000090C8 ; COMDAT (pick any)
.text$mn:000090C8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000090C8
.text$mn:000090C8 ; =============== S U B R O U T I N E =======================================
.text$mn:000090C8
.text$mn:000090C8 ; Attributes: bp-based frame
.text$mn:000090C8
.text$mn:000090C8 ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>>>::max_size(void)const
.text$mn:000090C8                 public ?max_size@?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QBEIXZ
.text$mn:000090C8 ?max_size@?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QBEIXZ proc near
.text$mn:000090C8                                         ; CODE XREF: std::_Alloc_max_size::_Fn<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>(int,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>> const &)+6p
.text$mn:000090C8
.text$mn:000090C8 var_4           = dword ptr -4
.text$mn:000090C8
.text$mn:000090C8                 push    ebp
.text$mn:000090C9                 mov     ebp, esp
.text$mn:000090CB                 push    ecx
.text$mn:000090CC                 mov     [ebp+var_4], ecx
.text$mn:000090CF                 mov     eax, [ebp+var_4]
.text$mn:000090D2                 push    eax
.text$mn:000090D3                 call    ?max_size@?$allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SAIABV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@2@@Z ; std::allocator_traits<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>::max_size(std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>> const &)
.text$mn:000090D8                 add     esp, 4
.text$mn:000090DB                 mov     esp, ebp
.text$mn:000090DD                 pop     ebp
.text$mn:000090DE                 retn
.text$mn:000090DE ?max_size@?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QBEIXZ endp
.text$mn:000090DE
.text$mn:000090DE ; ---------------------------------------------------------------------------
.text$mn:000090DF                 align 10h
.text$mn:000090DF _text$mn        ends
.text$mn:000090DF
.text$mn:000090E0 ; ===========================================================================
.text$mn:000090E0
.text$mn:000090E0 ; Segment type: Pure code
.text$mn:000090E0 ; Segment permissions: Read/Execute
.text$mn:000090E0 _text$mn        segment para public 'CODE' use32
.text$mn:000090E0                 assume cs:_text$mn
.text$mn:000090E0                 ;org 90E0h
.text$mn:000090E0 ; COMDAT (pick any)
.text$mn:000090E0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000090E0
.text$mn:000090E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000090E0
.text$mn:000090E0 ; Attributes: bp-based frame
.text$mn:000090E0
.text$mn:000090E0 ; public: unsigned int __thiscall std::allocator<char>::max_size(void)const
.text$mn:000090E0                 public ?max_size@?$allocator@D@std@@QBEIXZ
.text$mn:000090E0 ?max_size@?$allocator@D@std@@QBEIXZ proc near
.text$mn:000090E0                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char> const &)+6p
.text$mn:000090E0
.text$mn:000090E0 var_4           = dword ptr -4
.text$mn:000090E0
.text$mn:000090E0                 push    ebp
.text$mn:000090E1                 mov     ebp, esp
.text$mn:000090E3                 push    ecx
.text$mn:000090E4                 mov     [ebp+var_4], ecx
.text$mn:000090E7                 or      eax, 0FFFFFFFFh
.text$mn:000090EA                 mov     esp, ebp
.text$mn:000090EC                 pop     ebp
.text$mn:000090ED                 retn
.text$mn:000090ED ?max_size@?$allocator@D@std@@QBEIXZ endp
.text$mn:000090ED
.text$mn:000090ED ; ---------------------------------------------------------------------------
.text$mn:000090EE                 align 10h
.text$mn:000090EE _text$mn        ends
.text$mn:000090EE
.text$mn:000090F0 ; ===========================================================================
.text$mn:000090F0
.text$mn:000090F0 ; Segment type: Pure code
.text$mn:000090F0 ; Segment permissions: Read/Execute
.text$mn:000090F0 _text$mn        segment para public 'CODE' use32
.text$mn:000090F0                 assume cs:_text$mn
.text$mn:000090F0                 ;org 90F0h
.text$mn:000090F0 ; COMDAT (pick any)
.text$mn:000090F0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000090F0
.text$mn:000090F0 ; =============== S U B R O U T I N E =======================================
.text$mn:000090F0
.text$mn:000090F0 ; Attributes: bp-based frame
.text$mn:000090F0
.text$mn:000090F0 ; public: unsigned int __thiscall std::allocator<class ScintillaEditView *>::max_size(void)const
.text$mn:000090F0                 public ?max_size@?$allocator@PAVScintillaEditView@@@std@@QBEIXZ
.text$mn:000090F0 ?max_size@?$allocator@PAVScintillaEditView@@@std@@QBEIXZ proc near
.text$mn:000090F0                                         ; CODE XREF: std::allocator_traits<std::allocator<ScintillaEditView *>>::max_size(std::allocator<ScintillaEditView *> const &)+6p
.text$mn:000090F0
.text$mn:000090F0 var_4           = dword ptr -4
.text$mn:000090F0
.text$mn:000090F0                 push    ebp
.text$mn:000090F1                 mov     ebp, esp
.text$mn:000090F3                 push    ecx
.text$mn:000090F4                 mov     [ebp+var_4], ecx
.text$mn:000090F7                 mov     eax, 3FFFFFFFh
.text$mn:000090FC                 mov     esp, ebp
.text$mn:000090FE                 pop     ebp
.text$mn:000090FF                 retn
.text$mn:000090FF ?max_size@?$allocator@PAVScintillaEditView@@@std@@QBEIXZ endp
.text$mn:000090FF
.text$mn:000090FF _text$mn        ends
.text$mn:000090FF
.text$mn:00009100 ; ===========================================================================
.text$mn:00009100
.text$mn:00009100 ; Segment type: Pure code
.text$mn:00009100 ; Segment permissions: Read/Execute
.text$mn:00009100 _text$mn        segment para public 'CODE' use32
.text$mn:00009100                 assume cs:_text$mn
.text$mn:00009100                 ;org 9100h
.text$mn:00009100 ; COMDAT (pick any)
.text$mn:00009100                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009100
.text$mn:00009100 ; =============== S U B R O U T I N E =======================================
.text$mn:00009100
.text$mn:00009100 ; Attributes: bp-based frame
.text$mn:00009100
.text$mn:00009100 ; public: unsigned int __thiscall std::allocator<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>>::max_size(void)const
.text$mn:00009100                 public ?max_size@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@QBEIXZ
.text$mn:00009100 ?max_size@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@QBEIXZ proc near
.text$mn:00009100                                         ; CODE XREF: std::allocator_traits<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>::max_size(std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>> const &)+6p
.text$mn:00009100
.text$mn:00009100 var_4           = dword ptr -4
.text$mn:00009100
.text$mn:00009100                 push    ebp
.text$mn:00009101                 mov     ebp, esp
.text$mn:00009103                 push    ecx
.text$mn:00009104                 mov     [ebp+var_4], ecx
.text$mn:00009107                 mov     eax, 3FFFFFFFh
.text$mn:0000910C                 mov     esp, ebp
.text$mn:0000910E                 pop     ebp
.text$mn:0000910F                 retn
.text$mn:0000910F ?max_size@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@QBEIXZ endp
.text$mn:0000910F
.text$mn:0000910F _text$mn        ends
.text$mn:0000910F
.text$mn:00009110 ; ===========================================================================
.text$mn:00009110
.text$mn:00009110 ; Segment type: Pure code
.text$mn:00009110 ; Segment permissions: Read/Execute
.text$mn:00009110 _text$mn        segment para public 'CODE' use32
.text$mn:00009110                 assume cs:_text$mn
.text$mn:00009110                 ;org 9110h
.text$mn:00009110 ; COMDAT (pick any)
.text$mn:00009110                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009110
.text$mn:00009110 ; =============== S U B R O U T I N E =======================================
.text$mn:00009110
.text$mn:00009110 ; Attributes: bp-based frame
.text$mn:00009110
.text$mn:00009110 ; public: static unsigned int __cdecl std::allocator_traits<struct std::_Wrap_alloc<class std::allocator<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>>>>::max_size(struct std::_Wrap_alloc<class std::allocator<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>>> const &)
.text$mn:00009110                 public ?max_size@?$allocator_traits@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SAIABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@Z
.text$mn:00009110 ?max_size@?$allocator_traits@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SAIABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@Z proc near
.text$mn:00009110                                         ; CODE XREF: std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::max_size(void)+Bp
.text$mn:00009110
.text$mn:00009110 arg_0           = dword ptr  8
.text$mn:00009110
.text$mn:00009110                 push    ebp
.text$mn:00009111                 mov     ebp, esp
.text$mn:00009113                 mov     eax, [ebp+arg_0]
.text$mn:00009116                 push    eax
.text$mn:00009117                 push    0
.text$mn:00009119                 call    ??$_Fn@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@_Alloc_max_size@std@@SAIHABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@1@@Z ; std::_Alloc_max_size::_Fn<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>(int,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>> const &)
.text$mn:0000911E                 add     esp, 8
.text$mn:00009121                 pop     ebp
.text$mn:00009122                 retn
.text$mn:00009122 ?max_size@?$allocator_traits@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SAIABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@Z endp
.text$mn:00009122
.text$mn:00009122 ; ---------------------------------------------------------------------------
.text$mn:00009123                 align 4
.text$mn:00009123 _text$mn        ends
.text$mn:00009123
.text$mn:00009124 ; ===========================================================================
.text$mn:00009124
.text$mn:00009124 ; Segment type: Pure code
.text$mn:00009124 ; Segment permissions: Read/Execute
.text$mn:00009124 _text$mn        segment para public 'CODE' use32
.text$mn:00009124                 assume cs:_text$mn
.text$mn:00009124                 ;org 9124h
.text$mn:00009124 ; COMDAT (pick any)
.text$mn:00009124                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009124
.text$mn:00009124 ; =============== S U B R O U T I N E =======================================
.text$mn:00009124
.text$mn:00009124 ; Attributes: bp-based frame
.text$mn:00009124
.text$mn:00009124 ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<char>>::max_size(class std::allocator<char> const &)
.text$mn:00009124                 public ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
.text$mn:00009124 ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z proc near
.text$mn:00009124                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::max_size(void)+Bp
.text$mn:00009124
.text$mn:00009124 arg_0           = dword ptr  8
.text$mn:00009124
.text$mn:00009124                 push    ebp
.text$mn:00009125                 mov     ebp, esp
.text$mn:00009127                 mov     ecx, [ebp+arg_0]
.text$mn:0000912A                 call    ?max_size@?$allocator@D@std@@QBEIXZ ; std::allocator<char>::max_size(void)
.text$mn:0000912F                 pop     ebp
.text$mn:00009130                 retn
.text$mn:00009130 ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z endp
.text$mn:00009130
.text$mn:00009130 ; ---------------------------------------------------------------------------
.text$mn:00009131                 align 4
.text$mn:00009131 _text$mn        ends
.text$mn:00009131
.text$mn:00009134 ; ===========================================================================
.text$mn:00009134
.text$mn:00009134 ; Segment type: Pure code
.text$mn:00009134 ; Segment permissions: Read/Execute
.text$mn:00009134 _text$mn        segment para public 'CODE' use32
.text$mn:00009134                 assume cs:_text$mn
.text$mn:00009134                 ;org 9134h
.text$mn:00009134 ; COMDAT (pick any)
.text$mn:00009134                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009134
.text$mn:00009134 ; =============== S U B R O U T I N E =======================================
.text$mn:00009134
.text$mn:00009134 ; Attributes: bp-based frame
.text$mn:00009134
.text$mn:00009134 ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<class ScintillaEditView *>>::max_size(class std::allocator<class ScintillaEditView *> const &)
.text$mn:00009134                 public ?max_size@?$allocator_traits@V?$allocator@PAVScintillaEditView@@@std@@@std@@SAIABV?$allocator@PAVScintillaEditView@@@2@@Z
.text$mn:00009134 ?max_size@?$allocator_traits@V?$allocator@PAVScintillaEditView@@@std@@@std@@SAIABV?$allocator@PAVScintillaEditView@@@2@@Z proc near
.text$mn:00009134                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<ScintillaEditView *>>::max_size(void)+Bp
.text$mn:00009134
.text$mn:00009134 arg_0           = dword ptr  8
.text$mn:00009134
.text$mn:00009134                 push    ebp
.text$mn:00009135                 mov     ebp, esp
.text$mn:00009137                 mov     ecx, [ebp+arg_0]
.text$mn:0000913A                 call    ?max_size@?$allocator@PAVScintillaEditView@@@std@@QBEIXZ ; std::allocator<ScintillaEditView *>::max_size(void)
.text$mn:0000913F                 pop     ebp
.text$mn:00009140                 retn
.text$mn:00009140 ?max_size@?$allocator_traits@V?$allocator@PAVScintillaEditView@@@std@@@std@@SAIABV?$allocator@PAVScintillaEditView@@@2@@Z endp
.text$mn:00009140
.text$mn:00009140 ; ---------------------------------------------------------------------------
.text$mn:00009141                 align 4
.text$mn:00009141 _text$mn        ends
.text$mn:00009141
.text$mn:00009144 ; ===========================================================================
.text$mn:00009144
.text$mn:00009144 ; Segment type: Pure code
.text$mn:00009144 ; Segment permissions: Read/Execute
.text$mn:00009144 _text$mn        segment para public 'CODE' use32
.text$mn:00009144                 assume cs:_text$mn
.text$mn:00009144                 ;org 9144h
.text$mn:00009144 ; COMDAT (pick any)
.text$mn:00009144                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009144
.text$mn:00009144 ; =============== S U B R O U T I N E =======================================
.text$mn:00009144
.text$mn:00009144 ; Attributes: bp-based frame
.text$mn:00009144
.text$mn:00009144 ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>>>::max_size(class std::allocator<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>> const &)
.text$mn:00009144                 public ?max_size@?$allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SAIABV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@2@@Z
.text$mn:00009144 ?max_size@?$allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SAIABV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@2@@Z proc near
.text$mn:00009144                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>::max_size(void)+Bp
.text$mn:00009144
.text$mn:00009144 arg_0           = dword ptr  8
.text$mn:00009144
.text$mn:00009144                 push    ebp
.text$mn:00009145                 mov     ebp, esp
.text$mn:00009147                 mov     ecx, [ebp+arg_0]
.text$mn:0000914A                 call    ?max_size@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@QBEIXZ ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>::max_size(void)
.text$mn:0000914F                 pop     ebp
.text$mn:00009150                 retn
.text$mn:00009150 ?max_size@?$allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SAIABV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@2@@Z endp
.text$mn:00009150
.text$mn:00009150 ; ---------------------------------------------------------------------------
.text$mn:00009151                 align 4
.text$mn:00009151 _text$mn        ends
.text$mn:00009151
.text$mn:00009154 ; ===========================================================================
.text$mn:00009154
.text$mn:00009154 ; Segment type: Pure code
.text$mn:00009154 ; Segment permissions: Read/Execute
.text$mn:00009154 _text$mn        segment para public 'CODE' use32
.text$mn:00009154                 assume cs:_text$mn
.text$mn:00009154                 ;org 9154h
.text$mn:00009154 ; COMDAT (pick any)
.text$mn:00009154                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009154
.text$mn:00009154 ; =============== S U B R O U T I N E =======================================
.text$mn:00009154
.text$mn:00009154 ; Attributes: bp-based frame
.text$mn:00009154
.text$mn:00009154 ; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::max_size(void)const
.text$mn:00009154                 public ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
.text$mn:00009154 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
.text$mn:00009154                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+3Bp
.text$mn:00009154                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+6Ap ...
.text$mn:00009154
.text$mn:00009154 var_10          = dword ptr -10h
.text$mn:00009154 var_C           = dword ptr -0Ch
.text$mn:00009154 var_8           = dword ptr -8
.text$mn:00009154 var_1           = byte ptr -1
.text$mn:00009154
.text$mn:00009154                 push    ebp
.text$mn:00009155                 mov     ebp, esp
.text$mn:00009157                 sub     esp, 10h
.text$mn:0000915A                 mov     [ebp+var_10], ecx
.text$mn:0000915D                 lea     eax, [ebp+var_1]
.text$mn:00009160                 push    eax
.text$mn:00009161                 mov     ecx, [ebp+var_10]
.text$mn:00009164                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00009169                 mov     ecx, eax
.text$mn:0000916B                 call    ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char>>::max_size(void)
.text$mn:00009170                 mov     [ebp+var_8], eax
.text$mn:00009173                 cmp     [ebp+var_8], 1
.text$mn:00009177                 ja      short loc_9182
.text$mn:00009179                 mov     [ebp+var_C], 1
.text$mn:00009180                 jmp     short loc_918B
.text$mn:00009182 ; ---------------------------------------------------------------------------
.text$mn:00009182
.text$mn:00009182 loc_9182:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+23j
.text$mn:00009182                 mov     ecx, [ebp+var_8]
.text$mn:00009185                 sub     ecx, 1
.text$mn:00009188                 mov     [ebp+var_C], ecx
.text$mn:0000918B
.text$mn:0000918B loc_918B:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+2Cj
.text$mn:0000918B                 mov     eax, [ebp+var_C]
.text$mn:0000918E                 mov     esp, ebp
.text$mn:00009190                 pop     ebp
.text$mn:00009191                 retn
.text$mn:00009191 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp
.text$mn:00009191
.text$mn:00009191 ; ---------------------------------------------------------------------------
.text$mn:00009192                 align 4
.text$mn:00009192 _text$mn        ends
.text$mn:00009192
.text$mn:00009194 ; ===========================================================================
.text$mn:00009194
.text$mn:00009194 ; Segment type: Pure code
.text$mn:00009194 ; Segment permissions: Read/Execute
.text$mn:00009194 _text$mn        segment para public 'CODE' use32
.text$mn:00009194                 assume cs:_text$mn
.text$mn:00009194                 ;org 9194h
.text$mn:00009194 ; COMDAT (pick any)
.text$mn:00009194                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009194
.text$mn:00009194 ; =============== S U B R O U T I N E =======================================
.text$mn:00009194
.text$mn:00009194 ; Attributes: bp-based frame
.text$mn:00009194
.text$mn:00009194 ; public: unsigned int __thiscall std::vector<class ScintillaEditView *, class std::allocator<class ScintillaEditView *>>::max_size(void)const
.text$mn:00009194                 public ?max_size@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@QBEIXZ
.text$mn:00009194 ?max_size@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@QBEIXZ proc near
.text$mn:00009194                                         ; CODE XREF: std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::_Grow_to(uint)+17p
.text$mn:00009194                                         ; std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::_Reserve(uint)+18p
.text$mn:00009194
.text$mn:00009194 var_8           = dword ptr -8
.text$mn:00009194 var_1           = byte ptr -1
.text$mn:00009194
.text$mn:00009194                 push    ebp
.text$mn:00009195                 mov     ebp, esp
.text$mn:00009197                 sub     esp, 8
.text$mn:0000919A                 mov     [ebp+var_8], ecx
.text$mn:0000919D                 lea     eax, [ebp+var_1]
.text$mn:000091A0                 push    eax
.text$mn:000091A1                 mov     ecx, [ebp+var_8]
.text$mn:000091A4                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVScintillaEditView@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<ScintillaEditView *,std::allocator<ScintillaEditView *>>>::_Getal(void)
.text$mn:000091A9                 mov     ecx, eax
.text$mn:000091AB                 call    ?max_size@?$_Wrap_alloc@V?$allocator@PAVScintillaEditView@@@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<ScintillaEditView *>>::max_size(void)
.text$mn:000091B0                 mov     esp, ebp
.text$mn:000091B2                 pop     ebp
.text$mn:000091B3                 retn
.text$mn:000091B3 ?max_size@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@QBEIXZ endp
.text$mn:000091B3
.text$mn:000091B3 _text$mn        ends
.text$mn:000091B3
.text$mn:000091B4 ; ===========================================================================
.text$mn:000091B4
.text$mn:000091B4 ; Segment type: Pure code
.text$mn:000091B4 ; Segment permissions: Read/Execute
.text$mn:000091B4 _text$mn        segment para public 'CODE' use32
.text$mn:000091B4                 assume cs:_text$mn
.text$mn:000091B4                 ;org 91B4h
.text$mn:000091B4 ; COMDAT (pick any)
.text$mn:000091B4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000091B4
.text$mn:000091B4 ; =============== S U B R O U T I N E =======================================
.text$mn:000091B4
.text$mn:000091B4 ; Attributes: bp-based frame
.text$mn:000091B4
.text$mn:000091B4 ; public: unsigned int __thiscall std::vector<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>, struct std::_Wrap_alloc<class std::allocator<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>>>>::max_size(void)const
.text$mn:000091B4                 public ?max_size@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QBEIXZ
.text$mn:000091B4 ?max_size@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QBEIXZ proc near
.text$mn:000091B4                                         ; CODE XREF: std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::_Grow_to(uint)+17p
.text$mn:000091B4                                         ; ?_Insert_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@s
.text$mn:000091B4
.text$mn:000091B4 var_8           = dword ptr -8
.text$mn:000091B4 var_1           = byte ptr -1
.text$mn:000091B4
.text$mn:000091B4                 push    ebp
.text$mn:000091B5                 mov     ebp, esp
.text$mn:000091B7                 sub     esp, 8
.text$mn:000091BA                 mov     [ebp+var_8], ecx
.text$mn:000091BD                 lea     eax, [ebp+var_1]
.text$mn:000091C0                 push    eax
.text$mn:000091C1                 mov     ecx, [ebp+var_8]
.text$mn:000091C4                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>>::_Getal(void)
.text$mn:000091C9                 mov     ecx, eax
.text$mn:000091CB                 call    ?max_size@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::max_size(void)
.text$mn:000091D0                 mov     esp, ebp
.text$mn:000091D2                 pop     ebp
.text$mn:000091D3                 retn
.text$mn:000091D3 ?max_size@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QBEIXZ endp
.text$mn:000091D3
.text$mn:000091D3 _text$mn        ends
.text$mn:000091D3
.text$mn:000091D4 ; ===========================================================================
.text$mn:000091D4
.text$mn:000091D4 ; Segment type: Pure code
.text$mn:000091D4 ; Segment permissions: Read/Execute
.text$mn:000091D4 _text$mn        segment para public 'CODE' use32
.text$mn:000091D4                 assume cs:_text$mn
.text$mn:000091D4                 ;org 91D4h
.text$mn:000091D4 ; COMDAT (pick any)
.text$mn:000091D4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000091D4
.text$mn:000091D4 ; =============== S U B R O U T I N E =======================================
.text$mn:000091D4
.text$mn:000091D4 ; Attributes: bp-based frame
.text$mn:000091D4
.text$mn:000091D4 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Generic_error_category::message(int)const
.text$mn:000091D4                 public ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:000091D4 ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:000091D4                                         ; CODE XREF: std::_Iostream_error_category::message(int)+64p
.text$mn:000091D4                                         ; DATA XREF: .rdata:0000AEE8o
.text$mn:000091D4
.text$mn:000091D4 var_1C          = dword ptr -1Ch
.text$mn:000091D4 var_18          = dword ptr -18h
.text$mn:000091D4 Str             = dword ptr -14h
.text$mn:000091D4 var_10          = dword ptr -10h
.text$mn:000091D4 var_C           = dword ptr -0Ch
.text$mn:000091D4 var_4           = dword ptr -4
.text$mn:000091D4 arg_0           = dword ptr  8
.text$mn:000091D4 arg_4           = dword ptr  0Ch
.text$mn:000091D4
.text$mn:000091D4                 push    ebp
.text$mn:000091D5                 mov     ebp, esp
.text$mn:000091D7                 push    0FFFFFFFFh
.text$mn:000091D9                 push    offset __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:000091DE                 mov     eax, large fs:0
.text$mn:000091E4                 push    eax
.text$mn:000091E5                 sub     esp, 10h
.text$mn:000091E8                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000091ED                 xor     eax, ebp
.text$mn:000091EF                 push    eax
.text$mn:000091F0                 lea     eax, [ebp+var_C]
.text$mn:000091F3                 mov     large fs:0, eax
.text$mn:000091F9                 mov     [ebp+var_1C], ecx
.text$mn:000091FC                 mov     [ebp+var_18], 0
.text$mn:00009203                 mov     eax, [ebp+arg_4]
.text$mn:00009206                 push    eax             ; int
.text$mn:00009207                 call    ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map(int)
.text$mn:0000920C                 add     esp, 4
.text$mn:0000920F                 mov     [ebp+var_10], eax
.text$mn:00009212                 cmp     [ebp+var_10], 0
.text$mn:00009216                 jz      short loc_9220
.text$mn:00009218                 mov     ecx, [ebp+var_10]
.text$mn:0000921B                 mov     [ebp+Str], ecx
.text$mn:0000921E                 jmp     short loc_9227
.text$mn:00009220 ; ---------------------------------------------------------------------------
.text$mn:00009220
.text$mn:00009220 loc_9220:                               ; CODE XREF: std::_Generic_error_category::message(int)+42j
.text$mn:00009220                 mov     [ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ ; "unknown error"
.text$mn:00009227
.text$mn:00009227 loc_9227:                               ; CODE XREF: std::_Generic_error_category::message(int)+4Aj
.text$mn:00009227                 mov     edx, [ebp+Str]
.text$mn:0000922A                 push    edx             ; Str
.text$mn:0000922B                 mov     ecx, [ebp+arg_0]
.text$mn:0000922E                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:00009233                 mov     [ebp+var_4], 0
.text$mn:0000923A                 mov     eax, [ebp+var_18]
.text$mn:0000923D                 or      eax, 1
.text$mn:00009240                 mov     [ebp+var_18], eax
.text$mn:00009243                 mov     eax, [ebp+arg_0]
.text$mn:00009246                 mov     ecx, [ebp+var_C]
.text$mn:00009249                 mov     large fs:0, ecx
.text$mn:00009250                 pop     ecx
.text$mn:00009251                 mov     esp, ebp
.text$mn:00009253                 pop     ebp
.text$mn:00009254                 retn    8
.text$mn:00009254 ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:00009254
.text$mn:00009254 ; ---------------------------------------------------------------------------
.text$mn:00009257                 align 4
.text$mn:00009257 _text$mn        ends
.text$mn:00009257
.text$x:00009258 ; ===========================================================================
.text$x:00009258
.text$x:00009258 ; Segment type: Pure code
.text$x:00009258 ; Segment permissions: Read/Execute
.text$x:00009258 _text$x         segment para public 'CODE' use32
.text$x:00009258                 assume cs:_text$x
.text$x:00009258                 ;org 9258h
.text$x:00009258 ; COMDAT (pick associative to section at 91D4)
.text$x:00009258                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00009258
.text$x:00009258 ; =============== S U B R O U T I N E =======================================
.text$x:00009258
.text$x:00009258
.text$x:00009258 __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:00009258                                         ; DATA XREF: .xdata$x:00009B2Co
.text$x:00009258                 mov     eax, [ebp-18h]
.text$x:0000925B                 and     eax, 1
.text$x:0000925E                 jz      $LN6
.text$x:00009264                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:00009268                 mov     ecx, [ebp+8]
.text$x:0000926B                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00009270 ; ---------------------------------------------------------------------------
.text$x:00009270
.text$x:00009270 $LN6:                                   ; CODE XREF: __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:00009270                 retn
.text$x:00009270 __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:00009270
.text$x:00009271
.text$x:00009271 ; =============== S U B R O U T I N E =======================================
.text$x:00009271
.text$x:00009271
.text$x:00009271 __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:00009271                                         ; DATA XREF: std::_Generic_error_category::message(int)+5o
.text$x:00009271
.text$x:00009271 arg_4           = dword ptr  8
.text$x:00009271
.text$x:00009271                 mov     edx, [esp+arg_4]
.text$x:00009275                 lea     eax, [edx+0Ch]
.text$x:00009278                 mov     ecx, [edx-14h]
.text$x:0000927B                 xor     ecx, eax
.text$x:0000927D                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00009282                 mov     eax, offset __ehfuncinfo$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:00009287                 jmp     ___CxxFrameHandler3
.text$x:00009287 __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:00009287
.text$x:00009287 _text$x         ends
.text$x:00009287
.text$mn:0000928C ; ===========================================================================
.text$mn:0000928C
.text$mn:0000928C ; Segment type: Pure code
.text$mn:0000928C ; Segment permissions: Read/Execute
.text$mn:0000928C _text$mn        segment para public 'CODE' use32
.text$mn:0000928C                 assume cs:_text$mn
.text$mn:0000928C                 ;org 928Ch
.text$mn:0000928C ; COMDAT (pick any)
.text$mn:0000928C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000928C
.text$mn:0000928C ; =============== S U B R O U T I N E =======================================
.text$mn:0000928C
.text$mn:0000928C ; Attributes: bp-based frame
.text$mn:0000928C
.text$mn:0000928C ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Iostream_error_category::message(int)const
.text$mn:0000928C                 public ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:0000928C ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:0000928C                                         ; DATA XREF: .rdata:0000AF1Co
.text$mn:0000928C
.text$mn:0000928C var_14          = dword ptr -14h
.text$mn:0000928C var_10          = dword ptr -10h
.text$mn:0000928C var_C           = dword ptr -0Ch
.text$mn:0000928C var_4           = dword ptr -4
.text$mn:0000928C arg_0           = dword ptr  8
.text$mn:0000928C arg_4           = dword ptr  0Ch
.text$mn:0000928C
.text$mn:0000928C                 push    ebp
.text$mn:0000928D                 mov     ebp, esp
.text$mn:0000928F                 push    0FFFFFFFFh
.text$mn:00009291                 push    offset __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00009296                 mov     eax, large fs:0
.text$mn:0000929C                 push    eax
.text$mn:0000929D                 sub     esp, 8
.text$mn:000092A0                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000092A5                 xor     eax, ebp
.text$mn:000092A7                 push    eax
.text$mn:000092A8                 lea     eax, [ebp+var_C]
.text$mn:000092AB                 mov     large fs:0, eax
.text$mn:000092B1                 mov     [ebp+var_14], ecx
.text$mn:000092B4                 mov     [ebp+var_10], 0
.text$mn:000092BB                 cmp     [ebp+arg_4], 1
.text$mn:000092BF                 jnz     short loc_92E5
.text$mn:000092C1                 push    offset ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ ; "iostream stream error"
.text$mn:000092C6                 mov     ecx, [ebp+arg_0]
.text$mn:000092C9                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:000092CE                 mov     [ebp+var_4], 0
.text$mn:000092D5                 mov     eax, [ebp+var_10]
.text$mn:000092D8                 or      eax, 1
.text$mn:000092DB                 mov     [ebp+var_10], eax
.text$mn:000092DE                 mov     eax, [ebp+arg_0]
.text$mn:000092E1                 jmp     short loc_9308
.text$mn:000092E3 ; ---------------------------------------------------------------------------
.text$mn:000092E3                 jmp     short loc_9308
.text$mn:000092E5 ; ---------------------------------------------------------------------------
.text$mn:000092E5
.text$mn:000092E5 loc_92E5:                               ; CODE XREF: std::_Iostream_error_category::message(int)+33j
.text$mn:000092E5                 mov     ecx, [ebp+arg_4]
.text$mn:000092E8                 push    ecx
.text$mn:000092E9                 mov     edx, [ebp+arg_0]
.text$mn:000092EC                 push    edx
.text$mn:000092ED                 mov     ecx, [ebp+var_14]
.text$mn:000092F0                 call    ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
.text$mn:000092F5                 mov     [ebp+var_4], 0
.text$mn:000092FC                 mov     eax, [ebp+var_10]
.text$mn:000092FF                 or      eax, 1
.text$mn:00009302                 mov     [ebp+var_10], eax
.text$mn:00009305                 mov     eax, [ebp+arg_0]
.text$mn:00009308
.text$mn:00009308 loc_9308:                               ; CODE XREF: std::_Iostream_error_category::message(int)+55j
.text$mn:00009308                                         ; std::_Iostream_error_category::message(int)+57j
.text$mn:00009308                 mov     ecx, [ebp+var_C]
.text$mn:0000930B                 mov     large fs:0, ecx
.text$mn:00009312                 pop     ecx
.text$mn:00009313                 mov     esp, ebp
.text$mn:00009315                 pop     ebp
.text$mn:00009316                 retn    8
.text$mn:00009316 ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:00009316
.text$mn:00009316 ; ---------------------------------------------------------------------------
.text$mn:00009319                 align 4
.text$mn:00009319 _text$mn        ends
.text$mn:00009319
.text$x:0000931C ; ===========================================================================
.text$x:0000931C
.text$x:0000931C ; Segment type: Pure code
.text$x:0000931C ; Segment permissions: Read/Execute
.text$x:0000931C _text$x         segment para public 'CODE' use32
.text$x:0000931C                 assume cs:_text$x
.text$x:0000931C                 ;org 931Ch
.text$x:0000931C ; COMDAT (pick associative to section at 928C)
.text$x:0000931C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000931C
.text$x:0000931C ; =============== S U B R O U T I N E =======================================
.text$x:0000931C
.text$x:0000931C
.text$x:0000931C __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:0000931C                                         ; DATA XREF: .xdata$x:00009BB0o
.text$x:0000931C                 mov     eax, [ebp-10h]
.text$x:0000931F                 and     eax, 1
.text$x:00009322                 jz      $LN6_0
.text$x:00009328                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:0000932C                 mov     ecx, [ebp+8]
.text$x:0000932F                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00009334 ; ---------------------------------------------------------------------------
.text$x:00009334
.text$x:00009334 $LN6_0:                                 ; CODE XREF: __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:00009334                 retn
.text$x:00009334 __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:00009334
.text$x:00009335
.text$x:00009335 ; =============== S U B R O U T I N E =======================================
.text$x:00009335
.text$x:00009335
.text$x:00009335 __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:00009335                                         ; DATA XREF: std::_Iostream_error_category::message(int)+5o
.text$x:00009335
.text$x:00009335 arg_4           = dword ptr  8
.text$x:00009335
.text$x:00009335                 mov     edx, [esp+arg_4]
.text$x:00009339                 lea     eax, [edx+0Ch]
.text$x:0000933C                 mov     ecx, [edx-0Ch]
.text$x:0000933F                 xor     ecx, eax
.text$x:00009341                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00009346                 mov     eax, offset __ehfuncinfo$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:0000934B                 jmp     ___CxxFrameHandler3
.text$x:0000934B __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:0000934B
.text$x:0000934B _text$x         ends
.text$x:0000934B
.text$mn:00009350 ; ===========================================================================
.text$mn:00009350
.text$mn:00009350 ; Segment type: Pure code
.text$mn:00009350 ; Segment permissions: Read/Execute
.text$mn:00009350 _text$mn        segment para public 'CODE' use32
.text$mn:00009350                 assume cs:_text$mn
.text$mn:00009350                 ;org 9350h
.text$mn:00009350 ; COMDAT (pick any)
.text$mn:00009350                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009350
.text$mn:00009350 ; =============== S U B R O U T I N E =======================================
.text$mn:00009350
.text$mn:00009350 ; Attributes: bp-based frame
.text$mn:00009350
.text$mn:00009350 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_System_error_category::message(int)const
.text$mn:00009350                 public ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00009350 ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:00009350                                         ; DATA XREF: .rdata:0000AF5Co
.text$mn:00009350
.text$mn:00009350 var_1C          = dword ptr -1Ch
.text$mn:00009350 var_18          = dword ptr -18h
.text$mn:00009350 Str             = dword ptr -14h
.text$mn:00009350 var_10          = dword ptr -10h
.text$mn:00009350 var_C           = dword ptr -0Ch
.text$mn:00009350 var_4           = dword ptr -4
.text$mn:00009350 arg_0           = dword ptr  8
.text$mn:00009350 arg_4           = dword ptr  0Ch
.text$mn:00009350
.text$mn:00009350                 push    ebp
.text$mn:00009351                 mov     ebp, esp
.text$mn:00009353                 push    0FFFFFFFFh
.text$mn:00009355                 push    offset __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:0000935A                 mov     eax, large fs:0
.text$mn:00009360                 push    eax
.text$mn:00009361                 sub     esp, 10h
.text$mn:00009364                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00009369                 xor     eax, ebp
.text$mn:0000936B                 push    eax
.text$mn:0000936C                 lea     eax, [ebp+var_C]
.text$mn:0000936F                 mov     large fs:0, eax
.text$mn:00009375                 mov     [ebp+var_1C], ecx
.text$mn:00009378                 mov     [ebp+var_18], 0
.text$mn:0000937F                 mov     eax, [ebp+arg_4]
.text$mn:00009382                 push    eax             ; int
.text$mn:00009383                 call    ?_Winerror_map@std@@YAPBDH@Z ; std::_Winerror_map(int)
.text$mn:00009388                 add     esp, 4
.text$mn:0000938B                 mov     [ebp+var_10], eax
.text$mn:0000938E                 cmp     [ebp+var_10], 0
.text$mn:00009392                 jz      short loc_939C
.text$mn:00009394                 mov     ecx, [ebp+var_10]
.text$mn:00009397                 mov     [ebp+Str], ecx
.text$mn:0000939A                 jmp     short loc_93A3
.text$mn:0000939C ; ---------------------------------------------------------------------------
.text$mn:0000939C
.text$mn:0000939C loc_939C:                               ; CODE XREF: std::_System_error_category::message(int)+42j
.text$mn:0000939C                 mov     [ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ ; "unknown error"
.text$mn:000093A3
.text$mn:000093A3 loc_93A3:                               ; CODE XREF: std::_System_error_category::message(int)+4Aj
.text$mn:000093A3                 mov     edx, [ebp+Str]
.text$mn:000093A6                 push    edx             ; Str
.text$mn:000093A7                 mov     ecx, [ebp+arg_0]
.text$mn:000093AA                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:000093AF                 mov     [ebp+var_4], 0
.text$mn:000093B6                 mov     eax, [ebp+var_18]
.text$mn:000093B9                 or      eax, 1
.text$mn:000093BC                 mov     [ebp+var_18], eax
.text$mn:000093BF                 mov     eax, [ebp+arg_0]
.text$mn:000093C2                 mov     ecx, [ebp+var_C]
.text$mn:000093C5                 mov     large fs:0, ecx
.text$mn:000093CC                 pop     ecx
.text$mn:000093CD                 mov     esp, ebp
.text$mn:000093CF                 pop     ebp
.text$mn:000093D0                 retn    8
.text$mn:000093D0 ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:000093D0
.text$mn:000093D0 ; ---------------------------------------------------------------------------
.text$mn:000093D3                 align 4
.text$mn:000093D3 _text$mn        ends
.text$mn:000093D3
.text$x:000093D4 ; ===========================================================================
.text$x:000093D4
.text$x:000093D4 ; Segment type: Pure code
.text$x:000093D4 ; Segment permissions: Read/Execute
.text$x:000093D4 _text$x         segment para public 'CODE' use32
.text$x:000093D4                 assume cs:_text$x
.text$x:000093D4                 ;org 93D4h
.text$x:000093D4 ; COMDAT (pick associative to section at 9350)
.text$x:000093D4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000093D4
.text$x:000093D4 ; =============== S U B R O U T I N E =======================================
.text$x:000093D4
.text$x:000093D4
.text$x:000093D4 __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:000093D4                                         ; DATA XREF: .xdata$x:00009C34o
.text$x:000093D4                 mov     eax, [ebp-18h]
.text$x:000093D7                 and     eax, 1
.text$x:000093DA                 jz      $LN6_1
.text$x:000093E0                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:000093E4                 mov     ecx, [ebp+8]
.text$x:000093E7                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:000093EC ; ---------------------------------------------------------------------------
.text$x:000093EC
.text$x:000093EC $LN6_1:                                 ; CODE XREF: __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:000093EC                 retn
.text$x:000093EC __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:000093EC
.text$x:000093ED
.text$x:000093ED ; =============== S U B R O U T I N E =======================================
.text$x:000093ED
.text$x:000093ED
.text$x:000093ED __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:000093ED                                         ; DATA XREF: std::_System_error_category::message(int)+5o
.text$x:000093ED
.text$x:000093ED arg_4           = dword ptr  8
.text$x:000093ED
.text$x:000093ED                 mov     edx, [esp+arg_4]
.text$x:000093F1                 lea     eax, [edx+0Ch]
.text$x:000093F4                 mov     ecx, [edx-14h]
.text$x:000093F7                 xor     ecx, eax
.text$x:000093F9                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000093FE                 mov     eax, offset __ehfuncinfo$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:00009403                 jmp     ___CxxFrameHandler3
.text$x:00009403 __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:00009403
.text$x:00009403 _text$x         ends
.text$x:00009403
.text$mn:00009408 ; ===========================================================================
.text$mn:00009408
.text$mn:00009408 ; Segment type: Pure code
.text$mn:00009408 ; Segment permissions: Read/Execute
.text$mn:00009408 _text$mn        segment para public 'CODE' use32
.text$mn:00009408                 assume cs:_text$mn
.text$mn:00009408                 ;org 9408h
.text$mn:00009408 ; COMDAT (pick any)
.text$mn:00009408                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009408
.text$mn:00009408 ; =============== S U B R O U T I N E =======================================
.text$mn:00009408
.text$mn:00009408 ; Attributes: bp-based frame
.text$mn:00009408
.text$mn:00009408 ; int __cdecl std::char_traits<char>::move(void *Dst, void *Src, size_t Size)
.text$mn:00009408                 public ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
.text$mn:00009408 ?move@?$char_traits@D@std@@SAPADPADPBDI@Z proc near
.text$mn:00009408                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+6Ap
.text$mn:00009408
.text$mn:00009408 var_4           = dword ptr -4
.text$mn:00009408 Dst             = dword ptr  8
.text$mn:00009408 Src             = dword ptr  0Ch
.text$mn:00009408 Size            = dword ptr  10h
.text$mn:00009408
.text$mn:00009408                 push    ebp
.text$mn:00009409                 mov     ebp, esp
.text$mn:0000940B                 push    ecx
.text$mn:0000940C                 cmp     [ebp+Size], 0
.text$mn:00009410                 jnz     short loc_941A
.text$mn:00009412                 mov     eax, [ebp+Dst]
.text$mn:00009415                 mov     [ebp+var_4], eax
.text$mn:00009418                 jmp     short loc_9431
.text$mn:0000941A ; ---------------------------------------------------------------------------
.text$mn:0000941A
.text$mn:0000941A loc_941A:                               ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+8j
.text$mn:0000941A                 mov     ecx, [ebp+Size]
.text$mn:0000941D                 push    ecx             ; Size
.text$mn:0000941E                 mov     edx, [ebp+Src]
.text$mn:00009421                 push    edx             ; Src
.text$mn:00009422                 mov     eax, [ebp+Dst]
.text$mn:00009425                 push    eax             ; Dst
.text$mn:00009426                 call    _memmove
.text$mn:0000942B                 add     esp, 0Ch
.text$mn:0000942E                 mov     [ebp+var_4], eax
.text$mn:00009431
.text$mn:00009431 loc_9431:                               ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+10j
.text$mn:00009431                 mov     eax, [ebp+var_4]
.text$mn:00009434                 mov     esp, ebp
.text$mn:00009436                 pop     ebp
.text$mn:00009437                 retn
.text$mn:00009437 ?move@?$char_traits@D@std@@SAPADPADPBDI@Z endp
.text$mn:00009437
.text$mn:00009437 _text$mn        ends
.text$mn:00009437
.text$mn:00009438 ; ===========================================================================
.text$mn:00009438
.text$mn:00009438 ; Segment type: Pure code
.text$mn:00009438 ; Segment permissions: Read/Execute
.text$mn:00009438 _text$mn        segment para public 'CODE' use32
.text$mn:00009438                 assume cs:_text$mn
.text$mn:00009438                 ;org 9438h
.text$mn:00009438 ; COMDAT (pick any)
.text$mn:00009438                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009438
.text$mn:00009438 ; =============== S U B R O U T I N E =======================================
.text$mn:00009438
.text$mn:00009438 ; Attributes: bp-based frame
.text$mn:00009438
.text$mn:00009438 ; const char *__thiscall std::_Generic_error_category::name(std::_Generic_error_category *__hidden this)
.text$mn:00009438                 public ?name@_Generic_error_category@std@@UBEPBDXZ
.text$mn:00009438 ?name@_Generic_error_category@std@@UBEPBDXZ proc near
.text$mn:00009438                                         ; DATA XREF: .rdata:0000AEE4o
.text$mn:00009438
.text$mn:00009438 var_4           = dword ptr -4
.text$mn:00009438
.text$mn:00009438                 push    ebp
.text$mn:00009439                 mov     ebp, esp
.text$mn:0000943B                 push    ecx
.text$mn:0000943C                 mov     [ebp+var_4], ecx
.text$mn:0000943F                 mov     eax, offset ??_C@_07DCLBNMLN@generic?$AA@ ; "generic"
.text$mn:00009444                 mov     esp, ebp
.text$mn:00009446                 pop     ebp
.text$mn:00009447                 retn
.text$mn:00009447 ?name@_Generic_error_category@std@@UBEPBDXZ endp
.text$mn:00009447
.text$mn:00009447 _text$mn        ends
.text$mn:00009447
.text$mn:00009448 ; ===========================================================================
.text$mn:00009448
.text$mn:00009448 ; Segment type: Pure code
.text$mn:00009448 ; Segment permissions: Read/Execute
.text$mn:00009448 _text$mn        segment para public 'CODE' use32
.text$mn:00009448                 assume cs:_text$mn
.text$mn:00009448                 ;org 9448h
.text$mn:00009448 ; COMDAT (pick any)
.text$mn:00009448                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009448
.text$mn:00009448 ; =============== S U B R O U T I N E =======================================
.text$mn:00009448
.text$mn:00009448 ; Attributes: bp-based frame
.text$mn:00009448
.text$mn:00009448 ; const char *__thiscall std::_Iostream_error_category::name(std::_Iostream_error_category *__hidden this)
.text$mn:00009448                 public ?name@_Iostream_error_category@std@@UBEPBDXZ
.text$mn:00009448 ?name@_Iostream_error_category@std@@UBEPBDXZ proc near
.text$mn:00009448                                         ; DATA XREF: .rdata:0000AF18o
.text$mn:00009448
.text$mn:00009448 var_4           = dword ptr -4
.text$mn:00009448
.text$mn:00009448                 push    ebp
.text$mn:00009449                 mov     ebp, esp
.text$mn:0000944B                 push    ecx
.text$mn:0000944C                 mov     [ebp+var_4], ecx
.text$mn:0000944F                 mov     eax, offset ??_C@_08LLGCOLLL@iostream?$AA@ ; "iostream"
.text$mn:00009454                 mov     esp, ebp
.text$mn:00009456                 pop     ebp
.text$mn:00009457                 retn
.text$mn:00009457 ?name@_Iostream_error_category@std@@UBEPBDXZ endp
.text$mn:00009457
.text$mn:00009457 _text$mn        ends
.text$mn:00009457
.text$mn:00009458 ; ===========================================================================
.text$mn:00009458
.text$mn:00009458 ; Segment type: Pure code
.text$mn:00009458 ; Segment permissions: Read/Execute
.text$mn:00009458 _text$mn        segment para public 'CODE' use32
.text$mn:00009458                 assume cs:_text$mn
.text$mn:00009458                 ;org 9458h
.text$mn:00009458 ; COMDAT (pick any)
.text$mn:00009458                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009458
.text$mn:00009458 ; =============== S U B R O U T I N E =======================================
.text$mn:00009458
.text$mn:00009458 ; Attributes: bp-based frame
.text$mn:00009458
.text$mn:00009458 ; const char *__thiscall std::_System_error_category::name(std::_System_error_category *__hidden this)
.text$mn:00009458                 public ?name@_System_error_category@std@@UBEPBDXZ
.text$mn:00009458 ?name@_System_error_category@std@@UBEPBDXZ proc near
.text$mn:00009458                                         ; DATA XREF: .rdata:0000AF58o
.text$mn:00009458
.text$mn:00009458 var_4           = dword ptr -4
.text$mn:00009458
.text$mn:00009458                 push    ebp
.text$mn:00009459                 mov     ebp, esp
.text$mn:0000945B                 push    ecx
.text$mn:0000945C                 mov     [ebp+var_4], ecx
.text$mn:0000945F                 mov     eax, offset ??_C@_06FHFOAHML@system?$AA@ ; "system"
.text$mn:00009464                 mov     esp, ebp
.text$mn:00009466                 pop     ebp
.text$mn:00009467                 retn
.text$mn:00009467 ?name@_System_error_category@std@@UBEPBDXZ endp
.text$mn:00009467
.text$mn:00009467 _text$mn        ends
.text$mn:00009467
.text$mn:00009468 ; ===========================================================================
.text$mn:00009468
.text$mn:00009468 ; Segment type: Pure code
.text$mn:00009468 ; Segment permissions: Read/Execute
.text$mn:00009468 _text$mn        segment para public 'CODE' use32
.text$mn:00009468                 assume cs:_text$mn
.text$mn:00009468                 ;org 9468h
.text$mn:00009468 ; COMDAT (pick any)
.text$mn:00009468                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009468
.text$mn:00009468 ; =============== S U B R O U T I N E =======================================
.text$mn:00009468
.text$mn:00009468 ; Attributes: bp-based frame
.text$mn:00009468
.text$mn:00009468 ; public: static struct std::pair<int const, struct Style> * __cdecl std::pointer_traits<struct std::pair<int const, struct Style> *>::pointer_to(struct std::pair<int const, struct Style> &)
.text$mn:00009468                 public ?pointer_to@?$pointer_traits@PAU?$pair@$$CBHUStyle@@@std@@@std@@SAPAU?$pair@$$CBHUStyle@@@2@AAU32@@Z
.text$mn:00009468 ?pointer_to@?$pointer_traits@PAU?$pair@$$CBHUStyle@@@std@@@std@@SAPAU?$pair@$$CBHUStyle@@@2@AAU32@@Z proc near
.text$mn:00009468                                         ; CODE XREF: std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>::operator->(void)+10p
.text$mn:00009468
.text$mn:00009468 arg_0           = dword ptr  8
.text$mn:00009468
.text$mn:00009468                 push    ebp
.text$mn:00009469                 mov     ebp, esp
.text$mn:0000946B                 mov     eax, [ebp+arg_0]
.text$mn:0000946E                 push    eax
.text$mn:0000946F                 call    ??$addressof@U?$pair@$$CBHUStyle@@@std@@@std@@YAPAU?$pair@$$CBHUStyle@@@0@AAU10@@Z ; std::addressof<std::pair<int const,Style>>(std::pair<int const,Style> &)
.text$mn:00009474                 add     esp, 4
.text$mn:00009477                 pop     ebp
.text$mn:00009478                 retn
.text$mn:00009478 ?pointer_to@?$pointer_traits@PAU?$pair@$$CBHUStyle@@@std@@@std@@SAPAU?$pair@$$CBHUStyle@@@2@AAU32@@Z endp
.text$mn:00009478
.text$mn:00009478 ; ---------------------------------------------------------------------------
.text$mn:00009479                 align 4
.text$mn:00009479 _text$mn        ends
.text$mn:00009479
.text$mn:0000947C ; ===========================================================================
.text$mn:0000947C
.text$mn:0000947C ; Segment type: Pure code
.text$mn:0000947C ; Segment permissions: Read/Execute
.text$mn:0000947C _text$mn        segment para public 'CODE' use32
.text$mn:0000947C                 assume cs:_text$mn
.text$mn:0000947C                 ;org 947Ch
.text$mn:0000947C ; COMDAT (pick any)
.text$mn:0000947C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000947C
.text$mn:0000947C ; =============== S U B R O U T I N E =======================================
.text$mn:0000947C
.text$mn:0000947C ; Attributes: bp-based frame
.text$mn:0000947C
.text$mn:0000947C ; public: static struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *> * __cdecl std::pointer_traits<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *> *>::pointer_to(struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *> &)
.text$mn:0000947C                 public ?pointer_to@?$pointer_traits@PAU?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@SAPAU?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@2@AAU32@@Z
.text$mn:0000947C ?pointer_to@?$pointer_traits@PAU?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@SAPAU?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@2@AAU32@@Z proc near
.text$mn:0000947C                                         ; CODE XREF: std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::operator->(void)+10p
.text$mn:0000947C
.text$mn:0000947C arg_0           = dword ptr  8
.text$mn:0000947C
.text$mn:0000947C                 push    ebp
.text$mn:0000947D                 mov     ebp, esp
.text$mn:0000947F                 mov     eax, [ebp+arg_0]
.text$mn:00009482                 push    eax
.text$mn:00009483                 call    ??$addressof@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@YAPAU?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@0@AAU10@@Z ; std::addressof<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>(std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *> &)
.text$mn:00009488                 add     esp, 4
.text$mn:0000948B                 pop     ebp
.text$mn:0000948C                 retn
.text$mn:0000948C ?pointer_to@?$pointer_traits@PAU?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@SAPAU?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@2@AAU32@@Z endp
.text$mn:0000948C
.text$mn:0000948C ; ---------------------------------------------------------------------------
.text$mn:0000948D                 align 10h
.text$mn:0000948D _text$mn        ends
.text$mn:0000948D
.text$mn:00009490 ; ===========================================================================
.text$mn:00009490
.text$mn:00009490 ; Segment type: Pure code
.text$mn:00009490 ; Segment permissions: Read/Execute
.text$mn:00009490 _text$mn        segment para public 'CODE' use32
.text$mn:00009490                 assume cs:_text$mn
.text$mn:00009490                 ;org 9490h
.text$mn:00009490 ; COMDAT (pick any)
.text$mn:00009490                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009490
.text$mn:00009490 ; =============== S U B R O U T I N E =======================================
.text$mn:00009490
.text$mn:00009490 ; Attributes: bp-based frame
.text$mn:00009490
.text$mn:00009490 ; public: void __thiscall std::vector<class ScintillaEditView *, class std::allocator<class ScintillaEditView *>>::push_back(class ScintillaEditView * const &)
.text$mn:00009490                 public ?push_back@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@QAEXABQAVScintillaEditView@@@Z
.text$mn:00009490 ?push_back@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@QAEXABQAVScintillaEditView@@@Z proc near
.text$mn:00009490                                         ; CODE XREF: ScintillaCtrls::createSintilla(HWND__ *)+94p
.text$mn:00009490
.text$mn:00009490 var_C           = dword ptr -0Ch
.text$mn:00009490 var_8           = dword ptr -8
.text$mn:00009490 var_2           = byte ptr -2
.text$mn:00009490 var_1           = byte ptr -1
.text$mn:00009490 arg_0           = dword ptr  8
.text$mn:00009490
.text$mn:00009490                 push    ebp
.text$mn:00009491                 mov     ebp, esp
.text$mn:00009493                 sub     esp, 0Ch
.text$mn:00009496                 mov     [ebp+var_8], ecx
.text$mn:00009499                 mov     eax, [ebp+arg_0]
.text$mn:0000949C                 push    eax
.text$mn:0000949D                 call    ??$addressof@QAVScintillaEditView@@@std@@YAPBQAVScintillaEditView@@ABQAV1@@Z ; std::addressof<ScintillaEditView * const>(ScintillaEditView * const &)
.text$mn:000094A2                 add     esp, 4
.text$mn:000094A5                 push    eax
.text$mn:000094A6                 mov     ecx, [ebp+var_8]
.text$mn:000094A9                 call    ?_Inside@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@IBE_NPBQAVScintillaEditView@@@Z ; std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::_Inside(ScintillaEditView * const *)
.text$mn:000094AE                 movzx   ecx, al
.text$mn:000094B1                 test    ecx, ecx
.text$mn:000094B3                 jz      short loc_9533
.text$mn:000094B5                 mov     edx, [ebp+arg_0]
.text$mn:000094B8                 push    edx
.text$mn:000094B9                 call    ??$addressof@QAVScintillaEditView@@@std@@YAPBQAVScintillaEditView@@ABQAV1@@Z ; std::addressof<ScintillaEditView * const>(ScintillaEditView * const &)
.text$mn:000094BE                 add     esp, 4
.text$mn:000094C1                 mov     ecx, [ebp+var_8]
.text$mn:000094C4                 sub     eax, [ecx+4]
.text$mn:000094C7                 sar     eax, 2
.text$mn:000094CA                 mov     [ebp+var_C], eax
.text$mn:000094CD                 mov     edx, [ebp+var_8]
.text$mn:000094D0                 mov     eax, [ebp+var_8]
.text$mn:000094D3                 mov     ecx, [edx+8]
.text$mn:000094D6                 cmp     ecx, [eax+0Ch]
.text$mn:000094D9                 jnz     short loc_94E5
.text$mn:000094DB                 push    1
.text$mn:000094DD                 mov     ecx, [ebp+var_8]
.text$mn:000094E0                 call    ?_Reserve@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@IAEXI@Z ; std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::_Reserve(uint)
.text$mn:000094E5
.text$mn:000094E5 loc_94E5:                               ; CODE XREF: std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::push_back(ScintillaEditView * const &)+49j
.text$mn:000094E5                 mov     edx, [ebp+var_8]
.text$mn:000094E8                 mov     eax, [edx+8]
.text$mn:000094EB                 push    eax
.text$mn:000094EC                 mov     ecx, [ebp+var_8]
.text$mn:000094EF                 mov     edx, [ecx+8]
.text$mn:000094F2                 push    edx
.text$mn:000094F3                 mov     ecx, [ebp+var_8]
.text$mn:000094F6                 call    ?_Orphan_range@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@IBEXPAPAVScintillaEditView@@0@Z ; std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::_Orphan_range(ScintillaEditView * *,ScintillaEditView * *)
.text$mn:000094FB                 mov     eax, [ebp+var_8]
.text$mn:000094FE                 mov     ecx, [eax+4]
.text$mn:00009501                 mov     edx, [ebp+var_C]
.text$mn:00009504                 lea     eax, [ecx+edx*4]
.text$mn:00009507                 push    eax             ; int
.text$mn:00009508                 mov     ecx, [ebp+var_8]
.text$mn:0000950B                 mov     edx, [ecx+8]
.text$mn:0000950E                 push    edx             ; void *
.text$mn:0000950F                 lea     eax, [ebp+var_1]
.text$mn:00009512                 push    eax
.text$mn:00009513                 mov     ecx, [ebp+var_8]
.text$mn:00009516                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVScintillaEditView@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<ScintillaEditView *,std::allocator<ScintillaEditView *>>>::_Getal(void)
.text$mn:0000951B                 mov     ecx, eax
.text$mn:0000951D                 call    ??$construct@PAVScintillaEditView@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVScintillaEditView@@@std@@@std@@QAEXPAPAVScintillaEditView@@AAPAV2@@Z ; std::_Wrap_alloc<std::allocator<ScintillaEditView *>>::construct<ScintillaEditView *,ScintillaEditView * &>(ScintillaEditView * *,ScintillaEditView * &)
.text$mn:00009522                 mov     ecx, [ebp+var_8]
.text$mn:00009525                 mov     edx, [ecx+8]
.text$mn:00009528                 add     edx, 4
.text$mn:0000952B                 mov     eax, [ebp+var_8]
.text$mn:0000952E                 mov     [eax+8], edx
.text$mn:00009531                 jmp     short loc_958E
.text$mn:00009533 ; ---------------------------------------------------------------------------
.text$mn:00009533
.text$mn:00009533 loc_9533:                               ; CODE XREF: std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::push_back(ScintillaEditView * const &)+23j
.text$mn:00009533                 mov     ecx, [ebp+var_8]
.text$mn:00009536                 mov     edx, [ebp+var_8]
.text$mn:00009539                 mov     eax, [ecx+8]
.text$mn:0000953C                 cmp     eax, [edx+0Ch]
.text$mn:0000953F                 jnz     short loc_954B
.text$mn:00009541                 push    1
.text$mn:00009543                 mov     ecx, [ebp+var_8]
.text$mn:00009546                 call    ?_Reserve@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@IAEXI@Z ; std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::_Reserve(uint)
.text$mn:0000954B
.text$mn:0000954B loc_954B:                               ; CODE XREF: std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::push_back(ScintillaEditView * const &)+AFj
.text$mn:0000954B                 mov     ecx, [ebp+var_8]
.text$mn:0000954E                 mov     edx, [ecx+8]
.text$mn:00009551                 push    edx
.text$mn:00009552                 mov     eax, [ebp+var_8]
.text$mn:00009555                 mov     ecx, [eax+8]
.text$mn:00009558                 push    ecx
.text$mn:00009559                 mov     ecx, [ebp+var_8]
.text$mn:0000955C                 call    ?_Orphan_range@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@IBEXPAPAVScintillaEditView@@0@Z ; std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::_Orphan_range(ScintillaEditView * *,ScintillaEditView * *)
.text$mn:00009561                 mov     edx, [ebp+arg_0]
.text$mn:00009564                 push    edx             ; int
.text$mn:00009565                 mov     eax, [ebp+var_8]
.text$mn:00009568                 mov     ecx, [eax+8]
.text$mn:0000956B                 push    ecx             ; void *
.text$mn:0000956C                 lea     edx, [ebp+var_2]
.text$mn:0000956F                 push    edx
.text$mn:00009570                 mov     ecx, [ebp+var_8]
.text$mn:00009573                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVScintillaEditView@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<ScintillaEditView *,std::allocator<ScintillaEditView *>>>::_Getal(void)
.text$mn:00009578                 mov     ecx, eax
.text$mn:0000957A                 call    ??$construct@PAVScintillaEditView@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVScintillaEditView@@@std@@@std@@QAEXPAPAVScintillaEditView@@ABQAV2@@Z ; std::_Wrap_alloc<std::allocator<ScintillaEditView *>>::construct<ScintillaEditView *,ScintillaEditView * const &>(ScintillaEditView * *,ScintillaEditView * const &)
.text$mn:0000957F                 mov     eax, [ebp+var_8]
.text$mn:00009582                 mov     ecx, [eax+8]
.text$mn:00009585                 add     ecx, 4
.text$mn:00009588                 mov     edx, [ebp+var_8]
.text$mn:0000958B                 mov     [edx+8], ecx
.text$mn:0000958E
.text$mn:0000958E loc_958E:                               ; CODE XREF: std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::push_back(ScintillaEditView * const &)+A1j
.text$mn:0000958E                 mov     esp, ebp
.text$mn:00009590                 pop     ebp
.text$mn:00009591                 retn    4
.text$mn:00009591 ?push_back@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@QAEXABQAVScintillaEditView@@@Z endp
.text$mn:00009591
.text$mn:00009591 _text$mn        ends
.text$mn:00009591
.text$mn:00009594 ; ===========================================================================
.text$mn:00009594
.text$mn:00009594 ; Segment type: Pure code
.text$mn:00009594 ; Segment permissions: Read/Execute
.text$mn:00009594 _text$mn        segment para public 'CODE' use32
.text$mn:00009594                 assume cs:_text$mn
.text$mn:00009594                 ;org 9594h
.text$mn:00009594 ; COMDAT (pick any)
.text$mn:00009594                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009594
.text$mn:00009594 ; =============== S U B R O U T I N E =======================================
.text$mn:00009594
.text$mn:00009594 ; Attributes: bp-based frame
.text$mn:00009594
.text$mn:00009594 ; void __thiscall Window::reSizeTo(Window *this, struct tagRECT *)
.text$mn:00009594                 public ?reSizeTo@Window@@UAEXAAUtagRECT@@@Z
.text$mn:00009594 ?reSizeTo@Window@@UAEXAAUtagRECT@@@Z proc near
.text$mn:00009594                                         ; DATA XREF: .rdata:0000AF9Co
.text$mn:00009594                                         ; .rdata:0000AFD0o
.text$mn:00009594
.text$mn:00009594 var_4           = dword ptr -4
.text$mn:00009594 arg_0           = dword ptr  8
.text$mn:00009594
.text$mn:00009594                 push    ebp
.text$mn:00009595                 mov     ebp, esp
.text$mn:00009597                 push    ecx
.text$mn:00009598                 mov     [ebp+var_4], ecx
.text$mn:0000959B                 push    1               ; bRepaint
.text$mn:0000959D                 mov     eax, [ebp+arg_0]
.text$mn:000095A0                 mov     ecx, [eax+0Ch]
.text$mn:000095A3                 push    ecx             ; nHeight
.text$mn:000095A4                 mov     edx, [ebp+arg_0]
.text$mn:000095A7                 mov     eax, [edx+8]
.text$mn:000095AA                 push    eax             ; nWidth
.text$mn:000095AB                 mov     ecx, [ebp+arg_0]
.text$mn:000095AE                 mov     edx, [ecx+4]
.text$mn:000095B1                 push    edx             ; Y
.text$mn:000095B2                 mov     eax, [ebp+arg_0]
.text$mn:000095B5                 mov     ecx, [eax]
.text$mn:000095B7                 push    ecx             ; X
.text$mn:000095B8                 mov     edx, [ebp+var_4]
.text$mn:000095BB                 mov     eax, [edx+0Ch]
.text$mn:000095BE                 push    eax             ; hWnd
.text$mn:000095BF                 call    dword ptr ds:__imp__MoveWindow@24 ; MoveWindow(x,x,x,x,x,x)
.text$mn:000095C5                 push    0
.text$mn:000095C7                 mov     ecx, [ebp+var_4]
.text$mn:000095CA                 mov     edx, [ecx]
.text$mn:000095CC                 mov     ecx, [ebp+var_4]
.text$mn:000095CF                 mov     eax, [edx+18h]
.text$mn:000095D2                 call    eax
.text$mn:000095D4                 mov     esp, ebp
.text$mn:000095D6                 pop     ebp
.text$mn:000095D7                 retn    4
.text$mn:000095D7 ?reSizeTo@Window@@UAEXAAUtagRECT@@@Z endp
.text$mn:000095D7
.text$mn:000095D7 ; ---------------------------------------------------------------------------
.text$mn:000095DA                 align 4
.text$mn:000095DA _text$mn        ends
.text$mn:000095DA
.text$mn:000095DC ; ===========================================================================
.text$mn:000095DC
.text$mn:000095DC ; Segment type: Pure code
.text$mn:000095DC ; Segment permissions: Read/Execute
.text$mn:000095DC _text$mn        segment para public 'CODE' use32
.text$mn:000095DC                 assume cs:_text$mn
.text$mn:000095DC                 ;org 95DCh
.text$mn:000095DC ; COMDAT (pick any)
.text$mn:000095DC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000095DC
.text$mn:000095DC ; =============== S U B R O U T I N E =======================================
.text$mn:000095DC
.text$mn:000095DC ; Attributes: bp-based frame
.text$mn:000095DC
.text$mn:000095DC ; void __thiscall Window::reSizeToWH(Window *this, struct tagRECT *)
.text$mn:000095DC                 public ?reSizeToWH@Window@@UAEXAAUtagRECT@@@Z
.text$mn:000095DC ?reSizeToWH@Window@@UAEXAAUtagRECT@@@Z proc near
.text$mn:000095DC                                         ; DATA XREF: .rdata:0000AFA0o
.text$mn:000095DC                                         ; .rdata:0000AFD4o
.text$mn:000095DC
.text$mn:000095DC var_4           = dword ptr -4
.text$mn:000095DC arg_0           = dword ptr  8
.text$mn:000095DC
.text$mn:000095DC                 push    ebp
.text$mn:000095DD                 mov     ebp, esp
.text$mn:000095DF                 push    ecx
.text$mn:000095E0                 mov     [ebp+var_4], ecx
.text$mn:000095E3                 push    1               ; bRepaint
.text$mn:000095E5                 mov     eax, [ebp+arg_0]
.text$mn:000095E8                 mov     ecx, [ebp+arg_0]
.text$mn:000095EB                 mov     edx, [eax+0Ch]
.text$mn:000095EE                 sub     edx, [ecx+4]
.text$mn:000095F1                 push    edx             ; nHeight
.text$mn:000095F2                 mov     eax, [ebp+arg_0]
.text$mn:000095F5                 mov     ecx, [ebp+arg_0]
.text$mn:000095F8                 mov     edx, [eax+8]
.text$mn:000095FB                 sub     edx, [ecx]
.text$mn:000095FD                 push    edx             ; nWidth
.text$mn:000095FE                 mov     eax, [ebp+arg_0]
.text$mn:00009601                 mov     ecx, [eax+4]
.text$mn:00009604                 push    ecx             ; Y
.text$mn:00009605                 mov     edx, [ebp+arg_0]
.text$mn:00009608                 mov     eax, [edx]
.text$mn:0000960A                 push    eax             ; X
.text$mn:0000960B                 mov     ecx, [ebp+var_4]
.text$mn:0000960E                 mov     edx, [ecx+0Ch]
.text$mn:00009611                 push    edx             ; hWnd
.text$mn:00009612                 call    dword ptr ds:__imp__MoveWindow@24 ; MoveWindow(x,x,x,x,x,x)
.text$mn:00009618                 push    0
.text$mn:0000961A                 mov     eax, [ebp+var_4]
.text$mn:0000961D                 mov     edx, [eax]
.text$mn:0000961F                 mov     ecx, [ebp+var_4]
.text$mn:00009622                 mov     eax, [edx+18h]
.text$mn:00009625                 call    eax
.text$mn:00009627                 mov     esp, ebp
.text$mn:00009629                 pop     ebp
.text$mn:0000962A                 retn    4
.text$mn:0000962A ?reSizeToWH@Window@@UAEXAAUtagRECT@@@Z endp
.text$mn:0000962A
.text$mn:0000962A ; ---------------------------------------------------------------------------
.text$mn:0000962D                 align 10h
.text$mn:0000962D _text$mn        ends
.text$mn:0000962D
.text$mn:00009630 ; ===========================================================================
.text$mn:00009630
.text$mn:00009630 ; Segment type: Pure code
.text$mn:00009630 ; Segment permissions: Read/Execute
.text$mn:00009630 _text$mn        segment para public 'CODE' use32
.text$mn:00009630                 assume cs:_text$mn
.text$mn:00009630                 ;org 9630h
.text$mn:00009630 ; COMDAT (pick any)
.text$mn:00009630                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009630
.text$mn:00009630 ; =============== S U B R O U T I N E =======================================
.text$mn:00009630
.text$mn:00009630 ; Attributes: bp-based frame
.text$mn:00009630
.text$mn:00009630 ; void __thiscall Window::redraw(Window *this, bool)
.text$mn:00009630                 public ?redraw@Window@@UBEX_N@Z
.text$mn:00009630 ?redraw@Window@@UBEX_N@Z proc near      ; DATA XREF: .rdata:0000AFA4o
.text$mn:00009630                                         ; .rdata:0000AFD8o
.text$mn:00009630
.text$mn:00009630 var_4           = dword ptr -4
.text$mn:00009630 arg_0           = byte ptr  8
.text$mn:00009630
.text$mn:00009630                 push    ebp
.text$mn:00009631                 mov     ebp, esp
.text$mn:00009633                 push    ecx
.text$mn:00009634                 mov     [ebp+var_4], ecx
.text$mn:00009637                 push    1               ; bErase
.text$mn:00009639                 push    0               ; lpRect
.text$mn:0000963B                 mov     eax, [ebp+var_4]
.text$mn:0000963E                 mov     ecx, [eax+0Ch]
.text$mn:00009641                 push    ecx             ; hWnd
.text$mn:00009642                 call    dword ptr ds:__imp__InvalidateRect@12 ; InvalidateRect(x,x,x)
.text$mn:00009648                 movzx   edx, [ebp+arg_0]
.text$mn:0000964C                 test    edx, edx
.text$mn:0000964E                 jz      short loc_965D
.text$mn:00009650                 mov     eax, [ebp+var_4]
.text$mn:00009653                 mov     ecx, [eax+0Ch]
.text$mn:00009656                 push    ecx             ; hWnd
.text$mn:00009657                 call    dword ptr ds:__imp__UpdateWindow@4 ; UpdateWindow(x)
.text$mn:0000965D
.text$mn:0000965D loc_965D:                               ; CODE XREF: Window::redraw(bool)+1Ej
.text$mn:0000965D                 mov     esp, ebp
.text$mn:0000965F                 pop     ebp
.text$mn:00009660                 retn    4
.text$mn:00009660 ?redraw@Window@@UBEX_N@Z endp
.text$mn:00009660
.text$mn:00009660 ; ---------------------------------------------------------------------------
.text$mn:00009663                 align 4
.text$mn:00009663 _text$mn        ends
.text$mn:00009663
.text$mn:00009664 ; ===========================================================================
.text$mn:00009664
.text$mn:00009664 ; Segment type: Pure code
.text$mn:00009664 ; Segment permissions: Read/Execute
.text$mn:00009664 _text$mn        segment para public 'CODE' use32
.text$mn:00009664                 assume cs:_text$mn
.text$mn:00009664                 ;org 9664h
.text$mn:00009664 ; COMDAT (pick any)
.text$mn:00009664                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009664
.text$mn:00009664 ; =============== S U B R O U T I N E =======================================
.text$mn:00009664
.text$mn:00009664 ; Attributes: bp-based frame
.text$mn:00009664
.text$mn:00009664 ; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::size(void)const
.text$mn:00009664                 public ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
.text$mn:00009664 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
.text$mn:00009664                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+Cp
.text$mn:00009664                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+21p
.text$mn:00009664
.text$mn:00009664 var_4           = dword ptr -4
.text$mn:00009664
.text$mn:00009664                 push    ebp
.text$mn:00009665                 mov     ebp, esp
.text$mn:00009667                 push    ecx
.text$mn:00009668                 mov     [ebp+var_4], ecx
.text$mn:0000966B                 mov     eax, [ebp+var_4]
.text$mn:0000966E                 mov     eax, [eax+14h]
.text$mn:00009671                 mov     esp, ebp
.text$mn:00009673                 pop     ebp
.text$mn:00009674                 retn
.text$mn:00009674 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp
.text$mn:00009674
.text$mn:00009674 ; ---------------------------------------------------------------------------
.text$mn:00009675                 align 4
.text$mn:00009675 _text$mn        ends
.text$mn:00009675
.text$mn:00009678 ; ===========================================================================
.text$mn:00009678
.text$mn:00009678 ; Segment type: Pure code
.text$mn:00009678 ; Segment permissions: Read/Execute
.text$mn:00009678 _text$mn        segment para public 'CODE' use32
.text$mn:00009678                 assume cs:_text$mn
.text$mn:00009678                 ;org 9678h
.text$mn:00009678 ; COMDAT (pick any)
.text$mn:00009678                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009678
.text$mn:00009678 ; =============== S U B R O U T I N E =======================================
.text$mn:00009678
.text$mn:00009678 ; Attributes: bp-based frame
.text$mn:00009678
.text$mn:00009678 ; public: unsigned int __thiscall std::vector<class ScintillaEditView *, class std::allocator<class ScintillaEditView *>>::size(void)const
.text$mn:00009678                 public ?size@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@QBEIXZ
.text$mn:00009678 ?size@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@QBEIXZ proc near
.text$mn:00009678                                         ; CODE XREF: ScintillaCtrls::getScintillaEditViewFrom(HWND__ *)+21p
.text$mn:00009678                                         ; ScintillaCtrls::destroy(void)+13p ...
.text$mn:00009678
.text$mn:00009678 var_4           = dword ptr -4
.text$mn:00009678
.text$mn:00009678                 push    ebp
.text$mn:00009679                 mov     ebp, esp
.text$mn:0000967B                 push    ecx
.text$mn:0000967C                 mov     [ebp+var_4], ecx
.text$mn:0000967F                 mov     eax, [ebp+var_4]
.text$mn:00009682                 mov     ecx, [ebp+var_4]
.text$mn:00009685                 mov     eax, [eax+8]
.text$mn:00009688                 sub     eax, [ecx+4]
.text$mn:0000968B                 sar     eax, 2
.text$mn:0000968E                 mov     esp, ebp
.text$mn:00009690                 pop     ebp
.text$mn:00009691                 retn
.text$mn:00009691 ?size@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@QBEIXZ endp
.text$mn:00009691
.text$mn:00009691 ; ---------------------------------------------------------------------------
.text$mn:00009692                 align 4
.text$mn:00009692 _text$mn        ends
.text$mn:00009692
.text$mn:00009694 ; ===========================================================================
.text$mn:00009694
.text$mn:00009694 ; Segment type: Pure code
.text$mn:00009694 ; Segment permissions: Read/Execute
.text$mn:00009694 _text$mn        segment para public 'CODE' use32
.text$mn:00009694                 assume cs:_text$mn
.text$mn:00009694                 ;org 9694h
.text$mn:00009694 ; COMDAT (pick any)
.text$mn:00009694                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009694
.text$mn:00009694 ; =============== S U B R O U T I N E =======================================
.text$mn:00009694
.text$mn:00009694 ; Attributes: bp-based frame
.text$mn:00009694
.text$mn:00009694 ; public: unsigned int __thiscall std::vector<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>, struct std::_Wrap_alloc<class std::allocator<class std::_List_unchecked_iterator<class std::_List_val<struct std::_List_simple_types<struct std::pair<class Buffer * const, class std::unordered_map<int, struct Style, struct std::hash<int>, struct std::equal_to<int>, class std::allocator<struct std::pair<int const, struct Style>>> *>>>>>>>::size(void)const
.text$mn:00009694                 public ?size@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QBEIXZ
.text$mn:00009694 ?size@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QBEIXZ proc near
.text$mn:00009694                                         ; CODE XREF: ?_Insert_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CB
.text$mn:00009694                                         ; ?_Insert_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@s ...
.text$mn:00009694
.text$mn:00009694 var_4           = dword ptr -4
.text$mn:00009694
.text$mn:00009694                 push    ebp
.text$mn:00009695                 mov     ebp, esp
.text$mn:00009697                 push    ecx
.text$mn:00009698                 mov     [ebp+var_4], ecx
.text$mn:0000969B                 mov     eax, [ebp+var_4]
.text$mn:0000969E                 mov     ecx, [ebp+var_4]
.text$mn:000096A1                 mov     eax, [eax+8]
.text$mn:000096A4                 sub     eax, [ecx+4]
.text$mn:000096A7                 sar     eax, 2
.text$mn:000096AA                 mov     esp, ebp
.text$mn:000096AC                 pop     ebp
.text$mn:000096AD                 retn
.text$mn:000096AD ?size@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QBEIXZ endp
.text$mn:000096AD
.text$mn:000096AD ; ---------------------------------------------------------------------------
.text$mn:000096AE                 align 10h
.text$mn:000096AE _text$mn        ends
.text$mn:000096AE
.text$mn:000096B0 ; ===========================================================================
.text$mn:000096B0
.text$mn:000096B0 ; Segment type: Pure code
.text$mn:000096B0 ; Segment permissions: Read/Execute
.text$mn:000096B0 _text$mn        segment para public 'CODE' use32
.text$mn:000096B0                 assume cs:_text$mn
.text$mn:000096B0                 ;org 96B0h
.text$mn:000096B0 ; COMDAT (pick any)
.text$mn:000096B0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000096B0
.text$mn:000096B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000096B0
.text$mn:000096B0 ; Attributes: bp-based frame
.text$mn:000096B0
.text$mn:000096B0 ; const struct std::error_category *__cdecl std::system_category()
.text$mn:000096B0                 public ?system_category@std@@YAABVerror_category@1@XZ
.text$mn:000096B0 ?system_category@std@@YAABVerror_category@1@XZ proc near
.text$mn:000096B0                                         ; CODE XREF: std::_System_error_category::default_error_condition(int):loc_88B4p
.text$mn:000096B0                 push    ebp
.text$mn:000096B1                 mov     ebp, esp
.text$mn:000096B3                 mov     eax, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_System_error_category std::_Error_objects<int>::_System_object
.text$mn:000096B8                 pop     ebp
.text$mn:000096B9                 retn
.text$mn:000096B9 ?system_category@std@@YAABVerror_category@1@XZ endp
.text$mn:000096B9
.text$mn:000096B9 ; ---------------------------------------------------------------------------
.text$mn:000096BA                 align 4
.text$mn:000096BA _text$mn        ends
.text$mn:000096BA
.text$mn:000096BC ; ===========================================================================
.text$mn:000096BC
.text$mn:000096BC ; Segment type: Pure code
.text$mn:000096BC ; Segment permissions: Read/Execute
.text$mn:000096BC _text$mn        segment para public 'CODE' use32
.text$mn:000096BC                 assume cs:_text$mn
.text$mn:000096BC                 ;org 96BCh
.text$mn:000096BC ; COMDAT (pick any)
.text$mn:000096BC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000096BC
.text$mn:000096BC ; =============== S U B R O U T I N E =======================================
.text$mn:000096BC
.text$mn:000096BC ; Attributes: bp-based frame
.text$mn:000096BC
.text$mn:000096BC ; int __thiscall std::error_code::value(std::error_code *__hidden this)
.text$mn:000096BC                 public ?value@error_code@std@@QBEHXZ
.text$mn:000096BC ?value@error_code@std@@QBEHXZ proc near ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+24p
.text$mn:000096BC
.text$mn:000096BC var_4           = dword ptr -4
.text$mn:000096BC
.text$mn:000096BC                 push    ebp
.text$mn:000096BD                 mov     ebp, esp
.text$mn:000096BF                 push    ecx
.text$mn:000096C0                 mov     [ebp+var_4], ecx
.text$mn:000096C3                 mov     eax, [ebp+var_4]
.text$mn:000096C6                 mov     eax, [eax]
.text$mn:000096C8                 mov     esp, ebp
.text$mn:000096CA                 pop     ebp
.text$mn:000096CB                 retn
.text$mn:000096CB ?value@error_code@std@@QBEHXZ endp
.text$mn:000096CB
.text$mn:000096CB _text$mn        ends
.text$mn:000096CB
.text$mn:000096CC ; ===========================================================================
.text$mn:000096CC
.text$mn:000096CC ; Segment type: Pure code
.text$mn:000096CC ; Segment permissions: Read/Execute
.text$mn:000096CC _text$mn        segment para public 'CODE' use32
.text$mn:000096CC                 assume cs:_text$mn
.text$mn:000096CC                 ;org 96CCh
.text$mn:000096CC ; COMDAT (pick any)
.text$mn:000096CC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000096CC
.text$mn:000096CC ; =============== S U B R O U T I N E =======================================
.text$mn:000096CC
.text$mn:000096CC ; Attributes: bp-based frame
.text$mn:000096CC
.text$mn:000096CC ; int __thiscall std::error_condition::value(std::error_condition *__hidden this)
.text$mn:000096CC                 public ?value@error_condition@std@@QBEHXZ
.text$mn:000096CC ?value@error_condition@std@@QBEHXZ proc near
.text$mn:000096CC                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+2Cp
.text$mn:000096CC                                         ; std::error_condition::operator==(std::error_condition const &)+36p
.text$mn:000096CC
.text$mn:000096CC var_4           = dword ptr -4
.text$mn:000096CC
.text$mn:000096CC                 push    ebp
.text$mn:000096CD                 mov     ebp, esp
.text$mn:000096CF                 push    ecx
.text$mn:000096D0                 mov     [ebp+var_4], ecx
.text$mn:000096D3                 mov     eax, [ebp+var_4]
.text$mn:000096D6                 mov     eax, [eax]
.text$mn:000096D8                 mov     esp, ebp
.text$mn:000096DA                 pop     ebp
.text$mn:000096DB                 retn
.text$mn:000096DB ?value@error_condition@std@@QBEHXZ endp
.text$mn:000096DB
.text$mn:000096DB _text$mn        ends
.text$mn:000096DB
.text$mn:000096DC ; ===========================================================================
.text$mn:000096DC
.text$mn:000096DC ; Segment type: Pure code
.text$mn:000096DC ; Segment permissions: Read/Execute
.text$mn:000096DC _text$mn        segment para public 'CODE' use32
.text$mn:000096DC                 assume cs:_text$mn
.text$mn:000096DC                 ;org 96DCh
.text$mn:000096DC ; COMDAT (pick any)
.text$mn:000096DC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000096DC
.text$mn:000096DC ; =============== S U B R O U T I N E =======================================
.text$mn:000096DC
.text$mn:000096DC ; Attributes: bp-based frame
.text$mn:000096DC
.text$mn:000096DC                 public _hypot
.text$mn:000096DC _hypot          proc near
.text$mn:000096DC
.text$mn:000096DC var_10          = qword ptr -10h
.text$mn:000096DC var_8           = qword ptr -8
.text$mn:000096DC arg_0           = qword ptr  8
.text$mn:000096DC arg_8           = qword ptr  10h
.text$mn:000096DC
.text$mn:000096DC                 push    ebp
.text$mn:000096DD                 mov     ebp, esp
.text$mn:000096DF                 sub     esp, 8
.text$mn:000096E2                 movsd   xmm0, [ebp+arg_8]
.text$mn:000096E7                 movsd   [esp+8+var_8], xmm0
.text$mn:000096EC                 sub     esp, 8
.text$mn:000096EF                 movsd   xmm0, [ebp+arg_0]
.text$mn:000096F4                 movsd   [esp+10h+var_10], xmm0
.text$mn:000096F9                 call    __hypot
.text$mn:000096FE                 add     esp, 10h
.text$mn:00009701                 pop     ebp
.text$mn:00009702                 retn
.text$mn:00009702 _hypot          endp
.text$mn:00009702
.text$mn:00009702 ; ---------------------------------------------------------------------------
.text$mn:00009703                 align 4
.text$mn:00009703 _text$mn        ends
.text$mn:00009703
.text$mn:00009704 ; ===========================================================================
.text$mn:00009704
.text$mn:00009704 ; Segment type: Pure code
.text$mn:00009704 ; Segment permissions: Read/Execute
.text$mn:00009704 _text$mn        segment para public 'CODE' use32
.text$mn:00009704                 assume cs:_text$mn
.text$mn:00009704                 ;org 9704h
.text$mn:00009704 ; COMDAT (pick any)
.text$mn:00009704                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009704
.text$mn:00009704 ; =============== S U B R O U T I N E =======================================
.text$mn:00009704
.text$mn:00009704 ; Attributes: bp-based frame
.text$mn:00009704
.text$mn:00009704 ; int __cdecl wmemcpy(void *Dst, void *Src, int)
.text$mn:00009704                 public _wmemcpy
.text$mn:00009704 _wmemcpy        proc near               ; CODE XREF: std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)+1Ep
.text$mn:00009704
.text$mn:00009704 Dst             = dword ptr  8
.text$mn:00009704 Src             = dword ptr  0Ch
.text$mn:00009704 arg_8           = dword ptr  10h
.text$mn:00009704
.text$mn:00009704                 push    ebp
.text$mn:00009705                 mov     ebp, esp
.text$mn:00009707                 mov     eax, [ebp+arg_8]
.text$mn:0000970A                 shl     eax, 1
.text$mn:0000970C                 push    eax             ; Size
.text$mn:0000970D                 mov     ecx, [ebp+Src]
.text$mn:00009710                 push    ecx             ; Src
.text$mn:00009711                 mov     edx, [ebp+Dst]
.text$mn:00009714                 push    edx             ; Dst
.text$mn:00009715                 call    _memcpy
.text$mn:0000971A                 add     esp, 0Ch
.text$mn:0000971D                 pop     ebp
.text$mn:0000971E                 retn
.text$mn:0000971E _wmemcpy        endp
.text$mn:0000971E
.text$mn:0000971E ; ---------------------------------------------------------------------------
.text$mn:0000971F                 align 10h
.text$mn:0000971F _text$mn        ends
.text$mn:0000971F
.xdata$x:00009720 ; ===========================================================================
.xdata$x:00009720
.xdata$x:00009720 ; Segment type: Pure data
.xdata$x:00009720 ; Segment permissions: Read
.xdata$x:00009720 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009720                 assume cs:_xdata$x
.xdata$x:00009720                 ;org 9720h
.xdata$x:00009720 ; COMDAT (pick associative to section at 7208)
.xdata$x:00009720 __unwindtable$?_Orphan_all@_Container_base12@std@@QAEXXZ db 0FFh
.xdata$x:00009720                                         ; DATA XREF: .xdata$x:00009730o
.xdata$x:00009721                 db 0FFh
.xdata$x:00009722                 db 0FFh
.xdata$x:00009723                 db 0FFh
.xdata$x:00009724                 dd offset __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0
.xdata$x:00009728 __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ db  22h ; "
.xdata$x:00009728                                         ; DATA XREF: __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ+11o
.xdata$x:00009729                 db    5
.xdata$x:0000972A                 db  93h ; ô
.xdata$x:0000972B                 db  19h
.xdata$x:0000972C                 db    1
.xdata$x:0000972D                 db    0
.xdata$x:0000972E                 db    0
.xdata$x:0000972F                 db    0
.xdata$x:00009730                 dd offset __unwindtable$?_Orphan_all@_Container_base12@std@@QAEXXZ
.xdata$x:00009734                 db    0
.xdata$x:00009735                 db    0
.xdata$x:00009736                 db    0
.xdata$x:00009737                 db    0
.xdata$x:00009738                 db    0
.xdata$x:00009739                 db    0
.xdata$x:0000973A                 db    0
.xdata$x:0000973B                 db    0
.xdata$x:0000973C                 db    0
.xdata$x:0000973D                 db    0
.xdata$x:0000973E                 db    0
.xdata$x:0000973F                 db    0
.xdata$x:00009740                 db    0
.xdata$x:00009741                 db    0
.xdata$x:00009742                 db    0
.xdata$x:00009743                 db    0
.xdata$x:00009744                 db    0
.xdata$x:00009745                 db    0
.xdata$x:00009746                 db    0
.xdata$x:00009747                 db    0
.xdata$x:00009748                 db    0
.xdata$x:00009749                 db    0
.xdata$x:0000974A                 db    0
.xdata$x:0000974B                 db    0
.xdata$x:0000974B _xdata$x        ends
.xdata$x:0000974B
.xdata$x:0000974C ; ===========================================================================
.xdata$x:0000974C
.xdata$x:0000974C ; Segment type: Pure data
.xdata$x:0000974C ; Segment permissions: Read
.xdata$x:0000974C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000974C                 assume cs:_xdata$x
.xdata$x:0000974C                 ;org 974Ch
.xdata$x:0000974C ; COMDAT (pick associative to section at 5214)
.xdata$x:0000974C __unwindtable$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z db 0FFh
.xdata$x:0000974C                                         ; DATA XREF: .xdata$x:0000975Co
.xdata$x:0000974D                 db 0FFh
.xdata$x:0000974E                 db 0FFh
.xdata$x:0000974F                 db 0FFh
.xdata$x:00009750                 dd offset __unwindfunclet$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z$0
.xdata$x:00009754 __ehfuncinfo$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z db  22h ; "
.xdata$x:00009754                                         ; DATA XREF: __ehhandler$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z+11o
.xdata$x:00009755                 db    5
.xdata$x:00009756                 db  93h ; ô
.xdata$x:00009757                 db  19h
.xdata$x:00009758                 db    1
.xdata$x:00009759                 db    0
.xdata$x:0000975A                 db    0
.xdata$x:0000975B                 db    0
.xdata$x:0000975C                 dd offset __unwindtable$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z
.xdata$x:00009760                 db    0
.xdata$x:00009761                 db    0
.xdata$x:00009762                 db    0
.xdata$x:00009763                 db    0
.xdata$x:00009764                 db    0
.xdata$x:00009765                 db    0
.xdata$x:00009766                 db    0
.xdata$x:00009767                 db    0
.xdata$x:00009768                 db    0
.xdata$x:00009769                 db    0
.xdata$x:0000976A                 db    0
.xdata$x:0000976B                 db    0
.xdata$x:0000976C                 db    0
.xdata$x:0000976D                 db    0
.xdata$x:0000976E                 db    0
.xdata$x:0000976F                 db    0
.xdata$x:00009770                 db    0
.xdata$x:00009771                 db    0
.xdata$x:00009772                 db    0
.xdata$x:00009773                 db    0
.xdata$x:00009774                 db    0
.xdata$x:00009775                 db    0
.xdata$x:00009776                 db    0
.xdata$x:00009777                 db    0
.xdata$x:00009777 _xdata$x        ends
.xdata$x:00009777
.xdata$x:00009778 ; ===========================================================================
.xdata$x:00009778
.xdata$x:00009778 ; Segment type: Pure data
.xdata$x:00009778 ; Segment permissions: Read
.xdata$x:00009778 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009778                 assume cs:_xdata$x
.xdata$x:00009778                 ;org 9778h
.xdata$x:00009778 ; COMDAT (pick associative to section at 50FC)
.xdata$x:00009778 __unwindtable$??1_Iterator_base12@std@@QAE@XZ db 0FFh
.xdata$x:00009778                                         ; DATA XREF: .xdata$x:00009788o
.xdata$x:00009779                 db 0FFh
.xdata$x:0000977A                 db 0FFh
.xdata$x:0000977B                 db 0FFh
.xdata$x:0000977C                 dd offset __unwindfunclet$??1_Iterator_base12@std@@QAE@XZ$0
.xdata$x:00009780 __ehfuncinfo$??1_Iterator_base12@std@@QAE@XZ db  22h ; "
.xdata$x:00009780                                         ; DATA XREF: __ehhandler$??1_Iterator_base12@std@@QAE@XZ+11o
.xdata$x:00009781                 db    5
.xdata$x:00009782                 db  93h ; ô
.xdata$x:00009783                 db  19h
.xdata$x:00009784                 db    1
.xdata$x:00009785                 db    0
.xdata$x:00009786                 db    0
.xdata$x:00009787                 db    0
.xdata$x:00009788                 dd offset __unwindtable$??1_Iterator_base12@std@@QAE@XZ
.xdata$x:0000978C                 db    0
.xdata$x:0000978D                 db    0
.xdata$x:0000978E                 db    0
.xdata$x:0000978F                 db    0
.xdata$x:00009790                 db    0
.xdata$x:00009791                 db    0
.xdata$x:00009792                 db    0
.xdata$x:00009793                 db    0
.xdata$x:00009794                 db    0
.xdata$x:00009795                 db    0
.xdata$x:00009796                 db    0
.xdata$x:00009797                 db    0
.xdata$x:00009798                 db    0
.xdata$x:00009799                 db    0
.xdata$x:0000979A                 db    0
.xdata$x:0000979B                 db    0
.xdata$x:0000979C                 db    0
.xdata$x:0000979D                 db    0
.xdata$x:0000979E                 db    0
.xdata$x:0000979F                 db    0
.xdata$x:000097A0                 db    0
.xdata$x:000097A1                 db    0
.xdata$x:000097A2                 db    0
.xdata$x:000097A3                 db    0
.xdata$x:000097A3 _xdata$x        ends
.xdata$x:000097A3
.xdata$x:000097A4 ; ===========================================================================
.xdata$x:000097A4
.xdata$x:000097A4 ; Segment type: Pure data
.xdata$x:000097A4 ; Segment permissions: Read
.xdata$x:000097A4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000097A4                 assume cs:_xdata$x
.xdata$x:000097A4                 ;org 97A4h
.xdata$x:000097A4 ; COMDAT (pick associative to section at 5F14)
.xdata$x:000097A4 __unwindtable$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z db 0FFh
.xdata$x:000097A4                                         ; DATA XREF: .xdata$x:000097BCo
.xdata$x:000097A5                 db 0FFh
.xdata$x:000097A6                 db 0FFh
.xdata$x:000097A7                 db 0FFh
.xdata$x:000097A8                 dd offset __unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$0
.xdata$x:000097AC                 db 0FFh
.xdata$x:000097AD                 db 0FFh
.xdata$x:000097AE                 db 0FFh
.xdata$x:000097AF                 db 0FFh
.xdata$x:000097B0                 dd offset __unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$1
.xdata$x:000097B4 __ehfuncinfo$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z db  22h ; "
.xdata$x:000097B4                                         ; DATA XREF: __ehhandler$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z+11o
.xdata$x:000097B5                 db    5
.xdata$x:000097B6                 db  93h ; ô
.xdata$x:000097B7                 db  19h
.xdata$x:000097B8                 db    2
.xdata$x:000097B9                 db    0
.xdata$x:000097BA                 db    0
.xdata$x:000097BB                 db    0
.xdata$x:000097BC                 dd offset __unwindtable$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
.xdata$x:000097C0                 db    0
.xdata$x:000097C1                 db    0
.xdata$x:000097C2                 db    0
.xdata$x:000097C3                 db    0
.xdata$x:000097C4                 db    0
.xdata$x:000097C5                 db    0
.xdata$x:000097C6                 db    0
.xdata$x:000097C7                 db    0
.xdata$x:000097C8                 db    0
.xdata$x:000097C9                 db    0
.xdata$x:000097CA                 db    0
.xdata$x:000097CB                 db    0
.xdata$x:000097CC                 db    0
.xdata$x:000097CD                 db    0
.xdata$x:000097CE                 db    0
.xdata$x:000097CF                 db    0
.xdata$x:000097D0                 db    0
.xdata$x:000097D1                 db    0
.xdata$x:000097D2                 db    0
.xdata$x:000097D3                 db    0
.xdata$x:000097D4                 db    0
.xdata$x:000097D5                 db    0
.xdata$x:000097D6                 db    0
.xdata$x:000097D7                 db    0
.xdata$x:000097D7 _xdata$x        ends
.xdata$x:000097D7
.xdata$x:000097D8 ; ===========================================================================
.xdata$x:000097D8
.xdata$x:000097D8 ; Segment type: Pure data
.xdata$x:000097D8 ; Segment permissions: Read
.xdata$x:000097D8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000097D8                 assume cs:_xdata$x
.xdata$x:000097D8                 ;org 97D8h
.xdata$x:000097D8 ; COMDAT (pick associative to section at 2EC4)
.xdata$x:000097D8 __unwindtable$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:000097D8                                         ; DATA XREF: .xdata$x:000097E8o
.xdata$x:000097D9                 db 0FFh
.xdata$x:000097DA                 db 0FFh
.xdata$x:000097DB                 db 0FFh
.xdata$x:000097DC                 dd offset __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
.xdata$x:000097E0 __ehfuncinfo$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:000097E0                                         ; DATA XREF: __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ+11o
.xdata$x:000097E1                 db    5
.xdata$x:000097E2                 db  93h ; ô
.xdata$x:000097E3                 db  19h
.xdata$x:000097E4                 db    1
.xdata$x:000097E5                 db    0
.xdata$x:000097E6                 db    0
.xdata$x:000097E7                 db    0
.xdata$x:000097E8                 dd offset __unwindtable$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.xdata$x:000097EC                 db    0
.xdata$x:000097ED                 db    0
.xdata$x:000097EE                 db    0
.xdata$x:000097EF                 db    0
.xdata$x:000097F0                 db    0
.xdata$x:000097F1                 db    0
.xdata$x:000097F2                 db    0
.xdata$x:000097F3                 db    0
.xdata$x:000097F4                 db    0
.xdata$x:000097F5                 db    0
.xdata$x:000097F6                 db    0
.xdata$x:000097F7                 db    0
.xdata$x:000097F8                 db    0
.xdata$x:000097F9                 db    0
.xdata$x:000097FA                 db    0
.xdata$x:000097FB                 db    0
.xdata$x:000097FC                 db    0
.xdata$x:000097FD                 db    0
.xdata$x:000097FE                 db    0
.xdata$x:000097FF                 db    0
.xdata$x:00009800                 db    0
.xdata$x:00009801                 db    0
.xdata$x:00009802                 db    0
.xdata$x:00009803                 db    0
.xdata$x:00009803 _xdata$x        ends
.xdata$x:00009803
.xdata$x:00009804 ; ===========================================================================
.xdata$x:00009804
.xdata$x:00009804 ; Segment type: Pure data
.xdata$x:00009804 ; Segment permissions: Read
.xdata$x:00009804 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009804                 assume cs:_xdata$x
.xdata$x:00009804                 ;org 9804h
.xdata$x:00009804 ; COMDAT (pick associative to section at 44EC)
.xdata$x:00009804 __unwindtable$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00009804                                         ; DATA XREF: .xdata$x:00009814o
.xdata$x:00009805                 db 0FFh
.xdata$x:00009806                 db 0FFh
.xdata$x:00009807                 db 0FFh
.xdata$x:00009808                 dd offset __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
.xdata$x:0000980C __ehfuncinfo$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000980C                                         ; DATA XREF: __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ+11o
.xdata$x:0000980D                 db    5
.xdata$x:0000980E                 db  93h ; ô
.xdata$x:0000980F                 db  19h
.xdata$x:00009810                 db    1
.xdata$x:00009811                 db    0
.xdata$x:00009812                 db    0
.xdata$x:00009813                 db    0
.xdata$x:00009814                 dd offset __unwindtable$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.xdata$x:00009818                 db    0
.xdata$x:00009819                 db    0
.xdata$x:0000981A                 db    0
.xdata$x:0000981B                 db    0
.xdata$x:0000981C                 db    0
.xdata$x:0000981D                 db    0
.xdata$x:0000981E                 db    0
.xdata$x:0000981F                 db    0
.xdata$x:00009820                 db    0
.xdata$x:00009821                 db    0
.xdata$x:00009822                 db    0
.xdata$x:00009823                 db    0
.xdata$x:00009824                 db    0
.xdata$x:00009825                 db    0
.xdata$x:00009826                 db    0
.xdata$x:00009827                 db    0
.xdata$x:00009828                 db    0
.xdata$x:00009829                 db    0
.xdata$x:0000982A                 db    0
.xdata$x:0000982B                 db    0
.xdata$x:0000982C                 db    0
.xdata$x:0000982D                 db    0
.xdata$x:0000982E                 db    0
.xdata$x:0000982F                 db    0
.xdata$x:0000982F _xdata$x        ends
.xdata$x:0000982F
.xdata$x:00009830 ; ===========================================================================
.xdata$x:00009830
.xdata$x:00009830 ; Segment type: Pure data
.xdata$x:00009830 ; Segment permissions: Read
.xdata$x:00009830 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009830                 assume cs:_xdata$x
.xdata$x:00009830                 ;org 9830h
.xdata$x:00009830 ; COMDAT (pick associative to section at 2E48)
.xdata$x:00009830 __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z db 0FFh
.xdata$x:00009830                                         ; DATA XREF: .xdata$x:00009840o
.xdata$x:00009831                 db 0FFh
.xdata$x:00009832                 db 0FFh
.xdata$x:00009833                 db 0FFh
.xdata$x:00009834                 dd offset __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0
.xdata$x:00009838 __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z db  22h ; "
.xdata$x:00009838                                         ; DATA XREF: __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z+11o
.xdata$x:00009839                 db    5
.xdata$x:0000983A                 db  93h ; ô
.xdata$x:0000983B                 db  19h
.xdata$x:0000983C                 db    1
.xdata$x:0000983D                 db    0
.xdata$x:0000983E                 db    0
.xdata$x:0000983F                 db    0
.xdata$x:00009840                 dd offset __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.xdata$x:00009844                 db    0
.xdata$x:00009845                 db    0
.xdata$x:00009846                 db    0
.xdata$x:00009847                 db    0
.xdata$x:00009848                 db    0
.xdata$x:00009849                 db    0
.xdata$x:0000984A                 db    0
.xdata$x:0000984B                 db    0
.xdata$x:0000984C                 db    0
.xdata$x:0000984D                 db    0
.xdata$x:0000984E                 db    0
.xdata$x:0000984F                 db    0
.xdata$x:00009850                 db    0
.xdata$x:00009851                 db    0
.xdata$x:00009852                 db    0
.xdata$x:00009853                 db    0
.xdata$x:00009854                 db    0
.xdata$x:00009855                 db    0
.xdata$x:00009856                 db    0
.xdata$x:00009857                 db    0
.xdata$x:00009858                 db    0
.xdata$x:00009859                 db    0
.xdata$x:0000985A                 db    0
.xdata$x:0000985B                 db    0
.xdata$x:0000985B _xdata$x        ends
.xdata$x:0000985B
.xdata$x:0000985C ; ===========================================================================
.xdata$x:0000985C
.xdata$x:0000985C ; Segment type: Pure data
.xdata$x:0000985C ; Segment permissions: Read
.xdata$x:0000985C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000985C                 assume cs:_xdata$x
.xdata$x:0000985C                 ;org 985Ch
.xdata$x:0000985C ; COMDAT (pick associative to section at 43FC)
.xdata$x:0000985C __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000985C                                         ; DATA XREF: .xdata$x:0000986Co
.xdata$x:0000985D                 db 0FFh
.xdata$x:0000985E                 db 0FFh
.xdata$x:0000985F                 db 0FFh
.xdata$x:00009860                 dd offset __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0
.xdata$x:00009864 __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00009864                                         ; DATA XREF: __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:00009865                 db    5
.xdata$x:00009866                 db  93h ; ô
.xdata$x:00009867                 db  19h
.xdata$x:00009868                 db    1
.xdata$x:00009869                 db    0
.xdata$x:0000986A                 db    0
.xdata$x:0000986B                 db    0
.xdata$x:0000986C                 dd offset __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.xdata$x:00009870                 db    0
.xdata$x:00009871                 db    0
.xdata$x:00009872                 db    0
.xdata$x:00009873                 db    0
.xdata$x:00009874                 db    0
.xdata$x:00009875                 db    0
.xdata$x:00009876                 db    0
.xdata$x:00009877                 db    0
.xdata$x:00009878                 db    0
.xdata$x:00009879                 db    0
.xdata$x:0000987A                 db    0
.xdata$x:0000987B                 db    0
.xdata$x:0000987C                 db    0
.xdata$x:0000987D                 db    0
.xdata$x:0000987E                 db    0
.xdata$x:0000987F                 db    0
.xdata$x:00009880                 db    0
.xdata$x:00009881                 db    0
.xdata$x:00009882                 db    0
.xdata$x:00009883                 db    0
.xdata$x:00009884                 db    0
.xdata$x:00009885                 db    0
.xdata$x:00009886                 db    0
.xdata$x:00009887                 db    0
.xdata$x:00009887 _xdata$x        ends
.xdata$x:00009887
.xdata$x:00009888 ; ===========================================================================
.xdata$x:00009888
.xdata$x:00009888 ; Segment type: Pure data
.xdata$x:00009888 ; Segment permissions: Read
.xdata$x:00009888 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009888                 assume cs:_xdata$x
.xdata$x:00009888                 ;org 9888h
.xdata$x:00009888 ; COMDAT (pick associative to section at 362C)
.xdata$x:00009888 __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z db 0FFh
.xdata$x:00009888                                         ; DATA XREF: .xdata$x:00009898o
.xdata$x:00009889                 db 0FFh
.xdata$x:0000988A                 db 0FFh
.xdata$x:0000988B                 db 0FFh
.xdata$x:0000988C                 dd offset __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0
.xdata$x:00009890 __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z db  22h ; "
.xdata$x:00009890                                         ; DATA XREF: __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z+11o
.xdata$x:00009891                 db    5
.xdata$x:00009892                 db  93h ; ô
.xdata$x:00009893                 db  19h
.xdata$x:00009894                 db    1
.xdata$x:00009895                 db    0
.xdata$x:00009896                 db    0
.xdata$x:00009897                 db    0
.xdata$x:00009898                 dd offset __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.xdata$x:0000989C                 db    0
.xdata$x:0000989D                 db    0
.xdata$x:0000989E                 db    0
.xdata$x:0000989F                 db    0
.xdata$x:000098A0                 db    0
.xdata$x:000098A1                 db    0
.xdata$x:000098A2                 db    0
.xdata$x:000098A3                 db    0
.xdata$x:000098A4                 db    0
.xdata$x:000098A5                 db    0
.xdata$x:000098A6                 db    0
.xdata$x:000098A7                 db    0
.xdata$x:000098A8                 db    0
.xdata$x:000098A9                 db    0
.xdata$x:000098AA                 db    0
.xdata$x:000098AB                 db    0
.xdata$x:000098AC                 db    0
.xdata$x:000098AD                 db    0
.xdata$x:000098AE                 db    0
.xdata$x:000098AF                 db    0
.xdata$x:000098B0                 db    0
.xdata$x:000098B1                 db    0
.xdata$x:000098B2                 db    0
.xdata$x:000098B3                 db    0
.xdata$x:000098B3 _xdata$x        ends
.xdata$x:000098B3
.xdata$x:000098B4 ; ===========================================================================
.xdata$x:000098B4
.xdata$x:000098B4 ; Segment type: Pure data
.xdata$x:000098B4 ; Segment permissions: Read
.xdata$x:000098B4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000098B4                 assume cs:_xdata$x
.xdata$x:000098B4                 ;org 98B4h
.xdata$x:000098B4 ; COMDAT (pick associative to section at 495C)
.xdata$x:000098B4 __unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db 0FFh
.xdata$x:000098B4                                         ; DATA XREF: .xdata$x:000098C4o
.xdata$x:000098B5                 db 0FFh
.xdata$x:000098B6                 db 0FFh
.xdata$x:000098B7                 db 0FFh
.xdata$x:000098B8                 dd offset __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0
.xdata$x:000098BC __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db  22h ; "
.xdata$x:000098BC                                         ; DATA XREF: __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ+11o
.xdata$x:000098BD                 db    5
.xdata$x:000098BE                 db  93h ; ô
.xdata$x:000098BF                 db  19h
.xdata$x:000098C0                 db    1
.xdata$x:000098C1                 db    0
.xdata$x:000098C2                 db    0
.xdata$x:000098C3                 db    0
.xdata$x:000098C4                 dd offset __unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.xdata$x:000098C8                 align 20h
.xdata$x:000098C8 _xdata$x        ends
.xdata$x:000098C8
.xdata$x:000098E0 ; ===========================================================================
.xdata$x:000098E0
.xdata$x:000098E0 ; Segment type: Pure data
.xdata$x:000098E0 ; Segment permissions: Read
.xdata$x:000098E0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000098E0                 assume cs:_xdata$x
.xdata$x:000098E0                 ;org 98E0h
.xdata$x:000098E0 ; COMDAT (pick associative to section at 622C)
.xdata$x:000098E0 __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 db    0
.xdata$x:000098E0                                         ; DATA XREF: .xdata$x:00009968o
.xdata$x:000098E1                 db    0
.xdata$x:000098E2                 db    0
.xdata$x:000098E3                 db    0
.xdata$x:000098E4                 db    0
.xdata$x:000098E5                 db    0
.xdata$x:000098E6                 db    0
.xdata$x:000098E7                 db    0
.xdata$x:000098E8                 db    0
.xdata$x:000098E9                 db    0
.xdata$x:000098EA                 db    0
.xdata$x:000098EB                 db    0
.xdata$x:000098EC                 dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.xdata$x:000098F0 __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 db    0
.xdata$x:000098F0                                         ; DATA XREF: .xdata$x:00009954o
.xdata$x:000098F1                 db    0
.xdata$x:000098F2                 db    0
.xdata$x:000098F3                 db    0
.xdata$x:000098F4                 db    0
.xdata$x:000098F5                 db    0
.xdata$x:000098F6                 db    0
.xdata$x:000098F7                 db    0
.xdata$x:000098F8                 db    0
.xdata$x:000098F9                 db    0
.xdata$x:000098FA                 db    0
.xdata$x:000098FB                 db    0
.xdata$x:000098FC                 dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
.xdata$x:00009900 __unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db 0FFh
.xdata$x:00009900                                         ; DATA XREF: .xdata$x:00009928o
.xdata$x:00009901                 db 0FFh
.xdata$x:00009902                 db 0FFh
.xdata$x:00009903                 db 0FFh
.xdata$x:00009904                 db    0
.xdata$x:00009905                 db    0
.xdata$x:00009906                 db    0
.xdata$x:00009907                 db    0
.xdata$x:00009908                 db 0FFh
.xdata$x:00009909                 db 0FFh
.xdata$x:0000990A                 db 0FFh
.xdata$x:0000990B                 db 0FFh
.xdata$x:0000990C                 db    0
.xdata$x:0000990D                 db    0
.xdata$x:0000990E                 db    0
.xdata$x:0000990F                 db    0
.xdata$x:00009910                 db    1
.xdata$x:00009911                 db    0
.xdata$x:00009912                 db    0
.xdata$x:00009913                 db    0
.xdata$x:00009914                 db    0
.xdata$x:00009915                 db    0
.xdata$x:00009916                 db    0
.xdata$x:00009917                 db    0
.xdata$x:00009918                 db    1
.xdata$x:00009919                 db    0
.xdata$x:0000991A                 db    0
.xdata$x:0000991B                 db    0
.xdata$x:0000991C                 db    0
.xdata$x:0000991D                 db    0
.xdata$x:0000991E                 db    0
.xdata$x:0000991F                 db    0
.xdata$x:00009920 __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db  22h ; "
.xdata$x:00009920                                         ; DATA XREF: __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z+11o
.xdata$x:00009921                 db    5
.xdata$x:00009922                 db  93h ; ô
.xdata$x:00009923                 db  19h
.xdata$x:00009924                 db    4
.xdata$x:00009925                 db    0
.xdata$x:00009926                 db    0
.xdata$x:00009927                 db    0
.xdata$x:00009928                 dd offset __unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.xdata$x:0000992C                 db    2
.xdata$x:0000992D                 db    0
.xdata$x:0000992E                 db    0
.xdata$x:0000992F                 db    0
.xdata$x:00009930                 dd offset __tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.xdata$x:00009934                 db    0
.xdata$x:00009935                 db    0
.xdata$x:00009936                 db    0
.xdata$x:00009937                 db    0
.xdata$x:00009938                 db    0
.xdata$x:00009939                 db    0
.xdata$x:0000993A                 db    0
.xdata$x:0000993B                 db    0
.xdata$x:0000993C                 db    0
.xdata$x:0000993D                 db    0
.xdata$x:0000993E                 db    0
.xdata$x:0000993F                 db    0
.xdata$x:00009940                 db    0
.xdata$x:00009941                 db    0
.xdata$x:00009942                 db    0
.xdata$x:00009943                 db    0
.xdata$x:00009944 __tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db    2
.xdata$x:00009944                                         ; DATA XREF: .xdata$x:00009930o
.xdata$x:00009945                 db    0
.xdata$x:00009946                 db    0
.xdata$x:00009947                 db    0
.xdata$x:00009948                 db    2
.xdata$x:00009949                 db    0
.xdata$x:0000994A                 db    0
.xdata$x:0000994B                 db    0
.xdata$x:0000994C                 db    3
.xdata$x:0000994D                 db    0
.xdata$x:0000994E                 db    0
.xdata$x:0000994F                 db    0
.xdata$x:00009950                 db    1
.xdata$x:00009951                 db    0
.xdata$x:00009952                 db    0
.xdata$x:00009953                 db    0
.xdata$x:00009954                 dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
.xdata$x:00009958                 align 10h
.xdata$x:00009960                 db    3
.xdata$x:00009961                 db    0
.xdata$x:00009962                 db    0
.xdata$x:00009963                 db    0
.xdata$x:00009964                 db    1
.xdata$x:00009965                 db    0
.xdata$x:00009966                 db    0
.xdata$x:00009967                 db    0
.xdata$x:00009968                 dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
.xdata$x:00009968 _xdata$x        ends
.xdata$x:00009968
.xdata$x:0000996C ; ===========================================================================
.xdata$x:0000996C
.xdata$x:0000996C ; Segment type: Pure data
.xdata$x:0000996C ; Segment permissions: Read
.xdata$x:0000996C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000996C                 assume cs:_xdata$x
.xdata$x:0000996C                 ;org 996Ch
.xdata$x:0000996C __unwindtable$?createSintilla@ScintillaCtrls@@QAEPAUHWND__@@PAU2@@Z db 0FFh
.xdata$x:0000996C                                         ; DATA XREF: .xdata$x:000099C0o
.xdata$x:0000996D                 db 0FFh
.xdata$x:0000996E                 db 0FFh
.xdata$x:0000996F                 db 0FFh
.xdata$x:00009970                 dd offset __unwindfunclet$?createSintilla@ScintillaCtrls@@QAEPAUHWND__@@PAU2@@Z$0
.xdata$x:00009974 __unwindtable$?destroyScintilla@ScintillaCtrls@@QAE_NPAUHWND__@@@Z db 0FFh
.xdata$x:00009974                                         ; DATA XREF: .xdata$x:0000999Co
.xdata$x:00009975                 db 0FFh
.xdata$x:00009976                 db 0FFh
.xdata$x:00009977                 db 0FFh
.xdata$x:00009978                 dd offset __unwindfunclet$?destroyScintilla@ScintillaCtrls@@QAE_NPAUHWND__@@@Z$0
.xdata$x:0000997C                 align 10h
.xdata$x:00009980                 dd offset __unwindfunclet$?destroyScintilla@ScintillaCtrls@@QAE_NPAUHWND__@@@Z$1
.xdata$x:00009984                 db 0FFh
.xdata$x:00009985                 db 0FFh
.xdata$x:00009986                 db 0FFh
.xdata$x:00009987                 db 0FFh
.xdata$x:00009988                 dd offset __unwindfunclet$?destroyScintilla@ScintillaCtrls@@QAE_NPAUHWND__@@@Z$1
.xdata$x:0000998C                 db    2
.xdata$x:0000998D                 db    0
.xdata$x:0000998E                 db    0
.xdata$x:0000998F                 db    0
.xdata$x:00009990                 dd offset __unwindfunclet$?destroyScintilla@ScintillaCtrls@@QAE_NPAUHWND__@@@Z$2
.xdata$x:00009994 __ehfuncinfo$?destroyScintilla@ScintillaCtrls@@QAE_NPAUHWND__@@@Z db  22h ; "
.xdata$x:00009994                                         ; DATA XREF: __ehhandler$?destroyScintilla@ScintillaCtrls@@QAE_NPAUHWND__@@@Z+11o
.xdata$x:00009995                 db    5
.xdata$x:00009996                 db  93h ; ô
.xdata$x:00009997                 db  19h
.xdata$x:00009998                 db    4
.xdata$x:00009999                 db    0
.xdata$x:0000999A                 db    0
.xdata$x:0000999B                 db    0
.xdata$x:0000999C                 dd offset __unwindtable$?destroyScintilla@ScintillaCtrls@@QAE_NPAUHWND__@@@Z
.xdata$x:000099A0                 db    0
.xdata$x:000099A1                 db    0
.xdata$x:000099A2                 db    0
.xdata$x:000099A3                 db    0
.xdata$x:000099A4                 db    0
.xdata$x:000099A5                 db    0
.xdata$x:000099A6                 db    0
.xdata$x:000099A7                 db    0
.xdata$x:000099A8                 db    0
.xdata$x:000099A9                 db    0
.xdata$x:000099AA                 db    0
.xdata$x:000099AB                 db    0
.xdata$x:000099AC                 db    0
.xdata$x:000099AD                 db    0
.xdata$x:000099AE                 db    0
.xdata$x:000099AF                 db    0
.xdata$x:000099B0                 db    0
.xdata$x:000099B1                 db    0
.xdata$x:000099B2                 db    0
.xdata$x:000099B3                 db    0
.xdata$x:000099B4                 db    0
.xdata$x:000099B5                 db    0
.xdata$x:000099B6                 db    0
.xdata$x:000099B7                 db    0
.xdata$x:000099B8 __ehfuncinfo$?createSintilla@ScintillaCtrls@@QAEPAUHWND__@@PAU2@@Z db  22h ; "
.xdata$x:000099B8                                         ; DATA XREF: __ehhandler$?createSintilla@ScintillaCtrls@@QAEPAUHWND__@@PAU2@@Z+11o
.xdata$x:000099B9                 db    5
.xdata$x:000099BA                 db  93h ; ô
.xdata$x:000099BB                 db  19h
.xdata$x:000099BC                 db    1
.xdata$x:000099BD                 db    0
.xdata$x:000099BE                 db    0
.xdata$x:000099BF                 db    0
.xdata$x:000099C0                 dd offset __unwindtable$?createSintilla@ScintillaCtrls@@QAEPAUHWND__@@PAU2@@Z
.xdata$x:000099C4                 db    0
.xdata$x:000099C5                 db    0
.xdata$x:000099C6                 db    0
.xdata$x:000099C7                 db    0
.xdata$x:000099C8                 db    0
.xdata$x:000099C9                 db    0
.xdata$x:000099CA                 db    0
.xdata$x:000099CB                 db    0
.xdata$x:000099CC                 db    0
.xdata$x:000099CD                 db    0
.xdata$x:000099CE                 db    0
.xdata$x:000099CF                 db    0
.xdata$x:000099D0                 db    0
.xdata$x:000099D1                 db    0
.xdata$x:000099D2                 db    0
.xdata$x:000099D3                 db    0
.xdata$x:000099D4                 db    0
.xdata$x:000099D5                 db    0
.xdata$x:000099D6                 db    0
.xdata$x:000099D7                 db    0
.xdata$x:000099D8                 db    0
.xdata$x:000099D9                 db    0
.xdata$x:000099DA                 db    0
.xdata$x:000099DB                 db    0
.xdata$x:000099DB _xdata$x        ends
.xdata$x:000099DB
.xdata$x:000099DC ; ===========================================================================
.xdata$x:000099DC
.xdata$x:000099DC ; Segment type: Pure data
.xdata$x:000099DC ; Segment permissions: Read
.xdata$x:000099DC _xdata$x        segment dword public 'DATA' use32
.xdata$x:000099DC                 assume cs:_xdata$x
.xdata$x:000099DC                 ;org 99DCh
.xdata$x:000099DC ; COMDAT (pick associative to section at 825C)
.xdata$x:000099DC __unwindtable$?begin@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@2@XZ db 0FFh
.xdata$x:000099DC                                         ; DATA XREF: .xdata$x:000099ECo
.xdata$x:000099DD                 db 0FFh
.xdata$x:000099DE                 db 0FFh
.xdata$x:000099DF                 db 0FFh
.xdata$x:000099E0                 dd offset __unwindfunclet$?begin@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@2@XZ$0
.xdata$x:000099E4 __ehfuncinfo$?begin@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@2@XZ db  22h ; "
.xdata$x:000099E4                                         ; DATA XREF: __ehhandler$?begin@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@2@XZ+11o
.xdata$x:000099E5                 db    5
.xdata$x:000099E6                 db  93h ; ô
.xdata$x:000099E7                 db  19h
.xdata$x:000099E8                 db    1
.xdata$x:000099E9                 db    0
.xdata$x:000099EA                 db    0
.xdata$x:000099EB                 db    0
.xdata$x:000099EC                 dd offset __unwindtable$?begin@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@2@XZ
.xdata$x:000099F0                 db    0
.xdata$x:000099F1                 db    0
.xdata$x:000099F2                 db    0
.xdata$x:000099F3                 db    0
.xdata$x:000099F4                 db    0
.xdata$x:000099F5                 db    0
.xdata$x:000099F6                 db    0
.xdata$x:000099F7                 db    0
.xdata$x:000099F8                 db    0
.xdata$x:000099F9                 db    0
.xdata$x:000099FA                 db    0
.xdata$x:000099FB                 db    0
.xdata$x:000099FC                 db    0
.xdata$x:000099FD                 db    0
.xdata$x:000099FE                 db    0
.xdata$x:000099FF                 db    0
.xdata$x:00009A00                 db    0
.xdata$x:00009A01                 db    0
.xdata$x:00009A02                 db    0
.xdata$x:00009A03                 db    0
.xdata$x:00009A04                 db    0
.xdata$x:00009A05                 db    0
.xdata$x:00009A06                 db    0
.xdata$x:00009A07                 db    0
.xdata$x:00009A07 _xdata$x        ends
.xdata$x:00009A07
.xdata$x:00009A08 ; ===========================================================================
.xdata$x:00009A08
.xdata$x:00009A08 ; Segment type: Pure data
.xdata$x:00009A08 ; Segment permissions: Read
.xdata$x:00009A08 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009A08                 assume cs:_xdata$x
.xdata$x:00009A08                 ;org 9A08h
.xdata$x:00009A08 ; COMDAT (pick associative to section at 708C)
.xdata$x:00009A08 __unwindtable$?_Make_iter@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@2@@Z db 0FFh
.xdata$x:00009A08                                         ; DATA XREF: .xdata$x:00009A20o
.xdata$x:00009A09                 db 0FFh
.xdata$x:00009A0A                 db 0FFh
.xdata$x:00009A0B                 db 0FFh
.xdata$x:00009A0C                 dd offset __unwindfunclet$?_Make_iter@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@2@@Z$1
.xdata$x:00009A10                 db    0
.xdata$x:00009A11                 db    0
.xdata$x:00009A12                 db    0
.xdata$x:00009A13                 db    0
.xdata$x:00009A14                 dd offset __unwindfunclet$?_Make_iter@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@2@@Z$0
.xdata$x:00009A18 __ehfuncinfo$?_Make_iter@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@2@@Z db  22h ; "
.xdata$x:00009A18                                         ; DATA XREF: __ehhandler$?_Make_iter@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@2@@Z+11o
.xdata$x:00009A19                 db    5
.xdata$x:00009A1A                 db  93h ; ô
.xdata$x:00009A1B                 db  19h
.xdata$x:00009A1C                 db    2
.xdata$x:00009A1D                 db    0
.xdata$x:00009A1E                 db    0
.xdata$x:00009A1F                 db    0
.xdata$x:00009A20                 dd offset __unwindtable$?_Make_iter@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@2@@Z
.xdata$x:00009A24                 db    0
.xdata$x:00009A25                 db    0
.xdata$x:00009A26                 db    0
.xdata$x:00009A27                 db    0
.xdata$x:00009A28                 db    0
.xdata$x:00009A29                 db    0
.xdata$x:00009A2A                 db    0
.xdata$x:00009A2B                 db    0
.xdata$x:00009A2C                 db    0
.xdata$x:00009A2D                 db    0
.xdata$x:00009A2E                 db    0
.xdata$x:00009A2F                 db    0
.xdata$x:00009A30                 db    0
.xdata$x:00009A31                 db    0
.xdata$x:00009A32                 db    0
.xdata$x:00009A33                 db    0
.xdata$x:00009A34                 db    0
.xdata$x:00009A35                 db    0
.xdata$x:00009A36                 db    0
.xdata$x:00009A37                 db    0
.xdata$x:00009A38                 db    0
.xdata$x:00009A39                 db    0
.xdata$x:00009A3A                 db    0
.xdata$x:00009A3B                 db    0
.xdata$x:00009A3B _xdata$x        ends
.xdata$x:00009A3B
.xdata$x:00009A3C ; ===========================================================================
.xdata$x:00009A3C
.xdata$x:00009A3C ; Segment type: Pure data
.xdata$x:00009A3C ; Segment permissions: Read
.xdata$x:00009A3C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009A3C                 assume cs:_xdata$x
.xdata$x:00009A3C                 ;org 9A3Ch
.xdata$x:00009A3C ; COMDAT (pick associative to section at 8CDC)
.xdata$x:00009A3C __unwindtable$?erase@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@2@@Z db 0FFh
.xdata$x:00009A3C                                         ; DATA XREF: .xdata$x:00009A5Co
.xdata$x:00009A3D                 db 0FFh
.xdata$x:00009A3E                 db 0FFh
.xdata$x:00009A3F                 db 0FFh
.xdata$x:00009A40                 dd offset __unwindfunclet$?erase@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@2@@Z$2
.xdata$x:00009A44                 align 8
.xdata$x:00009A48                 dd offset __unwindfunclet$?erase@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@2@@Z$0
.xdata$x:00009A4C                 db    1
.xdata$x:00009A4D                 db    0
.xdata$x:00009A4E                 db    0
.xdata$x:00009A4F                 db    0
.xdata$x:00009A50                 dd offset __unwindfunclet$?erase@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@2@@Z$1
.xdata$x:00009A54 __ehfuncinfo$?erase@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@2@@Z db  22h ; "
.xdata$x:00009A54                                         ; DATA XREF: __ehhandler$?erase@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@2@@Z+11o
.xdata$x:00009A55                 db    5
.xdata$x:00009A56                 db  93h ; ô
.xdata$x:00009A57                 db  19h
.xdata$x:00009A58                 db    3
.xdata$x:00009A59                 db    0
.xdata$x:00009A5A                 db    0
.xdata$x:00009A5B                 db    0
.xdata$x:00009A5C                 dd offset __unwindtable$?erase@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@2@@Z
.xdata$x:00009A60                 db    0
.xdata$x:00009A61                 db    0
.xdata$x:00009A62                 db    0
.xdata$x:00009A63                 db    0
.xdata$x:00009A64                 db    0
.xdata$x:00009A65                 db    0
.xdata$x:00009A66                 db    0
.xdata$x:00009A67                 db    0
.xdata$x:00009A68                 db    0
.xdata$x:00009A69                 db    0
.xdata$x:00009A6A                 db    0
.xdata$x:00009A6B                 db    0
.xdata$x:00009A6C                 db    0
.xdata$x:00009A6D                 db    0
.xdata$x:00009A6E                 db    0
.xdata$x:00009A6F                 db    0
.xdata$x:00009A70                 db    0
.xdata$x:00009A71                 db    0
.xdata$x:00009A72                 db    0
.xdata$x:00009A73                 db    0
.xdata$x:00009A74                 db    0
.xdata$x:00009A75                 db    0
.xdata$x:00009A76                 db    0
.xdata$x:00009A77                 db    0
.xdata$x:00009A77 _xdata$x        ends
.xdata$x:00009A77
.xdata$x:00009A78 ; ===========================================================================
.xdata$x:00009A78
.xdata$x:00009A78 ; Segment type: Pure data
.xdata$x:00009A78 ; Segment permissions: Read
.xdata$x:00009A78 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009A78                 assume cs:_xdata$x
.xdata$x:00009A78                 ;org 9A78h
.xdata$x:00009A78 ; COMDAT (pick associative to section at 76DC)
.xdata$x:00009A78 __catchsym$?_Reallocate@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@IAEXI@Z$2 db    0
.xdata$x:00009A78                                         ; DATA XREF: .xdata$x:00009AA8o
.xdata$x:00009A79                 db    0
.xdata$x:00009A7A                 db    0
.xdata$x:00009A7B                 db    0
.xdata$x:00009A7C                 db    0
.xdata$x:00009A7D                 db    0
.xdata$x:00009A7E                 db    0
.xdata$x:00009A7F                 db    0
.xdata$x:00009A80                 db    0
.xdata$x:00009A81                 db    0
.xdata$x:00009A82                 db    0
.xdata$x:00009A83                 db    0
.xdata$x:00009A84                 dd offset __catch$?_Reallocate@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@IAEXI@Z$0
.xdata$x:00009A88 __unwindtable$?_Reallocate@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@IAEXI@Z db 0FFh
.xdata$x:00009A88                                         ; DATA XREF: .xdata$x:00009AB4o
.xdata$x:00009A89                 db 0FFh
.xdata$x:00009A8A                 db 0FFh
.xdata$x:00009A8B                 db 0FFh
.xdata$x:00009A8C                 db    0
.xdata$x:00009A8D                 db    0
.xdata$x:00009A8E                 db    0
.xdata$x:00009A8F                 db    0
.xdata$x:00009A90                 db 0FFh
.xdata$x:00009A91                 db 0FFh
.xdata$x:00009A92                 db 0FFh
.xdata$x:00009A93                 db 0FFh
.xdata$x:00009A94                 db    0
.xdata$x:00009A95                 db    0
.xdata$x:00009A96                 db    0
.xdata$x:00009A97                 db    0
.xdata$x:00009A98 __tryblocktable$?_Reallocate@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@IAEXI@Z db    0
.xdata$x:00009A98                                         ; DATA XREF: .xdata$x:00009ABCo
.xdata$x:00009A99                 db    0
.xdata$x:00009A9A                 db    0
.xdata$x:00009A9B                 db    0
.xdata$x:00009A9C                 db    0
.xdata$x:00009A9D                 db    0
.xdata$x:00009A9E                 db    0
.xdata$x:00009A9F                 db    0
.xdata$x:00009AA0                 db    1
.xdata$x:00009AA1                 db    0
.xdata$x:00009AA2                 db    0
.xdata$x:00009AA3                 db    0
.xdata$x:00009AA4                 db    1
.xdata$x:00009AA5                 db    0
.xdata$x:00009AA6                 db    0
.xdata$x:00009AA7                 db    0
.xdata$x:00009AA8                 dd offset __catchsym$?_Reallocate@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@IAEXI@Z$2
.xdata$x:00009AAC __ehfuncinfo$?_Reallocate@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@IAEXI@Z db  22h ; "
.xdata$x:00009AAC                                         ; DATA XREF: __ehhandler$?_Reallocate@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@IAEXI@Z+11o
.xdata$x:00009AAD                 db    5
.xdata$x:00009AAE                 db  93h ; ô
.xdata$x:00009AAF                 db  19h
.xdata$x:00009AB0                 db    2
.xdata$x:00009AB1                 db    0
.xdata$x:00009AB2                 db    0
.xdata$x:00009AB3                 db    0
.xdata$x:00009AB4                 dd offset __unwindtable$?_Reallocate@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@IAEXI@Z
.xdata$x:00009AB8                 db    1
.xdata$x:00009AB9                 db    0
.xdata$x:00009ABA                 db    0
.xdata$x:00009ABB                 db    0
.xdata$x:00009ABC                 dd offset __tryblocktable$?_Reallocate@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@IAEXI@Z
.xdata$x:00009AC0                 db    0
.xdata$x:00009AC1                 db    0
.xdata$x:00009AC2                 db    0
.xdata$x:00009AC3                 db    0
.xdata$x:00009AC4                 db    0
.xdata$x:00009AC5                 db    0
.xdata$x:00009AC6                 db    0
.xdata$x:00009AC7                 db    0
.xdata$x:00009AC8                 db    0
.xdata$x:00009AC9                 db    0
.xdata$x:00009ACA                 db    0
.xdata$x:00009ACB                 db    0
.xdata$x:00009ACC                 db    0
.xdata$x:00009ACD                 db    0
.xdata$x:00009ACE                 db    0
.xdata$x:00009ACF                 db    0
.xdata$x:00009ACF _xdata$x        ends
.xdata$x:00009ACF
.xdata$x:00009AD0 ; ===========================================================================
.xdata$x:00009AD0
.xdata$x:00009AD0 ; Segment type: Pure data
.xdata$x:00009AD0 ; Segment permissions: Read
.xdata$x:00009AD0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009AD0                 assume cs:_xdata$x
.xdata$x:00009AD0                 ;org 9AD0h
.xdata$x:00009AD0 ; COMDAT (pick associative to section at 750C)
.xdata$x:00009AD0 __unwindtable$?_Orphan_range@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@IBEXPAPAVScintillaEditView@@0@Z db 0FFh
.xdata$x:00009AD0                                         ; DATA XREF: .xdata$x:00009AE0o
.xdata$x:00009AD1                 db 0FFh
.xdata$x:00009AD2                 db 0FFh
.xdata$x:00009AD3                 db 0FFh
.xdata$x:00009AD4                 dd offset __unwindfunclet$?_Orphan_range@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@IBEXPAPAVScintillaEditView@@0@Z$0
.xdata$x:00009AD8 __ehfuncinfo$?_Orphan_range@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@IBEXPAPAVScintillaEditView@@0@Z db  22h ; "
.xdata$x:00009AD8                                         ; DATA XREF: __ehhandler$?_Orphan_range@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@IBEXPAPAVScintillaEditView@@0@Z+11o
.xdata$x:00009AD9                 db    5
.xdata$x:00009ADA                 db  93h ; ô
.xdata$x:00009ADB                 db  19h
.xdata$x:00009ADC                 db    1
.xdata$x:00009ADD                 db    0
.xdata$x:00009ADE                 db    0
.xdata$x:00009ADF                 db    0
.xdata$x:00009AE0                 dd offset __unwindtable$?_Orphan_range@?$vector@PAVScintillaEditView@@V?$allocator@PAVScintillaEditView@@@std@@@std@@IBEXPAPAVScintillaEditView@@0@Z
.xdata$x:00009AE4                 db    0
.xdata$x:00009AE5                 db    0
.xdata$x:00009AE6                 db    0
.xdata$x:00009AE7                 db    0
.xdata$x:00009AE8                 db    0
.xdata$x:00009AE9                 db    0
.xdata$x:00009AEA                 db    0
.xdata$x:00009AEB                 db    0
.xdata$x:00009AEC                 db    0
.xdata$x:00009AED                 db    0
.xdata$x:00009AEE                 db    0
.xdata$x:00009AEF                 db    0
.xdata$x:00009AF0                 db    0
.xdata$x:00009AF1                 db    0
.xdata$x:00009AF2                 db    0
.xdata$x:00009AF3                 db    0
.xdata$x:00009AF4                 db    0
.xdata$x:00009AF5                 db    0
.xdata$x:00009AF6                 db    0
.xdata$x:00009AF7                 db    0
.xdata$x:00009AF8                 db    0
.xdata$x:00009AF9                 db    0
.xdata$x:00009AFA                 db    0
.xdata$x:00009AFB                 db    0
.xdata$x:00009AFB _xdata$x        ends
.xdata$x:00009AFB
.xdata$x:00009AFC ; ===========================================================================
.xdata$x:00009AFC
.xdata$x:00009AFC ; Segment type: Pure data
.xdata$x:00009AFC ; Segment permissions: Read
.xdata$x:00009AFC _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009AFC                 assume cs:_xdata$x
.xdata$x:00009AFC                 ;org 9AFCh
.xdata$x:00009AFC ; COMDAT (pick associative to section at 3988)
.xdata$x:00009AFC __unwindtable$??0_Generic_error_category@std@@QAE@XZ db 0FFh
.xdata$x:00009AFC                                         ; DATA XREF: .xdata$x:00009B0Co
.xdata$x:00009AFD                 db 0FFh
.xdata$x:00009AFE                 db 0FFh
.xdata$x:00009AFF                 db 0FFh
.xdata$x:00009B00                 dd offset __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0
.xdata$x:00009B04 __ehfuncinfo$??0_Generic_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:00009B04                                         ; DATA XREF: __ehhandler$??0_Generic_error_category@std@@QAE@XZ+11o
.xdata$x:00009B05                 db    5
.xdata$x:00009B06                 db  93h ; ô
.xdata$x:00009B07                 db  19h
.xdata$x:00009B08                 db    1
.xdata$x:00009B09                 db    0
.xdata$x:00009B0A                 db    0
.xdata$x:00009B0B                 db    0
.xdata$x:00009B0C                 dd offset __unwindtable$??0_Generic_error_category@std@@QAE@XZ
.xdata$x:00009B10                 db    0
.xdata$x:00009B11                 db    0
.xdata$x:00009B12                 db    0
.xdata$x:00009B13                 db    0
.xdata$x:00009B14                 db    0
.xdata$x:00009B15                 db    0
.xdata$x:00009B16                 db    0
.xdata$x:00009B17                 db    0
.xdata$x:00009B18                 db    0
.xdata$x:00009B19                 db    0
.xdata$x:00009B1A                 db    0
.xdata$x:00009B1B                 db    0
.xdata$x:00009B1C                 db    0
.xdata$x:00009B1D                 db    0
.xdata$x:00009B1E                 db    0
.xdata$x:00009B1F                 db    0
.xdata$x:00009B20                 db    0
.xdata$x:00009B21                 db    0
.xdata$x:00009B22                 db    0
.xdata$x:00009B23                 db    0
.xdata$x:00009B24                 db    0
.xdata$x:00009B25                 db    0
.xdata$x:00009B26                 db    0
.xdata$x:00009B27                 db    0
.xdata$x:00009B27 _xdata$x        ends
.xdata$x:00009B27
.xdata$x:00009B28 ; ===========================================================================
.xdata$x:00009B28
.xdata$x:00009B28 ; Segment type: Pure data
.xdata$x:00009B28 ; Segment permissions: Read
.xdata$x:00009B28 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009B28                 assume cs:_xdata$x
.xdata$x:00009B28                 ;org 9B28h
.xdata$x:00009B28 ; COMDAT (pick associative to section at 91D4)
.xdata$x:00009B28 __unwindtable$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:00009B28                                         ; DATA XREF: .xdata$x:00009B38o
.xdata$x:00009B29                 db 0FFh
.xdata$x:00009B2A                 db 0FFh
.xdata$x:00009B2B                 db 0FFh
.xdata$x:00009B2C                 dd offset __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:00009B30 __ehfuncinfo$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:00009B30                                         ; DATA XREF: __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:00009B31                 db    5
.xdata$x:00009B32                 db  93h ; ô
.xdata$x:00009B33                 db  19h
.xdata$x:00009B34                 db    1
.xdata$x:00009B35                 db    0
.xdata$x:00009B36                 db    0
.xdata$x:00009B37                 db    0
.xdata$x:00009B38                 dd offset __unwindtable$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:00009B3C                 db    0
.xdata$x:00009B3D                 db    0
.xdata$x:00009B3E                 db    0
.xdata$x:00009B3F                 db    0
.xdata$x:00009B40                 db    0
.xdata$x:00009B41                 db    0
.xdata$x:00009B42                 db    0
.xdata$x:00009B43                 db    0
.xdata$x:00009B44                 db    0
.xdata$x:00009B45                 db    0
.xdata$x:00009B46                 db    0
.xdata$x:00009B47                 db    0
.xdata$x:00009B48                 db    0
.xdata$x:00009B49                 db    0
.xdata$x:00009B4A                 db    0
.xdata$x:00009B4B                 db    0
.xdata$x:00009B4C                 db    0
.xdata$x:00009B4D                 db    0
.xdata$x:00009B4E                 db    0
.xdata$x:00009B4F                 db    0
.xdata$x:00009B50                 db    0
.xdata$x:00009B51                 db    0
.xdata$x:00009B52                 db    0
.xdata$x:00009B53                 db    0
.xdata$x:00009B53 _xdata$x        ends
.xdata$x:00009B53
.xdata$x:00009B54 ; ===========================================================================
.xdata$x:00009B54
.xdata$x:00009B54 ; Segment type: Pure data
.xdata$x:00009B54 ; Segment permissions: Read
.xdata$x:00009B54 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009B54                 assume cs:_xdata$x
.xdata$x:00009B54                 ;org 9B54h
.xdata$x:00009B54 ; COMDAT (pick associative to section at 501C)
.xdata$x:00009B54 __unwindtable$??1_Generic_error_category@std@@UAE@XZ db 0FFh
.xdata$x:00009B54                                         ; DATA XREF: .xdata$x:00009B64o
.xdata$x:00009B55                 db 0FFh
.xdata$x:00009B56                 db 0FFh
.xdata$x:00009B57                 db 0FFh
.xdata$x:00009B58                 dd offset __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0
.xdata$x:00009B5C __ehfuncinfo$??1_Generic_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:00009B5C                                         ; DATA XREF: __ehhandler$??1_Generic_error_category@std@@UAE@XZ+11o
.xdata$x:00009B5D                 db    5
.xdata$x:00009B5E                 db  93h ; ô
.xdata$x:00009B5F                 db  19h
.xdata$x:00009B60                 db    1
.xdata$x:00009B61                 db    0
.xdata$x:00009B62                 db    0
.xdata$x:00009B63                 db    0
.xdata$x:00009B64                 dd offset __unwindtable$??1_Generic_error_category@std@@UAE@XZ
.xdata$x:00009B68                 align 20h
.xdata$x:00009B68 _xdata$x        ends
.xdata$x:00009B68
.xdata$x:00009B80 ; ===========================================================================
.xdata$x:00009B80
.xdata$x:00009B80 ; Segment type: Pure data
.xdata$x:00009B80 ; Segment permissions: Read
.xdata$x:00009B80 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009B80                 assume cs:_xdata$x
.xdata$x:00009B80                 ;org 9B80h
.xdata$x:00009B80 ; COMDAT (pick associative to section at 3A14)
.xdata$x:00009B80 __unwindtable$??0_Iostream_error_category@std@@QAE@XZ db 0FFh
.xdata$x:00009B80                                         ; DATA XREF: .xdata$x:00009B90o
.xdata$x:00009B81                 db 0FFh
.xdata$x:00009B82                 db 0FFh
.xdata$x:00009B83                 db 0FFh
.xdata$x:00009B84                 dd offset __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0
.xdata$x:00009B88 __ehfuncinfo$??0_Iostream_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:00009B88                                         ; DATA XREF: __ehhandler$??0_Iostream_error_category@std@@QAE@XZ+11o
.xdata$x:00009B89                 db    5
.xdata$x:00009B8A                 db  93h ; ô
.xdata$x:00009B8B                 db  19h
.xdata$x:00009B8C                 db    1
.xdata$x:00009B8D                 db    0
.xdata$x:00009B8E                 db    0
.xdata$x:00009B8F                 db    0
.xdata$x:00009B90                 dd offset __unwindtable$??0_Iostream_error_category@std@@QAE@XZ
.xdata$x:00009B94                 db    0
.xdata$x:00009B95                 db    0
.xdata$x:00009B96                 db    0
.xdata$x:00009B97                 db    0
.xdata$x:00009B98                 db    0
.xdata$x:00009B99                 db    0
.xdata$x:00009B9A                 db    0
.xdata$x:00009B9B                 db    0
.xdata$x:00009B9C                 db    0
.xdata$x:00009B9D                 db    0
.xdata$x:00009B9E                 db    0
.xdata$x:00009B9F                 db    0
.xdata$x:00009BA0                 db    0
.xdata$x:00009BA1                 db    0
.xdata$x:00009BA2                 db    0
.xdata$x:00009BA3                 db    0
.xdata$x:00009BA4                 db    0
.xdata$x:00009BA5                 db    0
.xdata$x:00009BA6                 db    0
.xdata$x:00009BA7                 db    0
.xdata$x:00009BA8                 db    0
.xdata$x:00009BA9                 db    0
.xdata$x:00009BAA                 db    0
.xdata$x:00009BAB                 db    0
.xdata$x:00009BAB _xdata$x        ends
.xdata$x:00009BAB
.xdata$x:00009BAC ; ===========================================================================
.xdata$x:00009BAC
.xdata$x:00009BAC ; Segment type: Pure data
.xdata$x:00009BAC ; Segment permissions: Read
.xdata$x:00009BAC _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009BAC                 assume cs:_xdata$x
.xdata$x:00009BAC                 ;org 9BACh
.xdata$x:00009BAC ; COMDAT (pick associative to section at 928C)
.xdata$x:00009BAC __unwindtable$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:00009BAC                                         ; DATA XREF: .xdata$x:00009BBCo
.xdata$x:00009BAD                 db 0FFh
.xdata$x:00009BAE                 db 0FFh
.xdata$x:00009BAF                 db 0FFh
.xdata$x:00009BB0                 dd offset __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:00009BB4 __ehfuncinfo$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:00009BB4                                         ; DATA XREF: __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:00009BB5                 db    5
.xdata$x:00009BB6                 db  93h ; ô
.xdata$x:00009BB7                 db  19h
.xdata$x:00009BB8                 db    1
.xdata$x:00009BB9                 db    0
.xdata$x:00009BBA                 db    0
.xdata$x:00009BBB                 db    0
.xdata$x:00009BBC                 dd offset __unwindtable$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:00009BC0                 db    0
.xdata$x:00009BC1                 db    0
.xdata$x:00009BC2                 db    0
.xdata$x:00009BC3                 db    0
.xdata$x:00009BC4                 db    0
.xdata$x:00009BC5                 db    0
.xdata$x:00009BC6                 db    0
.xdata$x:00009BC7                 db    0
.xdata$x:00009BC8                 db    0
.xdata$x:00009BC9                 db    0
.xdata$x:00009BCA                 db    0
.xdata$x:00009BCB                 db    0
.xdata$x:00009BCC                 db    0
.xdata$x:00009BCD                 db    0
.xdata$x:00009BCE                 db    0
.xdata$x:00009BCF                 db    0
.xdata$x:00009BD0                 db    0
.xdata$x:00009BD1                 db    0
.xdata$x:00009BD2                 db    0
.xdata$x:00009BD3                 db    0
.xdata$x:00009BD4                 db    0
.xdata$x:00009BD5                 db    0
.xdata$x:00009BD6                 db    0
.xdata$x:00009BD7                 db    0
.xdata$x:00009BD7 _xdata$x        ends
.xdata$x:00009BD7
.xdata$x:00009BD8 ; ===========================================================================
.xdata$x:00009BD8
.xdata$x:00009BD8 ; Segment type: Pure data
.xdata$x:00009BD8 ; Segment permissions: Read
.xdata$x:00009BD8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009BD8                 assume cs:_xdata$x
.xdata$x:00009BD8                 ;org 9BD8h
.xdata$x:00009BD8 ; COMDAT (pick associative to section at 508C)
.xdata$x:00009BD8 __unwindtable$??1_Iostream_error_category@std@@UAE@XZ db 0FFh
.xdata$x:00009BD8                                         ; DATA XREF: .xdata$x:00009BE8o
.xdata$x:00009BD9                 db 0FFh
.xdata$x:00009BDA                 db 0FFh
.xdata$x:00009BDB                 db 0FFh
.xdata$x:00009BDC                 dd offset __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0
.xdata$x:00009BE0 __ehfuncinfo$??1_Iostream_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:00009BE0                                         ; DATA XREF: __ehhandler$??1_Iostream_error_category@std@@UAE@XZ+11o
.xdata$x:00009BE1                 db    5
.xdata$x:00009BE2                 db  93h ; ô
.xdata$x:00009BE3                 db  19h
.xdata$x:00009BE4                 db    1
.xdata$x:00009BE5                 db    0
.xdata$x:00009BE6                 db    0
.xdata$x:00009BE7                 db    0
.xdata$x:00009BE8                 dd offset __unwindtable$??1_Iostream_error_category@std@@UAE@XZ
.xdata$x:00009BEC                 db    0
.xdata$x:00009BED                 db    0
.xdata$x:00009BEE                 db    0
.xdata$x:00009BEF                 db    0
.xdata$x:00009BF0                 db    0
.xdata$x:00009BF1                 db    0
.xdata$x:00009BF2                 db    0
.xdata$x:00009BF3                 db    0
.xdata$x:00009BF4                 db    0
.xdata$x:00009BF5                 db    0
.xdata$x:00009BF6                 db    0
.xdata$x:00009BF7                 db    0
.xdata$x:00009BF8                 db    0
.xdata$x:00009BF9                 db    0
.xdata$x:00009BFA                 db    0
.xdata$x:00009BFB                 db    0
.xdata$x:00009BFC                 db    0
.xdata$x:00009BFD                 db    0
.xdata$x:00009BFE                 db    0
.xdata$x:00009BFF                 db    0
.xdata$x:00009C00                 db    0
.xdata$x:00009C01                 db    0
.xdata$x:00009C02                 db    0
.xdata$x:00009C03                 db    0
.xdata$x:00009C03 _xdata$x        ends
.xdata$x:00009C03
.xdata$x:00009C04 ; ===========================================================================
.xdata$x:00009C04
.xdata$x:00009C04 ; Segment type: Pure data
.xdata$x:00009C04 ; Segment permissions: Read
.xdata$x:00009C04 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009C04                 assume cs:_xdata$x
.xdata$x:00009C04                 ;org 9C04h
.xdata$x:00009C04 ; COMDAT (pick associative to section at 3AE4)
.xdata$x:00009C04 __unwindtable$??0_System_error_category@std@@QAE@XZ db 0FFh
.xdata$x:00009C04                                         ; DATA XREF: .xdata$x:00009C14o
.xdata$x:00009C05                 db 0FFh
.xdata$x:00009C06                 db 0FFh
.xdata$x:00009C07                 db 0FFh
.xdata$x:00009C08                 dd offset __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0
.xdata$x:00009C0C __ehfuncinfo$??0_System_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:00009C0C                                         ; DATA XREF: __ehhandler$??0_System_error_category@std@@QAE@XZ+11o
.xdata$x:00009C0D                 db    5
.xdata$x:00009C0E                 db  93h ; ô
.xdata$x:00009C0F                 db  19h
.xdata$x:00009C10                 db    1
.xdata$x:00009C11                 db    0
.xdata$x:00009C12                 db    0
.xdata$x:00009C13                 db    0
.xdata$x:00009C14                 dd offset __unwindtable$??0_System_error_category@std@@QAE@XZ
.xdata$x:00009C18                 db    0
.xdata$x:00009C19                 db    0
.xdata$x:00009C1A                 db    0
.xdata$x:00009C1B                 db    0
.xdata$x:00009C1C                 db    0
.xdata$x:00009C1D                 db    0
.xdata$x:00009C1E                 db    0
.xdata$x:00009C1F                 db    0
.xdata$x:00009C20                 db    0
.xdata$x:00009C21                 db    0
.xdata$x:00009C22                 db    0
.xdata$x:00009C23                 db    0
.xdata$x:00009C24                 db    0
.xdata$x:00009C25                 db    0
.xdata$x:00009C26                 db    0
.xdata$x:00009C27                 db    0
.xdata$x:00009C28                 db    0
.xdata$x:00009C29                 db    0
.xdata$x:00009C2A                 db    0
.xdata$x:00009C2B                 db    0
.xdata$x:00009C2C                 db    0
.xdata$x:00009C2D                 db    0
.xdata$x:00009C2E                 db    0
.xdata$x:00009C2F                 db    0
.xdata$x:00009C2F _xdata$x        ends
.xdata$x:00009C2F
.xdata$x:00009C30 ; ===========================================================================
.xdata$x:00009C30
.xdata$x:00009C30 ; Segment type: Pure data
.xdata$x:00009C30 ; Segment permissions: Read
.xdata$x:00009C30 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009C30                 assume cs:_xdata$x
.xdata$x:00009C30                 ;org 9C30h
.xdata$x:00009C30 ; COMDAT (pick associative to section at 9350)
.xdata$x:00009C30 __unwindtable$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:00009C30                                         ; DATA XREF: .xdata$x:00009C40o
.xdata$x:00009C31                 db 0FFh
.xdata$x:00009C32                 db 0FFh
.xdata$x:00009C33                 db 0FFh
.xdata$x:00009C34                 dd offset __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:00009C38 __ehfuncinfo$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:00009C38                                         ; DATA XREF: __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:00009C39                 db    5
.xdata$x:00009C3A                 db  93h ; ô
.xdata$x:00009C3B                 db  19h
.xdata$x:00009C3C                 db    1
.xdata$x:00009C3D                 db    0
.xdata$x:00009C3E                 db    0
.xdata$x:00009C3F                 db    0
.xdata$x:00009C40                 dd offset __unwindtable$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:00009C44                 db    0
.xdata$x:00009C45                 db    0
.xdata$x:00009C46                 db    0
.xdata$x:00009C47                 db    0
.xdata$x:00009C48                 db    0
.xdata$x:00009C49                 db    0
.xdata$x:00009C4A                 db    0
.xdata$x:00009C4B                 db    0
.xdata$x:00009C4C                 db    0
.xdata$x:00009C4D                 db    0
.xdata$x:00009C4E                 db    0
.xdata$x:00009C4F                 db    0
.xdata$x:00009C50                 db    0
.xdata$x:00009C51                 db    0
.xdata$x:00009C52                 db    0
.xdata$x:00009C53                 db    0
.xdata$x:00009C54                 db    0
.xdata$x:00009C55                 db    0
.xdata$x:00009C56                 db    0
.xdata$x:00009C57                 db    0
.xdata$x:00009C58                 db    0
.xdata$x:00009C59                 db    0
.xdata$x:00009C5A                 db    0
.xdata$x:00009C5B                 db    0
.xdata$x:00009C5B _xdata$x        ends
.xdata$x:00009C5B
.xdata$x:00009C5C ; ===========================================================================
.xdata$x:00009C5C
.xdata$x:00009C5C ; Segment type: Pure data
.xdata$x:00009C5C ; Segment permissions: Read
.xdata$x:00009C5C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009C5C                 assume cs:_xdata$x
.xdata$x:00009C5C                 ;org 9C5Ch
.xdata$x:00009C5C ; COMDAT (pick associative to section at 5180)
.xdata$x:00009C5C __unwindtable$??1_System_error_category@std@@UAE@XZ db 0FFh
.xdata$x:00009C5C                                         ; DATA XREF: .xdata$x:00009C6Co
.xdata$x:00009C5D                 db 0FFh
.xdata$x:00009C5E                 db 0FFh
.xdata$x:00009C5F                 db 0FFh
.xdata$x:00009C60                 dd offset __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0
.xdata$x:00009C64 __ehfuncinfo$??1_System_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:00009C64                                         ; DATA XREF: __ehhandler$??1_System_error_category@std@@UAE@XZ+11o
.xdata$x:00009C65                 db    5
.xdata$x:00009C66                 db  93h ; ô
.xdata$x:00009C67                 db  19h
.xdata$x:00009C68                 db    1
.xdata$x:00009C69                 db    0
.xdata$x:00009C6A                 db    0
.xdata$x:00009C6B                 db    0
.xdata$x:00009C6C                 dd offset __unwindtable$??1_System_error_category@std@@UAE@XZ
.xdata$x:00009C70                 db    0
.xdata$x:00009C71                 db    0
.xdata$x:00009C72                 db    0
.xdata$x:00009C73                 db    0
.xdata$x:00009C74                 db    0
.xdata$x:00009C75                 db    0
.xdata$x:00009C76                 db    0
.xdata$x:00009C77                 db    0
.xdata$x:00009C78                 db    0
.xdata$x:00009C79                 db    0
.xdata$x:00009C7A                 db    0
.xdata$x:00009C7B                 db    0
.xdata$x:00009C7C                 db    0
.xdata$x:00009C7D                 db    0
.xdata$x:00009C7E                 db    0
.xdata$x:00009C7F                 db    0
.xdata$x:00009C80                 db    0
.xdata$x:00009C81                 db    0
.xdata$x:00009C82                 db    0
.xdata$x:00009C83                 db    0
.xdata$x:00009C84                 db    0
.xdata$x:00009C85                 db    0
.xdata$x:00009C86                 db    0
.xdata$x:00009C87                 db    0
.xdata$x:00009C87 _xdata$x        ends
.xdata$x:00009C87
.xdata$x:00009C88 ; ===========================================================================
.xdata$x:00009C88
.xdata$x:00009C88 ; Segment type: Pure data
.xdata$x:00009C88 ; Segment permissions: Read
.xdata$x:00009C88 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009C88                 assume cs:_xdata$x
.xdata$x:00009C88                 ;org 9C88h
.xdata$x:00009C88 ; COMDAT (pick associative to section at 455C)
.xdata$x:00009C88 __unwindtable$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00009C88                                         ; DATA XREF: .xdata$x:00009C98o
.xdata$x:00009C89                 db 0FFh
.xdata$x:00009C8A                 db 0FFh
.xdata$x:00009C8B                 db 0FFh
.xdata$x:00009C8C                 dd offset __unwindfunclet$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0
.xdata$x:00009C90 __ehfuncinfo$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00009C90                                         ; DATA XREF: __ehhandler$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ+11o
.xdata$x:00009C91                 db    5
.xdata$x:00009C92                 db  93h ; ô
.xdata$x:00009C93                 db  19h
.xdata$x:00009C94                 db    1
.xdata$x:00009C95                 db    0
.xdata$x:00009C96                 db    0
.xdata$x:00009C97                 db    0
.xdata$x:00009C98                 dd offset __unwindtable$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.xdata$x:00009C9C                 db    0
.xdata$x:00009C9D                 db    0
.xdata$x:00009C9E                 db    0
.xdata$x:00009C9F                 db    0
.xdata$x:00009CA0                 db    0
.xdata$x:00009CA1                 db    0
.xdata$x:00009CA2                 db    0
.xdata$x:00009CA3                 db    0
.xdata$x:00009CA4                 db    0
.xdata$x:00009CA5                 db    0
.xdata$x:00009CA6                 db    0
.xdata$x:00009CA7                 db    0
.xdata$x:00009CA8                 db    0
.xdata$x:00009CA9                 db    0
.xdata$x:00009CAA                 db    0
.xdata$x:00009CAB                 db    0
.xdata$x:00009CAC                 db    0
.xdata$x:00009CAD                 db    0
.xdata$x:00009CAE                 db    0
.xdata$x:00009CAF                 db    0
.xdata$x:00009CB0                 db    0
.xdata$x:00009CB1                 db    0
.xdata$x:00009CB2                 db    0
.xdata$x:00009CB3                 db    0
.xdata$x:00009CB3 _xdata$x        ends
.xdata$x:00009CB3
.xdata$x:00009CB4 ; ===========================================================================
.xdata$x:00009CB4
.xdata$x:00009CB4 ; Segment type: Pure data
.xdata$x:00009CB4 ; Segment permissions: Read
.xdata$x:00009CB4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009CB4                 assume cs:_xdata$x
.xdata$x:00009CB4                 ;org 9CB4h
.xdata$x:00009CB4 ; COMDAT (pick associative to section at 4474)
.xdata$x:00009CB4 __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00009CB4                                         ; DATA XREF: .xdata$x:00009CC4o
.xdata$x:00009CB5                 db 0FFh
.xdata$x:00009CB6                 db 0FFh
.xdata$x:00009CB7                 db 0FFh
.xdata$x:00009CB8                 dd offset __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ$0
.xdata$x:00009CBC __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00009CBC                                         ; DATA XREF: __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:00009CBD                 db    5
.xdata$x:00009CBE                 db  93h ; ô
.xdata$x:00009CBF                 db  19h
.xdata$x:00009CC0                 db    1
.xdata$x:00009CC1                 db    0
.xdata$x:00009CC2                 db    0
.xdata$x:00009CC3                 db    0
.xdata$x:00009CC4                 dd offset __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
.xdata$x:00009CC8                 align 20h
.xdata$x:00009CC8 _xdata$x        ends
.xdata$x:00009CC8
.xdata$x:00009CE0 ; ===========================================================================
.xdata$x:00009CE0
.xdata$x:00009CE0 ; Segment type: Pure data
.xdata$x:00009CE0 ; Segment permissions: Read
.xdata$x:00009CE0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009CE0                 assume cs:_xdata$x
.xdata$x:00009CE0                 ;org 9CE0h
.xdata$x:00009CE0 ; COMDAT (pick associative to section at 49D8)
.xdata$x:00009CE0 __unwindtable$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ db 0FFh
.xdata$x:00009CE0                                         ; DATA XREF: .xdata$x:00009CF0o
.xdata$x:00009CE1                 db 0FFh
.xdata$x:00009CE2                 db 0FFh
.xdata$x:00009CE3                 db 0FFh
.xdata$x:00009CE4                 dd offset __unwindfunclet$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ$0
.xdata$x:00009CE8 __ehfuncinfo$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ db  22h ; "
.xdata$x:00009CE8                                         ; DATA XREF: __ehhandler$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ+11o
.xdata$x:00009CE9                 db    5
.xdata$x:00009CEA                 db  93h ; ô
.xdata$x:00009CEB                 db  19h
.xdata$x:00009CEC                 db    1
.xdata$x:00009CED                 db    0
.xdata$x:00009CEE                 db    0
.xdata$x:00009CEF                 db    0
.xdata$x:00009CF0                 dd offset __unwindtable$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.xdata$x:00009CF4                 db    0
.xdata$x:00009CF5                 db    0
.xdata$x:00009CF6                 db    0
.xdata$x:00009CF7                 db    0
.xdata$x:00009CF8                 db    0
.xdata$x:00009CF9                 db    0
.xdata$x:00009CFA                 db    0
.xdata$x:00009CFB                 db    0
.xdata$x:00009CFC                 db    0
.xdata$x:00009CFD                 db    0
.xdata$x:00009CFE                 db    0
.xdata$x:00009CFF                 db    0
.xdata$x:00009D00                 db    0
.xdata$x:00009D01                 db    0
.xdata$x:00009D02                 db    0
.xdata$x:00009D03                 db    0
.xdata$x:00009D04                 db    0
.xdata$x:00009D05                 db    0
.xdata$x:00009D06                 db    0
.xdata$x:00009D07                 db    0
.xdata$x:00009D08                 db    0
.xdata$x:00009D09                 db    0
.xdata$x:00009D0A                 db    0
.xdata$x:00009D0B                 db    0
.xdata$x:00009D0B _xdata$x        ends
.xdata$x:00009D0B
.xdata$x:00009D0C ; ===========================================================================
.xdata$x:00009D0C
.xdata$x:00009D0C ; Segment type: Pure data
.xdata$x:00009D0C ; Segment permissions: Read
.xdata$x:00009D0C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009D0C                 assume cs:_xdata$x
.xdata$x:00009D0C                 ;org 9D0Ch
.xdata$x:00009D0C ; COMDAT (pick associative to section at 3844)
.xdata$x:00009D0C __unwindtable$??0ScintillaEditView@@QAE@XZ db 0FFh
.xdata$x:00009D0C                                         ; DATA XREF: .xdata$x:00009D24o
.xdata$x:00009D0D                 db 0FFh
.xdata$x:00009D0E                 db 0FFh
.xdata$x:00009D0F                 db 0FFh
.xdata$x:00009D10                 dd offset __unwindfunclet$??0ScintillaEditView@@QAE@XZ$0
.xdata$x:00009D14                 align 8
.xdata$x:00009D18                 dd offset __unwindfunclet$??0ScintillaEditView@@QAE@XZ$1
.xdata$x:00009D1C __ehfuncinfo$??0ScintillaEditView@@QAE@XZ db  22h ; "
.xdata$x:00009D1C                                         ; DATA XREF: __ehhandler$??0ScintillaEditView@@QAE@XZ+11o
.xdata$x:00009D1D                 db    5
.xdata$x:00009D1E                 db  93h ; ô
.xdata$x:00009D1F                 db  19h
.xdata$x:00009D20                 db    2
.xdata$x:00009D21                 db    0
.xdata$x:00009D22                 db    0
.xdata$x:00009D23                 db    0
.xdata$x:00009D24                 dd offset __unwindtable$??0ScintillaEditView@@QAE@XZ
.xdata$x:00009D28                 align 20h
.xdata$x:00009D28 _xdata$x        ends
.xdata$x:00009D28
.xdata$x:00009D40 ; ===========================================================================
.xdata$x:00009D40
.xdata$x:00009D40 ; Segment type: Pure data
.xdata$x:00009D40 ; Segment permissions: Read
.xdata$x:00009D40 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009D40                 assume cs:_xdata$x
.xdata$x:00009D40                 ;org 9D40h
.xdata$x:00009D40 ; COMDAT (pick associative to section at 4D8C)
.xdata$x:00009D40 __ehfuncinfo$??1ScintillaEditView@@UAE@XZ db  22h ; "
.xdata$x:00009D40                                         ; DATA XREF: __ehhandler$??1ScintillaEditView@@UAE@XZ+11o
.xdata$x:00009D41                 db    5
.xdata$x:00009D42                 db  93h ; ô
.xdata$x:00009D43                 db  19h
.xdata$x:00009D44                 db    6
.xdata$x:00009D45                 db    0
.xdata$x:00009D46                 db    0
.xdata$x:00009D47                 db    0
.xdata$x:00009D48                 dd offset __unwindtable$??1ScintillaEditView@@UAE@XZ
.xdata$x:00009D4C                 db    0
.xdata$x:00009D4D                 db    0
.xdata$x:00009D4E                 db    0
.xdata$x:00009D4F                 db    0
.xdata$x:00009D50                 db    0
.xdata$x:00009D51                 db    0
.xdata$x:00009D52                 db    0
.xdata$x:00009D53                 db    0
.xdata$x:00009D54                 db    0
.xdata$x:00009D55                 db    0
.xdata$x:00009D56                 db    0
.xdata$x:00009D57                 db    0
.xdata$x:00009D58                 db    0
.xdata$x:00009D59                 db    0
.xdata$x:00009D5A                 db    0
.xdata$x:00009D5B                 db    0
.xdata$x:00009D5C                 db    0
.xdata$x:00009D5D                 db    0
.xdata$x:00009D5E                 db    0
.xdata$x:00009D5F                 db    0
.xdata$x:00009D60                 db    0
.xdata$x:00009D61                 db    0
.xdata$x:00009D62                 db    0
.xdata$x:00009D63                 db    0
.xdata$x:00009D64 __unwindtable$??1ScintillaEditView@@UAE@XZ db 0FFh
.xdata$x:00009D64                                         ; DATA XREF: .xdata$x:00009D48o
.xdata$x:00009D65                 db 0FFh
.xdata$x:00009D66                 db 0FFh
.xdata$x:00009D67                 db 0FFh
.xdata$x:00009D68                 dd offset __unwindfunclet$??1ScintillaEditView@@UAE@XZ$0
.xdata$x:00009D6C                 align 10h
.xdata$x:00009D70                 dd offset __unwindfunclet$??1ScintillaEditView@@UAE@XZ$1
.xdata$x:00009D74                 db    1
.xdata$x:00009D75                 db    0
.xdata$x:00009D76                 db    0
.xdata$x:00009D77                 db    0
.xdata$x:00009D78                 dd offset __unwindfunclet$??1ScintillaEditView@@UAE@XZ$2
.xdata$x:00009D7C                 db    2
.xdata$x:00009D7D                 db    0
.xdata$x:00009D7E                 db    0
.xdata$x:00009D7F                 db    0
.xdata$x:00009D80                 dd offset __unwindfunclet$??1ScintillaEditView@@UAE@XZ$3
.xdata$x:00009D84                 db    2
.xdata$x:00009D85                 db    0
.xdata$x:00009D86                 db    0
.xdata$x:00009D87                 db    0
.xdata$x:00009D88                 dd offset __unwindfunclet$??1ScintillaEditView@@UAE@XZ$4
.xdata$x:00009D8C                 db    4
.xdata$x:00009D8D                 db    0
.xdata$x:00009D8E                 db    0
.xdata$x:00009D8F                 db    0
.xdata$x:00009D90                 dd offset __unwindfunclet$??1ScintillaEditView@@UAE@XZ$5
.xdata$x:00009D90 _xdata$x        ends
.xdata$x:00009D90
.xdata$x:00009D94 ; ===========================================================================
.xdata$x:00009D94
.xdata$x:00009D94 ; Segment type: Pure data
.xdata$x:00009D94 ; Segment permissions: Read
.xdata$x:00009D94 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009D94                 assume cs:_xdata$x
.xdata$x:00009D94                 ;org 9D94h
.xdata$x:00009D94 ; COMDAT (pick associative to section at 2DC0)
.xdata$x:00009D94 __unwindtable$??0?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00009D94                                         ; DATA XREF: .xdata$x:00009DA4o
.xdata$x:00009D95                 db 0FFh
.xdata$x:00009D96                 db 0FFh
.xdata$x:00009D97                 db 0FFh
.xdata$x:00009D98                 dd offset __unwindfunclet$??0?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@QAE@XZ$0
.xdata$x:00009D9C __ehfuncinfo$??0?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00009D9C                                         ; DATA XREF: __ehhandler$??0?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:00009D9D                 db    5
.xdata$x:00009D9E                 db  93h ; ô
.xdata$x:00009D9F                 db  19h
.xdata$x:00009DA0                 db    1
.xdata$x:00009DA1                 db    0
.xdata$x:00009DA2                 db    0
.xdata$x:00009DA3                 db    0
.xdata$x:00009DA4                 dd offset __unwindtable$??0?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@QAE@XZ
.xdata$x:00009DA8                 align 20h
.xdata$x:00009DA8 _xdata$x        ends
.xdata$x:00009DA8
.xdata$x:00009DC0 ; ===========================================================================
.xdata$x:00009DC0
.xdata$x:00009DC0 ; Segment type: Pure data
.xdata$x:00009DC0 ; Segment permissions: Read
.xdata$x:00009DC0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009DC0                 assume cs:_xdata$x
.xdata$x:00009DC0                 ;org 9DC0h
.xdata$x:00009DC0 ; COMDAT (pick associative to section at 438C)
.xdata$x:00009DC0 __unwindtable$??1?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00009DC0                                         ; DATA XREF: .xdata$x:00009DD0o
.xdata$x:00009DC1                 db 0FFh
.xdata$x:00009DC2                 db 0FFh
.xdata$x:00009DC3                 db 0FFh
.xdata$x:00009DC4                 dd offset __unwindfunclet$??1?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@QAE@XZ$0
.xdata$x:00009DC8 __ehfuncinfo$??1?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00009DC8                                         ; DATA XREF: __ehhandler$??1?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:00009DC9                 db    5
.xdata$x:00009DCA                 db  93h ; ô
.xdata$x:00009DCB                 db  19h
.xdata$x:00009DCC                 db    1
.xdata$x:00009DCD                 db    0
.xdata$x:00009DCE                 db    0
.xdata$x:00009DCF                 db    0
.xdata$x:00009DD0                 dd offset __unwindtable$??1?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@QAE@XZ
.xdata$x:00009DD4                 db    0
.xdata$x:00009DD5                 db    0
.xdata$x:00009DD6                 db    0
.xdata$x:00009DD7                 db    0
.xdata$x:00009DD8                 db    0
.xdata$x:00009DD9                 db    0
.xdata$x:00009DDA                 db    0
.xdata$x:00009DDB                 db    0
.xdata$x:00009DDC                 db    0
.xdata$x:00009DDD                 db    0
.xdata$x:00009DDE                 db    0
.xdata$x:00009DDF                 db    0
.xdata$x:00009DE0                 db    0
.xdata$x:00009DE1                 db    0
.xdata$x:00009DE2                 db    0
.xdata$x:00009DE3                 db    0
.xdata$x:00009DE4                 db    0
.xdata$x:00009DE5                 db    0
.xdata$x:00009DE6                 db    0
.xdata$x:00009DE7                 db    0
.xdata$x:00009DE8                 db    0
.xdata$x:00009DE9                 db    0
.xdata$x:00009DEA                 db    0
.xdata$x:00009DEB                 db    0
.xdata$x:00009DEB _xdata$x        ends
.xdata$x:00009DEB
.xdata$x:00009DEC ; ===========================================================================
.xdata$x:00009DEC
.xdata$x:00009DEC ; Segment type: Pure data
.xdata$x:00009DEC ; Segment permissions: Read
.xdata$x:00009DEC _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009DEC                 assume cs:_xdata$x
.xdata$x:00009DEC                 ;org 9DECh
.xdata$x:00009DEC ; COMDAT (pick associative to section at 2934)
.xdata$x:00009DEC __catchsym$??0?$_List_alloc@$0A@U?$_List_base_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@1@@Z$3 db    0
.xdata$x:00009DEC                                         ; DATA XREF: .xdata$x:00009E0Co
.xdata$x:00009DED                 db    0
.xdata$x:00009DEE                 db    0
.xdata$x:00009DEF                 db    0
.xdata$x:00009DF0                 db    0
.xdata$x:00009DF1                 db    0
.xdata$x:00009DF2                 db    0
.xdata$x:00009DF3                 db    0
.xdata$x:00009DF4                 db    0
.xdata$x:00009DF5                 db    0
.xdata$x:00009DF6                 db    0
.xdata$x:00009DF7                 db    0
.xdata$x:00009DF8                 dd offset __catch$??0?$_List_alloc@$0A@U?$_List_base_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@1@@Z$0
.xdata$x:00009DFC __tryblocktable$??0?$_List_alloc@$0A@U?$_List_base_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@1@@Z db    1
.xdata$x:00009DFC                                         ; DATA XREF: .xdata$x:00009E38o
.xdata$x:00009DFD                 db    0
.xdata$x:00009DFE                 db    0
.xdata$x:00009DFF                 db    0
.xdata$x:00009E00                 db    1
.xdata$x:00009E01                 db    0
.xdata$x:00009E02                 db    0
.xdata$x:00009E03                 db    0
.xdata$x:00009E04                 db    2
.xdata$x:00009E05                 db    0
.xdata$x:00009E06                 db    0
.xdata$x:00009E07                 db    0
.xdata$x:00009E08                 db    1
.xdata$x:00009E09                 db    0
.xdata$x:00009E0A                 db    0
.xdata$x:00009E0B                 db    0
.xdata$x:00009E0C                 dd offset __catchsym$??0?$_List_alloc@$0A@U?$_List_base_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@1@@Z$3
.xdata$x:00009E10 __unwindtable$??0?$_List_alloc@$0A@U?$_List_base_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@1@@Z db 0FFh
.xdata$x:00009E10                                         ; DATA XREF: .xdata$x:00009E30o
.xdata$x:00009E11                 db 0FFh
.xdata$x:00009E12                 db 0FFh
.xdata$x:00009E13                 db 0FFh
.xdata$x:00009E14                 dd offset __unwindfunclet$??0?$_List_alloc@$0A@U?$_List_base_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@1@@Z$2
.xdata$x:00009E18                 db    0
.xdata$x:00009E19                 db    0
.xdata$x:00009E1A                 db    0
.xdata$x:00009E1B                 db    0
.xdata$x:00009E1C                 db    0
.xdata$x:00009E1D                 db    0
.xdata$x:00009E1E                 db    0
.xdata$x:00009E1F                 db    0
.xdata$x:00009E20                 db    0
.xdata$x:00009E21                 db    0
.xdata$x:00009E22                 db    0
.xdata$x:00009E23                 db    0
.xdata$x:00009E24                 db    0
.xdata$x:00009E25                 db    0
.xdata$x:00009E26                 db    0
.xdata$x:00009E27                 db    0
.xdata$x:00009E28 __ehfuncinfo$??0?$_List_alloc@$0A@U?$_List_base_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@1@@Z db  22h ; "
.xdata$x:00009E28                                         ; DATA XREF: __ehhandler$??0?$_List_alloc@$0A@U?$_List_base_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@1@@Z+11o
.xdata$x:00009E29                 db    5
.xdata$x:00009E2A                 db  93h ; ô
.xdata$x:00009E2B                 db  19h
.xdata$x:00009E2C                 db    3
.xdata$x:00009E2D                 db    0
.xdata$x:00009E2E                 db    0
.xdata$x:00009E2F                 db    0
.xdata$x:00009E30                 dd offset __unwindtable$??0?$_List_alloc@$0A@U?$_List_base_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@1@@Z
.xdata$x:00009E34                 db    1
.xdata$x:00009E35                 db    0
.xdata$x:00009E36                 db    0
.xdata$x:00009E37                 db    0
.xdata$x:00009E38                 dd offset __tryblocktable$??0?$_List_alloc@$0A@U?$_List_base_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@1@@Z
.xdata$x:00009E3C                 db    0
.xdata$x:00009E3D                 db    0
.xdata$x:00009E3E                 db    0
.xdata$x:00009E3F                 db    0
.xdata$x:00009E40                 db    0
.xdata$x:00009E41                 db    0
.xdata$x:00009E42                 db    0
.xdata$x:00009E43                 db    0
.xdata$x:00009E44                 db    0
.xdata$x:00009E45                 db    0
.xdata$x:00009E46                 db    0
.xdata$x:00009E47                 db    0
.xdata$x:00009E48                 db    0
.xdata$x:00009E49                 db    0
.xdata$x:00009E4A                 db    0
.xdata$x:00009E4B                 db    0
.xdata$x:00009E4B _xdata$x        ends
.xdata$x:00009E4B
.xdata$x:00009E4C ; ===========================================================================
.xdata$x:00009E4C
.xdata$x:00009E4C ; Segment type: Pure data
.xdata$x:00009E4C ; Segment permissions: Read
.xdata$x:00009E4C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009E4C                 assume cs:_xdata$x
.xdata$x:00009E4C                 ;org 9E4Ch
.xdata$x:00009E4C ; COMDAT (pick associative to section at 3F14)
.xdata$x:00009E4C __unwindtable$??1?$_List_alloc@$0A@U?$_List_base_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00009E4C                                         ; DATA XREF: .xdata$x:00009E5Co
.xdata$x:00009E4D                 db 0FFh
.xdata$x:00009E4E                 db 0FFh
.xdata$x:00009E4F                 db 0FFh
.xdata$x:00009E50                 dd offset __unwindfunclet$??1?$_List_alloc@$0A@U?$_List_base_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@@std@@QAE@XZ$0
.xdata$x:00009E54 __ehfuncinfo$??1?$_List_alloc@$0A@U?$_List_base_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00009E54                                         ; DATA XREF: __ehhandler$??1?$_List_alloc@$0A@U?$_List_base_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@@std@@QAE@XZ+11o
.xdata$x:00009E55                 db    5
.xdata$x:00009E56                 db  93h ; ô
.xdata$x:00009E57                 db  19h
.xdata$x:00009E58                 db    1
.xdata$x:00009E59                 db    0
.xdata$x:00009E5A                 db    0
.xdata$x:00009E5B                 db    0
.xdata$x:00009E5C                 dd offset __unwindtable$??1?$_List_alloc@$0A@U?$_List_base_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@@std@@QAE@XZ
.xdata$x:00009E60                 db    0
.xdata$x:00009E61                 db    0
.xdata$x:00009E62                 db    0
.xdata$x:00009E63                 db    0
.xdata$x:00009E64                 db    0
.xdata$x:00009E65                 db    0
.xdata$x:00009E66                 db    0
.xdata$x:00009E67                 db    0
.xdata$x:00009E68                 db    0
.xdata$x:00009E69                 db    0
.xdata$x:00009E6A                 db    0
.xdata$x:00009E6B                 db    0
.xdata$x:00009E6C                 db    0
.xdata$x:00009E6D                 db    0
.xdata$x:00009E6E                 db    0
.xdata$x:00009E6F                 db    0
.xdata$x:00009E70                 db    0
.xdata$x:00009E71                 db    0
.xdata$x:00009E72                 db    0
.xdata$x:00009E73                 db    0
.xdata$x:00009E74                 db    0
.xdata$x:00009E75                 db    0
.xdata$x:00009E76                 db    0
.xdata$x:00009E77                 db    0
.xdata$x:00009E77 _xdata$x        ends
.xdata$x:00009E77
.xdata$x:00009E78 ; ===========================================================================
.xdata$x:00009E78
.xdata$x:00009E78 ; Segment type: Pure data
.xdata$x:00009E78 ; Segment permissions: Read
.xdata$x:00009E78 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009E78                 assume cs:_xdata$x
.xdata$x:00009E78                 ;org 9E78h
.xdata$x:00009E78 ; COMDAT (pick associative to section at 60F0)
.xdata$x:00009E78 __catchsym$?_Buynode0@?$_List_alloc@$0A@U?$_List_base_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@@std@@QAEPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@2 db    0
.xdata$x:00009E78                                         ; DATA XREF: .xdata$x:00009EA8o
.xdata$x:00009E79                 db    0
.xdata$x:00009E7A                 db    0
.xdata$x:00009E7B                 db    0
.xdata$x:00009E7C                 db    0
.xdata$x:00009E7D                 db    0
.xdata$x:00009E7E                 db    0
.xdata$x:00009E7F                 db    0
.xdata$x:00009E80                 db    0
.xdata$x:00009E81                 db    0
.xdata$x:00009E82                 db    0
.xdata$x:00009E83                 db    0
.xdata$x:00009E84                 dd offset __catch$?_Buynode0@?$_List_alloc@$0A@U?$_List_base_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@@std@@QAEPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@2@PAU32@0@Z$0
.xdata$x:00009E88 __unwindtable$?_Buynode0@?$_List_alloc@$0A@U?$_List_base_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@@std@@QAEPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PA db 0FFh
.xdata$x:00009E88                                         ; DATA XREF: .xdata$x:00009EB4o
.xdata$x:00009E89                 db 0FFh
.xdata$x:00009E8A                 db 0FFh
.xdata$x:00009E8B                 db 0FFh
.xdata$x:00009E8C                 db    0
.xdata$x:00009E8D                 db    0
.xdata$x:00009E8E                 db    0
.xdata$x:00009E8F                 db    0
.xdata$x:00009E90                 db 0FFh
.xdata$x:00009E91                 db 0FFh
.xdata$x:00009E92                 db 0FFh
.xdata$x:00009E93                 db 0FFh
.xdata$x:00009E94                 db    0
.xdata$x:00009E95                 db    0
.xdata$x:00009E96                 db    0
.xdata$x:00009E97                 db    0
.xdata$x:00009E98 __tryblocktable$?_Buynode0@?$_List_alloc@$0A@U?$_List_base_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@@std@@QAEPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@ db    0
.xdata$x:00009E98                                         ; DATA XREF: .xdata$x:00009EBCo
.xdata$x:00009E99                 db    0
.xdata$x:00009E9A                 db    0
.xdata$x:00009E9B                 db    0
.xdata$x:00009E9C                 db    0
.xdata$x:00009E9D                 db    0
.xdata$x:00009E9E                 db    0
.xdata$x:00009E9F                 db    0
.xdata$x:00009EA0                 db    1
.xdata$x:00009EA1                 db    0
.xdata$x:00009EA2                 db    0
.xdata$x:00009EA3                 db    0
.xdata$x:00009EA4                 db    1
.xdata$x:00009EA5                 db    0
.xdata$x:00009EA6                 db    0
.xdata$x:00009EA7                 db    0
.xdata$x:00009EA8                 dd offset __catchsym$?_Buynode0@?$_List_alloc@$0A@U?$_List_base_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@@std@@QAEPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@2@PAU32@0@Z$2
.xdata$x:00009EAC __ehfuncinfo$?_Buynode0@?$_List_alloc@$0A@U?$_List_base_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@@std@@QAEPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX db  22h ; "
.xdata$x:00009EAC                                         ; DATA XREF: __ehhandler$?_Buynode0@?$_List_alloc@$0A@U?$_List_base_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@@std@@QAEPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@2@PAU32@0@Z+11o
.xdata$x:00009EAD                 db    5
.xdata$x:00009EAE                 db  93h ; ô
.xdata$x:00009EAF                 db  19h
.xdata$x:00009EB0                 db    2
.xdata$x:00009EB1                 db    0
.xdata$x:00009EB2                 db    0
.xdata$x:00009EB3                 db    0
.xdata$x:00009EB4                 dd offset __unwindtable$?_Buynode0@?$_List_alloc@$0A@U?$_List_base_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@@std@@QAEPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@2@PAU32@0@Z
.xdata$x:00009EB8                 db    1
.xdata$x:00009EB9                 db    0
.xdata$x:00009EBA                 db    0
.xdata$x:00009EBB                 db    0
.xdata$x:00009EBC                 dd offset __tryblocktable$?_Buynode0@?$_List_alloc@$0A@U?$_List_base_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@@std@@QAEPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@2@PAU32@0@Z
.xdata$x:00009EC0                 db    0
.xdata$x:00009EC1                 db    0
.xdata$x:00009EC2                 db    0
.xdata$x:00009EC3                 db    0
.xdata$x:00009EC4                 db    0
.xdata$x:00009EC5                 db    0
.xdata$x:00009EC6                 db    0
.xdata$x:00009EC7                 db    0
.xdata$x:00009EC8                 db    0
.xdata$x:00009EC9                 db    0
.xdata$x:00009ECA                 db    0
.xdata$x:00009ECB                 db    0
.xdata$x:00009ECC                 db    0
.xdata$x:00009ECD                 db    0
.xdata$x:00009ECE                 db    0
.xdata$x:00009ECF                 db    0
.xdata$x:00009ECF _xdata$x        ends
.xdata$x:00009ECF
.xdata$x:00009ED0 ; ===========================================================================
.xdata$x:00009ED0
.xdata$x:00009ED0 ; Segment type: Pure data
.xdata$x:00009ED0 ; Segment permissions: Read
.xdata$x:00009ED0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009ED0                 assume cs:_xdata$x
.xdata$x:00009ED0                 ;org 9ED0h
.xdata$x:00009ED0 ; COMDAT (pick associative to section at 29FC)
.xdata$x:00009ED0 __unwindtable$??0?$_List_buy@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@1@@Z db 0FFh
.xdata$x:00009ED0                                         ; DATA XREF: .xdata$x:00009EE0o
.xdata$x:00009ED1                 db 0FFh
.xdata$x:00009ED2                 db 0FFh
.xdata$x:00009ED3                 db 0FFh
.xdata$x:00009ED4                 dd offset __unwindfunclet$??0?$_List_buy@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@1@@Z$0
.xdata$x:00009ED8 __ehfuncinfo$??0?$_List_buy@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@1@@Z db  22h ; "
.xdata$x:00009ED8                                         ; DATA XREF: __ehhandler$??0?$_List_buy@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@1@@Z+11o
.xdata$x:00009ED9                 db    5
.xdata$x:00009EDA                 db  93h ; ô
.xdata$x:00009EDB                 db  19h
.xdata$x:00009EDC                 db    1
.xdata$x:00009EDD                 db    0
.xdata$x:00009EDE                 db    0
.xdata$x:00009EDF                 db    0
.xdata$x:00009EE0                 dd offset __unwindtable$??0?$_List_buy@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@1@@Z
.xdata$x:00009EE4                 db    0
.xdata$x:00009EE5                 db    0
.xdata$x:00009EE6                 db    0
.xdata$x:00009EE7                 db    0
.xdata$x:00009EE8                 db    0
.xdata$x:00009EE9                 db    0
.xdata$x:00009EEA                 db    0
.xdata$x:00009EEB                 db    0
.xdata$x:00009EEC                 db    0
.xdata$x:00009EED                 db    0
.xdata$x:00009EEE                 db    0
.xdata$x:00009EEF                 db    0
.xdata$x:00009EF0                 db    0
.xdata$x:00009EF1                 db    0
.xdata$x:00009EF2                 db    0
.xdata$x:00009EF3                 db    0
.xdata$x:00009EF4                 db    0
.xdata$x:00009EF5                 db    0
.xdata$x:00009EF6                 db    0
.xdata$x:00009EF7                 db    0
.xdata$x:00009EF8                 db    0
.xdata$x:00009EF9                 db    0
.xdata$x:00009EFA                 db    0
.xdata$x:00009EFB                 db    0
.xdata$x:00009EFB _xdata$x        ends
.xdata$x:00009EFB
.xdata$x:00009EFC ; ===========================================================================
.xdata$x:00009EFC
.xdata$x:00009EFC ; Segment type: Pure data
.xdata$x:00009EFC ; Segment permissions: Read
.xdata$x:00009EFC _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009EFC                 assume cs:_xdata$x
.xdata$x:00009EFC                 ;org 9EFCh
.xdata$x:00009EFC ; COMDAT (pick associative to section at 400C)
.xdata$x:00009EFC __unwindtable$??1?$_List_buy@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAE@XZ db 0FFh
.xdata$x:00009EFC                                         ; DATA XREF: .xdata$x:00009F0Co
.xdata$x:00009EFD                 db 0FFh
.xdata$x:00009EFE                 db 0FFh
.xdata$x:00009EFF                 db 0FFh
.xdata$x:00009F00                 dd offset __unwindfunclet$??1?$_List_buy@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAE@XZ$0
.xdata$x:00009F04 __ehfuncinfo$??1?$_List_buy@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAE@XZ db  22h ; "
.xdata$x:00009F04                                         ; DATA XREF: __ehhandler$??1?$_List_buy@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAE@XZ+11o
.xdata$x:00009F05                 db    5
.xdata$x:00009F06                 db  93h ; ô
.xdata$x:00009F07                 db  19h
.xdata$x:00009F08                 db    1
.xdata$x:00009F09                 db    0
.xdata$x:00009F0A                 db    0
.xdata$x:00009F0B                 db    0
.xdata$x:00009F0C                 dd offset __unwindtable$??1?$_List_buy@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAE@XZ
.xdata$x:00009F10                 db    0
.xdata$x:00009F11                 db    0
.xdata$x:00009F12                 db    0
.xdata$x:00009F13                 db    0
.xdata$x:00009F14                 db    0
.xdata$x:00009F15                 db    0
.xdata$x:00009F16                 db    0
.xdata$x:00009F17                 db    0
.xdata$x:00009F18                 db    0
.xdata$x:00009F19                 db    0
.xdata$x:00009F1A                 db    0
.xdata$x:00009F1B                 db    0
.xdata$x:00009F1C                 db    0
.xdata$x:00009F1D                 db    0
.xdata$x:00009F1E                 db    0
.xdata$x:00009F1F                 db    0
.xdata$x:00009F20                 db    0
.xdata$x:00009F21                 db    0
.xdata$x:00009F22                 db    0
.xdata$x:00009F23                 db    0
.xdata$x:00009F24                 db    0
.xdata$x:00009F25                 db    0
.xdata$x:00009F26                 db    0
.xdata$x:00009F27                 db    0
.xdata$x:00009F27 _xdata$x        ends
.xdata$x:00009F27
.xdata$x:00009F28 ; ===========================================================================
.xdata$x:00009F28
.xdata$x:00009F28 ; Segment type: Pure data
.xdata$x:00009F28 ; Segment permissions: Read
.xdata$x:00009F28 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009F28                 assume cs:_xdata$x
.xdata$x:00009F28                 ;org 9F28h
.xdata$x:00009F28 ; COMDAT (pick associative to section at 36C4)
.xdata$x:00009F28 __unwindtable$??0?$list@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@1@@Z db 0FFh
.xdata$x:00009F28                                         ; DATA XREF: .xdata$x:00009F38o
.xdata$x:00009F29                 db 0FFh
.xdata$x:00009F2A                 db 0FFh
.xdata$x:00009F2B                 db 0FFh
.xdata$x:00009F2C                 dd offset __unwindfunclet$??0?$list@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@1@@Z$0
.xdata$x:00009F30 __ehfuncinfo$??0?$list@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@1@@Z db  22h ; "
.xdata$x:00009F30                                         ; DATA XREF: __ehhandler$??0?$list@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@1@@Z+11o
.xdata$x:00009F31                 db    5
.xdata$x:00009F32                 db  93h ; ô
.xdata$x:00009F33                 db  19h
.xdata$x:00009F34                 db    1
.xdata$x:00009F35                 db    0
.xdata$x:00009F36                 db    0
.xdata$x:00009F37                 db    0
.xdata$x:00009F38                 dd offset __unwindtable$??0?$list@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@1@@Z
.xdata$x:00009F3C                 db    0
.xdata$x:00009F3D                 db    0
.xdata$x:00009F3E                 db    0
.xdata$x:00009F3F                 db    0
.xdata$x:00009F40                 db    0
.xdata$x:00009F41                 db    0
.xdata$x:00009F42                 db    0
.xdata$x:00009F43                 db    0
.xdata$x:00009F44                 db    0
.xdata$x:00009F45                 db    0
.xdata$x:00009F46                 db    0
.xdata$x:00009F47                 db    0
.xdata$x:00009F48                 db    0
.xdata$x:00009F49                 db    0
.xdata$x:00009F4A                 db    0
.xdata$x:00009F4B                 db    0
.xdata$x:00009F4C                 db    0
.xdata$x:00009F4D                 db    0
.xdata$x:00009F4E                 db    0
.xdata$x:00009F4F                 db    0
.xdata$x:00009F50                 db    0
.xdata$x:00009F51                 db    0
.xdata$x:00009F52                 db    0
.xdata$x:00009F53                 db    0
.xdata$x:00009F53 _xdata$x        ends
.xdata$x:00009F53
.xdata$x:00009F54 ; ===========================================================================
.xdata$x:00009F54
.xdata$x:00009F54 ; Segment type: Pure data
.xdata$x:00009F54 ; Segment permissions: Read
.xdata$x:00009F54 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009F54                 assume cs:_xdata$x
.xdata$x:00009F54                 ;org 9F54h
.xdata$x:00009F54 ; COMDAT (pick associative to section at 4ACC)
.xdata$x:00009F54 __unwindtable$??1?$list@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAE@XZ db 0FFh
.xdata$x:00009F54                                         ; DATA XREF: .xdata$x:00009F64o
.xdata$x:00009F55                 db 0FFh
.xdata$x:00009F56                 db 0FFh
.xdata$x:00009F57                 db 0FFh
.xdata$x:00009F58                 dd offset __unwindfunclet$??1?$list@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAE@XZ$0
.xdata$x:00009F5C __ehfuncinfo$??1?$list@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAE@XZ db  22h ; "
.xdata$x:00009F5C                                         ; DATA XREF: __ehhandler$??1?$list@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAE@XZ+11o
.xdata$x:00009F5D                 db    5
.xdata$x:00009F5E                 db  93h ; ô
.xdata$x:00009F5F                 db  19h
.xdata$x:00009F60                 db    1
.xdata$x:00009F61                 db    0
.xdata$x:00009F62                 db    0
.xdata$x:00009F63                 db    0
.xdata$x:00009F64                 dd offset __unwindtable$??1?$list@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAE@XZ
.xdata$x:00009F68                 align 20h
.xdata$x:00009F68 _xdata$x        ends
.xdata$x:00009F68
.xdata$x:00009F80 ; ===========================================================================
.xdata$x:00009F80
.xdata$x:00009F80 ; Segment type: Pure data
.xdata$x:00009F80 ; Segment permissions: Read
.xdata$x:00009F80 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009F80                 assume cs:_xdata$x
.xdata$x:00009F80                 ;org 9F80h
.xdata$x:00009F80 ; COMDAT (pick associative to section at 81B4)
.xdata$x:00009F80 __unwindtable$?begin@?$list@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std db 0FFh
.xdata$x:00009F80                                         ; DATA XREF: .xdata$x:00009F90o
.xdata$x:00009F81                 db 0FFh
.xdata$x:00009F82                 db 0FFh
.xdata$x:00009F83                 db 0FFh
.xdata$x:00009F84                 dd offset __unwindfunclet$?begin@?$list@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@XZ$0
.xdata$x:00009F88 __ehfuncinfo$?begin@?$list@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@ db  22h ; "
.xdata$x:00009F88                                         ; DATA XREF: __ehhandler$?begin@?$list@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@XZ+11o
.xdata$x:00009F89                 db    5
.xdata$x:00009F8A                 db  93h ; ô
.xdata$x:00009F8B                 db  19h
.xdata$x:00009F8C                 db    1
.xdata$x:00009F8D                 db    0
.xdata$x:00009F8E                 db    0
.xdata$x:00009F8F                 db    0
.xdata$x:00009F90                 dd offset __unwindtable$?begin@?$list@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@XZ
.xdata$x:00009F94                 db    0
.xdata$x:00009F95                 db    0
.xdata$x:00009F96                 db    0
.xdata$x:00009F97                 db    0
.xdata$x:00009F98                 db    0
.xdata$x:00009F99                 db    0
.xdata$x:00009F9A                 db    0
.xdata$x:00009F9B                 db    0
.xdata$x:00009F9C                 db    0
.xdata$x:00009F9D                 db    0
.xdata$x:00009F9E                 db    0
.xdata$x:00009F9F                 db    0
.xdata$x:00009FA0                 db    0
.xdata$x:00009FA1                 db    0
.xdata$x:00009FA2                 db    0
.xdata$x:00009FA3                 db    0
.xdata$x:00009FA4                 db    0
.xdata$x:00009FA5                 db    0
.xdata$x:00009FA6                 db    0
.xdata$x:00009FA7                 db    0
.xdata$x:00009FA8                 db    0
.xdata$x:00009FA9                 db    0
.xdata$x:00009FAA                 db    0
.xdata$x:00009FAB                 db    0
.xdata$x:00009FAB _xdata$x        ends
.xdata$x:00009FAB
.xdata$x:00009FAC ; ===========================================================================
.xdata$x:00009FAC
.xdata$x:00009FAC ; Segment type: Pure data
.xdata$x:00009FAC ; Segment permissions: Read
.xdata$x:00009FAC _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009FAC                 assume cs:_xdata$x
.xdata$x:00009FAC                 ;org 9FACh
.xdata$x:00009FAC ; COMDAT (pick associative to section at 8B10)
.xdata$x:00009FAC __unwindtable$?end@?$list@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@ db 0FFh
.xdata$x:00009FAC                                         ; DATA XREF: .xdata$x:00009FBCo
.xdata$x:00009FAD                 db 0FFh
.xdata$x:00009FAE                 db 0FFh
.xdata$x:00009FAF                 db 0FFh
.xdata$x:00009FB0                 dd offset __unwindfunclet$?end@?$list@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@XZ$0
.xdata$x:00009FB4 __ehfuncinfo$?end@?$list@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@ db  22h ; "
.xdata$x:00009FB4                                         ; DATA XREF: __ehhandler$?end@?$list@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@XZ+11o
.xdata$x:00009FB5                 db    5
.xdata$x:00009FB6                 db  93h ; ô
.xdata$x:00009FB7                 db  19h
.xdata$x:00009FB8                 db    1
.xdata$x:00009FB9                 db    0
.xdata$x:00009FBA                 db    0
.xdata$x:00009FBB                 db    0
.xdata$x:00009FBC                 dd offset __unwindtable$?end@?$list@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@XZ
.xdata$x:00009FC0                 db    0
.xdata$x:00009FC1                 db    0
.xdata$x:00009FC2                 db    0
.xdata$x:00009FC3                 db    0
.xdata$x:00009FC4                 db    0
.xdata$x:00009FC5                 db    0
.xdata$x:00009FC6                 db    0
.xdata$x:00009FC7                 db    0
.xdata$x:00009FC8                 db    0
.xdata$x:00009FC9                 db    0
.xdata$x:00009FCA                 db    0
.xdata$x:00009FCB                 db    0
.xdata$x:00009FCC                 db    0
.xdata$x:00009FCD                 db    0
.xdata$x:00009FCE                 db    0
.xdata$x:00009FCF                 db    0
.xdata$x:00009FD0                 db    0
.xdata$x:00009FD1                 db    0
.xdata$x:00009FD2                 db    0
.xdata$x:00009FD3                 db    0
.xdata$x:00009FD4                 db    0
.xdata$x:00009FD5                 db    0
.xdata$x:00009FD6                 db    0
.xdata$x:00009FD7                 db    0
.xdata$x:00009FD7 _xdata$x        ends
.xdata$x:00009FD7
.xdata$x:00009FD8 ; ===========================================================================
.xdata$x:00009FD8
.xdata$x:00009FD8 ; Segment type: Pure data
.xdata$x:00009FD8 ; Segment permissions: Read
.xdata$x:00009FD8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009FD8                 assume cs:_xdata$x
.xdata$x:00009FD8                 ;org 9FD8h
.xdata$x:00009FD8 ; COMDAT (pick associative to section at 7424)
.xdata$x:00009FD8 __unwindtable$?_Orphan_ptr@?$list@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QBEXAAV12@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@2@@Z db 0FFh
.xdata$x:00009FD8                                         ; DATA XREF: .xdata$x:00009FE8o
.xdata$x:00009FD9                 db 0FFh
.xdata$x:00009FDA                 db 0FFh
.xdata$x:00009FDB                 db 0FFh
.xdata$x:00009FDC                 dd offset __unwindfunclet$?_Orphan_ptr@?$list@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QBEXAAV12@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@2@@Z$0
.xdata$x:00009FE0 __ehfuncinfo$?_Orphan_ptr@?$list@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QBEXAAV12@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@2@@Z db  22h ; "
.xdata$x:00009FE0                                         ; DATA XREF: __ehhandler$?_Orphan_ptr@?$list@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QBEXAAV12@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@2@@Z+11o
.xdata$x:00009FE1                 db    5
.xdata$x:00009FE2                 db  93h ; ô
.xdata$x:00009FE3                 db  19h
.xdata$x:00009FE4                 db    1
.xdata$x:00009FE5                 db    0
.xdata$x:00009FE6                 db    0
.xdata$x:00009FE7                 db    0
.xdata$x:00009FE8                 dd offset __unwindtable$?_Orphan_ptr@?$list@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@2@@std@@QBEXAAV12@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@2@@Z
.xdata$x:00009FEC                 db    0
.xdata$x:00009FED                 db    0
.xdata$x:00009FEE                 db    0
.xdata$x:00009FEF                 db    0
.xdata$x:00009FF0                 db    0
.xdata$x:00009FF1                 db    0
.xdata$x:00009FF2                 db    0
.xdata$x:00009FF3                 db    0
.xdata$x:00009FF4                 db    0
.xdata$x:00009FF5                 db    0
.xdata$x:00009FF6                 db    0
.xdata$x:00009FF7                 db    0
.xdata$x:00009FF8                 db    0
.xdata$x:00009FF9                 db    0
.xdata$x:00009FFA                 db    0
.xdata$x:00009FFB                 db    0
.xdata$x:00009FFC                 db    0
.xdata$x:00009FFD                 db    0
.xdata$x:00009FFE                 db    0
.xdata$x:00009FFF                 db    0
.xdata$x:0000A000                 db    0
.xdata$x:0000A001                 db    0
.xdata$x:0000A002                 db    0
.xdata$x:0000A003                 db    0
.xdata$x:0000A003 _xdata$x        ends
.xdata$x:0000A003
.xdata$x:0000A004 ; ===========================================================================
.xdata$x:0000A004
.xdata$x:0000A004 ; Segment type: Pure data
.xdata$x:0000A004 ; Segment permissions: Read
.xdata$x:0000A004 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A004                 assume cs:_xdata$x
.xdata$x:0000A004                 ;org 0A004h
.xdata$x:0000A004 ; COMDAT (pick associative to section at 2578)
.xdata$x:0000A004 __unwindtable$??0?$_Hash@V?$_Umap_traits@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@V?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@$0A@@std@@@std@@QAE@ABV?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@1@ABV?$allocator db 0FFh
.xdata$x:0000A004                                         ; DATA XREF: .xdata$x:0000A01Co
.xdata$x:0000A005                 db 0FFh
.xdata$x:0000A006                 db 0FFh
.xdata$x:0000A007                 db 0FFh
.xdata$x:0000A008                 dd offset __unwindfunclet$??0?$_Hash@V?$_Umap_traits@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@V?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@$0A@@std@@@std@@QAE@ABV?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@1@ABV?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@1@@Z$0
.xdata$x:0000A00C                 align 10h
.xdata$x:0000A010                 dd offset __unwindfunclet$??0?$_Hash@V?$_Umap_traits@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@V?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@$0A@@std@@@std@@QAE@ABV?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@1@ABV?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@1@@Z$1
.xdata$x:0000A014 __ehfuncinfo$??0?$_Hash@V?$_Umap_traits@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@V?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@$0A@@std@@@std@@QAE@ABV?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@1@ABV?$allocator@ db  22h ; "
.xdata$x:0000A014                                         ; DATA XREF: __ehhandler$??0?$_Hash@V?$_Umap_traits@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@V?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@$0A@@std@@@std@@QAE@ABV?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@1@ABV?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@1@@Z+11o
.xdata$x:0000A015                 db    5
.xdata$x:0000A016                 db  93h ; ô
.xdata$x:0000A017                 db  19h
.xdata$x:0000A018                 db    2
.xdata$x:0000A019                 db    0
.xdata$x:0000A01A                 db    0
.xdata$x:0000A01B                 db    0
.xdata$x:0000A01C                 dd offset __unwindtable$??0?$_Hash@V?$_Umap_traits@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@V?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@$0A@@std@@@std@@QAE@ABV?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@1@ABV?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@1@@Z
.xdata$x:0000A020                 db    0
.xdata$x:0000A021                 db    0
.xdata$x:0000A022                 db    0
.xdata$x:0000A023                 db    0
.xdata$x:0000A024                 db    0
.xdata$x:0000A025                 db    0
.xdata$x:0000A026                 db    0
.xdata$x:0000A027                 db    0
.xdata$x:0000A028                 db    0
.xdata$x:0000A029                 db    0
.xdata$x:0000A02A                 db    0
.xdata$x:0000A02B                 db    0
.xdata$x:0000A02C                 db    0
.xdata$x:0000A02D                 db    0
.xdata$x:0000A02E                 db    0
.xdata$x:0000A02F                 db    0
.xdata$x:0000A030                 db    0
.xdata$x:0000A031                 db    0
.xdata$x:0000A032                 db    0
.xdata$x:0000A033                 db    0
.xdata$x:0000A034                 db    0
.xdata$x:0000A035                 db    0
.xdata$x:0000A036                 db    0
.xdata$x:0000A037                 db    0
.xdata$x:0000A037 _xdata$x        ends
.xdata$x:0000A037
.xdata$x:0000A038 ; ===========================================================================
.xdata$x:0000A038
.xdata$x:0000A038 ; Segment type: Pure data
.xdata$x:0000A038 ; Segment permissions: Read
.xdata$x:0000A038 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A038                 assume cs:_xdata$x
.xdata$x:0000A038                 ;org 0A038h
.xdata$x:0000A038 ; COMDAT (pick associative to section at 3C40)
.xdata$x:0000A038 __unwindtable$??1?$_Hash@V?$_Umap_traits@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@V?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@$0A@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000A038                                         ; DATA XREF: .xdata$x:0000A050o
.xdata$x:0000A039                 db 0FFh
.xdata$x:0000A03A                 db 0FFh
.xdata$x:0000A03B                 db 0FFh
.xdata$x:0000A03C                 dd offset __unwindfunclet$??1?$_Hash@V?$_Umap_traits@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@V?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@$0A@@std@@@std@@QAE@XZ$0
.xdata$x:0000A040                 db    0
.xdata$x:0000A041                 db    0
.xdata$x:0000A042                 db    0
.xdata$x:0000A043                 db    0
.xdata$x:0000A044                 dd offset __unwindfunclet$??1?$_Hash@V?$_Umap_traits@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@V?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@$0A@@std@@@std@@QAE@XZ$1
.xdata$x:0000A048 __ehfuncinfo$??1?$_Hash@V?$_Umap_traits@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@V?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@$0A@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000A048                                         ; DATA XREF: __ehhandler$??1?$_Hash@V?$_Umap_traits@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@V?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@$0A@@std@@@std@@QAE@XZ+11o
.xdata$x:0000A049                 db    5
.xdata$x:0000A04A                 db  93h ; ô
.xdata$x:0000A04B                 db  19h
.xdata$x:0000A04C                 db    2
.xdata$x:0000A04D                 db    0
.xdata$x:0000A04E                 db    0
.xdata$x:0000A04F                 db    0
.xdata$x:0000A050                 dd offset __unwindtable$??1?$_Hash@V?$_Umap_traits@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@V?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@$0A@@std@@@std@@QAE@XZ
.xdata$x:0000A054                 db    0
.xdata$x:0000A055                 db    0
.xdata$x:0000A056                 db    0
.xdata$x:0000A057                 db    0
.xdata$x:0000A058                 db    0
.xdata$x:0000A059                 db    0
.xdata$x:0000A05A                 db    0
.xdata$x:0000A05B                 db    0
.xdata$x:0000A05C                 db    0
.xdata$x:0000A05D                 db    0
.xdata$x:0000A05E                 db    0
.xdata$x:0000A05F                 db    0
.xdata$x:0000A060                 db    0
.xdata$x:0000A061                 db    0
.xdata$x:0000A062                 db    0
.xdata$x:0000A063                 db    0
.xdata$x:0000A064                 db    0
.xdata$x:0000A065                 db    0
.xdata$x:0000A066                 db    0
.xdata$x:0000A067                 db    0
.xdata$x:0000A068                 db    0
.xdata$x:0000A069                 db    0
.xdata$x:0000A06A                 db    0
.xdata$x:0000A06B                 db    0
.xdata$x:0000A06B _xdata$x        ends
.xdata$x:0000A06B
.xdata$x:0000A06C ; ===========================================================================
.xdata$x:0000A06C
.xdata$x:0000A06C ; Segment type: Pure data
.xdata$x:0000A06C ; Segment permissions: Read
.xdata$x:0000A06C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A06C                 assume cs:_xdata$x
.xdata$x:0000A06C                 ;org 0A06Ch
.xdata$x:0000A06C ; COMDAT (pick associative to section at 8078)
.xdata$x:0000A06C __unwindtable$?begin@?$_Hash@V?$_Umap_traits@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@V?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUS db 0FFh
.xdata$x:0000A06C                                         ; DATA XREF: .xdata$x:0000A07Co
.xdata$x:0000A06D                 db 0FFh
.xdata$x:0000A06E                 db 0FFh
.xdata$x:0000A06F                 db 0FFh
.xdata$x:0000A070                 dd offset __unwindfunclet$?begin@?$_Hash@V?$_Umap_traits@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@V?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@XZ$0
.xdata$x:0000A074 __ehfuncinfo$?begin@?$_Hash@V?$_Umap_traits@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@V?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUSt db  22h ; "
.xdata$x:0000A074                                         ; DATA XREF: __ehhandler$?begin@?$_Hash@V?$_Umap_traits@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@V?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@XZ+11o
.xdata$x:0000A075                 db    5
.xdata$x:0000A076                 db  93h ; ô
.xdata$x:0000A077                 db  19h
.xdata$x:0000A078                 db    1
.xdata$x:0000A079                 db    0
.xdata$x:0000A07A                 db    0
.xdata$x:0000A07B                 db    0
.xdata$x:0000A07C                 dd offset __unwindtable$?begin@?$_Hash@V?$_Umap_traits@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@V?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@XZ
.xdata$x:0000A080                 db    0
.xdata$x:0000A081                 db    0
.xdata$x:0000A082                 db    0
.xdata$x:0000A083                 db    0
.xdata$x:0000A084                 db    0
.xdata$x:0000A085                 db    0
.xdata$x:0000A086                 db    0
.xdata$x:0000A087                 db    0
.xdata$x:0000A088                 db    0
.xdata$x:0000A089                 db    0
.xdata$x:0000A08A                 db    0
.xdata$x:0000A08B                 db    0
.xdata$x:0000A08C                 db    0
.xdata$x:0000A08D                 db    0
.xdata$x:0000A08E                 db    0
.xdata$x:0000A08F                 db    0
.xdata$x:0000A090                 db    0
.xdata$x:0000A091                 db    0
.xdata$x:0000A092                 db    0
.xdata$x:0000A093                 db    0
.xdata$x:0000A094                 db    0
.xdata$x:0000A095                 db    0
.xdata$x:0000A096                 db    0
.xdata$x:0000A097                 db    0
.xdata$x:0000A097 _xdata$x        ends
.xdata$x:0000A097
.xdata$x:0000A098 ; ===========================================================================
.xdata$x:0000A098
.xdata$x:0000A098 ; Segment type: Pure data
.xdata$x:0000A098 ; Segment permissions: Read
.xdata$x:0000A098 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A098                 assume cs:_xdata$x
.xdata$x:0000A098                 ;org 0A098h
.xdata$x:0000A098 ; COMDAT (pick associative to section at 89E0)
.xdata$x:0000A098 __unwindtable$?end@?$_Hash@V?$_Umap_traits@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@V?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUSty db 0FFh
.xdata$x:0000A098                                         ; DATA XREF: .xdata$x:0000A0A8o
.xdata$x:0000A099                 db 0FFh
.xdata$x:0000A09A                 db 0FFh
.xdata$x:0000A09B                 db 0FFh
.xdata$x:0000A09C                 dd offset __unwindfunclet$?end@?$_Hash@V?$_Umap_traits@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@V?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@XZ$0
.xdata$x:0000A0A0 __ehfuncinfo$?end@?$_Hash@V?$_Umap_traits@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@V?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyl db  22h ; "
.xdata$x:0000A0A0                                         ; DATA XREF: __ehhandler$?end@?$_Hash@V?$_Umap_traits@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@V?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@XZ+11o
.xdata$x:0000A0A1                 db    5
.xdata$x:0000A0A2                 db  93h ; ô
.xdata$x:0000A0A3                 db  19h
.xdata$x:0000A0A4                 db    1
.xdata$x:0000A0A5                 db    0
.xdata$x:0000A0A6                 db    0
.xdata$x:0000A0A7                 db    0
.xdata$x:0000A0A8                 dd offset __unwindtable$?end@?$_Hash@V?$_Umap_traits@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@V?$_Uhash_compare@PAVBuffer@@U?$hash@PAVBuffer@@@std@@U?$equal_to@PAVBuffer@@@3@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@XZ
.xdata$x:0000A0AC                 db    0
.xdata$x:0000A0AD                 db    0
.xdata$x:0000A0AE                 db    0
.xdata$x:0000A0AF                 db    0
.xdata$x:0000A0B0                 db    0
.xdata$x:0000A0B1                 db    0
.xdata$x:0000A0B2                 db    0
.xdata$x:0000A0B3                 db    0
.xdata$x:0000A0B4                 db    0
.xdata$x:0000A0B5                 db    0
.xdata$x:0000A0B6                 db    0
.xdata$x:0000A0B7                 db    0
.xdata$x:0000A0B8                 db    0
.xdata$x:0000A0B9                 db    0
.xdata$x:0000A0BA                 db    0
.xdata$x:0000A0BB                 db    0
.xdata$x:0000A0BC                 db    0
.xdata$x:0000A0BD                 db    0
.xdata$x:0000A0BE                 db    0
.xdata$x:0000A0BF                 db    0
.xdata$x:0000A0C0                 db    0
.xdata$x:0000A0C1                 db    0
.xdata$x:0000A0C2                 db    0
.xdata$x:0000A0C3                 db    0
.xdata$x:0000A0C3 _xdata$x        ends
.xdata$x:0000A0C3
.xdata$x:0000A0C4 ; ===========================================================================
.xdata$x:0000A0C4
.xdata$x:0000A0C4 ; Segment type: Pure data
.xdata$x:0000A0C4 ; Segment permissions: Read
.xdata$x:0000A0C4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A0C4                 assume cs:_xdata$x
.xdata$x:0000A0C4                 ;org 0A0C4h
.xdata$x:0000A0C4 ; COMDAT (pick associative to section at 3404)
.xdata$x:0000A0C4 __unwindtable$??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000A0C4                                         ; DATA XREF: .xdata$x:0000A0D4o
.xdata$x:0000A0C5                 db 0FFh
.xdata$x:0000A0C6                 db 0FFh
.xdata$x:0000A0C7                 db 0FFh
.xdata$x:0000A0C8                 dd offset __unwindfunclet$??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ$0
.xdata$x:0000A0CC __ehfuncinfo$??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000A0CC                                         ; DATA XREF: __ehhandler$??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:0000A0CD                 db    5
.xdata$x:0000A0CE                 db  93h ; ô
.xdata$x:0000A0CF                 db  19h
.xdata$x:0000A0D0                 db    1
.xdata$x:0000A0D1                 db    0
.xdata$x:0000A0D2                 db    0
.xdata$x:0000A0D3                 db    0
.xdata$x:0000A0D4                 dd offset __unwindtable$??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ
.xdata$x:0000A0D8                 db    0
.xdata$x:0000A0D9                 db    0
.xdata$x:0000A0DA                 db    0
.xdata$x:0000A0DB                 db    0
.xdata$x:0000A0DC                 db    0
.xdata$x:0000A0DD                 db    0
.xdata$x:0000A0DE                 db    0
.xdata$x:0000A0DF                 db    0
.xdata$x:0000A0E0                 db    0
.xdata$x:0000A0E1                 db    0
.xdata$x:0000A0E2                 db    0
.xdata$x:0000A0E3                 db    0
.xdata$x:0000A0E4                 db    0
.xdata$x:0000A0E5                 db    0
.xdata$x:0000A0E6                 db    0
.xdata$x:0000A0E7                 db    0
.xdata$x:0000A0E8                 db    0
.xdata$x:0000A0E9                 db    0
.xdata$x:0000A0EA                 db    0
.xdata$x:0000A0EB                 db    0
.xdata$x:0000A0EC                 db    0
.xdata$x:0000A0ED                 db    0
.xdata$x:0000A0EE                 db    0
.xdata$x:0000A0EF                 db    0
.xdata$x:0000A0EF _xdata$x        ends
.xdata$x:0000A0EF
.xdata$x:0000A0F0 ; ===========================================================================
.xdata$x:0000A0F0
.xdata$x:0000A0F0 ; Segment type: Pure data
.xdata$x:0000A0F0 ; Segment permissions: Read
.xdata$x:0000A0F0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A0F0                 assume cs:_xdata$x
.xdata$x:0000A0F0                 ;org 0A0F0h
.xdata$x:0000A0F0 ; COMDAT (pick associative to section at 48EC)
.xdata$x:0000A0F0 __unwindtable$??1?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000A0F0                                         ; DATA XREF: .xdata$x:0000A100o
.xdata$x:0000A0F1                 db 0FFh
.xdata$x:0000A0F2                 db 0FFh
.xdata$x:0000A0F3                 db 0FFh
.xdata$x:0000A0F4                 dd offset __unwindfunclet$??1?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ$0
.xdata$x:0000A0F8 __ehfuncinfo$??1?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000A0F8                                         ; DATA XREF: __ehhandler$??1?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:0000A0F9                 db    5
.xdata$x:0000A0FA                 db  93h ; ô
.xdata$x:0000A0FB                 db  19h
.xdata$x:0000A0FC                 db    1
.xdata$x:0000A0FD                 db    0
.xdata$x:0000A0FE                 db    0
.xdata$x:0000A0FF                 db    0
.xdata$x:0000A100                 dd offset __unwindtable$??1?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ
.xdata$x:0000A104                 db    0
.xdata$x:0000A105                 db    0
.xdata$x:0000A106                 db    0
.xdata$x:0000A107                 db    0
.xdata$x:0000A108                 db    0
.xdata$x:0000A109                 db    0
.xdata$x:0000A10A                 db    0
.xdata$x:0000A10B                 db    0
.xdata$x:0000A10C                 db    0
.xdata$x:0000A10D                 db    0
.xdata$x:0000A10E                 db    0
.xdata$x:0000A10F                 db    0
.xdata$x:0000A110                 db    0
.xdata$x:0000A111                 db    0
.xdata$x:0000A112                 db    0
.xdata$x:0000A113                 db    0
.xdata$x:0000A114                 db    0
.xdata$x:0000A115                 db    0
.xdata$x:0000A116                 db    0
.xdata$x:0000A117                 db    0
.xdata$x:0000A118                 db    0
.xdata$x:0000A119                 db    0
.xdata$x:0000A11A                 db    0
.xdata$x:0000A11B                 db    0
.xdata$x:0000A11B _xdata$x        ends
.xdata$x:0000A11B
.xdata$x:0000A11C ; ===========================================================================
.xdata$x:0000A11C
.xdata$x:0000A11C ; Segment type: Pure data
.xdata$x:0000A11C ; Segment permissions: Read
.xdata$x:0000A11C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A11C                 assume cs:_xdata$x
.xdata$x:0000A11C                 ;org 0A11Ch
.xdata$x:0000A11C ; COMDAT (pick associative to section at 2F80)
.xdata$x:0000A11C __unwindtable$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@ db 0FFh
.xdata$x:0000A11C                                         ; DATA XREF: .xdata$x:0000A12Co
.xdata$x:0000A11D                 db 0FFh
.xdata$x:0000A11E                 db 0FFh
.xdata$x:0000A11F                 db 0FFh
.xdata$x:0000A120                 dd offset __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QAE@ABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@1@@Z$0
.xdata$x:0000A124 __ehfuncinfo$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@ db  22h ; "
.xdata$x:0000A124                                         ; DATA XREF: __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QAE@ABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@1@@Z+11o
.xdata$x:0000A125                 db    5
.xdata$x:0000A126                 db  93h ; ô
.xdata$x:0000A127                 db  19h
.xdata$x:0000A128                 db    1
.xdata$x:0000A129                 db    0
.xdata$x:0000A12A                 db    0
.xdata$x:0000A12B                 db    0
.xdata$x:0000A12C                 dd offset __unwindtable$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QAE@ABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@1@@Z
.xdata$x:0000A130                 db    0
.xdata$x:0000A131                 db    0
.xdata$x:0000A132                 db    0
.xdata$x:0000A133                 db    0
.xdata$x:0000A134                 db    0
.xdata$x:0000A135                 db    0
.xdata$x:0000A136                 db    0
.xdata$x:0000A137                 db    0
.xdata$x:0000A138                 db    0
.xdata$x:0000A139                 db    0
.xdata$x:0000A13A                 db    0
.xdata$x:0000A13B                 db    0
.xdata$x:0000A13C                 db    0
.xdata$x:0000A13D                 db    0
.xdata$x:0000A13E                 db    0
.xdata$x:0000A13F                 db    0
.xdata$x:0000A140                 db    0
.xdata$x:0000A141                 db    0
.xdata$x:0000A142                 db    0
.xdata$x:0000A143                 db    0
.xdata$x:0000A144                 db    0
.xdata$x:0000A145                 db    0
.xdata$x:0000A146                 db    0
.xdata$x:0000A147                 db    0
.xdata$x:0000A147 _xdata$x        ends
.xdata$x:0000A147
.xdata$x:0000A148 ; ===========================================================================
.xdata$x:0000A148
.xdata$x:0000A148 ; Segment type: Pure data
.xdata$x:0000A148 ; Segment permissions: Read
.xdata$x:0000A148 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A148                 assume cs:_xdata$x
.xdata$x:0000A148                 ;org 0A148h
.xdata$x:0000A148 ; COMDAT (pick associative to section at 4644)
.xdata$x:0000A148 __unwindtable$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@ db 0FFh
.xdata$x:0000A148                                         ; DATA XREF: .xdata$x:0000A158o
.xdata$x:0000A149                 db 0FFh
.xdata$x:0000A14A                 db 0FFh
.xdata$x:0000A14B                 db 0FFh
.xdata$x:0000A14C                 dd offset __unwindfunclet$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QAE@XZ$0
.xdata$x:0000A150 __ehfuncinfo$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@ db  22h ; "
.xdata$x:0000A150                                         ; DATA XREF: __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QAE@XZ+11o
.xdata$x:0000A151                 db    5
.xdata$x:0000A152                 db  93h ; ô
.xdata$x:0000A153                 db  19h
.xdata$x:0000A154                 db    1
.xdata$x:0000A155                 db    0
.xdata$x:0000A156                 db    0
.xdata$x:0000A157                 db    0
.xdata$x:0000A158                 dd offset __unwindtable$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QAE@XZ
.xdata$x:0000A15C                 db    0
.xdata$x:0000A15D                 db    0
.xdata$x:0000A15E                 db    0
.xdata$x:0000A15F                 db    0
.xdata$x:0000A160                 db    0
.xdata$x:0000A161                 db    0
.xdata$x:0000A162                 db    0
.xdata$x:0000A163                 db    0
.xdata$x:0000A164                 db    0
.xdata$x:0000A165                 db    0
.xdata$x:0000A166                 db    0
.xdata$x:0000A167                 db    0
.xdata$x:0000A168                 db    0
.xdata$x:0000A169                 db    0
.xdata$x:0000A16A                 db    0
.xdata$x:0000A16B                 db    0
.xdata$x:0000A16C                 db    0
.xdata$x:0000A16D                 db    0
.xdata$x:0000A16E                 db    0
.xdata$x:0000A16F                 db    0
.xdata$x:0000A170                 db    0
.xdata$x:0000A171                 db    0
.xdata$x:0000A172                 db    0
.xdata$x:0000A173                 db    0
.xdata$x:0000A173 _xdata$x        ends
.xdata$x:0000A173
.xdata$x:0000A174 ; ===========================================================================
.xdata$x:0000A174
.xdata$x:0000A174 ; Segment type: Pure data
.xdata$x:0000A174 ; Segment permissions: Read
.xdata$x:0000A174 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A174                 assume cs:_xdata$x
.xdata$x:0000A174                 ;org 0A174h
.xdata$x:0000A174 ; COMDAT (pick associative to section at 37CC)
.xdata$x:0000A174 __unwindtable$??0?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAE@ABU?$_Wrap db 0FFh
.xdata$x:0000A174                                         ; DATA XREF: .xdata$x:0000A184o
.xdata$x:0000A175                 db 0FFh
.xdata$x:0000A176                 db 0FFh
.xdata$x:0000A177                 db 0FFh
.xdata$x:0000A178                 dd offset __unwindfunclet$??0?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAE@ABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@1@@Z$0
.xdata$x:0000A17C __ehfuncinfo$??0?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAE@ABU?$_Wrap_ db  22h ; "
.xdata$x:0000A17C                                         ; DATA XREF: __ehhandler$??0?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAE@ABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@1@@Z+11o
.xdata$x:0000A17D                 db    5
.xdata$x:0000A17E                 db  93h ; ô
.xdata$x:0000A17F                 db  19h
.xdata$x:0000A180                 db    1
.xdata$x:0000A181                 db    0
.xdata$x:0000A182                 db    0
.xdata$x:0000A183                 db    0
.xdata$x:0000A184                 dd offset __unwindtable$??0?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAE@ABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@1@@Z
.xdata$x:0000A188                 align 20h
.xdata$x:0000A188 _xdata$x        ends
.xdata$x:0000A188
.xdata$x:0000A1A0 ; ===========================================================================
.xdata$x:0000A1A0
.xdata$x:0000A1A0 ; Segment type: Pure data
.xdata$x:0000A1A0 ; Segment permissions: Read
.xdata$x:0000A1A0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A1A0                 assume cs:_xdata$x
.xdata$x:0000A1A0                 ;org 0A1A0h
.xdata$x:0000A1A0 ; COMDAT (pick associative to section at 4D14)
.xdata$x:0000A1A0 __unwindtable$??1?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAE@XZ db 0FFh
.xdata$x:0000A1A0                                         ; DATA XREF: .xdata$x:0000A1B0o
.xdata$x:0000A1A1                 db 0FFh
.xdata$x:0000A1A2                 db 0FFh
.xdata$x:0000A1A3                 db 0FFh
.xdata$x:0000A1A4                 dd offset __unwindfunclet$??1?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAE@XZ$0
.xdata$x:0000A1A8 __ehfuncinfo$??1?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAE@XZ db  22h ; "
.xdata$x:0000A1A8                                         ; DATA XREF: __ehhandler$??1?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAE@XZ+11o
.xdata$x:0000A1A9                 db    5
.xdata$x:0000A1AA                 db  93h ; ô
.xdata$x:0000A1AB                 db  19h
.xdata$x:0000A1AC                 db    1
.xdata$x:0000A1AD                 db    0
.xdata$x:0000A1AE                 db    0
.xdata$x:0000A1AF                 db    0
.xdata$x:0000A1B0                 dd offset __unwindtable$??1?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAE@XZ
.xdata$x:0000A1B4                 db    0
.xdata$x:0000A1B5                 db    0
.xdata$x:0000A1B6                 db    0
.xdata$x:0000A1B7                 db    0
.xdata$x:0000A1B8                 db    0
.xdata$x:0000A1B9                 db    0
.xdata$x:0000A1BA                 db    0
.xdata$x:0000A1BB                 db    0
.xdata$x:0000A1BC                 db    0
.xdata$x:0000A1BD                 db    0
.xdata$x:0000A1BE                 db    0
.xdata$x:0000A1BF                 db    0
.xdata$x:0000A1C0                 db    0
.xdata$x:0000A1C1                 db    0
.xdata$x:0000A1C2                 db    0
.xdata$x:0000A1C3                 db    0
.xdata$x:0000A1C4                 db    0
.xdata$x:0000A1C5                 db    0
.xdata$x:0000A1C6                 db    0
.xdata$x:0000A1C7                 db    0
.xdata$x:0000A1C8                 db    0
.xdata$x:0000A1C9                 db    0
.xdata$x:0000A1CA                 db    0
.xdata$x:0000A1CB                 db    0
.xdata$x:0000A1CB _xdata$x        ends
.xdata$x:0000A1CB
.xdata$x:0000A1CC ; ===========================================================================
.xdata$x:0000A1CC
.xdata$x:0000A1CC ; Segment type: Pure data
.xdata$x:0000A1CC ; Segment permissions: Read
.xdata$x:0000A1CC _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A1CC                 assume cs:_xdata$x
.xdata$x:0000A1CC                 ;org 0A1CCh
.xdata$x:0000A1CC ; COMDAT (pick associative to section at 82F8)
.xdata$x:0000A1CC __unwindtable$?begin@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAE?AV?$_V db 0FFh
.xdata$x:0000A1CC                                         ; DATA XREF: .xdata$x:0000A1DCo
.xdata$x:0000A1CD                 db 0FFh
.xdata$x:0000A1CE                 db 0FFh
.xdata$x:0000A1CF                 db 0FFh
.xdata$x:0000A1D0                 dd offset __unwindfunclet$?begin@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@XZ$0
.xdata$x:0000A1D4 __ehfuncinfo$?begin@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAE?AV?$_Ve db  22h ; "
.xdata$x:0000A1D4                                         ; DATA XREF: __ehhandler$?begin@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@XZ+11o
.xdata$x:0000A1D5                 db    5
.xdata$x:0000A1D6                 db  93h ; ô
.xdata$x:0000A1D7                 db  19h
.xdata$x:0000A1D8                 db    1
.xdata$x:0000A1D9                 db    0
.xdata$x:0000A1DA                 db    0
.xdata$x:0000A1DB                 db    0
.xdata$x:0000A1DC                 dd offset __unwindtable$?begin@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@XZ
.xdata$x:0000A1E0                 db    0
.xdata$x:0000A1E1                 db    0
.xdata$x:0000A1E2                 db    0
.xdata$x:0000A1E3                 db    0
.xdata$x:0000A1E4                 db    0
.xdata$x:0000A1E5                 db    0
.xdata$x:0000A1E6                 db    0
.xdata$x:0000A1E7                 db    0
.xdata$x:0000A1E8                 db    0
.xdata$x:0000A1E9                 db    0
.xdata$x:0000A1EA                 db    0
.xdata$x:0000A1EB                 db    0
.xdata$x:0000A1EC                 db    0
.xdata$x:0000A1ED                 db    0
.xdata$x:0000A1EE                 db    0
.xdata$x:0000A1EF                 db    0
.xdata$x:0000A1F0                 db    0
.xdata$x:0000A1F1                 db    0
.xdata$x:0000A1F2                 db    0
.xdata$x:0000A1F3                 db    0
.xdata$x:0000A1F4                 db    0
.xdata$x:0000A1F5                 db    0
.xdata$x:0000A1F6                 db    0
.xdata$x:0000A1F7                 db    0
.xdata$x:0000A1F7 _xdata$x        ends
.xdata$x:0000A1F7
.xdata$x:0000A1F8 ; ===========================================================================
.xdata$x:0000A1F8
.xdata$x:0000A1F8 ; Segment type: Pure data
.xdata$x:0000A1F8 ; Segment permissions: Read
.xdata$x:0000A1F8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A1F8                 assume cs:_xdata$x
.xdata$x:0000A1F8                 ;org 0A1F8h
.xdata$x:0000A1F8 ; COMDAT (pick associative to section at 7F08)
.xdata$x:0000A1F8 __unwindtable$?assign@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAEXIABV? db 0FFh
.xdata$x:0000A1F8                                         ; DATA XREF: .xdata$x:0000A210o
.xdata$x:0000A1F9                 db 0FFh
.xdata$x:0000A1FA                 db 0FFh
.xdata$x:0000A1FB                 db 0FFh
.xdata$x:0000A1FC                 dd offset __unwindfunclet$?assign@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAEXIABV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@@Z$0
.xdata$x:0000A200                 db    0
.xdata$x:0000A201                 db    0
.xdata$x:0000A202                 db    0
.xdata$x:0000A203                 db    0
.xdata$x:0000A204                 dd offset __unwindfunclet$?assign@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAEXIABV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@@Z$1
.xdata$x:0000A208 __ehfuncinfo$?assign@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAEXIABV?$ db  22h ; "
.xdata$x:0000A208                                         ; DATA XREF: __ehhandler$?assign@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAEXIABV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@@Z+11o
.xdata$x:0000A209                 db    5
.xdata$x:0000A20A                 db  93h ; ô
.xdata$x:0000A20B                 db  19h
.xdata$x:0000A20C                 db    2
.xdata$x:0000A20D                 db    0
.xdata$x:0000A20E                 db    0
.xdata$x:0000A20F                 db    0
.xdata$x:0000A210                 dd offset __unwindtable$?assign@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAEXIABV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@@Z
.xdata$x:0000A214                 db    0
.xdata$x:0000A215                 db    0
.xdata$x:0000A216                 db    0
.xdata$x:0000A217                 db    0
.xdata$x:0000A218                 db    0
.xdata$x:0000A219                 db    0
.xdata$x:0000A21A                 db    0
.xdata$x:0000A21B                 db    0
.xdata$x:0000A21C                 db    0
.xdata$x:0000A21D                 db    0
.xdata$x:0000A21E                 db    0
.xdata$x:0000A21F                 db    0
.xdata$x:0000A220                 db    0
.xdata$x:0000A221                 db    0
.xdata$x:0000A222                 db    0
.xdata$x:0000A223                 db    0
.xdata$x:0000A224                 db    0
.xdata$x:0000A225                 db    0
.xdata$x:0000A226                 db    0
.xdata$x:0000A227                 db    0
.xdata$x:0000A228                 db    0
.xdata$x:0000A229                 db    0
.xdata$x:0000A22A                 db    0
.xdata$x:0000A22B                 db    0
.xdata$x:0000A22B _xdata$x        ends
.xdata$x:0000A22B
.xdata$x:0000A22C ; ===========================================================================
.xdata$x:0000A22C
.xdata$x:0000A22C ; Segment type: Pure data
.xdata$x:0000A22C ; Segment permissions: Read
.xdata$x:0000A22C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A22C                 assume cs:_xdata$x
.xdata$x:0000A22C                 ;org 0A22Ch
.xdata$x:0000A22C ; COMDAT (pick associative to section at 8F48)
.xdata$x:0000A22C __unwindtable$?insert@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAE?AV?$_ db 0FFh
.xdata$x:0000A22C                                         ; DATA XREF: .xdata$x:0000A24Co
.xdata$x:0000A22D                 db 0FFh
.xdata$x:0000A22E                 db 0FFh
.xdata$x:0000A22F                 db 0FFh
.xdata$x:0000A230                 dd offset __unwindfunclet$?insert@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocato
.xdata$x:0000A234                 align 8
.xdata$x:0000A238                 dd offset __unwindfunclet$?insert@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocato
.xdata$x:0000A23C                 db    1
.xdata$x:0000A23D                 db    0
.xdata$x:0000A23E                 db    0
.xdata$x:0000A23F                 db    0
.xdata$x:0000A240                 dd offset __unwindfunclet$?insert@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocato
.xdata$x:0000A244 __ehfuncinfo$?insert@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAE?AV?$_V db  22h ; "
.xdata$x:0000A244                                         ; DATA XREF: __ehhandler$?insert@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$
.xdata$x:0000A245                 db    5
.xdata$x:0000A246                 db  93h ; ô
.xdata$x:0000A247                 db  19h
.xdata$x:0000A248                 db    3
.xdata$x:0000A249                 db    0
.xdata$x:0000A24A                 db    0
.xdata$x:0000A24B                 db    0
.xdata$x:0000A24C                 dd offset __unwindtable$?insert@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@
.xdata$x:0000A250                 db    0
.xdata$x:0000A251                 db    0
.xdata$x:0000A252                 db    0
.xdata$x:0000A253                 db    0
.xdata$x:0000A254                 db    0
.xdata$x:0000A255                 db    0
.xdata$x:0000A256                 db    0
.xdata$x:0000A257                 db    0
.xdata$x:0000A258                 db    0
.xdata$x:0000A259                 db    0
.xdata$x:0000A25A                 db    0
.xdata$x:0000A25B                 db    0
.xdata$x:0000A25C                 db    0
.xdata$x:0000A25D                 db    0
.xdata$x:0000A25E                 db    0
.xdata$x:0000A25F                 db    0
.xdata$x:0000A260                 db    0
.xdata$x:0000A261                 db    0
.xdata$x:0000A262                 db    0
.xdata$x:0000A263                 db    0
.xdata$x:0000A264                 db    0
.xdata$x:0000A265                 db    0
.xdata$x:0000A266                 db    0
.xdata$x:0000A267                 db    0
.xdata$x:0000A267 _xdata$x        ends
.xdata$x:0000A267
.xdata$x:0000A268 ; ===========================================================================
.xdata$x:0000A268
.xdata$x:0000A268 ; Segment type: Pure data
.xdata$x:0000A268 ; Segment permissions: Read
.xdata$x:0000A268 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A268                 assume cs:_xdata$x
.xdata$x:0000A268                 ;org 0A268h
.xdata$x:0000A268 ; COMDAT (pick associative to section at 6B7C)
.xdata$x:0000A268 __catchsym$?_Insert_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAE?AV?$_ db    0
.xdata$x:0000A268                                         ; DATA XREF: .xdata$x:0000A2D0o
.xdata$x:0000A269                 db    0
.xdata$x:0000A26A                 db    0
.xdata$x:0000A26B                 db    0
.xdata$x:0000A26C                 db    0
.xdata$x:0000A26D                 db    0
.xdata$x:0000A26E                 db    0
.xdata$x:0000A26F                 db    0
.xdata$x:0000A270                 db    0
.xdata$x:0000A271                 db    0
.xdata$x:0000A272                 db    0
.xdata$x:0000A273                 db    0
.xdata$x:0000A274                 dd offset __catch$?_Insert_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$
.xdata$x:0000A278 __catchsym$?_Insert_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAE?AV?$_ db    0
.xdata$x:0000A278                                         ; DATA XREF: .xdata$x:0000A2BCo
.xdata$x:0000A279                 db    0
.xdata$x:0000A27A                 db    0
.xdata$x:0000A27B                 db    0
.xdata$x:0000A27C                 db    0
.xdata$x:0000A27D                 db    0
.xdata$x:0000A27E                 db    0
.xdata$x:0000A27F                 db    0
.xdata$x:0000A280                 db    0
.xdata$x:0000A281                 db    0
.xdata$x:0000A282                 db    0
.xdata$x:0000A283                 db    0
.xdata$x:0000A284                 dd offset __catch$?_Insert_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$
.xdata$x:0000A288 __ehfuncinfo$?_Insert_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAE?AV? db  22h ; "
.xdata$x:0000A288                                         ; DATA XREF: __ehhandler$?_Insert_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@
.xdata$x:0000A289                 db    5
.xdata$x:0000A28A                 db  93h ; ô
.xdata$x:0000A28B                 db  19h
.xdata$x:0000A28C                 db    7
.xdata$x:0000A28D                 db    0
.xdata$x:0000A28E                 db    0
.xdata$x:0000A28F                 db    0
.xdata$x:0000A290                 dd offset __unwindtable$?_Insert_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocat
.xdata$x:0000A294                 db    2
.xdata$x:0000A295                 db    0
.xdata$x:0000A296                 db    0
.xdata$x:0000A297                 db    0
.xdata$x:0000A298                 dd offset __tryblocktable$?_Insert_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$alloc
.xdata$x:0000A29C                 db    0
.xdata$x:0000A29D                 db    0
.xdata$x:0000A29E                 db    0
.xdata$x:0000A29F                 db    0
.xdata$x:0000A2A0                 db    0
.xdata$x:0000A2A1                 db    0
.xdata$x:0000A2A2                 db    0
.xdata$x:0000A2A3                 db    0
.xdata$x:0000A2A4                 db    0
.xdata$x:0000A2A5                 db    0
.xdata$x:0000A2A6                 db    0
.xdata$x:0000A2A7                 db    0
.xdata$x:0000A2A8                 db    0
.xdata$x:0000A2A9                 db    0
.xdata$x:0000A2AA                 db    0
.xdata$x:0000A2AB                 db    0
.xdata$x:0000A2AC __tryblocktable$?_Insert_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAE? db    2
.xdata$x:0000A2AC                                         ; DATA XREF: .xdata$x:0000A298o
.xdata$x:0000A2AD                 db    0
.xdata$x:0000A2AE                 db    0
.xdata$x:0000A2AF                 db    0
.xdata$x:0000A2B0                 db    2
.xdata$x:0000A2B1                 db    0
.xdata$x:0000A2B2                 db    0
.xdata$x:0000A2B3                 db    0
.xdata$x:0000A2B4                 db    3
.xdata$x:0000A2B5                 db    0
.xdata$x:0000A2B6                 db    0
.xdata$x:0000A2B7                 db    0
.xdata$x:0000A2B8                 db    1
.xdata$x:0000A2B9                 db    0
.xdata$x:0000A2BA                 db    0
.xdata$x:0000A2BB                 db    0
.xdata$x:0000A2BC                 dd offset __catchsym$?_Insert_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@
.xdata$x:0000A2C0                 db    4
.xdata$x:0000A2C1                 db    0
.xdata$x:0000A2C2                 db    0
.xdata$x:0000A2C3                 db    0
.xdata$x:0000A2C4                 db    4
.xdata$x:0000A2C5                 db    0
.xdata$x:0000A2C6                 db    0
.xdata$x:0000A2C7                 db    0
.xdata$x:0000A2C8                 db    5
.xdata$x:0000A2C9                 db    0
.xdata$x:0000A2CA                 db    0
.xdata$x:0000A2CB                 db    0
.xdata$x:0000A2CC                 db    1
.xdata$x:0000A2CD                 db    0
.xdata$x:0000A2CE                 db    0
.xdata$x:0000A2CF                 db    0
.xdata$x:0000A2D0                 dd offset __catchsym$?_Insert_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@
.xdata$x:0000A2D4 __unwindtable$?_Insert_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAE?AV db 0FFh
.xdata$x:0000A2D4                                         ; DATA XREF: .xdata$x:0000A290o
.xdata$x:0000A2D5                 db 0FFh
.xdata$x:0000A2D6                 db 0FFh
.xdata$x:0000A2D7                 db 0FFh
.xdata$x:0000A2D8                 dd offset __unwindfunclet$?_Insert_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$alloc
.xdata$x:0000A2DC                 align 10h
.xdata$x:0000A2E0                 dd offset __unwindfunclet$?_Insert_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$alloc
.xdata$x:0000A2E4                 db    1
.xdata$x:0000A2E5                 db    0
.xdata$x:0000A2E6                 db    0
.xdata$x:0000A2E7                 db    0
.xdata$x:0000A2E8                 db    0
.xdata$x:0000A2E9                 db    0
.xdata$x:0000A2EA                 db    0
.xdata$x:0000A2EB                 db    0
.xdata$x:0000A2EC                 db    1
.xdata$x:0000A2ED                 db    0
.xdata$x:0000A2EE                 db    0
.xdata$x:0000A2EF                 db    0
.xdata$x:0000A2F0                 db    0
.xdata$x:0000A2F1                 db    0
.xdata$x:0000A2F2                 db    0
.xdata$x:0000A2F3                 db    0
.xdata$x:0000A2F4                 db    1
.xdata$x:0000A2F5                 db    0
.xdata$x:0000A2F6                 db    0
.xdata$x:0000A2F7                 db    0
.xdata$x:0000A2F8                 db    0
.xdata$x:0000A2F9                 db    0
.xdata$x:0000A2FA                 db    0
.xdata$x:0000A2FB                 db    0
.xdata$x:0000A2FC                 db    1
.xdata$x:0000A2FD                 db    0
.xdata$x:0000A2FE                 db    0
.xdata$x:0000A2FF                 db    0
.xdata$x:0000A300                 db    0
.xdata$x:0000A301                 db    0
.xdata$x:0000A302                 db    0
.xdata$x:0000A303                 db    0
.xdata$x:0000A304                 db    1
.xdata$x:0000A305                 db    0
.xdata$x:0000A306                 db    0
.xdata$x:0000A307                 db    0
.xdata$x:0000A308                 dd offset __unwindfunclet$?_Insert_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$alloc
.xdata$x:0000A308 _xdata$x        ends
.xdata$x:0000A308
.xdata$x:0000A30C ; ===========================================================================
.xdata$x:0000A30C
.xdata$x:0000A30C ; Segment type: Pure data
.xdata$x:0000A30C ; Segment permissions: Read
.xdata$x:0000A30C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A30C                 assume cs:_xdata$x
.xdata$x:0000A30C                 ;org 0A30Ch
.xdata$x:0000A30C ; COMDAT (pick associative to section at 75E8)
.xdata$x:0000A30C __unwindtable$?_Orphan_range@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IB db 0FFh
.xdata$x:0000A30C                                         ; DATA XREF: .xdata$x:0000A31Co
.xdata$x:0000A30D                 db 0FFh
.xdata$x:0000A30E                 db 0FFh
.xdata$x:0000A30F                 db 0FFh
.xdata$x:0000A310                 dd offset __unwindfunclet$?_Orphan_range@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IBEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@0@Z$0
.xdata$x:0000A314 __ehfuncinfo$?_Orphan_range@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IBE db  22h ; "
.xdata$x:0000A314                                         ; DATA XREF: __ehhandler$?_Orphan_range@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IBEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@0@Z+11o
.xdata$x:0000A315                 db    5
.xdata$x:0000A316                 db  93h ; ô
.xdata$x:0000A317                 db  19h
.xdata$x:0000A318                 db    1
.xdata$x:0000A319                 db    0
.xdata$x:0000A31A                 db    0
.xdata$x:0000A31B                 db    0
.xdata$x:0000A31C                 dd offset __unwindtable$?_Orphan_range@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IBEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@0@Z
.xdata$x:0000A320                 db    0
.xdata$x:0000A321                 db    0
.xdata$x:0000A322                 db    0
.xdata$x:0000A323                 db    0
.xdata$x:0000A324                 db    0
.xdata$x:0000A325                 db    0
.xdata$x:0000A326                 db    0
.xdata$x:0000A327                 db    0
.xdata$x:0000A328                 db    0
.xdata$x:0000A329                 db    0
.xdata$x:0000A32A                 db    0
.xdata$x:0000A32B                 db    0
.xdata$x:0000A32C                 db    0
.xdata$x:0000A32D                 db    0
.xdata$x:0000A32E                 db    0
.xdata$x:0000A32F                 db    0
.xdata$x:0000A330                 db    0
.xdata$x:0000A331                 db    0
.xdata$x:0000A332                 db    0
.xdata$x:0000A333                 db    0
.xdata$x:0000A334                 db    0
.xdata$x:0000A335                 db    0
.xdata$x:0000A336                 db    0
.xdata$x:0000A337                 db    0
.xdata$x:0000A337 _xdata$x        ends
.xdata$x:0000A337
.xdata$x:0000A338 ; ===========================================================================
.xdata$x:0000A338
.xdata$x:0000A338 ; Segment type: Pure data
.xdata$x:0000A338 ; Segment permissions: Read
.xdata$x:0000A338 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A338                 assume cs:_xdata$x
.xdata$x:0000A338                 ;org 0A338h
.xdata$x:0000A338 ; COMDAT (pick associative to section at 373C)
.xdata$x:0000A338 __unwindtable$??0?$unordered_map@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@U?$hash@PAVBuffer@@@3@U?$equal_to@PAVBuffer@@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@@std@@QAE@XZ db 0FFh
.xdata$x:0000A338                                         ; DATA XREF: .xdata$x:0000A348o
.xdata$x:0000A339                 db 0FFh
.xdata$x:0000A33A                 db 0FFh
.xdata$x:0000A33B                 db 0FFh
.xdata$x:0000A33C                 dd offset __unwindfunclet$??0?$unordered_map@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@U?$hash@PAVBuffer@@@3@U?$equal_to@PAVBuffer@@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@@std@@QAE@XZ$0
.xdata$x:0000A340 __ehfuncinfo$??0?$unordered_map@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@U?$hash@PAVBuffer@@@3@U?$equal_to@PAVBuffer@@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@@std@@QAE@XZ db  22h ; "
.xdata$x:0000A340                                         ; DATA XREF: __ehhandler$??0?$unordered_map@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@U?$hash@PAVBuffer@@@3@U?$equal_to@PAVBuffer@@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@@std@@QAE@XZ+11o
.xdata$x:0000A341                 db    5
.xdata$x:0000A342                 db  93h ; ô
.xdata$x:0000A343                 db  19h
.xdata$x:0000A344                 db    1
.xdata$x:0000A345                 db    0
.xdata$x:0000A346                 db    0
.xdata$x:0000A347                 db    0
.xdata$x:0000A348                 dd offset __unwindtable$??0?$unordered_map@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@U?$hash@PAVBuffer@@@3@U?$equal_to@PAVBuffer@@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@@std@@QAE@XZ
.xdata$x:0000A34C                 db    0
.xdata$x:0000A34D                 db    0
.xdata$x:0000A34E                 db    0
.xdata$x:0000A34F                 db    0
.xdata$x:0000A350                 db    0
.xdata$x:0000A351                 db    0
.xdata$x:0000A352                 db    0
.xdata$x:0000A353                 db    0
.xdata$x:0000A354                 db    0
.xdata$x:0000A355                 db    0
.xdata$x:0000A356                 db    0
.xdata$x:0000A357                 db    0
.xdata$x:0000A358                 db    0
.xdata$x:0000A359                 db    0
.xdata$x:0000A35A                 db    0
.xdata$x:0000A35B                 db    0
.xdata$x:0000A35C                 db    0
.xdata$x:0000A35D                 db    0
.xdata$x:0000A35E                 db    0
.xdata$x:0000A35F                 db    0
.xdata$x:0000A360                 db    0
.xdata$x:0000A361                 db    0
.xdata$x:0000A362                 db    0
.xdata$x:0000A363                 db    0
.xdata$x:0000A363 _xdata$x        ends
.xdata$x:0000A363
.xdata$x:0000A364 ; ===========================================================================
.xdata$x:0000A364
.xdata$x:0000A364 ; Segment type: Pure data
.xdata$x:0000A364 ; Segment permissions: Read
.xdata$x:0000A364 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A364                 assume cs:_xdata$x
.xdata$x:0000A364                 ;org 0A364h
.xdata$x:0000A364 ; COMDAT (pick associative to section at 4C2C)
.xdata$x:0000A364 __unwindtable$??1?$unordered_map@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@U?$hash@PAVBuffer@@@3@U?$equal_to@PAVBuffer@@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@@std@@QAE@XZ db 0FFh
.xdata$x:0000A364                                         ; DATA XREF: .xdata$x:0000A374o
.xdata$x:0000A365                 db 0FFh
.xdata$x:0000A366                 db 0FFh
.xdata$x:0000A367                 db 0FFh
.xdata$x:0000A368                 dd offset __unwindfunclet$??1?$unordered_map@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@U?$hash@PAVBuffer@@@3@U?$equal_to@PAVBuffer@@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@@std@@QAE@XZ$0
.xdata$x:0000A36C __ehfuncinfo$??1?$unordered_map@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@U?$hash@PAVBuffer@@@3@U?$equal_to@PAVBuffer@@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@@std@@QAE@XZ db  22h ; "
.xdata$x:0000A36C                                         ; DATA XREF: __ehhandler$??1?$unordered_map@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@U?$hash@PAVBuffer@@@3@U?$equal_to@PAVBuffer@@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@@std@@QAE@XZ+11o
.xdata$x:0000A36D                 db    5
.xdata$x:0000A36E                 db  93h ; ô
.xdata$x:0000A36F                 db  19h
.xdata$x:0000A370                 db    1
.xdata$x:0000A371                 db    0
.xdata$x:0000A372                 db    0
.xdata$x:0000A373                 db    0
.xdata$x:0000A374                 dd offset __unwindtable$??1?$unordered_map@PAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@U?$hash@PAVBuffer@@@3@U?$equal_to@PAVBuffer@@@3@V?$allocator@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@3@@std@@QAE@XZ
.xdata$x:0000A378                 db    0
.xdata$x:0000A379                 db    0
.xdata$x:0000A37A                 db    0
.xdata$x:0000A37B                 db    0
.xdata$x:0000A37C                 db    0
.xdata$x:0000A37D                 db    0
.xdata$x:0000A37E                 db    0
.xdata$x:0000A37F                 db    0
.xdata$x:0000A380                 db    0
.xdata$x:0000A381                 db    0
.xdata$x:0000A382                 db    0
.xdata$x:0000A383                 db    0
.xdata$x:0000A384                 db    0
.xdata$x:0000A385                 db    0
.xdata$x:0000A386                 db    0
.xdata$x:0000A387                 db    0
.xdata$x:0000A388                 db    0
.xdata$x:0000A389                 db    0
.xdata$x:0000A38A                 db    0
.xdata$x:0000A38B                 db    0
.xdata$x:0000A38C                 db    0
.xdata$x:0000A38D                 db    0
.xdata$x:0000A38E                 db    0
.xdata$x:0000A38F                 db    0
.xdata$x:0000A38F _xdata$x        ends
.xdata$x:0000A38F
.xdata$x:0000A390 ; ===========================================================================
.xdata$x:0000A390
.xdata$x:0000A390 ; Segment type: Pure data
.xdata$x:0000A390 ; Segment permissions: Read
.xdata$x:0000A390 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A390                 assume cs:_xdata$x
.xdata$x:0000A390                 ;org 0A390h
.xdata$x:0000A390 ; COMDAT (pick associative to section at 26E8)
.xdata$x:0000A390 __unwindtable$??0?$_Iterator012@Ubidirectional_iterator_tag@std@@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@2@HPBU32@ABU32@U_Iterator_base12@2@@std@@QAE@XZ db 0FFh
.xdata$x:0000A390                                         ; DATA XREF: .xdata$x:0000A3A0o
.xdata$x:0000A391                 db 0FFh
.xdata$x:0000A392                 db 0FFh
.xdata$x:0000A393                 db 0FFh
.xdata$x:0000A394                 dd offset __unwindfunclet$??0?$_Iterator012@Ubidirectional_iterator_tag@std@@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@2@HPBU32@ABU32@U_Iterator_base12@2@@std@@QAE@XZ$0
.xdata$x:0000A398 __ehfuncinfo$??0?$_Iterator012@Ubidirectional_iterator_tag@std@@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@2@HPBU32@ABU32@U_Iterator_base12@2@@std@@QAE@XZ db  22h ; "
.xdata$x:0000A398                                         ; DATA XREF: __ehhandler$??0?$_Iterator012@Ubidirectional_iterator_tag@std@@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@2@HPBU32@ABU32@U_Iterator_base12@2@@std@@QAE@XZ+11o
.xdata$x:0000A399                 db    5
.xdata$x:0000A39A                 db  93h ; ô
.xdata$x:0000A39B                 db  19h
.xdata$x:0000A39C                 db    1
.xdata$x:0000A39D                 db    0
.xdata$x:0000A39E                 db    0
.xdata$x:0000A39F                 db    0
.xdata$x:0000A3A0                 dd offset __unwindtable$??0?$_Iterator012@Ubidirectional_iterator_tag@std@@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@2@HPBU32@ABU32@U_Iterator_base12@2@@std@@QAE@XZ
.xdata$x:0000A3A4                 db    0
.xdata$x:0000A3A5                 db    0
.xdata$x:0000A3A6                 db    0
.xdata$x:0000A3A7                 db    0
.xdata$x:0000A3A8                 db    0
.xdata$x:0000A3A9                 db    0
.xdata$x:0000A3AA                 db    0
.xdata$x:0000A3AB                 db    0
.xdata$x:0000A3AC                 db    0
.xdata$x:0000A3AD                 db    0
.xdata$x:0000A3AE                 db    0
.xdata$x:0000A3AF                 db    0
.xdata$x:0000A3B0                 db    0
.xdata$x:0000A3B1                 db    0
.xdata$x:0000A3B2                 db    0
.xdata$x:0000A3B3                 db    0
.xdata$x:0000A3B4                 db    0
.xdata$x:0000A3B5                 db    0
.xdata$x:0000A3B6                 db    0
.xdata$x:0000A3B7                 db    0
.xdata$x:0000A3B8                 db    0
.xdata$x:0000A3B9                 db    0
.xdata$x:0000A3BA                 db    0
.xdata$x:0000A3BB                 db    0
.xdata$x:0000A3BB _xdata$x        ends
.xdata$x:0000A3BB
.xdata$x:0000A3BC ; ===========================================================================
.xdata$x:0000A3BC
.xdata$x:0000A3BC ; Segment type: Pure data
.xdata$x:0000A3BC ; Segment permissions: Read
.xdata$x:0000A3BC _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A3BC                 assume cs:_xdata$x
.xdata$x:0000A3BC                 ;org 0A3BCh
.xdata$x:0000A3BC ; COMDAT (pick associative to section at 3D3C)
.xdata$x:0000A3BC __unwindtable$??1?$_Iterator012@Ubidirectional_iterator_tag@std@@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@2@HPBU32@ABU32@U_Iterator_base12@2@@std@@QAE@XZ db 0FFh
.xdata$x:0000A3BC                                         ; DATA XREF: .xdata$x:0000A3CCo
.xdata$x:0000A3BD                 db 0FFh
.xdata$x:0000A3BE                 db 0FFh
.xdata$x:0000A3BF                 db 0FFh
.xdata$x:0000A3C0                 dd offset __unwindfunclet$??1?$_Iterator012@Ubidirectional_iterator_tag@std@@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@2@HPBU32@ABU32@U_Iterator_base12@2@@std@@QAE@XZ$0
.xdata$x:0000A3C4 __ehfuncinfo$??1?$_Iterator012@Ubidirectional_iterator_tag@std@@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@2@HPBU32@ABU32@U_Iterator_base12@2@@std@@QAE@XZ db  22h ; "
.xdata$x:0000A3C4                                         ; DATA XREF: __ehhandler$??1?$_Iterator012@Ubidirectional_iterator_tag@std@@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@2@HPBU32@ABU32@U_Iterator_base12@2@@std@@QAE@XZ+11o
.xdata$x:0000A3C5                 db    5
.xdata$x:0000A3C6                 db  93h ; ô
.xdata$x:0000A3C7                 db  19h
.xdata$x:0000A3C8                 db    1
.xdata$x:0000A3C9                 db    0
.xdata$x:0000A3CA                 db    0
.xdata$x:0000A3CB                 db    0
.xdata$x:0000A3CC                 dd offset __unwindtable$??1?$_Iterator012@Ubidirectional_iterator_tag@std@@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@2@HPBU32@ABU32@U_Iterator_base12@2@@std@@QAE@XZ
.xdata$x:0000A3D0                 db    0
.xdata$x:0000A3D1                 db    0
.xdata$x:0000A3D2                 db    0
.xdata$x:0000A3D3                 db    0
.xdata$x:0000A3D4                 db    0
.xdata$x:0000A3D5                 db    0
.xdata$x:0000A3D6                 db    0
.xdata$x:0000A3D7                 db    0
.xdata$x:0000A3D8                 db    0
.xdata$x:0000A3D9                 db    0
.xdata$x:0000A3DA                 db    0
.xdata$x:0000A3DB                 db    0
.xdata$x:0000A3DC                 db    0
.xdata$x:0000A3DD                 db    0
.xdata$x:0000A3DE                 db    0
.xdata$x:0000A3DF                 db    0
.xdata$x:0000A3E0                 db    0
.xdata$x:0000A3E1                 db    0
.xdata$x:0000A3E2                 db    0
.xdata$x:0000A3E3                 db    0
.xdata$x:0000A3E4                 db    0
.xdata$x:0000A3E5                 db    0
.xdata$x:0000A3E6                 db    0
.xdata$x:0000A3E7                 db    0
.xdata$x:0000A3E7 _xdata$x        ends
.xdata$x:0000A3E7
.xdata$x:0000A3E8 ; ===========================================================================
.xdata$x:0000A3E8
.xdata$x:0000A3E8 ; Segment type: Pure data
.xdata$x:0000A3E8 ; Segment permissions: Read
.xdata$x:0000A3E8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A3E8                 assume cs:_xdata$x
.xdata$x:0000A3E8                 ;org 0A3E8h
.xdata$x:0000A3E8 ; COMDAT (pick associative to section at 2D14)
.xdata$x:0000A3E8 __unwindtable$??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QAE@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@st db 0FFh
.xdata$x:0000A3E8                                         ; DATA XREF: .xdata$x:0000A3F8o
.xdata$x:0000A3E9                 db 0FFh
.xdata$x:0000A3EA                 db 0FFh
.xdata$x:0000A3EB                 db 0FFh
.xdata$x:0000A3EC                 dd offset __unwindfunclet$??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QAE@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@1@@Z$0
.xdata$x:0000A3F0 __ehfuncinfo$??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QAE@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std db  22h ; "
.xdata$x:0000A3F0                                         ; DATA XREF: __ehhandler$??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QAE@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@1@@Z+11o
.xdata$x:0000A3F1                 db    5
.xdata$x:0000A3F2                 db  93h ; ô
.xdata$x:0000A3F3                 db  19h
.xdata$x:0000A3F4                 db    1
.xdata$x:0000A3F5                 db    0
.xdata$x:0000A3F6                 db    0
.xdata$x:0000A3F7                 db    0
.xdata$x:0000A3F8                 dd offset __unwindtable$??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QAE@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@1@@Z
.xdata$x:0000A3FC                 db    0
.xdata$x:0000A3FD                 db    0
.xdata$x:0000A3FE                 db    0
.xdata$x:0000A3FF                 db    0
.xdata$x:0000A400                 db    0
.xdata$x:0000A401                 db    0
.xdata$x:0000A402                 db    0
.xdata$x:0000A403                 db    0
.xdata$x:0000A404                 db    0
.xdata$x:0000A405                 db    0
.xdata$x:0000A406                 db    0
.xdata$x:0000A407                 db    0
.xdata$x:0000A408                 db    0
.xdata$x:0000A409                 db    0
.xdata$x:0000A40A                 db    0
.xdata$x:0000A40B                 db    0
.xdata$x:0000A40C                 db    0
.xdata$x:0000A40D                 db    0
.xdata$x:0000A40E                 db    0
.xdata$x:0000A40F                 db    0
.xdata$x:0000A410                 db    0
.xdata$x:0000A411                 db    0
.xdata$x:0000A412                 db    0
.xdata$x:0000A413                 db    0
.xdata$x:0000A413 _xdata$x        ends
.xdata$x:0000A413
.xdata$x:0000A414 ; ===========================================================================
.xdata$x:0000A414
.xdata$x:0000A414 ; Segment type: Pure data
.xdata$x:0000A414 ; Segment permissions: Read
.xdata$x:0000A414 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A414                 assume cs:_xdata$x
.xdata$x:0000A414                 ;org 0A414h
.xdata$x:0000A414 ; COMDAT (pick associative to section at 42AC)
.xdata$x:0000A414 __unwindtable$??1?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QAE@XZ db 0FFh
.xdata$x:0000A414                                         ; DATA XREF: .xdata$x:0000A424o
.xdata$x:0000A415                 db 0FFh
.xdata$x:0000A416                 db 0FFh
.xdata$x:0000A417                 db 0FFh
.xdata$x:0000A418                 dd offset __unwindfunclet$??1?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QAE@XZ$0
.xdata$x:0000A41C __ehfuncinfo$??1?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QAE@XZ db  22h ; "
.xdata$x:0000A41C                                         ; DATA XREF: __ehhandler$??1?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QAE@XZ+11o
.xdata$x:0000A41D                 db    5
.xdata$x:0000A41E                 db  93h ; ô
.xdata$x:0000A41F                 db  19h
.xdata$x:0000A420                 db    1
.xdata$x:0000A421                 db    0
.xdata$x:0000A422                 db    0
.xdata$x:0000A423                 db    0
.xdata$x:0000A424                 dd offset __unwindtable$??1?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QAE@XZ
.xdata$x:0000A428                 align 20h
.xdata$x:0000A428 _xdata$x        ends
.xdata$x:0000A428
.xdata$x:0000A440 ; ===========================================================================
.xdata$x:0000A440
.xdata$x:0000A440 ; Segment type: Pure data
.xdata$x:0000A440 ; Segment permissions: Read
.xdata$x:0000A440 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A440                 assume cs:_xdata$x
.xdata$x:0000A440                 ;org 0A440h
.xdata$x:0000A440 ; COMDAT (pick associative to section at 2AF0)
.xdata$x:0000A440 __unwindtable$??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocato db 0FFh
.xdata$x:0000A440                                         ; DATA XREF: .xdata$x:0000A450o
.xdata$x:0000A441                 db 0FFh
.xdata$x:0000A442                 db 0FFh
.xdata$x:0000A443                 db 0FFh
.xdata$x:0000A444                 dd offset __unwindfunclet$??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@1@@Z$0
.xdata$x:0000A448 __ehfuncinfo$??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator db  22h ; "
.xdata$x:0000A448                                         ; DATA XREF: __ehhandler$??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@1@@Z+11o
.xdata$x:0000A449                 db    5
.xdata$x:0000A44A                 db  93h ; ô
.xdata$x:0000A44B                 db  19h
.xdata$x:0000A44C                 db    1
.xdata$x:0000A44D                 db    0
.xdata$x:0000A44E                 db    0
.xdata$x:0000A44F                 db    0
.xdata$x:0000A450                 dd offset __unwindtable$??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@1@@Z
.xdata$x:0000A454                 db    0
.xdata$x:0000A455                 db    0
.xdata$x:0000A456                 db    0
.xdata$x:0000A457                 db    0
.xdata$x:0000A458                 db    0
.xdata$x:0000A459                 db    0
.xdata$x:0000A45A                 db    0
.xdata$x:0000A45B                 db    0
.xdata$x:0000A45C                 db    0
.xdata$x:0000A45D                 db    0
.xdata$x:0000A45E                 db    0
.xdata$x:0000A45F                 db    0
.xdata$x:0000A460                 db    0
.xdata$x:0000A461                 db    0
.xdata$x:0000A462                 db    0
.xdata$x:0000A463                 db    0
.xdata$x:0000A464                 db    0
.xdata$x:0000A465                 db    0
.xdata$x:0000A466                 db    0
.xdata$x:0000A467                 db    0
.xdata$x:0000A468                 db    0
.xdata$x:0000A469                 db    0
.xdata$x:0000A46A                 db    0
.xdata$x:0000A46B                 db    0
.xdata$x:0000A46B _xdata$x        ends
.xdata$x:0000A46B
.xdata$x:0000A46C ; ===========================================================================
.xdata$x:0000A46C
.xdata$x:0000A46C ; Segment type: Pure data
.xdata$x:0000A46C ; Segment permissions: Read
.xdata$x:0000A46C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A46C                 assume cs:_xdata$x
.xdata$x:0000A46C                 ;org 0A46Ch
.xdata$x:0000A46C ; COMDAT (pick associative to section at 40EC)
.xdata$x:0000A46C __unwindtable$??1?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000A46C                                         ; DATA XREF: .xdata$x:0000A47Co
.xdata$x:0000A46D                 db 0FFh
.xdata$x:0000A46E                 db 0FFh
.xdata$x:0000A46F                 db 0FFh
.xdata$x:0000A470                 dd offset __unwindfunclet$??1?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QAE@XZ$0
.xdata$x:0000A474 __ehfuncinfo$??1?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000A474                                         ; DATA XREF: __ehhandler$??1?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:0000A475                 db    5
.xdata$x:0000A476                 db  93h ; ô
.xdata$x:0000A477                 db  19h
.xdata$x:0000A478                 db    1
.xdata$x:0000A479                 db    0
.xdata$x:0000A47A                 db    0
.xdata$x:0000A47B                 db    0
.xdata$x:0000A47C                 dd offset __unwindtable$??1?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QAE@XZ
.xdata$x:0000A480                 db    0
.xdata$x:0000A481                 db    0
.xdata$x:0000A482                 db    0
.xdata$x:0000A483                 db    0
.xdata$x:0000A484                 db    0
.xdata$x:0000A485                 db    0
.xdata$x:0000A486                 db    0
.xdata$x:0000A487                 db    0
.xdata$x:0000A488                 db    0
.xdata$x:0000A489                 db    0
.xdata$x:0000A48A                 db    0
.xdata$x:0000A48B                 db    0
.xdata$x:0000A48C                 db    0
.xdata$x:0000A48D                 db    0
.xdata$x:0000A48E                 db    0
.xdata$x:0000A48F                 db    0
.xdata$x:0000A490                 db    0
.xdata$x:0000A491                 db    0
.xdata$x:0000A492                 db    0
.xdata$x:0000A493                 db    0
.xdata$x:0000A494                 db    0
.xdata$x:0000A495                 db    0
.xdata$x:0000A496                 db    0
.xdata$x:0000A497                 db    0
.xdata$x:0000A497 _xdata$x        ends
.xdata$x:0000A497
.xdata$x:0000A498 ; ===========================================================================
.xdata$x:0000A498
.xdata$x:0000A498 ; Segment type: Pure data
.xdata$x:0000A498 ; Segment permissions: Read
.xdata$x:0000A498 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A498                 assume cs:_xdata$x
.xdata$x:0000A498                 ;org 0A498h
.xdata$x:0000A498 ; COMDAT (pick associative to section at 2BE8)
.xdata$x:0000A498 __unwindtable$??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$p db 0FFh
.xdata$x:0000A498                                         ; DATA XREF: .xdata$x:0000A4A8o
.xdata$x:0000A499                 db 0FFh
.xdata$x:0000A49A                 db 0FFh
.xdata$x:0000A49B                 db 0FFh
.xdata$x:0000A49C                 dd offset __unwindfunclet$??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@1@@Z$0
.xdata$x:0000A4A0 __ehfuncinfo$??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pa db  22h ; "
.xdata$x:0000A4A0                                         ; DATA XREF: __ehhandler$??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@1@@Z+11o
.xdata$x:0000A4A1                 db    5
.xdata$x:0000A4A2                 db  93h ; ô
.xdata$x:0000A4A3                 db  19h
.xdata$x:0000A4A4                 db    1
.xdata$x:0000A4A5                 db    0
.xdata$x:0000A4A6                 db    0
.xdata$x:0000A4A7                 db    0
.xdata$x:0000A4A8                 dd offset __unwindtable$??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@1@@Z
.xdata$x:0000A4AC                 db    0
.xdata$x:0000A4AD                 db    0
.xdata$x:0000A4AE                 db    0
.xdata$x:0000A4AF                 db    0
.xdata$x:0000A4B0                 db    0
.xdata$x:0000A4B1                 db    0
.xdata$x:0000A4B2                 db    0
.xdata$x:0000A4B3                 db    0
.xdata$x:0000A4B4                 db    0
.xdata$x:0000A4B5                 db    0
.xdata$x:0000A4B6                 db    0
.xdata$x:0000A4B7                 db    0
.xdata$x:0000A4B8                 db    0
.xdata$x:0000A4B9                 db    0
.xdata$x:0000A4BA                 db    0
.xdata$x:0000A4BB                 db    0
.xdata$x:0000A4BC                 db    0
.xdata$x:0000A4BD                 db    0
.xdata$x:0000A4BE                 db    0
.xdata$x:0000A4BF                 db    0
.xdata$x:0000A4C0                 db    0
.xdata$x:0000A4C1                 db    0
.xdata$x:0000A4C2                 db    0
.xdata$x:0000A4C3                 db    0
.xdata$x:0000A4C3 _xdata$x        ends
.xdata$x:0000A4C3
.xdata$x:0000A4C4 ; ===========================================================================
.xdata$x:0000A4C4
.xdata$x:0000A4C4 ; Segment type: Pure data
.xdata$x:0000A4C4 ; Segment permissions: Read
.xdata$x:0000A4C4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A4C4                 assume cs:_xdata$x
.xdata$x:0000A4C4                 ;org 0A4C4h
.xdata$x:0000A4C4 ; COMDAT (pick associative to section at 41CC)
.xdata$x:0000A4C4 __unwindtable$??1?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000A4C4                                         ; DATA XREF: .xdata$x:0000A4D4o
.xdata$x:0000A4C5                 db 0FFh
.xdata$x:0000A4C6                 db 0FFh
.xdata$x:0000A4C7                 db 0FFh
.xdata$x:0000A4C8                 dd offset __unwindfunclet$??1?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QAE@XZ$0
.xdata$x:0000A4CC __ehfuncinfo$??1?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000A4CC                                         ; DATA XREF: __ehhandler$??1?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:0000A4CD                 db    5
.xdata$x:0000A4CE                 db  93h ; ô
.xdata$x:0000A4CF                 db  19h
.xdata$x:0000A4D0                 db    1
.xdata$x:0000A4D1                 db    0
.xdata$x:0000A4D2                 db    0
.xdata$x:0000A4D3                 db    0
.xdata$x:0000A4D4                 dd offset __unwindtable$??1?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@QAE@XZ
.xdata$x:0000A4D8                 db    0
.xdata$x:0000A4D9                 db    0
.xdata$x:0000A4DA                 db    0
.xdata$x:0000A4DB                 db    0
.xdata$x:0000A4DC                 db    0
.xdata$x:0000A4DD                 db    0
.xdata$x:0000A4DE                 db    0
.xdata$x:0000A4DF                 db    0
.xdata$x:0000A4E0                 db    0
.xdata$x:0000A4E1                 db    0
.xdata$x:0000A4E2                 db    0
.xdata$x:0000A4E3                 db    0
.xdata$x:0000A4E4                 db    0
.xdata$x:0000A4E5                 db    0
.xdata$x:0000A4E6                 db    0
.xdata$x:0000A4E7                 db    0
.xdata$x:0000A4E8                 db    0
.xdata$x:0000A4E9                 db    0
.xdata$x:0000A4EA                 db    0
.xdata$x:0000A4EB                 db    0
.xdata$x:0000A4EC                 db    0
.xdata$x:0000A4ED                 db    0
.xdata$x:0000A4EE                 db    0
.xdata$x:0000A4EF                 db    0
.xdata$x:0000A4EF _xdata$x        ends
.xdata$x:0000A4EF
.xdata$x:0000A4F0 ; ===========================================================================
.xdata$x:0000A4F0
.xdata$x:0000A4F0 ; Segment type: Pure data
.xdata$x:0000A4F0 ; Segment permissions: Read
.xdata$x:0000A4F0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A4F0                 assume cs:_xdata$x
.xdata$x:0000A4F0                 ;org 0A4F0h
.xdata$x:0000A4F0 ; COMDAT (pick associative to section at 431C)
.xdata$x:0000A4F0 __unwindtable$??1?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000A4F0                                         ; DATA XREF: .xdata$x:0000A500o
.xdata$x:0000A4F1                 db 0FFh
.xdata$x:0000A4F2                 db 0FFh
.xdata$x:0000A4F3                 db 0FFh
.xdata$x:0000A4F4                 dd offset __unwindfunclet$??1?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@QAE@XZ$0
.xdata$x:0000A4F8 __ehfuncinfo$??1?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000A4F8                                         ; DATA XREF: __ehhandler$??1?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:0000A4F9                 db    5
.xdata$x:0000A4FA                 db  93h ; ô
.xdata$x:0000A4FB                 db  19h
.xdata$x:0000A4FC                 db    1
.xdata$x:0000A4FD                 db    0
.xdata$x:0000A4FE                 db    0
.xdata$x:0000A4FF                 db    0
.xdata$x:0000A500                 dd offset __unwindtable$??1?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@QAE@XZ
.xdata$x:0000A504                 db    0
.xdata$x:0000A505                 db    0
.xdata$x:0000A506                 db    0
.xdata$x:0000A507                 db    0
.xdata$x:0000A508                 db    0
.xdata$x:0000A509                 db    0
.xdata$x:0000A50A                 db    0
.xdata$x:0000A50B                 db    0
.xdata$x:0000A50C                 db    0
.xdata$x:0000A50D                 db    0
.xdata$x:0000A50E                 db    0
.xdata$x:0000A50F                 db    0
.xdata$x:0000A510                 db    0
.xdata$x:0000A511                 db    0
.xdata$x:0000A512                 db    0
.xdata$x:0000A513                 db    0
.xdata$x:0000A514                 db    0
.xdata$x:0000A515                 db    0
.xdata$x:0000A516                 db    0
.xdata$x:0000A517                 db    0
.xdata$x:0000A518                 db    0
.xdata$x:0000A519                 db    0
.xdata$x:0000A51A                 db    0
.xdata$x:0000A51B                 db    0
.xdata$x:0000A51B _xdata$x        ends
.xdata$x:0000A51B
.xdata$x:0000A51C ; ===========================================================================
.xdata$x:0000A51C
.xdata$x:0000A51C ; Segment type: Pure data
.xdata$x:0000A51C ; Segment permissions: Read
.xdata$x:0000A51C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A51C                 assume cs:_xdata$x
.xdata$x:0000A51C                 ;org 0A51Ch
.xdata$x:0000A51C ; COMDAT (pick associative to section at 3E8C)
.xdata$x:0000A51C __unwindtable$??1?$_List_alloc@$0A@U?$_List_base_types@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000A51C                                         ; DATA XREF: .xdata$x:0000A52Co
.xdata$x:0000A51D                 db 0FFh
.xdata$x:0000A51E                 db 0FFh
.xdata$x:0000A51F                 db 0FFh
.xdata$x:0000A520                 dd offset __unwindfunclet$??1?$_List_alloc@$0A@U?$_List_base_types@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@@std@@QAE@XZ$0
.xdata$x:0000A524 __ehfuncinfo$??1?$_List_alloc@$0A@U?$_List_base_types@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000A524                                         ; DATA XREF: __ehhandler$??1?$_List_alloc@$0A@U?$_List_base_types@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@@std@@QAE@XZ+11o
.xdata$x:0000A525                 db    5
.xdata$x:0000A526                 db  93h ; ô
.xdata$x:0000A527                 db  19h
.xdata$x:0000A528                 db    1
.xdata$x:0000A529                 db    0
.xdata$x:0000A52A                 db    0
.xdata$x:0000A52B                 db    0
.xdata$x:0000A52C                 dd offset __unwindtable$??1?$_List_alloc@$0A@U?$_List_base_types@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@@std@@QAE@XZ
.xdata$x:0000A530                 db    0
.xdata$x:0000A531                 db    0
.xdata$x:0000A532                 db    0
.xdata$x:0000A533                 db    0
.xdata$x:0000A534                 db    0
.xdata$x:0000A535                 db    0
.xdata$x:0000A536                 db    0
.xdata$x:0000A537                 db    0
.xdata$x:0000A538                 db    0
.xdata$x:0000A539                 db    0
.xdata$x:0000A53A                 db    0
.xdata$x:0000A53B                 db    0
.xdata$x:0000A53C                 db    0
.xdata$x:0000A53D                 db    0
.xdata$x:0000A53E                 db    0
.xdata$x:0000A53F                 db    0
.xdata$x:0000A540                 db    0
.xdata$x:0000A541                 db    0
.xdata$x:0000A542                 db    0
.xdata$x:0000A543                 db    0
.xdata$x:0000A544                 db    0
.xdata$x:0000A545                 db    0
.xdata$x:0000A546                 db    0
.xdata$x:0000A547                 db    0
.xdata$x:0000A547 _xdata$x        ends
.xdata$x:0000A547
.xdata$x:0000A548 ; ===========================================================================
.xdata$x:0000A548
.xdata$x:0000A548 ; Segment type: Pure data
.xdata$x:0000A548 ; Segment permissions: Read
.xdata$x:0000A548 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A548                 assume cs:_xdata$x
.xdata$x:0000A548                 ;org 0A548h
.xdata$x:0000A548 ; COMDAT (pick associative to section at 3F9C)
.xdata$x:0000A548 __unwindtable$??1?$_List_buy@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@QAE@XZ db 0FFh
.xdata$x:0000A548                                         ; DATA XREF: .xdata$x:0000A558o
.xdata$x:0000A549                 db 0FFh
.xdata$x:0000A54A                 db 0FFh
.xdata$x:0000A54B                 db 0FFh
.xdata$x:0000A54C                 dd offset __unwindfunclet$??1?$_List_buy@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@QAE@XZ$0
.xdata$x:0000A550 __ehfuncinfo$??1?$_List_buy@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@QAE@XZ db  22h ; "
.xdata$x:0000A550                                         ; DATA XREF: __ehhandler$??1?$_List_buy@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@QAE@XZ+11o
.xdata$x:0000A551                 db    5
.xdata$x:0000A552                 db  93h ; ô
.xdata$x:0000A553                 db  19h
.xdata$x:0000A554                 db    1
.xdata$x:0000A555                 db    0
.xdata$x:0000A556                 db    0
.xdata$x:0000A557                 db    0
.xdata$x:0000A558                 dd offset __unwindtable$??1?$_List_buy@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@QAE@XZ
.xdata$x:0000A55C                 db    0
.xdata$x:0000A55D                 db    0
.xdata$x:0000A55E                 db    0
.xdata$x:0000A55F                 db    0
.xdata$x:0000A560                 db    0
.xdata$x:0000A561                 db    0
.xdata$x:0000A562                 db    0
.xdata$x:0000A563                 db    0
.xdata$x:0000A564                 db    0
.xdata$x:0000A565                 db    0
.xdata$x:0000A566                 db    0
.xdata$x:0000A567                 db    0
.xdata$x:0000A568                 db    0
.xdata$x:0000A569                 db    0
.xdata$x:0000A56A                 db    0
.xdata$x:0000A56B                 db    0
.xdata$x:0000A56C                 db    0
.xdata$x:0000A56D                 db    0
.xdata$x:0000A56E                 db    0
.xdata$x:0000A56F                 db    0
.xdata$x:0000A570                 db    0
.xdata$x:0000A571                 db    0
.xdata$x:0000A572                 db    0
.xdata$x:0000A573                 db    0
.xdata$x:0000A573 _xdata$x        ends
.xdata$x:0000A573
.xdata$x:0000A574 ; ===========================================================================
.xdata$x:0000A574
.xdata$x:0000A574 ; Segment type: Pure data
.xdata$x:0000A574 ; Segment permissions: Read
.xdata$x:0000A574 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A574                 assume cs:_xdata$x
.xdata$x:0000A574                 ;org 0A574h
.xdata$x:0000A574 ; COMDAT (pick associative to section at 4A54)
.xdata$x:0000A574 __unwindtable$??1?$list@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@QAE@XZ db 0FFh
.xdata$x:0000A574                                         ; DATA XREF: .xdata$x:0000A584o
.xdata$x:0000A575                 db 0FFh
.xdata$x:0000A576                 db 0FFh
.xdata$x:0000A577                 db 0FFh
.xdata$x:0000A578                 dd offset __unwindfunclet$??1?$list@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@QAE@XZ$0
.xdata$x:0000A57C __ehfuncinfo$??1?$list@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@QAE@XZ db  22h ; "
.xdata$x:0000A57C                                         ; DATA XREF: __ehhandler$??1?$list@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@QAE@XZ+11o
.xdata$x:0000A57D                 db    5
.xdata$x:0000A57E                 db  93h ; ô
.xdata$x:0000A57F                 db  19h
.xdata$x:0000A580                 db    1
.xdata$x:0000A581                 db    0
.xdata$x:0000A582                 db    0
.xdata$x:0000A583                 db    0
.xdata$x:0000A584                 dd offset __unwindtable$??1?$list@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@QAE@XZ
.xdata$x:0000A588                 align 20h
.xdata$x:0000A588 _xdata$x        ends
.xdata$x:0000A588
.xdata$x:0000A5A0 ; ===========================================================================
.xdata$x:0000A5A0
.xdata$x:0000A5A0 ; Segment type: Pure data
.xdata$x:0000A5A0 ; Segment permissions: Read
.xdata$x:0000A5A0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A5A0                 assume cs:_xdata$x
.xdata$x:0000A5A0                 ;org 0A5A0h
.xdata$x:0000A5A0 ; COMDAT (pick associative to section at 810C)
.xdata$x:0000A5A0 __unwindtable$?begin@?$list@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@2@XZ db 0FFh
.xdata$x:0000A5A0                                         ; DATA XREF: .xdata$x:0000A5B0o
.xdata$x:0000A5A1                 db 0FFh
.xdata$x:0000A5A2                 db 0FFh
.xdata$x:0000A5A3                 db 0FFh
.xdata$x:0000A5A4                 dd offset __unwindfunclet$?begin@?$list@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@2@XZ$0
.xdata$x:0000A5A8 __ehfuncinfo$?begin@?$list@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@2@XZ db  22h ; "
.xdata$x:0000A5A8                                         ; DATA XREF: __ehhandler$?begin@?$list@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@2@XZ+11o
.xdata$x:0000A5A9                 db    5
.xdata$x:0000A5AA                 db  93h ; ô
.xdata$x:0000A5AB                 db  19h
.xdata$x:0000A5AC                 db    1
.xdata$x:0000A5AD                 db    0
.xdata$x:0000A5AE                 db    0
.xdata$x:0000A5AF                 db    0
.xdata$x:0000A5B0                 dd offset __unwindtable$?begin@?$list@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@2@XZ
.xdata$x:0000A5B4                 db    0
.xdata$x:0000A5B5                 db    0
.xdata$x:0000A5B6                 db    0
.xdata$x:0000A5B7                 db    0
.xdata$x:0000A5B8                 db    0
.xdata$x:0000A5B9                 db    0
.xdata$x:0000A5BA                 db    0
.xdata$x:0000A5BB                 db    0
.xdata$x:0000A5BC                 db    0
.xdata$x:0000A5BD                 db    0
.xdata$x:0000A5BE                 db    0
.xdata$x:0000A5BF                 db    0
.xdata$x:0000A5C0                 db    0
.xdata$x:0000A5C1                 db    0
.xdata$x:0000A5C2                 db    0
.xdata$x:0000A5C3                 db    0
.xdata$x:0000A5C4                 db    0
.xdata$x:0000A5C5                 db    0
.xdata$x:0000A5C6                 db    0
.xdata$x:0000A5C7                 db    0
.xdata$x:0000A5C8                 db    0
.xdata$x:0000A5C9                 db    0
.xdata$x:0000A5CA                 db    0
.xdata$x:0000A5CB                 db    0
.xdata$x:0000A5CB _xdata$x        ends
.xdata$x:0000A5CB
.xdata$x:0000A5CC ; ===========================================================================
.xdata$x:0000A5CC
.xdata$x:0000A5CC ; Segment type: Pure data
.xdata$x:0000A5CC ; Segment permissions: Read
.xdata$x:0000A5CC _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A5CC                 assume cs:_xdata$x
.xdata$x:0000A5CC                 ;org 0A5CCh
.xdata$x:0000A5CC ; COMDAT (pick associative to section at 8A74)
.xdata$x:0000A5CC __unwindtable$?end@?$list@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@2@XZ db 0FFh
.xdata$x:0000A5CC                                         ; DATA XREF: .xdata$x:0000A5DCo
.xdata$x:0000A5CD                 db 0FFh
.xdata$x:0000A5CE                 db 0FFh
.xdata$x:0000A5CF                 db 0FFh
.xdata$x:0000A5D0                 dd offset __unwindfunclet$?end@?$list@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@2@XZ$0
.xdata$x:0000A5D4 __ehfuncinfo$?end@?$list@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@2@XZ db  22h ; "
.xdata$x:0000A5D4                                         ; DATA XREF: __ehhandler$?end@?$list@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@2@XZ+11o
.xdata$x:0000A5D5                 db    5
.xdata$x:0000A5D6                 db  93h ; ô
.xdata$x:0000A5D7                 db  19h
.xdata$x:0000A5D8                 db    1
.xdata$x:0000A5D9                 db    0
.xdata$x:0000A5DA                 db    0
.xdata$x:0000A5DB                 db    0
.xdata$x:0000A5DC                 dd offset __unwindtable$?end@?$list@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@2@XZ
.xdata$x:0000A5E0                 db    0
.xdata$x:0000A5E1                 db    0
.xdata$x:0000A5E2                 db    0
.xdata$x:0000A5E3                 db    0
.xdata$x:0000A5E4                 db    0
.xdata$x:0000A5E5                 db    0
.xdata$x:0000A5E6                 db    0
.xdata$x:0000A5E7                 db    0
.xdata$x:0000A5E8                 db    0
.xdata$x:0000A5E9                 db    0
.xdata$x:0000A5EA                 db    0
.xdata$x:0000A5EB                 db    0
.xdata$x:0000A5EC                 db    0
.xdata$x:0000A5ED                 db    0
.xdata$x:0000A5EE                 db    0
.xdata$x:0000A5EF                 db    0
.xdata$x:0000A5F0                 db    0
.xdata$x:0000A5F1                 db    0
.xdata$x:0000A5F2                 db    0
.xdata$x:0000A5F3                 db    0
.xdata$x:0000A5F4                 db    0
.xdata$x:0000A5F5                 db    0
.xdata$x:0000A5F6                 db    0
.xdata$x:0000A5F7                 db    0
.xdata$x:0000A5F7 _xdata$x        ends
.xdata$x:0000A5F7
.xdata$x:0000A5F8 ; ===========================================================================
.xdata$x:0000A5F8
.xdata$x:0000A5F8 ; Segment type: Pure data
.xdata$x:0000A5F8 ; Segment permissions: Read
.xdata$x:0000A5F8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A5F8                 assume cs:_xdata$x
.xdata$x:0000A5F8                 ;org 0A5F8h
.xdata$x:0000A5F8 ; COMDAT (pick associative to section at 733C)
.xdata$x:0000A5F8 __unwindtable$?_Orphan_ptr@?$list@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@QBEXAAV12@PAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@2@@Z db 0FFh
.xdata$x:0000A5F8                                         ; DATA XREF: .xdata$x:0000A608o
.xdata$x:0000A5F9                 db 0FFh
.xdata$x:0000A5FA                 db 0FFh
.xdata$x:0000A5FB                 db 0FFh
.xdata$x:0000A5FC                 dd offset __unwindfunclet$?_Orphan_ptr@?$list@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@QBEXAAV12@PAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@2@@Z$0
.xdata$x:0000A600 __ehfuncinfo$?_Orphan_ptr@?$list@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@QBEXAAV12@PAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@2@@Z db  22h ; "
.xdata$x:0000A600                                         ; DATA XREF: __ehhandler$?_Orphan_ptr@?$list@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@QBEXAAV12@PAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@2@@Z+11o
.xdata$x:0000A601                 db    5
.xdata$x:0000A602                 db  93h ; ô
.xdata$x:0000A603                 db  19h
.xdata$x:0000A604                 db    1
.xdata$x:0000A605                 db    0
.xdata$x:0000A606                 db    0
.xdata$x:0000A607                 db    0
.xdata$x:0000A608                 dd offset __unwindtable$?_Orphan_ptr@?$list@U?$pair@$$CBHUStyle@@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@2@@std@@QBEXAAV12@PAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@2@@Z
.xdata$x:0000A60C                 db    0
.xdata$x:0000A60D                 db    0
.xdata$x:0000A60E                 db    0
.xdata$x:0000A60F                 db    0
.xdata$x:0000A610                 db    0
.xdata$x:0000A611                 db    0
.xdata$x:0000A612                 db    0
.xdata$x:0000A613                 db    0
.xdata$x:0000A614                 db    0
.xdata$x:0000A615                 db    0
.xdata$x:0000A616                 db    0
.xdata$x:0000A617                 db    0
.xdata$x:0000A618                 db    0
.xdata$x:0000A619                 db    0
.xdata$x:0000A61A                 db    0
.xdata$x:0000A61B                 db    0
.xdata$x:0000A61C                 db    0
.xdata$x:0000A61D                 db    0
.xdata$x:0000A61E                 db    0
.xdata$x:0000A61F                 db    0
.xdata$x:0000A620                 db    0
.xdata$x:0000A621                 db    0
.xdata$x:0000A622                 db    0
.xdata$x:0000A623                 db    0
.xdata$x:0000A623 _xdata$x        ends
.xdata$x:0000A623
.xdata$x:0000A624 ; ===========================================================================
.xdata$x:0000A624
.xdata$x:0000A624 ; Segment type: Pure data
.xdata$x:0000A624 ; Segment permissions: Read
.xdata$x:0000A624 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A624                 assume cs:_xdata$x
.xdata$x:0000A624                 ;org 0A624h
.xdata$x:0000A624 ; COMDAT (pick associative to section at 3BB4)
.xdata$x:0000A624 __unwindtable$??1?$_Hash@V?$_Umap_traits@HUStyle@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@$0A@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000A624                                         ; DATA XREF: .xdata$x:0000A63Co
.xdata$x:0000A625                 db 0FFh
.xdata$x:0000A626                 db 0FFh
.xdata$x:0000A627                 db 0FFh
.xdata$x:0000A628                 dd offset __unwindfunclet$??1?$_Hash@V?$_Umap_traits@HUStyle@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@$0A@@std@@@std@@QAE@XZ$0
.xdata$x:0000A62C                 align 10h
.xdata$x:0000A630                 dd offset __unwindfunclet$??1?$_Hash@V?$_Umap_traits@HUStyle@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@$0A@@std@@@std@@QAE@XZ$1
.xdata$x:0000A634 __ehfuncinfo$??1?$_Hash@V?$_Umap_traits@HUStyle@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@$0A@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000A634                                         ; DATA XREF: __ehhandler$??1?$_Hash@V?$_Umap_traits@HUStyle@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@$0A@@std@@@std@@QAE@XZ+11o
.xdata$x:0000A635                 db    5
.xdata$x:0000A636                 db  93h ; ô
.xdata$x:0000A637                 db  19h
.xdata$x:0000A638                 db    2
.xdata$x:0000A639                 db    0
.xdata$x:0000A63A                 db    0
.xdata$x:0000A63B                 db    0
.xdata$x:0000A63C                 dd offset __unwindtable$??1?$_Hash@V?$_Umap_traits@HUStyle@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@$0A@@std@@@std@@QAE@XZ
.xdata$x:0000A640                 db    0
.xdata$x:0000A641                 db    0
.xdata$x:0000A642                 db    0
.xdata$x:0000A643                 db    0
.xdata$x:0000A644                 db    0
.xdata$x:0000A645                 db    0
.xdata$x:0000A646                 db    0
.xdata$x:0000A647                 db    0
.xdata$x:0000A648                 db    0
.xdata$x:0000A649                 db    0
.xdata$x:0000A64A                 db    0
.xdata$x:0000A64B                 db    0
.xdata$x:0000A64C                 db    0
.xdata$x:0000A64D                 db    0
.xdata$x:0000A64E                 db    0
.xdata$x:0000A64F                 db    0
.xdata$x:0000A650                 db    0
.xdata$x:0000A651                 db    0
.xdata$x:0000A652                 db    0
.xdata$x:0000A653                 db    0
.xdata$x:0000A654                 db    0
.xdata$x:0000A655                 db    0
.xdata$x:0000A656                 db    0
.xdata$x:0000A657                 db    0
.xdata$x:0000A657 _xdata$x        ends
.xdata$x:0000A657
.xdata$x:0000A658 ; ===========================================================================
.xdata$x:0000A658
.xdata$x:0000A658 ; Segment type: Pure data
.xdata$x:0000A658 ; Segment permissions: Read
.xdata$x:0000A658 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A658                 assume cs:_xdata$x
.xdata$x:0000A658                 ;org 0A658h
.xdata$x:0000A658 ; COMDAT (pick associative to section at 7FE4)
.xdata$x:0000A658 __unwindtable$?begin@?$_Hash@V?$_Umap_traits@HUStyle@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@2@XZ db 0FFh
.xdata$x:0000A658                                         ; DATA XREF: .xdata$x:0000A668o
.xdata$x:0000A659                 db 0FFh
.xdata$x:0000A65A                 db 0FFh
.xdata$x:0000A65B                 db 0FFh
.xdata$x:0000A65C                 dd offset __unwindfunclet$?begin@?$_Hash@V?$_Umap_traits@HUStyle@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@2@XZ$0
.xdata$x:0000A660 __ehfuncinfo$?begin@?$_Hash@V?$_Umap_traits@HUStyle@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@2@XZ db  22h ; "
.xdata$x:0000A660                                         ; DATA XREF: __ehhandler$?begin@?$_Hash@V?$_Umap_traits@HUStyle@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@2@XZ+11o
.xdata$x:0000A661                 db    5
.xdata$x:0000A662                 db  93h ; ô
.xdata$x:0000A663                 db  19h
.xdata$x:0000A664                 db    1
.xdata$x:0000A665                 db    0
.xdata$x:0000A666                 db    0
.xdata$x:0000A667                 db    0
.xdata$x:0000A668                 dd offset __unwindtable$?begin@?$_Hash@V?$_Umap_traits@HUStyle@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@2@XZ
.xdata$x:0000A66C                 db    0
.xdata$x:0000A66D                 db    0
.xdata$x:0000A66E                 db    0
.xdata$x:0000A66F                 db    0
.xdata$x:0000A670                 db    0
.xdata$x:0000A671                 db    0
.xdata$x:0000A672                 db    0
.xdata$x:0000A673                 db    0
.xdata$x:0000A674                 db    0
.xdata$x:0000A675                 db    0
.xdata$x:0000A676                 db    0
.xdata$x:0000A677                 db    0
.xdata$x:0000A678                 db    0
.xdata$x:0000A679                 db    0
.xdata$x:0000A67A                 db    0
.xdata$x:0000A67B                 db    0
.xdata$x:0000A67C                 db    0
.xdata$x:0000A67D                 db    0
.xdata$x:0000A67E                 db    0
.xdata$x:0000A67F                 db    0
.xdata$x:0000A680                 db    0
.xdata$x:0000A681                 db    0
.xdata$x:0000A682                 db    0
.xdata$x:0000A683                 db    0
.xdata$x:0000A683 _xdata$x        ends
.xdata$x:0000A683
.xdata$x:0000A684 ; ===========================================================================
.xdata$x:0000A684
.xdata$x:0000A684 ; Segment type: Pure data
.xdata$x:0000A684 ; Segment permissions: Read
.xdata$x:0000A684 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A684                 assume cs:_xdata$x
.xdata$x:0000A684                 ;org 0A684h
.xdata$x:0000A684 ; COMDAT (pick associative to section at 894C)
.xdata$x:0000A684 __unwindtable$?end@?$_Hash@V?$_Umap_traits@HUStyle@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@2@XZ db 0FFh
.xdata$x:0000A684                                         ; DATA XREF: .xdata$x:0000A694o
.xdata$x:0000A685                 db 0FFh
.xdata$x:0000A686                 db 0FFh
.xdata$x:0000A687                 db 0FFh
.xdata$x:0000A688                 dd offset __unwindfunclet$?end@?$_Hash@V?$_Umap_traits@HUStyle@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@2@XZ$0
.xdata$x:0000A68C __ehfuncinfo$?end@?$_Hash@V?$_Umap_traits@HUStyle@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@2@XZ db  22h ; "
.xdata$x:0000A68C                                         ; DATA XREF: __ehhandler$?end@?$_Hash@V?$_Umap_traits@HUStyle@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@2@XZ+11o
.xdata$x:0000A68D                 db    5
.xdata$x:0000A68E                 db  93h ; ô
.xdata$x:0000A68F                 db  19h
.xdata$x:0000A690                 db    1
.xdata$x:0000A691                 db    0
.xdata$x:0000A692                 db    0
.xdata$x:0000A693                 db    0
.xdata$x:0000A694                 dd offset __unwindtable$?end@?$_Hash@V?$_Umap_traits@HUStyle@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@2@XZ
.xdata$x:0000A698                 db    0
.xdata$x:0000A699                 db    0
.xdata$x:0000A69A                 db    0
.xdata$x:0000A69B                 db    0
.xdata$x:0000A69C                 db    0
.xdata$x:0000A69D                 db    0
.xdata$x:0000A69E                 db    0
.xdata$x:0000A69F                 db    0
.xdata$x:0000A6A0                 db    0
.xdata$x:0000A6A1                 db    0
.xdata$x:0000A6A2                 db    0
.xdata$x:0000A6A3                 db    0
.xdata$x:0000A6A4                 db    0
.xdata$x:0000A6A5                 db    0
.xdata$x:0000A6A6                 db    0
.xdata$x:0000A6A7                 db    0
.xdata$x:0000A6A8                 db    0
.xdata$x:0000A6A9                 db    0
.xdata$x:0000A6AA                 db    0
.xdata$x:0000A6AB                 db    0
.xdata$x:0000A6AC                 db    0
.xdata$x:0000A6AD                 db    0
.xdata$x:0000A6AE                 db    0
.xdata$x:0000A6AF                 db    0
.xdata$x:0000A6AF _xdata$x        ends
.xdata$x:0000A6AF
.xdata$x:0000A6B0 ; ===========================================================================
.xdata$x:0000A6B0
.xdata$x:0000A6B0 ; Segment type: Pure data
.xdata$x:0000A6B0 ; Segment permissions: Read
.xdata$x:0000A6B0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A6B0                 assume cs:_xdata$x
.xdata$x:0000A6B0                 ;org 0A6B0h
.xdata$x:0000A6B0 ; COMDAT (pick associative to section at 487C)
.xdata$x:0000A6B0 __unwindtable$??1?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000A6B0                                         ; DATA XREF: .xdata$x:0000A6C0o
.xdata$x:0000A6B1                 db 0FFh
.xdata$x:0000A6B2                 db 0FFh
.xdata$x:0000A6B3                 db 0FFh
.xdata$x:0000A6B4                 dd offset __unwindfunclet$??1?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ$0
.xdata$x:0000A6B8 __ehfuncinfo$??1?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000A6B8                                         ; DATA XREF: __ehhandler$??1?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:0000A6B9                 db    5
.xdata$x:0000A6BA                 db  93h ; ô
.xdata$x:0000A6BB                 db  19h
.xdata$x:0000A6BC                 db    1
.xdata$x:0000A6BD                 db    0
.xdata$x:0000A6BE                 db    0
.xdata$x:0000A6BF                 db    0
.xdata$x:0000A6C0                 dd offset __unwindtable$??1?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ
.xdata$x:0000A6C4                 db    0
.xdata$x:0000A6C5                 db    0
.xdata$x:0000A6C6                 db    0
.xdata$x:0000A6C7                 db    0
.xdata$x:0000A6C8                 db    0
.xdata$x:0000A6C9                 db    0
.xdata$x:0000A6CA                 db    0
.xdata$x:0000A6CB                 db    0
.xdata$x:0000A6CC                 db    0
.xdata$x:0000A6CD                 db    0
.xdata$x:0000A6CE                 db    0
.xdata$x:0000A6CF                 db    0
.xdata$x:0000A6D0                 db    0
.xdata$x:0000A6D1                 db    0
.xdata$x:0000A6D2                 db    0
.xdata$x:0000A6D3                 db    0
.xdata$x:0000A6D4                 db    0
.xdata$x:0000A6D5                 db    0
.xdata$x:0000A6D6                 db    0
.xdata$x:0000A6D7                 db    0
.xdata$x:0000A6D8                 db    0
.xdata$x:0000A6D9                 db    0
.xdata$x:0000A6DA                 db    0
.xdata$x:0000A6DB                 db    0
.xdata$x:0000A6DB _xdata$x        ends
.xdata$x:0000A6DB
.xdata$x:0000A6DC ; ===========================================================================
.xdata$x:0000A6DC
.xdata$x:0000A6DC ; Segment type: Pure data
.xdata$x:0000A6DC ; Segment permissions: Read
.xdata$x:0000A6DC _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A6DC                 assume cs:_xdata$x
.xdata$x:0000A6DC                 ;org 0A6DCh
.xdata$x:0000A6DC ; COMDAT (pick associative to section at 45CC)
.xdata$x:0000A6DC __unwindtable$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000A6DC                                         ; DATA XREF: .xdata$x:0000A6ECo
.xdata$x:0000A6DD                 db 0FFh
.xdata$x:0000A6DE                 db 0FFh
.xdata$x:0000A6DF                 db 0FFh
.xdata$x:0000A6E0                 dd offset __unwindfunclet$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QAE@XZ$0
.xdata$x:0000A6E4 __ehfuncinfo$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000A6E4                                         ; DATA XREF: __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QAE@XZ+11o
.xdata$x:0000A6E5                 db    5
.xdata$x:0000A6E6                 db  93h ; ô
.xdata$x:0000A6E7                 db  19h
.xdata$x:0000A6E8                 db    1
.xdata$x:0000A6E9                 db    0
.xdata$x:0000A6EA                 db    0
.xdata$x:0000A6EB                 db    0
.xdata$x:0000A6EC                 dd offset __unwindtable$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QAE@XZ
.xdata$x:0000A6F0                 db    0
.xdata$x:0000A6F1                 db    0
.xdata$x:0000A6F2                 db    0
.xdata$x:0000A6F3                 db    0
.xdata$x:0000A6F4                 db    0
.xdata$x:0000A6F5                 db    0
.xdata$x:0000A6F6                 db    0
.xdata$x:0000A6F7                 db    0
.xdata$x:0000A6F8                 db    0
.xdata$x:0000A6F9                 db    0
.xdata$x:0000A6FA                 db    0
.xdata$x:0000A6FB                 db    0
.xdata$x:0000A6FC                 db    0
.xdata$x:0000A6FD                 db    0
.xdata$x:0000A6FE                 db    0
.xdata$x:0000A6FF                 db    0
.xdata$x:0000A700                 db    0
.xdata$x:0000A701                 db    0
.xdata$x:0000A702                 db    0
.xdata$x:0000A703                 db    0
.xdata$x:0000A704                 db    0
.xdata$x:0000A705                 db    0
.xdata$x:0000A706                 db    0
.xdata$x:0000A707                 db    0
.xdata$x:0000A707 _xdata$x        ends
.xdata$x:0000A707
.xdata$x:0000A708 ; ===========================================================================
.xdata$x:0000A708
.xdata$x:0000A708 ; Segment type: Pure data
.xdata$x:0000A708 ; Segment permissions: Read
.xdata$x:0000A708 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A708                 assume cs:_xdata$x
.xdata$x:0000A708                 ;org 0A708h
.xdata$x:0000A708 ; COMDAT (pick associative to section at 4C9C)
.xdata$x:0000A708 __unwindtable$??1?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAE@XZ db 0FFh
.xdata$x:0000A708                                         ; DATA XREF: .xdata$x:0000A718o
.xdata$x:0000A709                 db 0FFh
.xdata$x:0000A70A                 db 0FFh
.xdata$x:0000A70B                 db 0FFh
.xdata$x:0000A70C                 dd offset __unwindfunclet$??1?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAE@XZ$0
.xdata$x:0000A710 __ehfuncinfo$??1?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAE@XZ db  22h ; "
.xdata$x:0000A710                                         ; DATA XREF: __ehhandler$??1?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAE@XZ+11o
.xdata$x:0000A711                 db    5
.xdata$x:0000A712                 db  93h ; ô
.xdata$x:0000A713                 db  19h
.xdata$x:0000A714                 db    1
.xdata$x:0000A715                 db    0
.xdata$x:0000A716                 db    0
.xdata$x:0000A717                 db    0
.xdata$x:0000A718                 dd offset __unwindtable$??1?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAE@XZ
.xdata$x:0000A71C                 db    0
.xdata$x:0000A71D                 db    0
.xdata$x:0000A71E                 db    0
.xdata$x:0000A71F                 db    0
.xdata$x:0000A720                 db    0
.xdata$x:0000A721                 db    0
.xdata$x:0000A722                 db    0
.xdata$x:0000A723                 db    0
.xdata$x:0000A724                 db    0
.xdata$x:0000A725                 db    0
.xdata$x:0000A726                 db    0
.xdata$x:0000A727                 db    0
.xdata$x:0000A728                 db    0
.xdata$x:0000A729                 db    0
.xdata$x:0000A72A                 db    0
.xdata$x:0000A72B                 db    0
.xdata$x:0000A72C                 db    0
.xdata$x:0000A72D                 db    0
.xdata$x:0000A72E                 db    0
.xdata$x:0000A72F                 db    0
.xdata$x:0000A730                 db    0
.xdata$x:0000A731                 db    0
.xdata$x:0000A732                 db    0
.xdata$x:0000A733                 db    0
.xdata$x:0000A733 _xdata$x        ends
.xdata$x:0000A733
.xdata$x:0000A734 ; ===========================================================================
.xdata$x:0000A734
.xdata$x:0000A734 ; Segment type: Pure data
.xdata$x:0000A734 ; Segment permissions: Read
.xdata$x:0000A734 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A734                 assume cs:_xdata$x
.xdata$x:0000A734                 ;org 0A734h
.xdata$x:0000A734 ; COMDAT (pick associative to section at 4BBC)
.xdata$x:0000A734 __unwindtable$??1?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@QAE@XZ db 0FFh
.xdata$x:0000A734                                         ; DATA XREF: .xdata$x:0000A744o
.xdata$x:0000A735                 db 0FFh
.xdata$x:0000A736                 db 0FFh
.xdata$x:0000A737                 db 0FFh
.xdata$x:0000A738                 dd offset __unwindfunclet$??1?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@QAE@XZ$0
.xdata$x:0000A73C __ehfuncinfo$??1?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@QAE@XZ db  22h ; "
.xdata$x:0000A73C                                         ; DATA XREF: __ehhandler$??1?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@QAE@XZ+11o
.xdata$x:0000A73D                 db    5
.xdata$x:0000A73E                 db  93h ; ô
.xdata$x:0000A73F                 db  19h
.xdata$x:0000A740                 db    1
.xdata$x:0000A741                 db    0
.xdata$x:0000A742                 db    0
.xdata$x:0000A743                 db    0
.xdata$x:0000A744                 dd offset __unwindtable$??1?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@QAE@XZ
.xdata$x:0000A748                 align 20h
.xdata$x:0000A748 _xdata$x        ends
.xdata$x:0000A748
.xdata$x:0000A760 ; ===========================================================================
.xdata$x:0000A760
.xdata$x:0000A760 ; Segment type: Pure data
.xdata$x:0000A760 ; Segment permissions: Read
.xdata$x:0000A760 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A760                 assume cs:_xdata$x
.xdata$x:0000A760                 ;org 0A760h
.xdata$x:0000A760 ; COMDAT (pick associative to section at 2674)
.xdata$x:0000A760 __unwindtable$??0?$_Iterator012@Ubidirectional_iterator_tag@std@@U?$pair@$$CBHUStyle@@@2@HPBU32@ABU32@U_Iterator_base12@2@@std@@QAE@XZ db 0FFh
.xdata$x:0000A760                                         ; DATA XREF: .xdata$x:0000A770o
.xdata$x:0000A761                 db 0FFh
.xdata$x:0000A762                 db 0FFh
.xdata$x:0000A763                 db 0FFh
.xdata$x:0000A764                 dd offset __unwindfunclet$??0?$_Iterator012@Ubidirectional_iterator_tag@std@@U?$pair@$$CBHUStyle@@@2@HPBU32@ABU32@U_Iterator_base12@2@@std@@QAE@XZ$0
.xdata$x:0000A768 __ehfuncinfo$??0?$_Iterator012@Ubidirectional_iterator_tag@std@@U?$pair@$$CBHUStyle@@@2@HPBU32@ABU32@U_Iterator_base12@2@@std@@QAE@XZ db  22h ; "
.xdata$x:0000A768                                         ; DATA XREF: __ehhandler$??0?$_Iterator012@Ubidirectional_iterator_tag@std@@U?$pair@$$CBHUStyle@@@2@HPBU32@ABU32@U_Iterator_base12@2@@std@@QAE@XZ+11o
.xdata$x:0000A769                 db    5
.xdata$x:0000A76A                 db  93h ; ô
.xdata$x:0000A76B                 db  19h
.xdata$x:0000A76C                 db    1
.xdata$x:0000A76D                 db    0
.xdata$x:0000A76E                 db    0
.xdata$x:0000A76F                 db    0
.xdata$x:0000A770                 dd offset __unwindtable$??0?$_Iterator012@Ubidirectional_iterator_tag@std@@U?$pair@$$CBHUStyle@@@2@HPBU32@ABU32@U_Iterator_base12@2@@std@@QAE@XZ
.xdata$x:0000A774                 db    0
.xdata$x:0000A775                 db    0
.xdata$x:0000A776                 db    0
.xdata$x:0000A777                 db    0
.xdata$x:0000A778                 db    0
.xdata$x:0000A779                 db    0
.xdata$x:0000A77A                 db    0
.xdata$x:0000A77B                 db    0
.xdata$x:0000A77C                 db    0
.xdata$x:0000A77D                 db    0
.xdata$x:0000A77E                 db    0
.xdata$x:0000A77F                 db    0
.xdata$x:0000A780                 db    0
.xdata$x:0000A781                 db    0
.xdata$x:0000A782                 db    0
.xdata$x:0000A783                 db    0
.xdata$x:0000A784                 db    0
.xdata$x:0000A785                 db    0
.xdata$x:0000A786                 db    0
.xdata$x:0000A787                 db    0
.xdata$x:0000A788                 db    0
.xdata$x:0000A789                 db    0
.xdata$x:0000A78A                 db    0
.xdata$x:0000A78B                 db    0
.xdata$x:0000A78B _xdata$x        ends
.xdata$x:0000A78B
.xdata$x:0000A78C ; ===========================================================================
.xdata$x:0000A78C
.xdata$x:0000A78C ; Segment type: Pure data
.xdata$x:0000A78C ; Segment permissions: Read
.xdata$x:0000A78C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A78C                 assume cs:_xdata$x
.xdata$x:0000A78C                 ;org 0A78Ch
.xdata$x:0000A78C ; COMDAT (pick associative to section at 3CCC)
.xdata$x:0000A78C __unwindtable$??1?$_Iterator012@Ubidirectional_iterator_tag@std@@U?$pair@$$CBHUStyle@@@2@HPBU32@ABU32@U_Iterator_base12@2@@std@@QAE@XZ db 0FFh
.xdata$x:0000A78C                                         ; DATA XREF: .xdata$x:0000A79Co
.xdata$x:0000A78D                 db 0FFh
.xdata$x:0000A78E                 db 0FFh
.xdata$x:0000A78F                 db 0FFh
.xdata$x:0000A790                 dd offset __unwindfunclet$??1?$_Iterator012@Ubidirectional_iterator_tag@std@@U?$pair@$$CBHUStyle@@@2@HPBU32@ABU32@U_Iterator_base12@2@@std@@QAE@XZ$0
.xdata$x:0000A794 __ehfuncinfo$??1?$_Iterator012@Ubidirectional_iterator_tag@std@@U?$pair@$$CBHUStyle@@@2@HPBU32@ABU32@U_Iterator_base12@2@@std@@QAE@XZ db  22h ; "
.xdata$x:0000A794                                         ; DATA XREF: __ehhandler$??1?$_Iterator012@Ubidirectional_iterator_tag@std@@U?$pair@$$CBHUStyle@@@2@HPBU32@ABU32@U_Iterator_base12@2@@std@@QAE@XZ+11o
.xdata$x:0000A795                 db    5
.xdata$x:0000A796                 db  93h ; ô
.xdata$x:0000A797                 db  19h
.xdata$x:0000A798                 db    1
.xdata$x:0000A799                 db    0
.xdata$x:0000A79A                 db    0
.xdata$x:0000A79B                 db    0
.xdata$x:0000A79C                 dd offset __unwindtable$??1?$_Iterator012@Ubidirectional_iterator_tag@std@@U?$pair@$$CBHUStyle@@@2@HPBU32@ABU32@U_Iterator_base12@2@@std@@QAE@XZ
.xdata$x:0000A7A0                 db    0
.xdata$x:0000A7A1                 db    0
.xdata$x:0000A7A2                 db    0
.xdata$x:0000A7A3                 db    0
.xdata$x:0000A7A4                 db    0
.xdata$x:0000A7A5                 db    0
.xdata$x:0000A7A6                 db    0
.xdata$x:0000A7A7                 db    0
.xdata$x:0000A7A8                 db    0
.xdata$x:0000A7A9                 db    0
.xdata$x:0000A7AA                 db    0
.xdata$x:0000A7AB                 db    0
.xdata$x:0000A7AC                 db    0
.xdata$x:0000A7AD                 db    0
.xdata$x:0000A7AE                 db    0
.xdata$x:0000A7AF                 db    0
.xdata$x:0000A7B0                 db    0
.xdata$x:0000A7B1                 db    0
.xdata$x:0000A7B2                 db    0
.xdata$x:0000A7B3                 db    0
.xdata$x:0000A7B4                 db    0
.xdata$x:0000A7B5                 db    0
.xdata$x:0000A7B6                 db    0
.xdata$x:0000A7B7                 db    0
.xdata$x:0000A7B7 _xdata$x        ends
.xdata$x:0000A7B7
.xdata$x:0000A7B8 ; ===========================================================================
.xdata$x:0000A7B8
.xdata$x:0000A7B8 ; Segment type: Pure data
.xdata$x:0000A7B8 ; Segment permissions: Read
.xdata$x:0000A7B8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A7B8                 assume cs:_xdata$x
.xdata$x:0000A7B8                 ;org 0A7B8h
.xdata$x:0000A7B8 ; COMDAT (pick associative to section at 2C64)
.xdata$x:0000A7B8 __unwindtable$??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QAE@PAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@1@@Z db 0FFh
.xdata$x:0000A7B8                                         ; DATA XREF: .xdata$x:0000A7C8o
.xdata$x:0000A7B9                 db 0FFh
.xdata$x:0000A7BA                 db 0FFh
.xdata$x:0000A7BB                 db 0FFh
.xdata$x:0000A7BC                 dd offset __unwindfunclet$??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QAE@PAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@1@@Z$0
.xdata$x:0000A7C0 __ehfuncinfo$??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QAE@PAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@1@@Z db  22h ; "
.xdata$x:0000A7C0                                         ; DATA XREF: __ehhandler$??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QAE@PAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@1@@Z+11o
.xdata$x:0000A7C1                 db    5
.xdata$x:0000A7C2                 db  93h ; ô
.xdata$x:0000A7C3                 db  19h
.xdata$x:0000A7C4                 db    1
.xdata$x:0000A7C5                 db    0
.xdata$x:0000A7C6                 db    0
.xdata$x:0000A7C7                 db    0
.xdata$x:0000A7C8                 dd offset __unwindtable$??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QAE@PAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@1@@Z
.xdata$x:0000A7CC                 db    0
.xdata$x:0000A7CD                 db    0
.xdata$x:0000A7CE                 db    0
.xdata$x:0000A7CF                 db    0
.xdata$x:0000A7D0                 db    0
.xdata$x:0000A7D1                 db    0
.xdata$x:0000A7D2                 db    0
.xdata$x:0000A7D3                 db    0
.xdata$x:0000A7D4                 db    0
.xdata$x:0000A7D5                 db    0
.xdata$x:0000A7D6                 db    0
.xdata$x:0000A7D7                 db    0
.xdata$x:0000A7D8                 db    0
.xdata$x:0000A7D9                 db    0
.xdata$x:0000A7DA                 db    0
.xdata$x:0000A7DB                 db    0
.xdata$x:0000A7DC                 db    0
.xdata$x:0000A7DD                 db    0
.xdata$x:0000A7DE                 db    0
.xdata$x:0000A7DF                 db    0
.xdata$x:0000A7E0                 db    0
.xdata$x:0000A7E1                 db    0
.xdata$x:0000A7E2                 db    0
.xdata$x:0000A7E3                 db    0
.xdata$x:0000A7E3 _xdata$x        ends
.xdata$x:0000A7E3
.xdata$x:0000A7E4 ; ===========================================================================
.xdata$x:0000A7E4
.xdata$x:0000A7E4 ; Segment type: Pure data
.xdata$x:0000A7E4 ; Segment permissions: Read
.xdata$x:0000A7E4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A7E4                 assume cs:_xdata$x
.xdata$x:0000A7E4                 ;org 0A7E4h
.xdata$x:0000A7E4 ; COMDAT (pick associative to section at 423C)
.xdata$x:0000A7E4 __unwindtable$??1?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QAE@XZ db 0FFh
.xdata$x:0000A7E4                                         ; DATA XREF: .xdata$x:0000A7F4o
.xdata$x:0000A7E5                 db 0FFh
.xdata$x:0000A7E6                 db 0FFh
.xdata$x:0000A7E7                 db 0FFh
.xdata$x:0000A7E8                 dd offset __unwindfunclet$??1?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QAE@XZ$0
.xdata$x:0000A7EC __ehfuncinfo$??1?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QAE@XZ db  22h ; "
.xdata$x:0000A7EC                                         ; DATA XREF: __ehhandler$??1?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QAE@XZ+11o
.xdata$x:0000A7ED                 db    5
.xdata$x:0000A7EE                 db  93h ; ô
.xdata$x:0000A7EF                 db  19h
.xdata$x:0000A7F0                 db    1
.xdata$x:0000A7F1                 db    0
.xdata$x:0000A7F2                 db    0
.xdata$x:0000A7F3                 db    0
.xdata$x:0000A7F4                 dd offset __unwindtable$??1?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QAE@XZ
.xdata$x:0000A7F8                 db    0
.xdata$x:0000A7F9                 db    0
.xdata$x:0000A7FA                 db    0
.xdata$x:0000A7FB                 db    0
.xdata$x:0000A7FC                 db    0
.xdata$x:0000A7FD                 db    0
.xdata$x:0000A7FE                 db    0
.xdata$x:0000A7FF                 db    0
.xdata$x:0000A800                 db    0
.xdata$x:0000A801                 db    0
.xdata$x:0000A802                 db    0
.xdata$x:0000A803                 db    0
.xdata$x:0000A804                 db    0
.xdata$x:0000A805                 db    0
.xdata$x:0000A806                 db    0
.xdata$x:0000A807                 db    0
.xdata$x:0000A808                 db    0
.xdata$x:0000A809                 db    0
.xdata$x:0000A80A                 db    0
.xdata$x:0000A80B                 db    0
.xdata$x:0000A80C                 db    0
.xdata$x:0000A80D                 db    0
.xdata$x:0000A80E                 db    0
.xdata$x:0000A80F                 db    0
.xdata$x:0000A80F _xdata$x        ends
.xdata$x:0000A80F
.xdata$x:0000A810 ; ===========================================================================
.xdata$x:0000A810
.xdata$x:0000A810 ; Segment type: Pure data
.xdata$x:0000A810 ; Segment permissions: Read
.xdata$x:0000A810 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A810                 assume cs:_xdata$x
.xdata$x:0000A810                 ;org 0A810h
.xdata$x:0000A810 ; COMDAT (pick associative to section at 2A74)
.xdata$x:0000A810 __unwindtable$??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@1@@Z db 0FFh
.xdata$x:0000A810                                         ; DATA XREF: .xdata$x:0000A820o
.xdata$x:0000A811                 db 0FFh
.xdata$x:0000A812                 db 0FFh
.xdata$x:0000A813                 db 0FFh
.xdata$x:0000A814                 dd offset __unwindfunclet$??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@1@@Z$0
.xdata$x:0000A818 __ehfuncinfo$??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@1@@Z db  22h ; "
.xdata$x:0000A818                                         ; DATA XREF: __ehhandler$??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@1@@Z+11o
.xdata$x:0000A819                 db    5
.xdata$x:0000A81A                 db  93h ; ô
.xdata$x:0000A81B                 db  19h
.xdata$x:0000A81C                 db    1
.xdata$x:0000A81D                 db    0
.xdata$x:0000A81E                 db    0
.xdata$x:0000A81F                 db    0
.xdata$x:0000A820                 dd offset __unwindtable$??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@1@@Z
.xdata$x:0000A824                 db    0
.xdata$x:0000A825                 db    0
.xdata$x:0000A826                 db    0
.xdata$x:0000A827                 db    0
.xdata$x:0000A828                 db    0
.xdata$x:0000A829                 db    0
.xdata$x:0000A82A                 db    0
.xdata$x:0000A82B                 db    0
.xdata$x:0000A82C                 db    0
.xdata$x:0000A82D                 db    0
.xdata$x:0000A82E                 db    0
.xdata$x:0000A82F                 db    0
.xdata$x:0000A830                 db    0
.xdata$x:0000A831                 db    0
.xdata$x:0000A832                 db    0
.xdata$x:0000A833                 db    0
.xdata$x:0000A834                 db    0
.xdata$x:0000A835                 db    0
.xdata$x:0000A836                 db    0
.xdata$x:0000A837                 db    0
.xdata$x:0000A838                 db    0
.xdata$x:0000A839                 db    0
.xdata$x:0000A83A                 db    0
.xdata$x:0000A83B                 db    0
.xdata$x:0000A83B _xdata$x        ends
.xdata$x:0000A83B
.xdata$x:0000A83C ; ===========================================================================
.xdata$x:0000A83C
.xdata$x:0000A83C ; Segment type: Pure data
.xdata$x:0000A83C ; Segment permissions: Read
.xdata$x:0000A83C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A83C                 assume cs:_xdata$x
.xdata$x:0000A83C                 ;org 0A83Ch
.xdata$x:0000A83C ; COMDAT (pick associative to section at 407C)
.xdata$x:0000A83C __unwindtable$??1?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000A83C                                         ; DATA XREF: .xdata$x:0000A84Co
.xdata$x:0000A83D                 db 0FFh
.xdata$x:0000A83E                 db 0FFh
.xdata$x:0000A83F                 db 0FFh
.xdata$x:0000A840                 dd offset __unwindfunclet$??1?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@QAE@XZ$0
.xdata$x:0000A844 __ehfuncinfo$??1?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000A844                                         ; DATA XREF: __ehhandler$??1?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:0000A845                 db    5
.xdata$x:0000A846                 db  93h ; ô
.xdata$x:0000A847                 db  19h
.xdata$x:0000A848                 db    1
.xdata$x:0000A849                 db    0
.xdata$x:0000A84A                 db    0
.xdata$x:0000A84B                 db    0
.xdata$x:0000A84C                 dd offset __unwindtable$??1?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@QAE@XZ
.xdata$x:0000A850                 db    0
.xdata$x:0000A851                 db    0
.xdata$x:0000A852                 db    0
.xdata$x:0000A853                 db    0
.xdata$x:0000A854                 db    0
.xdata$x:0000A855                 db    0
.xdata$x:0000A856                 db    0
.xdata$x:0000A857                 db    0
.xdata$x:0000A858                 db    0
.xdata$x:0000A859                 db    0
.xdata$x:0000A85A                 db    0
.xdata$x:0000A85B                 db    0
.xdata$x:0000A85C                 db    0
.xdata$x:0000A85D                 db    0
.xdata$x:0000A85E                 db    0
.xdata$x:0000A85F                 db    0
.xdata$x:0000A860                 db    0
.xdata$x:0000A861                 db    0
.xdata$x:0000A862                 db    0
.xdata$x:0000A863                 db    0
.xdata$x:0000A864                 db    0
.xdata$x:0000A865                 db    0
.xdata$x:0000A866                 db    0
.xdata$x:0000A867                 db    0
.xdata$x:0000A867 _xdata$x        ends
.xdata$x:0000A867
.xdata$x:0000A868 ; ===========================================================================
.xdata$x:0000A868
.xdata$x:0000A868 ; Segment type: Pure data
.xdata$x:0000A868 ; Segment permissions: Read
.xdata$x:0000A868 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A868                 assume cs:_xdata$x
.xdata$x:0000A868                 ;org 0A868h
.xdata$x:0000A868 ; COMDAT (pick associative to section at 2B6C)
.xdata$x:0000A868 __unwindtable$??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@1@@Z db 0FFh
.xdata$x:0000A868                                         ; DATA XREF: .xdata$x:0000A878o
.xdata$x:0000A869                 db 0FFh
.xdata$x:0000A86A                 db 0FFh
.xdata$x:0000A86B                 db 0FFh
.xdata$x:0000A86C                 dd offset __unwindfunclet$??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@1@@Z$0
.xdata$x:0000A870 __ehfuncinfo$??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@1@@Z db  22h ; "
.xdata$x:0000A870                                         ; DATA XREF: __ehhandler$??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@1@@Z+11o
.xdata$x:0000A871                 db    5
.xdata$x:0000A872                 db  93h ; ô
.xdata$x:0000A873                 db  19h
.xdata$x:0000A874                 db    1
.xdata$x:0000A875                 db    0
.xdata$x:0000A876                 db    0
.xdata$x:0000A877                 db    0
.xdata$x:0000A878                 dd offset __unwindtable$??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@U?$pair@$$CBHUStyle@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@1@@Z
.xdata$x:0000A87C                 db    0
.xdata$x:0000A87D                 db    0
.xdata$x:0000A87E                 db    0
.xdata$x:0000A87F                 db    0
.xdata$x:0000A880                 db    0
.xdata$x:0000A881                 db    0
.xdata$x:0000A882                 db    0
.xdata$x:0000A883                 db    0
.xdata$x:0000A884                 db    0
.xdata$x:0000A885                 db    0
.xdata$x:0000A886                 db    0
.xdata$x:0000A887                 db    0
.xdata$x:0000A888                 db    0
.xdata$x:0000A889                 db    0
.xdata$x:0000A88A                 db    0
.xdata$x:0000A88B                 db    0
.xdata$x:0000A88C                 db    0
.xdata$x:0000A88D                 db    0
.xdata$x:0000A88E                 db    0
.xdata$x:0000A88F                 db    0
.xdata$x:0000A890                 db    0
.xdata$x:0000A891                 db    0
.xdata$x:0000A892                 db    0
.xdata$x:0000A893                 db    0
.xdata$x:0000A893 _xdata$x        ends
.xdata$x:0000A893
.xdata$x:0000A894 ; ===========================================================================
.xdata$x:0000A894
.xdata$x:0000A894 ; Segment type: Pure data
.xdata$x:0000A894 ; Segment permissions: Read
.xdata$x:0000A894 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A894                 assume cs:_xdata$x
.xdata$x:0000A894                 ;org 0A894h
.xdata$x:0000A894 ; COMDAT (pick associative to section at 415C)
.xdata$x:0000A894 __unwindtable$??1?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000A894                                         ; DATA XREF: .xdata$x:0000A8A4o
.xdata$x:0000A895                 db 0FFh
.xdata$x:0000A896                 db 0FFh
.xdata$x:0000A897                 db 0FFh
.xdata$x:0000A898                 dd offset __unwindfunclet$??1?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@QAE@XZ$0
.xdata$x:0000A89C __ehfuncinfo$??1?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000A89C                                         ; DATA XREF: __ehhandler$??1?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:0000A89D                 db    5
.xdata$x:0000A89E                 db  93h ; ô
.xdata$x:0000A89F                 db  19h
.xdata$x:0000A8A0                 db    1
.xdata$x:0000A8A1                 db    0
.xdata$x:0000A8A2                 db    0
.xdata$x:0000A8A3                 db    0
.xdata$x:0000A8A4                 dd offset __unwindtable$??1?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUStyle@@@std@@@std@@@std@@@std@@QAE@XZ
.xdata$x:0000A8A8                 align 20h
.xdata$x:0000A8A8 _xdata$x        ends
.xdata$x:0000A8A8
.xdata$x:0000A8C0 ; ===========================================================================
.xdata$x:0000A8C0
.xdata$x:0000A8C0 ; Segment type: Pure data
.xdata$x:0000A8C0 ; Segment permissions: Read
.xdata$x:0000A8C0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A8C0                 assume cs:_xdata$x
.xdata$x:0000A8C0                 ;org 0A8C0h
.xdata$x:0000A8C0 ; COMDAT (pick associative to section at 4B44)
.xdata$x:0000A8C0 __unwindtable$??1?$pair@$$CBHUStyle@@@std@@QAE@XZ db 0FFh
.xdata$x:0000A8C0                                         ; DATA XREF: .xdata$x:0000A8D0o
.xdata$x:0000A8C1                 db 0FFh
.xdata$x:0000A8C2                 db 0FFh
.xdata$x:0000A8C3                 db 0FFh
.xdata$x:0000A8C4                 dd offset __unwindfunclet$??1?$pair@$$CBHUStyle@@@std@@QAE@XZ$0
.xdata$x:0000A8C8 __ehfuncinfo$??1?$pair@$$CBHUStyle@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000A8C8                                         ; DATA XREF: __ehhandler$??1?$pair@$$CBHUStyle@@@std@@QAE@XZ+11o
.xdata$x:0000A8C9                 db    5
.xdata$x:0000A8CA                 db  93h ; ô
.xdata$x:0000A8CB                 db  19h
.xdata$x:0000A8CC                 db    1
.xdata$x:0000A8CD                 db    0
.xdata$x:0000A8CE                 db    0
.xdata$x:0000A8CF                 db    0
.xdata$x:0000A8D0                 dd offset __unwindtable$??1?$pair@$$CBHUStyle@@@std@@QAE@XZ
.xdata$x:0000A8D4                 db    0
.xdata$x:0000A8D5                 db    0
.xdata$x:0000A8D6                 db    0
.xdata$x:0000A8D7                 db    0
.xdata$x:0000A8D8                 db    0
.xdata$x:0000A8D9                 db    0
.xdata$x:0000A8DA                 db    0
.xdata$x:0000A8DB                 db    0
.xdata$x:0000A8DC                 db    0
.xdata$x:0000A8DD                 db    0
.xdata$x:0000A8DE                 db    0
.xdata$x:0000A8DF                 db    0
.xdata$x:0000A8E0                 db    0
.xdata$x:0000A8E1                 db    0
.xdata$x:0000A8E2                 db    0
.xdata$x:0000A8E3                 db    0
.xdata$x:0000A8E4                 db    0
.xdata$x:0000A8E5                 db    0
.xdata$x:0000A8E6                 db    0
.xdata$x:0000A8E7                 db    0
.xdata$x:0000A8E8                 db    0
.xdata$x:0000A8E9                 db    0
.xdata$x:0000A8EA                 db    0
.xdata$x:0000A8EB                 db    0
.xdata$x:0000A8EB _xdata$x        ends
.xdata$x:0000A8EB
.xdata$x:0000A8EC ; ===========================================================================
.xdata$x:0000A8EC
.xdata$x:0000A8EC ; Segment type: Pure data
.xdata$x:0000A8EC ; Segment permissions: Read
.xdata$x:0000A8EC _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A8EC                 assume cs:_xdata$x
.xdata$x:0000A8EC                 ;org 0A8ECh
.xdata$x:0000A8EC ; COMDAT (pick associative to section at 27D4)
.xdata$x:0000A8EC __unwindtable$??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVScintillaEditView@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ db 0FFh
.xdata$x:0000A8EC                                         ; DATA XREF: .xdata$x:0000A8FCo
.xdata$x:0000A8ED                 db 0FFh
.xdata$x:0000A8EE                 db 0FFh
.xdata$x:0000A8EF                 db 0FFh
.xdata$x:0000A8F0                 dd offset __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVScintillaEditView@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ$0
.xdata$x:0000A8F4 __ehfuncinfo$??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVScintillaEditView@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ db  22h ; "
.xdata$x:0000A8F4                                         ; DATA XREF: __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVScintillaEditView@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ+11o
.xdata$x:0000A8F5                 db    5
.xdata$x:0000A8F6                 db  93h ; ô
.xdata$x:0000A8F7                 db  19h
.xdata$x:0000A8F8                 db    1
.xdata$x:0000A8F9                 db    0
.xdata$x:0000A8FA                 db    0
.xdata$x:0000A8FB                 db    0
.xdata$x:0000A8FC                 dd offset __unwindtable$??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVScintillaEditView@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ
.xdata$x:0000A900                 db    0
.xdata$x:0000A901                 db    0
.xdata$x:0000A902                 db    0
.xdata$x:0000A903                 db    0
.xdata$x:0000A904                 db    0
.xdata$x:0000A905                 db    0
.xdata$x:0000A906                 db    0
.xdata$x:0000A907                 db    0
.xdata$x:0000A908                 db    0
.xdata$x:0000A909                 db    0
.xdata$x:0000A90A                 db    0
.xdata$x:0000A90B                 db    0
.xdata$x:0000A90C                 db    0
.xdata$x:0000A90D                 db    0
.xdata$x:0000A90E                 db    0
.xdata$x:0000A90F                 db    0
.xdata$x:0000A910                 db    0
.xdata$x:0000A911                 db    0
.xdata$x:0000A912                 db    0
.xdata$x:0000A913                 db    0
.xdata$x:0000A914                 db    0
.xdata$x:0000A915                 db    0
.xdata$x:0000A916                 db    0
.xdata$x:0000A917                 db    0
.xdata$x:0000A917 _xdata$x        ends
.xdata$x:0000A917
.xdata$x:0000A918 ; ===========================================================================
.xdata$x:0000A918
.xdata$x:0000A918 ; Segment type: Pure data
.xdata$x:0000A918 ; Segment permissions: Read
.xdata$x:0000A918 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A918                 assume cs:_xdata$x
.xdata$x:0000A918                 ;org 0A918h
.xdata$x:0000A918 ; COMDAT (pick associative to section at 3DAC)
.xdata$x:0000A918 __unwindtable$??1?$_Iterator012@Urandom_access_iterator_tag@std@@PAVScintillaEditView@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ db 0FFh
.xdata$x:0000A918                                         ; DATA XREF: .xdata$x:0000A928o
.xdata$x:0000A919                 db 0FFh
.xdata$x:0000A91A                 db 0FFh
.xdata$x:0000A91B                 db 0FFh
.xdata$x:0000A91C                 dd offset __unwindfunclet$??1?$_Iterator012@Urandom_access_iterator_tag@std@@PAVScintillaEditView@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ$0
.xdata$x:0000A920 __ehfuncinfo$??1?$_Iterator012@Urandom_access_iterator_tag@std@@PAVScintillaEditView@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ db  22h ; "
.xdata$x:0000A920                                         ; DATA XREF: __ehhandler$??1?$_Iterator012@Urandom_access_iterator_tag@std@@PAVScintillaEditView@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ+11o
.xdata$x:0000A921                 db    5
.xdata$x:0000A922                 db  93h ; ô
.xdata$x:0000A923                 db  19h
.xdata$x:0000A924                 db    1
.xdata$x:0000A925                 db    0
.xdata$x:0000A926                 db    0
.xdata$x:0000A927                 db    0
.xdata$x:0000A928                 dd offset __unwindtable$??1?$_Iterator012@Urandom_access_iterator_tag@std@@PAVScintillaEditView@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ
.xdata$x:0000A92C                 db    0
.xdata$x:0000A92D                 db    0
.xdata$x:0000A92E                 db    0
.xdata$x:0000A92F                 db    0
.xdata$x:0000A930                 db    0
.xdata$x:0000A931                 db    0
.xdata$x:0000A932                 db    0
.xdata$x:0000A933                 db    0
.xdata$x:0000A934                 db    0
.xdata$x:0000A935                 db    0
.xdata$x:0000A936                 db    0
.xdata$x:0000A937                 db    0
.xdata$x:0000A938                 db    0
.xdata$x:0000A939                 db    0
.xdata$x:0000A93A                 db    0
.xdata$x:0000A93B                 db    0
.xdata$x:0000A93C                 db    0
.xdata$x:0000A93D                 db    0
.xdata$x:0000A93E                 db    0
.xdata$x:0000A93F                 db    0
.xdata$x:0000A940                 db    0
.xdata$x:0000A941                 db    0
.xdata$x:0000A942                 db    0
.xdata$x:0000A943                 db    0
.xdata$x:0000A943 _xdata$x        ends
.xdata$x:0000A943
.xdata$x:0000A944 ; ===========================================================================
.xdata$x:0000A944
.xdata$x:0000A944 ; Segment type: Pure data
.xdata$x:0000A944 ; Segment permissions: Read
.xdata$x:0000A944 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A944                 assume cs:_xdata$x
.xdata$x:0000A944                 ;org 0A944h
.xdata$x:0000A944 ; COMDAT (pick associative to section at 275C)
.xdata$x:0000A944 __unwindtable$??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVScintillaEditView@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z db 0FFh
.xdata$x:0000A944                                         ; DATA XREF: .xdata$x:0000A954o
.xdata$x:0000A945                 db 0FFh
.xdata$x:0000A946                 db 0FFh
.xdata$x:0000A947                 db 0FFh
.xdata$x:0000A948                 dd offset __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVScintillaEditView@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z$0
.xdata$x:0000A94C __ehfuncinfo$??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVScintillaEditView@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z db  22h ; "
.xdata$x:0000A94C                                         ; DATA XREF: __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVScintillaEditView@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z+11o
.xdata$x:0000A94D                 db    5
.xdata$x:0000A94E                 db  93h ; ô
.xdata$x:0000A94F                 db  19h
.xdata$x:0000A950                 db    1
.xdata$x:0000A951                 db    0
.xdata$x:0000A952                 db    0
.xdata$x:0000A953                 db    0
.xdata$x:0000A954                 dd offset __unwindtable$??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVScintillaEditView@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z
.xdata$x:0000A958                 db    0
.xdata$x:0000A959                 db    0
.xdata$x:0000A95A                 db    0
.xdata$x:0000A95B                 db    0
.xdata$x:0000A95C                 db    0
.xdata$x:0000A95D                 db    0
.xdata$x:0000A95E                 db    0
.xdata$x:0000A95F                 db    0
.xdata$x:0000A960                 db    0
.xdata$x:0000A961                 db    0
.xdata$x:0000A962                 db    0
.xdata$x:0000A963                 db    0
.xdata$x:0000A964                 db    0
.xdata$x:0000A965                 db    0
.xdata$x:0000A966                 db    0
.xdata$x:0000A967                 db    0
.xdata$x:0000A968                 db    0
.xdata$x:0000A969                 db    0
.xdata$x:0000A96A                 db    0
.xdata$x:0000A96B                 db    0
.xdata$x:0000A96C                 db    0
.xdata$x:0000A96D                 db    0
.xdata$x:0000A96E                 db    0
.xdata$x:0000A96F                 db    0
.xdata$x:0000A96F _xdata$x        ends
.xdata$x:0000A96F
.xdata$x:0000A970 ; ===========================================================================
.xdata$x:0000A970
.xdata$x:0000A970 ; Segment type: Pure data
.xdata$x:0000A970 ; Segment permissions: Read
.xdata$x:0000A970 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A970                 assume cs:_xdata$x
.xdata$x:0000A970                 ;org 0A970h
.xdata$x:0000A970 ; COMDAT (pick associative to section at 3080)
.xdata$x:0000A970 __unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@PAPAVScintillaEditView@@PBU_Container_base12@1@@Z db 0FFh
.xdata$x:0000A970                                         ; DATA XREF: .xdata$x:0000A980o
.xdata$x:0000A971                 db 0FFh
.xdata$x:0000A972                 db 0FFh
.xdata$x:0000A973                 db 0FFh
.xdata$x:0000A974                 dd offset __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@PAPAVScintillaEditView@@PBU_Container_base12@1@@Z$0
.xdata$x:0000A978 __ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@PAPAVScintillaEditView@@PBU_Container_base12@1@@Z db  22h ; "
.xdata$x:0000A978                                         ; DATA XREF: __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@PAPAVScintillaEditView@@PBU_Container_base12@1@@Z+11o
.xdata$x:0000A979                 db    5
.xdata$x:0000A97A                 db  93h ; ô
.xdata$x:0000A97B                 db  19h
.xdata$x:0000A97C                 db    1
.xdata$x:0000A97D                 db    0
.xdata$x:0000A97E                 db    0
.xdata$x:0000A97F                 db    0
.xdata$x:0000A980                 dd offset __unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@PAPAVScintillaEditView@@PBU_Container_base12@1@@Z
.xdata$x:0000A984                 db    0
.xdata$x:0000A985                 db    0
.xdata$x:0000A986                 db    0
.xdata$x:0000A987                 db    0
.xdata$x:0000A988                 db    0
.xdata$x:0000A989                 db    0
.xdata$x:0000A98A                 db    0
.xdata$x:0000A98B                 db    0
.xdata$x:0000A98C                 db    0
.xdata$x:0000A98D                 db    0
.xdata$x:0000A98E                 db    0
.xdata$x:0000A98F                 db    0
.xdata$x:0000A990                 db    0
.xdata$x:0000A991                 db    0
.xdata$x:0000A992                 db    0
.xdata$x:0000A993                 db    0
.xdata$x:0000A994                 db    0
.xdata$x:0000A995                 db    0
.xdata$x:0000A996                 db    0
.xdata$x:0000A997                 db    0
.xdata$x:0000A998                 db    0
.xdata$x:0000A999                 db    0
.xdata$x:0000A99A                 db    0
.xdata$x:0000A99B                 db    0
.xdata$x:0000A99B _xdata$x        ends
.xdata$x:0000A99B
.xdata$x:0000A99C ; ===========================================================================
.xdata$x:0000A99C
.xdata$x:0000A99C ; Segment type: Pure data
.xdata$x:0000A99C ; Segment permissions: Read
.xdata$x:0000A99C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A99C                 assume cs:_xdata$x
.xdata$x:0000A99C                 ;org 0A99Ch
.xdata$x:0000A99C ; COMDAT (pick associative to section at 46BC)
.xdata$x:0000A99C __unwindtable$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000A99C                                         ; DATA XREF: .xdata$x:0000A9ACo
.xdata$x:0000A99D                 db 0FFh
.xdata$x:0000A99E                 db 0FFh
.xdata$x:0000A99F                 db 0FFh
.xdata$x:0000A9A0                 dd offset __unwindfunclet$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@XZ$0
.xdata$x:0000A9A4 __ehfuncinfo$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000A9A4                                         ; DATA XREF: __ehhandler$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:0000A9A5                 db    5
.xdata$x:0000A9A6                 db  93h ; ô
.xdata$x:0000A9A7                 db  19h
.xdata$x:0000A9A8                 db    1
.xdata$x:0000A9A9                 db    0
.xdata$x:0000A9AA                 db    0
.xdata$x:0000A9AB                 db    0
.xdata$x:0000A9AC                 dd offset __unwindtable$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@XZ
.xdata$x:0000A9B0                 db    0
.xdata$x:0000A9B1                 db    0
.xdata$x:0000A9B2                 db    0
.xdata$x:0000A9B3                 db    0
.xdata$x:0000A9B4                 db    0
.xdata$x:0000A9B5                 db    0
.xdata$x:0000A9B6                 db    0
.xdata$x:0000A9B7                 db    0
.xdata$x:0000A9B8                 db    0
.xdata$x:0000A9B9                 db    0
.xdata$x:0000A9BA                 db    0
.xdata$x:0000A9BB                 db    0
.xdata$x:0000A9BC                 db    0
.xdata$x:0000A9BD                 db    0
.xdata$x:0000A9BE                 db    0
.xdata$x:0000A9BF                 db    0
.xdata$x:0000A9C0                 db    0
.xdata$x:0000A9C1                 db    0
.xdata$x:0000A9C2                 db    0
.xdata$x:0000A9C3                 db    0
.xdata$x:0000A9C4                 db    0
.xdata$x:0000A9C5                 db    0
.xdata$x:0000A9C6                 db    0
.xdata$x:0000A9C7                 db    0
.xdata$x:0000A9C7 _xdata$x        ends
.xdata$x:0000A9C7
.xdata$x:0000A9C8 ; ===========================================================================
.xdata$x:0000A9C8
.xdata$x:0000A9C8 ; Segment type: Pure data
.xdata$x:0000A9C8 ; Segment permissions: Read
.xdata$x:0000A9C8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A9C8                 assume cs:_xdata$x
.xdata$x:0000A9C8                 ;org 0A9C8h
.xdata$x:0000A9C8 ; COMDAT (pick associative to section at 2FFC)
.xdata$x:0000A9C8 __unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@ABV01@@Z db 0FFh
.xdata$x:0000A9C8                                         ; DATA XREF: .xdata$x:0000A9D8o
.xdata$x:0000A9C9                 db 0FFh
.xdata$x:0000A9CA                 db 0FFh
.xdata$x:0000A9CB                 db 0FFh
.xdata$x:0000A9CC                 dd offset __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@ABV01@@Z$0
.xdata$x:0000A9D0 __ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@ABV01@@Z db  22h ; "
.xdata$x:0000A9D0                                         ; DATA XREF: __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@ABV01@@Z+11o
.xdata$x:0000A9D1                 db    5
.xdata$x:0000A9D2                 db  93h ; ô
.xdata$x:0000A9D3                 db  19h
.xdata$x:0000A9D4                 db    1
.xdata$x:0000A9D5                 db    0
.xdata$x:0000A9D6                 db    0
.xdata$x:0000A9D7                 db    0
.xdata$x:0000A9D8                 dd offset __unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@ABV01@@Z
.xdata$x:0000A9DC                 db    0
.xdata$x:0000A9DD                 db    0
.xdata$x:0000A9DE                 db    0
.xdata$x:0000A9DF                 db    0
.xdata$x:0000A9E0                 db    0
.xdata$x:0000A9E1                 db    0
.xdata$x:0000A9E2                 db    0
.xdata$x:0000A9E3                 db    0
.xdata$x:0000A9E4                 db    0
.xdata$x:0000A9E5                 db    0
.xdata$x:0000A9E6                 db    0
.xdata$x:0000A9E7                 db    0
.xdata$x:0000A9E8                 db    0
.xdata$x:0000A9E9                 db    0
.xdata$x:0000A9EA                 db    0
.xdata$x:0000A9EB                 db    0
.xdata$x:0000A9EC                 db    0
.xdata$x:0000A9ED                 db    0
.xdata$x:0000A9EE                 db    0
.xdata$x:0000A9EF                 db    0
.xdata$x:0000A9F0                 db    0
.xdata$x:0000A9F1                 db    0
.xdata$x:0000A9F2                 db    0
.xdata$x:0000A9F3                 db    0
.xdata$x:0000A9F3 _xdata$x        ends
.xdata$x:0000A9F3
.xdata$x:0000A9F4 ; ===========================================================================
.xdata$x:0000A9F4
.xdata$x:0000A9F4 ; Segment type: Pure data
.xdata$x:0000A9F4 ; Segment permissions: Read
.xdata$x:0000A9F4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A9F4                 assume cs:_xdata$x
.xdata$x:0000A9F4                 ;org 0A9F4h
.xdata$x:0000A9F4 ; COMDAT (pick associative to section at 3294)
.xdata$x:0000A9F4 __unwindtable$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@PAPAVScintillaEditView@@PBU_Container_base12@1@@Z db 0FFh
.xdata$x:0000A9F4                                         ; DATA XREF: .xdata$x:0000AA04o
.xdata$x:0000A9F5                 db 0FFh
.xdata$x:0000A9F6                 db 0FFh
.xdata$x:0000A9F7                 db 0FFh
.xdata$x:0000A9F8                 dd offset __unwindfunclet$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@PAPAVScintillaEditView@@PBU_Container_base12@1@@Z$0
.xdata$x:0000A9FC __ehfuncinfo$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@PAPAVScintillaEditView@@PBU_Container_base12@1@@Z db  22h ; "
.xdata$x:0000A9FC                                         ; DATA XREF: __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@PAPAVScintillaEditView@@PBU_Container_base12@1@@Z+11o
.xdata$x:0000A9FD                 db    5
.xdata$x:0000A9FE                 db  93h ; ô
.xdata$x:0000A9FF                 db  19h
.xdata$x:0000AA00                 db    1
.xdata$x:0000AA01                 db    0
.xdata$x:0000AA02                 db    0
.xdata$x:0000AA03                 db    0
.xdata$x:0000AA04                 dd offset __unwindtable$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@PAPAVScintillaEditView@@PBU_Container_base12@1@@Z
.xdata$x:0000AA08                 align 20h
.xdata$x:0000AA08 _xdata$x        ends
.xdata$x:0000AA08
.xdata$x:0000AA20 ; ===========================================================================
.xdata$x:0000AA20
.xdata$x:0000AA20 ; Segment type: Pure data
.xdata$x:0000AA20 ; Segment permissions: Read
.xdata$x:0000AA20 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000AA20                 assume cs:_xdata$x
.xdata$x:0000AA20                 ;org 0AA20h
.xdata$x:0000AA20 ; COMDAT (pick associative to section at 591C)
.xdata$x:0000AA20 __unwindtable$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QBE?AV01@H@Z db 0FFh
.xdata$x:0000AA20                                         ; DATA XREF: .xdata$x:0000AA38o
.xdata$x:0000AA21                 db 0FFh
.xdata$x:0000AA22                 db 0FFh
.xdata$x:0000AA23                 db 0FFh
.xdata$x:0000AA24                 dd offset __unwindfunclet$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QBE?AV01@H@Z$1
.xdata$x:0000AA28                 db    0
.xdata$x:0000AA29                 db    0
.xdata$x:0000AA2A                 db    0
.xdata$x:0000AA2B                 db    0
.xdata$x:0000AA2C                 dd offset __unwindfunclet$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QBE?AV01@H@Z$0
.xdata$x:0000AA30 __ehfuncinfo$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QBE?AV01@H@Z db  22h ; "
.xdata$x:0000AA30                                         ; DATA XREF: __ehhandler$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QBE?AV01@H@Z+11o
.xdata$x:0000AA31                 db    5
.xdata$x:0000AA32                 db  93h ; ô
.xdata$x:0000AA33                 db  19h
.xdata$x:0000AA34                 db    2
.xdata$x:0000AA35                 db    0
.xdata$x:0000AA36                 db    0
.xdata$x:0000AA37                 db    0
.xdata$x:0000AA38                 dd offset __unwindtable$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QBE?AV01@H@Z
.xdata$x:0000AA3C                 db    0
.xdata$x:0000AA3D                 db    0
.xdata$x:0000AA3E                 db    0
.xdata$x:0000AA3F                 db    0
.xdata$x:0000AA40                 db    0
.xdata$x:0000AA41                 db    0
.xdata$x:0000AA42                 db    0
.xdata$x:0000AA43                 db    0
.xdata$x:0000AA44                 db    0
.xdata$x:0000AA45                 db    0
.xdata$x:0000AA46                 db    0
.xdata$x:0000AA47                 db    0
.xdata$x:0000AA48                 db    0
.xdata$x:0000AA49                 db    0
.xdata$x:0000AA4A                 db    0
.xdata$x:0000AA4B                 db    0
.xdata$x:0000AA4C                 db    0
.xdata$x:0000AA4D                 db    0
.xdata$x:0000AA4E                 db    0
.xdata$x:0000AA4F                 db    0
.xdata$x:0000AA50                 db    0
.xdata$x:0000AA51                 db    0
.xdata$x:0000AA52                 db    0
.xdata$x:0000AA53                 db    0
.xdata$x:0000AA53 _xdata$x        ends
.xdata$x:0000AA53
.xdata$x:0000AA54 ; ===========================================================================
.xdata$x:0000AA54
.xdata$x:0000AA54 ; Segment type: Pure data
.xdata$x:0000AA54 ; Segment permissions: Read
.xdata$x:0000AA54 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000AA54                 assume cs:_xdata$x
.xdata$x:0000AA54                 ;org 0AA54h
.xdata$x:0000AA54 ; COMDAT (pick associative to section at 479C)
.xdata$x:0000AA54 __unwindtable$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000AA54                                         ; DATA XREF: .xdata$x:0000AA64o
.xdata$x:0000AA55                 db 0FFh
.xdata$x:0000AA56                 db 0FFh
.xdata$x:0000AA57                 db 0FFh
.xdata$x:0000AA58                 dd offset __unwindfunclet$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@XZ$0
.xdata$x:0000AA5C __ehfuncinfo$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000AA5C                                         ; DATA XREF: __ehhandler$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:0000AA5D                 db    5
.xdata$x:0000AA5E                 db  93h ; ô
.xdata$x:0000AA5F                 db  19h
.xdata$x:0000AA60                 db    1
.xdata$x:0000AA61                 db    0
.xdata$x:0000AA62                 db    0
.xdata$x:0000AA63                 db    0
.xdata$x:0000AA64                 dd offset __unwindtable$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@XZ
.xdata$x:0000AA68                 align 20h
.xdata$x:0000AA68 _xdata$x        ends
.xdata$x:0000AA68
.xdata$x:0000AA80 ; ===========================================================================
.xdata$x:0000AA80
.xdata$x:0000AA80 ; Segment type: Pure data
.xdata$x:0000AA80 ; Segment permissions: Read
.xdata$x:0000AA80 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000AA80                 assume cs:_xdata$x
.xdata$x:0000AA80                 ;org 0AA80h
.xdata$x:0000AA80 ; COMDAT (pick associative to section at 321C)
.xdata$x:0000AA80 __unwindtable$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@ABV01@@Z db 0FFh
.xdata$x:0000AA80                                         ; DATA XREF: .xdata$x:0000AA90o
.xdata$x:0000AA81                 db 0FFh
.xdata$x:0000AA82                 db 0FFh
.xdata$x:0000AA83                 db 0FFh
.xdata$x:0000AA84                 dd offset __unwindfunclet$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@ABV01@@Z$0
.xdata$x:0000AA88 __ehfuncinfo$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@ABV01@@Z db  22h ; "
.xdata$x:0000AA88                                         ; DATA XREF: __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@ABV01@@Z+11o
.xdata$x:0000AA89                 db    5
.xdata$x:0000AA8A                 db  93h ; ô
.xdata$x:0000AA8B                 db  19h
.xdata$x:0000AA8C                 db    1
.xdata$x:0000AA8D                 db    0
.xdata$x:0000AA8E                 db    0
.xdata$x:0000AA8F                 db    0
.xdata$x:0000AA90                 dd offset __unwindtable$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVScintillaEditView@@@std@@@std@@@std@@QAE@ABV01@@Z
.xdata$x:0000AA94                 db    0
.xdata$x:0000AA95                 db    0
.xdata$x:0000AA96                 db    0
.xdata$x:0000AA97                 db    0
.xdata$x:0000AA98                 db    0
.xdata$x:0000AA99                 db    0
.xdata$x:0000AA9A                 db    0
.xdata$x:0000AA9B                 db    0
.xdata$x:0000AA9C                 db    0
.xdata$x:0000AA9D                 db    0
.xdata$x:0000AA9E                 db    0
.xdata$x:0000AA9F                 db    0
.xdata$x:0000AAA0                 db    0
.xdata$x:0000AAA1                 db    0
.xdata$x:0000AAA2                 db    0
.xdata$x:0000AAA3                 db    0
.xdata$x:0000AAA4                 db    0
.xdata$x:0000AAA5                 db    0
.xdata$x:0000AAA6                 db    0
.xdata$x:0000AAA7                 db    0
.xdata$x:0000AAA8                 db    0
.xdata$x:0000AAA9                 db    0
.xdata$x:0000AAAA                 db    0
.xdata$x:0000AAAB                 db    0
.xdata$x:0000AAAB _xdata$x        ends
.xdata$x:0000AAAB
.xdata$x:0000AAAC ; ===========================================================================
.xdata$x:0000AAAC
.xdata$x:0000AAAC ; Segment type: Pure data
.xdata$x:0000AAAC ; Segment permissions: Read
.xdata$x:0000AAAC _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000AAAC                 assume cs:_xdata$x
.xdata$x:0000AAAC                 ;org 0AAACh
.xdata$x:0000AAAC ; COMDAT (pick associative to section at 1EFC)
.xdata$x:0000AAAC __unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z db 0FFh
.xdata$x:0000AAAC                                         ; DATA XREF: .xdata$x:0000AABCo
.xdata$x:0000AAAD                 db 0FFh
.xdata$x:0000AAAE                 db 0FFh
.xdata$x:0000AAAF                 db 0FFh
.xdata$x:0000AAB0                 dd offset __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0
.xdata$x:0000AAB4 __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z db  22h ; "
.xdata$x:0000AAB4                                         ; DATA XREF: __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z+11o
.xdata$x:0000AAB5                 db    5
.xdata$x:0000AAB6                 db  93h ; ô
.xdata$x:0000AAB7                 db  19h
.xdata$x:0000AAB8                 db    1
.xdata$x:0000AAB9                 db    0
.xdata$x:0000AABA                 db    0
.xdata$x:0000AABB                 db    0
.xdata$x:0000AABC                 dd offset __unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.xdata$x:0000AAC0                 db    0
.xdata$x:0000AAC1                 db    0
.xdata$x:0000AAC2                 db    0
.xdata$x:0000AAC3                 db    0
.xdata$x:0000AAC4                 db    0
.xdata$x:0000AAC5                 db    0
.xdata$x:0000AAC6                 db    0
.xdata$x:0000AAC7                 db    0
.xdata$x:0000AAC8                 db    0
.xdata$x:0000AAC9                 db    0
.xdata$x:0000AACA                 db    0
.xdata$x:0000AACB                 db    0
.xdata$x:0000AACC                 db    0
.xdata$x:0000AACD                 db    0
.xdata$x:0000AACE                 db    0
.xdata$x:0000AACF                 db    0
.xdata$x:0000AAD0                 db    0
.xdata$x:0000AAD1                 db    0
.xdata$x:0000AAD2                 db    0
.xdata$x:0000AAD3                 db    0
.xdata$x:0000AAD4                 db    0
.xdata$x:0000AAD5                 db    0
.xdata$x:0000AAD6                 db    0
.xdata$x:0000AAD7                 db    0
.xdata$x:0000AAD7 _xdata$x        ends
.xdata$x:0000AAD7
.xdata$x:0000AAD8 ; ===========================================================================
.xdata$x:0000AAD8
.xdata$x:0000AAD8 ; Segment type: Pure data
.xdata$x:0000AAD8 ; Segment permissions: Read
.xdata$x:0000AAD8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000AAD8                 assume cs:_xdata$x
.xdata$x:0000AAD8                 ;org 0AAD8h
.xdata$x:0000AAD8 ; COMDAT (pick associative to section at 28C0)
.xdata$x:0000AAD8 __unwindtable$??0?$_Iterator012@Urandom_access_iterator_tag@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@HPBV32@ABV32@U_Iterator_base12@2@@std@@QAE@XZ db 0FFh
.xdata$x:0000AAD8                                         ; DATA XREF: .xdata$x:0000AAE8o
.xdata$x:0000AAD9                 db 0FFh
.xdata$x:0000AADA                 db 0FFh
.xdata$x:0000AADB                 db 0FFh
.xdata$x:0000AADC                 dd offset __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@HPBV32@ABV32@U_Iterator_base12@2@@std@@QAE@XZ$0
.xdata$x:0000AAE0 __ehfuncinfo$??0?$_Iterator012@Urandom_access_iterator_tag@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@HPBV32@ABV32@U_Iterator_base12@2@@std@@QAE@XZ db  22h ; "
.xdata$x:0000AAE0                                         ; DATA XREF: __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@HPBV32@ABV32@U_Iterator_base12@2@@std@@QAE@XZ+11o
.xdata$x:0000AAE1                 db    5
.xdata$x:0000AAE2                 db  93h ; ô
.xdata$x:0000AAE3                 db  19h
.xdata$x:0000AAE4                 db    1
.xdata$x:0000AAE5                 db    0
.xdata$x:0000AAE6                 db    0
.xdata$x:0000AAE7                 db    0
.xdata$x:0000AAE8                 dd offset __unwindtable$??0?$_Iterator012@Urandom_access_iterator_tag@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@HPBV32@ABV32@U_Iterator_base12@2@@std@@QAE@XZ
.xdata$x:0000AAEC                 db    0
.xdata$x:0000AAED                 db    0
.xdata$x:0000AAEE                 db    0
.xdata$x:0000AAEF                 db    0
.xdata$x:0000AAF0                 db    0
.xdata$x:0000AAF1                 db    0
.xdata$x:0000AAF2                 db    0
.xdata$x:0000AAF3                 db    0
.xdata$x:0000AAF4                 db    0
.xdata$x:0000AAF5                 db    0
.xdata$x:0000AAF6                 db    0
.xdata$x:0000AAF7                 db    0
.xdata$x:0000AAF8                 db    0
.xdata$x:0000AAF9                 db    0
.xdata$x:0000AAFA                 db    0
.xdata$x:0000AAFB                 db    0
.xdata$x:0000AAFC                 db    0
.xdata$x:0000AAFD                 db    0
.xdata$x:0000AAFE                 db    0
.xdata$x:0000AAFF                 db    0
.xdata$x:0000AB00                 db    0
.xdata$x:0000AB01                 db    0
.xdata$x:0000AB02                 db    0
.xdata$x:0000AB03                 db    0
.xdata$x:0000AB03 _xdata$x        ends
.xdata$x:0000AB03
.xdata$x:0000AB04 ; ===========================================================================
.xdata$x:0000AB04
.xdata$x:0000AB04 ; Segment type: Pure data
.xdata$x:0000AB04 ; Segment permissions: Read
.xdata$x:0000AB04 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000AB04                 assume cs:_xdata$x
.xdata$x:0000AB04                 ;org 0AB04h
.xdata$x:0000AB04 ; COMDAT (pick associative to section at 3E1C)
.xdata$x:0000AB04 __unwindtable$??1?$_Iterator012@Urandom_access_iterator_tag@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@HPBV32@ABV32@U_Iterator_base12@2@@std@@QAE@XZ db 0FFh
.xdata$x:0000AB04                                         ; DATA XREF: .xdata$x:0000AB14o
.xdata$x:0000AB05                 db 0FFh
.xdata$x:0000AB06                 db 0FFh
.xdata$x:0000AB07                 db 0FFh
.xdata$x:0000AB08                 dd offset __unwindfunclet$??1?$_Iterator012@Urandom_access_iterator_tag@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@HPBV32@ABV32@U_Iterator_base12@2@@std@@QAE@XZ$0
.xdata$x:0000AB0C __ehfuncinfo$??1?$_Iterator012@Urandom_access_iterator_tag@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@HPBV32@ABV32@U_Iterator_base12@2@@std@@QAE@XZ db  22h ; "
.xdata$x:0000AB0C                                         ; DATA XREF: __ehhandler$??1?$_Iterator012@Urandom_access_iterator_tag@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@HPBV32@ABV32@U_Iterator_base12@2@@std@@QAE@XZ+11o
.xdata$x:0000AB0D                 db    5
.xdata$x:0000AB0E                 db  93h ; ô
.xdata$x:0000AB0F                 db  19h
.xdata$x:0000AB10                 db    1
.xdata$x:0000AB11                 db    0
.xdata$x:0000AB12                 db    0
.xdata$x:0000AB13                 db    0
.xdata$x:0000AB14                 dd offset __unwindtable$??1?$_Iterator012@Urandom_access_iterator_tag@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@HPBV32@ABV32@U_Iterator_base12@2@@std@@QAE@XZ
.xdata$x:0000AB18                 db    0
.xdata$x:0000AB19                 db    0
.xdata$x:0000AB1A                 db    0
.xdata$x:0000AB1B                 db    0
.xdata$x:0000AB1C                 db    0
.xdata$x:0000AB1D                 db    0
.xdata$x:0000AB1E                 db    0
.xdata$x:0000AB1F                 db    0
.xdata$x:0000AB20                 db    0
.xdata$x:0000AB21                 db    0
.xdata$x:0000AB22                 db    0
.xdata$x:0000AB23                 db    0
.xdata$x:0000AB24                 db    0
.xdata$x:0000AB25                 db    0
.xdata$x:0000AB26                 db    0
.xdata$x:0000AB27                 db    0
.xdata$x:0000AB28                 db    0
.xdata$x:0000AB29                 db    0
.xdata$x:0000AB2A                 db    0
.xdata$x:0000AB2B                 db    0
.xdata$x:0000AB2C                 db    0
.xdata$x:0000AB2D                 db    0
.xdata$x:0000AB2E                 db    0
.xdata$x:0000AB2F                 db    0
.xdata$x:0000AB2F _xdata$x        ends
.xdata$x:0000AB2F
.xdata$x:0000AB30 ; ===========================================================================
.xdata$x:0000AB30
.xdata$x:0000AB30 ; Segment type: Pure data
.xdata$x:0000AB30 ; Segment permissions: Read
.xdata$x:0000AB30 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000AB30                 assume cs:_xdata$x
.xdata$x:0000AB30                 ;org 0AB30h
.xdata$x:0000AB30 ; COMDAT (pick associative to section at 2848)
.xdata$x:0000AB30 __unwindtable$??0?$_Iterator012@Urandom_access_iterator_tag@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@HPBV32@ABV32@U_Iterator_base12@2@@std@@QAE@ABU01@@Z db 0FFh
.xdata$x:0000AB30                                         ; DATA XREF: .xdata$x:0000AB40o
.xdata$x:0000AB31                 db 0FFh
.xdata$x:0000AB32                 db 0FFh
.xdata$x:0000AB33                 db 0FFh
.xdata$x:0000AB34                 dd offset __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@HPBV32@ABV32@U_Iterator_base12@2@@std@@QAE@ABU01@@Z$0
.xdata$x:0000AB38 __ehfuncinfo$??0?$_Iterator012@Urandom_access_iterator_tag@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@HPBV32@ABV32@U_Iterator_base12@2@@std@@QAE@ABU01@@Z db  22h ; "
.xdata$x:0000AB38                                         ; DATA XREF: __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@HPBV32@ABV32@U_Iterator_base12@2@@std@@QAE@ABU01@@Z+11o
.xdata$x:0000AB39                 db    5
.xdata$x:0000AB3A                 db  93h ; ô
.xdata$x:0000AB3B                 db  19h
.xdata$x:0000AB3C                 db    1
.xdata$x:0000AB3D                 db    0
.xdata$x:0000AB3E                 db    0
.xdata$x:0000AB3F                 db    0
.xdata$x:0000AB40                 dd offset __unwindtable$??0?$_Iterator012@Urandom_access_iterator_tag@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@2@HPBV32@ABV32@U_Iterator_base12@2@@std@@QAE@ABU01@@Z
.xdata$x:0000AB44                 db    0
.xdata$x:0000AB45                 db    0
.xdata$x:0000AB46                 db    0
.xdata$x:0000AB47                 db    0
.xdata$x:0000AB48                 db    0
.xdata$x:0000AB49                 db    0
.xdata$x:0000AB4A                 db    0
.xdata$x:0000AB4B                 db    0
.xdata$x:0000AB4C                 db    0
.xdata$x:0000AB4D                 db    0
.xdata$x:0000AB4E                 db    0
.xdata$x:0000AB4F                 db    0
.xdata$x:0000AB50                 db    0
.xdata$x:0000AB51                 db    0
.xdata$x:0000AB52                 db    0
.xdata$x:0000AB53                 db    0
.xdata$x:0000AB54                 db    0
.xdata$x:0000AB55                 db    0
.xdata$x:0000AB56                 db    0
.xdata$x:0000AB57                 db    0
.xdata$x:0000AB58                 db    0
.xdata$x:0000AB59                 db    0
.xdata$x:0000AB5A                 db    0
.xdata$x:0000AB5B                 db    0
.xdata$x:0000AB5B _xdata$x        ends
.xdata$x:0000AB5B
.xdata$x:0000AB5C ; ===========================================================================
.xdata$x:0000AB5C
.xdata$x:0000AB5C ; Segment type: Pure data
.xdata$x:0000AB5C ; Segment permissions: Read
.xdata$x:0000AB5C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000AB5C                 assume cs:_xdata$x
.xdata$x:0000AB5C                 ;org 0AB5Ch
.xdata$x:0000AB5C ; COMDAT (pick associative to section at 3190)
.xdata$x:0000AB5C __unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@st db 0FFh
.xdata$x:0000AB5C                                         ; DATA XREF: .xdata$x:0000AB6Co
.xdata$x:0000AB5D                 db 0FFh
.xdata$x:0000AB5E                 db 0FFh
.xdata$x:0000AB5F                 db 0FFh
.xdata$x:0000AB60                 dd offset __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@PBU_Container_base12@1@@Z$0
.xdata$x:0000AB64 __ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std db  22h ; "
.xdata$x:0000AB64                                         ; DATA XREF: __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@PBU_Container_base12@1@@Z+11o
.xdata$x:0000AB65                 db    5
.xdata$x:0000AB66                 db  93h ; ô
.xdata$x:0000AB67                 db  19h
.xdata$x:0000AB68                 db    1
.xdata$x:0000AB69                 db    0
.xdata$x:0000AB6A                 db    0
.xdata$x:0000AB6B                 db    0
.xdata$x:0000AB6C                 dd offset __unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@PBU_Container_base12@1@@Z
.xdata$x:0000AB70                 db    0
.xdata$x:0000AB71                 db    0
.xdata$x:0000AB72                 db    0
.xdata$x:0000AB73                 db    0
.xdata$x:0000AB74                 db    0
.xdata$x:0000AB75                 db    0
.xdata$x:0000AB76                 db    0
.xdata$x:0000AB77                 db    0
.xdata$x:0000AB78                 db    0
.xdata$x:0000AB79                 db    0
.xdata$x:0000AB7A                 db    0
.xdata$x:0000AB7B                 db    0
.xdata$x:0000AB7C                 db    0
.xdata$x:0000AB7D                 db    0
.xdata$x:0000AB7E                 db    0
.xdata$x:0000AB7F                 db    0
.xdata$x:0000AB80                 db    0
.xdata$x:0000AB81                 db    0
.xdata$x:0000AB82                 db    0
.xdata$x:0000AB83                 db    0
.xdata$x:0000AB84                 db    0
.xdata$x:0000AB85                 db    0
.xdata$x:0000AB86                 db    0
.xdata$x:0000AB87                 db    0
.xdata$x:0000AB87 _xdata$x        ends
.xdata$x:0000AB87
.xdata$x:0000AB88 ; ===========================================================================
.xdata$x:0000AB88
.xdata$x:0000AB88 ; Segment type: Pure data
.xdata$x:0000AB88 ; Segment permissions: Read
.xdata$x:0000AB88 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000AB88                 assume cs:_xdata$x
.xdata$x:0000AB88                 ;org 0AB88h
.xdata$x:0000AB88 ; COMDAT (pick associative to section at 472C)
.xdata$x:0000AB88 __unwindtable$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000AB88                                         ; DATA XREF: .xdata$x:0000AB98o
.xdata$x:0000AB89                 db 0FFh
.xdata$x:0000AB8A                 db 0FFh
.xdata$x:0000AB8B                 db 0FFh
.xdata$x:0000AB8C                 dd offset __unwindfunclet$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ$0
.xdata$x:0000AB90 __ehfuncinfo$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000AB90                                         ; DATA XREF: __ehhandler$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:0000AB91                 db    5
.xdata$x:0000AB92                 db  93h ; ô
.xdata$x:0000AB93                 db  19h
.xdata$x:0000AB94                 db    1
.xdata$x:0000AB95                 db    0
.xdata$x:0000AB96                 db    0
.xdata$x:0000AB97                 db    0
.xdata$x:0000AB98                 dd offset __unwindtable$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ
.xdata$x:0000AB9C                 db    0
.xdata$x:0000AB9D                 db    0
.xdata$x:0000AB9E                 db    0
.xdata$x:0000AB9F                 db    0
.xdata$x:0000ABA0                 db    0
.xdata$x:0000ABA1                 db    0
.xdata$x:0000ABA2                 db    0
.xdata$x:0000ABA3                 db    0
.xdata$x:0000ABA4                 db    0
.xdata$x:0000ABA5                 db    0
.xdata$x:0000ABA6                 db    0
.xdata$x:0000ABA7                 db    0
.xdata$x:0000ABA8                 db    0
.xdata$x:0000ABA9                 db    0
.xdata$x:0000ABAA                 db    0
.xdata$x:0000ABAB                 db    0
.xdata$x:0000ABAC                 db    0
.xdata$x:0000ABAD                 db    0
.xdata$x:0000ABAE                 db    0
.xdata$x:0000ABAF                 db    0
.xdata$x:0000ABB0                 db    0
.xdata$x:0000ABB1                 db    0
.xdata$x:0000ABB2                 db    0
.xdata$x:0000ABB3                 db    0
.xdata$x:0000ABB3 _xdata$x        ends
.xdata$x:0000ABB3
.xdata$x:0000ABB4 ; ===========================================================================
.xdata$x:0000ABB4
.xdata$x:0000ABB4 ; Segment type: Pure data
.xdata$x:0000ABB4 ; Segment permissions: Read
.xdata$x:0000ABB4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000ABB4                 assume cs:_xdata$x
.xdata$x:0000ABB4                 ;org 0ABB4h
.xdata$x:0000ABB4 ; COMDAT (pick associative to section at 310C)
.xdata$x:0000ABB4 __unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@ABV01@@Z db 0FFh
.xdata$x:0000ABB4                                         ; DATA XREF: .xdata$x:0000ABC4o
.xdata$x:0000ABB5                 db 0FFh
.xdata$x:0000ABB6                 db 0FFh
.xdata$x:0000ABB7                 db 0FFh
.xdata$x:0000ABB8                 dd offset __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@ABV01@@Z$0
.xdata$x:0000ABBC __ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@ABV01@@Z db  22h ; "
.xdata$x:0000ABBC                                         ; DATA XREF: __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@ABV01@@Z+11o
.xdata$x:0000ABBD                 db    5
.xdata$x:0000ABBE                 db  93h ; ô
.xdata$x:0000ABBF                 db  19h
.xdata$x:0000ABC0                 db    1
.xdata$x:0000ABC1                 db    0
.xdata$x:0000ABC2                 db    0
.xdata$x:0000ABC3                 db    0
.xdata$x:0000ABC4                 dd offset __unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@ABV01@@Z
.xdata$x:0000ABC8                 align 20h
.xdata$x:0000ABC8 _xdata$x        ends
.xdata$x:0000ABC8
.xdata$x:0000ABE0 ; ===========================================================================
.xdata$x:0000ABE0
.xdata$x:0000ABE0 ; Segment type: Pure data
.xdata$x:0000ABE0 ; Segment permissions: Read
.xdata$x:0000ABE0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000ABE0                 assume cs:_xdata$x
.xdata$x:0000ABE0                 ;org 0ABE0h
.xdata$x:0000ABE0 ; COMDAT (pick associative to section at 3388)
.xdata$x:0000ABE0 __unwindtable$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@st db 0FFh
.xdata$x:0000ABE0                                         ; DATA XREF: .xdata$x:0000ABF0o
.xdata$x:0000ABE1                 db 0FFh
.xdata$x:0000ABE2                 db 0FFh
.xdata$x:0000ABE3                 db 0FFh
.xdata$x:0000ABE4                 dd offset __unwindfunclet$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@PBU_Container_base12@1@@Z$0
.xdata$x:0000ABE8 __ehfuncinfo$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std db  22h ; "
.xdata$x:0000ABE8                                         ; DATA XREF: __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@PBU_Container_base12@1@@Z+11o
.xdata$x:0000ABE9                 db    5
.xdata$x:0000ABEA                 db  93h ; ô
.xdata$x:0000ABEB                 db  19h
.xdata$x:0000ABEC                 db    1
.xdata$x:0000ABED                 db    0
.xdata$x:0000ABEE                 db    0
.xdata$x:0000ABEF                 db    0
.xdata$x:0000ABF0                 dd offset __unwindtable$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@PBU_Container_base12@1@@Z
.xdata$x:0000ABF4                 db    0
.xdata$x:0000ABF5                 db    0
.xdata$x:0000ABF6                 db    0
.xdata$x:0000ABF7                 db    0
.xdata$x:0000ABF8                 db    0
.xdata$x:0000ABF9                 db    0
.xdata$x:0000ABFA                 db    0
.xdata$x:0000ABFB                 db    0
.xdata$x:0000ABFC                 db    0
.xdata$x:0000ABFD                 db    0
.xdata$x:0000ABFE                 db    0
.xdata$x:0000ABFF                 db    0
.xdata$x:0000AC00                 db    0
.xdata$x:0000AC01                 db    0
.xdata$x:0000AC02                 db    0
.xdata$x:0000AC03                 db    0
.xdata$x:0000AC04                 db    0
.xdata$x:0000AC05                 db    0
.xdata$x:0000AC06                 db    0
.xdata$x:0000AC07                 db    0
.xdata$x:0000AC08                 db    0
.xdata$x:0000AC09                 db    0
.xdata$x:0000AC0A                 db    0
.xdata$x:0000AC0B                 db    0
.xdata$x:0000AC0B _xdata$x        ends
.xdata$x:0000AC0B
.xdata$x:0000AC0C ; ===========================================================================
.xdata$x:0000AC0C
.xdata$x:0000AC0C ; Segment type: Pure data
.xdata$x:0000AC0C ; Segment permissions: Read
.xdata$x:0000AC0C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000AC0C                 assume cs:_xdata$x
.xdata$x:0000AC0C                 ;org 0AC0Ch
.xdata$x:0000AC0C ; COMDAT (pick associative to section at 59D8)
.xdata$x:0000AC0C __unwindtable$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QBE?AV01@H@Z db 0FFh
.xdata$x:0000AC0C                                         ; DATA XREF: .xdata$x:0000AC24o
.xdata$x:0000AC0D                 db 0FFh
.xdata$x:0000AC0E                 db 0FFh
.xdata$x:0000AC0F                 db 0FFh
.xdata$x:0000AC10                 dd offset __unwindfunclet$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QBE?AV01@H@Z$1
.xdata$x:0000AC14                 align 8
.xdata$x:0000AC18                 dd offset __unwindfunclet$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QBE?AV01@H@Z$0
.xdata$x:0000AC1C __ehfuncinfo$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QBE?AV01@H@Z db  22h ; "
.xdata$x:0000AC1C                                         ; DATA XREF: __ehhandler$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QBE?AV01@H@Z+11o
.xdata$x:0000AC1D                 db    5
.xdata$x:0000AC1E                 db  93h ; ô
.xdata$x:0000AC1F                 db  19h
.xdata$x:0000AC20                 db    2
.xdata$x:0000AC21                 db    0
.xdata$x:0000AC22                 db    0
.xdata$x:0000AC23                 db    0
.xdata$x:0000AC24                 dd offset __unwindtable$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QBE?AV01@H@Z
.xdata$x:0000AC28                 align 20h
.xdata$x:0000AC28 _xdata$x        ends
.xdata$x:0000AC28
.xdata$x:0000AC40 ; ===========================================================================
.xdata$x:0000AC40
.xdata$x:0000AC40 ; Segment type: Pure data
.xdata$x:0000AC40 ; Segment permissions: Read
.xdata$x:0000AC40 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000AC40                 assume cs:_xdata$x
.xdata$x:0000AC40                 ;org 0AC40h
.xdata$x:0000AC40 ; COMDAT (pick associative to section at 480C)
.xdata$x:0000AC40 __unwindtable$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000AC40                                         ; DATA XREF: .xdata$x:0000AC50o
.xdata$x:0000AC41                 db 0FFh
.xdata$x:0000AC42                 db 0FFh
.xdata$x:0000AC43                 db 0FFh
.xdata$x:0000AC44                 dd offset __unwindfunclet$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ$0
.xdata$x:0000AC48 __ehfuncinfo$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000AC48                                         ; DATA XREF: __ehhandler$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:0000AC49                 db    5
.xdata$x:0000AC4A                 db  93h ; ô
.xdata$x:0000AC4B                 db  19h
.xdata$x:0000AC4C                 db    1
.xdata$x:0000AC4D                 db    0
.xdata$x:0000AC4E                 db    0
.xdata$x:0000AC4F                 db    0
.xdata$x:0000AC50                 dd offset __unwindtable$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ
.xdata$x:0000AC54                 db    0
.xdata$x:0000AC55                 db    0
.xdata$x:0000AC56                 db    0
.xdata$x:0000AC57                 db    0
.xdata$x:0000AC58                 db    0
.xdata$x:0000AC59                 db    0
.xdata$x:0000AC5A                 db    0
.xdata$x:0000AC5B                 db    0
.xdata$x:0000AC5C                 db    0
.xdata$x:0000AC5D                 db    0
.xdata$x:0000AC5E                 db    0
.xdata$x:0000AC5F                 db    0
.xdata$x:0000AC60                 db    0
.xdata$x:0000AC61                 db    0
.xdata$x:0000AC62                 db    0
.xdata$x:0000AC63                 db    0
.xdata$x:0000AC64                 db    0
.xdata$x:0000AC65                 db    0
.xdata$x:0000AC66                 db    0
.xdata$x:0000AC67                 db    0
.xdata$x:0000AC68                 db    0
.xdata$x:0000AC69                 db    0
.xdata$x:0000AC6A                 db    0
.xdata$x:0000AC6B                 db    0
.xdata$x:0000AC6B _xdata$x        ends
.xdata$x:0000AC6B
.xdata$x:0000AC6C ; ===========================================================================
.xdata$x:0000AC6C
.xdata$x:0000AC6C ; Segment type: Pure data
.xdata$x:0000AC6C ; Segment permissions: Read
.xdata$x:0000AC6C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000AC6C                 assume cs:_xdata$x
.xdata$x:0000AC6C                 ;org 0AC6Ch
.xdata$x:0000AC6C ; COMDAT (pick associative to section at 3310)
.xdata$x:0000AC6C __unwindtable$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@ABV01@@Z db 0FFh
.xdata$x:0000AC6C                                         ; DATA XREF: .xdata$x:0000AC7Co
.xdata$x:0000AC6D                 db 0FFh
.xdata$x:0000AC6E                 db 0FFh
.xdata$x:0000AC6F                 db 0FFh
.xdata$x:0000AC70                 dd offset __unwindfunclet$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@ABV01@@Z$0
.xdata$x:0000AC74 __ehfuncinfo$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@ABV01@@Z db  22h ; "
.xdata$x:0000AC74                                         ; DATA XREF: __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@ABV01@@Z+11o
.xdata$x:0000AC75                 db    5
.xdata$x:0000AC76                 db  93h ; ô
.xdata$x:0000AC77                 db  19h
.xdata$x:0000AC78                 db    1
.xdata$x:0000AC79                 db    0
.xdata$x:0000AC7A                 db    0
.xdata$x:0000AC7B                 db    0
.xdata$x:0000AC7C                 dd offset __unwindtable$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@ABV01@@Z
.xdata$x:0000AC80                 db    0
.xdata$x:0000AC81                 db    0
.xdata$x:0000AC82                 db    0
.xdata$x:0000AC83                 db    0
.xdata$x:0000AC84                 db    0
.xdata$x:0000AC85                 db    0
.xdata$x:0000AC86                 db    0
.xdata$x:0000AC87                 db    0
.xdata$x:0000AC88                 db    0
.xdata$x:0000AC89                 db    0
.xdata$x:0000AC8A                 db    0
.xdata$x:0000AC8B                 db    0
.xdata$x:0000AC8C                 db    0
.xdata$x:0000AC8D                 db    0
.xdata$x:0000AC8E                 db    0
.xdata$x:0000AC8F                 db    0
.xdata$x:0000AC90                 db    0
.xdata$x:0000AC91                 db    0
.xdata$x:0000AC92                 db    0
.xdata$x:0000AC93                 db    0
.xdata$x:0000AC94                 db    0
.xdata$x:0000AC95                 db    0
.xdata$x:0000AC96                 db    0
.xdata$x:0000AC97                 db    0
.xdata$x:0000AC97 _xdata$x        ends
.xdata$x:0000AC97
.xdata$x:0000AC98 ; ===========================================================================
.xdata$x:0000AC98
.xdata$x:0000AC98 ; Segment type: Pure data
.xdata$x:0000AC98 ; Segment permissions: Read
.xdata$x:0000AC98 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000AC98                 assume cs:_xdata$x
.xdata$x:0000AC98                 ;org 0AC98h
.xdata$x:0000AC98 ; COMDAT (pick associative to section at 1758)
.xdata$x:0000AC98 __catchsym$??$_Uninit_fill_n@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@IV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@V12@@std@@ db    0
.xdata$x:0000AC98                                         ; DATA XREF: .xdata$x:0000ACC8o
.xdata$x:0000AC99                 db    0
.xdata$x:0000AC9A                 db    0
.xdata$x:0000AC9B                 db    0
.xdata$x:0000AC9C                 db    0
.xdata$x:0000AC9D                 db    0
.xdata$x:0000AC9E                 db    0
.xdata$x:0000AC9F                 db    0
.xdata$x:0000ACA0                 db    0
.xdata$x:0000ACA1                 db    0
.xdata$x:0000ACA2                 db    0
.xdata$x:0000ACA3                 db    0
.xdata$x:0000ACA4                 dd offset __catch$??$_Uninit_fill_n@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@IV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@V12@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@IPBV10@AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std
.xdata$x:0000ACA8 __unwindtable$??$_Uninit_fill_n@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@IV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@V12@@st db 0FFh
.xdata$x:0000ACA8                                         ; DATA XREF: .xdata$x:0000ACD4o
.xdata$x:0000ACA9                 db 0FFh
.xdata$x:0000ACAA                 db 0FFh
.xdata$x:0000ACAB                 db 0FFh
.xdata$x:0000ACAC                 db    0
.xdata$x:0000ACAD                 db    0
.xdata$x:0000ACAE                 db    0
.xdata$x:0000ACAF                 db    0
.xdata$x:0000ACB0                 db 0FFh
.xdata$x:0000ACB1                 db 0FFh
.xdata$x:0000ACB2                 db 0FFh
.xdata$x:0000ACB3                 db 0FFh
.xdata$x:0000ACB4                 db    0
.xdata$x:0000ACB5                 db    0
.xdata$x:0000ACB6                 db    0
.xdata$x:0000ACB7                 db    0
.xdata$x:0000ACB8 __tryblocktable$??$_Uninit_fill_n@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@IV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@V12@@ db    0
.xdata$x:0000ACB8                                         ; DATA XREF: .xdata$x:0000ACDCo
.xdata$x:0000ACB9                 db    0
.xdata$x:0000ACBA                 db    0
.xdata$x:0000ACBB                 db    0
.xdata$x:0000ACBC                 db    0
.xdata$x:0000ACBD                 db    0
.xdata$x:0000ACBE                 db    0
.xdata$x:0000ACBF                 db    0
.xdata$x:0000ACC0                 db    1
.xdata$x:0000ACC1                 db    0
.xdata$x:0000ACC2                 db    0
.xdata$x:0000ACC3                 db    0
.xdata$x:0000ACC4                 db    1
.xdata$x:0000ACC5                 db    0
.xdata$x:0000ACC6                 db    0
.xdata$x:0000ACC7                 db    0
.xdata$x:0000ACC8                 dd offset __catchsym$??$_Uninit_fill_n@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@IV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@V12@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@IPBV10@AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@
.xdata$x:0000ACCC __ehfuncinfo$??$_Uninit_fill_n@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@IV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@V12@@std db  22h ; "
.xdata$x:0000ACCC                                         ; DATA XREF: __ehhandler$??$_Uninit_fill_n@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@IV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@V12@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@IPBV10@AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@
.xdata$x:0000ACCD                 db    5
.xdata$x:0000ACCE                 db  93h ; ô
.xdata$x:0000ACCF                 db  19h
.xdata$x:0000ACD0                 db    2
.xdata$x:0000ACD1                 db    0
.xdata$x:0000ACD2                 db    0
.xdata$x:0000ACD3                 db    0
.xdata$x:0000ACD4                 dd offset __unwindtable$??$_Uninit_fill_n@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@IV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@V12@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@IPBV10@AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std
.xdata$x:0000ACD8                 db    1
.xdata$x:0000ACD9                 db    0
.xdata$x:0000ACDA                 db    0
.xdata$x:0000ACDB                 db    0
.xdata$x:0000ACDC                 dd offset __tryblocktable$??$_Uninit_fill_n@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@IV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@V12@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@IPBV10@AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@s
.xdata$x:0000ACE0                 db    0
.xdata$x:0000ACE1                 db    0
.xdata$x:0000ACE2                 db    0
.xdata$x:0000ACE3                 db    0
.xdata$x:0000ACE4                 db    0
.xdata$x:0000ACE5                 db    0
.xdata$x:0000ACE6                 db    0
.xdata$x:0000ACE7                 db    0
.xdata$x:0000ACE8                 db    0
.xdata$x:0000ACE9                 db    0
.xdata$x:0000ACEA                 db    0
.xdata$x:0000ACEB                 db    0
.xdata$x:0000ACEC                 db    0
.xdata$x:0000ACED                 db    0
.xdata$x:0000ACEE                 db    0
.xdata$x:0000ACEF                 db    0
.xdata$x:0000ACEF _xdata$x        ends
.xdata$x:0000ACEF
.xdata$x:0000ACF0 ; ===========================================================================
.xdata$x:0000ACF0
.xdata$x:0000ACF0 ; Segment type: Pure data
.xdata$x:0000ACF0 ; Segment permissions: Read
.xdata$x:0000ACF0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000ACF0                 assume cs:_xdata$x
.xdata$x:0000ACF0                 ;org 0ACF0h
.xdata$x:0000ACF0 ; COMDAT (pick associative to section at 1D84)
.xdata$x:0000ACF0 __unwindtable$??$construct@PAVScintillaEditView@@AAPAV1@@?$allocator@PAVScintillaEditView@@@std@@QAEXPAPAVScintillaEditView@@AAPAV2@@Z db 0FFh
.xdata$x:0000ACF0                                         ; DATA XREF: .xdata$x:0000AD00o
.xdata$x:0000ACF1                 db 0FFh
.xdata$x:0000ACF2                 db 0FFh
.xdata$x:0000ACF3                 db 0FFh
.xdata$x:0000ACF4                 dd offset __unwindfunclet$??$construct@PAVScintillaEditView@@AAPAV1@@?$allocator@PAVScintillaEditView@@@std@@QAEXPAPAVScintillaEditView@@AAPAV2@@Z$0
.xdata$x:0000ACF8 __ehfuncinfo$??$construct@PAVScintillaEditView@@AAPAV1@@?$allocator@PAVScintillaEditView@@@std@@QAEXPAPAVScintillaEditView@@AAPAV2@@Z db  22h ; "
.xdata$x:0000ACF8                                         ; DATA XREF: __ehhandler$??$construct@PAVScintillaEditView@@AAPAV1@@?$allocator@PAVScintillaEditView@@@std@@QAEXPAPAVScintillaEditView@@AAPAV2@@Z+11o
.xdata$x:0000ACF9                 db    5
.xdata$x:0000ACFA                 db  93h ; ô
.xdata$x:0000ACFB                 db  19h
.xdata$x:0000ACFC                 db    1
.xdata$x:0000ACFD                 db    0
.xdata$x:0000ACFE                 db    0
.xdata$x:0000ACFF                 db    0
.xdata$x:0000AD00                 dd offset __unwindtable$??$construct@PAVScintillaEditView@@AAPAV1@@?$allocator@PAVScintillaEditView@@@std@@QAEXPAPAVScintillaEditView@@AAPAV2@@Z
.xdata$x:0000AD04                 db    0
.xdata$x:0000AD05                 db    0
.xdata$x:0000AD06                 db    0
.xdata$x:0000AD07                 db    0
.xdata$x:0000AD08                 db    0
.xdata$x:0000AD09                 db    0
.xdata$x:0000AD0A                 db    0
.xdata$x:0000AD0B                 db    0
.xdata$x:0000AD0C                 db    0
.xdata$x:0000AD0D                 db    0
.xdata$x:0000AD0E                 db    0
.xdata$x:0000AD0F                 db    0
.xdata$x:0000AD10                 db    0
.xdata$x:0000AD11                 db    0
.xdata$x:0000AD12                 db    0
.xdata$x:0000AD13                 db    0
.xdata$x:0000AD14                 db    0
.xdata$x:0000AD15                 db    0
.xdata$x:0000AD16                 db    0
.xdata$x:0000AD17                 db    0
.xdata$x:0000AD18                 db    0
.xdata$x:0000AD19                 db    0
.xdata$x:0000AD1A                 db    0
.xdata$x:0000AD1B                 db    0
.xdata$x:0000AD1B _xdata$x        ends
.xdata$x:0000AD1B
.xdata$x:0000AD1C ; ===========================================================================
.xdata$x:0000AD1C
.xdata$x:0000AD1C ; Segment type: Pure data
.xdata$x:0000AD1C ; Segment permissions: Read
.xdata$x:0000AD1C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000AD1C                 assume cs:_xdata$x
.xdata$x:0000AD1C                 ;org 0AD1Ch
.xdata$x:0000AD1C ; COMDAT (pick associative to section at 1B84)
.xdata$x:0000AD1C __unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z db 0FFh
.xdata$x:0000AD1C                                         ; DATA XREF: .xdata$x:0000AD2Co
.xdata$x:0000AD1D                 db 0FFh
.xdata$x:0000AD1E                 db 0FFh
.xdata$x:0000AD1F                 db 0FFh
.xdata$x:0000AD20                 dd offset __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0
.xdata$x:0000AD24 __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z db  22h ; "
.xdata$x:0000AD24                                         ; DATA XREF: __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z+11o
.xdata$x:0000AD25                 db    5
.xdata$x:0000AD26                 db  93h ; ô
.xdata$x:0000AD27                 db  19h
.xdata$x:0000AD28                 db    1
.xdata$x:0000AD29                 db    0
.xdata$x:0000AD2A                 db    0
.xdata$x:0000AD2B                 db    0
.xdata$x:0000AD2C                 dd offset __unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.xdata$x:0000AD30                 db    0
.xdata$x:0000AD31                 db    0
.xdata$x:0000AD32                 db    0
.xdata$x:0000AD33                 db    0
.xdata$x:0000AD34                 db    0
.xdata$x:0000AD35                 db    0
.xdata$x:0000AD36                 db    0
.xdata$x:0000AD37                 db    0
.xdata$x:0000AD38                 db    0
.xdata$x:0000AD39                 db    0
.xdata$x:0000AD3A                 db    0
.xdata$x:0000AD3B                 db    0
.xdata$x:0000AD3C                 db    0
.xdata$x:0000AD3D                 db    0
.xdata$x:0000AD3E                 db    0
.xdata$x:0000AD3F                 db    0
.xdata$x:0000AD40                 db    0
.xdata$x:0000AD41                 db    0
.xdata$x:0000AD42                 db    0
.xdata$x:0000AD43                 db    0
.xdata$x:0000AD44                 db    0
.xdata$x:0000AD45                 db    0
.xdata$x:0000AD46                 db    0
.xdata$x:0000AD47                 db    0
.xdata$x:0000AD47 _xdata$x        ends
.xdata$x:0000AD47
.xdata$x:0000AD48 ; ===========================================================================
.xdata$x:0000AD48
.xdata$x:0000AD48 ; Segment type: Pure data
.xdata$x:0000AD48 ; Segment permissions: Read
.xdata$x:0000AD48 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000AD48                 assume cs:_xdata$x
.xdata$x:0000AD48                 ;org 0AD48h
.xdata$x:0000AD48 ; COMDAT (pick associative to section at 1C84)
.xdata$x:0000AD48 __unwindtable$??$construct@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@AAPAU12@@?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@QAEXPAPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@ db 0FFh
.xdata$x:0000AD48                                         ; DATA XREF: .xdata$x:0000AD58o
.xdata$x:0000AD49                 db 0FFh
.xdata$x:0000AD4A                 db 0FFh
.xdata$x:0000AD4B                 db 0FFh
.xdata$x:0000AD4C                 dd offset __unwindfunclet$??$construct@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@AAPAU12@@?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@QAEXPAPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@1@AAPAU21@@Z$0
.xdata$x:0000AD50 __ehfuncinfo$??$construct@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@AAPAU12@@?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@QAEXPAPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@ db  22h ; "
.xdata$x:0000AD50                                         ; DATA XREF: __ehhandler$??$construct@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@AAPAU12@@?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@QAEXPAPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@1@AAPAU21@@Z+11o
.xdata$x:0000AD51                 db    5
.xdata$x:0000AD52                 db  93h ; ô
.xdata$x:0000AD53                 db  19h
.xdata$x:0000AD54                 db    1
.xdata$x:0000AD55                 db    0
.xdata$x:0000AD56                 db    0
.xdata$x:0000AD57                 db    0
.xdata$x:0000AD58                 dd offset __unwindtable$??$construct@PAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@AAPAU12@@?$allocator@U?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@std@@@std@@QAEXPAPAU?$_List_node@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@PAX@1@AAPAU21@@Z
.xdata$x:0000AD5C                 db    0
.xdata$x:0000AD5D                 db    0
.xdata$x:0000AD5E                 db    0
.xdata$x:0000AD5F                 db    0
.xdata$x:0000AD60                 db    0
.xdata$x:0000AD61                 db    0
.xdata$x:0000AD62                 db    0
.xdata$x:0000AD63                 db    0
.xdata$x:0000AD64                 db    0
.xdata$x:0000AD65                 db    0
.xdata$x:0000AD66                 db    0
.xdata$x:0000AD67                 db    0
.xdata$x:0000AD68                 db    0
.xdata$x:0000AD69                 db    0
.xdata$x:0000AD6A                 db    0
.xdata$x:0000AD6B                 db    0
.xdata$x:0000AD6C                 db    0
.xdata$x:0000AD6D                 db    0
.xdata$x:0000AD6E                 db    0
.xdata$x:0000AD6F                 db    0
.xdata$x:0000AD70                 db    0
.xdata$x:0000AD71                 db    0
.xdata$x:0000AD72                 db    0
.xdata$x:0000AD73                 db    0
.xdata$x:0000AD73 _xdata$x        ends
.xdata$x:0000AD73
.xdata$x:0000AD74 ; ===========================================================================
.xdata$x:0000AD74
.xdata$x:0000AD74 ; Segment type: Pure data
.xdata$x:0000AD74 ; Segment permissions: Read
.xdata$x:0000AD74 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000AD74                 assume cs:_xdata$x
.xdata$x:0000AD74                 ;org 0AD74h
.xdata$x:0000AD74 ; COMDAT (pick associative to section at 18BC)
.xdata$x:0000AD74 __catchsym$??$_Uninit_move@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@V12@@std@@Y db    0
.xdata$x:0000AD74                                         ; DATA XREF: .xdata$x:0000ADA4o
.xdata$x:0000AD75                 db    0
.xdata$x:0000AD76                 db    0
.xdata$x:0000AD77                 db    0
.xdata$x:0000AD78                 db    0
.xdata$x:0000AD79                 db    0
.xdata$x:0000AD7A                 db    0
.xdata$x:0000AD7B                 db    0
.xdata$x:0000AD7C                 db    0
.xdata$x:0000AD7D                 db    0
.xdata$x:0000AD7E                 db    0
.xdata$x:0000AD7F                 db    0
.xdata$x:0000AD80                 dd offset __catch$??$_Uninit_move@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@V12@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@PAV10@00AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@
.xdata$x:0000AD84 __unwindtable$??$_Uninit_move@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@V12@@std db 0FFh
.xdata$x:0000AD84                                         ; DATA XREF: .xdata$x:0000ADB0o
.xdata$x:0000AD85                 db 0FFh
.xdata$x:0000AD86                 db 0FFh
.xdata$x:0000AD87                 db 0FFh
.xdata$x:0000AD88                 db    0
.xdata$x:0000AD89                 db    0
.xdata$x:0000AD8A                 db    0
.xdata$x:0000AD8B                 db    0
.xdata$x:0000AD8C                 db 0FFh
.xdata$x:0000AD8D                 db 0FFh
.xdata$x:0000AD8E                 db 0FFh
.xdata$x:0000AD8F                 db 0FFh
.xdata$x:0000AD90                 db    0
.xdata$x:0000AD91                 db    0
.xdata$x:0000AD92                 db    0
.xdata$x:0000AD93                 db    0
.xdata$x:0000AD94 __tryblocktable$??$_Uninit_move@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@V12@@s db    0
.xdata$x:0000AD94                                         ; DATA XREF: .xdata$x:0000ADB8o
.xdata$x:0000AD95                 db    0
.xdata$x:0000AD96                 db    0
.xdata$x:0000AD97                 db    0
.xdata$x:0000AD98                 db    0
.xdata$x:0000AD99                 db    0
.xdata$x:0000AD9A                 db    0
.xdata$x:0000AD9B                 db    0
.xdata$x:0000AD9C                 db    1
.xdata$x:0000AD9D                 db    0
.xdata$x:0000AD9E                 db    0
.xdata$x:0000AD9F                 db    0
.xdata$x:0000ADA0                 db    1
.xdata$x:0000ADA1                 db    0
.xdata$x:0000ADA2                 db    0
.xdata$x:0000ADA3                 db    0
.xdata$x:0000ADA4                 dd offset __catchsym$??$_Uninit_move@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@V12@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@PAV10@00AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@s
.xdata$x:0000ADA8 __ehfuncinfo$??$_Uninit_move@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@V12@@std@ db  22h ; "
.xdata$x:0000ADA8                                         ; DATA XREF: __ehhandler$??$_Uninit_move@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@V12@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@PAV10@00AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@s
.xdata$x:0000ADA9                 db    5
.xdata$x:0000ADAA                 db  93h ; ô
.xdata$x:0000ADAB                 db  19h
.xdata$x:0000ADAC                 db    2
.xdata$x:0000ADAD                 db    0
.xdata$x:0000ADAE                 db    0
.xdata$x:0000ADAF                 db    0
.xdata$x:0000ADB0                 dd offset __unwindtable$??$_Uninit_move@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@V12@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@PAV10@00AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@
.xdata$x:0000ADB4                 db    1
.xdata$x:0000ADB5                 db    0
.xdata$x:0000ADB6                 db    0
.xdata$x:0000ADB7                 db    0
.xdata$x:0000ADB8                 dd offset __tryblocktable$??$_Uninit_move@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@V12@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@PAV10@00AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@st
.xdata$x:0000ADBC                 db    0
.xdata$x:0000ADBD                 db    0
.xdata$x:0000ADBE                 db    0
.xdata$x:0000ADBF                 db    0
.xdata$x:0000ADC0                 db    0
.xdata$x:0000ADC1                 db    0
.xdata$x:0000ADC2                 db    0
.xdata$x:0000ADC3                 db    0
.xdata$x:0000ADC4                 db    0
.xdata$x:0000ADC5                 db    0
.xdata$x:0000ADC6                 db    0
.xdata$x:0000ADC7                 db    0
.xdata$x:0000ADC8                 db    0
.xdata$x:0000ADC9                 db    0
.xdata$x:0000ADCA                 db    0
.xdata$x:0000ADCB                 db    0
.xdata$x:0000ADCB _xdata$x        ends
.xdata$x:0000ADCB
.xdata$x:0000ADCC ; ===========================================================================
.xdata$x:0000ADCC
.xdata$x:0000ADCC ; Segment type: Pure data
.xdata$x:0000ADCC ; Segment permissions: Read
.xdata$x:0000ADCC _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000ADCC                 assume cs:_xdata$x
.xdata$x:0000ADCC                 ;org 0ADCCh
.xdata$x:0000ADCC ; COMDAT (pick associative to section at 20EC)
.xdata$x:0000ADCC __unwindtable$??$construct@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@V12@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator db 0FFh
.xdata$x:0000ADCC                                         ; DATA XREF: .xdata$x:0000ADDCo
.xdata$x:0000ADCD                 db 0FFh
.xdata$x:0000ADCE                 db 0FFh
.xdata$x:0000ADCF                 db 0FFh
.xdata$x:0000ADD0                 dd offset __unwindfunclet$??$construct@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@V12@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@$$QAV21@@Z$0
.xdata$x:0000ADD4 __ehfuncinfo$??$construct@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@V12@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@ db  22h ; "
.xdata$x:0000ADD4                                         ; DATA XREF: __ehhandler$??$construct@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@V12@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@$$QAV21@@Z+11o
.xdata$x:0000ADD5                 db    5
.xdata$x:0000ADD6                 db  93h ; ô
.xdata$x:0000ADD7                 db  19h
.xdata$x:0000ADD8                 db    1
.xdata$x:0000ADD9                 db    0
.xdata$x:0000ADDA                 db    0
.xdata$x:0000ADDB                 db    0
.xdata$x:0000ADDC                 dd offset __unwindtable$??$construct@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@V12@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@1@$$QAV21@@Z
.xdata$x:0000ADE0                 db    0
.xdata$x:0000ADE1                 db    0
.xdata$x:0000ADE2                 db    0
.xdata$x:0000ADE3                 db    0
.xdata$x:0000ADE4                 db    0
.xdata$x:0000ADE5                 db    0
.xdata$x:0000ADE6                 db    0
.xdata$x:0000ADE7                 db    0
.xdata$x:0000ADE8                 db    0
.xdata$x:0000ADE9                 db    0
.xdata$x:0000ADEA                 db    0
.xdata$x:0000ADEB                 db    0
.xdata$x:0000ADEC                 db    0
.xdata$x:0000ADED                 db    0
.xdata$x:0000ADEE                 db    0
.xdata$x:0000ADEF                 db    0
.xdata$x:0000ADF0                 db    0
.xdata$x:0000ADF1                 db    0
.xdata$x:0000ADF2                 db    0
.xdata$x:0000ADF3                 db    0
.xdata$x:0000ADF4                 db    0
.xdata$x:0000ADF5                 db    0
.xdata$x:0000ADF6                 db    0
.xdata$x:0000ADF7                 db    0
.xdata$x:0000ADF7 _xdata$x        ends
.xdata$x:0000ADF7
.bss:0000ADF8 ; ===========================================================================
.bss:0000ADF8
.bss:0000ADF8 ; Segment type: Uninitialized
.bss:0000ADF8 ; Segment permissions: Read/Write
.bss:0000ADF8 _bss            segment byte public 'BSS' use32
.bss:0000ADF8                 assume cs:_bss
.bss:0000ADF8                 ;org 0ADF8h
.bss:0000ADF8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:0000ADF8 __Tuple_alloc   db    ? ;
.bss:0000ADF9 ; std::_Ignore ignore
.bss:0000ADF9 _ignore         db    ? ;               ; DATA XREF: std::`dynamic initializer for 'ignore''(void)+3o
.bss:0000ADFA _allocator_arg  db    ? ;
.bss:0000ADFB _piecewise_construct db    ? ;
.bss:0000ADFB _bss            ends
.bss:0000ADFB
.rdata:0000ADFC ; ===========================================================================
.rdata:0000ADFC
.rdata:0000ADFC ; Segment type: Pure data
.rdata:0000ADFC ; Segment permissions: Read
.rdata:0000ADFC ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000ADFC _rdata          segment para public 'DATA' use32
.rdata:0000ADFC                 assume cs:_rdata
.rdata:0000ADFC                 ;org 0ADFCh
.rdata:0000ADFC ; COMDAT (pick any)
.rdata:0000ADFC                 public ??_C@_1JA@EADLBAJ@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:0000ADFC ; wchar_t `string'
.rdata:0000ADFC ??_C@_1JA@EADLBAJ@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:0000ADFC                                         ; DATA XREF: std::fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>
.rdata:0000ADFC                                         ; std::_Iterator_base12::_Orphan_me(void)+48o
.rdata:0000ADFC                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:0000ADFC                 unicode 0, <clude\xutility>,0
.rdata:0000ADFC _rdata          ends
.rdata:0000ADFC
.rdata:0000AE8C ; ===========================================================================
.rdata:0000AE8C
.rdata:0000AE8C ; Segment type: Pure data
.rdata:0000AE8C ; Segment permissions: Read
.rdata:0000AE8C _rdata          segment dword public 'DATA' use32
.rdata:0000AE8C                 assume cs:_rdata
.rdata:0000AE8C                 ;org 0AE8Ch
.rdata:0000AE8C ; COMDAT (pick any)
.rdata:0000AE8C                 public ??_C@_1DC@POOIKBAO@?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5?$AAC?$AAO?$AAR?$AAR?$AAU?$AAP?$AAT?$AAE?$AAD?$AA?$CB?$AA?$AA@
.rdata:0000AE8C ; wchar_t `string'
.rdata:0000AE8C ??_C@_1DC@POOIKBAO@?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5?$AAC?$AAO?$AAR?$AAR?$AAU?$AAP?$AAT?$AAE?$AAD?$AA?$CB?$AA?$AA@:
.rdata:0000AE8C                                         ; DATA XREF: std::_Iterator_base12::_Orphan_me(void)+4Do
.rdata:0000AE8C                 unicode 0, <ITERATOR LIST CORRUPTED!>,0
.rdata:0000AEBE                 align 10h
.rdata:0000AEBE _rdata          ends
.rdata:0000AEBE
.rdata:0000AEC0 ; ===========================================================================
.rdata:0000AEC0
.rdata:0000AEC0 ; Segment type: Pure data
.rdata:0000AEC0 ; Segment permissions: Read
.rdata:0000AEC0 _rdata          segment dword public 'DATA' use32
.rdata:0000AEC0                 assume cs:_rdata
.rdata:0000AEC0                 ;org 0AEC0h
.rdata:0000AEC0 ; COMDAT (pick largest)
.rdata:0000AEC0                 dd offset ??_R4error_category@std@@6B@ ; const std::error_category::`RTTI Complete Object Locator'
.rdata:0000AEC4                 public ??_7error_category@std@@6B@
.rdata:0000AEC4 ; const std::error_category::`vftable'
.rdata:0000AEC4 ??_7error_category@std@@6B@ dd offset ??_Eerror_category@std@@UAEPAXI@Z
.rdata:0000AEC4                                         ; DATA XREF: std::error_category::error_category(void)+Ao
.rdata:0000AEC4                                         ; std::error_category::~error_category(void)+Ao
.rdata:0000AEC4                                         ; std::error_category::`vector deleting destructor'(uint)
.rdata:0000AEC8                 dd offset __purecall
.rdata:0000AECC                 dd offset __purecall
.rdata:0000AED0                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:0000AED4                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:0000AED8                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:0000AED8 _rdata          ends
.rdata:0000AED8
.rdata:0000AEDC ; ===========================================================================
.rdata:0000AEDC
.rdata:0000AEDC ; Segment type: Pure data
.rdata:0000AEDC ; Segment permissions: Read
.rdata:0000AEDC _rdata          segment dword public 'DATA' use32
.rdata:0000AEDC                 assume cs:_rdata
.rdata:0000AEDC                 ;org 0AEDCh
.rdata:0000AEDC ; COMDAT (pick largest)
.rdata:0000AEDC                 dd offset ??_R4_Generic_error_category@std@@6B@ ; const std::_Generic_error_category::`RTTI Complete Object Locator'
.rdata:0000AEE0                 public ??_7_Generic_error_category@std@@6B@
.rdata:0000AEE0 ; const std::_Generic_error_category::`vftable'
.rdata:0000AEE0 ??_7_Generic_error_category@std@@6B@ dd offset ??_E_Generic_error_category@std@@UAEPAXI@Z
.rdata:0000AEE0                                         ; DATA XREF: std::_Generic_error_category::_Generic_error_category(void)+38o
.rdata:0000AEE0                                         ; std::_Generic_error_category::`vector deleting destructor'(uint)
.rdata:0000AEE4                 dd offset ?name@_Generic_error_category@std@@UBEPBDXZ ; std::_Generic_error_category::name(void)
.rdata:0000AEE8                 dd offset ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
.rdata:0000AEEC                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:0000AEF0                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:0000AEF4                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:0000AEF4 _rdata          ends
.rdata:0000AEF4
.rdata:0000AEF8 ; ===========================================================================
.rdata:0000AEF8
.rdata:0000AEF8 ; Segment type: Pure data
.rdata:0000AEF8 ; Segment permissions: Read
.rdata:0000AEF8 _rdata          segment dword public 'DATA' use32
.rdata:0000AEF8                 assume cs:_rdata
.rdata:0000AEF8                 ;org 0AEF8h
.rdata:0000AEF8 ; COMDAT (pick any)
.rdata:0000AEF8                 public ??_C@_07DCLBNMLN@generic?$AA@
.rdata:0000AEF8 ; `string'
.rdata:0000AEF8 ??_C@_07DCLBNMLN@generic?$AA@ db 'generic',0
.rdata:0000AEF8                                         ; DATA XREF: std::_Generic_error_category::name(void)+7o
.rdata:0000AEF8 _rdata          ends
.rdata:0000AEF8
.rdata:0000AF00 ; ===========================================================================
.rdata:0000AF00
.rdata:0000AF00 ; Segment type: Pure data
.rdata:0000AF00 ; Segment permissions: Read
.rdata:0000AF00 _rdata          segment dword public 'DATA' use32
.rdata:0000AF00                 assume cs:_rdata
.rdata:0000AF00                 ;org 0AF00h
.rdata:0000AF00 ; COMDAT (pick any)
.rdata:0000AF00                 public ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
.rdata:0000AF00 ; `string'
.rdata:0000AF00 ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ db 'unknown error',0
.rdata:0000AF00                                         ; DATA XREF: std::_Generic_error_category::message(int):loc_9220o
.rdata:0000AF00                                         ; std::_System_error_category::message(int):loc_939Co
.rdata:0000AF0E                 align 10h
.rdata:0000AF0E _rdata          ends
.rdata:0000AF0E
.rdata:0000AF10 ; ===========================================================================
.rdata:0000AF10
.rdata:0000AF10 ; Segment type: Pure data
.rdata:0000AF10 ; Segment permissions: Read
.rdata:0000AF10 _rdata          segment dword public 'DATA' use32
.rdata:0000AF10                 assume cs:_rdata
.rdata:0000AF10                 ;org 0AF10h
.rdata:0000AF10 ; COMDAT (pick largest)
.rdata:0000AF10                 dd offset ??_R4_Iostream_error_category@std@@6B@ ; const std::_Iostream_error_category::`RTTI Complete Object Locator'
.rdata:0000AF14                 public ??_7_Iostream_error_category@std@@6B@
.rdata:0000AF14 ; const std::_Iostream_error_category::`vftable'
.rdata:0000AF14 ??_7_Iostream_error_category@std@@6B@ dd offset ??_E_Iostream_error_category@std@@UAEPAXI@Z
.rdata:0000AF14                                         ; DATA XREF: std::_Iostream_error_category::_Iostream_error_category(void)+38o
.rdata:0000AF14                                         ; std::_Iostream_error_category::`vector deleting destructor'(uint)
.rdata:0000AF18                 dd offset ?name@_Iostream_error_category@std@@UBEPBDXZ ; std::_Iostream_error_category::name(void)
.rdata:0000AF1C                 dd offset ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message(int)
.rdata:0000AF20                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:0000AF24                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:0000AF28                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:0000AF28 _rdata          ends
.rdata:0000AF28
.rdata:0000AF2C ; ===========================================================================
.rdata:0000AF2C
.rdata:0000AF2C ; Segment type: Pure data
.rdata:0000AF2C ; Segment permissions: Read
.rdata:0000AF2C _rdata          segment dword public 'DATA' use32
.rdata:0000AF2C                 assume cs:_rdata
.rdata:0000AF2C                 ;org 0AF2Ch
.rdata:0000AF2C ; COMDAT (pick any)
.rdata:0000AF2C                 public ??_C@_08LLGCOLLL@iostream?$AA@
.rdata:0000AF2C ; `string'
.rdata:0000AF2C ??_C@_08LLGCOLLL@iostream?$AA@ db 'iostream',0
.rdata:0000AF2C                                         ; DATA XREF: std::_Iostream_error_category::name(void)+7o
.rdata:0000AF35                 align 4
.rdata:0000AF35 _rdata          ends
.rdata:0000AF35
.rdata:0000AF38 ; ===========================================================================
.rdata:0000AF38
.rdata:0000AF38 ; Segment type: Pure data
.rdata:0000AF38 ; Segment permissions: Read
.rdata:0000AF38 _rdata          segment dword public 'DATA' use32
.rdata:0000AF38                 assume cs:_rdata
.rdata:0000AF38                 ;org 0AF38h
.rdata:0000AF38 ; COMDAT (pick any)
.rdata:0000AF38                 public ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
.rdata:0000AF38 ; char `string'[]
.rdata:0000AF38 ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ db 'iostream stream error',0
.rdata:0000AF38                                         ; DATA XREF: std::_Iostream_error_category::message(int)+35o
.rdata:0000AF4E                 align 10h
.rdata:0000AF4E _rdata          ends
.rdata:0000AF4E
.rdata:0000AF50 ; ===========================================================================
.rdata:0000AF50
.rdata:0000AF50 ; Segment type: Pure data
.rdata:0000AF50 ; Segment permissions: Read
.rdata:0000AF50 _rdata          segment dword public 'DATA' use32
.rdata:0000AF50                 assume cs:_rdata
.rdata:0000AF50                 ;org 0AF50h
.rdata:0000AF50 ; COMDAT (pick largest)
.rdata:0000AF50                 dd offset ??_R4_System_error_category@std@@6B@ ; const std::_System_error_category::`RTTI Complete Object Locator'
.rdata:0000AF54                 public ??_7_System_error_category@std@@6B@
.rdata:0000AF54 ; const std::_System_error_category::`vftable'
.rdata:0000AF54 ??_7_System_error_category@std@@6B@ dd offset ??_E_System_error_category@std@@UAEPAXI@Z
.rdata:0000AF54                                         ; DATA XREF: std::_System_error_category::_System_error_category(void)+38o
.rdata:0000AF54                                         ; std::_System_error_category::`vector deleting destructor'(uint)
.rdata:0000AF58                 dd offset ?name@_System_error_category@std@@UBEPBDXZ ; std::_System_error_category::name(void)
.rdata:0000AF5C                 dd offset ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message(int)
.rdata:0000AF60                 dd offset ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition(int)
.rdata:0000AF64                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:0000AF68                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:0000AF68 _rdata          ends
.rdata:0000AF68
.rdata:0000AF6C ; ===========================================================================
.rdata:0000AF6C
.rdata:0000AF6C ; Segment type: Pure data
.rdata:0000AF6C ; Segment permissions: Read
.rdata:0000AF6C _rdata          segment dword public 'DATA' use32
.rdata:0000AF6C                 assume cs:_rdata
.rdata:0000AF6C                 ;org 0AF6Ch
.rdata:0000AF6C ; COMDAT (pick any)
.rdata:0000AF6C                 public ??_C@_06FHFOAHML@system?$AA@
.rdata:0000AF6C ; `string'
.rdata:0000AF6C ??_C@_06FHFOAHML@system?$AA@ db 'system',0
.rdata:0000AF6C                                         ; DATA XREF: std::_System_error_category::name(void)+7o
.rdata:0000AF73                 align 4
.rdata:0000AF73 _rdata          ends
.rdata:0000AF73
.bss:0000AF74 ; ===========================================================================
.bss:0000AF74
.bss:0000AF74 ; Segment type: Uninitialized
.bss:0000AF74 ; Segment permissions: Read/Write
.bss:0000AF74 _bss            segment dword public 'BSS' use32
.bss:0000AF74                 assume cs:_bss
.bss:0000AF74                 ;org 0AF74h
.bss:0000AF74 ; COMDAT (pick any)
.bss:0000AF74                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:0000AF74                 public ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
.bss:0000AF74 ; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
.bss:0000AF74 ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A db    ? ;
.bss:0000AF74                                         ; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o
.bss:0000AF74                                         ; `dynamic atexit destructor for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o ...
.bss:0000AF75                 db    ? ;
.bss:0000AF76                 db    ? ;
.bss:0000AF77                 db    ? ;
.bss:0000AF77 _bss            ends
.bss:0000AF77
.bss:0000AF78 ; ===========================================================================
.bss:0000AF78
.bss:0000AF78 ; Segment type: Uninitialized
.bss:0000AF78 ; Segment permissions: Read/Write
.bss:0000AF78 _bss            segment dword public 'BSS' use32
.bss:0000AF78                 assume cs:_bss
.bss:0000AF78                 ;org 0AF78h
.bss:0000AF78 ; COMDAT (pick any)
.bss:0000AF78                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:0000AF78                 public ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
.bss:0000AF78 ; std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object
.bss:0000AF78 ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A db    ? ;
.bss:0000AF78                                         ; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
.bss:0000AF78                                         ; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
.bss:0000AF79                 db    ? ;
.bss:0000AF7A                 db    ? ;
.bss:0000AF7B                 db    ? ;
.bss:0000AF7B _bss            ends
.bss:0000AF7B
.bss:0000AF7C ; ===========================================================================
.bss:0000AF7C
.bss:0000AF7C ; Segment type: Uninitialized
.bss:0000AF7C ; Segment permissions: Read/Write
.bss:0000AF7C _bss            segment dword public 'BSS' use32
.bss:0000AF7C                 assume cs:_bss
.bss:0000AF7C                 ;org 0AF7Ch
.bss:0000AF7C ; COMDAT (pick any)
.bss:0000AF7C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:0000AF7C                 public ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
.bss:0000AF7C ; std::_System_error_category std::_Error_objects<int>::_System_object
.bss:0000AF7C ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A db    ? ;
.bss:0000AF7C                                         ; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o
.bss:0000AF7C                                         ; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o ...
.bss:0000AF7D                 db    ? ;
.bss:0000AF7E                 db    ? ;
.bss:0000AF7F                 db    ? ;
.bss:0000AF7F _bss            ends
.bss:0000AF7F
.bss:0000AF80 ; ===========================================================================
.bss:0000AF80
.bss:0000AF80 ; Segment type: Uninitialized
.bss:0000AF80 ; Segment permissions: Read/Write
.bss:0000AF80 _bss            segment dword public 'BSS' use32
.bss:0000AF80                 assume cs:_bss
.bss:0000AF80                 ;org 0AF80h
.bss:0000AF80 ; COMDAT (pick any)
.bss:0000AF80                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:0000AF80                 public ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
.bss:0000AF80 ; std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id
.bss:0000AF80 ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A db    ? ;
.bss:0000AF80                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)+5o
.bss:0000AF81                 db    ? ;
.bss:0000AF82                 db    ? ;
.bss:0000AF83                 db    ? ;
.bss:0000AF83 _bss            ends
.bss:0000AF83
.bss:0000AF84 ; ===========================================================================
.bss:0000AF84
.bss:0000AF84 ; Segment type: Uninitialized
.bss:0000AF84 ; Segment permissions: Read/Write
.bss:0000AF84 _bss            segment dword public 'BSS' use32
.bss:0000AF84                 assume cs:_bss
.bss:0000AF84                 ;org 0AF84h
.bss:0000AF84 ; COMDAT (pick any)
.bss:0000AF84                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:0000AF84                 public ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
.bss:0000AF84 ; std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id
.bss:0000AF84 ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A db    ? ;
.bss:0000AF84                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)+5o
.bss:0000AF85                 db    ? ;
.bss:0000AF86                 db    ? ;
.bss:0000AF87                 db    ? ;
.bss:0000AF87 _bss            ends
.bss:0000AF87
.rdata:0000AF88 ; ===========================================================================
.rdata:0000AF88
.rdata:0000AF88 ; Segment type: Pure data
.rdata:0000AF88 ; Segment permissions: Read
.rdata:0000AF88 _rdata          segment dword public 'DATA' use32
.rdata:0000AF88                 assume cs:_rdata
.rdata:0000AF88                 ;org 0AF88h
.rdata:0000AF88 ; COMDAT (pick largest)
.rdata:0000AF88                 dd offset ??_R4Window@@6B@ ; const Window::`RTTI Complete Object Locator'
.rdata:0000AF8C                 public ??_7Window@@6B@
.rdata:0000AF8C ; const Window::`vftable'
.rdata:0000AF8C ??_7Window@@6B@ dd offset ??_EWindow@@UAEPAXI@Z
.rdata:0000AF8C                                         ; DATA XREF: Window::Window(void)+Ao
.rdata:0000AF8C                                         ; Window::~Window(void)+Ao
.rdata:0000AF8C                                         ; Window::`vector deleting destructor'(uint)
.rdata:0000AF90                 dd offset ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z ; Window::init(HINSTANCE__ *,HWND__ *)
.rdata:0000AF94                 dd offset __purecall
.rdata:0000AF98                 dd offset ?display@Window@@UBEX_N@Z ; Window::display(bool)
.rdata:0000AF9C                 dd offset ?reSizeTo@Window@@UAEXAAUtagRECT@@@Z ; Window::reSizeTo(tagRECT &)
.rdata:0000AFA0                 dd offset ?reSizeToWH@Window@@UAEXAAUtagRECT@@@Z ; Window::reSizeToWH(tagRECT &)
.rdata:0000AFA4                 dd offset ?redraw@Window@@UBEX_N@Z ; Window::redraw(bool)
.rdata:0000AFA8                 dd offset ?getClientRect@Window@@UBEXAAUtagRECT@@@Z ; Window::getClientRect(tagRECT &)
.rdata:0000AFAC                 dd offset ?getWindowRect@Window@@UBEXAAUtagRECT@@@Z ; Window::getWindowRect(tagRECT &)
.rdata:0000AFB0                 dd offset ?getWidth@Window@@UBEHXZ ; Window::getWidth(void)
.rdata:0000AFB4                 dd offset ?getHeight@Window@@UBEHXZ ; Window::getHeight(void)
.rdata:0000AFB8                 dd offset ?isVisible@Window@@UBE_NXZ ; Window::isVisible(void)
.rdata:0000AFB8 _rdata          ends
.rdata:0000AFB8
.rdata:0000AFBC ; ===========================================================================
.rdata:0000AFBC
.rdata:0000AFBC ; Segment type: Pure data
.rdata:0000AFBC ; Segment permissions: Read
.rdata:0000AFBC _rdata          segment dword public 'DATA' use32
.rdata:0000AFBC                 assume cs:_rdata
.rdata:0000AFBC                 ;org 0AFBCh
.rdata:0000AFBC ; COMDAT (pick largest)
.rdata:0000AFBC                 dd offset ??_R4ScintillaEditView@@6B@ ; const ScintillaEditView::`RTTI Complete Object Locator'
.rdata:0000AFC0                 public ??_7ScintillaEditView@@6B@
.rdata:0000AFC0 ; const ScintillaEditView::`vftable'
.rdata:0000AFC0 ??_7ScintillaEditView@@6B@ dd offset ??_EScintillaEditView@@UAEPAXI@Z
.rdata:0000AFC0                                         ; DATA XREF: ScintillaEditView::ScintillaEditView(void)+38o
.rdata:0000AFC0                                         ; ScintillaEditView::~ScintillaEditView(void)+2Bo
.rdata:0000AFC0                                         ; ScintillaEditView::`vector deleting destructor'(uint)
.rdata:0000AFC4                 dd offset ?init@ScintillaEditView@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z ; ScintillaEditView::init(HINSTANCE__ *,HWND__ *)
.rdata:0000AFC8                 dd offset ?destroy@ScintillaEditView@@UAEXXZ ; ScintillaEditView::destroy(void)
.rdata:0000AFCC                 dd offset ?display@Window@@UBEX_N@Z ; Window::display(bool)
.rdata:0000AFD0                 dd offset ?reSizeTo@Window@@UAEXAAUtagRECT@@@Z ; Window::reSizeTo(tagRECT &)
.rdata:0000AFD4                 dd offset ?reSizeToWH@Window@@UAEXAAUtagRECT@@@Z ; Window::reSizeToWH(tagRECT &)
.rdata:0000AFD8                 dd offset ?redraw@Window@@UBEX_N@Z ; Window::redraw(bool)
.rdata:0000AFDC                 dd offset ?getClientRect@Window@@UBEXAAUtagRECT@@@Z ; Window::getClientRect(tagRECT &)
.rdata:0000AFE0                 dd offset ?getWindowRect@Window@@UBEXAAUtagRECT@@@Z ; Window::getWindowRect(tagRECT &)
.rdata:0000AFE4                 dd offset ?getWidth@Window@@UBEHXZ ; Window::getWidth(void)
.rdata:0000AFE8                 dd offset ?getHeight@Window@@UBEHXZ ; Window::getHeight(void)
.rdata:0000AFEC                 dd offset ?isVisible@Window@@UBE_NXZ ; Window::isVisible(void)
.rdata:0000AFEC _rdata          ends
.rdata:0000AFEC
.rdata:0000AFF0 ; ===========================================================================
.rdata:0000AFF0
.rdata:0000AFF0 ; Segment type: Pure data
.rdata:0000AFF0 ; Segment permissions: Read
.rdata:0000AFF0 ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000AFF0 _rdata          segment para public 'DATA' use32
.rdata:0000AFF0                 assume cs:_rdata
.rdata:0000AFF0                 ;org 0AFF0h
.rdata:0000AFF0 ; COMDAT (pick any)
.rdata:0000AFF0                 public ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:0000AFF0 ; wchar_t `string'
.rdata:0000AFF0 ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:0000AFF0                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+Co
.rdata:0000AFF0                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+12o
.rdata:0000AFF0                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:0000AFF0                 unicode 0, <clude\xstring>,0
.rdata:0000B07E                 align 10h
.rdata:0000B07E _rdata          ends
.rdata:0000B07E
.rdata:0000B080 ; ===========================================================================
.rdata:0000B080
.rdata:0000B080 ; Segment type: Pure data
.rdata:0000B080 ; Segment permissions: Read
.rdata:0000B080 ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000B080 _rdata          segment para public 'DATA' use32
.rdata:0000B080                 assume cs:_rdata
.rdata:0000B080                 ;org 0B080h
.rdata:0000B080 ; COMDAT (pick any)
.rdata:0000B080                 public ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:0000B080 ; wchar_t `string'
.rdata:0000B080 ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:0000B080                                         ; DATA XREF: std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::operator[](uint)+19o
.rdata:0000B080                                         ; std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::operator[](uint)+49o ...
.rdata:0000B080                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:0000B080                 unicode 0, <clude\vector>,0
.rdata:0000B080 _rdata          ends
.rdata:0000B080
.rdata:0000B10C ; ===========================================================================
.rdata:0000B10C
.rdata:0000B10C ; Segment type: Pure data
.rdata:0000B10C ; Segment permissions: Read
.rdata:0000B10C _rdata          segment dword public 'DATA' use32
.rdata:0000B10C                 assume cs:_rdata
.rdata:0000B10C                 ;org 0B10Ch
.rdata:0000B10C ; COMDAT (pick any)
.rdata:0000B10C                 public ??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@
.rdata:0000B10C ; wchar_t `string'
.rdata:0000B10C ??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@:
.rdata:0000B10C                                         ; DATA XREF: std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::operator[](uint)+1Eo
.rdata:0000B10C                 unicode 0, <vector subscript out of range>,0
.rdata:0000B10C _rdata          ends
.rdata:0000B10C
.rdata:0000B148 ; ===========================================================================
.rdata:0000B148
.rdata:0000B148 ; Segment type: Pure data
.rdata:0000B148 ; Segment permissions: Read
.rdata:0000B148 _rdata          segment dword public 'DATA' use32
.rdata:0000B148                 assume cs:_rdata
.rdata:0000B148                 ;org 0B148h
.rdata:0000B148 ; COMDAT (pick any)
.rdata:0000B148                 public ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@
.rdata:0000B148 ; `string'
.rdata:0000B148 ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ db 'Standard C++ Libraries Out of Range',0
.rdata:0000B148                                         ; DATA XREF: std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::operator[](uint)+2Bo
.rdata:0000B148                                         ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>::operator*(void)+46o ...
.rdata:0000B148 _rdata          ends
.rdata:0000B148
.rdata:0000B16C ; ===========================================================================
.rdata:0000B16C
.rdata:0000B16C ; Segment type: Pure data
.rdata:0000B16C ; Segment permissions: Read
.rdata:0000B16C ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000B16C _rdata          segment para public 'DATA' use32
.rdata:0000B16C                 assume cs:_rdata
.rdata:0000B16C                 ;org 0B16Ch
.rdata:0000B16C ; COMDAT (pick any)
.rdata:0000B16C                 public ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@
.rdata:0000B16C ; `string'
.rdata:0000B16C ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@:
.rdata:0000B16C                                         ; DATA XREF: std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::operator[](uint):loc_556Co
.rdata:0000B16C                                         ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>::operator*(void):loc_564Fo ...
.rdata:0000B16C                 unicode 0, <"Standard C++ Libraries Out of Range" && 0>,0
.rdata:0000B1C2                 align 4
.rdata:0000B1C2 _rdata          ends
.rdata:0000B1C2
.rdata:0000B1C4 ; ===========================================================================
.rdata:0000B1C4
.rdata:0000B1C4 ; Segment type: Pure data
.rdata:0000B1C4 ; Segment permissions: Read
.rdata:0000B1C4 _rdata          segment dword public 'DATA' use32
.rdata:0000B1C4                 assume cs:_rdata
.rdata:0000B1C4                 ;org 0B1C4h
.rdata:0000B1C4 ; COMDAT (pick any)
.rdata:0000B1C4                 public ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
.rdata:0000B1C4 ; `string'
.rdata:0000B1C4 ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@:
.rdata:0000B1C4                                         ; DATA XREF: std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>::operator==(std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>> const &)+55o
.rdata:0000B1C4                                         ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::operator==(std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const &)+55o ...
.rdata:0000B1C4                 unicode 0, <%s>,0
.rdata:0000B1CA                 align 4
.rdata:0000B1CA _rdata          ends
.rdata:0000B1CA
.rdata:0000B1CC ; ===========================================================================
.rdata:0000B1CC
.rdata:0000B1CC ; Segment type: Pure data
.rdata:0000B1CC ; Segment permissions: Read
.rdata:0000B1CC ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000B1CC _rdata          segment para public 'DATA' use32
.rdata:0000B1CC                 assume cs:_rdata
.rdata:0000B1CC                 ;org 0B1CCh
.rdata:0000B1CC ; COMDAT (pick any)
.rdata:0000B1CC                 public ??_C@_1MK@HJPEJHDM@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAS?$AAc?$AAi?$AAn?$AAt?$AAi?$AAl?$AAl?$AAa?$AAE?$AAd?$AAi?$AAt?$AAV@
.rdata:0000B1CC ; `string'
.rdata:0000B1CC ??_C@_1MK@HJPEJHDM@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAS?$AAc?$AAi?$AAn?$AAt?$AAi?$AAl?$AAl?$AAa?$AAE?$AAd?$AAi?$AAt?$AAV@:
.rdata:0000B1CC                                         ; DATA XREF: std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::operator[](uint)+6Ao
.rdata:0000B1CC                 unicode 0, <std::vector>
.rdata:0000B1CC                 dw 3Ch
.rdata:0000B1CC                 unicode 0, <class ScintillaEditView *,class std::allocator>
.rdata:0000B1CC                 dw 3Ch
.rdata:0000B1CC                 unicode 0, <class ScintillaEditView *>
.rdata:0000B1CC                 dw 3Eh
.rdata:0000B1CC                 unicode 0, < >
.rdata:0000B1CC                 dw 3Eh
.rdata:0000B1CC                 unicode 0, <::operator []>,0
.rdata:0000B296                 align 4
.rdata:0000B296 _rdata          ends
.rdata:0000B296
.rdata:0000B298 ; ===========================================================================
.rdata:0000B298
.rdata:0000B298 ; Segment type: Pure data
.rdata:0000B298 ; Segment permissions: Read
.rdata:0000B298 _rdata          segment dword public 'DATA' use32
.rdata:0000B298                 assume cs:_rdata
.rdata:0000B298                 ;org 0B298h
.rdata:0000B298 ; COMDAT (pick any)
.rdata:0000B298                 public ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@
.rdata:0000B298 ; `string'
.rdata:0000B298 ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@:
.rdata:0000B298                                         ; DATA XREF: std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::operator[](uint)+6Fo
.rdata:0000B298                                         ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>::operator*(void)+8Ao ...
.rdata:0000B298                 unicode 0, <"out of range">,0
.rdata:0000B2B6                 align 4
.rdata:0000B2B6 _rdata          ends
.rdata:0000B2B6
.rdata:0000B2B8 ; ===========================================================================
.rdata:0000B2B8
.rdata:0000B2B8 ; Segment type: Pure data
.rdata:0000B2B8 ; Segment permissions: Read
.rdata:0000B2B8 ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000B2B8 _rdata          segment para public 'DATA' use32
.rdata:0000B2B8                 assume cs:_rdata
.rdata:0000B2B8                 ;org 0B2B8h
.rdata:0000B2B8 ; COMDAT (pick any)
.rdata:0000B2B8                 public ??_C@_1EI@HGIDLLCM@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAe?$AAr?$AAa?$AAs?$AAe?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAo?$AAu?$AAt?$AAs?$AAi?$AAd?$AAe?$AA?5?$AAr?$AAa@
.rdata:0000B2B8 ; wchar_t `string'
.rdata:0000B2B8 ??_C@_1EI@HGIDLLCM@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAe?$AAr?$AAa?$AAs?$AAe?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAo?$AAu?$AAt?$AAs?$AAi?$AAd?$AAe?$AA?5?$AAr?$AAa@:
.rdata:0000B2B8                                         ; DATA XREF: std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::erase(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>)+63o
.rdata:0000B2B8                 unicode 0, <vector erase iterator outside range>,0
.rdata:0000B2B8 _rdata          ends
.rdata:0000B2B8
.bss:0000B300 ; ===========================================================================
.bss:0000B300
.bss:0000B300 ; Segment type: Uninitialized
.bss:0000B300 ; Segment permissions: Read/Write
.bss:0000B300 _bss            segment dword public 'BSS' use32
.bss:0000B300                 assume cs:_bss
.bss:0000B300                 ;org 0B300h
.bss:0000B300 ; COMDAT (pick any)
.bss:0000B300                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:0000B300                 public ?id@?$numpunct@D@std@@2V0locale@2@A
.bss:0000B300 ; std::locale::id std::numpunct<char>::id
.bss:0000B300 ?id@?$numpunct@D@std@@2V0locale@2@A db    ? ;
.bss:0000B300                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::numpunct<char>::id''(void)+5o
.bss:0000B301                 db    ? ;
.bss:0000B302                 db    ? ;
.bss:0000B303                 db    ? ;
.bss:0000B303 _bss            ends
.bss:0000B303
.bss:0000B304 ; ===========================================================================
.bss:0000B304
.bss:0000B304 ; Segment type: Uninitialized
.bss:0000B304 ; Segment permissions: Read/Write
.bss:0000B304 _bss            segment dword public 'BSS' use32
.bss:0000B304                 assume cs:_bss
.bss:0000B304                 ;org 0B304h
.bss:0000B304 ; COMDAT (pick any)
.bss:0000B304                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:0000B304                 public ?id@?$numpunct@_W@std@@2V0locale@2@A
.bss:0000B304 ; std::locale::id std::numpunct<wchar_t>::id
.bss:0000B304 ?id@?$numpunct@_W@std@@2V0locale@2@A db    ? ;
.bss:0000B304                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::numpunct<wchar_t>::id''(void)+5o
.bss:0000B305                 db    ? ;
.bss:0000B306                 db    ? ;
.bss:0000B307                 db    ? ;
.bss:0000B307 _bss            ends
.bss:0000B307
.rdata:0000B308 ; ===========================================================================
.rdata:0000B308
.rdata:0000B308 ; Segment type: Pure data
.rdata:0000B308 ; Segment permissions: Read
.rdata:0000B308 ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000B308 _rdata          segment para public 'DATA' use32
.rdata:0000B308                 assume cs:_rdata
.rdata:0000B308                 ;org 0B308h
.rdata:0000B308 ; COMDAT (pick any)
.rdata:0000B308                 public ??_C@_1II@KCNBAEMF@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:0000B308 ; wchar_t `string'
.rdata:0000B308 ??_C@_1II@KCNBAEMF@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:0000B308                                         ; DATA XREF: std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>::operator==(std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>> const &)+31o
.rdata:0000B308                                         ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>::operator==(std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>> const &)+61o ...
.rdata:0000B308                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:0000B308                 unicode 0, <clude\list>,0
.rdata:0000B308 _rdata          ends
.rdata:0000B308
.rdata:0000B390 ; ===========================================================================
.rdata:0000B390
.rdata:0000B390 ; Segment type: Pure data
.rdata:0000B390 ; Segment permissions: Read
.rdata:0000B390 ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000B390 _rdata          segment para public 'DATA' use32
.rdata:0000B390                 assume cs:_rdata
.rdata:0000B390                 ;org 0B390h
.rdata:0000B390 ; COMDAT (pick any)
.rdata:0000B390                 public ??_C@_1EA@DOGAGKDH@?$AAl?$AAi?$AAs?$AAt?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAi?$AAn?$AAc?$AAr?$AAe?$AAm?$AAe?$AAn?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?$AA@
.rdata:0000B390 ; wchar_t `string'
.rdata:0000B390 ??_C@_1EA@DOGAGKDH@?$AAl?$AAi?$AAs?$AAt?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAi?$AAn?$AAc?$AAr?$AAe?$AAm?$AAe?$AAn?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?$AA@:
.rdata:0000B390                                         ; DATA XREF: std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>::operator++(void)+39o
.rdata:0000B390                                         ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::operator++(void)+39o
.rdata:0000B390                 unicode 0, <list iterator not incrementable>,0
.rdata:0000B390 _rdata          ends
.rdata:0000B390
.rdata:0000B3D0 ; ===========================================================================
.rdata:0000B3D0
.rdata:0000B3D0 ; Segment type: Pure data
.rdata:0000B3D0 ; Segment permissions: Read
.rdata:0000B3D0 _rdata          segment dword public 'DATA' use32
.rdata:0000B3D0                 assume cs:_rdata
.rdata:0000B3D0                 ;org 0B3D0h
.rdata:0000B3D0 ; COMDAT (pick any)
.rdata:0000B3D0                 public ??_C@_1DI@MDELDGPI@?$AAl?$AAi?$AAs?$AAt?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AAs?$AA?5?$AAi?$AAn?$AAc?$AAo?$AAm?$AAp?$AAa?$AAt?$AAi?$AAb?$AAl?$AAe?$AA?$AA@
.rdata:0000B3D0 ; wchar_t `string'
.rdata:0000B3D0 ??_C@_1DI@MDELDGPI@?$AAl?$AAi?$AAs?$AAt?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AAs?$AA?5?$AAi?$AAn?$AAc?$AAo?$AAm?$AAp?$AAa?$AAt?$AAi?$AAb?$AAl?$AAe?$AA?$AA@:
.rdata:0000B3D0                                         ; DATA XREF: std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>::operator==(std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>> const &)+36o
.rdata:0000B3D0                                         ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::operator==(std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const &)+36o
.rdata:0000B3D0                 unicode 0, <list iterators incompatible>,0
.rdata:0000B3D0 _rdata          ends
.rdata:0000B3D0
.rdata:0000B408 ; ===========================================================================
.rdata:0000B408
.rdata:0000B408 ; Segment type: Pure data
.rdata:0000B408 ; Segment permissions: Read
.rdata:0000B408 _rdata          segment dword public 'DATA' use32
.rdata:0000B408                 assume cs:_rdata
.rdata:0000B408                 ;org 0B408h
.rdata:0000B408 ; COMDAT (pick any)
.rdata:0000B408                 public ??_C@_0CI@FNPHFCCM@Standard?5C?$CL?$CL?5Libraries?5Invalid?5A@
.rdata:0000B408 ; `string'
.rdata:0000B408 ??_C@_0CI@FNPHFCCM@Standard?5C?$CL?$CL?5Libraries?5Invalid?5A@ db 'Standard C++ Libraries Invalid Argument',0
.rdata:0000B408                                         ; DATA XREF: std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>::operator==(std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>> const &)+43o
.rdata:0000B408                                         ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::operator==(std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const &)+43o
.rdata:0000B408 _rdata          ends
.rdata:0000B408
.rdata:0000B430 ; ===========================================================================
.rdata:0000B430
.rdata:0000B430 ; Segment type: Pure data
.rdata:0000B430 ; Segment permissions: Read
.rdata:0000B430 ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000B430 _rdata          segment para public 'DATA' use32
.rdata:0000B430                 assume cs:_rdata
.rdata:0000B430                 ;org 0B430h
.rdata:0000B430 ; COMDAT (pick any)
.rdata:0000B430                 public ??_C@_1FO@GJIHNDLM@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5@
.rdata:0000B430 ; `string'
.rdata:0000B430 ??_C@_1FO@GJIHNDLM@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5@:
.rdata:0000B430                                         ; DATA XREF: std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>::operator==(std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>> const &):loc_5314o
.rdata:0000B430                                         ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::operator==(std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const &):loc_53D0o
.rdata:0000B430                 unicode 0, <"Standard C++ Libraries Invalid Argument" && 0>,0
.rdata:0000B48E                 align 10h
.rdata:0000B48E _rdata          ends
.rdata:0000B48E
.rdata:0000B490 ; ===========================================================================
.rdata:0000B490
.rdata:0000B490 ; Segment type: Pure data
.rdata:0000B490 ; Segment permissions: Read
.rdata:0000B490 _rdata          segment dword public 'DATA' use32
.rdata:0000B490                 assume cs:_rdata
.rdata:0000B490                 ;org 0B490h
.rdata:0000B490 ; COMDAT (pick any)
.rdata:0000B490                 public ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@
.rdata:0000B490 ; `string'
.rdata:0000B490 ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@:
.rdata:0000B490                                         ; DATA XREF: std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>::operator==(std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>> const &)+87o
.rdata:0000B490                                         ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::operator==(std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const &)+87o
.rdata:0000B490                 unicode 0, <"invalid argument">,0
.rdata:0000B4B6                 align 4
.rdata:0000B4B6 _rdata          ends
.rdata:0000B4B6
.rdata:0000B4B8 ; ===========================================================================
.rdata:0000B4B8
.rdata:0000B4B8 ; Segment type: Pure data
.rdata:0000B4B8 ; Segment permissions: Read
.rdata:0000B4B8 ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000B4B8 _rdata          segment para public 'DATA' use32
.rdata:0000B4B8                 assume cs:_rdata
.rdata:0000B4B8                 ;org 0B4B8h
.rdata:0000B4B8 ; COMDAT (pick any)
.rdata:0000B4B8                 public ??_C@_1CEO@JJNDPOME@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAL?$AAi?$AAs?$AAt?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5@
.rdata:0000B4B8 ; `string'
.rdata:0000B4B8 ??_C@_1CEO@JJNDPOME@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAL?$AAi?$AAs?$AAt?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5@:
.rdata:0000B4B8                                         ; DATA XREF: std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::operator++(void)+85o
.rdata:0000B4B8                 unicode 0, <std::_List_const_iterator>
.rdata:0000B4B8                 dw 3Ch
.rdata:0000B4B8                 unicode 0, <class std::_List_val>
.rdata:0000B4B8                 dw 3Ch
.rdata:0000B4B8                 unicode 0, <struct std::_List_simple_types>
.rdata:0000B4B8                 dw 3Ch
.rdata:0000B4B8                 unicode 0, <struct std::pair>
.rdata:0000B4B8                 dw 3Ch
.rdata:0000B4B8                 unicode 0, <class Buffer * const,class std::unordered_map>
.rdata:0000B4B8                 dw 3Ch
.rdata:0000B4B8                 unicode 0, <int,struct Style,struct std::hash>
.rdata:0000B4B8                 dw 3Ch
.rdata:0000B4B8                 unicode 0, <int>
.rdata:0000B4B8                 dw 3Eh
.rdata:0000B4B8                 unicode 0, <,struct std::equal_to>
.rdata:0000B4B8                 dw 3Ch
.rdata:0000B4B8                 unicode 0, <int>
.rdata:0000B4B8                 dw 3Eh
.rdata:0000B4B8                 unicode 0, <,class std::allocator>
.rdata:0000B4B8                 dw 3Ch
.rdata:0000B4B8                 unicode 0, <struct std::pair>
.rdata:0000B4B8                 dw 3Ch
.rdata:0000B4B8                 unicode 0, <int const ,struct Style>
.rdata:0000B4B8                 dw 3Eh
.rdata:0000B4B8                 unicode 0, < >
.rdata:0000B4B8                 dw 3Eh
.rdata:0000B4B8                 unicode 0, < >
.rdata:0000B4B8                 dw 3Eh
.rdata:0000B4B8                 unicode 0, < *>
.rdata:0000B4B8                 dw 3Eh
.rdata:0000B4B8                 unicode 0, < >
.rdata:0000B4B8                 dw 3Eh
.rdata:0000B4B8                 unicode 0, < >
.rdata:0000B4B8                 dw 3Eh
.rdata:0000B4B8                 unicode 0, < >
.rdata:0000B4B8                 dw 3Eh
.rdata:0000B4B8                 unicode 0, <::operator ++>,0
.rdata:0000B706                 align 4
.rdata:0000B706 _rdata          ends
.rdata:0000B706
.rdata:0000B708 ; ===========================================================================
.rdata:0000B708
.rdata:0000B708 ; Segment type: Pure data
.rdata:0000B708 ; Segment permissions: Read
.rdata:0000B708 ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000B708 _rdata          segment para public 'DATA' use32
.rdata:0000B708                 assume cs:_rdata
.rdata:0000B708                 ;org 0B708h
.rdata:0000B708 ; COMDAT (pick any)
.rdata:0000B708                 public ??_C@_1CEO@DJCOBHAB@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAL?$AAi?$AAs?$AAt?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5@
.rdata:0000B708 ; `string'
.rdata:0000B708 ??_C@_1CEO@DJCOBHAB@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAL?$AAi?$AAs?$AAt?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5@:
.rdata:0000B708                                         ; DATA XREF: std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::operator==(std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const &)+82o
.rdata:0000B708                 unicode 0, <std::_List_const_iterator>
.rdata:0000B708                 dw 3Ch
.rdata:0000B708                 unicode 0, <class std::_List_val>
.rdata:0000B708                 dw 3Ch
.rdata:0000B708                 unicode 0, <struct std::_List_simple_types>
.rdata:0000B708                 dw 3Ch
.rdata:0000B708                 unicode 0, <struct std::pair>
.rdata:0000B708                 dw 3Ch
.rdata:0000B708                 unicode 0, <class Buffer * const,class std::unordered_map>
.rdata:0000B708                 dw 3Ch
.rdata:0000B708                 unicode 0, <int,struct Style,struct std::hash>
.rdata:0000B708                 dw 3Ch
.rdata:0000B708                 unicode 0, <int>
.rdata:0000B708                 dw 3Eh
.rdata:0000B708                 unicode 0, <,struct std::equal_to>
.rdata:0000B708                 dw 3Ch
.rdata:0000B708                 unicode 0, <int>
.rdata:0000B708                 dw 3Eh
.rdata:0000B708                 unicode 0, <,class std::allocator>
.rdata:0000B708                 dw 3Ch
.rdata:0000B708                 unicode 0, <struct std::pair>
.rdata:0000B708                 dw 3Ch
.rdata:0000B708                 unicode 0, <int const ,struct Style>
.rdata:0000B708                 dw 3Eh
.rdata:0000B708                 unicode 0, < >
.rdata:0000B708                 dw 3Eh
.rdata:0000B708                 unicode 0, < >
.rdata:0000B708                 dw 3Eh
.rdata:0000B708                 unicode 0, < *>
.rdata:0000B708                 dw 3Eh
.rdata:0000B708                 unicode 0, < >
.rdata:0000B708                 dw 3Eh
.rdata:0000B708                 unicode 0, < >
.rdata:0000B708                 dw 3Eh
.rdata:0000B708                 unicode 0, < >
.rdata:0000B708                 dw 3Eh
.rdata:0000B708                 unicode 0, <::operator ==>,0
.rdata:0000B956                 align 4
.rdata:0000B956 _rdata          ends
.rdata:0000B956
.rdata:0000B958 ; ===========================================================================
.rdata:0000B958
.rdata:0000B958 ; Segment type: Pure data
.rdata:0000B958 ; Segment permissions: Read
.rdata:0000B958 ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000B958 _rdata          segment para public 'DATA' use32
.rdata:0000B958                 assume cs:_rdata
.rdata:0000B958                 ;org 0B958h
.rdata:0000B958 ; COMDAT (pick any)
.rdata:0000B958                 public ??_C@_1BBG@GEKGEJHF@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAL?$AAi?$AAs?$AAt?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5@
.rdata:0000B958 ; `string'
.rdata:0000B958 ??_C@_1BBG@GEKGEJHF@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAL?$AAi?$AAs?$AAt?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5@:
.rdata:0000B958                                         ; DATA XREF: std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>::operator++(void)+85o
.rdata:0000B958                 unicode 0, <std::_List_const_iterator>
.rdata:0000B958                 dw 3Ch
.rdata:0000B958                 unicode 0, <class std::_List_val>
.rdata:0000B958                 dw 3Ch
.rdata:0000B958                 unicode 0, <struct std::_List_simple_types>
.rdata:0000B958                 dw 3Ch
.rdata:0000B958                 unicode 0, <struct std::pair>
.rdata:0000B958                 dw 3Ch
.rdata:0000B958                 unicode 0, <int const ,struct Style>
.rdata:0000B958                 dw 3Eh
.rdata:0000B958                 unicode 0, < >
.rdata:0000B958                 dw 3Eh
.rdata:0000B958                 unicode 0, < >
.rdata:0000B958                 dw 3Eh
.rdata:0000B958                 unicode 0, < >
.rdata:0000B958                 dw 3Eh
.rdata:0000B958                 unicode 0, <::operator ++>,0
.rdata:0000BA6E                 align 10h
.rdata:0000BA6E _rdata          ends
.rdata:0000BA6E
.rdata:0000BA70 ; ===========================================================================
.rdata:0000BA70
.rdata:0000BA70 ; Segment type: Pure data
.rdata:0000BA70 ; Segment permissions: Read
.rdata:0000BA70 ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000BA70 _rdata          segment para public 'DATA' use32
.rdata:0000BA70                 assume cs:_rdata
.rdata:0000BA70                 ;org 0BA70h
.rdata:0000BA70 ; COMDAT (pick any)
.rdata:0000BA70                 public ??_C@_1BBG@MEFLKALA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAL?$AAi?$AAs?$AAt?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5@
.rdata:0000BA70 ; `string'
.rdata:0000BA70 ??_C@_1BBG@MEFLKALA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAL?$AAi?$AAs?$AAt?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5@:
.rdata:0000BA70                                         ; DATA XREF: std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>::operator==(std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>> const &)+82o
.rdata:0000BA70                 unicode 0, <std::_List_const_iterator>
.rdata:0000BA70                 dw 3Ch
.rdata:0000BA70                 unicode 0, <class std::_List_val>
.rdata:0000BA70                 dw 3Ch
.rdata:0000BA70                 unicode 0, <struct std::_List_simple_types>
.rdata:0000BA70                 dw 3Ch
.rdata:0000BA70                 unicode 0, <struct std::pair>
.rdata:0000BA70                 dw 3Ch
.rdata:0000BA70                 unicode 0, <int const ,struct Style>
.rdata:0000BA70                 dw 3Eh
.rdata:0000BA70                 unicode 0, < >
.rdata:0000BA70                 dw 3Eh
.rdata:0000BA70                 unicode 0, < >
.rdata:0000BA70                 dw 3Eh
.rdata:0000BA70                 unicode 0, < >
.rdata:0000BA70                 dw 3Eh
.rdata:0000BA70                 unicode 0, <::operator ==>,0
.rdata:0000BB86                 align 4
.rdata:0000BB86 _rdata          ends
.rdata:0000BB86
.rdata:0000BB88 ; ===========================================================================
.rdata:0000BB88
.rdata:0000BB88 ; Segment type: Pure data
.rdata:0000BB88 ; Segment permissions: Read
.rdata:0000BB88 _rdata          segment dword public 'DATA' use32
.rdata:0000BB88                 assume cs:_rdata
.rdata:0000BB88                 ;org 0BB88h
.rdata:0000BB88 ; COMDAT (pick any)
.rdata:0000BB88                 public ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
.rdata:0000BB88 ; char `string'[]
.rdata:0000BB88 ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ db 'string too long',0
.rdata:0000BB88                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+7o
.rdata:0000BB88 _rdata          ends
.rdata:0000BB88
.rdata:0000BB98 ; ===========================================================================
.rdata:0000BB98
.rdata:0000BB98 ; Segment type: Pure data
.rdata:0000BB98 ; Segment permissions: Read
.rdata:0000BB98 _rdata          segment dword public 'DATA' use32
.rdata:0000BB98                 assume cs:_rdata
.rdata:0000BB98                 ;org 0BB98h
.rdata:0000BB98 ; COMDAT (pick any)
.rdata:0000BB98                 public ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
.rdata:0000BB98 ; char `string'[]
.rdata:0000BB98 ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ db 'invalid string position',0
.rdata:0000BB98                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+7o
.rdata:0000BB98 _rdata          ends
.rdata:0000BB98
.rdata:0000BBB0 ; ===========================================================================
.rdata:0000BBB0
.rdata:0000BBB0 ; Segment type: Pure data
.rdata:0000BBB0 ; Segment permissions: Read
.rdata:0000BBB0 _rdata          segment dword public 'DATA' use32
.rdata:0000BBB0                 assume cs:_rdata
.rdata:0000BBB0                 ;org 0BBB0h
.rdata:0000BBB0 ; COMDAT (pick any)
.rdata:0000BBB0                 public ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
.rdata:0000BBB0 ; char `string'[]
.rdata:0000BBB0 ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ db 'vector<T> too long',0
.rdata:0000BBB0                                         ; DATA XREF: std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::_Xlen(void)+7o
.rdata:0000BBB0                                         ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::_Xlen(void)+7o
.rdata:0000BBC3                 align 4
.rdata:0000BBC3 _rdata          ends
.rdata:0000BBC3
.rdata:0000BBC4 ; ===========================================================================
.rdata:0000BBC4
.rdata:0000BBC4 ; Segment type: Pure data
.rdata:0000BBC4 ; Segment permissions: Read
.rdata:0000BBC4 ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000BBC4 _rdata          segment para public 'DATA' use32
.rdata:0000BBC4                 assume cs:_rdata
.rdata:0000BBC4                 ;org 0BBC4h
.rdata:0000BBC4 ; COMDAT (pick any)
.rdata:0000BBC4                 public ??_C@_1EM@FKAOCOMF@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AA?$CL?$AA?5?$AAo?$AAf?$AAf?$AAs?$AAe?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5@
.rdata:0000BBC4 ; wchar_t `string'
.rdata:0000BBC4 ??_C@_1EM@FKAOCOMF@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AA?$CL?$AA?5?$AAo?$AAf?$AAf?$AAs?$AAe?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5@:
.rdata:0000BBC4                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>::operator+=(int)+50o
.rdata:0000BBC4                                         ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::operator+=(int)+50o
.rdata:0000BBC4                 unicode 0, <vector iterator + offset out of range>,0
.rdata:0000BBC4 _rdata          ends
.rdata:0000BBC4
.rdata:0000BC10 ; ===========================================================================
.rdata:0000BC10
.rdata:0000BC10 ; Segment type: Pure data
.rdata:0000BC10 ; Segment permissions: Read
.rdata:0000BC10 ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000BC10 _rdata          segment para public 'DATA' use32
.rdata:0000BC10                 assume cs:_rdata
.rdata:0000BC10                 ;org 0BC10h
.rdata:0000BC10 ; COMDAT (pick any)
.rdata:0000BC10                 public ??_C@_1EC@HILJLMMC@?$AAl?$AAi?$AAs?$AAt?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAa?$AAb?$AAl?$AAe@
.rdata:0000BC10 ; wchar_t `string'
.rdata:0000BC10 ??_C@_1EC@HILJLMMC@?$AAl?$AAi?$AAs?$AAt?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAa?$AAb?$AAl?$AAe@:
.rdata:0000BC10                                         ; DATA XREF: std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>::operator*(void)+39o
.rdata:0000BC10                                         ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::operator*(void)+39o
.rdata:0000BC10                 unicode 0, <list iterator not dereferencable>,0
.rdata:0000BC52                 align 4
.rdata:0000BC52 _rdata          ends
.rdata:0000BC52
.rdata:0000BC54 ; ===========================================================================
.rdata:0000BC54
.rdata:0000BC54 ; Segment type: Pure data
.rdata:0000BC54 ; Segment permissions: Read
.rdata:0000BC54 ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000BC54 _rdata          segment para public 'DATA' use32
.rdata:0000BC54                 assume cs:_rdata
.rdata:0000BC54                 ;org 0BC54h
.rdata:0000BC54 ; COMDAT (pick any)
.rdata:0000BC54                 public ??_C@_1CEM@BAKEJGH@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAL?$AAi?$AAs?$AAt?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5@
.rdata:0000BC54 ; `string'
.rdata:0000BC54 ??_C@_1CEM@BAKEJGH@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAL?$AAi?$AAs?$AAt?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5@:
.rdata:0000BC54                                         ; DATA XREF: std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::operator*(void)+85o
.rdata:0000BC54                 unicode 0, <std::_List_const_iterator>
.rdata:0000BC54                 dw 3Ch
.rdata:0000BC54                 unicode 0, <class std::_List_val>
.rdata:0000BC54                 dw 3Ch
.rdata:0000BC54                 unicode 0, <struct std::_List_simple_types>
.rdata:0000BC54                 dw 3Ch
.rdata:0000BC54                 unicode 0, <struct std::pair>
.rdata:0000BC54                 dw 3Ch
.rdata:0000BC54                 unicode 0, <class Buffer * const,class std::unordered_map>
.rdata:0000BC54                 dw 3Ch
.rdata:0000BC54                 unicode 0, <int,struct Style,struct std::hash>
.rdata:0000BC54                 dw 3Ch
.rdata:0000BC54                 unicode 0, <int>
.rdata:0000BC54                 dw 3Eh
.rdata:0000BC54                 unicode 0, <,struct std::equal_to>
.rdata:0000BC54                 dw 3Ch
.rdata:0000BC54                 unicode 0, <int>
.rdata:0000BC54                 dw 3Eh
.rdata:0000BC54                 unicode 0, <,class std::allocator>
.rdata:0000BC54                 dw 3Ch
.rdata:0000BC54                 unicode 0, <struct std::pair>
.rdata:0000BC54                 dw 3Ch
.rdata:0000BC54                 unicode 0, <int const ,struct Style>
.rdata:0000BC54                 dw 3Eh
.rdata:0000BC54                 unicode 0, < >
.rdata:0000BC54                 dw 3Eh
.rdata:0000BC54                 unicode 0, < >
.rdata:0000BC54                 dw 3Eh
.rdata:0000BC54                 unicode 0, < *>
.rdata:0000BC54                 dw 3Eh
.rdata:0000BC54                 unicode 0, < >
.rdata:0000BC54                 dw 3Eh
.rdata:0000BC54                 unicode 0, < >
.rdata:0000BC54                 dw 3Eh
.rdata:0000BC54                 unicode 0, < >
.rdata:0000BC54                 dw 3Eh
.rdata:0000BC54                 unicode 0, <::operator *>,0
.rdata:0000BC54 _rdata          ends
.rdata:0000BC54
.rdata:0000BEA0 ; ===========================================================================
.rdata:0000BEA0
.rdata:0000BEA0 ; Segment type: Pure data
.rdata:0000BEA0 ; Segment permissions: Read
.rdata:0000BEA0 ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000BEA0 _rdata          segment para public 'DATA' use32
.rdata:0000BEA0                 assume cs:_rdata
.rdata:0000BEA0                 ;org 0BEA0h
.rdata:0000BEA0 ; COMDAT (pick any)
.rdata:0000BEA0                 public ??_C@_1BBE@PIHPBAPJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAL?$AAi?$AAs?$AAt?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5@
.rdata:0000BEA0 ; `string'
.rdata:0000BEA0 ??_C@_1BBE@PIHPBAPJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAL?$AAi?$AAs?$AAt?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5@:
.rdata:0000BEA0                                         ; DATA XREF: std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>::operator*(void)+85o
.rdata:0000BEA0                 unicode 0, <std::_List_const_iterator>
.rdata:0000BEA0                 dw 3Ch
.rdata:0000BEA0                 unicode 0, <class std::_List_val>
.rdata:0000BEA0                 dw 3Ch
.rdata:0000BEA0                 unicode 0, <struct std::_List_simple_types>
.rdata:0000BEA0                 dw 3Ch
.rdata:0000BEA0                 unicode 0, <struct std::pair>
.rdata:0000BEA0                 dw 3Ch
.rdata:0000BEA0                 unicode 0, <int const ,struct Style>
.rdata:0000BEA0                 dw 3Eh
.rdata:0000BEA0                 unicode 0, < >
.rdata:0000BEA0                 dw 3Eh
.rdata:0000BEA0                 unicode 0, < >
.rdata:0000BEA0                 dw 3Eh
.rdata:0000BEA0                 unicode 0, < >
.rdata:0000BEA0                 dw 3Eh
.rdata:0000BEA0                 unicode 0, <::operator *>,0
.rdata:0000BEA0 _rdata          ends
.rdata:0000BEA0
.rdata:0000BFB4 ; ===========================================================================
.rdata:0000BFB4
.rdata:0000BFB4 ; Segment type: Pure data
.rdata:0000BFB4 ; Segment permissions: Read
.rdata:0000BFB4 ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000BFB4 _rdata          segment para public 'DATA' use32
.rdata:0000BFB4                 assume cs:_rdata
.rdata:0000BFB4                 ;org 0BFB4h
.rdata:0000BFB4 ; COMDAT (pick any)
.rdata:0000BFB4                 public ??_C@_1PC@LBPAGKOJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
.rdata:0000BFB4 ; `string'
.rdata:0000BFB4 ??_C@_1PC@LBPAGKOJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@:
.rdata:0000BFB4                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ScintillaEditView *>>>::operator+=(int)+9Co
.rdata:0000BFB4                 unicode 0, <std::_Vector_const_iterator>
.rdata:0000BFB4                 dw 3Ch
.rdata:0000BFB4                 unicode 0, <class std::_Vector_val>
.rdata:0000BFB4                 dw 3Ch
.rdata:0000BFB4                 unicode 0, <struct std::_Simple_types>
.rdata:0000BFB4                 dw 3Ch
.rdata:0000BFB4                 unicode 0, <class ScintillaEditView *>
.rdata:0000BFB4                 dw 3Eh
.rdata:0000BFB4                 unicode 0, < >
.rdata:0000BFB4                 dw 3Eh
.rdata:0000BFB4                 unicode 0, < >
.rdata:0000BFB4                 dw 3Eh
.rdata:0000BFB4                 unicode 0, <::operator +=>,0
.rdata:0000C0A6                 align 4
.rdata:0000C0A6 _rdata          ends
.rdata:0000C0A6
.rdata:0000C0A8 ; ===========================================================================
.rdata:0000C0A8
.rdata:0000C0A8 ; Segment type: Pure data
.rdata:0000C0A8 ; Segment permissions: Read
.rdata:0000C0A8 ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000C0A8 _rdata          segment para public 'DATA' use32
.rdata:0000C0A8                 assume cs:_rdata
.rdata:0000C0A8                 ;org 0C0A8h
.rdata:0000C0A8 ; COMDAT (pick any)
.rdata:0000C0A8                 public ??_C@_1EK@EEHFMKDC@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAn?$AAs?$AAe?$AAr?$AAt?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAo?$AAu?$AAt?$AAs?$AAi?$AAd?$AAe?$AA?5?$AAr@
.rdata:0000C0A8 ; wchar_t `string'
.rdata:0000C0A8 ??_C@_1EK@EEHFMKDC@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAn?$AAs?$AAe?$AAr?$AAt?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAo?$AAu?$AAt?$AAs?$AAi?$AAd?$AAe?$AA?5?$AAr@:
.rdata:0000C0A8                                         ; DATA XREF: ?_Insert_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CB
.rdata:0000C0A8                 unicode 0, <vector insert iterator outside range>,0
.rdata:0000C0F2                 align 4
.rdata:0000C0F2 _rdata          ends
.rdata:0000C0F2
.rdata:0000C0F4 ; ===========================================================================
.rdata:0000C0F4
.rdata:0000C0F4 ; Segment type: Pure data
.rdata:0000C0F4 ; Segment permissions: Read
.rdata:0000C0F4 ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000C0F4 _rdata          segment para public 'DATA' use32
.rdata:0000C0F4                 assume cs:_rdata
.rdata:0000C0F4                 ;org 0C0F4h
.rdata:0000C0F4 ; COMDAT (pick any)
.rdata:0000C0F4                 public ??_C@_1DAI@BKGFFCGA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
.rdata:0000C0F4 ; `string'
.rdata:0000C0F4 ??_C@_1DAI@BKGFFCGA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@:
.rdata:0000C0F4                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>>>>::operator+=(int)+9Co
.rdata:0000C0F4                 unicode 0, <std::_Vector_const_iterator>
.rdata:0000C0F4                 dw 3Ch
.rdata:0000C0F4                 unicode 0, <class std::_Vector_val>
.rdata:0000C0F4                 dw 3Ch
.rdata:0000C0F4                 unicode 0, <struct std::_Simple_types>
.rdata:0000C0F4                 dw 3Ch
.rdata:0000C0F4                 unicode 0, <class std::_List_unchecked_iterator>
.rdata:0000C0F4                 dw 3Ch
.rdata:0000C0F4                 unicode 0, <class std::_List_val>
.rdata:0000C0F4                 dw 3Ch
.rdata:0000C0F4                 unicode 0, <struct std::_List_simple_types>
.rdata:0000C0F4                 dw 3Ch
.rdata:0000C0F4                 unicode 0, <struct std::pair>
.rdata:0000C0F4                 dw 3Ch
.rdata:0000C0F4                 unicode 0, <class Buffer * const,class std::unordered_map>
.rdata:0000C0F4                 dw 3Ch
.rdata:0000C0F4                 unicode 0, <int,struct Style,struct std::hash>
.rdata:0000C0F4                 dw 3Ch
.rdata:0000C0F4                 unicode 0, <int>
.rdata:0000C0F4                 dw 3Eh
.rdata:0000C0F4                 unicode 0, <,struct std::equal_to>
.rdata:0000C0F4                 dw 3Ch
.rdata:0000C0F4                 unicode 0, <int>
.rdata:0000C0F4                 dw 3Eh
.rdata:0000C0F4                 unicode 0, <,class std::allocator>
.rdata:0000C0F4                 dw 3Ch
.rdata:0000C0F4                 unicode 0, <struct std::pair>
.rdata:0000C0F4                 dw 3Ch
.rdata:0000C0F4                 unicode 0, <int const ,struct Style>
.rdata:0000C0F4                 dw 3Eh
.rdata:0000C0F4                 unicode 0, < >
.rdata:0000C0F4                 dw 3Eh
.rdata:0000C0F4                 unicode 0, < >
.rdata:0000C0F4                 dw 3Eh
.rdata:0000C0F4                 unicode 0, < *>
.rdata:0000C0F4                 dw 3Eh
.rdata:0000C0F4                 unicode 0, < >
.rdata:0000C0F4                 dw 3Eh
.rdata:0000C0F4                 unicode 0, < >
.rdata:0000C0F4                 dw 3Eh
.rdata:0000C0F4                 unicode 0, < >
.rdata:0000C0F4                 dw 3Eh
.rdata:0000C0F4                 unicode 0, < >
.rdata:0000C0F4                 dw 3Eh
.rdata:0000C0F4                 unicode 0, < >
.rdata:0000C0F4                 dw 3Eh
.rdata:0000C0F4                 unicode 0, < >
.rdata:0000C0F4                 dw 3Eh
.rdata:0000C0F4                 unicode 0, <::operator +=>,0
.rdata:0000C0F4 _rdata          ends
.rdata:0000C0F4
.rdata:0000C3FC ; ===========================================================================
.rdata:0000C3FC
.rdata:0000C3FC ; Segment type: Pure data
.rdata:0000C3FC ; Segment permissions: Read
.rdata:0000C3FC _rdata          segment dword public 'DATA' use32
.rdata:0000C3FC                 assume cs:_rdata
.rdata:0000C3FC                 ;org 0C3FCh
.rdata:0000C3FC ; COMDAT (pick any)
.rdata:0000C3FC                 public ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
.rdata:0000C3FC ; wchar_t `string'
.rdata:0000C3FC ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@:
.rdata:0000C3FC                                         ; DATA XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+11o
.rdata:0000C3FC                                         ; std::_Debug_pointer<ScintillaEditView *>(ScintillaEditView * *,wchar_t const *,uint)+11o ...
.rdata:0000C3FC                 unicode 0, <invalid null pointer>,0
.rdata:0000C426                 align 4
.rdata:0000C426 _rdata          ends
.rdata:0000C426
.rdata:0000C428 ; ===========================================================================
.rdata:0000C428
.rdata:0000C428 ; Segment type: Pure data
.rdata:0000C428 ; Segment permissions: Read
.rdata:0000C428 _rdata          segment dword public 'DATA' use32
.rdata:0000C428                 assume cs:_rdata
.rdata:0000C428                 ;org 0C428h
.rdata:0000C428 ; COMDAT (pick any)
.rdata:0000C428                 public ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@
.rdata:0000C428 ; wchar_t `string'
.rdata:0000C428 ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@:
.rdata:0000C428                                         ; DATA XREF: std::_Debug_range2<ScintillaEditView * *>(ScintillaEditView * *,ScintillaEditView * *,wchar_t const *,uint,std::random_access_iterator_tag)+43o
.rdata:0000C428                                         ; std::_Debug_range2<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *>(std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> *,wchar_t const *,uint,std::random_access_iterator_tag)+43o
.rdata:0000C428                 unicode 0, <invalid iterator range>,0
.rdata:0000C456                 align 4
.rdata:0000C456 _rdata          ends
.rdata:0000C456
.rdata:0000C458 ; ===========================================================================
.rdata:0000C458
.rdata:0000C458 ; Segment type: Pure data
.rdata:0000C458 ; Segment permissions: Read
.rdata:0000C458 ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000C458 _rdata          segment para public 'DATA' use32
.rdata:0000C458                 assume cs:_rdata
.rdata:0000C458                 ;org 0C458h
.rdata:0000C458 ; COMDAT (pick any)
.rdata:0000C458                 public ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:0000C458 ; wchar_t `string'
.rdata:0000C458 ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:0000C458                                         ; DATA XREF: ??$_Uninit_move@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@V12@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@PAV10@00AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@0@0U_No
.rdata:0000C458                                         ; ??$_Uninit_move@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@V12@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@PAV10@00AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@0@0U_Nonscalar_ptr ...
.rdata:0000C458                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:0000C458                 unicode 0, <clude\xmemory>,0
.rdata:0000C4E6                 align 4
.rdata:0000C4E6 _rdata          ends
.rdata:0000C4E6
.rdata$r:0000C4E8 ; ===========================================================================
.rdata$r:0000C4E8
.rdata$r:0000C4E8 ; Segment type: Pure data
.rdata$r:0000C4E8 ; Segment permissions: Read
.rdata$r:0000C4E8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000C4E8                 assume cs:_rdata$r
.rdata$r:0000C4E8                 ;org 0C4E8h
.rdata$r:0000C4E8 ; COMDAT (pick any)
.rdata$r:0000C4E8                 public ??_R4ScintillaEditView@@6B@
.rdata$r:0000C4E8 ; const ScintillaEditView::`RTTI Complete Object Locator'
.rdata$r:0000C4E8 ??_R4ScintillaEditView@@6B@ db    0     ; DATA XREF: .rdata:0000AFBCo
.rdata$r:0000C4E9                 db    0
.rdata$r:0000C4EA                 db    0
.rdata$r:0000C4EB                 db    0
.rdata$r:0000C4EC                 db    0
.rdata$r:0000C4ED                 db    0
.rdata$r:0000C4EE                 db    0
.rdata$r:0000C4EF                 db    0
.rdata$r:0000C4F0                 db    0
.rdata$r:0000C4F1                 db    0
.rdata$r:0000C4F2                 db    0
.rdata$r:0000C4F3                 db    0
.rdata$r:0000C4F4                 dd offset ??_R0?AVScintillaEditView@@@8 ; ScintillaEditView `RTTI Type Descriptor'
.rdata$r:0000C4F8                 dd offset ??_R3ScintillaEditView@@8 ; ScintillaEditView::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000C4F8 _rdata$r        ends
.rdata$r:0000C4F8
.data$r:0000C4FC ; ===========================================================================
.data$r:0000C4FC
.data$r:0000C4FC ; Segment type: Pure data
.data$r:0000C4FC ; Segment permissions: Read/Write
.data$r:0000C4FC _data$r         segment dword public 'DATA' use32
.data$r:0000C4FC                 assume cs:_data$r
.data$r:0000C4FC                 ;org 0C4FCh
.data$r:0000C4FC ; COMDAT (pick any)
.data$r:0000C4FC                 public ??_R0?AVScintillaEditView@@@8
.data$r:0000C4FC ; class ScintillaEditView `RTTI Type Descriptor'
.data$r:0000C4FC ??_R0?AVScintillaEditView@@@8 dd offset ??_7type_info@@6B@
.data$r:0000C4FC                                         ; DATA XREF: .rdata$r:0000C4F4o
.data$r:0000C4FC                                         ; .rdata$r:ScintillaEditView::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:0000C4FC                                         ; const type_info::`vftable'
.data$r:0000C500                 db    0
.data$r:0000C501                 db    0
.data$r:0000C502                 db    0
.data$r:0000C503                 db    0
.data$r:0000C504                 db  2Eh ; .
.data$r:0000C505                 db  3Fh ; ?
.data$r:0000C506                 db  41h ; A
.data$r:0000C507                 db  56h ; V
.data$r:0000C508                 db  53h ; S
.data$r:0000C509                 db  63h ; c
.data$r:0000C50A                 db  69h ; i
.data$r:0000C50B                 db  6Eh ; n
.data$r:0000C50C                 db  74h ; t
.data$r:0000C50D                 db  69h ; i
.data$r:0000C50E                 db  6Ch ; l
.data$r:0000C50F                 db  6Ch ; l
.data$r:0000C510                 db  61h ; a
.data$r:0000C511                 db  45h ; E
.data$r:0000C512                 db  64h ; d
.data$r:0000C513                 db  69h ; i
.data$r:0000C514                 db  74h ; t
.data$r:0000C515                 db  56h ; V
.data$r:0000C516                 db  69h ; i
.data$r:0000C517                 db  65h ; e
.data$r:0000C518                 db  77h ; w
.data$r:0000C519                 db  40h ; @
.data$r:0000C51A                 db  40h ; @
.data$r:0000C51B                 db    0
.data$r:0000C51B _data$r         ends
.data$r:0000C51B
.rdata$r:0000C51C ; ===========================================================================
.rdata$r:0000C51C
.rdata$r:0000C51C ; Segment type: Pure data
.rdata$r:0000C51C ; Segment permissions: Read
.rdata$r:0000C51C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000C51C                 assume cs:_rdata$r
.rdata$r:0000C51C                 ;org 0C51Ch
.rdata$r:0000C51C ; COMDAT (pick any)
.rdata$r:0000C51C                 public ??_R3ScintillaEditView@@8
.rdata$r:0000C51C ; ScintillaEditView::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000C51C ??_R3ScintillaEditView@@8 db    0       ; DATA XREF: .rdata$r:0000C4F8o
.rdata$r:0000C51C                                         ; .rdata$r:0000C550o
.rdata$r:0000C51D                 db    0
.rdata$r:0000C51E                 db    0
.rdata$r:0000C51F                 db    0
.rdata$r:0000C520                 db    0
.rdata$r:0000C521                 db    0
.rdata$r:0000C522                 db    0
.rdata$r:0000C523                 db    0
.rdata$r:0000C524                 db    2
.rdata$r:0000C525                 db    0
.rdata$r:0000C526                 db    0
.rdata$r:0000C527                 db    0
.rdata$r:0000C528                 dd offset ??_R2ScintillaEditView@@8 ; ScintillaEditView::`RTTI Base Class Array'
.rdata$r:0000C528 _rdata$r        ends
.rdata$r:0000C528
.rdata$r:0000C52C ; ===========================================================================
.rdata$r:0000C52C
.rdata$r:0000C52C ; Segment type: Pure data
.rdata$r:0000C52C ; Segment permissions: Read
.rdata$r:0000C52C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000C52C                 assume cs:_rdata$r
.rdata$r:0000C52C                 ;org 0C52Ch
.rdata$r:0000C52C ; COMDAT (pick any)
.rdata$r:0000C52C                 public ??_R2ScintillaEditView@@8
.rdata$r:0000C52C ; ScintillaEditView::`RTTI Base Class Array'
.rdata$r:0000C52C ??_R2ScintillaEditView@@8 dd offset ??_R1A@?0A@EA@ScintillaEditView@@8
.rdata$r:0000C52C                                         ; DATA XREF: .rdata$r:0000C528o
.rdata$r:0000C52C                                         ; ScintillaEditView::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000C530                 dd offset ??_R1A@?0A@EA@Window@@8 ; Window::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000C534                 db    0
.rdata$r:0000C535                 align 4
.rdata$r:0000C535 _rdata$r        ends
.rdata$r:0000C535
.rdata$r:0000C538 ; ===========================================================================
.rdata$r:0000C538
.rdata$r:0000C538 ; Segment type: Pure data
.rdata$r:0000C538 ; Segment permissions: Read
.rdata$r:0000C538 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000C538                 assume cs:_rdata$r
.rdata$r:0000C538                 ;org 0C538h
.rdata$r:0000C538 ; COMDAT (pick any)
.rdata$r:0000C538                 public ??_R1A@?0A@EA@ScintillaEditView@@8
.rdata$r:0000C538 ; ScintillaEditView::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000C538 ??_R1A@?0A@EA@ScintillaEditView@@8 dd offset ??_R0?AVScintillaEditView@@@8
.rdata$r:0000C538                                         ; DATA XREF: .rdata$r:ScintillaEditView::`RTTI Base Class Array'o
.rdata$r:0000C538                                         ; ScintillaEditView `RTTI Type Descriptor'
.rdata$r:0000C53C                 db    1
.rdata$r:0000C53D                 db    0
.rdata$r:0000C53E                 db    0
.rdata$r:0000C53F                 db    0
.rdata$r:0000C540                 db    0
.rdata$r:0000C541                 db    0
.rdata$r:0000C542                 db    0
.rdata$r:0000C543                 db    0
.rdata$r:0000C544                 db 0FFh
.rdata$r:0000C545                 db 0FFh
.rdata$r:0000C546                 db 0FFh
.rdata$r:0000C547                 db 0FFh
.rdata$r:0000C548                 db    0
.rdata$r:0000C549                 db    0
.rdata$r:0000C54A                 db    0
.rdata$r:0000C54B                 db    0
.rdata$r:0000C54C                 db  40h ; @
.rdata$r:0000C54D                 db    0
.rdata$r:0000C54E                 db    0
.rdata$r:0000C54F                 db    0
.rdata$r:0000C550                 dd offset ??_R3ScintillaEditView@@8 ; ScintillaEditView::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000C550 _rdata$r        ends
.rdata$r:0000C550
.rdata$r:0000C554 ; ===========================================================================
.rdata$r:0000C554
.rdata$r:0000C554 ; Segment type: Pure data
.rdata$r:0000C554 ; Segment permissions: Read
.rdata$r:0000C554 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000C554                 assume cs:_rdata$r
.rdata$r:0000C554                 ;org 0C554h
.rdata$r:0000C554 ; COMDAT (pick any)
.rdata$r:0000C554                 public ??_R1A@?0A@EA@Window@@8
.rdata$r:0000C554 ; Window::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000C554 ??_R1A@?0A@EA@Window@@8 dd offset ??_R0?AVWindow@@@8
.rdata$r:0000C554                                         ; DATA XREF: .rdata$r:0000C530o
.rdata$r:0000C554                                         ; .rdata$r:Window::`RTTI Base Class Array'o
.rdata$r:0000C554                                         ; Window `RTTI Type Descriptor'
.rdata$r:0000C558                 align 10h
.rdata$r:0000C560                 db 0FFh
.rdata$r:0000C561                 db 0FFh
.rdata$r:0000C562                 db 0FFh
.rdata$r:0000C563                 db 0FFh
.rdata$r:0000C564                 db    0
.rdata$r:0000C565                 db    0
.rdata$r:0000C566                 db    0
.rdata$r:0000C567                 db    0
.rdata$r:0000C568                 db  40h ; @
.rdata$r:0000C569                 db    0
.rdata$r:0000C56A                 db    0
.rdata$r:0000C56B                 db    0
.rdata$r:0000C56C                 dd offset ??_R3Window@@8 ; Window::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000C56C _rdata$r        ends
.rdata$r:0000C56C
.data$r:0000C570 ; ===========================================================================
.data$r:0000C570
.data$r:0000C570 ; Segment type: Pure data
.data$r:0000C570 ; Segment permissions: Read/Write
.data$r:0000C570 _data$r         segment dword public 'DATA' use32
.data$r:0000C570                 assume cs:_data$r
.data$r:0000C570                 ;org 0C570h
.data$r:0000C570 ; COMDAT (pick any)
.data$r:0000C570                 public ??_R0?AVWindow@@@8
.data$r:0000C570 ; class Window `RTTI Type Descriptor'
.data$r:0000C570 ??_R0?AVWindow@@@8 dd offset ??_7type_info@@6B@
.data$r:0000C570                                         ; DATA XREF: .rdata$r:Window::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:0000C570                                         ; .rdata$r:0000C788o
.data$r:0000C570                                         ; const type_info::`vftable'
.data$r:0000C574                 align 8
.data$r:0000C578 a_?avwindow@@   db '.?AVWindow@@',0
.data$r:0000C585                 align 4
.data$r:0000C585 _data$r         ends
.data$r:0000C585
.rdata$r:0000C588 ; ===========================================================================
.rdata$r:0000C588
.rdata$r:0000C588 ; Segment type: Pure data
.rdata$r:0000C588 ; Segment permissions: Read
.rdata$r:0000C588 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000C588                 assume cs:_rdata$r
.rdata$r:0000C588                 ;org 0C588h
.rdata$r:0000C588 ; COMDAT (pick any)
.rdata$r:0000C588                 public ??_R3Window@@8
.rdata$r:0000C588 ; Window::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000C588 ??_R3Window@@8  db    0                 ; DATA XREF: .rdata$r:0000C56Co
.rdata$r:0000C588                                         ; .rdata$r:0000C78Co
.rdata$r:0000C589                 db    0
.rdata$r:0000C58A                 db    0
.rdata$r:0000C58B                 db    0
.rdata$r:0000C58C                 db    0
.rdata$r:0000C58D                 db    0
.rdata$r:0000C58E                 db    0
.rdata$r:0000C58F                 db    0
.rdata$r:0000C590                 db    1
.rdata$r:0000C591                 db    0
.rdata$r:0000C592                 db    0
.rdata$r:0000C593                 db    0
.rdata$r:0000C594                 dd offset ??_R2Window@@8 ; Window::`RTTI Base Class Array'
.rdata$r:0000C594 _rdata$r        ends
.rdata$r:0000C594
.rdata$r:0000C598 ; ===========================================================================
.rdata$r:0000C598
.rdata$r:0000C598 ; Segment type: Pure data
.rdata$r:0000C598 ; Segment permissions: Read
.rdata$r:0000C598 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000C598                 assume cs:_rdata$r
.rdata$r:0000C598                 ;org 0C598h
.rdata$r:0000C598 ; COMDAT (pick any)
.rdata$r:0000C598                 public ??_R2Window@@8
.rdata$r:0000C598 ; Window::`RTTI Base Class Array'
.rdata$r:0000C598 ??_R2Window@@8  dd offset ??_R1A@?0A@EA@Window@@8
.rdata$r:0000C598                                         ; DATA XREF: .rdata$r:0000C594o
.rdata$r:0000C598                                         ; Window::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000C59C                 db    0
.rdata$r:0000C59D                 align 10h
.rdata$r:0000C59D _rdata$r        ends
.rdata$r:0000C59D
.rdata$r:0000C5A0 ; ===========================================================================
.rdata$r:0000C5A0
.rdata$r:0000C5A0 ; Segment type: Pure data
.rdata$r:0000C5A0 ; Segment permissions: Read
.rdata$r:0000C5A0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000C5A0                 assume cs:_rdata$r
.rdata$r:0000C5A0                 ;org 0C5A0h
.rdata$r:0000C5A0 ; COMDAT (pick any)
.rdata$r:0000C5A0                 public ??_R4error_category@std@@6B@
.rdata$r:0000C5A0 ; const std::error_category::`RTTI Complete Object Locator'
.rdata$r:0000C5A0 ??_R4error_category@std@@6B@ db    0    ; DATA XREF: .rdata:0000AEC0o
.rdata$r:0000C5A1                 db    0
.rdata$r:0000C5A2                 db    0
.rdata$r:0000C5A3                 db    0
.rdata$r:0000C5A4                 db    0
.rdata$r:0000C5A5                 db    0
.rdata$r:0000C5A6                 db    0
.rdata$r:0000C5A7                 db    0
.rdata$r:0000C5A8                 db    0
.rdata$r:0000C5A9                 db    0
.rdata$r:0000C5AA                 db    0
.rdata$r:0000C5AB                 db    0
.rdata$r:0000C5AC                 dd offset ??_R0?AVerror_category@std@@@8 ; std::error_category `RTTI Type Descriptor'
.rdata$r:0000C5B0                 dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000C5B0 _rdata$r        ends
.rdata$r:0000C5B0
.data$r:0000C5B4 ; ===========================================================================
.data$r:0000C5B4
.data$r:0000C5B4 ; Segment type: Pure data
.data$r:0000C5B4 ; Segment permissions: Read/Write
.data$r:0000C5B4 _data$r         segment dword public 'DATA' use32
.data$r:0000C5B4                 assume cs:_data$r
.data$r:0000C5B4                 ;org 0C5B4h
.data$r:0000C5B4 ; COMDAT (pick any)
.data$r:0000C5B4                 public ??_R0?AVerror_category@std@@@8
.data$r:0000C5B4 ; class std::error_category `RTTI Type Descriptor'
.data$r:0000C5B4 ??_R0?AVerror_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:0000C5B4                                         ; DATA XREF: .rdata$r:0000C5ACo
.data$r:0000C5B4                                         ; .rdata$r:std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:0000C5B4                                         ; const type_info::`vftable'
.data$r:0000C5B8                 db    0
.data$r:0000C5B9                 db    0
.data$r:0000C5BA                 db    0
.data$r:0000C5BB                 db    0
.data$r:0000C5BC                 db  2Eh ; .
.data$r:0000C5BD                 db  3Fh ; ?
.data$r:0000C5BE                 db  41h ; A
.data$r:0000C5BF                 db  56h ; V
.data$r:0000C5C0                 db  65h ; e
.data$r:0000C5C1                 db  72h ; r
.data$r:0000C5C2                 db  72h ; r
.data$r:0000C5C3                 db  6Fh ; o
.data$r:0000C5C4                 db  72h ; r
.data$r:0000C5C5                 db  5Fh ; _
.data$r:0000C5C6                 db  63h ; c
.data$r:0000C5C7                 db  61h ; a
.data$r:0000C5C8                 db  74h ; t
.data$r:0000C5C9                 db  65h ; e
.data$r:0000C5CA                 db  67h ; g
.data$r:0000C5CB                 db  6Fh ; o
.data$r:0000C5CC                 db  72h ; r
.data$r:0000C5CD                 db  79h ; y
.data$r:0000C5CE                 db  40h ; @
.data$r:0000C5CF                 db  73h ; s
.data$r:0000C5D0                 db  74h ; t
.data$r:0000C5D1                 db  64h ; d
.data$r:0000C5D2                 db  40h ; @
.data$r:0000C5D3                 db  40h ; @
.data$r:0000C5D4                 db    0
.data$r:0000C5D5                 align 4
.data$r:0000C5D5 _data$r         ends
.data$r:0000C5D5
.rdata$r:0000C5D8 ; ===========================================================================
.rdata$r:0000C5D8
.rdata$r:0000C5D8 ; Segment type: Pure data
.rdata$r:0000C5D8 ; Segment permissions: Read
.rdata$r:0000C5D8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000C5D8                 assume cs:_rdata$r
.rdata$r:0000C5D8                 ;org 0C5D8h
.rdata$r:0000C5D8 ; COMDAT (pick any)
.rdata$r:0000C5D8                 public ??_R3error_category@std@@8
.rdata$r:0000C5D8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000C5D8 ??_R3error_category@std@@8 db    0      ; DATA XREF: .rdata$r:0000C5B0o
.rdata$r:0000C5D8                                         ; .rdata$r:0000C608o
.rdata$r:0000C5D9                 db    0
.rdata$r:0000C5DA                 db    0
.rdata$r:0000C5DB                 db    0
.rdata$r:0000C5DC                 db    0
.rdata$r:0000C5DD                 db    0
.rdata$r:0000C5DE                 db    0
.rdata$r:0000C5DF                 db    0
.rdata$r:0000C5E0                 db    1
.rdata$r:0000C5E1                 db    0
.rdata$r:0000C5E2                 db    0
.rdata$r:0000C5E3                 db    0
.rdata$r:0000C5E4                 dd offset ??_R2error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
.rdata$r:0000C5E4 _rdata$r        ends
.rdata$r:0000C5E4
.rdata$r:0000C5E8 ; ===========================================================================
.rdata$r:0000C5E8
.rdata$r:0000C5E8 ; Segment type: Pure data
.rdata$r:0000C5E8 ; Segment permissions: Read
.rdata$r:0000C5E8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000C5E8                 assume cs:_rdata$r
.rdata$r:0000C5E8                 ;org 0C5E8h
.rdata$r:0000C5E8 ; COMDAT (pick any)
.rdata$r:0000C5E8                 public ??_R2error_category@std@@8
.rdata$r:0000C5E8 ; std::error_category::`RTTI Base Class Array'
.rdata$r:0000C5E8 ??_R2error_category@std@@8 dd offset ??_R1A@?0A@EA@error_category@std@@8
.rdata$r:0000C5E8                                         ; DATA XREF: .rdata$r:0000C5E4o
.rdata$r:0000C5E8                                         ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000C5EC                 db    0
.rdata$r:0000C5ED                 align 10h
.rdata$r:0000C5ED _rdata$r        ends
.rdata$r:0000C5ED
.rdata$r:0000C5F0 ; ===========================================================================
.rdata$r:0000C5F0
.rdata$r:0000C5F0 ; Segment type: Pure data
.rdata$r:0000C5F0 ; Segment permissions: Read
.rdata$r:0000C5F0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000C5F0                 assume cs:_rdata$r
.rdata$r:0000C5F0                 ;org 0C5F0h
.rdata$r:0000C5F0 ; COMDAT (pick any)
.rdata$r:0000C5F0                 public ??_R1A@?0A@EA@error_category@std@@8
.rdata$r:0000C5F0 ; std::error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000C5F0 ??_R1A@?0A@EA@error_category@std@@8 dd offset ??_R0?AVerror_category@std@@@8
.rdata$r:0000C5F0                                         ; DATA XREF: .rdata$r:std::error_category::`RTTI Base Class Array'o
.rdata$r:0000C5F0                                         ; .rdata$r:0000C660o ...
.rdata$r:0000C5F0                                         ; std::error_category `RTTI Type Descriptor'
.rdata$r:0000C5F4                 db    0
.rdata$r:0000C5F5                 db    0
.rdata$r:0000C5F6                 db    0
.rdata$r:0000C5F7                 db    0
.rdata$r:0000C5F8                 db    0
.rdata$r:0000C5F9                 db    0
.rdata$r:0000C5FA                 db    0
.rdata$r:0000C5FB                 db    0
.rdata$r:0000C5FC                 db 0FFh
.rdata$r:0000C5FD                 db 0FFh
.rdata$r:0000C5FE                 db 0FFh
.rdata$r:0000C5FF                 db 0FFh
.rdata$r:0000C600                 db    0
.rdata$r:0000C601                 db    0
.rdata$r:0000C602                 db    0
.rdata$r:0000C603                 db    0
.rdata$r:0000C604                 db  40h ; @
.rdata$r:0000C605                 db    0
.rdata$r:0000C606                 db    0
.rdata$r:0000C607                 db    0
.rdata$r:0000C608                 dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000C608 _rdata$r        ends
.rdata$r:0000C608
.rdata$r:0000C60C ; ===========================================================================
.rdata$r:0000C60C
.rdata$r:0000C60C ; Segment type: Pure data
.rdata$r:0000C60C ; Segment permissions: Read
.rdata$r:0000C60C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000C60C                 assume cs:_rdata$r
.rdata$r:0000C60C                 ;org 0C60Ch
.rdata$r:0000C60C ; COMDAT (pick any)
.rdata$r:0000C60C                 public ??_R4_Generic_error_category@std@@6B@
.rdata$r:0000C60C ; const std::_Generic_error_category::`RTTI Complete Object Locator'
.rdata$r:0000C60C ??_R4_Generic_error_category@std@@6B@ db    0
.rdata$r:0000C60C                                         ; DATA XREF: .rdata:0000AEDCo
.rdata$r:0000C60D                 db    0
.rdata$r:0000C60E                 db    0
.rdata$r:0000C60F                 db    0
.rdata$r:0000C610                 db    0
.rdata$r:0000C611                 db    0
.rdata$r:0000C612                 db    0
.rdata$r:0000C613                 db    0
.rdata$r:0000C614                 db    0
.rdata$r:0000C615                 db    0
.rdata$r:0000C616                 db    0
.rdata$r:0000C617                 db    0
.rdata$r:0000C618                 dd offset ??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category `RTTI Type Descriptor'
.rdata$r:0000C61C                 dd offset ??_R3_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000C61C _rdata$r        ends
.rdata$r:0000C61C
.data$r:0000C620 ; ===========================================================================
.data$r:0000C620
.data$r:0000C620 ; Segment type: Pure data
.data$r:0000C620 ; Segment permissions: Read/Write
.data$r:0000C620 _data$r         segment dword public 'DATA' use32
.data$r:0000C620                 assume cs:_data$r
.data$r:0000C620                 ;org 0C620h
.data$r:0000C620 ; COMDAT (pick any)
.data$r:0000C620                 public ??_R0?AV_Generic_error_category@std@@@8
.data$r:0000C620 ; class std::_Generic_error_category `RTTI Type Descriptor'
.data$r:0000C620 ??_R0?AV_Generic_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:0000C620                                         ; DATA XREF: .rdata$r:0000C618o
.data$r:0000C620                                         ; .rdata$r:std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:0000C620                                         ; const type_info::`vftable'
.data$r:0000C624                 align 8
.data$r:0000C628 a_?av_generic_e db '.?AV_Generic_error_category@std@@',0
.data$r:0000C64A                 align 4
.data$r:0000C64A _data$r         ends
.data$r:0000C64A
.rdata$r:0000C64C ; ===========================================================================
.rdata$r:0000C64C
.rdata$r:0000C64C ; Segment type: Pure data
.rdata$r:0000C64C ; Segment permissions: Read
.rdata$r:0000C64C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000C64C                 assume cs:_rdata$r
.rdata$r:0000C64C                 ;org 0C64Ch
.rdata$r:0000C64C ; COMDAT (pick any)
.rdata$r:0000C64C                 public ??_R3_Generic_error_category@std@@8
.rdata$r:0000C64C ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000C64C ??_R3_Generic_error_category@std@@8 db    0
.rdata$r:0000C64C                                         ; DATA XREF: .rdata$r:0000C61Co
.rdata$r:0000C64C                                         ; .rdata$r:0000C680o
.rdata$r:0000C64D                 db    0
.rdata$r:0000C64E                 db    0
.rdata$r:0000C64F                 db    0
.rdata$r:0000C650                 db    0
.rdata$r:0000C651                 db    0
.rdata$r:0000C652                 db    0
.rdata$r:0000C653                 db    0
.rdata$r:0000C654                 db    2
.rdata$r:0000C655                 db    0
.rdata$r:0000C656                 db    0
.rdata$r:0000C657                 db    0
.rdata$r:0000C658                 dd offset ??_R2_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
.rdata$r:0000C658 _rdata$r        ends
.rdata$r:0000C658
.rdata$r:0000C65C ; ===========================================================================
.rdata$r:0000C65C
.rdata$r:0000C65C ; Segment type: Pure data
.rdata$r:0000C65C ; Segment permissions: Read
.rdata$r:0000C65C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000C65C                 assume cs:_rdata$r
.rdata$r:0000C65C                 ;org 0C65Ch
.rdata$r:0000C65C ; COMDAT (pick any)
.rdata$r:0000C65C                 public ??_R2_Generic_error_category@std@@8
.rdata$r:0000C65C ; std::_Generic_error_category::`RTTI Base Class Array'
.rdata$r:0000C65C ??_R2_Generic_error_category@std@@8 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8
.rdata$r:0000C65C                                         ; DATA XREF: .rdata$r:0000C658o
.rdata$r:0000C65C                                         ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000C660                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000C664                 db    0
.rdata$r:0000C665                 align 4
.rdata$r:0000C665 _rdata$r        ends
.rdata$r:0000C665
.rdata$r:0000C668 ; ===========================================================================
.rdata$r:0000C668
.rdata$r:0000C668 ; Segment type: Pure data
.rdata$r:0000C668 ; Segment permissions: Read
.rdata$r:0000C668 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000C668                 assume cs:_rdata$r
.rdata$r:0000C668                 ;org 0C668h
.rdata$r:0000C668 ; COMDAT (pick any)
.rdata$r:0000C668                 public ??_R1A@?0A@EA@_Generic_error_category@std@@8
.rdata$r:0000C668 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000C668 ??_R1A@?0A@EA@_Generic_error_category@std@@8 dd offset ??_R0?AV_Generic_error_category@std@@@8
.rdata$r:0000C668                                         ; DATA XREF: .rdata$r:std::_Generic_error_category::`RTTI Base Class Array'o
.rdata$r:0000C668                                         ; .rdata$r:0000C6D8o ...
.rdata$r:0000C668                                         ; std::_Generic_error_category `RTTI Type Descriptor'
.rdata$r:0000C66C                 db    1
.rdata$r:0000C66D                 db    0
.rdata$r:0000C66E                 db    0
.rdata$r:0000C66F                 db    0
.rdata$r:0000C670                 db    0
.rdata$r:0000C671                 db    0
.rdata$r:0000C672                 db    0
.rdata$r:0000C673                 db    0
.rdata$r:0000C674                 db 0FFh
.rdata$r:0000C675                 db 0FFh
.rdata$r:0000C676                 db 0FFh
.rdata$r:0000C677                 db 0FFh
.rdata$r:0000C678                 db    0
.rdata$r:0000C679                 db    0
.rdata$r:0000C67A                 db    0
.rdata$r:0000C67B                 db    0
.rdata$r:0000C67C                 db  40h ; @
.rdata$r:0000C67D                 db    0
.rdata$r:0000C67E                 db    0
.rdata$r:0000C67F                 db    0
.rdata$r:0000C680                 dd offset ??_R3_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000C680 _rdata$r        ends
.rdata$r:0000C680
.rdata$r:0000C684 ; ===========================================================================
.rdata$r:0000C684
.rdata$r:0000C684 ; Segment type: Pure data
.rdata$r:0000C684 ; Segment permissions: Read
.rdata$r:0000C684 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000C684                 assume cs:_rdata$r
.rdata$r:0000C684                 ;org 0C684h
.rdata$r:0000C684 ; COMDAT (pick any)
.rdata$r:0000C684                 public ??_R4_Iostream_error_category@std@@6B@
.rdata$r:0000C684 ; const std::_Iostream_error_category::`RTTI Complete Object Locator'
.rdata$r:0000C684 ??_R4_Iostream_error_category@std@@6B@ db    0
.rdata$r:0000C684                                         ; DATA XREF: .rdata:0000AF10o
.rdata$r:0000C685                 db    0
.rdata$r:0000C686                 db    0
.rdata$r:0000C687                 db    0
.rdata$r:0000C688                 db    0
.rdata$r:0000C689                 db    0
.rdata$r:0000C68A                 db    0
.rdata$r:0000C68B                 db    0
.rdata$r:0000C68C                 db    0
.rdata$r:0000C68D                 db    0
.rdata$r:0000C68E                 db    0
.rdata$r:0000C68F                 db    0
.rdata$r:0000C690                 dd offset ??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category `RTTI Type Descriptor'
.rdata$r:0000C694                 dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000C694 _rdata$r        ends
.rdata$r:0000C694
.data$r:0000C698 ; ===========================================================================
.data$r:0000C698
.data$r:0000C698 ; Segment type: Pure data
.data$r:0000C698 ; Segment permissions: Read/Write
.data$r:0000C698 _data$r         segment dword public 'DATA' use32
.data$r:0000C698                 assume cs:_data$r
.data$r:0000C698                 ;org 0C698h
.data$r:0000C698 ; COMDAT (pick any)
.data$r:0000C698                 public ??_R0?AV_Iostream_error_category@std@@@8
.data$r:0000C698 ; class std::_Iostream_error_category `RTTI Type Descriptor'
.data$r:0000C698 ??_R0?AV_Iostream_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:0000C698                                         ; DATA XREF: .rdata$r:0000C690o
.data$r:0000C698                                         ; .rdata$r:std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:0000C698                                         ; const type_info::`vftable'
.data$r:0000C69C                 align 10h
.data$r:0000C6A0 a_?av_iostream_ db '.?AV_Iostream_error_category@std@@',0
.data$r:0000C6C3                 align 4
.data$r:0000C6C3 _data$r         ends
.data$r:0000C6C3
.rdata$r:0000C6C4 ; ===========================================================================
.rdata$r:0000C6C4
.rdata$r:0000C6C4 ; Segment type: Pure data
.rdata$r:0000C6C4 ; Segment permissions: Read
.rdata$r:0000C6C4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000C6C4                 assume cs:_rdata$r
.rdata$r:0000C6C4                 ;org 0C6C4h
.rdata$r:0000C6C4 ; COMDAT (pick any)
.rdata$r:0000C6C4                 public ??_R3_Iostream_error_category@std@@8
.rdata$r:0000C6C4 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000C6C4 ??_R3_Iostream_error_category@std@@8 db    0
.rdata$r:0000C6C4                                         ; DATA XREF: .rdata$r:0000C694o
.rdata$r:0000C6C4                                         ; .rdata$r:0000C6FCo
.rdata$r:0000C6C5                 db    0
.rdata$r:0000C6C6                 db    0
.rdata$r:0000C6C7                 db    0
.rdata$r:0000C6C8                 db    0
.rdata$r:0000C6C9                 db    0
.rdata$r:0000C6CA                 db    0
.rdata$r:0000C6CB                 db    0
.rdata$r:0000C6CC                 db    3
.rdata$r:0000C6CD                 db    0
.rdata$r:0000C6CE                 db    0
.rdata$r:0000C6CF                 db    0
.rdata$r:0000C6D0                 dd offset ??_R2_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
.rdata$r:0000C6D0 _rdata$r        ends
.rdata$r:0000C6D0
.rdata$r:0000C6D4 ; ===========================================================================
.rdata$r:0000C6D4
.rdata$r:0000C6D4 ; Segment type: Pure data
.rdata$r:0000C6D4 ; Segment permissions: Read
.rdata$r:0000C6D4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000C6D4                 assume cs:_rdata$r
.rdata$r:0000C6D4                 ;org 0C6D4h
.rdata$r:0000C6D4 ; COMDAT (pick any)
.rdata$r:0000C6D4                 public ??_R2_Iostream_error_category@std@@8
.rdata$r:0000C6D4 ; std::_Iostream_error_category::`RTTI Base Class Array'
.rdata$r:0000C6D4 ??_R2_Iostream_error_category@std@@8 dd offset ??_R1A@?0A@EA@_Iostream_error_category@std@@8
.rdata$r:0000C6D4                                         ; DATA XREF: .rdata$r:0000C6D0o
.rdata$r:0000C6D4                                         ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000C6D8                 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000C6DC                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000C6E0                 db    0
.rdata$r:0000C6E1                 align 4
.rdata$r:0000C6E1 _rdata$r        ends
.rdata$r:0000C6E1
.rdata$r:0000C6E4 ; ===========================================================================
.rdata$r:0000C6E4
.rdata$r:0000C6E4 ; Segment type: Pure data
.rdata$r:0000C6E4 ; Segment permissions: Read
.rdata$r:0000C6E4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000C6E4                 assume cs:_rdata$r
.rdata$r:0000C6E4                 ;org 0C6E4h
.rdata$r:0000C6E4 ; COMDAT (pick any)
.rdata$r:0000C6E4                 public ??_R1A@?0A@EA@_Iostream_error_category@std@@8
.rdata$r:0000C6E4 ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000C6E4 ??_R1A@?0A@EA@_Iostream_error_category@std@@8 dd offset ??_R0?AV_Iostream_error_category@std@@@8
.rdata$r:0000C6E4                                         ; DATA XREF: .rdata$r:std::_Iostream_error_category::`RTTI Base Class Array'o
.rdata$r:0000C6E4                                         ; std::_Iostream_error_category `RTTI Type Descriptor'
.rdata$r:0000C6E8                 db    2
.rdata$r:0000C6E9                 db    0
.rdata$r:0000C6EA                 db    0
.rdata$r:0000C6EB                 db    0
.rdata$r:0000C6EC                 db    0
.rdata$r:0000C6ED                 db    0
.rdata$r:0000C6EE                 db    0
.rdata$r:0000C6EF                 db    0
.rdata$r:0000C6F0                 db 0FFh
.rdata$r:0000C6F1                 db 0FFh
.rdata$r:0000C6F2                 db 0FFh
.rdata$r:0000C6F3                 db 0FFh
.rdata$r:0000C6F4                 db    0
.rdata$r:0000C6F5                 db    0
.rdata$r:0000C6F6                 db    0
.rdata$r:0000C6F7                 db    0
.rdata$r:0000C6F8                 db  40h ; @
.rdata$r:0000C6F9                 db    0
.rdata$r:0000C6FA                 db    0
.rdata$r:0000C6FB                 db    0
.rdata$r:0000C6FC                 dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000C6FC _rdata$r        ends
.rdata$r:0000C6FC
.rdata$r:0000C700 ; ===========================================================================
.rdata$r:0000C700
.rdata$r:0000C700 ; Segment type: Pure data
.rdata$r:0000C700 ; Segment permissions: Read
.rdata$r:0000C700 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000C700                 assume cs:_rdata$r
.rdata$r:0000C700                 ;org 0C700h
.rdata$r:0000C700 ; COMDAT (pick any)
.rdata$r:0000C700                 public ??_R4_System_error_category@std@@6B@
.rdata$r:0000C700 ; const std::_System_error_category::`RTTI Complete Object Locator'
.rdata$r:0000C700 ??_R4_System_error_category@std@@6B@ db    0 ; DATA XREF: .rdata:0000AF50o
.rdata$r:0000C701                 db    0
.rdata$r:0000C702                 db    0
.rdata$r:0000C703                 db    0
.rdata$r:0000C704                 db    0
.rdata$r:0000C705                 db    0
.rdata$r:0000C706                 db    0
.rdata$r:0000C707                 db    0
.rdata$r:0000C708                 db    0
.rdata$r:0000C709                 db    0
.rdata$r:0000C70A                 db    0
.rdata$r:0000C70B                 db    0
.rdata$r:0000C70C                 dd offset ??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category `RTTI Type Descriptor'
.rdata$r:0000C710                 dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000C710 _rdata$r        ends
.rdata$r:0000C710
.data$r:0000C714 ; ===========================================================================
.data$r:0000C714
.data$r:0000C714 ; Segment type: Pure data
.data$r:0000C714 ; Segment permissions: Read/Write
.data$r:0000C714 _data$r         segment dword public 'DATA' use32
.data$r:0000C714                 assume cs:_data$r
.data$r:0000C714                 ;org 0C714h
.data$r:0000C714 ; COMDAT (pick any)
.data$r:0000C714                 public ??_R0?AV_System_error_category@std@@@8
.data$r:0000C714 ; class std::_System_error_category `RTTI Type Descriptor'
.data$r:0000C714 ??_R0?AV_System_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:0000C714                                         ; DATA XREF: .rdata$r:0000C70Co
.data$r:0000C714                                         ; .rdata$r:std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:0000C714                                         ; const type_info::`vftable'
.data$r:0000C718                 db    0
.data$r:0000C719                 db    0
.data$r:0000C71A                 db    0
.data$r:0000C71B                 db    0
.data$r:0000C71C                 db  2Eh ; .
.data$r:0000C71D                 db  3Fh ; ?
.data$r:0000C71E                 db  41h ; A
.data$r:0000C71F                 db  56h ; V
.data$r:0000C720                 db  5Fh ; _
.data$r:0000C721                 db  53h ; S
.data$r:0000C722                 db  79h ; y
.data$r:0000C723                 db  73h ; s
.data$r:0000C724                 db  74h ; t
.data$r:0000C725                 db  65h ; e
.data$r:0000C726                 db  6Dh ; m
.data$r:0000C727                 db  5Fh ; _
.data$r:0000C728                 db  65h ; e
.data$r:0000C729                 db  72h ; r
.data$r:0000C72A                 db  72h ; r
.data$r:0000C72B                 db  6Fh ; o
.data$r:0000C72C                 db  72h ; r
.data$r:0000C72D                 db  5Fh ; _
.data$r:0000C72E                 db  63h ; c
.data$r:0000C72F                 db  61h ; a
.data$r:0000C730                 db  74h ; t
.data$r:0000C731                 db  65h ; e
.data$r:0000C732                 db  67h ; g
.data$r:0000C733                 db  6Fh ; o
.data$r:0000C734                 db  72h ; r
.data$r:0000C735                 db  79h ; y
.data$r:0000C736                 db  40h ; @
.data$r:0000C737                 db  73h ; s
.data$r:0000C738                 db  74h ; t
.data$r:0000C739                 db  64h ; d
.data$r:0000C73A                 db  40h ; @
.data$r:0000C73B                 db  40h ; @
.data$r:0000C73C                 db    0
.data$r:0000C73D                 align 10h
.data$r:0000C73D _data$r         ends
.data$r:0000C73D
.rdata$r:0000C740 ; ===========================================================================
.rdata$r:0000C740
.rdata$r:0000C740 ; Segment type: Pure data
.rdata$r:0000C740 ; Segment permissions: Read
.rdata$r:0000C740 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000C740                 assume cs:_rdata$r
.rdata$r:0000C740                 ;org 0C740h
.rdata$r:0000C740 ; COMDAT (pick any)
.rdata$r:0000C740                 public ??_R3_System_error_category@std@@8
.rdata$r:0000C740 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000C740 ??_R3_System_error_category@std@@8 db    0 ; DATA XREF: .rdata$r:0000C710o
.rdata$r:0000C740                                         ; .rdata$r:0000C778o
.rdata$r:0000C741                 db    0
.rdata$r:0000C742                 db    0
.rdata$r:0000C743                 db    0
.rdata$r:0000C744                 db    0
.rdata$r:0000C745                 db    0
.rdata$r:0000C746                 db    0
.rdata$r:0000C747                 db    0
.rdata$r:0000C748                 db    3
.rdata$r:0000C749                 db    0
.rdata$r:0000C74A                 db    0
.rdata$r:0000C74B                 db    0
.rdata$r:0000C74C                 dd offset ??_R2_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
.rdata$r:0000C74C _rdata$r        ends
.rdata$r:0000C74C
.rdata$r:0000C750 ; ===========================================================================
.rdata$r:0000C750
.rdata$r:0000C750 ; Segment type: Pure data
.rdata$r:0000C750 ; Segment permissions: Read
.rdata$r:0000C750 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000C750                 assume cs:_rdata$r
.rdata$r:0000C750                 ;org 0C750h
.rdata$r:0000C750 ; COMDAT (pick any)
.rdata$r:0000C750                 public ??_R2_System_error_category@std@@8
.rdata$r:0000C750 ; std::_System_error_category::`RTTI Base Class Array'
.rdata$r:0000C750 ??_R2_System_error_category@std@@8 dd offset ??_R1A@?0A@EA@_System_error_category@std@@8
.rdata$r:0000C750                                         ; DATA XREF: .rdata$r:0000C74Co
.rdata$r:0000C750                                         ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000C754                 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000C758                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000C75C                 db    0
.rdata$r:0000C75D                 align 10h
.rdata$r:0000C75D _rdata$r        ends
.rdata$r:0000C75D
.rdata$r:0000C760 ; ===========================================================================
.rdata$r:0000C760
.rdata$r:0000C760 ; Segment type: Pure data
.rdata$r:0000C760 ; Segment permissions: Read
.rdata$r:0000C760 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000C760                 assume cs:_rdata$r
.rdata$r:0000C760                 ;org 0C760h
.rdata$r:0000C760 ; COMDAT (pick any)
.rdata$r:0000C760                 public ??_R1A@?0A@EA@_System_error_category@std@@8
.rdata$r:0000C760 ; std::_System_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000C760 ??_R1A@?0A@EA@_System_error_category@std@@8 dd offset ??_R0?AV_System_error_category@std@@@8
.rdata$r:0000C760                                         ; DATA XREF: .rdata$r:std::_System_error_category::`RTTI Base Class Array'o
.rdata$r:0000C760                                         ; std::_System_error_category `RTTI Type Descriptor'
.rdata$r:0000C764                 db    2
.rdata$r:0000C765                 db    0
.rdata$r:0000C766                 db    0
.rdata$r:0000C767                 db    0
.rdata$r:0000C768                 db    0
.rdata$r:0000C769                 db    0
.rdata$r:0000C76A                 db    0
.rdata$r:0000C76B                 db    0
.rdata$r:0000C76C                 db 0FFh
.rdata$r:0000C76D                 db 0FFh
.rdata$r:0000C76E                 db 0FFh
.rdata$r:0000C76F                 db 0FFh
.rdata$r:0000C770                 db    0
.rdata$r:0000C771                 db    0
.rdata$r:0000C772                 db    0
.rdata$r:0000C773                 db    0
.rdata$r:0000C774                 db  40h ; @
.rdata$r:0000C775                 db    0
.rdata$r:0000C776                 db    0
.rdata$r:0000C777                 db    0
.rdata$r:0000C778                 dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000C778 _rdata$r        ends
.rdata$r:0000C778
.rdata$r:0000C77C ; ===========================================================================
.rdata$r:0000C77C
.rdata$r:0000C77C ; Segment type: Pure data
.rdata$r:0000C77C ; Segment permissions: Read
.rdata$r:0000C77C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000C77C                 assume cs:_rdata$r
.rdata$r:0000C77C                 ;org 0C77Ch
.rdata$r:0000C77C ; COMDAT (pick any)
.rdata$r:0000C77C                 public ??_R4Window@@6B@
.rdata$r:0000C77C ; const Window::`RTTI Complete Object Locator'
.rdata$r:0000C77C ??_R4Window@@6B@ db    0                ; DATA XREF: .rdata:0000AF88o
.rdata$r:0000C77D                 db    0
.rdata$r:0000C77E                 db    0
.rdata$r:0000C77F                 db    0
.rdata$r:0000C780                 db    0
.rdata$r:0000C781                 db    0
.rdata$r:0000C782                 db    0
.rdata$r:0000C783                 db    0
.rdata$r:0000C784                 db    0
.rdata$r:0000C785                 db    0
.rdata$r:0000C786                 db    0
.rdata$r:0000C787                 db    0
.rdata$r:0000C788                 dd offset ??_R0?AVWindow@@@8 ; Window `RTTI Type Descriptor'
.rdata$r:0000C78C                 dd offset ??_R3Window@@8 ; Window::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000C78C _rdata$r        ends
.rdata$r:0000C78C
.rdata:0000C790 ; ===========================================================================
.rdata:0000C790
.rdata:0000C790 ; Segment type: Pure data
.rdata:0000C790 ; Segment permissions: Read
.rdata:0000C790 _rdata          segment dword public 'DATA' use32
.rdata:0000C790                 assume cs:_rdata
.rdata:0000C790                 ;org 0C790h
.rdata:0000C790 ; COMDAT (pick any)
.rdata:0000C790                 public __real@3f800000
.rdata:0000C790 __real@3f800000 dd 3F800000h            ; DATA XREF: std::_Hash<std::_Umap_traits<Buffer *,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *,std::_Uhash_compare<Buffer *,std::hash<Buffer *>,std::equal_to<Buffer *>>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>,0>>::_Hash<std::_Umap_traits<Buffer *,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *,std::_Uhash_compare<Buffer *,std::hash<Buffer *>,std::equal_to<Buffer *>>,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>,0>>(std::_Uhash_compare<Buffer *,std::hash<Buffer *>,std::equal_to<Buffer *>> const &,std::allocator<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>> const &)+69r
.rdata:0000C790 _rdata          ends
.rdata:0000C790
.CRT$XCU:0000C794 ; ===========================================================================
.CRT$XCU:0000C794
.CRT$XCU:0000C794 ; Segment type: Pure data
.CRT$XCU:0000C794 ; Segment permissions: Read
.CRT$XCU:0000C794 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0000C794                 assume cs:_CRT$XCU
.CRT$XCU:0000C794                 ;org 0C794h
.CRT$XCU:0000C794 _piecewise_construct$initializer$ dd offset ??__Epiecewise_construct@std@@YAXXZ ; std::`dynamic initializer for 'piecewise_construct''(void)
.CRT$XCU:0000C798 _allocator_arg$initializer$ dd offset ??__Eallocator_arg@std@@YAXXZ ; std::`dynamic initializer for 'allocator_arg''(void)
.CRT$XCU:0000C79C _ignore$initializer$ dd offset ??__Eignore@std@@YAXXZ ; std::`dynamic initializer for 'ignore''(void)
.CRT$XCU:0000C7A0 __Tuple_alloc$initializer$ dd offset ??__E_Tuple_alloc@std@@YAXXZ ; std::`dynamic initializer for '_Tuple_alloc''(void)
.CRT$XCU:0000C7A0 _CRT$XCU        ends
.CRT$XCU:0000C7A0
.CRT$XCU:0000C7A4 ; ===========================================================================
.CRT$XCU:0000C7A4
.CRT$XCU:0000C7A4 ; Segment type: Pure data
.CRT$XCU:0000C7A4 ; Segment permissions: Read
.CRT$XCU:0000C7A4 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0000C7A4                 assume cs:_CRT$XCU
.CRT$XCU:0000C7A4                 ;org 0C7A4h
.CRT$XCU:0000C7A4 ; COMDAT (pick associative to section at AF74)
.CRT$XCU:0000C7A4 ; public: static void (__cdecl *std::_Error_objects<int>::_Generic_object$initializer$)(void)
.CRT$XCU:0000C7A4 ?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
.CRT$XCU:0000C7A4 _CRT$XCU        ends
.CRT$XCU:0000C7A4
.CRT$XCU:0000C7A8 ; ===========================================================================
.CRT$XCU:0000C7A8
.CRT$XCU:0000C7A8 ; Segment type: Pure data
.CRT$XCU:0000C7A8 ; Segment permissions: Read
.CRT$XCU:0000C7A8 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0000C7A8                 assume cs:_CRT$XCU
.CRT$XCU:0000C7A8                 ;org 0C7A8h
.CRT$XCU:0000C7A8 ; COMDAT (pick associative to section at AF78)
.CRT$XCU:0000C7A8 ; public: static void (__cdecl *std::_Error_objects<int>::_Iostream_object$initializer$)(void)
.CRT$XCU:0000C7A8 ?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
.CRT$XCU:0000C7A8 _CRT$XCU        ends
.CRT$XCU:0000C7A8
.CRT$XCU:0000C7AC ; ===========================================================================
.CRT$XCU:0000C7AC
.CRT$XCU:0000C7AC ; Segment type: Pure data
.CRT$XCU:0000C7AC ; Segment permissions: Read
.CRT$XCU:0000C7AC _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0000C7AC                 assume cs:_CRT$XCU
.CRT$XCU:0000C7AC                 ;org 0C7ACh
.CRT$XCU:0000C7AC ; COMDAT (pick associative to section at AF7C)
.CRT$XCU:0000C7AC ; public: static void (__cdecl *std::_Error_objects<int>::_System_object$initializer$)(void)
.CRT$XCU:0000C7AC ?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)
.CRT$XCU:0000C7AC _CRT$XCU        ends
.CRT$XCU:0000C7AC
.CRT$XCU:0000C7B0 ; ===========================================================================
.CRT$XCU:0000C7B0
.CRT$XCU:0000C7B0 ; Segment type: Pure data
.CRT$XCU:0000C7B0 ; Segment permissions: Read
.CRT$XCU:0000C7B0 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0000C7B0                 assume cs:_CRT$XCU
.CRT$XCU:0000C7B0                 ;org 0C7B0h
.CRT$XCU:0000C7B0 ; COMDAT (pick associative to section at AF80)
.CRT$XCU:0000C7B0 ; public: static void (__cdecl *std::num_put<char, class std::back_insert_iterator<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>::id$initializer$)(void)
.CRT$XCU:0000C7B0 ?id$initializer$@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2P6AXXZA dd offset ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)
.CRT$XCU:0000C7B0 _CRT$XCU        ends
.CRT$XCU:0000C7B0
.CRT$XCU:0000C7B4 ; ===========================================================================
.CRT$XCU:0000C7B4
.CRT$XCU:0000C7B4 ; Segment type: Pure data
.CRT$XCU:0000C7B4 ; Segment permissions: Read
.CRT$XCU:0000C7B4 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0000C7B4                 assume cs:_CRT$XCU
.CRT$XCU:0000C7B4                 ;org 0C7B4h
.CRT$XCU:0000C7B4 ; COMDAT (pick associative to section at AF84)
.CRT$XCU:0000C7B4 ; public: static void (__cdecl *std::num_put<wchar_t, class std::back_insert_iterator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::id$initializer$)(void)
.CRT$XCU:0000C7B4 ?id$initializer$@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2P6AXXZA dd offset ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)
.CRT$XCU:0000C7B4 _CRT$XCU        ends
.CRT$XCU:0000C7B4
.CRT$XCU:0000C7B8 ; ===========================================================================
.CRT$XCU:0000C7B8
.CRT$XCU:0000C7B8 ; Segment type: Pure data
.CRT$XCU:0000C7B8 ; Segment permissions: Read
.CRT$XCU:0000C7B8 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0000C7B8                 assume cs:_CRT$XCU
.CRT$XCU:0000C7B8                 ;org 0C7B8h
.CRT$XCU:0000C7B8 ; COMDAT (pick associative to section at B300)
.CRT$XCU:0000C7B8 ; public: static void (__cdecl *std::numpunct<char>::id$initializer$)(void)
.CRT$XCU:0000C7B8 ?id$initializer$@?$numpunct@D@std@@2P6AXXZA dd offset ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::numpunct<char>::id''(void)
.CRT$XCU:0000C7B8 _CRT$XCU        ends
.CRT$XCU:0000C7B8
.CRT$XCU:0000C7BC ; ===========================================================================
.CRT$XCU:0000C7BC
.CRT$XCU:0000C7BC ; Segment type: Pure data
.CRT$XCU:0000C7BC ; Segment permissions: Read
.CRT$XCU:0000C7BC _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0000C7BC                 assume cs:_CRT$XCU
.CRT$XCU:0000C7BC                 ;org 0C7BCh
.CRT$XCU:0000C7BC ; COMDAT (pick associative to section at B304)
.CRT$XCU:0000C7BC ; public: static void (__cdecl *std::numpunct<wchar_t>::id$initializer$)(void)
.CRT$XCU:0000C7BC ?id$initializer$@?$numpunct@_W@std@@2P6AXXZA dd offset ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::numpunct<wchar_t>::id''(void)
.CRT$XCU:0000C7BC _CRT$XCU        ends
.CRT$XCU:0000C7BC
UNDEF:0000C7C0 ; ===========================================================================
UNDEF:0000C7C0
UNDEF:0000C7C0 ; Segment type: Externs
UNDEF:0000C7C0 ; UNDEF
UNDEF:0000C7C0                 extrn __purecall:near   ; DATA XREF: .rdata:0000AEC8o
UNDEF:0000C7C0                                         ; .rdata:0000AECCo ...
UNDEF:0000C7C4 ; void *__cdecl operator new(unsigned int)
UNDEF:0000C7C4                 extrn ??2@YAPAXI@Z:near ; CODE XREF: ScintillaCtrls::createSintilla(HWND__ *)+33p
UNDEF:0000C7C4                                         ; std::_Allocate<char>(uint,char *)+1Dp ...
UNDEF:0000C7C8 ; void __cdecl operator delete(void *)
UNDEF:0000C7C8                 extrn ??3@YAXPAX@Z:near ; CODE XREF: __unwindfunclet$?createSintilla@ScintillaCtrls@@QAEPAUHWND__@@PAU2@@Z$0+4p
UNDEF:0000C7C8                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::`scalar deleting destructor'(uint)+1Bp ...
UNDEF:0000C7CC ; int __cdecl atexit(void (__cdecl *)())
UNDEF:0000C7CC                 extrn _atexit:near      ; CODE XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+12p
UNDEF:0000C7CC                                         ; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+12p ...
UNDEF:0000C7D0                 extrn __invalid_parameter:near
UNDEF:0000C7D0                                         ; CODE XREF: std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>::operator==(std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>> const &)+8Cp
UNDEF:0000C7D0                                         ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::operator==(std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const &)+8Cp ...
UNDEF:0000C7D4 ; _DWORD __thiscall std::_Lockit::_Lockit(std::_Lockit *__hidden this, int)
UNDEF:0000C7D4                 extrn ??0_Lockit@std@@QAE@H@Z:near
UNDEF:0000C7D4                                         ; CODE XREF: std::_Iterator_base12::~_Iterator_base12(void)+2Dp
UNDEF:0000C7D4                                         ; std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+55p ...
UNDEF:0000C7D8 ; _DWORD __thiscall std::_Lockit::~_Lockit(std::_Lockit *__hidden this)
UNDEF:0000C7D8                 extrn ??1_Lockit@std@@QAE@XZ:near
UNDEF:0000C7D8                                         ; CODE XREF: std::_Iterator_base12::~_Iterator_base12(void)+4Bp
UNDEF:0000C7D8                                         ; __unwindfunclet$??1_Iterator_base12@std@@QAE@XZ$0+3j ...
UNDEF:0000C7DC                 extrn __hypot:near      ; CODE XREF: _hypot+1Dp
UNDEF:0000C7E0 ; void *__cdecl memmove(void *Dst, const void *Src, size_t Size)
UNDEF:0000C7E0                 extrn _memmove:near     ; CODE XREF: std::_Move<ScintillaEditView * *,ScintillaEditView * *>(ScintillaEditView * *,ScintillaEditView * *,ScintillaEditView * *,std::_Scalar_ptr_iterator_tag)+1Fp
UNDEF:0000C7E0                                         ; std::_Uninit_move<ScintillaEditView *,ScintillaEditView *,ScintillaEditView *>(ScintillaEditView * *,ScintillaEditView * *,ScintillaEditView * *,std::_Wrap_alloc<std::allocator<ScintillaEditView *>> &,ScintillaEditView * *,std::_Scalar_ptr_iterator_tag)+4Fp ...
UNDEF:0000C7E4 ; void *__cdecl memcpy(void *Dst, const void *Src, size_t Size)
UNDEF:0000C7E4                 extrn _memcpy:near      ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+1Ep
UNDEF:0000C7E4                                         ; _wmemcpy+11p
UNDEF:0000C7E8 ; size_t __cdecl strlen(const char *Str)
UNDEF:0000C7E8                 extrn _strlen:near      ; CODE XREF: std::char_traits<char>::length(char const *)+1Bp
UNDEF:0000C7EC ; void __cdecl operator delete[](void *)
UNDEF:0000C7EC                 extrn ??_V@YAXPAX@Z:near
UNDEF:0000C7EC                                         ; CODE XREF: ScintillaEditView::~ScintillaEditView(void)+14Dp
UNDEF:0000C7F0                 extrn __CrtDbgReportW:near
UNDEF:0000C7F0                                         ; CODE XREF: std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>>::operator==(std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,Style>>>> const &)+68p
UNDEF:0000C7F0                                         ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>>::operator==(std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<Buffer * const,std::unordered_map<int,Style,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const,Style>>> *>>>> const &)+68p ...
UNDEF:0000C7F4 ; void __cdecl std::_Debug_message(const wchar_t *, const wchar_t *, unsigned int)
UNDEF:0000C7F4                 extrn ?_Debug_message@std@@YAXPB_W0I@Z:near
UNDEF:0000C7F4                                         ; CODE XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+16p
UNDEF:0000C7F4                                         ; std::_Debug_pointer<ScintillaEditView *>(ScintillaEditView * *,wchar_t const *,uint)+16p ...
UNDEF:0000C7F8 ; void __cdecl std::_Xbad_alloc()
UNDEF:0000C7F8                 extrn ?_Xbad_alloc@std@@YAXXZ:near
UNDEF:0000C7F8                                         ; CODE XREF: std::_Allocate<char>(uint,char *):loc_115Ep
UNDEF:0000C7F8                                         ; std::_Allocate<ScintillaEditView *>(uint,ScintillaEditView * *):loc_11A0p ...
UNDEF:0000C7FC ; void __cdecl std::_Xlength_error(const char *)
UNDEF:0000C7FC                 extrn ?_Xlength_error@std@@YAXPBD@Z:near
UNDEF:0000C7FC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+Cp
UNDEF:0000C7FC                                         ; std::vector<ScintillaEditView *,std::allocator<ScintillaEditView *>>::_Xlen(void)+Cp ...
UNDEF:0000C800 ; void __cdecl std::_Xout_of_range(const char *)
UNDEF:0000C800                 extrn ?_Xout_of_range@std@@YAXPBD@Z:near
UNDEF:0000C800                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+Cp
UNDEF:0000C804 ; BOOL __stdcall FreeLibrary(HMODULE hLibModule)
UNDEF:0000C804                 extrn __imp__FreeLibrary@4:near
UNDEF:0000C804                                         ; CODE XREF: ScintillaEditView::~ScintillaEditView(void)+61p
UNDEF:0000C804                                         ; DATA XREF: ScintillaEditView::~ScintillaEditView(void)+61r
UNDEF:0000C808 ; BOOL __stdcall DestroyWindow(HWND hWnd)
UNDEF:0000C808                 extrn __imp__DestroyWindow@4:near
UNDEF:0000C808                                         ; CODE XREF: ScintillaEditView::destroy(void)+Ep
UNDEF:0000C808                                         ; DATA XREF: ScintillaEditView::destroy(void)+Er
UNDEF:0000C80C ; BOOL __stdcall ShowWindow(HWND hWnd, int nCmdShow)
UNDEF:0000C80C                 extrn __imp__ShowWindow@8:near
UNDEF:0000C80C                                         ; CODE XREF: Window::display(bool)+2Cp
UNDEF:0000C80C                                         ; DATA XREF: Window::display(bool)+2Cr
UNDEF:0000C810 ; BOOL __stdcall MoveWindow(HWND hWnd, int X, int Y, int nWidth, int nHeight, BOOL bRepaint)
UNDEF:0000C810                 extrn __imp__MoveWindow@24:near
UNDEF:0000C810                                         ; CODE XREF: Window::reSizeTo(tagRECT &)+2Bp
UNDEF:0000C810                                         ; Window::reSizeToWH(tagRECT &)+36p
UNDEF:0000C810                                         ; DATA XREF: ...
UNDEF:0000C814 ; BOOL __stdcall IsWindowVisible(HWND hWnd)
UNDEF:0000C814                 extrn __imp__IsWindowVisible@4:near
UNDEF:0000C814                                         ; CODE XREF: Window::getHeight(void)+2Bp
UNDEF:0000C814                                         ; Window::isVisible(void)+10p
UNDEF:0000C814                                         ; DATA XREF: ...
UNDEF:0000C818 ; BOOL __stdcall UpdateWindow(HWND hWnd)
UNDEF:0000C818                 extrn __imp__UpdateWindow@4:near
UNDEF:0000C818                                         ; CODE XREF: Window::redraw(bool)+27p
UNDEF:0000C818                                         ; DATA XREF: Window::redraw(bool)+27r
UNDEF:0000C81C ; BOOL __stdcall InvalidateRect(HWND hWnd, const RECT *lpRect, BOOL bErase)
UNDEF:0000C81C                 extrn __imp__InvalidateRect@12:near
UNDEF:0000C81C                                         ; CODE XREF: Window::redraw(bool)+12p
UNDEF:0000C81C                                         ; DATA XREF: Window::redraw(bool)+12r
UNDEF:0000C820 ; BOOL __stdcall GetClientRect(HWND hWnd, LPRECT lpRect)
UNDEF:0000C820                 extrn __imp__GetClientRect@8:near
UNDEF:0000C820                                         ; CODE XREF: Window::getClientRect(tagRECT &)+12p
UNDEF:0000C820                                         ; Window::getHeight(void)+1Ep ...
UNDEF:0000C824 ; BOOL __stdcall GetWindowRect(HWND hWnd, LPRECT lpRect)
UNDEF:0000C824                 extrn __imp__GetWindowRect@8:near
UNDEF:0000C824                                         ; CODE XREF: Window::getWindowRect(tagRECT &)+12p
UNDEF:0000C824                                         ; DATA XREF: Window::getWindowRect(tagRECT &)+12r
UNDEF:0000C828 ; public: virtual void * __thiscall std::error_category::`vector deleting destructor'(unsigned int)
UNDEF:0000C828                 extrn ??_Eerror_category@std@@UAEPAXI@Z:near ; weak
UNDEF:0000C828                                         ; DATA XREF: .rdata:const std::error_category::`vftable'o
UNDEF:0000C82C ; const char *__cdecl std::_Syserror_map(int)
UNDEF:0000C82C                 extrn ?_Syserror_map@std@@YAPBDH@Z:near
UNDEF:0000C82C                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+Bp
UNDEF:0000C82C                                         ; std::_Generic_error_category::message(int)+33p
UNDEF:0000C830 ; const char *__cdecl std::_Winerror_map(int)
UNDEF:0000C830                 extrn ?_Winerror_map@std@@YAPBDH@Z:near
UNDEF:0000C830                                         ; CODE XREF: std::_System_error_category::message(int)+33p
UNDEF:0000C834 ; public: virtual void * __thiscall std::_Generic_error_category::`vector deleting destructor'(unsigned int)
UNDEF:0000C834                 extrn ??_E_Generic_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:0000C834                                         ; DATA XREF: .rdata:const std::_Generic_error_category::`vftable'o
UNDEF:0000C838 ; public: virtual void * __thiscall std::_Iostream_error_category::`vector deleting destructor'(unsigned int)
UNDEF:0000C838                 extrn ??_E_Iostream_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:0000C838                                         ; DATA XREF: .rdata:const std::_Iostream_error_category::`vftable'o
UNDEF:0000C83C ; public: virtual void * __thiscall std::_System_error_category::`vector deleting destructor'(unsigned int)
UNDEF:0000C83C                 extrn ??_E_System_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:0000C83C                                         ; DATA XREF: .rdata:const std::_System_error_category::`vftable'o
UNDEF:0000C840 ; public: virtual void * __thiscall Window::`vector deleting destructor'(unsigned int)
UNDEF:0000C840                 extrn ??_EWindow@@UAEPAXI@Z:near ; weak
UNDEF:0000C840                                         ; DATA XREF: .rdata:const Window::`vftable'o
UNDEF:0000C844 ; public: virtual void __thiscall ScintillaEditView::init(struct HINSTANCE__ *, struct HWND__ *)
UNDEF:0000C844                 extrn ?init@ScintillaEditView@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z:near
UNDEF:0000C844                                         ; DATA XREF: .rdata:0000AFC4o
UNDEF:0000C848 ; public: virtual void * __thiscall ScintillaEditView::`vector deleting destructor'(unsigned int)
UNDEF:0000C848                 extrn ??_EScintillaEditView@@UAEPAXI@Z:near ; weak
UNDEF:0000C848                                         ; DATA XREF: .rdata:const ScintillaEditView::`vftable'o
UNDEF:0000C84C ; __fastcall __security_check_cookie(x)
UNDEF:0000C84C                 extrn @__security_check_cookie@4:near
UNDEF:0000C84C                                         ; CODE XREF: __ehhandler$?createSintilla@ScintillaCtrls@@QAEPAUHWND__@@PAU2@@Z+Cp
UNDEF:0000C84C                                         ; __ehhandler$?destroyScintilla@ScintillaCtrls@@QAE_NPAUHWND__@@@Z+Cp ...
UNDEF:0000C850 ; __stdcall _CxxThrowException(x, x)
UNDEF:0000C850                 extrn __CxxThrowException@8:near
UNDEF:0000C850                                         ; CODE XREF: __catch$??$_Uninit_fill_n@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@IV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@V12@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@IPBV10@AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@
UNDEF:0000C850                                         ; __catch$??$_Uninit_move@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@2@V12@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@0@PAV10@00AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVBuffer@@PAV?$unordered_map@HUStyle@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHUStyle@@@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@0@0U_Nonsc ...
UNDEF:0000C854                 extrn ___CxxFrameHandler3:near
UNDEF:0000C854                                         ; CODE XREF: __ehhandler$?createSintilla@ScintillaCtrls@@QAEPAUHWND__@@PAU2@@Z+16j
UNDEF:0000C854                                         ; __ehhandler$?destroyScintilla@ScintillaCtrls@@QAE_NPAUHWND__@@@Z+16j ...
UNDEF:0000C858 ; const type_info::`vftable'
UNDEF:0000C858                 extrn ??_7type_info@@6B@:near
UNDEF:0000C858                                         ; DATA XREF: .data$r:ScintillaEditView `RTTI Type Descriptor'o
UNDEF:0000C858                                         ; .data$r:Window `RTTI Type Descriptor'o ...
UNDEF:0000C85C ; HMODULE ScintillaEditView::_hLib
UNDEF:0000C85C                 extrn ?_hLib@ScintillaEditView@@1PAUHINSTANCE__@@A:near
UNDEF:0000C85C                                         ; DATA XREF: ScintillaEditView::~ScintillaEditView(void)+4Dr
UNDEF:0000C85C                                         ; ScintillaEditView::~ScintillaEditView(void)+5Ar
UNDEF:0000C860 ; protected: static int ScintillaEditView::_refCount
UNDEF:0000C860                 extrn ?_refCount@ScintillaEditView@@1HA:near
UNDEF:0000C860                                         ; DATA XREF: ScintillaEditView::ScintillaEditView(void)+79r
UNDEF:0000C860                                         ; ScintillaEditView::ScintillaEditView(void)+81w ...
UNDEF:0000C864                 extrn ___security_cookie:near
UNDEF:0000C864                                         ; DATA XREF: ScintillaCtrls::createSintilla(HWND__ *)+14r
UNDEF:0000C864                                         ; ScintillaCtrls::destroyScintilla(HWND__ *)+14r ...
UNDEF:0000C868                 extrn __fltused:near
UNDEF:0000C868
UNDEF:0000C868
UNDEF:0000C868                 end