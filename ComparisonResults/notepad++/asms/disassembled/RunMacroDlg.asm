.data:00000000 ;
.data:00000000 ; +-------------------------------------------------------------------------+
.data:00000000 ; |   This file has been generated by The Interactive Disassembler (IDA)    |
.data:00000000 ; |           Copyright (c) 2015 Hex-Rays, <support@hex-rays.com>           |
.data:00000000 ; |                      License info: 48-3677-7074-51                      |
.data:00000000 ; |             Michalis Polychronakis, Stony Brook University              |
.data:00000000 ; +-------------------------------------------------------------------------+
.data:00000000 ;
.data:00000000 ; Input MD5   : 248D1E2E5971A3AFBCD98FC812B1B60F
.data:00000000 ; Input CRC32 : 80973007
.data:00000000
.data:00000000 ; File Name   : C:\workspace\notepad-plus-plus-6.7.9.2\PowerEditor\visual.net\Unicode Debug\RunMacroDlg.obj
.data:00000000 ; Format      : COFF (X386MAGIC)
.data:00000000 ; includelib "uuid.lib"
.data:00000000 ; includelib "libcpmtd"
.data:00000000 ; must resolve: ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
.data:00000000 ; must resolve: ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
.data:00000000 ; must resolve: ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
.data:00000000 ; must resolve: ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
.data:00000000 ; must resolve: ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
.data:00000000 ; must resolve: ?id@?$numpunct@D@std@@2V0locale@2@A
.data:00000000 ; must resolve: ?id@?$numpunct@_W@std@@2V0locale@2@A
.data:00000000 ; includelib "LIBCMTD"
.data:00000000 ; includelib "OLDNAMES"
.data:00000000
.data:00000000                 include uni.inc ; see unicode subdir of ida for info on unicode
.data:00000000
.data:00000000                 .686p
.data:00000000                 .mmx
.data:00000000                 .model flat
.data:00000000
.data:00000000 ; ===========================================================================
.data:00000000
.data:00000000 ; Segment type: Pure data
.data:00000000 ; Segment permissions: Read/Write
.data:00000000 ; Segment alignment 'qword' can not be represented in assembly
.data:00000000 _data           segment para public 'DATA' use32
.data:00000000                 assume cs:_data
.data:00000000 _acTop_xpm      dd offset $SG143466     ; "12 12 56 1"
.data:00000004                 dd offset $SG143467     ; " \tc #FFFFFF"
.data:00000008                 dd offset $SG143468     ; ".\tc #8AB2E9"
.data:0000000C                 dd offset $SG143469     ; "+\tc #CCDCF6"
.data:00000010                 dd offset $SG143470     ; "@\tc #80ABEA"
.data:00000014                 dd offset $SG143471     ; "#\tc #7DA9E8"
.data:00000018                 dd offset $SG143472     ; "$\tc #C7DAF3"
.data:0000001C                 dd offset $SG143473     ; "%\tc #79A7E6"
.data:00000020                 dd offset $SG143474     ; "&\tc #ADC8EF"
.data:00000024                 dd offset $SG143475     ; "*\tc #87B0E8"
.data:00000028                 dd offset $SG143476     ; "=\tc #BBD2F0"
.data:0000002C                 dd offset $SG143477     ; "-\tc #6EA0E2"
.data:00000030                 dd offset $SG143478     ; ";\tc #A8C7EE"
.data:00000034                 dd offset $SG143479     ; ">\tc #A3C2ED"
.data:00000038                 dd offset $SG143480     ; ",\tc #75A4E3"
.data:0000003C                 dd offset $SG143481     ; "'\tc #A7C4EB"
.data:00000040                 dd offset $SG143482     ; ")\tc #6297E1"
.data:00000044                 dd offset $SG143483     ; "!\tc #A1C1EC"
.data:00000048                 dd offset $SG143484     ; "~\tc #92B7E8"
.data:0000004C                 dd offset $SG143485     ; "{\tc #99BBE9"
.data:00000050                 dd offset $SG143486     ; "]\tc #6197DD"
.data:00000054                 dd offset $SG143487     ; "^\tc #96B9E6"
.data:00000058                 dd offset $SG143488     ; "/\tc #538EDB"
.data:0000005C                 dd offset $SG143489     ; "(\tc #99BBEA"
.data:00000060                 dd offset $SG143490     ; "_\tc #80AAE3"
.data:00000064                 dd offset $SG143491     ; ":\tc #81ABE3"
.data:00000068                 dd offset $SG143492     ; "<\tc #8AB1E4"
.data:0000006C                 dd offset $SG143493     ; "[\tc #4B88D6"
.data:00000070                 dd offset $SG143494     ; "}\tc #4882D1"
.data:00000074                 dd offset $SG143495     ; "|\tc #4384D6"
.data:00000078                 dd offset $SG143496     ; "1\tc #90B5E7"
.data:0000007C                 dd offset $SG143497     ; "2\tc #74A3E0"
.data:00000080                 dd offset $SG143498     ; "3\tc #77A4E0"
.data:00000084                 dd offset $SG143499     ; "4\tc #81ABE2"
.data:00000088                 dd offset $SG143500     ; "5\tc #437FD3"
.data:0000008C                 dd offset $SG143501     ; "6\tc #7FA2DF"
.data:00000090                 dd offset $SG143502     ; "7\tc #3577D2"
.data:00000094                 dd offset $SG143503     ; "8\tc #87AFE4"
.data:00000098                 dd offset $SG143504     ; "9\tc #72A1DF"
.data:0000009C                 dd offset $SG143505     ; "0\tc #7CA9E1"
.data:000000A0                 dd offset $SG143506     ; "a\tc #3F7AD0"
.data:000000A4                 dd offset $SG143507     ; "b\tc #85A4DE"
.data:000000A8                 dd offset $SG143508     ; "c\tc #FBFCFE"
.data:000000AC                 dd offset $SG143509     ; "d\tc #236ECD"
.data:000000B0                 dd offset $SG143510     ; "e\tc #7EA8E1"
.data:000000B4                 dd offset $SG143511     ; "f\tc #79A6E0"
.data:000000B8                 dd offset $SG143512     ; "g\tc #3D77D0"
.data:000000BC                 dd offset $SG143513     ; "h\tc #87A4DC"
.data:000000C0                 dd offset $SG143514     ; "i\tc #1A62C9"
.data:000000C4                 dd offset $SG143515     ; "j\tc #75A3DF"
.data:000000C8                 dd offset $SG143516     ; "k\tc #3C74CF"
.data:000000CC                 dd offset $SG143517     ; "l\tc #8DA6DE"
.data:000000D0                 dd offset $SG143518     ; "m\tc #1859C4"
.data:000000D4                 dd offset $SG143519     ; "n\tc #3B71CC"
.data:000000D8                 dd offset $SG143520     ; "o\tc #8EA5DD"
.data:000000DC                 dd offset $SG143521     ; "p\tc #164EC0"
.data:000000E0                 dd offset $SG143522     ; "q\tc #92A7DD"
.data:000000E4                 dd offset $SG143523     ; "    .+      "
.data:000000E8                 dd offset $SG143524     ; "    @#$     "
.data:000000EC                 dd offset $SG143525     ; "    %&*=    "
.data:000000F0                 dd offset $SG143526     ; "    -;>,'   "
.data:000000F4                 dd offset $SG143527     ; "    )!~{]^  "
.data:000000F8                 dd offset $SG143528     ; "    /(_:<[} "
.data:000000FC                 dd offset $SG143529     ; "    |123456 "
.data:00000100                 dd offset $SG143530     ; "    7890abc "
.data:00000104                 dd offset $SG143531     ; "    defgh   "
.data:00000108                 dd offset $SG143532     ; "    ijkl    "
.data:0000010C                 dd offset $SG143533     ; "    mno     "
.data:00000110                 dd offset $SG143534     ; "    pq      "
.data:00000114                 align 8
.data:00000118 _acBottom_xpm   dd offset $SG143536     ; "12 12 54 1"
.data:0000011C                 dd offset $SG143537     ; " \tc #FFFFFF"
.data:00000120                 dd offset $SG143538     ; ".\tc #C4D7F3"
.data:00000124                 dd offset $SG143539     ; "+\tc #72A1E3"
.data:00000128                 dd offset $SG143540     ; "@\tc #C1D6F2"
.data:0000012C                 dd offset $SG143541     ; "#\tc #6397E1"
.data:00000130                 dd offset $SG143542     ; "$\tc #5990DD"
.data:00000134                 dd offset $SG143543     ; "%\tc #BBD2F0"
.data:00000138                 dd offset $SG143544     ; "&\tc #7AA6E5"
.data:0000013C                 dd offset $SG143545     ; "*\tc #9ABDEA"
.data:00000140                 dd offset $SG143546     ; "=\tc #4A87D9"
.data:00000144                 dd offset $SG143547     ; "-\tc #B1CAEE"
.data:00000148                 dd offset $SG143548     ; ";\tc #75A4E3"
.data:0000014C                 dd offset $SG143549     ; ">\tc #99BBE9"
.data:00000150                 dd offset $SG143550     ; ",\tc #95B9E8"
.data:00000154                 dd offset $SG143551     ; "'\tc #3A7CD4"
.data:00000158                 dd offset $SG143552     ; ")\tc #A9C6EC"
.data:0000015C                 dd offset $SG143553     ; "!\tc #71A0E0"
.data:00000160                 dd offset $SG143554     ; "~\tc #86AFE5"
.data:00000164                 dd offset $SG143555     ; "{\tc #8DB2E6"
.data:00000168                 dd offset $SG143556     ; "]\tc #2A72CF"
.data:0000016C                 dd offset $SG143557     ; "^\tc #73A0E0"
.data:00000170                 dd offset $SG143558     ; "/\tc #6B9DE0"
.data:00000174                 dd offset $SG143559     ; "(\tc #95B8E8"
.data:00000178                 dd offset $SG143560     ; "_\tc #81ABE3"
.data:0000017C                 dd offset $SG143561     ; ":\tc #72A1DF"
.data:00000180                 dd offset $SG143562     ; "<\tc #83ADE3"
.data:00000184                 dd offset $SG143563     ; "[\tc #1B65C9"
.data:00000188                 dd offset $SG143564     ; "}\tc #5F95DC"
.data:0000018C                 dd offset $SG143565     ; "|\tc #8BB3E5"
.data:00000190                 dd offset $SG143566     ; "1\tc #77A4E0"
.data:00000194                 dd offset $SG143567     ; "2\tc #679ADC"
.data:00000198                 dd offset $SG143568     ; "3\tc #7AA6E1"
.data:0000019C                 dd offset $SG143569     ; "4\tc #195CC6"
.data:000001A0                 dd offset $SG143570     ; "5\tc #FCFDFE"
.data:000001A4                 dd offset $SG143571     ; "6\tc #8DB2E4"
.data:000001A8                 dd offset $SG143572     ; "7\tc #4885D6"
.data:000001AC                 dd offset $SG143573     ; "8\tc #7CA9E1"
.data:000001B0                 dd offset $SG143574     ; "9\tc #6698DB"
.data:000001B4                 dd offset $SG143575     ; "0\tc #71A1DE"
.data:000001B8                 dd offset $SG143576     ; "a\tc #1752C0"
.data:000001BC                 dd offset $SG143577     ; "b\tc #88ABE0"
.data:000001C0                 dd offset $SG143578     ; "c\tc #3D77D0"
.data:000001C4                 dd offset $SG143579     ; "d\tc #6E9FDD"
.data:000001C8                 dd offset $SG143580     ; "e\tc #699BDC"
.data:000001CC                 dd offset $SG143581     ; "f\tc #1547BD"
.data:000001D0                 dd offset $SG143582     ; "g\tc #8DA6DE"
.data:000001D4                 dd offset $SG143583     ; "h\tc #376BC9"
.data:000001D8                 dd offset $SG143584     ; "i\tc #6295DA"
.data:000001DC                 dd offset $SG143585     ; "j\tc #1440B9"
.data:000001E0                 dd offset $SG143586     ; "k\tc #8DA0DB"
.data:000001E4                 dd offset $SG143587     ; "l\tc #315FC4"
.data:000001E8                 dd offset $SG143588     ; "m\tc #1339B7"
.data:000001EC                 dd offset $SG143589     ; "n\tc #909FDA"
.data:000001F0                 dd offset $SG143590     ; "o\tc #1233B4"
.data:000001F4                 dd offset $SG143591     ; "         .+ "
.data:000001F8                 dd offset $SG143592     ; "        @#$ "
.data:000001FC                 dd offset $SG143593     ; "       %&*= L"
.data:00000200                 dd offset $SG143594     ; "      -;>,' "
.data:00000204                 dd offset $SG143595     ; "     )!>~{] "
.data:00000208                 dd offset $SG143596     ; "    ^/(_:<[ "
.data:0000020C                 dd offset $SG143597     ; "    (}|1234 "
.data:00000210                 dd offset $SG143598     ; "    567890a "
.data:00000214                 dd offset $SG143599     ; "      bcdef "
.data:00000218                 dd offset $SG143600     ; "       ghij "
.data:0000021C                 dd offset $SG143601     ; "        klm "
.data:00000220                 dd offset $SG143602     ; "         no "
.data:00000224                 align 8
.data:00000228 _bookmark_xpm   dd offset $SG143604     ; "13 14 54 1"
.data:0000022C                 dd offset $SG143605     ; " \tc None"
.data:00000230                 dd offset $SG143606     ; ".\tc #545254"
.data:00000234                 dd offset $SG143607     ; "+\tc #3C3E3C"
.data:00000238                 dd offset $SG143608     ; "@\tc #646464"
.data:0000023C                 dd offset $SG143609     ; "#\tc #A4A4A4"
.data:00000240                 dd offset $SG143610     ; "$\tc #B7B8B7"
.data:00000244                 dd offset $SG143611     ; "%\tc #747284"
.data:00000248                 dd offset $SG143612     ; "&\tc #B4B2C4"
.data:0000024C                 dd offset $SG143613     ; "*\tc #DCD7E4"
.data:00000250                 dd offset $SG143614     ; "=\tc #1C1A1C"
.data:00000254                 dd offset $SG143615     ; "-\tc #403E58"
.data:00000258                 dd offset $SG143616     ; ";\tc #5C5A8C"
.data:0000025C                 dd offset $SG143617     ; ">\tc #7C7EAC"
.data:00000260                 dd offset $SG143618     ; ",\tc #7C8EBC"
.data:00000264                 dd offset $SG143619     ; "'\tc #242644"
.data:00000268                 dd offset $SG143620     ; ")\tc #282668"
.data:0000026C                 dd offset $SG143621     ; "!\tc #24367C"
.data:00000270                 dd offset $SG143622     ; "~\tc #244A84"
.data:00000274                 dd offset $SG143623     ; "{\tc #2C5098"
.data:00000278                 dd offset $SG143624     ; "]\tc #14162C"
.data:0000027C                 dd offset $SG143625     ; "^\tc #142E7C"
.data:00000280                 dd offset $SG143626     ; "/\tc #143789"
.data:00000284                 dd offset $SG143627     ; "(\tc #204990"
.data:00000288                 dd offset $SG143628     ; "_\tc #174091"
.data:0000028C                 dd offset $SG143629     ; ":\tc #0C0630"
.data:00000290                 dd offset $SG143630     ; "<\tc #24327C"
.data:00000294                 dd offset $SG143631     ; "[\tc #2450A0"
.data:00000298                 dd offset $SG143632     ; "}\tc #345DB4"
.data:0000029C                 dd offset $SG143633     ; "|\tc #3C68B8"
.data:000002A0                 dd offset $SG143634     ; "1\tc #141244"
.data:000002A4                 dd offset $SG143635     ; "2\tc #24428C"
.data:000002A8                 dd offset $SG143636     ; "3\tc #3462B9"
.data:000002AC                 dd offset $SG143637     ; "4\tc #4470C4"
.data:000002B0                 dd offset $SG143638     ; "5\tc #4C7FD6"
.data:000002B4                 dd offset $SG143639     ; "6\tc #4472CC"
.data:000002B8                 dd offset $SG143640     ; "7\tc #24224C"
.data:000002BC                 dd offset $SG143641     ; "8\tc #5C8DEC"
.data:000002C0                 dd offset $SG143642     ; "9\tc #5C94F6"
.data:000002C4                 dd offset $SG143643     ; "0\tc #5482DF"
.data:000002C8                 dd offset $SG143644     ; "a\tc #619DF7"
.data:000002CC                 dd offset $SG143645     ; "b\tc #6CA6FC"
.data:000002D0                 dd offset $SG143646     ; "c\tc #64A2FC"
.data:000002D4                 dd offset $SG143647     ; "d\tc #1C2E5C"
.data:000002D8                 dd offset $SG143648     ; "e\tc #6CA2FC"
.data:000002DC                 dd offset $SG143649     ; "f\tc #74B2FC"
.data:000002E0                 dd offset $SG143650     ; "g\tc #7CB8FC"
.data:000002E4                 dd offset $SG143651     ; "h\tc #1C3264"
.data:000002E8                 dd offset $SG143652     ; "i\tc #346AD4"
.data:000002EC                 dd offset $SG143653     ; "j\tc #7CBEFC"
.data:000002F0                 dd offset $SG143654     ; "k\tc #3C72DC"
.data:000002F4                 dd offset $SG143655     ; "l\tc #243250"
.data:000002F8                 dd offset $SG143656     ; "m\tc #346AB4"
.data:000002FC                 dd offset $SG143657     ; "n\tc #3C82DC"
.data:00000300                 dd offset $SG143658     ; "o\tc #6C6A6C"
.data:00000304                 dd offset $SG143659     ; "     .+.     "
.data:00000308                 dd offset $SG143660     ; "   @##$##@   "
.data:0000030C                 dd offset $SG143661     ; "  @%&***&%@  "
.data:00000310                 dd offset $SG143662     ; " =-;>,,,>;-= "
.data:00000314                 dd offset $SG143663     ; " ')!~{{{~!)' "
.data:00000318                 dd offset $SG143664     ; "])^/({{{(_^)]"
.data:0000031C                 dd offset $SG143665     ; ":<_[}|||}[_<:"
.data:00000320                 dd offset $SG143666     ; "12[3455563[21"
.data:00000324                 dd offset $SG143667     ; "7_365899063_7"
.data:00000328                 dd offset $SG143668     ; " /|09abc904/ "
.data:0000032C                 dd offset $SG143669     ; " d}8efgfb83d "
.data:00000330                 dd offset $SG143670     ; "  hiafjgakh  "
.data:00000334                 dd offset $SG143671     ; "   l~mnm~l   "
.data:00000338                 dd offset $SG143672     ; "     o@o     "
.data:00000338 _data           ends
.data:00000338
.rdata:0000033C ; ===========================================================================
.rdata:0000033C
.rdata:0000033C ; Segment type: Pure data
.rdata:0000033C ; Segment permissions: Read
.rdata:0000033C _rdata          segment dword public 'DATA' use32
.rdata:0000033C                 assume cs:_rdata
.rdata:0000033C                 ;org 33Ch
.rdata:0000033C $SG143466       db '12 12 56 1',0       ; DATA XREF: .data:_acTop_xpmo
.rdata:00000347                 align 4
.rdata:00000348 $SG143467       db ' ',9,'c #FFFFFF',0  ; DATA XREF: .data:00000004o
.rdata:00000354 $SG143468       db '.',9,'c #8AB2E9',0  ; DATA XREF: .data:00000008o
.rdata:00000360 $SG143469       db '+',9,'c #CCDCF6',0  ; DATA XREF: .data:0000000Co
.rdata:0000036C $SG143470       db '@',9,'c #80ABEA',0  ; DATA XREF: .data:00000010o
.rdata:00000378 $SG143471       db '#',9,'c #7DA9E8',0  ; DATA XREF: .data:00000014o
.rdata:00000384 $SG143472       db '$',9,'c #C7DAF3',0  ; DATA XREF: .data:00000018o
.rdata:00000390 $SG143473       db '%',9,'c #79A7E6',0  ; DATA XREF: .data:0000001Co
.rdata:0000039C $SG143474       db '&',9,'c #ADC8EF',0  ; DATA XREF: .data:00000020o
.rdata:000003A8 $SG143475       db '*',9,'c #87B0E8',0  ; DATA XREF: .data:00000024o
.rdata:000003B4 $SG143476       db '=',9,'c #BBD2F0',0  ; DATA XREF: .data:00000028o
.rdata:000003C0 $SG143477       db '-',9,'c #6EA0E2',0  ; DATA XREF: .data:0000002Co
.rdata:000003CC $SG143478       db ';',9,'c #A8C7EE',0  ; DATA XREF: .data:00000030o
.rdata:000003D8 $SG143479       db '>',9,'c #A3C2ED',0  ; DATA XREF: .data:00000034o
.rdata:000003E4 $SG143480       db ',',9,'c #75A4E3',0  ; DATA XREF: .data:00000038o
.rdata:000003F0 $SG143481       db 27h,9,'c #A7C4EB',0  ; DATA XREF: .data:0000003Co
.rdata:000003FC $SG143482       db ')',9,'c #6297E1',0  ; DATA XREF: .data:00000040o
.rdata:00000408 $SG143483       db '!',9,'c #A1C1EC',0  ; DATA XREF: .data:00000044o
.rdata:00000414 $SG143484       db '~',9,'c #92B7E8',0  ; DATA XREF: .data:00000048o
.rdata:00000420 $SG143485       db '{',9,'c #99BBE9',0  ; DATA XREF: .data:0000004Co
.rdata:0000042C $SG143486       db ']',9,'c #6197DD',0  ; DATA XREF: .data:00000050o
.rdata:00000438 $SG143487       db '^',9,'c #96B9E6',0  ; DATA XREF: .data:00000054o
.rdata:00000444 $SG143488       db '/',9,'c #538EDB',0  ; DATA XREF: .data:00000058o
.rdata:00000450 $SG143489       db '(',9,'c #99BBEA',0  ; DATA XREF: .data:0000005Co
.rdata:0000045C $SG143490       db '_',9,'c #80AAE3',0  ; DATA XREF: .data:00000060o
.rdata:00000468 $SG143491       db ':',9,'c #81ABE3',0  ; DATA XREF: .data:00000064o
.rdata:00000474 $SG143492       db '<',9,'c #8AB1E4',0  ; DATA XREF: .data:00000068o
.rdata:00000480 $SG143493       db '[',9,'c #4B88D6',0  ; DATA XREF: .data:0000006Co
.rdata:0000048C $SG143494       db '}',9,'c #4882D1',0  ; DATA XREF: .data:00000070o
.rdata:00000498 $SG143495       db '|',9,'c #4384D6',0  ; DATA XREF: .data:00000074o
.rdata:000004A4 $SG143496       db '1',9,'c #90B5E7',0  ; DATA XREF: .data:00000078o
.rdata:000004B0 $SG143497       db '2',9,'c #74A3E0',0  ; DATA XREF: .data:0000007Co
.rdata:000004BC $SG143498       db '3',9,'c #77A4E0',0  ; DATA XREF: .data:00000080o
.rdata:000004C8 $SG143499       db '4',9,'c #81ABE2',0  ; DATA XREF: .data:00000084o
.rdata:000004D4 $SG143500       db '5',9,'c #437FD3',0  ; DATA XREF: .data:00000088o
.rdata:000004E0 $SG143501       db '6',9,'c #7FA2DF',0  ; DATA XREF: .data:0000008Co
.rdata:000004EC $SG143502       db '7',9,'c #3577D2',0  ; DATA XREF: .data:00000090o
.rdata:000004F8 $SG143503       db '8',9,'c #87AFE4',0  ; DATA XREF: .data:00000094o
.rdata:00000504 $SG143504       db '9',9,'c #72A1DF',0  ; DATA XREF: .data:00000098o
.rdata:00000510 $SG143505       db '0',9,'c #7CA9E1',0  ; DATA XREF: .data:0000009Co
.rdata:0000051C $SG143506       db 'a',9,'c #3F7AD0',0  ; DATA XREF: .data:000000A0o
.rdata:00000528 $SG143507       db 'b',9,'c #85A4DE',0  ; DATA XREF: .data:000000A4o
.rdata:00000534 $SG143508       db 'c',9,'c #FBFCFE',0  ; DATA XREF: .data:000000A8o
.rdata:00000540 $SG143509       db 'd',9,'c #236ECD',0  ; DATA XREF: .data:000000ACo
.rdata:0000054C $SG143510       db 'e',9,'c #7EA8E1',0  ; DATA XREF: .data:000000B0o
.rdata:00000558 $SG143511       db 'f',9,'c #79A6E0',0  ; DATA XREF: .data:000000B4o
.rdata:00000564 $SG143512       db 'g',9,'c #3D77D0',0  ; DATA XREF: .data:000000B8o
.rdata:00000570 $SG143513       db 'h',9,'c #87A4DC',0  ; DATA XREF: .data:000000BCo
.rdata:0000057C $SG143514       db 'i',9,'c #1A62C9',0  ; DATA XREF: .data:000000C0o
.rdata:00000588 $SG143515       db 'j',9,'c #75A3DF',0  ; DATA XREF: .data:000000C4o
.rdata:00000594 $SG143516       db 'k',9,'c #3C74CF',0  ; DATA XREF: .data:000000C8o
.rdata:000005A0 $SG143517       db 'l',9,'c #8DA6DE',0  ; DATA XREF: .data:000000CCo
.rdata:000005AC $SG143518       db 'm',9,'c #1859C4',0  ; DATA XREF: .data:000000D0o
.rdata:000005B8 $SG143519       db 'n',9,'c #3B71CC',0  ; DATA XREF: .data:000000D4o
.rdata:000005C4 $SG143520       db 'o',9,'c #8EA5DD',0  ; DATA XREF: .data:000000D8o
.rdata:000005D0 $SG143521       db 'p',9,'c #164EC0',0  ; DATA XREF: .data:000000DCo
.rdata:000005DC $SG143522       db 'q',9,'c #92A7DD',0  ; DATA XREF: .data:000000E0o
.rdata:000005E8 $SG143523       db '    .+      ',0     ; DATA XREF: .data:000000E4o
.rdata:000005F5                 align 4
.rdata:000005F8 $SG143524       db '    @#$     ',0     ; DATA XREF: .data:000000E8o
.rdata:00000605                 align 4
.rdata:00000608 $SG143525       db '    %&*=    ',0     ; DATA XREF: .data:000000ECo
.rdata:00000615                 align 4
.rdata:00000618 $SG143526       db '    -;>,',27h,'   ',0 ; DATA XREF: .data:000000F0o
.rdata:00000625                 align 4
.rdata:00000628 $SG143527       db '    )!~{]^  ',0     ; DATA XREF: .data:000000F4o
.rdata:00000635                 align 4
.rdata:00000638 $SG143528       db '    /(_:<[} ',0     ; DATA XREF: .data:000000F8o
.rdata:00000645                 align 4
.rdata:00000648 $SG143529       db '    |123456 ',0     ; DATA XREF: .data:000000FCo
.rdata:00000655                 align 4
.rdata:00000658 $SG143530       db '    7890abc ',0     ; DATA XREF: .data:00000100o
.rdata:00000665                 align 4
.rdata:00000668 $SG143531       db '    defgh   ',0     ; DATA XREF: .data:00000104o
.rdata:00000675                 align 4
.rdata:00000678 $SG143532       db '    ijkl    ',0     ; DATA XREF: .data:00000108o
.rdata:00000685                 align 4
.rdata:00000688 $SG143533       db '    mno     ',0     ; DATA XREF: .data:0000010Co
.rdata:00000695                 align 4
.rdata:00000698 $SG143534       db '    pq      ',0     ; DATA XREF: .data:00000110o
.rdata:000006A5                 align 4
.rdata:000006A8 $SG143536       db '12 12 54 1',0       ; DATA XREF: .data:_acBottom_xpmo
.rdata:000006B3                 align 4
.rdata:000006B4 $SG143537       db ' ',9,'c #FFFFFF',0  ; DATA XREF: .data:0000011Co
.rdata:000006C0 $SG143538       db '.',9,'c #C4D7F3',0  ; DATA XREF: .data:00000120o
.rdata:000006CC $SG143539       db '+',9,'c #72A1E3',0  ; DATA XREF: .data:00000124o
.rdata:000006D8 $SG143540       db '@',9,'c #C1D6F2',0  ; DATA XREF: .data:00000128o
.rdata:000006E4 $SG143541       db '#',9,'c #6397E1',0  ; DATA XREF: .data:0000012Co
.rdata:000006F0 $SG143542       db '$',9,'c #5990DD',0  ; DATA XREF: .data:00000130o
.rdata:000006FC $SG143543       db '%',9,'c #BBD2F0',0  ; DATA XREF: .data:00000134o
.rdata:00000708 $SG143544       db '&',9,'c #7AA6E5',0  ; DATA XREF: .data:00000138o
.rdata:00000714 $SG143545       db '*',9,'c #9ABDEA',0  ; DATA XREF: .data:0000013Co
.rdata:00000720 $SG143546       db '=',9,'c #4A87D9',0  ; DATA XREF: .data:00000140o
.rdata:0000072C $SG143547       db '-',9,'c #B1CAEE',0  ; DATA XREF: .data:00000144o
.rdata:00000738 $SG143548       db ';',9,'c #75A4E3',0  ; DATA XREF: .data:00000148o
.rdata:00000744 $SG143549       db '>',9,'c #99BBE9',0  ; DATA XREF: .data:0000014Co
.rdata:00000750 $SG143550       db ',',9,'c #95B9E8',0  ; DATA XREF: .data:00000150o
.rdata:0000075C $SG143551       db 27h,9,'c #3A7CD4',0  ; DATA XREF: .data:00000154o
.rdata:00000768 $SG143552       db ')',9,'c #A9C6EC',0  ; DATA XREF: .data:00000158o
.rdata:00000774 $SG143553       db '!',9,'c #71A0E0',0  ; DATA XREF: .data:0000015Co
.rdata:00000780 $SG143554       db '~',9,'c #86AFE5',0  ; DATA XREF: .data:00000160o
.rdata:0000078C $SG143555       db '{',9,'c #8DB2E6',0  ; DATA XREF: .data:00000164o
.rdata:00000798 $SG143556       db ']',9,'c #2A72CF',0  ; DATA XREF: .data:00000168o
.rdata:000007A4 $SG143557       db '^',9,'c #73A0E0',0  ; DATA XREF: .data:0000016Co
.rdata:000007B0 $SG143558       db '/',9,'c #6B9DE0',0  ; DATA XREF: .data:00000170o
.rdata:000007BC $SG143559       db '(',9,'c #95B8E8',0  ; DATA XREF: .data:00000174o
.rdata:000007C8 $SG143560       db '_',9,'c #81ABE3',0  ; DATA XREF: .data:00000178o
.rdata:000007D4 $SG143561       db ':',9,'c #72A1DF',0  ; DATA XREF: .data:0000017Co
.rdata:000007E0 $SG143562       db '<',9,'c #83ADE3',0  ; DATA XREF: .data:00000180o
.rdata:000007EC $SG143563       db '[',9,'c #1B65C9',0  ; DATA XREF: .data:00000184o
.rdata:000007F8 $SG143564       db '}',9,'c #5F95DC',0  ; DATA XREF: .data:00000188o
.rdata:00000804 $SG143565       db '|',9,'c #8BB3E5',0  ; DATA XREF: .data:0000018Co
.rdata:00000810 $SG143566       db '1',9,'c #77A4E0',0  ; DATA XREF: .data:00000190o
.rdata:0000081C $SG143567       db '2',9,'c #679ADC',0  ; DATA XREF: .data:00000194o
.rdata:00000828 $SG143568       db '3',9,'c #7AA6E1',0  ; DATA XREF: .data:00000198o
.rdata:00000834 $SG143569       db '4',9,'c #195CC6',0  ; DATA XREF: .data:0000019Co
.rdata:00000840 $SG143570       db '5',9,'c #FCFDFE',0  ; DATA XREF: .data:000001A0o
.rdata:0000084C $SG143571       db '6',9,'c #8DB2E4',0  ; DATA XREF: .data:000001A4o
.rdata:00000858 $SG143572       db '7',9,'c #4885D6',0  ; DATA XREF: .data:000001A8o
.rdata:00000864 $SG143573       db '8',9,'c #7CA9E1',0  ; DATA XREF: .data:000001ACo
.rdata:00000870 $SG143574       db '9',9,'c #6698DB',0  ; DATA XREF: .data:000001B0o
.rdata:0000087C $SG143575       db '0',9,'c #71A1DE',0  ; DATA XREF: .data:000001B4o
.rdata:00000888 $SG143576       db 'a',9,'c #1752C0',0  ; DATA XREF: .data:000001B8o
.rdata:00000894 $SG143577       db 'b',9,'c #88ABE0',0  ; DATA XREF: .data:000001BCo
.rdata:000008A0 $SG143578       db 'c',9,'c #3D77D0',0  ; DATA XREF: .data:000001C0o
.rdata:000008AC $SG143579       db 'd',9,'c #6E9FDD',0  ; DATA XREF: .data:000001C4o
.rdata:000008B8 $SG143580       db 'e',9,'c #699BDC',0  ; DATA XREF: .data:000001C8o
.rdata:000008C4 $SG143581       db 'f',9,'c #1547BD',0  ; DATA XREF: .data:000001CCo
.rdata:000008D0 $SG143582       db 'g',9,'c #8DA6DE',0  ; DATA XREF: .data:000001D0o
.rdata:000008DC $SG143583       db 'h',9,'c #376BC9',0  ; DATA XREF: .data:000001D4o
.rdata:000008E8 $SG143584       db 'i',9,'c #6295DA',0  ; DATA XREF: .data:000001D8o
.rdata:000008F4 $SG143585       db 'j',9,'c #1440B9',0  ; DATA XREF: .data:000001DCo
.rdata:00000900 $SG143586       db 'k',9,'c #8DA0DB',0  ; DATA XREF: .data:000001E0o
.rdata:0000090C $SG143587       db 'l',9,'c #315FC4',0  ; DATA XREF: .data:000001E4o
.rdata:00000918 $SG143588       db 'm',9,'c #1339B7',0  ; DATA XREF: .data:000001E8o
.rdata:00000924 $SG143589       db 'n',9,'c #909FDA',0  ; DATA XREF: .data:000001ECo
.rdata:00000930 $SG143590       db 'o',9,'c #1233B4',0  ; DATA XREF: .data:000001F0o
.rdata:0000093C $SG143591       db '         .+ ',0     ; DATA XREF: .data:000001F4o
.rdata:00000949                 align 4
.rdata:0000094C $SG143592       db '        @#$ ',0     ; DATA XREF: .data:000001F8o
.rdata:00000959                 align 4
.rdata:0000095C $SG143593       db '       %&*= L',0    ; DATA XREF: .data:000001FCo
.rdata:0000096A                 align 4
.rdata:0000096C $SG143594       db '      -;>,',27h,' ',0 ; DATA XREF: .data:00000200o
.rdata:00000979                 align 4
.rdata:0000097C $SG143595       db '     )!>~{] ',0     ; DATA XREF: .data:00000204o
.rdata:00000989                 align 4
.rdata:0000098C $SG143596       db '    ^/(_:<[ ',0     ; DATA XREF: .data:00000208o
.rdata:00000999                 align 4
.rdata:0000099C $SG143597       db '    (}|1234 ',0     ; DATA XREF: .data:0000020Co
.rdata:000009A9                 align 4
.rdata:000009AC $SG143598       db '    567890a ',0     ; DATA XREF: .data:00000210o
.rdata:000009B9                 align 4
.rdata:000009BC $SG143599       db '      bcdef ',0     ; DATA XREF: .data:00000214o
.rdata:000009C9                 align 4
.rdata:000009CC $SG143600       db '       ghij ',0     ; DATA XREF: .data:00000218o
.rdata:000009D9                 align 4
.rdata:000009DC $SG143601       db '        klm ',0     ; DATA XREF: .data:0000021Co
.rdata:000009E9                 align 4
.rdata:000009EC $SG143602       db '         no ',0     ; DATA XREF: .data:00000220o
.rdata:000009F9                 align 4
.rdata:000009FC $SG143604       db '13 14 54 1',0       ; DATA XREF: .data:_bookmark_xpmo
.rdata:00000A07                 align 4
.rdata:00000A08 $SG143605       db ' ',9,'c None',0     ; DATA XREF: .data:0000022Co
.rdata:00000A11                 align 4
.rdata:00000A14 $SG143606       db '.',9,'c #545254',0  ; DATA XREF: .data:00000230o
.rdata:00000A20 $SG143607       db '+',9,'c #3C3E3C',0  ; DATA XREF: .data:00000234o
.rdata:00000A2C $SG143608       db '@',9,'c #646464',0  ; DATA XREF: .data:00000238o
.rdata:00000A38 $SG143609       db '#',9,'c #A4A4A4',0  ; DATA XREF: .data:0000023Co
.rdata:00000A44 $SG143610       db '$',9,'c #B7B8B7',0  ; DATA XREF: .data:00000240o
.rdata:00000A50 $SG143611       db '%',9,'c #747284',0  ; DATA XREF: .data:00000244o
.rdata:00000A5C $SG143612       db '&',9,'c #B4B2C4',0  ; DATA XREF: .data:00000248o
.rdata:00000A68 $SG143613       db '*',9,'c #DCD7E4',0  ; DATA XREF: .data:0000024Co
.rdata:00000A74 $SG143614       db '=',9,'c #1C1A1C',0  ; DATA XREF: .data:00000250o
.rdata:00000A80 $SG143615       db '-',9,'c #403E58',0  ; DATA XREF: .data:00000254o
.rdata:00000A8C $SG143616       db ';',9,'c #5C5A8C',0  ; DATA XREF: .data:00000258o
.rdata:00000A98 $SG143617       db '>',9,'c #7C7EAC',0  ; DATA XREF: .data:0000025Co
.rdata:00000AA4 $SG143618       db ',',9,'c #7C8EBC',0  ; DATA XREF: .data:00000260o
.rdata:00000AB0 $SG143619       db 27h,9,'c #242644',0  ; DATA XREF: .data:00000264o
.rdata:00000ABC $SG143620       db ')',9,'c #282668',0  ; DATA XREF: .data:00000268o
.rdata:00000AC8 $SG143621       db '!',9,'c #24367C',0  ; DATA XREF: .data:0000026Co
.rdata:00000AD4 $SG143622       db '~',9,'c #244A84',0  ; DATA XREF: .data:00000270o
.rdata:00000AE0 $SG143623       db '{',9,'c #2C5098',0  ; DATA XREF: .data:00000274o
.rdata:00000AEC $SG143624       db ']',9,'c #14162C',0  ; DATA XREF: .data:00000278o
.rdata:00000AF8 $SG143625       db '^',9,'c #142E7C',0  ; DATA XREF: .data:0000027Co
.rdata:00000B04 $SG143626       db '/',9,'c #143789',0  ; DATA XREF: .data:00000280o
.rdata:00000B10 $SG143627       db '(',9,'c #204990',0  ; DATA XREF: .data:00000284o
.rdata:00000B1C $SG143628       db '_',9,'c #174091',0  ; DATA XREF: .data:00000288o
.rdata:00000B28 $SG143629       db ':',9,'c #0C0630',0  ; DATA XREF: .data:0000028Co
.rdata:00000B34 $SG143630       db '<',9,'c #24327C',0  ; DATA XREF: .data:00000290o
.rdata:00000B40 $SG143631       db '[',9,'c #2450A0',0  ; DATA XREF: .data:00000294o
.rdata:00000B4C $SG143632       db '}',9,'c #345DB4',0  ; DATA XREF: .data:00000298o
.rdata:00000B58 $SG143633       db '|',9,'c #3C68B8',0  ; DATA XREF: .data:0000029Co
.rdata:00000B64 $SG143634       db '1',9,'c #141244',0  ; DATA XREF: .data:000002A0o
.rdata:00000B70 $SG143635       db '2',9,'c #24428C',0  ; DATA XREF: .data:000002A4o
.rdata:00000B7C $SG143636       db '3',9,'c #3462B9',0  ; DATA XREF: .data:000002A8o
.rdata:00000B88 $SG143637       db '4',9,'c #4470C4',0  ; DATA XREF: .data:000002ACo
.rdata:00000B94 $SG143638       db '5',9,'c #4C7FD6',0  ; DATA XREF: .data:000002B0o
.rdata:00000BA0 $SG143639       db '6',9,'c #4472CC',0  ; DATA XREF: .data:000002B4o
.rdata:00000BAC $SG143640       db '7',9,'c #24224C',0  ; DATA XREF: .data:000002B8o
.rdata:00000BB8 $SG143641       db '8',9,'c #5C8DEC',0  ; DATA XREF: .data:000002BCo
.rdata:00000BC4 $SG143642       db '9',9,'c #5C94F6',0  ; DATA XREF: .data:000002C0o
.rdata:00000BD0 $SG143643       db '0',9,'c #5482DF',0  ; DATA XREF: .data:000002C4o
.rdata:00000BDC $SG143644       db 'a',9,'c #619DF7',0  ; DATA XREF: .data:000002C8o
.rdata:00000BE8 $SG143645       db 'b',9,'c #6CA6FC',0  ; DATA XREF: .data:000002CCo
.rdata:00000BF4 $SG143646       db 'c',9,'c #64A2FC',0  ; DATA XREF: .data:000002D0o
.rdata:00000C00 $SG143647       db 'd',9,'c #1C2E5C',0  ; DATA XREF: .data:000002D4o
.rdata:00000C0C $SG143648       db 'e',9,'c #6CA2FC',0  ; DATA XREF: .data:000002D8o
.rdata:00000C18 $SG143649       db 'f',9,'c #74B2FC',0  ; DATA XREF: .data:000002DCo
.rdata:00000C24 $SG143650       db 'g',9,'c #7CB8FC',0  ; DATA XREF: .data:000002E0o
.rdata:00000C30 $SG143651       db 'h',9,'c #1C3264',0  ; DATA XREF: .data:000002E4o
.rdata:00000C3C $SG143652       db 'i',9,'c #346AD4',0  ; DATA XREF: .data:000002E8o
.rdata:00000C48 $SG143653       db 'j',9,'c #7CBEFC',0  ; DATA XREF: .data:000002ECo
.rdata:00000C54 $SG143654       db 'k',9,'c #3C72DC',0  ; DATA XREF: .data:000002F0o
.rdata:00000C60 $SG143655       db 'l',9,'c #243250',0  ; DATA XREF: .data:000002F4o
.rdata:00000C6C $SG143656       db 'm',9,'c #346AB4',0  ; DATA XREF: .data:000002F8o
.rdata:00000C78 $SG143657       db 'n',9,'c #3C82DC',0  ; DATA XREF: .data:000002FCo
.rdata:00000C84 $SG143658       db 'o',9,'c #6C6A6C',0  ; DATA XREF: .data:00000300o
.rdata:00000C90 $SG143659       db '     .+.     ',0    ; DATA XREF: .data:00000304o
.rdata:00000C9E                 align 10h
.rdata:00000CA0 $SG143660       db '   @##$##@   ',0    ; DATA XREF: .data:00000308o
.rdata:00000CAE                 align 10h
.rdata:00000CB0 $SG143661       db '  @%&***&%@  ',0    ; DATA XREF: .data:0000030Co
.rdata:00000CBE                 align 10h
.rdata:00000CC0 $SG143662       db ' =-;>,,,>;-= ',0    ; DATA XREF: .data:00000310o
.rdata:00000CCE                 align 10h
.rdata:00000CD0 $SG143663       db ' ',27h,')!~{{{~!)',27h,' ',0
.rdata:00000CD0                                         ; DATA XREF: .data:00000314o
.rdata:00000CDE                 align 10h
.rdata:00000CE0 $SG143664       db '])^/({{{(_^)]',0    ; DATA XREF: .data:00000318o
.rdata:00000CEE                 align 10h
.rdata:00000CF0 $SG143665       db ':<_[}|||}[_<:',0    ; DATA XREF: .data:0000031Co
.rdata:00000CFE                 align 10h
.rdata:00000D00 $SG143666       db '12[3455563[21',0    ; DATA XREF: .data:00000320o
.rdata:00000D0E                 align 10h
.rdata:00000D10 $SG143667       db '7_365899063_7',0    ; DATA XREF: .data:00000324o
.rdata:00000D1E                 align 10h
.rdata:00000D20 $SG143668       db ' /|09abc904/ ',0    ; DATA XREF: .data:00000328o
.rdata:00000D2E                 align 10h
.rdata:00000D30 $SG143669       db ' d}8efgfb83d ',0    ; DATA XREF: .data:0000032Co
.rdata:00000D3E                 align 10h
.rdata:00000D40 $SG143670       db '  hiafjgakh  ',0    ; DATA XREF: .data:00000330o
.rdata:00000D4E                 align 10h
.rdata:00000D50 $SG143671       db '   l~mnm~l   ',0    ; DATA XREF: .data:00000334o
.rdata:00000D5E                 align 10h
.rdata:00000D60 $SG143672       db '     o@o     ',0    ; DATA XREF: .data:00000338o
.rdata:00000D6E                 align 10h
.rdata:00000D70 $SG151186:                              ; DATA XREF: RunMacroDlg::initMacroList(void)+6Bo
.rdata:00000D70                 unicode 0, <Current recorded macro>,0
.rdata:00000D9E                 align 10h
.rdata:00000D9E _rdata          ends
.rdata:00000D9E
.text$mn:00000DA0 ; ===========================================================================
.text$mn:00000DA0
.text$mn:00000DA0 ; Segment type: Pure code
.text$mn:00000DA0 ; Segment permissions: Read/Execute
.text$mn:00000DA0 _text$mn        segment para public 'CODE' use32
.text$mn:00000DA0                 assume cs:_text$mn
.text$mn:00000DA0                 ;org 0DA0h
.text$mn:00000DA0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00000DA0
.text$mn:00000DA0 ; =============== S U B R O U T I N E =======================================
.text$mn:00000DA0
.text$mn:00000DA0 ; Attributes: bp-based frame
.text$mn:00000DA0
.text$mn:00000DA0 ; void __thiscall RunMacroDlg::initMacroList(RunMacroDlg *__hidden this)
.text$mn:00000DA0                 public ?initMacroList@RunMacroDlg@@QAEXXZ
.text$mn:00000DA0 ?initMacroList@RunMacroDlg@@QAEXXZ proc near
.text$mn:00000DA0                                         ; CODE XREF: RunMacroDlg::run_dlgProc(uint,uint,long)+2Ap
.text$mn:00000DA0
.text$mn:00000DA0 var_14          = dword ptr -14h
.text$mn:00000DA0 var_10          = dword ptr -10h
.text$mn:00000DA0 var_C           = dword ptr -0Ch
.text$mn:00000DA0 var_8           = dword ptr -8
.text$mn:00000DA0 var_4           = dword ptr -4
.text$mn:00000DA0
.text$mn:00000DA0                 push    ebp
.text$mn:00000DA1                 mov     ebp, esp
.text$mn:00000DA3                 sub     esp, 14h
.text$mn:00000DA6                 mov     [ebp+var_4], ecx
.text$mn:00000DA9                 mov     eax, [ebp+var_4]
.text$mn:00000DAC                 mov     edx, [eax]
.text$mn:00000DAE                 mov     ecx, [ebp+var_4]
.text$mn:00000DB1                 mov     eax, [edx+34h]
.text$mn:00000DB4                 call    eax
.text$mn:00000DB6                 movzx   ecx, al
.text$mn:00000DB9                 test    ecx, ecx
.text$mn:00000DBB                 jnz     short loc_DC2
.text$mn:00000DBD                 jmp     loc_EA2
.text$mn:00000DC2 ; ---------------------------------------------------------------------------
.text$mn:00000DC2
.text$mn:00000DC2 loc_DC2:                                ; CODE XREF: RunMacroDlg::initMacroList(void)+1Bj
.text$mn:00000DC2                 call    ?getInstance@NppParameters@@SAPAV1@XZ ; NppParameters::getInstance(void)
.text$mn:00000DC7                 mov     [ebp+var_10], eax
.text$mn:00000DCA                 mov     ecx, [ebp+var_10]
.text$mn:00000DCD                 call    ?getMacroList@NppParameters@@QAEAAV?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@XZ ; NppParameters::getMacroList(void)
.text$mn:00000DD2                 mov     [ebp+var_C], eax
.text$mn:00000DD5                 push    0               ; lParam
.text$mn:00000DD7                 push    0               ; wParam
.text$mn:00000DD9                 push    14Bh            ; Msg
.text$mn:00000DDE                 push    1F44h           ; nIDDlgItem
.text$mn:00000DE3                 mov     edx, [ebp+var_4]
.text$mn:00000DE6                 mov     eax, [edx+0Ch]
.text$mn:00000DE9                 push    eax             ; hDlg
.text$mn:00000DEA                 call    dword ptr ds:__imp__SendDlgItemMessageW@20 ; SendDlgItemMessageW(x,x,x,x,x)
.text$mn:00000DF0                 push    0               ; lParam
.text$mn:00000DF2                 push    0               ; wParam
.text$mn:00000DF4                 push    13A1h           ; Msg
.text$mn:00000DF9                 mov     ecx, [ebp+var_4]
.text$mn:00000DFC                 mov     edx, [ecx+8]
.text$mn:00000DFF                 push    edx             ; hWnd
.text$mn:00000E00                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000E06                 cmp     eax, 2
.text$mn:00000E09                 jnz     short loc_E29
.text$mn:00000E0B                 push    offset $SG151186 ; "Current recorded macro"
.text$mn:00000E10                 push    0               ; wParam
.text$mn:00000E12                 push    143h            ; Msg
.text$mn:00000E17                 push    1F44h           ; nIDDlgItem
.text$mn:00000E1C                 mov     eax, [ebp+var_4]
.text$mn:00000E1F                 mov     ecx, [eax+0Ch]
.text$mn:00000E22                 push    ecx             ; hDlg
.text$mn:00000E23                 call    dword ptr ds:__imp__SendDlgItemMessageW@20 ; SendDlgItemMessageW(x,x,x,x,x)
.text$mn:00000E29
.text$mn:00000E29 loc_E29:                                ; CODE XREF: RunMacroDlg::initMacroList(void)+69j
.text$mn:00000E29                 mov     [ebp+var_8], 0
.text$mn:00000E30                 mov     ecx, [ebp+var_C]
.text$mn:00000E33                 call    ?size@?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@QBEIXZ ; std::vector<MacroShortcut,std::allocator<MacroShortcut>>::size(void)
.text$mn:00000E38                 mov     [ebp+var_14], eax
.text$mn:00000E3B                 jmp     short loc_E46
.text$mn:00000E3D ; ---------------------------------------------------------------------------
.text$mn:00000E3D
.text$mn:00000E3D loc_E3D:                                ; CODE XREF: RunMacroDlg::initMacroList(void)+DBj
.text$mn:00000E3D                 mov     edx, [ebp+var_8]
.text$mn:00000E40                 add     edx, 1
.text$mn:00000E43                 mov     [ebp+var_8], edx
.text$mn:00000E46
.text$mn:00000E46 loc_E46:                                ; CODE XREF: RunMacroDlg::initMacroList(void)+9Bj
.text$mn:00000E46                 mov     eax, [ebp+var_8]
.text$mn:00000E49                 cmp     eax, [ebp+var_14]
.text$mn:00000E4C                 jnb     short loc_E7D
.text$mn:00000E4E                 mov     ecx, [ebp+var_8]
.text$mn:00000E51                 push    ecx
.text$mn:00000E52                 mov     ecx, [ebp+var_C]
.text$mn:00000E55                 call    ??A?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@QAEAAVMacroShortcut@@I@Z ; std::vector<MacroShortcut,std::allocator<MacroShortcut>>::operator[](uint)
.text$mn:00000E5A                 mov     ecx, eax        ; this
.text$mn:00000E5C                 call    ?getName@Shortcut@@QBEPB_WXZ ; Shortcut::getName(void)
.text$mn:00000E61                 push    eax             ; lParam
.text$mn:00000E62                 push    0               ; wParam
.text$mn:00000E64                 push    143h            ; Msg
.text$mn:00000E69                 push    1F44h           ; nIDDlgItem
.text$mn:00000E6E                 mov     edx, [ebp+var_4]
.text$mn:00000E71                 mov     eax, [edx+0Ch]
.text$mn:00000E74                 push    eax             ; hDlg
.text$mn:00000E75                 call    dword ptr ds:__imp__SendDlgItemMessageW@20 ; SendDlgItemMessageW(x,x,x,x,x)
.text$mn:00000E7B                 jmp     short loc_E3D
.text$mn:00000E7D ; ---------------------------------------------------------------------------
.text$mn:00000E7D
.text$mn:00000E7D loc_E7D:                                ; CODE XREF: RunMacroDlg::initMacroList(void)+ACj
.text$mn:00000E7D                 push    0               ; lParam
.text$mn:00000E7F                 push    0               ; wParam
.text$mn:00000E81                 push    14Eh            ; Msg
.text$mn:00000E86                 push    1F44h           ; nIDDlgItem
.text$mn:00000E8B                 mov     ecx, [ebp+var_4]
.text$mn:00000E8E                 mov     edx, [ecx+0Ch]
.text$mn:00000E91                 push    edx             ; hDlg
.text$mn:00000E92                 call    dword ptr ds:__imp__SendDlgItemMessageW@20 ; SendDlgItemMessageW(x,x,x,x,x)
.text$mn:00000E98                 mov     eax, [ebp+var_4]
.text$mn:00000E9B                 mov     dword ptr [eax+28h], 0
.text$mn:00000EA2
.text$mn:00000EA2 loc_EA2:                                ; CODE XREF: RunMacroDlg::initMacroList(void)+1Dj
.text$mn:00000EA2                 mov     esp, ebp
.text$mn:00000EA4                 pop     ebp
.text$mn:00000EA5                 retn
.text$mn:00000EA5 ?initMacroList@RunMacroDlg@@QAEXXZ endp
.text$mn:00000EA5
.text$mn:00000EA5 ; ---------------------------------------------------------------------------
.text$mn:00000EA6                 align 10h
.text$mn:00000EB0
.text$mn:00000EB0 ; =============== S U B R O U T I N E =======================================
.text$mn:00000EB0
.text$mn:00000EB0 ; Attributes: bp-based frame
.text$mn:00000EB0
.text$mn:00000EB0 ; int __thiscall RunMacroDlg::getMacro2Exec(RunMacroDlg *__hidden this)
.text$mn:00000EB0                 public ?getMacro2Exec@RunMacroDlg@@QBEHXZ
.text$mn:00000EB0 ?getMacro2Exec@RunMacroDlg@@QBEHXZ proc near
.text$mn:00000EB0
.text$mn:00000EB0 var_10          = dword ptr -10h
.text$mn:00000EB0 var_C           = dword ptr -0Ch
.text$mn:00000EB0 var_8           = dword ptr -8
.text$mn:00000EB0 var_1           = byte ptr -1
.text$mn:00000EB0
.text$mn:00000EB0                 push    ebp
.text$mn:00000EB1                 mov     ebp, esp
.text$mn:00000EB3                 sub     esp, 10h
.text$mn:00000EB6                 mov     [ebp+var_8], ecx
.text$mn:00000EB9                 push    0               ; lParam
.text$mn:00000EBB                 push    0               ; wParam
.text$mn:00000EBD                 push    13A1h           ; Msg
.text$mn:00000EC2                 mov     eax, [ebp+var_8]
.text$mn:00000EC5                 mov     ecx, [eax+8]
.text$mn:00000EC8                 push    ecx             ; hWnd
.text$mn:00000EC9                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000ECF                 cmp     eax, 2
.text$mn:00000ED2                 jnz     short loc_EDD
.text$mn:00000ED4                 mov     [ebp+var_C], 1
.text$mn:00000EDB                 jmp     short loc_EE4
.text$mn:00000EDD ; ---------------------------------------------------------------------------
.text$mn:00000EDD
.text$mn:00000EDD loc_EDD:                                ; CODE XREF: RunMacroDlg::getMacro2Exec(void)+22j
.text$mn:00000EDD                 mov     [ebp+var_C], 0
.text$mn:00000EE4
.text$mn:00000EE4 loc_EE4:                                ; CODE XREF: RunMacroDlg::getMacro2Exec(void)+2Bj
.text$mn:00000EE4                 mov     dl, byte ptr [ebp+var_C]
.text$mn:00000EE7                 mov     [ebp+var_1], dl
.text$mn:00000EEA                 movzx   eax, [ebp+var_1]
.text$mn:00000EEE                 test    eax, eax
.text$mn:00000EF0                 jz      short loc_F00
.text$mn:00000EF2                 mov     ecx, [ebp+var_8]
.text$mn:00000EF5                 mov     edx, [ecx+28h]
.text$mn:00000EF8                 sub     edx, 1
.text$mn:00000EFB                 mov     [ebp+var_10], edx
.text$mn:00000EFE                 jmp     short loc_F09
.text$mn:00000F00 ; ---------------------------------------------------------------------------
.text$mn:00000F00
.text$mn:00000F00 loc_F00:                                ; CODE XREF: RunMacroDlg::getMacro2Exec(void)+40j
.text$mn:00000F00                 mov     eax, [ebp+var_8]
.text$mn:00000F03                 mov     ecx, [eax+28h]
.text$mn:00000F06                 mov     [ebp+var_10], ecx
.text$mn:00000F09
.text$mn:00000F09 loc_F09:                                ; CODE XREF: RunMacroDlg::getMacro2Exec(void)+4Ej
.text$mn:00000F09                 mov     eax, [ebp+var_10]
.text$mn:00000F0C                 mov     esp, ebp
.text$mn:00000F0E                 pop     ebp
.text$mn:00000F0F                 retn
.text$mn:00000F0F ?getMacro2Exec@RunMacroDlg@@QBEHXZ endp
.text$mn:00000F0F
.text$mn:00000F10
.text$mn:00000F10 ; =============== S U B R O U T I N E =======================================
.text$mn:00000F10
.text$mn:00000F10 ; Attributes: bp-based frame
.text$mn:00000F10
.text$mn:00000F10 ; int __stdcall RunMacroDlg::run_dlgProc(RunMacroDlg *this, unsigned int, unsigned int, __int32)
.text$mn:00000F10                 public ?run_dlgProc@RunMacroDlg@@EAGHIIJ@Z
.text$mn:00000F10 ?run_dlgProc@RunMacroDlg@@EAGHIIJ@Z proc near
.text$mn:00000F10
.text$mn:00000F10 var_10          = dword ptr -10h
.text$mn:00000F10 var_C           = dword ptr -0Ch
.text$mn:00000F10 var_8           = dword ptr -8
.text$mn:00000F10 var_4           = dword ptr -4
.text$mn:00000F10 this            = dword ptr  8
.text$mn:00000F10 arg_4           = dword ptr  0Ch
.text$mn:00000F10 arg_8           = dword ptr  10h
.text$mn:00000F10
.text$mn:00000F10                 push    ebp
.text$mn:00000F11                 mov     ebp, esp
.text$mn:00000F13                 sub     esp, 10h
.text$mn:00000F16                 mov     eax, [ebp+arg_4]
.text$mn:00000F19                 mov     [ebp+var_4], eax
.text$mn:00000F1C                 cmp     [ebp+var_4], 110h
.text$mn:00000F23                 jz      short loc_F37
.text$mn:00000F25                 cmp     [ebp+var_4], 111h
.text$mn:00000F2C                 jz      loc_FBA
.text$mn:00000F32                 jmp     loc_111C
.text$mn:00000F37 ; ---------------------------------------------------------------------------
.text$mn:00000F37
.text$mn:00000F37 loc_F37:                                ; CODE XREF: RunMacroDlg::run_dlgProc(uint,uint,long)+13j
.text$mn:00000F37                 mov     ecx, [ebp+this] ; this
.text$mn:00000F3A                 call    ?initMacroList@RunMacroDlg@@QAEXXZ ; RunMacroDlg::initMacroList(void)
.text$mn:00000F3F                 push    0               ; bSigned
.text$mn:00000F41                 mov     ecx, [ebp+this]
.text$mn:00000F44                 mov     edx, [ecx+24h]
.text$mn:00000F47                 push    edx             ; uValue
.text$mn:00000F48                 push    1F43h           ; nIDDlgItem
.text$mn:00000F4D                 mov     eax, [ebp+this]
.text$mn:00000F50                 mov     ecx, [eax+0Ch]
.text$mn:00000F53                 push    ecx             ; hDlg
.text$mn:00000F54                 call    dword ptr ds:__imp__SetDlgItemInt@16 ; SetDlgItemInt(x,x,x,x)
.text$mn:00000F5A                 mov     edx, [ebp+this]
.text$mn:00000F5D                 mov     eax, [edx+20h]
.text$mn:00000F60                 mov     [ebp+var_8], eax
.text$mn:00000F63                 cmp     [ebp+var_8], 1
.text$mn:00000F67                 jz      short loc_F71
.text$mn:00000F69                 cmp     [ebp+var_8], 2
.text$mn:00000F6D                 jz      short loc_F80
.text$mn:00000F6F                 jmp     short loc_F8D
.text$mn:00000F71 ; ---------------------------------------------------------------------------
.text$mn:00000F71
.text$mn:00000F71 loc_F71:                                ; CODE XREF: RunMacroDlg::run_dlgProc(uint,uint,long)+57j
.text$mn:00000F71                 push    1F41h           ; int
.text$mn:00000F76                 mov     ecx, [ebp+this] ; this
.text$mn:00000F79                 call    ?check@RunMacroDlg@@AAEXH@Z ; RunMacroDlg::check(int)
.text$mn:00000F7E                 jmp     short loc_F8D
.text$mn:00000F80 ; ---------------------------------------------------------------------------
.text$mn:00000F80
.text$mn:00000F80 loc_F80:                                ; CODE XREF: RunMacroDlg::run_dlgProc(uint,uint,long)+5Dj
.text$mn:00000F80                 push    1F42h           ; int
.text$mn:00000F85                 mov     ecx, [ebp+this] ; this
.text$mn:00000F88                 call    ?check@RunMacroDlg@@AAEXH@Z ; RunMacroDlg::check(int)
.text$mn:00000F8D
.text$mn:00000F8D loc_F8D:                                ; CODE XREF: RunMacroDlg::run_dlgProc(uint,uint,long)+5Fj
.text$mn:00000F8D                                         ; RunMacroDlg::run_dlgProc(uint,uint,long)+6Ej
.text$mn:00000F8D                 push    0               ; lParam
.text$mn:00000F8F                 push    4               ; wParam
.text$mn:00000F91                 push    0C5h ; '+'      ; Msg
.text$mn:00000F96                 push    1F43h           ; nIDDlgItem
.text$mn:00000F9B                 mov     ecx, [ebp+this]
.text$mn:00000F9E                 mov     edx, [ecx+0Ch]
.text$mn:00000FA1                 push    edx             ; hDlg
.text$mn:00000FA2                 call    dword ptr ds:__imp__SendDlgItemMessageW@20 ; SendDlgItemMessageW(x,x,x,x,x)
.text$mn:00000FA8                 mov     ecx, [ebp+this] ; this
.text$mn:00000FAB                 call    ?goToCenter@StaticDialog@@QAEXXZ ; StaticDialog::goToCenter(void)
.text$mn:00000FB0                 mov     eax, 1
.text$mn:00000FB5                 jmp     loc_111E
.text$mn:00000FBA ; ---------------------------------------------------------------------------
.text$mn:00000FBA
.text$mn:00000FBA loc_FBA:                                ; CODE XREF: RunMacroDlg::run_dlgProc(uint,uint,long)+1Cj
.text$mn:00000FBA                 mov     eax, [ebp+arg_8]
.text$mn:00000FBD                 shr     eax, 10h
.text$mn:00000FC0                 and     eax, 0FFFFh
.text$mn:00000FC5                 movzx   ecx, ax
.text$mn:00000FC8                 cmp     ecx, 300h
.text$mn:00000FCE                 jnz     short loc_1008
.text$mn:00000FD0                 mov     edx, [ebp+arg_8]
.text$mn:00000FD3                 and     edx, 0FFFFh
.text$mn:00000FD9                 movzx   eax, dx
.text$mn:00000FDC                 mov     [ebp+var_10], eax
.text$mn:00000FDF                 cmp     [ebp+var_10], 1F43h
.text$mn:00000FE6                 jz      short loc_FEA
.text$mn:00000FE8                 jmp     short loc_1001
.text$mn:00000FEA ; ---------------------------------------------------------------------------
.text$mn:00000FEA
.text$mn:00000FEA loc_FEA:                                ; CODE XREF: RunMacroDlg::run_dlgProc(uint,uint,long)+D6j
.text$mn:00000FEA                 push    1F41h           ; int
.text$mn:00000FEF                 mov     ecx, [ebp+this] ; this
.text$mn:00000FF2                 call    ?check@RunMacroDlg@@AAEXH@Z ; RunMacroDlg::check(int)
.text$mn:00000FF7                 mov     eax, 1
.text$mn:00000FFC                 jmp     loc_111E
.text$mn:00001001 ; ---------------------------------------------------------------------------
.text$mn:00001001
.text$mn:00001001 loc_1001:                               ; CODE XREF: RunMacroDlg::run_dlgProc(uint,uint,long)+D8j
.text$mn:00001001                 xor     eax, eax
.text$mn:00001003                 jmp     loc_111E
.text$mn:00001008 ; ---------------------------------------------------------------------------
.text$mn:00001008
.text$mn:00001008 loc_1008:                               ; CODE XREF: RunMacroDlg::run_dlgProc(uint,uint,long)+BEj
.text$mn:00001008                 mov     ecx, [ebp+arg_8]
.text$mn:0000100B                 mov     [ebp+var_C], ecx
.text$mn:0000100E                 cmp     [ebp+var_C], 1
.text$mn:00001012                 jz      short loc_1038
.text$mn:00001014                 cmp     [ebp+var_C], 2
.text$mn:00001018                 jz      short loc_101F
.text$mn:0000101A                 jmp     loc_10CE
.text$mn:0000101F ; ---------------------------------------------------------------------------
.text$mn:0000101F
.text$mn:0000101F loc_101F:                               ; CODE XREF: RunMacroDlg::run_dlgProc(uint,uint,long)+108j
.text$mn:0000101F                 push    0               ; nCmdShow
.text$mn:00001021                 mov     edx, [ebp+this]
.text$mn:00001024                 mov     eax, [edx+0Ch]
.text$mn:00001027                 push    eax             ; hWnd
.text$mn:00001028                 call    dword ptr ds:__imp__ShowWindow@8 ; ShowWindow(x,x)
.text$mn:0000102E                 mov     eax, 1
.text$mn:00001033                 jmp     loc_111E
.text$mn:00001038 ; ---------------------------------------------------------------------------
.text$mn:00001038
.text$mn:00001038 loc_1038:                               ; CODE XREF: RunMacroDlg::run_dlgProc(uint,uint,long)+102j
.text$mn:00001038                 push    1F41h           ; int
.text$mn:0000103D                 mov     ecx, [ebp+this] ; this
.text$mn:00001040                 call    ?isCheckedOrNot@StaticDialog@@QBE_NH@Z ; StaticDialog::isCheckedOrNot(int)
.text$mn:00001045                 movzx   ecx, al
.text$mn:00001048                 test    ecx, ecx
.text$mn:0000104A                 jz      short loc_1074
.text$mn:0000104C                 mov     edx, [ebp+this]
.text$mn:0000104F                 mov     dword ptr [edx+20h], 1
.text$mn:00001056                 push    0               ; bSigned
.text$mn:00001058                 push    0               ; lpTranslated
.text$mn:0000105A                 push    1F43h           ; nIDDlgItem
.text$mn:0000105F                 mov     eax, [ebp+this]
.text$mn:00001062                 mov     ecx, [eax+0Ch]
.text$mn:00001065                 push    ecx             ; hDlg
.text$mn:00001066                 call    dword ptr ds:__imp__GetDlgItemInt@16 ; GetDlgItemInt(x,x,x,x)
.text$mn:0000106C                 mov     edx, [ebp+this]
.text$mn:0000106F                 mov     [edx+24h], eax
.text$mn:00001072                 jmp     short loc_1092
.text$mn:00001074 ; ---------------------------------------------------------------------------
.text$mn:00001074
.text$mn:00001074 loc_1074:                               ; CODE XREF: RunMacroDlg::run_dlgProc(uint,uint,long)+13Aj
.text$mn:00001074                 push    1F42h           ; int
.text$mn:00001079                 mov     ecx, [ebp+this] ; this
.text$mn:0000107C                 call    ?isCheckedOrNot@StaticDialog@@QBE_NH@Z ; StaticDialog::isCheckedOrNot(int)
.text$mn:00001081                 movzx   eax, al
.text$mn:00001084                 test    eax, eax
.text$mn:00001086                 jz      short loc_1092
.text$mn:00001088                 mov     ecx, [ebp+this]
.text$mn:0000108B                 mov     dword ptr [ecx+20h], 2
.text$mn:00001092
.text$mn:00001092 loc_1092:                               ; CODE XREF: RunMacroDlg::run_dlgProc(uint,uint,long)+162j
.text$mn:00001092                                         ; RunMacroDlg::run_dlgProc(uint,uint,long)+176j
.text$mn:00001092                 push    0               ; lParam
.text$mn:00001094                 push    0               ; wParam
.text$mn:00001096                 push    146h            ; Msg
.text$mn:0000109B                 push    1F44h           ; nIDDlgItem
.text$mn:000010A0                 mov     edx, [ebp+this]
.text$mn:000010A3                 mov     eax, [edx+0Ch]
.text$mn:000010A6                 push    eax             ; hDlg
.text$mn:000010A7                 call    dword ptr ds:__imp__SendDlgItemMessageW@20 ; SendDlgItemMessageW(x,x,x,x,x)
.text$mn:000010AD                 test    eax, eax
.text$mn:000010AF                 jz      short loc_10C7
.text$mn:000010B1                 push    0               ; lParam
.text$mn:000010B3                 push    0               ; wParam
.text$mn:000010B5                 push    13A2h           ; Msg
.text$mn:000010BA                 mov     ecx, [ebp+this]
.text$mn:000010BD                 mov     edx, [ecx+8]
.text$mn:000010C0                 push    edx             ; hWnd
.text$mn:000010C1                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:000010C7
.text$mn:000010C7 loc_10C7:                               ; CODE XREF: RunMacroDlg::run_dlgProc(uint,uint,long)+19Fj
.text$mn:000010C7                 mov     eax, 1
.text$mn:000010CC                 jmp     short loc_111E
.text$mn:000010CE ; ---------------------------------------------------------------------------
.text$mn:000010CE
.text$mn:000010CE loc_10CE:                               ; CODE XREF: RunMacroDlg::run_dlgProc(uint,uint,long)+10Aj
.text$mn:000010CE                 mov     eax, [ebp+arg_8]
.text$mn:000010D1                 shr     eax, 10h
.text$mn:000010D4                 and     eax, 0FFFFh
.text$mn:000010D9                 movzx   ecx, ax
.text$mn:000010DC                 cmp     ecx, 1
.text$mn:000010DF                 jnz     short loc_111C
.text$mn:000010E1                 mov     edx, [ebp+arg_8]
.text$mn:000010E4                 and     edx, 0FFFFh
.text$mn:000010EA                 movzx   eax, dx
.text$mn:000010ED                 cmp     eax, 1F44h
.text$mn:000010F2                 jnz     short loc_111C
.text$mn:000010F4                 push    0               ; lParam
.text$mn:000010F6                 push    0               ; wParam
.text$mn:000010F8                 push    147h            ; Msg
.text$mn:000010FD                 push    1F44h           ; nIDDlgItem
.text$mn:00001102                 mov     ecx, [ebp+this]
.text$mn:00001105                 mov     edx, [ecx+0Ch]
.text$mn:00001108                 push    edx             ; hDlg
.text$mn:00001109                 call    dword ptr ds:__imp__SendDlgItemMessageW@20 ; SendDlgItemMessageW(x,x,x,x,x)
.text$mn:0000110F                 mov     ecx, [ebp+this]
.text$mn:00001112                 mov     [ecx+28h], eax
.text$mn:00001115                 mov     eax, 1
.text$mn:0000111A                 jmp     short loc_111E
.text$mn:0000111C ; ---------------------------------------------------------------------------
.text$mn:0000111C
.text$mn:0000111C loc_111C:                               ; CODE XREF: RunMacroDlg::run_dlgProc(uint,uint,long)+22j
.text$mn:0000111C                                         ; RunMacroDlg::run_dlgProc(uint,uint,long)+1CFj ...
.text$mn:0000111C                 xor     eax, eax
.text$mn:0000111E
.text$mn:0000111E loc_111E:                               ; CODE XREF: RunMacroDlg::run_dlgProc(uint,uint,long)+A5j
.text$mn:0000111E                                         ; RunMacroDlg::run_dlgProc(uint,uint,long)+ECj ...
.text$mn:0000111E                 mov     esp, ebp
.text$mn:00001120                 pop     ebp
.text$mn:00001121                 retn    10h
.text$mn:00001121 ?run_dlgProc@RunMacroDlg@@EAGHIIJ@Z endp
.text$mn:00001121
.text$mn:00001121 ; ---------------------------------------------------------------------------
.text$mn:00001124                 align 10h
.text$mn:00001130
.text$mn:00001130 ; =============== S U B R O U T I N E =======================================
.text$mn:00001130
.text$mn:00001130 ; Attributes: bp-based frame
.text$mn:00001130
.text$mn:00001130 ; void __thiscall RunMacroDlg::check(RunMacroDlg *this, int)
.text$mn:00001130                 public ?check@RunMacroDlg@@AAEXH@Z
.text$mn:00001130 ?check@RunMacroDlg@@AAEXH@Z proc near   ; CODE XREF: RunMacroDlg::run_dlgProc(uint,uint,long)+69p
.text$mn:00001130                                         ; RunMacroDlg::run_dlgProc(uint,uint,long)+78p ...
.text$mn:00001130
.text$mn:00001130 var_4           = dword ptr -4
.text$mn:00001130 arg_0           = dword ptr  8
.text$mn:00001130
.text$mn:00001130                 push    ebp
.text$mn:00001131                 mov     ebp, esp
.text$mn:00001133                 push    ecx
.text$mn:00001134                 mov     [ebp+var_4], ecx
.text$mn:00001137                 cmp     [ebp+arg_0], 1F41h
.text$mn:0000113E                 jnz     short loc_115D
.text$mn:00001140                 push    0               ; lParam
.text$mn:00001142                 push    1               ; wParam
.text$mn:00001144                 push    0F1h ; '±'      ; Msg
.text$mn:00001149                 push    1F41h           ; nIDDlgItem
.text$mn:0000114E                 mov     eax, [ebp+var_4]
.text$mn:00001151                 mov     ecx, [eax+0Ch]
.text$mn:00001154                 push    ecx             ; hDlg
.text$mn:00001155                 call    dword ptr ds:__imp__SendDlgItemMessageW@20 ; SendDlgItemMessageW(x,x,x,x,x)
.text$mn:0000115B                 jmp     short loc_1178
.text$mn:0000115D ; ---------------------------------------------------------------------------
.text$mn:0000115D
.text$mn:0000115D loc_115D:                               ; CODE XREF: RunMacroDlg::check(int)+Ej
.text$mn:0000115D                 push    0               ; lParam
.text$mn:0000115F                 push    0               ; wParam
.text$mn:00001161                 push    0F1h ; '±'      ; Msg
.text$mn:00001166                 push    1F41h           ; nIDDlgItem
.text$mn:0000116B                 mov     edx, [ebp+var_4]
.text$mn:0000116E                 mov     eax, [edx+0Ch]
.text$mn:00001171                 push    eax             ; hDlg
.text$mn:00001172                 call    dword ptr ds:__imp__SendDlgItemMessageW@20 ; SendDlgItemMessageW(x,x,x,x,x)
.text$mn:00001178
.text$mn:00001178 loc_1178:                               ; CODE XREF: RunMacroDlg::check(int)+2Bj
.text$mn:00001178                 cmp     [ebp+arg_0], 1F42h
.text$mn:0000117F                 jnz     short loc_119E
.text$mn:00001181                 push    0               ; lParam
.text$mn:00001183                 push    1               ; wParam
.text$mn:00001185                 push    0F1h ; '±'      ; Msg
.text$mn:0000118A                 push    1F42h           ; nIDDlgItem
.text$mn:0000118F                 mov     ecx, [ebp+var_4]
.text$mn:00001192                 mov     edx, [ecx+0Ch]
.text$mn:00001195                 push    edx             ; hDlg
.text$mn:00001196                 call    dword ptr ds:__imp__SendDlgItemMessageW@20 ; SendDlgItemMessageW(x,x,x,x,x)
.text$mn:0000119C                 jmp     short loc_11B9
.text$mn:0000119E ; ---------------------------------------------------------------------------
.text$mn:0000119E
.text$mn:0000119E loc_119E:                               ; CODE XREF: RunMacroDlg::check(int)+4Fj
.text$mn:0000119E                 push    0               ; lParam
.text$mn:000011A0                 push    0               ; wParam
.text$mn:000011A2                 push    0F1h ; '±'      ; Msg
.text$mn:000011A7                 push    1F42h           ; nIDDlgItem
.text$mn:000011AC                 mov     eax, [ebp+var_4]
.text$mn:000011AF                 mov     ecx, [eax+0Ch]
.text$mn:000011B2                 push    ecx             ; hDlg
.text$mn:000011B3                 call    dword ptr ds:__imp__SendDlgItemMessageW@20 ; SendDlgItemMessageW(x,x,x,x,x)
.text$mn:000011B9
.text$mn:000011B9 loc_11B9:                               ; CODE XREF: RunMacroDlg::check(int)+6Cj
.text$mn:000011B9                 mov     esp, ebp
.text$mn:000011BB                 pop     ebp
.text$mn:000011BC                 retn    4
.text$mn:000011BC ?check@RunMacroDlg@@AAEXH@Z endp
.text$mn:000011BC
.text$mn:000011BC ; ---------------------------------------------------------------------------
.text$mn:000011BF                 align 10h
.text$mn:000011BF _text$mn        ends
.text$mn:000011BF
.text$mn:000011C0 ; ===========================================================================
.text$mn:000011C0
.text$mn:000011C0 ; Segment type: Pure code
.text$mn:000011C0 ; Segment permissions: Read/Execute
.text$mn:000011C0 _text$mn        segment para public 'CODE' use32
.text$mn:000011C0                 assume cs:_text$mn
.text$mn:000011C0                 ;org 11C0h
.text$mn:000011C0 ; COMDAT (pick any)
.text$mn:000011C0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000011C0
.text$mn:000011C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000011C0
.text$mn:000011C0 ; Attributes: bp-based frame
.text$mn:000011C0
.text$mn:000011C0 ; char * __cdecl std::_Allocate<char>(unsigned int, char *)
.text$mn:000011C0                 public ??$_Allocate@D@std@@YAPADIPAD@Z
.text$mn:000011C0 ??$_Allocate@D@std@@YAPADIPAD@Z proc near
.text$mn:000011C0                                         ; CODE XREF: std::allocator<char>::allocate(uint)+Dp
.text$mn:000011C0
.text$mn:000011C0 var_4           = dword ptr -4
.text$mn:000011C0 arg_0           = dword ptr  8
.text$mn:000011C0
.text$mn:000011C0                 push    ebp
.text$mn:000011C1                 mov     ebp, esp
.text$mn:000011C3                 push    ecx
.text$mn:000011C4                 mov     [ebp+var_4], 0
.text$mn:000011CB                 cmp     [ebp+arg_0], 0
.text$mn:000011CF                 jnz     short loc_11D3
.text$mn:000011D1                 jmp     short loc_11F3
.text$mn:000011D3 ; ---------------------------------------------------------------------------
.text$mn:000011D3
.text$mn:000011D3 loc_11D3:                               ; CODE XREF: std::_Allocate<char>(uint,char *)+Fj
.text$mn:000011D3                 cmp     [ebp+arg_0], 0FFFFFFFFh
.text$mn:000011D7                 ja      short loc_11EE
.text$mn:000011D9                 mov     eax, [ebp+arg_0]
.text$mn:000011DC                 push    eax             ; unsigned int
.text$mn:000011DD                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:000011E2                 add     esp, 4
.text$mn:000011E5                 mov     [ebp+var_4], eax
.text$mn:000011E8                 cmp     [ebp+var_4], 0
.text$mn:000011EC                 jnz     short loc_11F3
.text$mn:000011EE
.text$mn:000011EE loc_11EE:                               ; CODE XREF: std::_Allocate<char>(uint,char *)+17j
.text$mn:000011EE                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:000011F3
.text$mn:000011F3 loc_11F3:                               ; CODE XREF: std::_Allocate<char>(uint,char *)+11j
.text$mn:000011F3                                         ; std::_Allocate<char>(uint,char *)+2Cj
.text$mn:000011F3                 mov     eax, [ebp+var_4]
.text$mn:000011F6                 mov     esp, ebp
.text$mn:000011F8                 pop     ebp
.text$mn:000011F9                 retn
.text$mn:000011F9 ??$_Allocate@D@std@@YAPADIPAD@Z endp
.text$mn:000011F9
.text$mn:000011F9 ; ---------------------------------------------------------------------------
.text$mn:000011FA                 align 4
.text$mn:000011FA _text$mn        ends
.text$mn:000011FA
.text$mn:000011FC ; ===========================================================================
.text$mn:000011FC
.text$mn:000011FC ; Segment type: Pure code
.text$mn:000011FC ; Segment permissions: Read/Execute
.text$mn:000011FC _text$mn        segment para public 'CODE' use32
.text$mn:000011FC                 assume cs:_text$mn
.text$mn:000011FC                 ;org 11FCh
.text$mn:000011FC ; COMDAT (pick any)
.text$mn:000011FC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000011FC
.text$mn:000011FC ; =============== S U B R O U T I N E =======================================
.text$mn:000011FC
.text$mn:000011FC ; Attributes: bp-based frame
.text$mn:000011FC
.text$mn:000011FC ; struct std::_Container_proxy * __cdecl std::_Allocate<struct std::_Container_proxy>(unsigned int, struct std::_Container_proxy *)
.text$mn:000011FC                 public ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z
.text$mn:000011FC ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z proc near
.text$mn:000011FC                                         ; CODE XREF: std::allocator<std::_Container_proxy>::allocate(uint)+Dp
.text$mn:000011FC
.text$mn:000011FC var_4           = dword ptr -4
.text$mn:000011FC arg_0           = dword ptr  8
.text$mn:000011FC
.text$mn:000011FC                 push    ebp
.text$mn:000011FD                 mov     ebp, esp
.text$mn:000011FF                 push    ecx
.text$mn:00001200                 mov     [ebp+var_4], 0
.text$mn:00001207                 cmp     [ebp+arg_0], 0
.text$mn:0000120B                 jnz     short loc_120F
.text$mn:0000120D                 jmp     short loc_1235
.text$mn:0000120F ; ---------------------------------------------------------------------------
.text$mn:0000120F
.text$mn:0000120F loc_120F:                               ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+Fj
.text$mn:0000120F                 cmp     [ebp+arg_0], 1FFFFFFFh
.text$mn:00001216                 ja      short loc_1230
.text$mn:00001218                 mov     eax, [ebp+arg_0]
.text$mn:0000121B                 shl     eax, 3
.text$mn:0000121E                 push    eax             ; unsigned int
.text$mn:0000121F                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00001224                 add     esp, 4
.text$mn:00001227                 mov     [ebp+var_4], eax
.text$mn:0000122A                 cmp     [ebp+var_4], 0
.text$mn:0000122E                 jnz     short loc_1235
.text$mn:00001230
.text$mn:00001230 loc_1230:                               ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+1Aj
.text$mn:00001230                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:00001235
.text$mn:00001235 loc_1235:                               ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+11j
.text$mn:00001235                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+32j
.text$mn:00001235                 mov     eax, [ebp+var_4]
.text$mn:00001238                 mov     esp, ebp
.text$mn:0000123A                 pop     ebp
.text$mn:0000123B                 retn
.text$mn:0000123B ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z endp
.text$mn:0000123B
.text$mn:0000123B _text$mn        ends
.text$mn:0000123B
.text$mn:0000123C ; ===========================================================================
.text$mn:0000123C
.text$mn:0000123C ; Segment type: Pure code
.text$mn:0000123C ; Segment permissions: Read/Execute
.text$mn:0000123C _text$mn        segment para public 'CODE' use32
.text$mn:0000123C                 assume cs:_text$mn
.text$mn:0000123C                 ;org 123Ch
.text$mn:0000123C ; COMDAT (pick any)
.text$mn:0000123C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000123C
.text$mn:0000123C ; =============== S U B R O U T I N E =======================================
.text$mn:0000123C
.text$mn:0000123C ; Attributes: bp-based frame
.text$mn:0000123C
.text$mn:0000123C ; int __cdecl std::_Debug_pointer<char>(int, wchar_t *, unsigned int)
.text$mn:0000123C                 public ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z
.text$mn:0000123C ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z proc near
.text$mn:0000123C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+15p
.text$mn:0000123C                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+1Bp
.text$mn:0000123C
.text$mn:0000123C arg_0           = dword ptr  8
.text$mn:0000123C arg_4           = dword ptr  0Ch
.text$mn:0000123C arg_8           = dword ptr  10h
.text$mn:0000123C
.text$mn:0000123C                 push    ebp
.text$mn:0000123D                 mov     ebp, esp
.text$mn:0000123F                 cmp     [ebp+arg_0], 0
.text$mn:00001243                 jnz     short loc_125A
.text$mn:00001245                 mov     eax, [ebp+arg_8]
.text$mn:00001248                 push    eax             ; unsigned int
.text$mn:00001249                 mov     ecx, [ebp+arg_4]
.text$mn:0000124C                 push    ecx             ; wchar_t *
.text$mn:0000124D                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:00001252                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00001257                 add     esp, 0Ch
.text$mn:0000125A
.text$mn:0000125A loc_125A:                               ; CODE XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+7j
.text$mn:0000125A                 pop     ebp
.text$mn:0000125B                 retn
.text$mn:0000125B ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z endp
.text$mn:0000125B
.text$mn:0000125B _text$mn        ends
.text$mn:0000125B
.text$mn:0000125C ; ===========================================================================
.text$mn:0000125C
.text$mn:0000125C ; Segment type: Pure code
.text$mn:0000125C ; Segment permissions: Read/Execute
.text$mn:0000125C _text$mn        segment para public 'CODE' use32
.text$mn:0000125C                 assume cs:_text$mn
.text$mn:0000125C                 ;org 125Ch
.text$mn:0000125C ; COMDAT (pick any)
.text$mn:0000125C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000125C
.text$mn:0000125C ; =============== S U B R O U T I N E =======================================
.text$mn:0000125C
.text$mn:0000125C ; Attributes: bp-based frame
.text$mn:0000125C
.text$mn:0000125C ; char * __cdecl std::addressof<char>(char &)
.text$mn:0000125C                 public ??$addressof@D@std@@YAPADAAD@Z
.text$mn:0000125C ??$addressof@D@std@@YAPADAAD@Z proc near
.text$mn:0000125C                                         ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+19p
.text$mn:0000125C                                         ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)+19p ...
.text$mn:0000125C
.text$mn:0000125C arg_0           = dword ptr  8
.text$mn:0000125C
.text$mn:0000125C                 push    ebp
.text$mn:0000125D                 mov     ebp, esp
.text$mn:0000125F                 mov     eax, [ebp+arg_0]
.text$mn:00001262                 pop     ebp
.text$mn:00001263                 retn
.text$mn:00001263 ??$addressof@D@std@@YAPADAAD@Z endp
.text$mn:00001263
.text$mn:00001263 _text$mn        ends
.text$mn:00001263
.text$mn:00001264 ; ===========================================================================
.text$mn:00001264
.text$mn:00001264 ; Segment type: Pure code
.text$mn:00001264 ; Segment permissions: Read/Execute
.text$mn:00001264 _text$mn        segment para public 'CODE' use32
.text$mn:00001264                 assume cs:_text$mn
.text$mn:00001264                 ;org 1264h
.text$mn:00001264 ; COMDAT (pick any)
.text$mn:00001264                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001264
.text$mn:00001264 ; =============== S U B R O U T I N E =======================================
.text$mn:00001264
.text$mn:00001264 ; Attributes: bp-based frame
.text$mn:00001264
.text$mn:00001264 ; int __stdcall std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(void *, int)
.text$mn:00001264                 public ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
.text$mn:00001264 ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z proc near
.text$mn:00001264                                         ; CODE XREF: $LN19+4Bp
.text$mn:00001264
.text$mn:00001264 var_4           = dword ptr -4
.text$mn:00001264 arg_0           = dword ptr  8
.text$mn:00001264 arg_4           = dword ptr  0Ch
.text$mn:00001264
.text$mn:00001264                 push    ebp
.text$mn:00001265                 mov     ebp, esp
.text$mn:00001267                 push    ecx
.text$mn:00001268                 mov     [ebp+var_4], ecx
.text$mn:0000126B                 mov     eax, [ebp+arg_4]
.text$mn:0000126E                 push    eax
.text$mn:0000126F                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:00001274                 add     esp, 4
.text$mn:00001277                 push    eax             ; int
.text$mn:00001278                 mov     ecx, [ebp+arg_0]
.text$mn:0000127B                 push    ecx             ; void *
.text$mn:0000127C                 mov     edx, [ebp+var_4]
.text$mn:0000127F                 push    edx             ; int
.text$mn:00001280                 call    ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(std::allocator<char> &,char * *,char * &)
.text$mn:00001285                 add     esp, 0Ch
.text$mn:00001288                 mov     esp, ebp
.text$mn:0000128A                 pop     ebp
.text$mn:0000128B                 retn    8
.text$mn:0000128B ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z endp
.text$mn:0000128B
.text$mn:0000128B ; ---------------------------------------------------------------------------
.text$mn:0000128E                 align 10h
.text$mn:0000128E _text$mn        ends
.text$mn:0000128E
.text$mn:00001290 ; ===========================================================================
.text$mn:00001290
.text$mn:00001290 ; Segment type: Pure code
.text$mn:00001290 ; Segment permissions: Read/Execute
.text$mn:00001290 _text$mn        segment para public 'CODE' use32
.text$mn:00001290                 assume cs:_text$mn
.text$mn:00001290                 ;org 1290h
.text$mn:00001290 ; COMDAT (pick any)
.text$mn:00001290                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001290
.text$mn:00001290 ; =============== S U B R O U T I N E =======================================
.text$mn:00001290
.text$mn:00001290 ; Attributes: bp-based frame
.text$mn:00001290
.text$mn:00001290 ; int __stdcall std::allocator<char>::construct<char *,char * &>(void *, int)
.text$mn:00001290                 public ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$mn:00001290 ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
.text$mn:00001290                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(std::allocator<char> &,char * *,char * &)+17p
.text$mn:00001290
.text$mn:00001290 var_1C          = dword ptr -1Ch
.text$mn:00001290 var_18          = dword ptr -18h
.text$mn:00001290 var_14          = dword ptr -14h
.text$mn:00001290 var_10          = dword ptr -10h
.text$mn:00001290 var_C           = dword ptr -0Ch
.text$mn:00001290 var_4           = dword ptr -4
.text$mn:00001290 arg_0           = dword ptr  8
.text$mn:00001290 arg_4           = dword ptr  0Ch
.text$mn:00001290
.text$mn:00001290                 push    ebp
.text$mn:00001291                 mov     ebp, esp
.text$mn:00001293                 push    0FFFFFFFFh
.text$mn:00001295                 push    offset __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$mn:0000129A                 mov     eax, large fs:0
.text$mn:000012A0                 push    eax
.text$mn:000012A1                 sub     esp, 10h
.text$mn:000012A4                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000012A9                 xor     eax, ebp
.text$mn:000012AB                 push    eax
.text$mn:000012AC                 lea     eax, [ebp+var_C]
.text$mn:000012AF                 mov     large fs:0, eax
.text$mn:000012B5                 mov     [ebp+var_18], ecx
.text$mn:000012B8                 mov     eax, [ebp+arg_0]
.text$mn:000012BB                 push    eax             ; void *
.text$mn:000012BC                 push    4               ; unsigned int
.text$mn:000012BE                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:000012C3                 add     esp, 8
.text$mn:000012C6                 mov     [ebp+var_10], eax
.text$mn:000012C9                 mov     [ebp+var_4], 0
.text$mn:000012D0                 cmp     [ebp+var_10], 0
.text$mn:000012D4                 jz      short loc_12F1
.text$mn:000012D6                 mov     ecx, [ebp+arg_4]
.text$mn:000012D9                 push    ecx
.text$mn:000012DA                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:000012DF                 add     esp, 4
.text$mn:000012E2                 mov     edx, [ebp+var_10]
.text$mn:000012E5                 mov     eax, [eax]
.text$mn:000012E7                 mov     [edx], eax
.text$mn:000012E9                 mov     ecx, [ebp+var_10]
.text$mn:000012EC                 mov     [ebp+var_14], ecx
.text$mn:000012EF                 jmp     short loc_12F8
.text$mn:000012F1 ; ---------------------------------------------------------------------------
.text$mn:000012F1
.text$mn:000012F1 loc_12F1:                               ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+44j
.text$mn:000012F1                 mov     [ebp+var_14], 0
.text$mn:000012F8
.text$mn:000012F8 loc_12F8:                               ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+5Fj
.text$mn:000012F8                 mov     edx, [ebp+var_14]
.text$mn:000012FB                 mov     [ebp+var_1C], edx
.text$mn:000012FE                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001305                 mov     ecx, [ebp+var_C]
.text$mn:00001308                 mov     large fs:0, ecx
.text$mn:0000130F                 pop     ecx
.text$mn:00001310                 mov     esp, ebp
.text$mn:00001312                 pop     ebp
.text$mn:00001313                 retn    8
.text$mn:00001313 ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp
.text$mn:00001313
.text$mn:00001313 ; ---------------------------------------------------------------------------
.text$mn:00001316                 align 4
.text$mn:00001316 _text$mn        ends
.text$mn:00001316
.text$x:00001318 ; ===========================================================================
.text$x:00001318
.text$x:00001318 ; Segment type: Pure code
.text$x:00001318 ; Segment permissions: Read/Execute
.text$x:00001318 _text$x         segment para public 'CODE' use32
.text$x:00001318                 assume cs:_text$x
.text$x:00001318                 ;org 1318h
.text$x:00001318 ; COMDAT (pick associative to section at 1290)
.text$x:00001318                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00001318
.text$x:00001318 ; =============== S U B R O U T I N E =======================================
.text$x:00001318
.text$x:00001318
.text$x:00001318 __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 proc near
.text$x:00001318                                         ; DATA XREF: .xdata$x:00002FACo
.text$x:00001318                 mov     eax, [ebp+8]
.text$x:0000131B                 push    eax
.text$x:0000131C                 mov     eax, [ebp-10h]
.text$x:0000131F                 push    eax             ; void *
.text$x:00001320                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00001325                 add     esp, 8
.text$x:00001328                 retn
.text$x:00001328 __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 endp
.text$x:00001328
.text$x:00001329
.text$x:00001329 ; =============== S U B R O U T I N E =======================================
.text$x:00001329
.text$x:00001329
.text$x:00001329 __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
.text$x:00001329                                         ; DATA XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+5o
.text$x:00001329
.text$x:00001329 arg_4           = dword ptr  8
.text$x:00001329
.text$x:00001329                 mov     edx, [esp+arg_4]
.text$x:0000132D                 lea     eax, [edx+0Ch]
.text$x:00001330                 mov     ecx, [edx-14h]
.text$x:00001333                 xor     ecx, eax
.text$x:00001335                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000133A                 mov     eax, offset __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$x:0000133F                 jmp     ___CxxFrameHandler3
.text$x:0000133F __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp
.text$x:0000133F
.text$x:0000133F _text$x         ends
.text$x:0000133F
.text$mn:00001344 ; ===========================================================================
.text$mn:00001344
.text$mn:00001344 ; Segment type: Pure code
.text$mn:00001344 ; Segment permissions: Read/Execute
.text$mn:00001344 _text$mn        segment para public 'CODE' use32
.text$mn:00001344                 assume cs:_text$mn
.text$mn:00001344                 ;org 1344h
.text$mn:00001344 ; COMDAT (pick any)
.text$mn:00001344                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001344
.text$mn:00001344 ; =============== S U B R O U T I N E =======================================
.text$mn:00001344
.text$mn:00001344 ; Attributes: bp-based frame
.text$mn:00001344
.text$mn:00001344 ; int __cdecl std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(int, void *, int)
.text$mn:00001344                 public ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
.text$mn:00001344 ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z proc near
.text$mn:00001344                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)+1Cp
.text$mn:00001344
.text$mn:00001344 arg_0           = dword ptr  8
.text$mn:00001344 arg_4           = dword ptr  0Ch
.text$mn:00001344 arg_8           = dword ptr  10h
.text$mn:00001344
.text$mn:00001344                 push    ebp
.text$mn:00001345                 mov     ebp, esp
.text$mn:00001347                 mov     eax, [ebp+arg_8]
.text$mn:0000134A                 push    eax
.text$mn:0000134B                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:00001350                 add     esp, 4
.text$mn:00001353                 push    eax             ; int
.text$mn:00001354                 mov     ecx, [ebp+arg_4]
.text$mn:00001357                 push    ecx             ; void *
.text$mn:00001358                 mov     ecx, [ebp+arg_0]
.text$mn:0000135B                 call    ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)
.text$mn:00001360                 pop     ebp
.text$mn:00001361                 retn
.text$mn:00001361 ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z endp
.text$mn:00001361
.text$mn:00001361 ; ---------------------------------------------------------------------------
.text$mn:00001362                 align 4
.text$mn:00001362 _text$mn        ends
.text$mn:00001362
.text$mn:00001364 ; ===========================================================================
.text$mn:00001364
.text$mn:00001364 ; Segment type: Pure code
.text$mn:00001364 ; Segment permissions: Read/Execute
.text$mn:00001364 _text$mn        segment para public 'CODE' use32
.text$mn:00001364                 assume cs:_text$mn
.text$mn:00001364                 ;org 1364h
.text$mn:00001364 ; COMDAT (pick any)
.text$mn:00001364                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001364
.text$mn:00001364 ; =============== S U B R O U T I N E =======================================
.text$mn:00001364
.text$mn:00001364 ; Attributes: bp-based frame
.text$mn:00001364
.text$mn:00001364 ; int __stdcall std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(void *, int)
.text$mn:00001364                 public ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:00001364 ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$mn:00001364                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+32p
.text$mn:00001364
.text$mn:00001364 var_1C          = dword ptr -1Ch
.text$mn:00001364 var_18          = dword ptr -18h
.text$mn:00001364 var_14          = dword ptr -14h
.text$mn:00001364 var_10          = dword ptr -10h
.text$mn:00001364 var_C           = dword ptr -0Ch
.text$mn:00001364 var_4           = dword ptr -4
.text$mn:00001364 arg_0           = dword ptr  8
.text$mn:00001364 arg_4           = dword ptr  0Ch
.text$mn:00001364
.text$mn:00001364                 push    ebp
.text$mn:00001365                 mov     ebp, esp
.text$mn:00001367                 push    0FFFFFFFFh
.text$mn:00001369                 push    offset __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:0000136E                 mov     eax, large fs:0
.text$mn:00001374                 push    eax
.text$mn:00001375                 sub     esp, 10h
.text$mn:00001378                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000137D                 xor     eax, ebp
.text$mn:0000137F                 push    eax
.text$mn:00001380                 lea     eax, [ebp+var_C]
.text$mn:00001383                 mov     large fs:0, eax
.text$mn:00001389                 mov     [ebp+var_18], ecx
.text$mn:0000138C                 mov     eax, [ebp+arg_0]
.text$mn:0000138F                 push    eax             ; void *
.text$mn:00001390                 push    8               ; unsigned int
.text$mn:00001392                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00001397                 add     esp, 8
.text$mn:0000139A                 mov     [ebp+var_10], eax
.text$mn:0000139D                 mov     [ebp+var_4], 0
.text$mn:000013A4                 cmp     [ebp+var_10], 0
.text$mn:000013A8                 jz      short loc_13CB
.text$mn:000013AA                 mov     ecx, [ebp+arg_4]
.text$mn:000013AD                 push    ecx
.text$mn:000013AE                 call    ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>(std::_Container_proxy &)
.text$mn:000013B3                 add     esp, 4
.text$mn:000013B6                 mov     edx, [eax]
.text$mn:000013B8                 mov     eax, [eax+4]
.text$mn:000013BB                 mov     ecx, [ebp+var_10]
.text$mn:000013BE                 mov     [ecx], edx
.text$mn:000013C0                 mov     [ecx+4], eax
.text$mn:000013C3                 mov     edx, [ebp+var_10]
.text$mn:000013C6                 mov     [ebp+var_14], edx
.text$mn:000013C9                 jmp     short loc_13D2
.text$mn:000013CB ; ---------------------------------------------------------------------------
.text$mn:000013CB
.text$mn:000013CB loc_13CB:                               ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+44j
.text$mn:000013CB                 mov     [ebp+var_14], 0
.text$mn:000013D2
.text$mn:000013D2 loc_13D2:                               ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+65j
.text$mn:000013D2                 mov     eax, [ebp+var_14]
.text$mn:000013D5                 mov     [ebp+var_1C], eax
.text$mn:000013D8                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000013DF                 mov     ecx, [ebp+var_C]
.text$mn:000013E2                 mov     large fs:0, ecx
.text$mn:000013E9                 pop     ecx
.text$mn:000013EA                 mov     esp, ebp
.text$mn:000013EC                 pop     ebp
.text$mn:000013ED                 retn    8
.text$mn:000013ED ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$mn:000013ED
.text$mn:000013ED _text$mn        ends
.text$mn:000013ED
.text$x:000013F0 ; ===========================================================================
.text$x:000013F0
.text$x:000013F0 ; Segment type: Pure code
.text$x:000013F0 ; Segment permissions: Read/Execute
.text$x:000013F0 _text$x         segment para public 'CODE' use32
.text$x:000013F0                 assume cs:_text$x
.text$x:000013F0                 ;org 13F0h
.text$x:000013F0 ; COMDAT (pick associative to section at 1364)
.text$x:000013F0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000013F0
.text$x:000013F0 ; =============== S U B R O U T I N E =======================================
.text$x:000013F0
.text$x:000013F0
.text$x:000013F0 __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 proc near
.text$x:000013F0                                         ; DATA XREF: .xdata$x:00002F80o
.text$x:000013F0                 mov     eax, [ebp+8]
.text$x:000013F3                 push    eax
.text$x:000013F4                 mov     eax, [ebp-10h]
.text$x:000013F7                 push    eax             ; void *
.text$x:000013F8                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:000013FD                 add     esp, 8
.text$x:00001400                 retn
.text$x:00001400 __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 endp
.text$x:00001400
.text$x:00001401
.text$x:00001401 ; =============== S U B R O U T I N E =======================================
.text$x:00001401
.text$x:00001401
.text$x:00001401 __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$x:00001401                                         ; DATA XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+5o
.text$x:00001401
.text$x:00001401 arg_4           = dword ptr  8
.text$x:00001401
.text$x:00001401                 mov     edx, [esp+arg_4]
.text$x:00001405                 lea     eax, [edx+0Ch]
.text$x:00001408                 mov     ecx, [edx-14h]
.text$x:0000140B                 xor     ecx, eax
.text$x:0000140D                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001412                 mov     eax, offset __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$x:00001417                 jmp     ___CxxFrameHandler3
.text$x:00001417 __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$x:00001417
.text$x:00001417 _text$x         ends
.text$x:00001417
.text$mn:0000141C ; ===========================================================================
.text$mn:0000141C
.text$mn:0000141C ; Segment type: Pure code
.text$mn:0000141C ; Segment permissions: Read/Execute
.text$mn:0000141C _text$mn        segment para public 'CODE' use32
.text$mn:0000141C                 assume cs:_text$mn
.text$mn:0000141C                 ;org 141Ch
.text$mn:0000141C ; COMDAT (pick any)
.text$mn:0000141C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000141C
.text$mn:0000141C ; =============== S U B R O U T I N E =======================================
.text$mn:0000141C
.text$mn:0000141C ; Attributes: bp-based frame
.text$mn:0000141C
.text$mn:0000141C ; public: void __thiscall std::_Wrap_alloc<class std::allocator<char>>::destroy<char *>(char * *)
.text$mn:0000141C                 public ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
.text$mn:0000141C ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z proc near
.text$mn:0000141C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+3Ap
.text$mn:0000141C
.text$mn:0000141C var_4           = dword ptr -4
.text$mn:0000141C arg_0           = dword ptr  8
.text$mn:0000141C
.text$mn:0000141C                 push    ebp
.text$mn:0000141D                 mov     ebp, esp
.text$mn:0000141F                 push    ecx
.text$mn:00001420                 mov     [ebp+var_4], ecx
.text$mn:00001423                 mov     eax, [ebp+arg_0]
.text$mn:00001426                 push    eax
.text$mn:00001427                 mov     ecx, [ebp+var_4]
.text$mn:0000142A                 push    ecx
.text$mn:0000142B                 call    ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char * *)
.text$mn:00001430                 add     esp, 8
.text$mn:00001433                 mov     esp, ebp
.text$mn:00001435                 pop     ebp
.text$mn:00001436                 retn    4
.text$mn:00001436 ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z endp
.text$mn:00001436
.text$mn:00001436 ; ---------------------------------------------------------------------------
.text$mn:00001439                 align 4
.text$mn:00001439 _text$mn        ends
.text$mn:00001439
.text$mn:0000143C ; ===========================================================================
.text$mn:0000143C
.text$mn:0000143C ; Segment type: Pure code
.text$mn:0000143C ; Segment permissions: Read/Execute
.text$mn:0000143C _text$mn        segment para public 'CODE' use32
.text$mn:0000143C                 assume cs:_text$mn
.text$mn:0000143C                 ;org 143Ch
.text$mn:0000143C ; COMDAT (pick any)
.text$mn:0000143C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000143C
.text$mn:0000143C ; =============== S U B R O U T I N E =======================================
.text$mn:0000143C
.text$mn:0000143C ; Attributes: bp-based frame
.text$mn:0000143C
.text$mn:0000143C ; public: void __thiscall std::allocator<char>::destroy<char *>(char * *)
.text$mn:0000143C                 public ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
.text$mn:0000143C ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z proc near
.text$mn:0000143C                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char * *)+Ap
.text$mn:0000143C
.text$mn:0000143C var_4           = dword ptr -4
.text$mn:0000143C
.text$mn:0000143C                 push    ebp
.text$mn:0000143D                 mov     ebp, esp
.text$mn:0000143F                 push    ecx
.text$mn:00001440                 mov     [ebp+var_4], ecx
.text$mn:00001443                 mov     esp, ebp
.text$mn:00001445                 pop     ebp
.text$mn:00001446                 retn    4
.text$mn:00001446 ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z endp
.text$mn:00001446
.text$mn:00001446 ; ---------------------------------------------------------------------------
.text$mn:00001449                 align 4
.text$mn:00001449 _text$mn        ends
.text$mn:00001449
.text$mn:0000144C ; ===========================================================================
.text$mn:0000144C
.text$mn:0000144C ; Segment type: Pure code
.text$mn:0000144C ; Segment permissions: Read/Execute
.text$mn:0000144C _text$mn        segment para public 'CODE' use32
.text$mn:0000144C                 assume cs:_text$mn
.text$mn:0000144C                 ;org 144Ch
.text$mn:0000144C ; COMDAT (pick any)
.text$mn:0000144C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000144C
.text$mn:0000144C ; =============== S U B R O U T I N E =======================================
.text$mn:0000144C
.text$mn:0000144C ; Attributes: bp-based frame
.text$mn:0000144C
.text$mn:0000144C ; public: static void __cdecl std::allocator_traits<class std::allocator<char>>::destroy<char *>(class std::allocator<char> &, char * *)
.text$mn:0000144C                 public ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
.text$mn:0000144C ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z proc near
.text$mn:0000144C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)+Fp
.text$mn:0000144C
.text$mn:0000144C arg_0           = dword ptr  8
.text$mn:0000144C arg_4           = dword ptr  0Ch
.text$mn:0000144C
.text$mn:0000144C                 push    ebp
.text$mn:0000144D                 mov     ebp, esp
.text$mn:0000144F                 mov     eax, [ebp+arg_4]
.text$mn:00001452                 push    eax
.text$mn:00001453                 mov     ecx, [ebp+arg_0]
.text$mn:00001456                 call    ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ; std::allocator<char>::destroy<char *>(char * *)
.text$mn:0000145B                 pop     ebp
.text$mn:0000145C                 retn
.text$mn:0000145C ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z endp
.text$mn:0000145C
.text$mn:0000145C ; ---------------------------------------------------------------------------
.text$mn:0000145D                 align 10h
.text$mn:0000145D _text$mn        ends
.text$mn:0000145D
.text$mn:00001460 ; ===========================================================================
.text$mn:00001460
.text$mn:00001460 ; Segment type: Pure code
.text$mn:00001460 ; Segment permissions: Read/Execute
.text$mn:00001460 _text$mn        segment para public 'CODE' use32
.text$mn:00001460                 assume cs:_text$mn
.text$mn:00001460                 ;org 1460h
.text$mn:00001460 ; COMDAT (pick any)
.text$mn:00001460                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001460
.text$mn:00001460 ; =============== S U B R O U T I N E =======================================
.text$mn:00001460
.text$mn:00001460 ; Attributes: bp-based frame
.text$mn:00001460
.text$mn:00001460 ; public: void __thiscall std::allocator<struct std::_Container_proxy>::destroy<struct std::_Container_proxy>(struct std::_Container_proxy *)
.text$mn:00001460                 public ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z
.text$mn:00001460 ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z proc near
.text$mn:00001460                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+22p
.text$mn:00001460
.text$mn:00001460 var_4           = dword ptr -4
.text$mn:00001460
.text$mn:00001460                 push    ebp
.text$mn:00001461                 mov     ebp, esp
.text$mn:00001463                 push    ecx
.text$mn:00001464                 mov     [ebp+var_4], ecx
.text$mn:00001467                 mov     esp, ebp
.text$mn:00001469                 pop     ebp
.text$mn:0000146A                 retn    4
.text$mn:0000146A ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z endp
.text$mn:0000146A
.text$mn:0000146A ; ---------------------------------------------------------------------------
.text$mn:0000146D                 align 10h
.text$mn:0000146D _text$mn        ends
.text$mn:0000146D
.text$mn:00001470 ; ===========================================================================
.text$mn:00001470
.text$mn:00001470 ; Segment type: Pure code
.text$mn:00001470 ; Segment permissions: Read/Execute
.text$mn:00001470 _text$mn        segment para public 'CODE' use32
.text$mn:00001470                 assume cs:_text$mn
.text$mn:00001470                 ;org 1470h
.text$mn:00001470 ; COMDAT (pick any)
.text$mn:00001470                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001470
.text$mn:00001470 ; =============== S U B R O U T I N E =======================================
.text$mn:00001470
.text$mn:00001470 ; Attributes: bp-based frame
.text$mn:00001470
.text$mn:00001470 ; char * & __cdecl std::forward<char * &>(char * &)
.text$mn:00001470                 public ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
.text$mn:00001470 ??$forward@AAPAD@std@@YAAAPADAAPAD@Z proc near
.text$mn:00001470                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)+Bp
.text$mn:00001470                                         ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)+4Ap ...
.text$mn:00001470
.text$mn:00001470 arg_0           = dword ptr  8
.text$mn:00001470
.text$mn:00001470                 push    ebp
.text$mn:00001471                 mov     ebp, esp
.text$mn:00001473                 mov     eax, [ebp+arg_0]
.text$mn:00001476                 pop     ebp
.text$mn:00001477                 retn
.text$mn:00001477 ??$forward@AAPAD@std@@YAAAPADAAPAD@Z endp
.text$mn:00001477
.text$mn:00001477 _text$mn        ends
.text$mn:00001477
.text$mn:00001478 ; ===========================================================================
.text$mn:00001478
.text$mn:00001478 ; Segment type: Pure code
.text$mn:00001478 ; Segment permissions: Read/Execute
.text$mn:00001478 _text$mn        segment para public 'CODE' use32
.text$mn:00001478                 assume cs:_text$mn
.text$mn:00001478                 ;org 1478h
.text$mn:00001478 ; COMDAT (pick any)
.text$mn:00001478                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001478
.text$mn:00001478 ; =============== S U B R O U T I N E =======================================
.text$mn:00001478
.text$mn:00001478 ; Attributes: bp-based frame
.text$mn:00001478
.text$mn:00001478 ; struct std::_Container_proxy && __cdecl std::forward<struct std::_Container_proxy>(struct std::_Container_proxy &)
.text$mn:00001478                 public ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z
.text$mn:00001478 ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z proc near
.text$mn:00001478                                         ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+4Ap
.text$mn:00001478
.text$mn:00001478 arg_0           = dword ptr  8
.text$mn:00001478
.text$mn:00001478                 push    ebp
.text$mn:00001479                 mov     ebp, esp
.text$mn:0000147B                 mov     eax, [ebp+arg_0]
.text$mn:0000147E                 pop     ebp
.text$mn:0000147F                 retn
.text$mn:0000147F ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z endp
.text$mn:0000147F
.text$mn:0000147F _text$mn        ends
.text$mn:0000147F
.text$mn:00001480 ; ===========================================================================
.text$mn:00001480
.text$mn:00001480 ; Segment type: Pure code
.text$mn:00001480 ; Segment permissions: Read/Execute
.text$mn:00001480 _text$mn        segment para public 'CODE' use32
.text$mn:00001480                 assume cs:_text$mn
.text$mn:00001480                 ;org 1480h
.text$mn:00001480 ; COMDAT (pick any)
.text$mn:00001480                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001480
.text$mn:00001480 ; =============== S U B R O U T I N E =======================================
.text$mn:00001480
.text$mn:00001480 ; Attributes: bp-based frame
.text$mn:00001480
.text$mn:00001480 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>(class std::allocator<char> const &)
.text$mn:00001480                 public ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$mn:00001480 ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
.text$mn:00001480                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+34p
.text$mn:00001480
.text$mn:00001480 var_10          = dword ptr -10h
.text$mn:00001480 var_C           = dword ptr -0Ch
.text$mn:00001480 var_4           = dword ptr -4
.text$mn:00001480
.text$mn:00001480                 push    ebp
.text$mn:00001481                 mov     ebp, esp
.text$mn:00001483                 push    0FFFFFFFFh
.text$mn:00001485                 push    offset __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$mn:0000148A                 mov     eax, large fs:0
.text$mn:00001490                 push    eax
.text$mn:00001491                 push    ecx
.text$mn:00001492                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001497                 xor     eax, ebp
.text$mn:00001499                 push    eax
.text$mn:0000149A                 lea     eax, [ebp+var_C]
.text$mn:0000149D                 mov     large fs:0, eax
.text$mn:000014A3                 mov     [ebp+var_10], ecx
.text$mn:000014A6                 mov     ecx, [ebp+var_10]
.text$mn:000014A9                 call    ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)
.text$mn:000014AE                 mov     [ebp+var_4], 0
.text$mn:000014B5                 mov     ecx, [ebp+var_10]
.text$mn:000014B8                 call    ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)
.text$mn:000014BD                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000014C4                 mov     eax, [ebp+var_10]
.text$mn:000014C7                 mov     ecx, [ebp+var_C]
.text$mn:000014CA                 mov     large fs:0, ecx
.text$mn:000014D1                 pop     ecx
.text$mn:000014D2                 mov     esp, ebp
.text$mn:000014D4                 pop     ebp
.text$mn:000014D5                 retn    4
.text$mn:000014D5 ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp
.text$mn:000014D5
.text$mn:000014D5 _text$mn        ends
.text$mn:000014D5
.text$x:000014D8 ; ===========================================================================
.text$x:000014D8
.text$x:000014D8 ; Segment type: Pure code
.text$x:000014D8 ; Segment permissions: Read/Execute
.text$x:000014D8 _text$x         segment para public 'CODE' use32
.text$x:000014D8                 assume cs:_text$x
.text$x:000014D8                 ;org 14D8h
.text$x:000014D8 ; COMDAT (pick associative to section at 1480)
.text$x:000014D8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000014D8
.text$x:000014D8 ; =============== S U B R O U T I N E =======================================
.text$x:000014D8
.text$x:000014D8
.text$x:000014D8 __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 proc near
.text$x:000014D8                                         ; DATA XREF: .xdata$x:00002CB8o
.text$x:000014D8                 mov     ecx, [ebp-10h]
.text$x:000014DB                 jmp     ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$x:000014DB __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 endp
.text$x:000014DB
.text$x:000014E0
.text$x:000014E0 ; =============== S U B R O U T I N E =======================================
.text$x:000014E0
.text$x:000014E0
.text$x:000014E0 __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
.text$x:000014E0                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+5o
.text$x:000014E0
.text$x:000014E0 arg_4           = dword ptr  8
.text$x:000014E0
.text$x:000014E0                 mov     edx, [esp+arg_4]
.text$x:000014E4                 lea     eax, [edx+0Ch]
.text$x:000014E7                 mov     ecx, [edx-8]
.text$x:000014EA                 xor     ecx, eax
.text$x:000014EC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000014F1                 mov     eax, offset __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$x:000014F6                 jmp     ___CxxFrameHandler3
.text$x:000014F6 __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp
.text$x:000014F6
.text$x:000014F6 ; ---------------------------------------------------------------------------
.text$x:000014FB                 align 4
.text$x:000014FB _text$x         ends
.text$x:000014FB
.text$mn:000014FC ; ===========================================================================
.text$mn:000014FC
.text$mn:000014FC ; Segment type: Pure code
.text$mn:000014FC ; Segment permissions: Read/Execute
.text$mn:000014FC _text$mn        segment para public 'CODE' use32
.text$mn:000014FC                 assume cs:_text$mn
.text$mn:000014FC                 ;org 14FCh
.text$mn:000014FC ; COMDAT (pick any)
.text$mn:000014FC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000014FC
.text$mn:000014FC ; =============== S U B R O U T I N E =======================================
.text$mn:000014FC
.text$mn:000014FC ; Attributes: bp-based frame
.text$mn:000014FC
.text$mn:000014FC ; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::_String_val<struct std::_Simple_types<char>>(void)
.text$mn:000014FC                 public ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:000014FC ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$mn:000014FC                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+29p
.text$mn:000014FC
.text$mn:000014FC var_10          = dword ptr -10h
.text$mn:000014FC var_C           = dword ptr -0Ch
.text$mn:000014FC var_4           = dword ptr -4
.text$mn:000014FC
.text$mn:000014FC                 push    ebp
.text$mn:000014FD                 mov     ebp, esp
.text$mn:000014FF                 push    0FFFFFFFFh
.text$mn:00001501                 push    offset __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00001506                 mov     eax, large fs:0
.text$mn:0000150C                 push    eax
.text$mn:0000150D                 push    ecx
.text$mn:0000150E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001513                 xor     eax, ebp
.text$mn:00001515                 push    eax
.text$mn:00001516                 lea     eax, [ebp+var_C]
.text$mn:00001519                 mov     large fs:0, eax
.text$mn:0000151F                 mov     [ebp+var_10], ecx
.text$mn:00001522                 mov     ecx, [ebp+var_10] ; this
.text$mn:00001525                 call    ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
.text$mn:0000152A                 mov     [ebp+var_4], 0
.text$mn:00001531                 mov     eax, [ebp+var_10]
.text$mn:00001534                 mov     dword ptr [eax+14h], 0
.text$mn:0000153B                 mov     ecx, [ebp+var_10]
.text$mn:0000153E                 mov     dword ptr [ecx+18h], 0
.text$mn:00001545                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000154C                 mov     eax, [ebp+var_10]
.text$mn:0000154F                 mov     ecx, [ebp+var_C]
.text$mn:00001552                 mov     large fs:0, ecx
.text$mn:00001559                 pop     ecx
.text$mn:0000155A                 mov     esp, ebp
.text$mn:0000155C                 pop     ebp
.text$mn:0000155D                 retn
.text$mn:0000155D ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$mn:0000155D
.text$mn:0000155D ; ---------------------------------------------------------------------------
.text$mn:0000155E                 align 10h
.text$mn:0000155E _text$mn        ends
.text$mn:0000155E
.text$x:00001560 ; ===========================================================================
.text$x:00001560
.text$x:00001560 ; Segment type: Pure code
.text$x:00001560 ; Segment permissions: Read/Execute
.text$x:00001560 _text$x         segment para public 'CODE' use32
.text$x:00001560                 assume cs:_text$x
.text$x:00001560                 ;org 1560h
.text$x:00001560 ; COMDAT (pick associative to section at 14FC)
.text$x:00001560                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00001560
.text$x:00001560 ; =============== S U B R O U T I N E =======================================
.text$x:00001560
.text$x:00001560
.text$x:00001560 __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 proc near
.text$x:00001560                                         ; DATA XREF: .xdata$x:00002C60o
.text$x:00001560                 mov     ecx, [ebp-10h]  ; this
.text$x:00001563                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00001563 __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 endp
.text$x:00001563
.text$x:00001568
.text$x:00001568 ; =============== S U B R O U T I N E =======================================
.text$x:00001568
.text$x:00001568
.text$x:00001568 __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$x:00001568                                         ; DATA XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+5o
.text$x:00001568
.text$x:00001568 arg_4           = dword ptr  8
.text$x:00001568
.text$x:00001568                 mov     edx, [esp+arg_4]
.text$x:0000156C                 lea     eax, [edx+0Ch]
.text$x:0000156F                 mov     ecx, [edx-8]
.text$x:00001572                 xor     ecx, eax
.text$x:00001574                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001579                 mov     eax, offset __ehfuncinfo$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$x:0000157E                 jmp     ___CxxFrameHandler3
.text$x:0000157E __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$x:0000157E
.text$x:0000157E ; ---------------------------------------------------------------------------
.text$x:00001583                 align 4
.text$x:00001583 _text$x         ends
.text$x:00001583
.text$mn:00001584 ; ===========================================================================
.text$mn:00001584
.text$mn:00001584 ; Segment type: Pure code
.text$mn:00001584 ; Segment permissions: Read/Execute
.text$mn:00001584 _text$mn        segment para public 'CODE' use32
.text$mn:00001584                 assume cs:_text$mn
.text$mn:00001584                 ;org 1584h
.text$mn:00001584 ; COMDAT (pick any)
.text$mn:00001584                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001584
.text$mn:00001584 ; =============== S U B R O U T I N E =======================================
.text$mn:00001584
.text$mn:00001584 ; Attributes: bp-based frame
.text$mn:00001584
.text$mn:00001584 ; public: __thiscall std::_Wrap_alloc<class std::allocator<char>>::_Wrap_alloc<class std::allocator<char>>(void)
.text$mn:00001584                 public ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
.text$mn:00001584 ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ proc near
.text$mn:00001584                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)+Ap
.text$mn:00001584
.text$mn:00001584 var_4           = dword ptr -4
.text$mn:00001584
.text$mn:00001584                 push    ebp
.text$mn:00001585                 mov     ebp, esp
.text$mn:00001587                 push    ecx
.text$mn:00001588                 mov     [ebp+var_4], ecx
.text$mn:0000158B                 mov     ecx, [ebp+var_4]
.text$mn:0000158E                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:00001593                 mov     eax, [ebp+var_4]
.text$mn:00001596                 mov     esp, ebp
.text$mn:00001598                 pop     ebp
.text$mn:00001599                 retn
.text$mn:00001599 ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ endp
.text$mn:00001599
.text$mn:00001599 ; ---------------------------------------------------------------------------
.text$mn:0000159A                 align 4
.text$mn:0000159A _text$mn        ends
.text$mn:0000159A
.text$mn:0000159C ; ===========================================================================
.text$mn:0000159C
.text$mn:0000159C ; Segment type: Pure code
.text$mn:0000159C ; Segment permissions: Read/Execute
.text$mn:0000159C _text$mn        segment para public 'CODE' use32
.text$mn:0000159C                 assume cs:_text$mn
.text$mn:0000159C                 ;org 159Ch
.text$mn:0000159C ; COMDAT (pick any)
.text$mn:0000159C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000159C
.text$mn:0000159C ; =============== S U B R O U T I N E =======================================
.text$mn:0000159C
.text$mn:0000159C ; Attributes: bp-based frame
.text$mn:0000159C
.text$mn:0000159C ; public: __thiscall std::allocator<char>::allocator<char>(void)
.text$mn:0000159C                 public ??0?$allocator@D@std@@QAE@XZ
.text$mn:0000159C ??0?$allocator@D@std@@QAE@XZ proc near  ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)+Ap
.text$mn:0000159C                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+2Bp
.text$mn:0000159C
.text$mn:0000159C var_4           = dword ptr -4
.text$mn:0000159C
.text$mn:0000159C                 push    ebp
.text$mn:0000159D                 mov     ebp, esp
.text$mn:0000159F                 push    ecx
.text$mn:000015A0                 mov     [ebp+var_4], ecx
.text$mn:000015A3                 mov     eax, [ebp+var_4]
.text$mn:000015A6                 mov     esp, ebp
.text$mn:000015A8                 pop     ebp
.text$mn:000015A9                 retn
.text$mn:000015A9 ??0?$allocator@D@std@@QAE@XZ endp
.text$mn:000015A9
.text$mn:000015A9 ; ---------------------------------------------------------------------------
.text$mn:000015AA                 align 4
.text$mn:000015AA _text$mn        ends
.text$mn:000015AA
.text$mn:000015AC ; ===========================================================================
.text$mn:000015AC
.text$mn:000015AC ; Segment type: Pure code
.text$mn:000015AC ; Segment permissions: Read/Execute
.text$mn:000015AC _text$mn        segment para public 'CODE' use32
.text$mn:000015AC                 assume cs:_text$mn
.text$mn:000015AC                 ;org 15ACh
.text$mn:000015AC ; COMDAT (pick any)
.text$mn:000015AC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000015AC
.text$mn:000015AC ; =============== S U B R O U T I N E =======================================
.text$mn:000015AC
.text$mn:000015AC ; Attributes: bp-based frame
.text$mn:000015AC
.text$mn:000015AC ; public: __thiscall std::allocator<struct std::_Container_proxy>::allocator<struct std::_Container_proxy>(void)
.text$mn:000015AC                 public ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ
.text$mn:000015AC ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ proc near
.text$mn:000015AC                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+Cp
.text$mn:000015AC                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+Cp
.text$mn:000015AC
.text$mn:000015AC var_4           = dword ptr -4
.text$mn:000015AC
.text$mn:000015AC                 push    ebp
.text$mn:000015AD                 mov     ebp, esp
.text$mn:000015AF                 push    ecx
.text$mn:000015B0                 mov     [ebp+var_4], ecx
.text$mn:000015B3                 mov     eax, [ebp+var_4]
.text$mn:000015B6                 mov     esp, ebp
.text$mn:000015B8                 pop     ebp
.text$mn:000015B9                 retn
.text$mn:000015B9 ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ endp
.text$mn:000015B9
.text$mn:000015B9 ; ---------------------------------------------------------------------------
.text$mn:000015BA                 align 4
.text$mn:000015BA _text$mn        ends
.text$mn:000015BA
.text$mn:000015BC ; ===========================================================================
.text$mn:000015BC
.text$mn:000015BC ; Segment type: Pure code
.text$mn:000015BC ; Segment permissions: Read/Execute
.text$mn:000015BC _text$mn        segment para public 'CODE' use32
.text$mn:000015BC                 assume cs:_text$mn
.text$mn:000015BC                 ;org 15BCh
.text$mn:000015BC ; COMDAT (pick any)
.text$mn:000015BC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000015BC
.text$mn:000015BC ; =============== S U B R O U T I N E =======================================
.text$mn:000015BC
.text$mn:000015BC ; Attributes: bp-based frame
.text$mn:000015BC
.text$mn:000015BC ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char *Str)
.text$mn:000015BC                 public ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$mn:000015BC ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
.text$mn:000015BC                                         ; CODE XREF: std::_Generic_error_category::message(int)+5Ap
.text$mn:000015BC                                         ; std::_Iostream_error_category::message(int)+3Dp ...
.text$mn:000015BC
.text$mn:000015BC var_14          = dword ptr -14h
.text$mn:000015BC var_D           = byte ptr -0Dh
.text$mn:000015BC var_C           = dword ptr -0Ch
.text$mn:000015BC var_4           = dword ptr -4
.text$mn:000015BC Str             = dword ptr  8
.text$mn:000015BC
.text$mn:000015BC                 push    ebp
.text$mn:000015BD                 mov     ebp, esp
.text$mn:000015BF                 push    0FFFFFFFFh
.text$mn:000015C1                 push    offset __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$mn:000015C6                 mov     eax, large fs:0
.text$mn:000015CC                 push    eax
.text$mn:000015CD                 sub     esp, 8
.text$mn:000015D0                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000015D5                 xor     eax, ebp
.text$mn:000015D7                 push    eax
.text$mn:000015D8                 lea     eax, [ebp+var_C]
.text$mn:000015DB                 mov     large fs:0, eax
.text$mn:000015E1                 mov     [ebp+var_14], ecx
.text$mn:000015E4                 lea     ecx, [ebp+var_D]
.text$mn:000015E7                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:000015EC                 push    eax
.text$mn:000015ED                 mov     ecx, [ebp+var_14]
.text$mn:000015F0                 call    ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)
.text$mn:000015F5                 mov     [ebp+var_4], 0
.text$mn:000015FC                 push    0               ; Size
.text$mn:000015FE                 push    0               ; char
.text$mn:00001600                 mov     ecx, [ebp+var_14]
.text$mn:00001603                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00001608                 mov     eax, [ebp+Str]
.text$mn:0000160B                 push    eax             ; Str
.text$mn:0000160C                 mov     ecx, [ebp+var_14]
.text$mn:0000160F                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)
.text$mn:00001614                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000161B                 mov     eax, [ebp+var_14]
.text$mn:0000161E                 mov     ecx, [ebp+var_C]
.text$mn:00001621                 mov     large fs:0, ecx
.text$mn:00001628                 pop     ecx
.text$mn:00001629                 mov     esp, ebp
.text$mn:0000162B                 pop     ebp
.text$mn:0000162C                 retn    4
.text$mn:0000162C ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp
.text$mn:0000162C
.text$mn:0000162C ; ---------------------------------------------------------------------------
.text$mn:0000162F                 align 10h
.text$mn:0000162F _text$mn        ends
.text$mn:0000162F
.text$x:00001630 ; ===========================================================================
.text$x:00001630
.text$x:00001630 ; Segment type: Pure code
.text$x:00001630 ; Segment permissions: Read/Execute
.text$x:00001630 _text$x         segment para public 'CODE' use32
.text$x:00001630                 assume cs:_text$x
.text$x:00001630                 ;org 1630h
.text$x:00001630 ; COMDAT (pick associative to section at 15BC)
.text$x:00001630                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00001630
.text$x:00001630 ; =============== S U B R O U T I N E =======================================
.text$x:00001630
.text$x:00001630
.text$x:00001630 __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 proc near
.text$x:00001630                                         ; DATA XREF: .xdata$x:00002D10o
.text$x:00001630                 mov     ecx, [ebp-14h]
.text$x:00001633                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:00001633 __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 endp
.text$x:00001633
.text$x:00001638
.text$x:00001638 ; =============== S U B R O U T I N E =======================================
.text$x:00001638
.text$x:00001638
.text$x:00001638 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
.text$x:00001638                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+5o
.text$x:00001638
.text$x:00001638 arg_4           = dword ptr  8
.text$x:00001638
.text$x:00001638                 mov     edx, [esp+arg_4]
.text$x:0000163C                 lea     eax, [edx+0Ch]
.text$x:0000163F                 mov     ecx, [edx-0Ch]
.text$x:00001642                 xor     ecx, eax
.text$x:00001644                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001649                 mov     eax, offset __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$x:0000164E                 jmp     ___CxxFrameHandler3
.text$x:0000164E __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp
.text$x:0000164E
.text$x:0000164E ; ---------------------------------------------------------------------------
.text$x:00001653                 align 4
.text$x:00001653 _text$x         ends
.text$x:00001653
.text$mn:00001654 ; ===========================================================================
.text$mn:00001654
.text$mn:00001654 ; Segment type: Pure code
.text$mn:00001654 ; Segment permissions: Read/Execute
.text$mn:00001654 _text$mn        segment para public 'CODE' use32
.text$mn:00001654                 assume cs:_text$mn
.text$mn:00001654                 ;org 1654h
.text$mn:00001654 ; COMDAT (pick any)
.text$mn:00001654                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001654
.text$mn:00001654 ; =============== S U B R O U T I N E =======================================
.text$mn:00001654
.text$mn:00001654 ; Attributes: bp-based frame
.text$mn:00001654
.text$mn:00001654 ; _DWORD __thiscall std::_Container_base12::_Container_base12(std::_Container_base12 *__hidden this)
.text$mn:00001654                 public ??0_Container_base12@std@@QAE@XZ
.text$mn:00001654 ??0_Container_base12@std@@QAE@XZ proc near
.text$mn:00001654                                         ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+29p
.text$mn:00001654
.text$mn:00001654 var_4           = dword ptr -4
.text$mn:00001654
.text$mn:00001654                 push    ebp
.text$mn:00001655                 mov     ebp, esp
.text$mn:00001657                 push    ecx
.text$mn:00001658                 mov     [ebp+var_4], ecx
.text$mn:0000165B                 mov     eax, [ebp+var_4]
.text$mn:0000165E                 mov     dword ptr [eax], 0
.text$mn:00001664                 mov     eax, [ebp+var_4]
.text$mn:00001667                 mov     esp, ebp
.text$mn:00001669                 pop     ebp
.text$mn:0000166A                 retn
.text$mn:0000166A ??0_Container_base12@std@@QAE@XZ endp
.text$mn:0000166A
.text$mn:0000166A ; ---------------------------------------------------------------------------
.text$mn:0000166B                 align 4
.text$mn:0000166B _text$mn        ends
.text$mn:0000166B
.text$mn:0000166C ; ===========================================================================
.text$mn:0000166C
.text$mn:0000166C ; Segment type: Pure code
.text$mn:0000166C ; Segment permissions: Read/Execute
.text$mn:0000166C _text$mn        segment para public 'CODE' use32
.text$mn:0000166C                 assume cs:_text$mn
.text$mn:0000166C                 ;org 166Ch
.text$mn:0000166C ; COMDAT (pick any)
.text$mn:0000166C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000166C
.text$mn:0000166C ; =============== S U B R O U T I N E =======================================
.text$mn:0000166C
.text$mn:0000166C ; Attributes: bp-based frame
.text$mn:0000166C
.text$mn:0000166C ; _DWORD __thiscall std::_Container_proxy::_Container_proxy(std::_Container_proxy *__hidden this)
.text$mn:0000166C                 public ??0_Container_proxy@std@@QAE@XZ
.text$mn:0000166C ??0_Container_proxy@std@@QAE@XZ proc near
.text$mn:0000166C                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+23p
.text$mn:0000166C
.text$mn:0000166C var_4           = dword ptr -4
.text$mn:0000166C
.text$mn:0000166C                 push    ebp
.text$mn:0000166D                 mov     ebp, esp
.text$mn:0000166F                 push    ecx
.text$mn:00001670                 mov     [ebp+var_4], ecx
.text$mn:00001673                 mov     eax, [ebp+var_4]
.text$mn:00001676                 mov     dword ptr [eax], 0
.text$mn:0000167C                 mov     ecx, [ebp+var_4]
.text$mn:0000167F                 mov     dword ptr [ecx+4], 0
.text$mn:00001686                 mov     eax, [ebp+var_4]
.text$mn:00001689                 mov     esp, ebp
.text$mn:0000168B                 pop     ebp
.text$mn:0000168C                 retn
.text$mn:0000168C ??0_Container_proxy@std@@QAE@XZ endp
.text$mn:0000168C
.text$mn:0000168C ; ---------------------------------------------------------------------------
.text$mn:0000168D                 align 10h
.text$mn:0000168D _text$mn        ends
.text$mn:0000168D
.text$mn:00001690 ; ===========================================================================
.text$mn:00001690
.text$mn:00001690 ; Segment type: Pure code
.text$mn:00001690 ; Segment permissions: Read/Execute
.text$mn:00001690 _text$mn        segment para public 'CODE' use32
.text$mn:00001690                 assume cs:_text$mn
.text$mn:00001690                 ;org 1690h
.text$mn:00001690 ; COMDAT (pick any)
.text$mn:00001690                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001690
.text$mn:00001690 ; =============== S U B R O U T I N E =======================================
.text$mn:00001690
.text$mn:00001690 ; Attributes: bp-based frame
.text$mn:00001690
.text$mn:00001690 ; _DWORD __thiscall std::_Generic_error_category::_Generic_error_category(std::_Generic_error_category *__hidden this)
.text$mn:00001690                 public ??0_Generic_error_category@std@@QAE@XZ
.text$mn:00001690 ??0_Generic_error_category@std@@QAE@XZ proc near
.text$mn:00001690                                         ; CODE XREF: std::_Iostream_error_category::_Iostream_error_category(void)+29p
.text$mn:00001690                                         ; std::_System_error_category::_System_error_category(void)+29p ...
.text$mn:00001690
.text$mn:00001690 var_10          = dword ptr -10h
.text$mn:00001690 var_C           = dword ptr -0Ch
.text$mn:00001690 var_4           = dword ptr -4
.text$mn:00001690
.text$mn:00001690                 push    ebp
.text$mn:00001691                 mov     ebp, esp
.text$mn:00001693                 push    0FFFFFFFFh
.text$mn:00001695                 push    offset __ehhandler$??0_Generic_error_category@std@@QAE@XZ
.text$mn:0000169A                 mov     eax, large fs:0
.text$mn:000016A0                 push    eax
.text$mn:000016A1                 push    ecx
.text$mn:000016A2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000016A7                 xor     eax, ebp
.text$mn:000016A9                 push    eax
.text$mn:000016AA                 lea     eax, [ebp+var_C]
.text$mn:000016AD                 mov     large fs:0, eax
.text$mn:000016B3                 mov     [ebp+var_10], ecx
.text$mn:000016B6                 mov     ecx, [ebp+var_10] ; this
.text$mn:000016B9                 call    ??0error_category@std@@QAE@XZ ; std::error_category::error_category(void)
.text$mn:000016BE                 mov     [ebp+var_4], 0
.text$mn:000016C5                 mov     eax, [ebp+var_10]
.text$mn:000016C8                 mov     dword ptr [eax], offset ??_7_Generic_error_category@std@@6B@ ; const std::_Generic_error_category::`vftable'
.text$mn:000016CE                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000016D5                 mov     eax, [ebp+var_10]
.text$mn:000016D8                 mov     ecx, [ebp+var_C]
.text$mn:000016DB                 mov     large fs:0, ecx
.text$mn:000016E2                 pop     ecx
.text$mn:000016E3                 mov     esp, ebp
.text$mn:000016E5                 pop     ebp
.text$mn:000016E6                 retn
.text$mn:000016E6 ??0_Generic_error_category@std@@QAE@XZ endp
.text$mn:000016E6
.text$mn:000016E6 ; ---------------------------------------------------------------------------
.text$mn:000016E7                 align 4
.text$mn:000016E7 _text$mn        ends
.text$mn:000016E7
.text$x:000016E8 ; ===========================================================================
.text$x:000016E8
.text$x:000016E8 ; Segment type: Pure code
.text$x:000016E8 ; Segment permissions: Read/Execute
.text$x:000016E8 _text$x         segment para public 'CODE' use32
.text$x:000016E8                 assume cs:_text$x
.text$x:000016E8                 ;org 16E8h
.text$x:000016E8 ; COMDAT (pick associative to section at 1690)
.text$x:000016E8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000016E8
.text$x:000016E8 ; =============== S U B R O U T I N E =======================================
.text$x:000016E8
.text$x:000016E8
.text$x:000016E8 __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0 proc near
.text$x:000016E8                                         ; DATA XREF: .xdata$x:00002DF4o
.text$x:000016E8                 mov     ecx, [ebp-10h]  ; this
.text$x:000016EB                 jmp     ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$x:000016EB __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0 endp
.text$x:000016EB
.text$x:000016F0
.text$x:000016F0 ; =============== S U B R O U T I N E =======================================
.text$x:000016F0
.text$x:000016F0
.text$x:000016F0 __ehhandler$??0_Generic_error_category@std@@QAE@XZ proc near
.text$x:000016F0                                         ; DATA XREF: std::_Generic_error_category::_Generic_error_category(void)+5o
.text$x:000016F0
.text$x:000016F0 arg_4           = dword ptr  8
.text$x:000016F0
.text$x:000016F0                 mov     edx, [esp+arg_4]
.text$x:000016F4                 lea     eax, [edx+0Ch]
.text$x:000016F7                 mov     ecx, [edx-8]
.text$x:000016FA                 xor     ecx, eax
.text$x:000016FC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001701                 mov     eax, offset __ehfuncinfo$??0_Generic_error_category@std@@QAE@XZ
.text$x:00001706                 jmp     ___CxxFrameHandler3
.text$x:00001706 __ehhandler$??0_Generic_error_category@std@@QAE@XZ endp
.text$x:00001706
.text$x:00001706 ; ---------------------------------------------------------------------------
.text$x:0000170B                 align 4
.text$x:0000170B _text$x         ends
.text$x:0000170B
.text$mn:0000170C ; ===========================================================================
.text$mn:0000170C
.text$mn:0000170C ; Segment type: Pure code
.text$mn:0000170C ; Segment permissions: Read/Execute
.text$mn:0000170C _text$mn        segment para public 'CODE' use32
.text$mn:0000170C                 assume cs:_text$mn
.text$mn:0000170C                 ;org 170Ch
.text$mn:0000170C ; COMDAT (pick any)
.text$mn:0000170C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000170C
.text$mn:0000170C ; =============== S U B R O U T I N E =======================================
.text$mn:0000170C
.text$mn:0000170C ; Attributes: bp-based frame
.text$mn:0000170C
.text$mn:0000170C ; _DWORD __thiscall std::_Ignore::_Ignore(std::_Ignore *__hidden this)
.text$mn:0000170C                 public ??0_Ignore@std@@QAE@XZ
.text$mn:0000170C ??0_Ignore@std@@QAE@XZ proc near        ; CODE XREF: std::`dynamic initializer for 'ignore''(void)+8p
.text$mn:0000170C
.text$mn:0000170C var_4           = dword ptr -4
.text$mn:0000170C
.text$mn:0000170C                 push    ebp
.text$mn:0000170D                 mov     ebp, esp
.text$mn:0000170F                 push    ecx
.text$mn:00001710                 mov     [ebp+var_4], ecx
.text$mn:00001713                 mov     eax, [ebp+var_4]
.text$mn:00001716                 mov     esp, ebp
.text$mn:00001718                 pop     ebp
.text$mn:00001719                 retn
.text$mn:00001719 ??0_Ignore@std@@QAE@XZ endp
.text$mn:00001719
.text$mn:00001719 ; ---------------------------------------------------------------------------
.text$mn:0000171A                 align 4
.text$mn:0000171A _text$mn        ends
.text$mn:0000171A
.text$mn:0000171C ; ===========================================================================
.text$mn:0000171C
.text$mn:0000171C ; Segment type: Pure code
.text$mn:0000171C ; Segment permissions: Read/Execute
.text$mn:0000171C _text$mn        segment para public 'CODE' use32
.text$mn:0000171C                 assume cs:_text$mn
.text$mn:0000171C                 ;org 171Ch
.text$mn:0000171C ; COMDAT (pick any)
.text$mn:0000171C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000171C
.text$mn:0000171C ; =============== S U B R O U T I N E =======================================
.text$mn:0000171C
.text$mn:0000171C ; Attributes: bp-based frame
.text$mn:0000171C
.text$mn:0000171C ; _DWORD __thiscall std::_Iostream_error_category::_Iostream_error_category(std::_Iostream_error_category *__hidden this)
.text$mn:0000171C                 public ??0_Iostream_error_category@std@@QAE@XZ
.text$mn:0000171C ??0_Iostream_error_category@std@@QAE@XZ proc near
.text$mn:0000171C                                         ; CODE XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p
.text$mn:0000171C
.text$mn:0000171C var_10          = dword ptr -10h
.text$mn:0000171C var_C           = dword ptr -0Ch
.text$mn:0000171C var_4           = dword ptr -4
.text$mn:0000171C
.text$mn:0000171C                 push    ebp
.text$mn:0000171D                 mov     ebp, esp
.text$mn:0000171F                 push    0FFFFFFFFh
.text$mn:00001721                 push    offset __ehhandler$??0_Iostream_error_category@std@@QAE@XZ
.text$mn:00001726                 mov     eax, large fs:0
.text$mn:0000172C                 push    eax
.text$mn:0000172D                 push    ecx
.text$mn:0000172E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001733                 xor     eax, ebp
.text$mn:00001735                 push    eax
.text$mn:00001736                 lea     eax, [ebp+var_C]
.text$mn:00001739                 mov     large fs:0, eax
.text$mn:0000173F                 mov     [ebp+var_10], ecx
.text$mn:00001742                 mov     ecx, [ebp+var_10] ; this
.text$mn:00001745                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$mn:0000174A                 mov     [ebp+var_4], 0
.text$mn:00001751                 mov     eax, [ebp+var_10]
.text$mn:00001754                 mov     dword ptr [eax], offset ??_7_Iostream_error_category@std@@6B@ ; const std::_Iostream_error_category::`vftable'
.text$mn:0000175A                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001761                 mov     eax, [ebp+var_10]
.text$mn:00001764                 mov     ecx, [ebp+var_C]
.text$mn:00001767                 mov     large fs:0, ecx
.text$mn:0000176E                 pop     ecx
.text$mn:0000176F                 mov     esp, ebp
.text$mn:00001771                 pop     ebp
.text$mn:00001772                 retn
.text$mn:00001772 ??0_Iostream_error_category@std@@QAE@XZ endp
.text$mn:00001772
.text$mn:00001772 ; ---------------------------------------------------------------------------
.text$mn:00001773                 align 4
.text$mn:00001773 _text$mn        ends
.text$mn:00001773
.text$x:00001774 ; ===========================================================================
.text$x:00001774
.text$x:00001774 ; Segment type: Pure code
.text$x:00001774 ; Segment permissions: Read/Execute
.text$x:00001774 _text$x         segment para public 'CODE' use32
.text$x:00001774                 assume cs:_text$x
.text$x:00001774                 ;org 1774h
.text$x:00001774 ; COMDAT (pick associative to section at 171C)
.text$x:00001774                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00001774
.text$x:00001774 ; =============== S U B R O U T I N E =======================================
.text$x:00001774
.text$x:00001774
.text$x:00001774 __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0 proc near
.text$x:00001774                                         ; DATA XREF: .xdata$x:00002E78o
.text$x:00001774                 mov     ecx, [ebp-10h]  ; this
.text$x:00001777                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00001777 __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0 endp
.text$x:00001777
.text$x:0000177C
.text$x:0000177C ; =============== S U B R O U T I N E =======================================
.text$x:0000177C
.text$x:0000177C
.text$x:0000177C __ehhandler$??0_Iostream_error_category@std@@QAE@XZ proc near
.text$x:0000177C                                         ; DATA XREF: std::_Iostream_error_category::_Iostream_error_category(void)+5o
.text$x:0000177C
.text$x:0000177C arg_4           = dword ptr  8
.text$x:0000177C
.text$x:0000177C                 mov     edx, [esp+arg_4]
.text$x:00001780                 lea     eax, [edx+0Ch]
.text$x:00001783                 mov     ecx, [edx-8]
.text$x:00001786                 xor     ecx, eax
.text$x:00001788                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000178D                 mov     eax, offset __ehfuncinfo$??0_Iostream_error_category@std@@QAE@XZ
.text$x:00001792                 jmp     ___CxxFrameHandler3
.text$x:00001792 __ehhandler$??0_Iostream_error_category@std@@QAE@XZ endp
.text$x:00001792
.text$x:00001792 ; ---------------------------------------------------------------------------
.text$x:00001797                 align 4
.text$x:00001797 _text$x         ends
.text$x:00001797
.text$mn:00001798 ; ===========================================================================
.text$mn:00001798
.text$mn:00001798 ; Segment type: Pure code
.text$mn:00001798 ; Segment permissions: Read/Execute
.text$mn:00001798 _text$mn        segment para public 'CODE' use32
.text$mn:00001798                 assume cs:_text$mn
.text$mn:00001798                 ;org 1798h
.text$mn:00001798 ; COMDAT (pick any)
.text$mn:00001798                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001798
.text$mn:00001798 ; =============== S U B R O U T I N E =======================================
.text$mn:00001798
.text$mn:00001798 ; Attributes: bp-based frame
.text$mn:00001798
.text$mn:00001798 ; _DWORD __thiscall std::_System_error_category::_System_error_category(std::_System_error_category *__hidden this)
.text$mn:00001798                 public ??0_System_error_category@std@@QAE@XZ
.text$mn:00001798 ??0_System_error_category@std@@QAE@XZ proc near
.text$mn:00001798                                         ; CODE XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p
.text$mn:00001798
.text$mn:00001798 var_10          = dword ptr -10h
.text$mn:00001798 var_C           = dword ptr -0Ch
.text$mn:00001798 var_4           = dword ptr -4
.text$mn:00001798
.text$mn:00001798                 push    ebp
.text$mn:00001799                 mov     ebp, esp
.text$mn:0000179B                 push    0FFFFFFFFh
.text$mn:0000179D                 push    offset __ehhandler$??0_System_error_category@std@@QAE@XZ
.text$mn:000017A2                 mov     eax, large fs:0
.text$mn:000017A8                 push    eax
.text$mn:000017A9                 push    ecx
.text$mn:000017AA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000017AF                 xor     eax, ebp
.text$mn:000017B1                 push    eax
.text$mn:000017B2                 lea     eax, [ebp+var_C]
.text$mn:000017B5                 mov     large fs:0, eax
.text$mn:000017BB                 mov     [ebp+var_10], ecx
.text$mn:000017BE                 mov     ecx, [ebp+var_10] ; this
.text$mn:000017C1                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$mn:000017C6                 mov     [ebp+var_4], 0
.text$mn:000017CD                 mov     eax, [ebp+var_10]
.text$mn:000017D0                 mov     dword ptr [eax], offset ??_7_System_error_category@std@@6B@ ; const std::_System_error_category::`vftable'
.text$mn:000017D6                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000017DD                 mov     eax, [ebp+var_10]
.text$mn:000017E0                 mov     ecx, [ebp+var_C]
.text$mn:000017E3                 mov     large fs:0, ecx
.text$mn:000017EA                 pop     ecx
.text$mn:000017EB                 mov     esp, ebp
.text$mn:000017ED                 pop     ebp
.text$mn:000017EE                 retn
.text$mn:000017EE ??0_System_error_category@std@@QAE@XZ endp
.text$mn:000017EE
.text$mn:000017EE ; ---------------------------------------------------------------------------
.text$mn:000017EF                 align 10h
.text$mn:000017EF _text$mn        ends
.text$mn:000017EF
.text$x:000017F0 ; ===========================================================================
.text$x:000017F0
.text$x:000017F0 ; Segment type: Pure code
.text$x:000017F0 ; Segment permissions: Read/Execute
.text$x:000017F0 _text$x         segment para public 'CODE' use32
.text$x:000017F0                 assume cs:_text$x
.text$x:000017F0                 ;org 17F0h
.text$x:000017F0 ; COMDAT (pick associative to section at 1798)
.text$x:000017F0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000017F0
.text$x:000017F0 ; =============== S U B R O U T I N E =======================================
.text$x:000017F0
.text$x:000017F0
.text$x:000017F0 __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0 proc near
.text$x:000017F0                                         ; DATA XREF: .xdata$x:00002EFCo
.text$x:000017F0                 mov     ecx, [ebp-10h]  ; this
.text$x:000017F3                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:000017F3 __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0 endp
.text$x:000017F3
.text$x:000017F8
.text$x:000017F8 ; =============== S U B R O U T I N E =======================================
.text$x:000017F8
.text$x:000017F8
.text$x:000017F8 __ehhandler$??0_System_error_category@std@@QAE@XZ proc near
.text$x:000017F8                                         ; DATA XREF: std::_System_error_category::_System_error_category(void)+5o
.text$x:000017F8
.text$x:000017F8 arg_4           = dword ptr  8
.text$x:000017F8
.text$x:000017F8                 mov     edx, [esp+arg_4]
.text$x:000017FC                 lea     eax, [edx+0Ch]
.text$x:000017FF                 mov     ecx, [edx-8]
.text$x:00001802                 xor     ecx, eax
.text$x:00001804                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001809                 mov     eax, offset __ehfuncinfo$??0_System_error_category@std@@QAE@XZ
.text$x:0000180E                 jmp     ___CxxFrameHandler3
.text$x:0000180E __ehhandler$??0_System_error_category@std@@QAE@XZ endp
.text$x:0000180E
.text$x:0000180E ; ---------------------------------------------------------------------------
.text$x:00001813                 align 4
.text$x:00001813 _text$x         ends
.text$x:00001813
.text$mn:00001814 ; ===========================================================================
.text$mn:00001814
.text$mn:00001814 ; Segment type: Pure code
.text$mn:00001814 ; Segment permissions: Read/Execute
.text$mn:00001814 _text$mn        segment para public 'CODE' use32
.text$mn:00001814                 assume cs:_text$mn
.text$mn:00001814                 ;org 1814h
.text$mn:00001814 ; COMDAT (pick any)
.text$mn:00001814                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001814
.text$mn:00001814 ; =============== S U B R O U T I N E =======================================
.text$mn:00001814
.text$mn:00001814 ; Attributes: bp-based frame
.text$mn:00001814
.text$mn:00001814 ; _DWORD __thiscall std::error_category::error_category(std::error_category *__hidden this)
.text$mn:00001814                 public ??0error_category@std@@QAE@XZ
.text$mn:00001814 ??0error_category@std@@QAE@XZ proc near ; CODE XREF: std::_Generic_error_category::_Generic_error_category(void)+29p
.text$mn:00001814
.text$mn:00001814 var_4           = dword ptr -4
.text$mn:00001814
.text$mn:00001814                 push    ebp
.text$mn:00001815                 mov     ebp, esp
.text$mn:00001817                 push    ecx
.text$mn:00001818                 mov     [ebp+var_4], ecx
.text$mn:0000181B                 mov     eax, [ebp+var_4]
.text$mn:0000181E                 mov     dword ptr [eax], offset ??_7error_category@std@@6B@ ; const std::error_category::`vftable'
.text$mn:00001824                 mov     eax, [ebp+var_4]
.text$mn:00001827                 mov     esp, ebp
.text$mn:00001829                 pop     ebp
.text$mn:0000182A                 retn
.text$mn:0000182A ??0error_category@std@@QAE@XZ endp
.text$mn:0000182A
.text$mn:0000182A ; ---------------------------------------------------------------------------
.text$mn:0000182B                 align 4
.text$mn:0000182B _text$mn        ends
.text$mn:0000182B
.text$mn:0000182C ; ===========================================================================
.text$mn:0000182C
.text$mn:0000182C ; Segment type: Pure code
.text$mn:0000182C ; Segment permissions: Read/Execute
.text$mn:0000182C _text$mn        segment para public 'CODE' use32
.text$mn:0000182C                 assume cs:_text$mn
.text$mn:0000182C                 ;org 182Ch
.text$mn:0000182C ; COMDAT (pick any)
.text$mn:0000182C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000182C
.text$mn:0000182C ; =============== S U B R O U T I N E =======================================
.text$mn:0000182C
.text$mn:0000182C ; Attributes: bp-based frame
.text$mn:0000182C
.text$mn:0000182C ; _DWORD __thiscall std::error_condition::error_condition(std::error_condition *this, int, const struct std::error_category *)
.text$mn:0000182C                 public ??0error_condition@std@@QAE@HABVerror_category@1@@Z
.text$mn:0000182C ??0error_condition@std@@QAE@HABVerror_category@1@@Z proc near
.text$mn:0000182C                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+24p
.text$mn:0000182C                                         ; std::_System_error_category::default_error_condition(int)+3Dp ...
.text$mn:0000182C
.text$mn:0000182C var_4           = dword ptr -4
.text$mn:0000182C arg_0           = dword ptr  8
.text$mn:0000182C arg_4           = dword ptr  0Ch
.text$mn:0000182C
.text$mn:0000182C                 push    ebp
.text$mn:0000182D                 mov     ebp, esp
.text$mn:0000182F                 push    ecx
.text$mn:00001830                 mov     [ebp+var_4], ecx
.text$mn:00001833                 mov     eax, [ebp+var_4]
.text$mn:00001836                 mov     ecx, [ebp+arg_0]
.text$mn:00001839                 mov     [eax], ecx
.text$mn:0000183B                 mov     edx, [ebp+var_4]
.text$mn:0000183E                 mov     eax, [ebp+arg_4]
.text$mn:00001841                 mov     [edx+4], eax
.text$mn:00001844                 mov     eax, [ebp+var_4]
.text$mn:00001847                 mov     esp, ebp
.text$mn:00001849                 pop     ebp
.text$mn:0000184A                 retn    8
.text$mn:0000184A ??0error_condition@std@@QAE@HABVerror_category@1@@Z endp
.text$mn:0000184A
.text$mn:0000184A ; ---------------------------------------------------------------------------
.text$mn:0000184D                 align 10h
.text$mn:0000184D _text$mn        ends
.text$mn:0000184D
.text$mn:00001850 ; ===========================================================================
.text$mn:00001850
.text$mn:00001850 ; Segment type: Pure code
.text$mn:00001850 ; Segment permissions: Read/Execute
.text$mn:00001850 _text$mn        segment para public 'CODE' use32
.text$mn:00001850                 assume cs:_text$mn
.text$mn:00001850                 ;org 1850h
.text$mn:00001850 ; COMDAT (pick any)
.text$mn:00001850                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001850
.text$mn:00001850 ; =============== S U B R O U T I N E =======================================
.text$mn:00001850
.text$mn:00001850 ; Attributes: bp-based frame
.text$mn:00001850
.text$mn:00001850 ; _DWORD __thiscall std::locale::id::id(std::locale::id *this, unsigned int)
.text$mn:00001850                 public ??0id@locale@std@@QAE@I@Z
.text$mn:00001850 ??0id@locale@std@@QAE@I@Z proc near     ; CODE XREF: `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)+Ap
.text$mn:00001850                                         ; `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)+Ap ...
.text$mn:00001850
.text$mn:00001850 var_4           = dword ptr -4
.text$mn:00001850 arg_0           = dword ptr  8
.text$mn:00001850
.text$mn:00001850                 push    ebp
.text$mn:00001851                 mov     ebp, esp
.text$mn:00001853                 push    ecx
.text$mn:00001854                 mov     [ebp+var_4], ecx
.text$mn:00001857                 mov     eax, [ebp+var_4]
.text$mn:0000185A                 mov     ecx, [ebp+arg_0]
.text$mn:0000185D                 mov     [eax], ecx
.text$mn:0000185F                 mov     eax, [ebp+var_4]
.text$mn:00001862                 mov     esp, ebp
.text$mn:00001864                 pop     ebp
.text$mn:00001865                 retn    4
.text$mn:00001865 ??0id@locale@std@@QAE@I@Z endp
.text$mn:00001865
.text$mn:00001865 _text$mn        ends
.text$mn:00001865
.text$mn:00001868 ; ===========================================================================
.text$mn:00001868
.text$mn:00001868 ; Segment type: Pure code
.text$mn:00001868 ; Segment permissions: Read/Execute
.text$mn:00001868 _text$mn        segment para public 'CODE' use32
.text$mn:00001868                 assume cs:_text$mn
.text$mn:00001868                 ;org 1868h
.text$mn:00001868 ; COMDAT (pick any)
.text$mn:00001868                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001868
.text$mn:00001868 ; =============== S U B R O U T I N E =======================================
.text$mn:00001868
.text$mn:00001868 ; Attributes: bp-based frame
.text$mn:00001868
.text$mn:00001868 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::~_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>(void)
.text$mn:00001868                 public ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$mn:00001868 ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00001868                                         ; CODE XREF: __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0+3j
.text$mn:00001868                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+43p ...
.text$mn:00001868
.text$mn:00001868 var_10          = dword ptr -10h
.text$mn:00001868 var_C           = dword ptr -0Ch
.text$mn:00001868 var_4           = dword ptr -4
.text$mn:00001868
.text$mn:00001868                 push    ebp
.text$mn:00001869                 mov     ebp, esp
.text$mn:0000186B                 push    0FFFFFFFFh
.text$mn:0000186D                 push    offset __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$mn:00001872                 mov     eax, large fs:0
.text$mn:00001878                 push    eax
.text$mn:00001879                 push    ecx
.text$mn:0000187A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000187F                 xor     eax, ebp
.text$mn:00001881                 push    eax
.text$mn:00001882                 lea     eax, [ebp+var_C]
.text$mn:00001885                 mov     large fs:0, eax
.text$mn:0000188B                 mov     [ebp+var_10], ecx
.text$mn:0000188E                 mov     [ebp+var_4], 0
.text$mn:00001895                 mov     ecx, [ebp+var_10]
.text$mn:00001898                 call    ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)
.text$mn:0000189D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000018A4                 mov     ecx, [ebp+var_10]
.text$mn:000018A7                 call    ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$mn:000018AC                 mov     ecx, [ebp+var_C]
.text$mn:000018AF                 mov     large fs:0, ecx
.text$mn:000018B6                 pop     ecx
.text$mn:000018B7                 mov     esp, ebp
.text$mn:000018B9                 pop     ebp
.text$mn:000018BA                 retn
.text$mn:000018BA ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp
.text$mn:000018BA
.text$mn:000018BA ; ---------------------------------------------------------------------------
.text$mn:000018BB                 align 4
.text$mn:000018BB _text$mn        ends
.text$mn:000018BB
.text$x:000018BC ; ===========================================================================
.text$x:000018BC
.text$x:000018BC ; Segment type: Pure code
.text$x:000018BC ; Segment permissions: Read/Execute
.text$x:000018BC _text$x         segment para public 'CODE' use32
.text$x:000018BC                 assume cs:_text$x
.text$x:000018BC                 ;org 18BCh
.text$x:000018BC ; COMDAT (pick associative to section at 1868)
.text$x:000018BC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000018BC
.text$x:000018BC ; =============== S U B R O U T I N E =======================================
.text$x:000018BC
.text$x:000018BC
.text$x:000018BC __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:000018BC                                         ; DATA XREF: .xdata$x:00002CE4o
.text$x:000018BC                 mov     ecx, [ebp-10h]
.text$x:000018BF                 jmp     ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$x:000018BF __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:000018BF
.text$x:000018C4
.text$x:000018C4 ; =============== S U B R O U T I N E =======================================
.text$x:000018C4
.text$x:000018C4
.text$x:000018C4 __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
.text$x:000018C4                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+5o
.text$x:000018C4
.text$x:000018C4 arg_4           = dword ptr  8
.text$x:000018C4
.text$x:000018C4                 mov     edx, [esp+arg_4]
.text$x:000018C8                 lea     eax, [edx+0Ch]
.text$x:000018CB                 mov     ecx, [edx-8]
.text$x:000018CE                 xor     ecx, eax
.text$x:000018D0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000018D5                 mov     eax, offset __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$x:000018DA                 jmp     ___CxxFrameHandler3
.text$x:000018DA __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp
.text$x:000018DA
.text$x:000018DA ; ---------------------------------------------------------------------------
.text$x:000018DF                 align 10h
.text$x:000018DF _text$x         ends
.text$x:000018DF
.text$mn:000018E0 ; ===========================================================================
.text$mn:000018E0
.text$mn:000018E0 ; Segment type: Pure code
.text$mn:000018E0 ; Segment permissions: Read/Execute
.text$mn:000018E0 _text$mn        segment para public 'CODE' use32
.text$mn:000018E0                 assume cs:_text$mn
.text$mn:000018E0                 ;org 18E0h
.text$mn:000018E0 ; COMDAT (pick any)
.text$mn:000018E0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000018E0
.text$mn:000018E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000018E0
.text$mn:000018E0 ; Attributes: bp-based frame
.text$mn:000018E0
.text$mn:000018E0 ; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::~_String_val<struct std::_Simple_types<char>>(void)
.text$mn:000018E0                 public ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:000018E0 ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$mn:000018E0                                         ; CODE XREF: __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0+3j
.text$mn:000018E0                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+3Fp ...
.text$mn:000018E0
.text$mn:000018E0 var_10          = dword ptr -10h
.text$mn:000018E0 var_C           = dword ptr -0Ch
.text$mn:000018E0 var_4           = dword ptr -4
.text$mn:000018E0
.text$mn:000018E0                 push    ebp
.text$mn:000018E1                 mov     ebp, esp
.text$mn:000018E3                 push    0FFFFFFFFh
.text$mn:000018E5                 push    offset __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:000018EA                 mov     eax, large fs:0
.text$mn:000018F0                 push    eax
.text$mn:000018F1                 push    ecx
.text$mn:000018F2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000018F7                 xor     eax, ebp
.text$mn:000018F9                 push    eax
.text$mn:000018FA                 lea     eax, [ebp+var_C]
.text$mn:000018FD                 mov     large fs:0, eax
.text$mn:00001903                 mov     [ebp+var_10], ecx
.text$mn:00001906                 mov     [ebp+var_4], 0
.text$mn:0000190D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001914                 mov     ecx, [ebp+var_10] ; this
.text$mn:00001917                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:0000191C                 mov     ecx, [ebp+var_C]
.text$mn:0000191F                 mov     large fs:0, ecx
.text$mn:00001926                 pop     ecx
.text$mn:00001927                 mov     esp, ebp
.text$mn:00001929                 pop     ebp
.text$mn:0000192A                 retn
.text$mn:0000192A ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$mn:0000192A
.text$mn:0000192A ; ---------------------------------------------------------------------------
.text$mn:0000192B                 align 4
.text$mn:0000192B _text$mn        ends
.text$mn:0000192B
.text$x:0000192C ; ===========================================================================
.text$x:0000192C
.text$x:0000192C ; Segment type: Pure code
.text$x:0000192C ; Segment permissions: Read/Execute
.text$x:0000192C _text$x         segment para public 'CODE' use32
.text$x:0000192C                 assume cs:_text$x
.text$x:0000192C                 ;org 192Ch
.text$x:0000192C ; COMDAT (pick associative to section at 18E0)
.text$x:0000192C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000192C
.text$x:0000192C ; =============== S U B R O U T I N E =======================================
.text$x:0000192C
.text$x:0000192C
.text$x:0000192C __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 proc near
.text$x:0000192C                                         ; DATA XREF: .xdata$x:00002C8Co
.text$x:0000192C                 mov     ecx, [ebp-10h]  ; this
.text$x:0000192F                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:0000192F __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 endp
.text$x:0000192F
.text$x:00001934
.text$x:00001934 ; =============== S U B R O U T I N E =======================================
.text$x:00001934
.text$x:00001934
.text$x:00001934 __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$x:00001934                                         ; DATA XREF: std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)+5o
.text$x:00001934
.text$x:00001934 arg_4           = dword ptr  8
.text$x:00001934
.text$x:00001934                 mov     edx, [esp+arg_4]
.text$x:00001938                 lea     eax, [edx+0Ch]
.text$x:0000193B                 mov     ecx, [edx-8]
.text$x:0000193E                 xor     ecx, eax
.text$x:00001940                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001945                 mov     eax, offset __ehfuncinfo$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$x:0000194A                 jmp     ___CxxFrameHandler3
.text$x:0000194A __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$x:0000194A
.text$x:0000194A ; ---------------------------------------------------------------------------
.text$x:0000194F                 align 10h
.text$x:0000194F _text$x         ends
.text$x:0000194F
.text$mn:00001950 ; ===========================================================================
.text$mn:00001950
.text$mn:00001950 ; Segment type: Pure code
.text$mn:00001950 ; Segment permissions: Read/Execute
.text$mn:00001950 _text$mn        segment para public 'CODE' use32
.text$mn:00001950                 assume cs:_text$mn
.text$mn:00001950                 ;org 1950h
.text$mn:00001950 ; COMDAT (pick any)
.text$mn:00001950                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001950
.text$mn:00001950 ; =============== S U B R O U T I N E =======================================
.text$mn:00001950
.text$mn:00001950 ; Attributes: bp-based frame
.text$mn:00001950
.text$mn:00001950 ; public: __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::~basic_string<char, struct std::char_traits<char>, class std::allocator<char>>(void)
.text$mn:00001950                 public ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:00001950 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$mn:00001950                                         ; CODE XREF: __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+13j
.text$mn:00001950                                         ; __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+13j ...
.text$mn:00001950
.text$mn:00001950 var_10          = dword ptr -10h
.text$mn:00001950 var_C           = dword ptr -0Ch
.text$mn:00001950 var_4           = dword ptr -4
.text$mn:00001950
.text$mn:00001950                 push    ebp
.text$mn:00001951                 mov     ebp, esp
.text$mn:00001953                 push    0FFFFFFFFh
.text$mn:00001955                 push    offset __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:0000195A                 mov     eax, large fs:0
.text$mn:00001960                 push    eax
.text$mn:00001961                 push    ecx
.text$mn:00001962                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001967                 xor     eax, ebp
.text$mn:00001969                 push    eax
.text$mn:0000196A                 lea     eax, [ebp+var_C]
.text$mn:0000196D                 mov     large fs:0, eax
.text$mn:00001973                 mov     [ebp+var_10], ecx
.text$mn:00001976                 mov     [ebp+var_4], 0
.text$mn:0000197D                 push    0               ; Size
.text$mn:0000197F                 push    1               ; char
.text$mn:00001981                 mov     ecx, [ebp+var_10]
.text$mn:00001984                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00001989                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001990                 mov     ecx, [ebp+var_10]
.text$mn:00001993                 call    ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$mn:00001998                 mov     ecx, [ebp+var_C]
.text$mn:0000199B                 mov     large fs:0, ecx
.text$mn:000019A2                 pop     ecx
.text$mn:000019A3                 mov     esp, ebp
.text$mn:000019A5                 pop     ebp
.text$mn:000019A6                 retn
.text$mn:000019A6 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$mn:000019A6
.text$mn:000019A6 ; ---------------------------------------------------------------------------
.text$mn:000019A7                 align 4
.text$mn:000019A7 _text$mn        ends
.text$mn:000019A7
.text$x:000019A8 ; ===========================================================================
.text$x:000019A8
.text$x:000019A8 ; Segment type: Pure code
.text$x:000019A8 ; Segment permissions: Read/Execute
.text$x:000019A8 _text$x         segment para public 'CODE' use32
.text$x:000019A8                 assume cs:_text$x
.text$x:000019A8                 ;org 19A8h
.text$x:000019A8 ; COMDAT (pick associative to section at 1950)
.text$x:000019A8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000019A8
.text$x:000019A8 ; =============== S U B R O U T I N E =======================================
.text$x:000019A8
.text$x:000019A8
.text$x:000019A8 __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 proc near
.text$x:000019A8                                         ; DATA XREF: .xdata$x:00002D3Co
.text$x:000019A8                 mov     ecx, [ebp-10h]
.text$x:000019AB                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:000019AB __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 endp
.text$x:000019AB
.text$x:000019B0
.text$x:000019B0 ; =============== S U B R O U T I N E =======================================
.text$x:000019B0
.text$x:000019B0
.text$x:000019B0 __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$x:000019B0                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+5o
.text$x:000019B0
.text$x:000019B0 arg_4           = dword ptr  8
.text$x:000019B0
.text$x:000019B0                 mov     edx, [esp+arg_4]
.text$x:000019B4                 lea     eax, [edx+0Ch]
.text$x:000019B7                 mov     ecx, [edx-8]
.text$x:000019BA                 xor     ecx, eax
.text$x:000019BC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000019C1                 mov     eax, offset __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$x:000019C6                 jmp     ___CxxFrameHandler3
.text$x:000019C6 __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$x:000019C6
.text$x:000019C6 ; ---------------------------------------------------------------------------
.text$x:000019CB                 align 4
.text$x:000019CB _text$x         ends
.text$x:000019CB
.text$mn:000019CC ; ===========================================================================
.text$mn:000019CC
.text$mn:000019CC ; Segment type: Pure code
.text$mn:000019CC ; Segment permissions: Read/Execute
.text$mn:000019CC _text$mn        segment para public 'CODE' use32
.text$mn:000019CC                 assume cs:_text$mn
.text$mn:000019CC                 ;org 19CCh
.text$mn:000019CC ; COMDAT (pick any)
.text$mn:000019CC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000019CC
.text$mn:000019CC ; =============== S U B R O U T I N E =======================================
.text$mn:000019CC
.text$mn:000019CC ; Attributes: bp-based frame
.text$mn:000019CC
.text$mn:000019CC ; _DWORD __thiscall std::_Container_base12::~_Container_base12(std::_Container_base12 *__hidden this)
.text$mn:000019CC                 public ??1_Container_base12@std@@QAE@XZ
.text$mn:000019CC ??1_Container_base12@std@@QAE@XZ proc near
.text$mn:000019CC                                         ; CODE XREF: __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0+3j
.text$mn:000019CC                                         ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)+37p ...
.text$mn:000019CC
.text$mn:000019CC var_4           = dword ptr -4
.text$mn:000019CC
.text$mn:000019CC                 push    ebp
.text$mn:000019CD                 mov     ebp, esp
.text$mn:000019CF                 push    ecx
.text$mn:000019D0                 mov     [ebp+var_4], ecx
.text$mn:000019D3                 mov     ecx, [ebp+var_4] ; this
.text$mn:000019D6                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:000019DB                 mov     esp, ebp
.text$mn:000019DD                 pop     ebp
.text$mn:000019DE                 retn
.text$mn:000019DE ??1_Container_base12@std@@QAE@XZ endp
.text$mn:000019DE
.text$mn:000019DE ; ---------------------------------------------------------------------------
.text$mn:000019DF                 align 10h
.text$mn:000019DF _text$mn        ends
.text$mn:000019DF
.text$mn:000019E0 ; ===========================================================================
.text$mn:000019E0
.text$mn:000019E0 ; Segment type: Pure code
.text$mn:000019E0 ; Segment permissions: Read/Execute
.text$mn:000019E0 _text$mn        segment para public 'CODE' use32
.text$mn:000019E0                 assume cs:_text$mn
.text$mn:000019E0                 ;org 19E0h
.text$mn:000019E0 ; COMDAT (pick any)
.text$mn:000019E0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000019E0
.text$mn:000019E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000019E0
.text$mn:000019E0 ; Attributes: bp-based frame
.text$mn:000019E0
.text$mn:000019E0 ; _DWORD __thiscall std::_Generic_error_category::~_Generic_error_category(std::_Generic_error_category *__hidden this)
.text$mn:000019E0                 public ??1_Generic_error_category@std@@UAE@XZ
.text$mn:000019E0 ??1_Generic_error_category@std@@UAE@XZ proc near
.text$mn:000019E0                                         ; CODE XREF: __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0+3j
.text$mn:000019E0                                         ; __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0+3j ...
.text$mn:000019E0
.text$mn:000019E0 var_10          = dword ptr -10h
.text$mn:000019E0 var_C           = dword ptr -0Ch
.text$mn:000019E0 var_4           = dword ptr -4
.text$mn:000019E0
.text$mn:000019E0                 push    ebp
.text$mn:000019E1                 mov     ebp, esp
.text$mn:000019E3                 push    0FFFFFFFFh
.text$mn:000019E5                 push    offset __ehhandler$??1_Generic_error_category@std@@UAE@XZ
.text$mn:000019EA                 mov     eax, large fs:0
.text$mn:000019F0                 push    eax
.text$mn:000019F1                 push    ecx
.text$mn:000019F2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000019F7                 xor     eax, ebp
.text$mn:000019F9                 push    eax
.text$mn:000019FA                 lea     eax, [ebp+var_C]
.text$mn:000019FD                 mov     large fs:0, eax
.text$mn:00001A03                 mov     [ebp+var_10], ecx
.text$mn:00001A06                 mov     [ebp+var_4], 0
.text$mn:00001A0D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001A14                 mov     ecx, [ebp+var_10] ; this
.text$mn:00001A17                 call    ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$mn:00001A1C                 mov     ecx, [ebp+var_C]
.text$mn:00001A1F                 mov     large fs:0, ecx
.text$mn:00001A26                 pop     ecx
.text$mn:00001A27                 mov     esp, ebp
.text$mn:00001A29                 pop     ebp
.text$mn:00001A2A                 retn
.text$mn:00001A2A ??1_Generic_error_category@std@@UAE@XZ endp
.text$mn:00001A2A
.text$mn:00001A2A ; ---------------------------------------------------------------------------
.text$mn:00001A2B                 align 4
.text$mn:00001A2B _text$mn        ends
.text$mn:00001A2B
.text$x:00001A2C ; ===========================================================================
.text$x:00001A2C
.text$x:00001A2C ; Segment type: Pure code
.text$x:00001A2C ; Segment permissions: Read/Execute
.text$x:00001A2C _text$x         segment para public 'CODE' use32
.text$x:00001A2C                 assume cs:_text$x
.text$x:00001A2C                 ;org 1A2Ch
.text$x:00001A2C ; COMDAT (pick associative to section at 19E0)
.text$x:00001A2C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00001A2C
.text$x:00001A2C ; =============== S U B R O U T I N E =======================================
.text$x:00001A2C
.text$x:00001A2C
.text$x:00001A2C __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0 proc near
.text$x:00001A2C                                         ; DATA XREF: .xdata$x:00002E4Co
.text$x:00001A2C                 mov     ecx, [ebp-10h]  ; this
.text$x:00001A2F                 jmp     ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$x:00001A2F __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0 endp
.text$x:00001A2F
.text$x:00001A34
.text$x:00001A34 ; =============== S U B R O U T I N E =======================================
.text$x:00001A34
.text$x:00001A34
.text$x:00001A34 __ehhandler$??1_Generic_error_category@std@@UAE@XZ proc near
.text$x:00001A34                                         ; DATA XREF: std::_Generic_error_category::~_Generic_error_category(void)+5o
.text$x:00001A34
.text$x:00001A34 arg_4           = dword ptr  8
.text$x:00001A34
.text$x:00001A34                 mov     edx, [esp+arg_4]
.text$x:00001A38                 lea     eax, [edx+0Ch]
.text$x:00001A3B                 mov     ecx, [edx-8]
.text$x:00001A3E                 xor     ecx, eax
.text$x:00001A40                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001A45                 mov     eax, offset __ehfuncinfo$??1_Generic_error_category@std@@UAE@XZ
.text$x:00001A4A                 jmp     ___CxxFrameHandler3
.text$x:00001A4A __ehhandler$??1_Generic_error_category@std@@UAE@XZ endp
.text$x:00001A4A
.text$x:00001A4A ; ---------------------------------------------------------------------------
.text$x:00001A4F                 align 10h
.text$x:00001A4F _text$x         ends
.text$x:00001A4F
.text$mn:00001A50 ; ===========================================================================
.text$mn:00001A50
.text$mn:00001A50 ; Segment type: Pure code
.text$mn:00001A50 ; Segment permissions: Read/Execute
.text$mn:00001A50 _text$mn        segment para public 'CODE' use32
.text$mn:00001A50                 assume cs:_text$mn
.text$mn:00001A50                 ;org 1A50h
.text$mn:00001A50 ; COMDAT (pick any)
.text$mn:00001A50                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001A50
.text$mn:00001A50 ; =============== S U B R O U T I N E =======================================
.text$mn:00001A50
.text$mn:00001A50 ; Attributes: bp-based frame
.text$mn:00001A50
.text$mn:00001A50 ; _DWORD __thiscall std::_Iostream_error_category::~_Iostream_error_category(std::_Iostream_error_category *__hidden this)
.text$mn:00001A50                 public ??1_Iostream_error_category@std@@UAE@XZ
.text$mn:00001A50 ??1_Iostream_error_category@std@@UAE@XZ proc near
.text$mn:00001A50                                         ; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+Ap
.text$mn:00001A50                                         ; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p
.text$mn:00001A50
.text$mn:00001A50 var_10          = dword ptr -10h
.text$mn:00001A50 var_C           = dword ptr -0Ch
.text$mn:00001A50 var_4           = dword ptr -4
.text$mn:00001A50
.text$mn:00001A50                 push    ebp
.text$mn:00001A51                 mov     ebp, esp
.text$mn:00001A53                 push    0FFFFFFFFh
.text$mn:00001A55                 push    offset __ehhandler$??1_Iostream_error_category@std@@UAE@XZ
.text$mn:00001A5A                 mov     eax, large fs:0
.text$mn:00001A60                 push    eax
.text$mn:00001A61                 push    ecx
.text$mn:00001A62                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001A67                 xor     eax, ebp
.text$mn:00001A69                 push    eax
.text$mn:00001A6A                 lea     eax, [ebp+var_C]
.text$mn:00001A6D                 mov     large fs:0, eax
.text$mn:00001A73                 mov     [ebp+var_10], ecx
.text$mn:00001A76                 mov     [ebp+var_4], 0
.text$mn:00001A7D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001A84                 mov     ecx, [ebp+var_10] ; this
.text$mn:00001A87                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:00001A8C                 mov     ecx, [ebp+var_C]
.text$mn:00001A8F                 mov     large fs:0, ecx
.text$mn:00001A96                 pop     ecx
.text$mn:00001A97                 mov     esp, ebp
.text$mn:00001A99                 pop     ebp
.text$mn:00001A9A                 retn
.text$mn:00001A9A ??1_Iostream_error_category@std@@UAE@XZ endp
.text$mn:00001A9A
.text$mn:00001A9A ; ---------------------------------------------------------------------------
.text$mn:00001A9B                 align 4
.text$mn:00001A9B _text$mn        ends
.text$mn:00001A9B
.text$x:00001A9C ; ===========================================================================
.text$x:00001A9C
.text$x:00001A9C ; Segment type: Pure code
.text$x:00001A9C ; Segment permissions: Read/Execute
.text$x:00001A9C _text$x         segment para public 'CODE' use32
.text$x:00001A9C                 assume cs:_text$x
.text$x:00001A9C                 ;org 1A9Ch
.text$x:00001A9C ; COMDAT (pick associative to section at 1A50)
.text$x:00001A9C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00001A9C
.text$x:00001A9C ; =============== S U B R O U T I N E =======================================
.text$x:00001A9C
.text$x:00001A9C
.text$x:00001A9C __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0 proc near
.text$x:00001A9C                                         ; DATA XREF: .xdata$x:00002ED0o
.text$x:00001A9C                 mov     ecx, [ebp-10h]  ; this
.text$x:00001A9F                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00001A9F __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0 endp
.text$x:00001A9F
.text$x:00001AA4
.text$x:00001AA4 ; =============== S U B R O U T I N E =======================================
.text$x:00001AA4
.text$x:00001AA4
.text$x:00001AA4 __ehhandler$??1_Iostream_error_category@std@@UAE@XZ proc near
.text$x:00001AA4                                         ; DATA XREF: std::_Iostream_error_category::~_Iostream_error_category(void)+5o
.text$x:00001AA4
.text$x:00001AA4 arg_4           = dword ptr  8
.text$x:00001AA4
.text$x:00001AA4                 mov     edx, [esp+arg_4]
.text$x:00001AA8                 lea     eax, [edx+0Ch]
.text$x:00001AAB                 mov     ecx, [edx-8]
.text$x:00001AAE                 xor     ecx, eax
.text$x:00001AB0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001AB5                 mov     eax, offset __ehfuncinfo$??1_Iostream_error_category@std@@UAE@XZ
.text$x:00001ABA                 jmp     ___CxxFrameHandler3
.text$x:00001ABA __ehhandler$??1_Iostream_error_category@std@@UAE@XZ endp
.text$x:00001ABA
.text$x:00001ABA ; ---------------------------------------------------------------------------
.text$x:00001ABF                 align 10h
.text$x:00001ABF _text$x         ends
.text$x:00001ABF
.text$mn:00001AC0 ; ===========================================================================
.text$mn:00001AC0
.text$mn:00001AC0 ; Segment type: Pure code
.text$mn:00001AC0 ; Segment permissions: Read/Execute
.text$mn:00001AC0 _text$mn        segment para public 'CODE' use32
.text$mn:00001AC0                 assume cs:_text$mn
.text$mn:00001AC0                 ;org 1AC0h
.text$mn:00001AC0 ; COMDAT (pick any)
.text$mn:00001AC0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001AC0
.text$mn:00001AC0 ; =============== S U B R O U T I N E =======================================
.text$mn:00001AC0
.text$mn:00001AC0 ; Attributes: bp-based frame
.text$mn:00001AC0
.text$mn:00001AC0 ; _DWORD __thiscall std::_System_error_category::~_System_error_category(std::_System_error_category *__hidden this)
.text$mn:00001AC0                 public ??1_System_error_category@std@@UAE@XZ
.text$mn:00001AC0 ??1_System_error_category@std@@UAE@XZ proc near
.text$mn:00001AC0                                         ; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+Ap
.text$mn:00001AC0                                         ; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p
.text$mn:00001AC0
.text$mn:00001AC0 var_10          = dword ptr -10h
.text$mn:00001AC0 var_C           = dword ptr -0Ch
.text$mn:00001AC0 var_4           = dword ptr -4
.text$mn:00001AC0
.text$mn:00001AC0                 push    ebp
.text$mn:00001AC1                 mov     ebp, esp
.text$mn:00001AC3                 push    0FFFFFFFFh
.text$mn:00001AC5                 push    offset __ehhandler$??1_System_error_category@std@@UAE@XZ
.text$mn:00001ACA                 mov     eax, large fs:0
.text$mn:00001AD0                 push    eax
.text$mn:00001AD1                 push    ecx
.text$mn:00001AD2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001AD7                 xor     eax, ebp
.text$mn:00001AD9                 push    eax
.text$mn:00001ADA                 lea     eax, [ebp+var_C]
.text$mn:00001ADD                 mov     large fs:0, eax
.text$mn:00001AE3                 mov     [ebp+var_10], ecx
.text$mn:00001AE6                 mov     [ebp+var_4], 0
.text$mn:00001AED                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001AF4                 mov     ecx, [ebp+var_10] ; this
.text$mn:00001AF7                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:00001AFC                 mov     ecx, [ebp+var_C]
.text$mn:00001AFF                 mov     large fs:0, ecx
.text$mn:00001B06                 pop     ecx
.text$mn:00001B07                 mov     esp, ebp
.text$mn:00001B09                 pop     ebp
.text$mn:00001B0A                 retn
.text$mn:00001B0A ??1_System_error_category@std@@UAE@XZ endp
.text$mn:00001B0A
.text$mn:00001B0A ; ---------------------------------------------------------------------------
.text$mn:00001B0B                 align 4
.text$mn:00001B0B _text$mn        ends
.text$mn:00001B0B
.text$x:00001B0C ; ===========================================================================
.text$x:00001B0C
.text$x:00001B0C ; Segment type: Pure code
.text$x:00001B0C ; Segment permissions: Read/Execute
.text$x:00001B0C _text$x         segment para public 'CODE' use32
.text$x:00001B0C                 assume cs:_text$x
.text$x:00001B0C                 ;org 1B0Ch
.text$x:00001B0C ; COMDAT (pick associative to section at 1AC0)
.text$x:00001B0C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00001B0C
.text$x:00001B0C ; =============== S U B R O U T I N E =======================================
.text$x:00001B0C
.text$x:00001B0C
.text$x:00001B0C __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0 proc near
.text$x:00001B0C                                         ; DATA XREF: .xdata$x:00002F54o
.text$x:00001B0C                 mov     ecx, [ebp-10h]  ; this
.text$x:00001B0F                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00001B0F __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0 endp
.text$x:00001B0F
.text$x:00001B14
.text$x:00001B14 ; =============== S U B R O U T I N E =======================================
.text$x:00001B14
.text$x:00001B14
.text$x:00001B14 __ehhandler$??1_System_error_category@std@@UAE@XZ proc near
.text$x:00001B14                                         ; DATA XREF: std::_System_error_category::~_System_error_category(void)+5o
.text$x:00001B14
.text$x:00001B14 arg_4           = dword ptr  8
.text$x:00001B14
.text$x:00001B14                 mov     edx, [esp+arg_4]
.text$x:00001B18                 lea     eax, [edx+0Ch]
.text$x:00001B1B                 mov     ecx, [edx-8]
.text$x:00001B1E                 xor     ecx, eax
.text$x:00001B20                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001B25                 mov     eax, offset __ehfuncinfo$??1_System_error_category@std@@UAE@XZ
.text$x:00001B2A                 jmp     ___CxxFrameHandler3
.text$x:00001B2A __ehhandler$??1_System_error_category@std@@UAE@XZ endp
.text$x:00001B2A
.text$x:00001B2A ; ---------------------------------------------------------------------------
.text$x:00001B2F                 align 10h
.text$x:00001B2F _text$x         ends
.text$x:00001B2F
.text$mn:00001B30 ; ===========================================================================
.text$mn:00001B30
.text$mn:00001B30 ; Segment type: Pure code
.text$mn:00001B30 ; Segment permissions: Read/Execute
.text$mn:00001B30 _text$mn        segment para public 'CODE' use32
.text$mn:00001B30                 assume cs:_text$mn
.text$mn:00001B30                 ;org 1B30h
.text$mn:00001B30 ; COMDAT (pick any)
.text$mn:00001B30                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001B30
.text$mn:00001B30 ; =============== S U B R O U T I N E =======================================
.text$mn:00001B30
.text$mn:00001B30 ; Attributes: bp-based frame
.text$mn:00001B30
.text$mn:00001B30 ; _DWORD __thiscall std::error_category::~error_category(std::error_category *__hidden this)
.text$mn:00001B30                 public ??1error_category@std@@UAE@XZ
.text$mn:00001B30 ??1error_category@std@@UAE@XZ proc near ; CODE XREF: __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0+3j
.text$mn:00001B30                                         ; std::_Generic_error_category::~_Generic_error_category(void)+37p ...
.text$mn:00001B30
.text$mn:00001B30 var_4           = dword ptr -4
.text$mn:00001B30
.text$mn:00001B30                 push    ebp
.text$mn:00001B31                 mov     ebp, esp
.text$mn:00001B33                 push    ecx
.text$mn:00001B34                 mov     [ebp+var_4], ecx
.text$mn:00001B37                 mov     eax, [ebp+var_4]
.text$mn:00001B3A                 mov     dword ptr [eax], offset ??_7error_category@std@@6B@ ; const std::error_category::`vftable'
.text$mn:00001B40                 mov     esp, ebp
.text$mn:00001B42                 pop     ebp
.text$mn:00001B43                 retn
.text$mn:00001B43 ??1error_category@std@@UAE@XZ endp
.text$mn:00001B43
.text$mn:00001B43 _text$mn        ends
.text$mn:00001B43
.text$mn:00001B44 ; ===========================================================================
.text$mn:00001B44
.text$mn:00001B44 ; Segment type: Pure code
.text$mn:00001B44 ; Segment permissions: Read/Execute
.text$mn:00001B44 _text$mn        segment para public 'CODE' use32
.text$mn:00001B44                 assume cs:_text$mn
.text$mn:00001B44                 ;org 1B44h
.text$mn:00001B44 ; COMDAT (pick any)
.text$mn:00001B44                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001B44
.text$mn:00001B44 ; =============== S U B R O U T I N E =======================================
.text$mn:00001B44
.text$mn:00001B44 ; Attributes: bp-based frame
.text$mn:00001B44
.text$mn:00001B44 ; void *__cdecl operator new(unsigned int, void *)
.text$mn:00001B44                 public ??2@YAPAXIPAX@Z
.text$mn:00001B44 ??2@YAPAXIPAX@Z proc near               ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+2Ep
.text$mn:00001B44                                         ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+2Ep
.text$mn:00001B44
.text$mn:00001B44 arg_4           = dword ptr  0Ch
.text$mn:00001B44
.text$mn:00001B44                 push    ebp
.text$mn:00001B45                 mov     ebp, esp
.text$mn:00001B47                 mov     eax, [ebp+arg_4]
.text$mn:00001B4A                 pop     ebp
.text$mn:00001B4B                 retn
.text$mn:00001B4B ??2@YAPAXIPAX@Z endp
.text$mn:00001B4B
.text$mn:00001B4B _text$mn        ends
.text$mn:00001B4B
.text$mn:00001B4C ; ===========================================================================
.text$mn:00001B4C
.text$mn:00001B4C ; Segment type: Pure code
.text$mn:00001B4C ; Segment permissions: Read/Execute
.text$mn:00001B4C _text$mn        segment para public 'CODE' use32
.text$mn:00001B4C                 assume cs:_text$mn
.text$mn:00001B4C                 ;org 1B4Ch
.text$mn:00001B4C ; COMDAT (pick any)
.text$mn:00001B4C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001B4C
.text$mn:00001B4C ; =============== S U B R O U T I N E =======================================
.text$mn:00001B4C
.text$mn:00001B4C ; Attributes: bp-based frame
.text$mn:00001B4C
.text$mn:00001B4C ; void __cdecl operator delete(void *)
.text$mn:00001B4C                 public ??3@YAXPAX0@Z
.text$mn:00001B4C ??3@YAXPAX0@Z   proc near               ; CODE XREF: __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0+8p
.text$mn:00001B4C                                         ; __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0+8p
.text$mn:00001B4C                 push    ebp
.text$mn:00001B4D                 mov     ebp, esp
.text$mn:00001B4F                 pop     ebp
.text$mn:00001B50                 retn
.text$mn:00001B50 ??3@YAXPAX0@Z   endp
.text$mn:00001B50
.text$mn:00001B50 ; ---------------------------------------------------------------------------
.text$mn:00001B51                 align 4
.text$mn:00001B51 _text$mn        ends
.text$mn:00001B51
.text$mn:00001B54 ; ===========================================================================
.text$mn:00001B54
.text$mn:00001B54 ; Segment type: Pure code
.text$mn:00001B54 ; Segment permissions: Read/Execute
.text$mn:00001B54 _text$mn        segment para public 'CODE' use32
.text$mn:00001B54                 assume cs:_text$mn
.text$mn:00001B54                 ;org 1B54h
.text$mn:00001B54 ; COMDAT (pick any)
.text$mn:00001B54                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001B54
.text$mn:00001B54 ; =============== S U B R O U T I N E =======================================
.text$mn:00001B54
.text$mn:00001B54 ; Attributes: bp-based frame
.text$mn:00001B54
.text$mn:00001B54 ; public: bool __thiscall std::error_category::operator==(class std::error_category const &)const
.text$mn:00001B54                 public ??8error_category@std@@QBE_NABV01@@Z
.text$mn:00001B54 ??8error_category@std@@QBE_NABV01@@Z proc near
.text$mn:00001B54                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+1Dp
.text$mn:00001B54                                         ; std::error_category::equivalent(std::error_code const &,int)+15p
.text$mn:00001B54
.text$mn:00001B54 var_8           = dword ptr -8
.text$mn:00001B54 var_4           = dword ptr -4
.text$mn:00001B54 arg_0           = dword ptr  8
.text$mn:00001B54
.text$mn:00001B54                 push    ebp
.text$mn:00001B55                 mov     ebp, esp
.text$mn:00001B57                 sub     esp, 8
.text$mn:00001B5A                 mov     [ebp+var_8], ecx
.text$mn:00001B5D                 mov     eax, [ebp+var_8]
.text$mn:00001B60                 cmp     eax, [ebp+arg_0]
.text$mn:00001B63                 jnz     short loc_1B6E
.text$mn:00001B65                 mov     [ebp+var_4], 1
.text$mn:00001B6C                 jmp     short loc_1B75
.text$mn:00001B6E ; ---------------------------------------------------------------------------
.text$mn:00001B6E
.text$mn:00001B6E loc_1B6E:                               ; CODE XREF: std::error_category::operator==(std::error_category const &)+Fj
.text$mn:00001B6E                 mov     [ebp+var_4], 0
.text$mn:00001B75
.text$mn:00001B75 loc_1B75:                               ; CODE XREF: std::error_category::operator==(std::error_category const &)+18j
.text$mn:00001B75                 mov     al, byte ptr [ebp+var_4]
.text$mn:00001B78                 mov     esp, ebp
.text$mn:00001B7A                 pop     ebp
.text$mn:00001B7B                 retn    4
.text$mn:00001B7B ??8error_category@std@@QBE_NABV01@@Z endp
.text$mn:00001B7B
.text$mn:00001B7B ; ---------------------------------------------------------------------------
.text$mn:00001B7E                 align 10h
.text$mn:00001B7E _text$mn        ends
.text$mn:00001B7E
.text$mn:00001B80 ; ===========================================================================
.text$mn:00001B80
.text$mn:00001B80 ; Segment type: Pure code
.text$mn:00001B80 ; Segment permissions: Read/Execute
.text$mn:00001B80 _text$mn        segment para public 'CODE' use32
.text$mn:00001B80                 assume cs:_text$mn
.text$mn:00001B80                 ;org 1B80h
.text$mn:00001B80 ; COMDAT (pick any)
.text$mn:00001B80                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001B80
.text$mn:00001B80 ; =============== S U B R O U T I N E =======================================
.text$mn:00001B80
.text$mn:00001B80 ; Attributes: bp-based frame
.text$mn:00001B80
.text$mn:00001B80 ; int __stdcall std::error_condition::operator==(std::error_condition *)
.text$mn:00001B80                 public ??8error_condition@std@@QBE_NABV01@@Z
.text$mn:00001B80 ??8error_condition@std@@QBE_NABV01@@Z proc near
.text$mn:00001B80                                         ; CODE XREF: std::error_category::equivalent(int,std::error_condition const &)+24p
.text$mn:00001B80
.text$mn:00001B80 var_8           = dword ptr -8
.text$mn:00001B80 var_4           = dword ptr -4
.text$mn:00001B80 arg_0           = dword ptr  8
.text$mn:00001B80
.text$mn:00001B80                 push    ebp
.text$mn:00001B81                 mov     ebp, esp
.text$mn:00001B83                 sub     esp, 8
.text$mn:00001B86                 push    esi
.text$mn:00001B87                 mov     [ebp+var_4], ecx
.text$mn:00001B8A                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00001B8D                 call    ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
.text$mn:00001B92                 push    eax
.text$mn:00001B93                 mov     ecx, [ebp+var_4] ; this
.text$mn:00001B96                 call    ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
.text$mn:00001B9B                 mov     ecx, eax
.text$mn:00001B9D                 call    ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
.text$mn:00001BA2                 movzx   eax, al
.text$mn:00001BA5                 test    eax, eax
.text$mn:00001BA7                 jz      short loc_1BC8
.text$mn:00001BA9                 mov     ecx, [ebp+var_4] ; this
.text$mn:00001BAC                 call    ?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
.text$mn:00001BB1                 mov     esi, eax
.text$mn:00001BB3                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00001BB6                 call    ?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
.text$mn:00001BBB                 cmp     esi, eax
.text$mn:00001BBD                 jnz     short loc_1BC8
.text$mn:00001BBF                 mov     [ebp+var_8], 1
.text$mn:00001BC6                 jmp     short loc_1BCF
.text$mn:00001BC8 ; ---------------------------------------------------------------------------
.text$mn:00001BC8
.text$mn:00001BC8 loc_1BC8:                               ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+27j
.text$mn:00001BC8                                         ; std::error_condition::operator==(std::error_condition const &)+3Dj
.text$mn:00001BC8                 mov     [ebp+var_8], 0
.text$mn:00001BCF
.text$mn:00001BCF loc_1BCF:                               ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+46j
.text$mn:00001BCF                 mov     al, byte ptr [ebp+var_8]
.text$mn:00001BD2                 pop     esi
.text$mn:00001BD3                 mov     esp, ebp
.text$mn:00001BD5                 pop     ebp
.text$mn:00001BD6                 retn    4
.text$mn:00001BD6 ??8error_condition@std@@QBE_NABV01@@Z endp
.text$mn:00001BD6
.text$mn:00001BD6 ; ---------------------------------------------------------------------------
.text$mn:00001BD9                 align 4
.text$mn:00001BD9 _text$mn        ends
.text$mn:00001BD9
.text$mn:00001BDC ; ===========================================================================
.text$mn:00001BDC
.text$mn:00001BDC ; Segment type: Pure code
.text$mn:00001BDC ; Segment permissions: Read/Execute
.text$mn:00001BDC _text$mn        segment para public 'CODE' use32
.text$mn:00001BDC                 assume cs:_text$mn
.text$mn:00001BDC                 ;org 1BDCh
.text$mn:00001BDC ; COMDAT (pick any)
.text$mn:00001BDC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001BDC
.text$mn:00001BDC ; =============== S U B R O U T I N E =======================================
.text$mn:00001BDC
.text$mn:00001BDC ; Attributes: bp-based frame
.text$mn:00001BDC
.text$mn:00001BDC ; public: class MacroShortcut & __thiscall std::vector<class MacroShortcut, class std::allocator<class MacroShortcut>>::operator[](unsigned int)
.text$mn:00001BDC                 public ??A?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@QAEAAVMacroShortcut@@I@Z
.text$mn:00001BDC ??A?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@QAEAAVMacroShortcut@@I@Z proc near
.text$mn:00001BDC                                         ; CODE XREF: RunMacroDlg::initMacroList(void)+B5p
.text$mn:00001BDC
.text$mn:00001BDC var_4           = dword ptr -4
.text$mn:00001BDC arg_0           = dword ptr  8
.text$mn:00001BDC
.text$mn:00001BDC                 push    ebp
.text$mn:00001BDD                 mov     ebp, esp
.text$mn:00001BDF                 push    ecx
.text$mn:00001BE0                 mov     [ebp+var_4], ecx
.text$mn:00001BE3                 mov     ecx, [ebp+var_4]
.text$mn:00001BE6                 call    ?size@?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@QBEIXZ ; std::vector<MacroShortcut,std::allocator<MacroShortcut>>::size(void)
.text$mn:00001BEB                 cmp     eax, [ebp+arg_0]
.text$mn:00001BEE                 ja      short loc_1C58
.text$mn:00001BF0                 push    4B1h            ; unsigned int
.text$mn:00001BF5                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00001BFA                 push    offset ??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "vector subscript out of range"
.text$mn:00001BFF                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00001C04                 add     esp, 0Ch
.text$mn:00001C07                 mov     eax, offset ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ ; "Standard C++ Libraries Out of Range"
.text$mn:00001C0C                 test    eax, eax
.text$mn:00001C0E                 jz      short loc_1C14
.text$mn:00001C10                 xor     ecx, ecx
.text$mn:00001C12                 jnz     short loc_1C3A
.text$mn:00001C14
.text$mn:00001C14 loc_1C14:                               ; CODE XREF: std::vector<MacroShortcut,std::allocator<MacroShortcut>>::operator[](uint)+32j
.text$mn:00001C14                 push    offset ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@ ; "\"Standard C++ Libraries Out of Range\""...
.text$mn:00001C19                 push    offset ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ ; "%s"
.text$mn:00001C1E                 push    0
.text$mn:00001C20                 push    4B2h
.text$mn:00001C25                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00001C2A                 push    2
.text$mn:00001C2C                 call    __CrtDbgReportW
.text$mn:00001C31                 add     esp, 18h
.text$mn:00001C34                 cmp     eax, 1
.text$mn:00001C37                 jnz     short loc_1C3A
.text$mn:00001C39                 int     3               ; Trap to Debugger
.text$mn:00001C3A
.text$mn:00001C3A loc_1C3A:                               ; CODE XREF: std::vector<MacroShortcut,std::allocator<MacroShortcut>>::operator[](uint)+36j
.text$mn:00001C3A                                         ; std::vector<MacroShortcut,std::allocator<MacroShortcut>>::operator[](uint)+5Bj
.text$mn:00001C3A                 push    0
.text$mn:00001C3C                 push    4B2h
.text$mn:00001C41                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00001C46                 push    offset ??_C@_1LC@OPANGMDH@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAM?$AAa?$AAc?$AAr?$AAo?$AAS?$AAh?$AAo?$AAr?$AAt?$AAc?$AAu?$AAt?$AA?0@ ; "std::vector<class MacroShortcut,class s"...
.text$mn:00001C4B                 push    offset ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@ ; "\"out of range\""
.text$mn:00001C50                 call    __invalid_parameter
.text$mn:00001C55                 add     esp, 14h
.text$mn:00001C58
.text$mn:00001C58 loc_1C58:                               ; CODE XREF: std::vector<MacroShortcut,std::allocator<MacroShortcut>>::operator[](uint)+12j
.text$mn:00001C58                 imul    eax, [ebp+arg_0], 13Ch
.text$mn:00001C5F                 mov     ecx, [ebp+var_4]
.text$mn:00001C62                 add     eax, [ecx+4]
.text$mn:00001C65                 mov     esp, ebp
.text$mn:00001C67                 pop     ebp
.text$mn:00001C68                 retn    4
.text$mn:00001C68 ??A?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@QAEAAVMacroShortcut@@I@Z endp
.text$mn:00001C68
.text$mn:00001C68 ; ---------------------------------------------------------------------------
.text$mn:00001C6B                 align 4
.text$mn:00001C6B _text$mn        ends
.text$mn:00001C6B
.text$mn:00001C6C ; ===========================================================================
.text$mn:00001C6C
.text$mn:00001C6C ; Segment type: Pure code
.text$mn:00001C6C ; Segment permissions: Read/Execute
.text$mn:00001C6C _text$mn        segment para public 'CODE' use32
.text$mn:00001C6C                 assume cs:_text$mn
.text$mn:00001C6C                 ;org 1C6Ch
.text$mn:00001C6C ; COMDAT (pick any)
.text$mn:00001C6C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001C6C
.text$mn:00001C6C ; =============== S U B R O U T I N E =======================================
.text$mn:00001C6C
.text$mn:00001C6C ; Attributes: bp-based frame
.text$mn:00001C6C
.text$mn:00001C6C ; public: virtual void * __thiscall std::_Generic_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00001C6C                 public ??_G_Generic_error_category@std@@UAEPAXI@Z
.text$mn:00001C6C ??_G_Generic_error_category@std@@UAEPAXI@Z proc near
.text$mn:00001C6C
.text$mn:00001C6C var_4           = dword ptr -4
.text$mn:00001C6C arg_0           = dword ptr  8
.text$mn:00001C6C
.text$mn:00001C6C                 push    ebp
.text$mn:00001C6D                 mov     ebp, esp
.text$mn:00001C6F                 push    ecx
.text$mn:00001C70                 mov     [ebp+var_4], ecx
.text$mn:00001C73                 mov     ecx, [ebp+var_4] ; this
.text$mn:00001C76                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:00001C7B                 mov     eax, [ebp+arg_0]
.text$mn:00001C7E                 and     eax, 1
.text$mn:00001C81                 jz      short loc_1C8F
.text$mn:00001C83                 mov     ecx, [ebp+var_4]
.text$mn:00001C86                 push    ecx             ; void *
.text$mn:00001C87                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00001C8C                 add     esp, 4
.text$mn:00001C8F
.text$mn:00001C8F loc_1C8F:                               ; CODE XREF: std::_Generic_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00001C8F                 mov     eax, [ebp+var_4]
.text$mn:00001C92                 mov     esp, ebp
.text$mn:00001C94                 pop     ebp
.text$mn:00001C95                 retn    4
.text$mn:00001C95 ??_G_Generic_error_category@std@@UAEPAXI@Z endp
.text$mn:00001C95
.text$mn:00001C95 _text$mn        ends
.text$mn:00001C95
.text$mn:00001C98 ; ===========================================================================
.text$mn:00001C98
.text$mn:00001C98 ; Segment type: Pure code
.text$mn:00001C98 ; Segment permissions: Read/Execute
.text$mn:00001C98 _text$mn        segment para public 'CODE' use32
.text$mn:00001C98                 assume cs:_text$mn
.text$mn:00001C98                 ;org 1C98h
.text$mn:00001C98 ; COMDAT (pick any)
.text$mn:00001C98                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001C98
.text$mn:00001C98 ; =============== S U B R O U T I N E =======================================
.text$mn:00001C98
.text$mn:00001C98 ; Attributes: bp-based frame
.text$mn:00001C98
.text$mn:00001C98 ; public: virtual void * __thiscall std::_Iostream_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00001C98                 public ??_G_Iostream_error_category@std@@UAEPAXI@Z
.text$mn:00001C98 ??_G_Iostream_error_category@std@@UAEPAXI@Z proc near
.text$mn:00001C98
.text$mn:00001C98 var_4           = dword ptr -4
.text$mn:00001C98 arg_0           = dword ptr  8
.text$mn:00001C98
.text$mn:00001C98                 push    ebp
.text$mn:00001C99                 mov     ebp, esp
.text$mn:00001C9B                 push    ecx
.text$mn:00001C9C                 mov     [ebp+var_4], ecx
.text$mn:00001C9F                 mov     ecx, [ebp+var_4] ; this
.text$mn:00001CA2                 call    ??1_Iostream_error_category@std@@UAE@XZ ; std::_Iostream_error_category::~_Iostream_error_category(void)
.text$mn:00001CA7                 mov     eax, [ebp+arg_0]
.text$mn:00001CAA                 and     eax, 1
.text$mn:00001CAD                 jz      short loc_1CBB
.text$mn:00001CAF                 mov     ecx, [ebp+var_4]
.text$mn:00001CB2                 push    ecx             ; void *
.text$mn:00001CB3                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00001CB8                 add     esp, 4
.text$mn:00001CBB
.text$mn:00001CBB loc_1CBB:                               ; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00001CBB                 mov     eax, [ebp+var_4]
.text$mn:00001CBE                 mov     esp, ebp
.text$mn:00001CC0                 pop     ebp
.text$mn:00001CC1                 retn    4
.text$mn:00001CC1 ??_G_Iostream_error_category@std@@UAEPAXI@Z endp
.text$mn:00001CC1
.text$mn:00001CC1 _text$mn        ends
.text$mn:00001CC1
.text$mn:00001CC4 ; ===========================================================================
.text$mn:00001CC4
.text$mn:00001CC4 ; Segment type: Pure code
.text$mn:00001CC4 ; Segment permissions: Read/Execute
.text$mn:00001CC4 _text$mn        segment para public 'CODE' use32
.text$mn:00001CC4                 assume cs:_text$mn
.text$mn:00001CC4                 ;org 1CC4h
.text$mn:00001CC4 ; COMDAT (pick any)
.text$mn:00001CC4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001CC4
.text$mn:00001CC4 ; =============== S U B R O U T I N E =======================================
.text$mn:00001CC4
.text$mn:00001CC4 ; Attributes: bp-based frame
.text$mn:00001CC4
.text$mn:00001CC4 ; public: virtual void * __thiscall std::_System_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00001CC4                 public ??_G_System_error_category@std@@UAEPAXI@Z
.text$mn:00001CC4 ??_G_System_error_category@std@@UAEPAXI@Z proc near
.text$mn:00001CC4
.text$mn:00001CC4 var_4           = dword ptr -4
.text$mn:00001CC4 arg_0           = dword ptr  8
.text$mn:00001CC4
.text$mn:00001CC4                 push    ebp
.text$mn:00001CC5                 mov     ebp, esp
.text$mn:00001CC7                 push    ecx
.text$mn:00001CC8                 mov     [ebp+var_4], ecx
.text$mn:00001CCB                 mov     ecx, [ebp+var_4] ; this
.text$mn:00001CCE                 call    ??1_System_error_category@std@@UAE@XZ ; std::_System_error_category::~_System_error_category(void)
.text$mn:00001CD3                 mov     eax, [ebp+arg_0]
.text$mn:00001CD6                 and     eax, 1
.text$mn:00001CD9                 jz      short loc_1CE7
.text$mn:00001CDB                 mov     ecx, [ebp+var_4]
.text$mn:00001CDE                 push    ecx             ; void *
.text$mn:00001CDF                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00001CE4                 add     esp, 4
.text$mn:00001CE7
.text$mn:00001CE7 loc_1CE7:                               ; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00001CE7                 mov     eax, [ebp+var_4]
.text$mn:00001CEA                 mov     esp, ebp
.text$mn:00001CEC                 pop     ebp
.text$mn:00001CED                 retn    4
.text$mn:00001CED ??_G_System_error_category@std@@UAEPAXI@Z endp
.text$mn:00001CED
.text$mn:00001CED _text$mn        ends
.text$mn:00001CED
.text$mn:00001CF0 ; ===========================================================================
.text$mn:00001CF0
.text$mn:00001CF0 ; Segment type: Pure code
.text$mn:00001CF0 ; Segment permissions: Read/Execute
.text$mn:00001CF0 _text$mn        segment para public 'CODE' use32
.text$mn:00001CF0                 assume cs:_text$mn
.text$mn:00001CF0                 ;org 1CF0h
.text$mn:00001CF0 ; COMDAT (pick any)
.text$mn:00001CF0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001CF0
.text$mn:00001CF0 ; =============== S U B R O U T I N E =======================================
.text$mn:00001CF0
.text$mn:00001CF0 ; Attributes: bp-based frame
.text$mn:00001CF0
.text$mn:00001CF0 ; public: virtual void * __thiscall std::error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00001CF0                 public ??_Gerror_category@std@@UAEPAXI@Z
.text$mn:00001CF0 ??_Gerror_category@std@@UAEPAXI@Z proc near
.text$mn:00001CF0
.text$mn:00001CF0 var_4           = dword ptr -4
.text$mn:00001CF0 arg_0           = dword ptr  8
.text$mn:00001CF0
.text$mn:00001CF0                 push    ebp
.text$mn:00001CF1                 mov     ebp, esp
.text$mn:00001CF3                 push    ecx
.text$mn:00001CF4                 mov     [ebp+var_4], ecx
.text$mn:00001CF7                 mov     ecx, [ebp+var_4] ; this
.text$mn:00001CFA                 call    ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$mn:00001CFF                 mov     eax, [ebp+arg_0]
.text$mn:00001D02                 and     eax, 1
.text$mn:00001D05                 jz      short loc_1D13
.text$mn:00001D07                 mov     ecx, [ebp+var_4]
.text$mn:00001D0A                 push    ecx             ; void *
.text$mn:00001D0B                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00001D10                 add     esp, 4
.text$mn:00001D13
.text$mn:00001D13 loc_1D13:                               ; CODE XREF: std::error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00001D13                 mov     eax, [ebp+var_4]
.text$mn:00001D16                 mov     esp, ebp
.text$mn:00001D18                 pop     ebp
.text$mn:00001D19                 retn    4
.text$mn:00001D19 ??_Gerror_category@std@@UAEPAXI@Z endp
.text$mn:00001D19
.text$mn:00001D19 _text$mn        ends
.text$mn:00001D19
.text$di:00001D1C ; ===========================================================================
.text$di:00001D1C
.text$di:00001D1C ; Segment type: Pure code
.text$di:00001D1C ; Segment permissions: Read/Execute
.text$di:00001D1C _text$di        segment para public 'CODE' use32
.text$di:00001D1C                 assume cs:_text$di
.text$di:00001D1C                 ;org 1D1Ch
.text$di:00001D1C ; COMDAT (pick any)
.text$di:00001D1C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00001D1C
.text$di:00001D1C ; =============== S U B R O U T I N E =======================================
.text$di:00001D1C
.text$di:00001D1C ; Attributes: bp-based frame
.text$di:00001D1C
.text$di:00001D1C ; void __cdecl `dynamic initializer for 'public: static class std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
.text$di:00001D1C ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc near
.text$di:00001D1C                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Generic_object$initializer$)(void)o
.text$di:00001D1C                 push    ebp
.text$di:00001D1D                 mov     ebp, esp
.text$di:00001D1F                 mov     ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
.text$di:00001D24                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$di:00001D29                 push    offset ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:00001D2E                 call    _atexit
.text$di:00001D33                 add     esp, 4
.text$di:00001D36                 pop     ebp
.text$di:00001D37                 retn
.text$di:00001D37 ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp
.text$di:00001D37
.text$di:00001D37 _text$di        ends
.text$di:00001D37
.text$di:00001D38 ; ===========================================================================
.text$di:00001D38
.text$di:00001D38 ; Segment type: Pure code
.text$di:00001D38 ; Segment permissions: Read/Execute
.text$di:00001D38 _text$di        segment para public 'CODE' use32
.text$di:00001D38                 assume cs:_text$di
.text$di:00001D38                 ;org 1D38h
.text$di:00001D38 ; COMDAT (pick any)
.text$di:00001D38                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00001D38
.text$di:00001D38 ; =============== S U B R O U T I N E =======================================
.text$di:00001D38
.text$di:00001D38 ; Attributes: bp-based frame
.text$di:00001D38
.text$di:00001D38 ; void __cdecl `dynamic initializer for 'public: static class std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
.text$di:00001D38 ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
.text$di:00001D38                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Iostream_object$initializer$)(void)o
.text$di:00001D38                 push    ebp
.text$di:00001D39                 mov     ebp, esp
.text$di:00001D3B                 mov     ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
.text$di:00001D40                 call    ??0_Iostream_error_category@std@@QAE@XZ ; std::_Iostream_error_category::_Iostream_error_category(void)
.text$di:00001D45                 push    offset ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:00001D4A                 call    _atexit
.text$di:00001D4F                 add     esp, 4
.text$di:00001D52                 pop     ebp
.text$di:00001D53                 retn
.text$di:00001D53 ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp
.text$di:00001D53
.text$di:00001D53 _text$di        ends
.text$di:00001D53
.text$di:00001D54 ; ===========================================================================
.text$di:00001D54
.text$di:00001D54 ; Segment type: Pure code
.text$di:00001D54 ; Segment permissions: Read/Execute
.text$di:00001D54 _text$di        segment para public 'CODE' use32
.text$di:00001D54                 assume cs:_text$di
.text$di:00001D54                 ;org 1D54h
.text$di:00001D54 ; COMDAT (pick any)
.text$di:00001D54                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00001D54
.text$di:00001D54 ; =============== S U B R O U T I N E =======================================
.text$di:00001D54
.text$di:00001D54 ; Attributes: bp-based frame
.text$di:00001D54
.text$di:00001D54 ; void __cdecl `dynamic initializer for 'public: static class std::_System_error_category std::_Error_objects<int>::_System_object''(void)
.text$di:00001D54 ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
.text$di:00001D54                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_System_object$initializer$)(void)o
.text$di:00001D54                 push    ebp
.text$di:00001D55                 mov     ebp, esp
.text$di:00001D57                 mov     ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
.text$di:00001D5C                 call    ??0_System_error_category@std@@QAE@XZ ; std::_System_error_category::_System_error_category(void)
.text$di:00001D61                 push    offset ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:00001D66                 call    _atexit
.text$di:00001D6B                 add     esp, 4
.text$di:00001D6E                 pop     ebp
.text$di:00001D6F                 retn
.text$di:00001D6F ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp
.text$di:00001D6F
.text$di:00001D6F _text$di        ends
.text$di:00001D6F
.text$di:00001D70 ; ===========================================================================
.text$di:00001D70
.text$di:00001D70 ; Segment type: Pure code
.text$di:00001D70 ; Segment permissions: Read/Execute
.text$di:00001D70 _text$di        segment para public 'CODE' use32
.text$di:00001D70                 assume cs:_text$di
.text$di:00001D70                 ;org 1D70h
.text$di:00001D70 ; COMDAT (pick any)
.text$di:00001D70                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00001D70
.text$di:00001D70 ; =============== S U B R O U T I N E =======================================
.text$di:00001D70
.text$di:00001D70 ; Attributes: bp-based frame
.text$di:00001D70
.text$di:00001D70 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::num_put<char, class std::back_insert_iterator<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>::id''(void)
.text$di:00001D70 ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00001D70                                         ; DATA XREF: .CRT$XCU:void (*std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id$initializer$)(void)o
.text$di:00001D70                 push    ebp
.text$di:00001D71                 mov     ebp, esp
.text$di:00001D73                 push    0               ; unsigned int
.text$di:00001D75                 mov     ecx, offset ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; this
.text$di:00001D7A                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00001D7F                 pop     ebp
.text$di:00001D80                 retn
.text$di:00001D80 ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00001D80
.text$di:00001D80 ; ---------------------------------------------------------------------------
.text$di:00001D81                 align 4
.text$di:00001D81 _text$di        ends
.text$di:00001D81
.text$di:00001D84 ; ===========================================================================
.text$di:00001D84
.text$di:00001D84 ; Segment type: Pure code
.text$di:00001D84 ; Segment permissions: Read/Execute
.text$di:00001D84 _text$di        segment para public 'CODE' use32
.text$di:00001D84                 assume cs:_text$di
.text$di:00001D84                 ;org 1D84h
.text$di:00001D84 ; COMDAT (pick any)
.text$di:00001D84                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00001D84
.text$di:00001D84 ; =============== S U B R O U T I N E =======================================
.text$di:00001D84
.text$di:00001D84 ; Attributes: bp-based frame
.text$di:00001D84
.text$di:00001D84 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::num_put<wchar_t, class std::back_insert_iterator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::id''(void)
.text$di:00001D84 ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00001D84                                         ; DATA XREF: .CRT$XCU:void (*std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id$initializer$)(void)o
.text$di:00001D84                 push    ebp
.text$di:00001D85                 mov     ebp, esp
.text$di:00001D87                 push    0               ; unsigned int
.text$di:00001D89                 mov     ecx, offset ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; this
.text$di:00001D8E                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00001D93                 pop     ebp
.text$di:00001D94                 retn
.text$di:00001D94 ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00001D94
.text$di:00001D94 ; ---------------------------------------------------------------------------
.text$di:00001D95                 align 4
.text$di:00001D95 _text$di        ends
.text$di:00001D95
.text$di:00001D98 ; ===========================================================================
.text$di:00001D98
.text$di:00001D98 ; Segment type: Pure code
.text$di:00001D98 ; Segment permissions: Read/Execute
.text$di:00001D98 _text$di        segment para public 'CODE' use32
.text$di:00001D98                 assume cs:_text$di
.text$di:00001D98                 ;org 1D98h
.text$di:00001D98 ; COMDAT (pick any)
.text$di:00001D98                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00001D98
.text$di:00001D98 ; =============== S U B R O U T I N E =======================================
.text$di:00001D98
.text$di:00001D98 ; Attributes: bp-based frame
.text$di:00001D98
.text$di:00001D98 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::numpunct<char>::id''(void)
.text$di:00001D98 ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00001D98                                         ; DATA XREF: .CRT$XCU:void (*std::numpunct<char>::id$initializer$)(void)o
.text$di:00001D98                 push    ebp
.text$di:00001D99                 mov     ebp, esp
.text$di:00001D9B                 push    0               ; unsigned int
.text$di:00001D9D                 mov     ecx, offset ?id@?$numpunct@D@std@@2V0locale@2@A ; this
.text$di:00001DA2                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00001DA7                 pop     ebp
.text$di:00001DA8                 retn
.text$di:00001DA8 ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00001DA8
.text$di:00001DA8 ; ---------------------------------------------------------------------------
.text$di:00001DA9                 align 4
.text$di:00001DA9 _text$di        ends
.text$di:00001DA9
.text$di:00001DAC ; ===========================================================================
.text$di:00001DAC
.text$di:00001DAC ; Segment type: Pure code
.text$di:00001DAC ; Segment permissions: Read/Execute
.text$di:00001DAC _text$di        segment para public 'CODE' use32
.text$di:00001DAC                 assume cs:_text$di
.text$di:00001DAC                 ;org 1DACh
.text$di:00001DAC ; COMDAT (pick any)
.text$di:00001DAC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00001DAC
.text$di:00001DAC ; =============== S U B R O U T I N E =======================================
.text$di:00001DAC
.text$di:00001DAC ; Attributes: bp-based frame
.text$di:00001DAC
.text$di:00001DAC ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::numpunct<wchar_t>::id''(void)
.text$di:00001DAC ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00001DAC                                         ; DATA XREF: .CRT$XCU:void (*std::numpunct<wchar_t>::id$initializer$)(void)o
.text$di:00001DAC                 push    ebp
.text$di:00001DAD                 mov     ebp, esp
.text$di:00001DAF                 push    0               ; unsigned int
.text$di:00001DB1                 mov     ecx, offset ?id@?$numpunct@_W@std@@2V0locale@2@A ; this
.text$di:00001DB6                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00001DBB                 pop     ebp
.text$di:00001DBC                 retn
.text$di:00001DBC ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00001DBC
.text$di:00001DBC ; ---------------------------------------------------------------------------
.text$di:00001DBD                 align 10h
.text$di:00001DBD _text$di        ends
.text$di:00001DBD
.text$di:00001DC0 ; ===========================================================================
.text$di:00001DC0
.text$di:00001DC0 ; Segment type: Pure code
.text$di:00001DC0 ; Segment permissions: Read/Execute
.text$di:00001DC0 _text$di        segment para public 'CODE' use32
.text$di:00001DC0                 assume cs:_text$di
.text$di:00001DC0                 ;org 1DC0h
.text$di:00001DC0 ; COMDAT (pick any)
.text$di:00001DC0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00001DC0
.text$di:00001DC0 ; =============== S U B R O U T I N E =======================================
.text$di:00001DC0
.text$di:00001DC0 ; Attributes: bp-based frame
.text$di:00001DC0
.text$di:00001DC0 ; void __cdecl std::`dynamic initializer for '_Tuple_alloc''(void)
.text$di:00001DC0 ??__E_Tuple_alloc@std@@YAXXZ proc near  ; DATA XREF: .CRT$XCU:__Tuple_alloc$initializer$o
.text$di:00001DC0
.text$di:00001DC0 var_1           = byte ptr -1
.text$di:00001DC0
.text$di:00001DC0                 push    ebp
.text$di:00001DC1                 mov     ebp, esp
.text$di:00001DC3                 push    ecx
.text$di:00001DC4                 xor     eax, eax
.text$di:00001DC6                 mov     [ebp+var_1], al
.text$di:00001DC9                 mov     esp, ebp
.text$di:00001DCB                 pop     ebp
.text$di:00001DCC                 retn
.text$di:00001DCC ??__E_Tuple_alloc@std@@YAXXZ endp
.text$di:00001DCC
.text$di:00001DCC ; ---------------------------------------------------------------------------
.text$di:00001DCD                 align 10h
.text$di:00001DCD _text$di        ends
.text$di:00001DCD
.text$di:00001DD0 ; ===========================================================================
.text$di:00001DD0
.text$di:00001DD0 ; Segment type: Pure code
.text$di:00001DD0 ; Segment permissions: Read/Execute
.text$di:00001DD0 _text$di        segment para public 'CODE' use32
.text$di:00001DD0                 assume cs:_text$di
.text$di:00001DD0                 ;org 1DD0h
.text$di:00001DD0 ; COMDAT (pick any)
.text$di:00001DD0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00001DD0
.text$di:00001DD0 ; =============== S U B R O U T I N E =======================================
.text$di:00001DD0
.text$di:00001DD0 ; Attributes: bp-based frame
.text$di:00001DD0
.text$di:00001DD0 ; void __cdecl std::`dynamic initializer for 'allocator_arg''(void)
.text$di:00001DD0 ??__Eallocator_arg@std@@YAXXZ proc near ; DATA XREF: .CRT$XCU:_allocator_arg$initializer$o
.text$di:00001DD0
.text$di:00001DD0 var_1           = byte ptr -1
.text$di:00001DD0
.text$di:00001DD0                 push    ebp
.text$di:00001DD1                 mov     ebp, esp
.text$di:00001DD3                 push    ecx
.text$di:00001DD4                 xor     eax, eax
.text$di:00001DD6                 mov     [ebp+var_1], al
.text$di:00001DD9                 mov     esp, ebp
.text$di:00001DDB                 pop     ebp
.text$di:00001DDC                 retn
.text$di:00001DDC ??__Eallocator_arg@std@@YAXXZ endp
.text$di:00001DDC
.text$di:00001DDC ; ---------------------------------------------------------------------------
.text$di:00001DDD                 align 10h
.text$di:00001DDD _text$di        ends
.text$di:00001DDD
.text$di:00001DE0 ; ===========================================================================
.text$di:00001DE0
.text$di:00001DE0 ; Segment type: Pure code
.text$di:00001DE0 ; Segment permissions: Read/Execute
.text$di:00001DE0 _text$di        segment para public 'CODE' use32
.text$di:00001DE0                 assume cs:_text$di
.text$di:00001DE0                 ;org 1DE0h
.text$di:00001DE0 ; COMDAT (pick any)
.text$di:00001DE0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00001DE0
.text$di:00001DE0 ; =============== S U B R O U T I N E =======================================
.text$di:00001DE0
.text$di:00001DE0 ; Attributes: bp-based frame
.text$di:00001DE0
.text$di:00001DE0 ; void __cdecl std::`dynamic initializer for 'ignore''(void)
.text$di:00001DE0 ??__Eignore@std@@YAXXZ proc near        ; DATA XREF: .CRT$XCU:_ignore$initializer$o
.text$di:00001DE0                 push    ebp
.text$di:00001DE1                 mov     ebp, esp
.text$di:00001DE3                 mov     ecx, offset _ignore ; this
.text$di:00001DE8                 call    ??0_Ignore@std@@QAE@XZ ; std::_Ignore::_Ignore(void)
.text$di:00001DED                 pop     ebp
.text$di:00001DEE                 retn
.text$di:00001DEE ??__Eignore@std@@YAXXZ endp
.text$di:00001DEE
.text$di:00001DEE ; ---------------------------------------------------------------------------
.text$di:00001DEF                 align 10h
.text$di:00001DEF _text$di        ends
.text$di:00001DEF
.text$di:00001DF0 ; ===========================================================================
.text$di:00001DF0
.text$di:00001DF0 ; Segment type: Pure code
.text$di:00001DF0 ; Segment permissions: Read/Execute
.text$di:00001DF0 _text$di        segment para public 'CODE' use32
.text$di:00001DF0                 assume cs:_text$di
.text$di:00001DF0                 ;org 1DF0h
.text$di:00001DF0 ; COMDAT (pick any)
.text$di:00001DF0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00001DF0
.text$di:00001DF0 ; =============== S U B R O U T I N E =======================================
.text$di:00001DF0
.text$di:00001DF0 ; Attributes: bp-based frame
.text$di:00001DF0
.text$di:00001DF0 ; void __cdecl std::`dynamic initializer for 'piecewise_construct''(void)
.text$di:00001DF0 ??__Epiecewise_construct@std@@YAXXZ proc near
.text$di:00001DF0                                         ; DATA XREF: .CRT$XCU:_piecewise_construct$initializer$o
.text$di:00001DF0
.text$di:00001DF0 var_1           = byte ptr -1
.text$di:00001DF0
.text$di:00001DF0                 push    ebp
.text$di:00001DF1                 mov     ebp, esp
.text$di:00001DF3                 push    ecx
.text$di:00001DF4                 xor     eax, eax
.text$di:00001DF6                 mov     [ebp+var_1], al
.text$di:00001DF9                 mov     esp, ebp
.text$di:00001DFB                 pop     ebp
.text$di:00001DFC                 retn
.text$di:00001DFC ??__Epiecewise_construct@std@@YAXXZ endp
.text$di:00001DFC
.text$di:00001DFC ; ---------------------------------------------------------------------------
.text$di:00001DFD                 align 10h
.text$di:00001DFD _text$di        ends
.text$di:00001DFD
.text$yd:00001E00 ; ===========================================================================
.text$yd:00001E00
.text$yd:00001E00 ; Segment type: Pure code
.text$yd:00001E00 ; Segment permissions: Read/Execute
.text$yd:00001E00 _text$yd        segment para public 'CODE' use32
.text$yd:00001E00                 assume cs:_text$yd
.text$yd:00001E00                 ;org 1E00h
.text$yd:00001E00 ; COMDAT (pick any)
.text$yd:00001E00                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$yd:00001E00
.text$yd:00001E00 ; =============== S U B R O U T I N E =======================================
.text$yd:00001E00
.text$yd:00001E00 ; Attributes: bp-based frame
.text$yd:00001E00
.text$yd:00001E00 ; void __cdecl `dynamic atexit destructor for 'public: static std::_Generic_error_category std::_Error_objects<int>::_Generic_object''()
.text$yd:00001E00 ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc near
.text$yd:00001E00                                         ; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+Do
.text$yd:00001E00                 push    ebp
.text$yd:00001E01                 mov     ebp, esp
.text$yd:00001E03                 mov     ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
.text$yd:00001E08                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$yd:00001E0D                 pop     ebp
.text$yd:00001E0E                 retn
.text$yd:00001E0E ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp
.text$yd:00001E0E
.text$yd:00001E0E ; ---------------------------------------------------------------------------
.text$yd:00001E0F                 align 10h
.text$yd:00001E0F _text$yd        ends
.text$yd:00001E0F
.text$yd:00001E10 ; ===========================================================================
.text$yd:00001E10
.text$yd:00001E10 ; Segment type: Pure code
.text$yd:00001E10 ; Segment permissions: Read/Execute
.text$yd:00001E10 _text$yd        segment para public 'CODE' use32
.text$yd:00001E10                 assume cs:_text$yd
.text$yd:00001E10                 ;org 1E10h
.text$yd:00001E10 ; COMDAT (pick any)
.text$yd:00001E10                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$yd:00001E10
.text$yd:00001E10 ; =============== S U B R O U T I N E =======================================
.text$yd:00001E10
.text$yd:00001E10 ; Attributes: bp-based frame
.text$yd:00001E10
.text$yd:00001E10 ; void __cdecl `dynamic atexit destructor for 'public: static std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''()
.text$yd:00001E10 ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
.text$yd:00001E10                                         ; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+Do
.text$yd:00001E10                 push    ebp
.text$yd:00001E11                 mov     ebp, esp
.text$yd:00001E13                 mov     ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
.text$yd:00001E18                 call    ??1_Iostream_error_category@std@@UAE@XZ ; std::_Iostream_error_category::~_Iostream_error_category(void)
.text$yd:00001E1D                 pop     ebp
.text$yd:00001E1E                 retn
.text$yd:00001E1E ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp
.text$yd:00001E1E
.text$yd:00001E1E ; ---------------------------------------------------------------------------
.text$yd:00001E1F                 align 10h
.text$yd:00001E1F _text$yd        ends
.text$yd:00001E1F
.text$yd:00001E20 ; ===========================================================================
.text$yd:00001E20
.text$yd:00001E20 ; Segment type: Pure code
.text$yd:00001E20 ; Segment permissions: Read/Execute
.text$yd:00001E20 _text$yd        segment para public 'CODE' use32
.text$yd:00001E20                 assume cs:_text$yd
.text$yd:00001E20                 ;org 1E20h
.text$yd:00001E20 ; COMDAT (pick any)
.text$yd:00001E20                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$yd:00001E20
.text$yd:00001E20 ; =============== S U B R O U T I N E =======================================
.text$yd:00001E20
.text$yd:00001E20 ; Attributes: bp-based frame
.text$yd:00001E20
.text$yd:00001E20 ; void __cdecl `dynamic atexit destructor for 'public: static std::_System_error_category std::_Error_objects<int>::_System_object''()
.text$yd:00001E20 ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
.text$yd:00001E20                                         ; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+Do
.text$yd:00001E20                 push    ebp
.text$yd:00001E21                 mov     ebp, esp
.text$yd:00001E23                 mov     ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
.text$yd:00001E28                 call    ??1_System_error_category@std@@UAE@XZ ; std::_System_error_category::~_System_error_category(void)
.text$yd:00001E2D                 pop     ebp
.text$yd:00001E2E                 retn
.text$yd:00001E2E ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp
.text$yd:00001E2E
.text$yd:00001E2E ; ---------------------------------------------------------------------------
.text$yd:00001E2F                 align 10h
.text$yd:00001E2F _text$yd        ends
.text$yd:00001E2F
.text$mn:00001E30 ; ===========================================================================
.text$mn:00001E30
.text$mn:00001E30 ; Segment type: Pure code
.text$mn:00001E30 ; Segment permissions: Read/Execute
.text$mn:00001E30 _text$mn        segment para public 'CODE' use32
.text$mn:00001E30                 assume cs:_text$mn
.text$mn:00001E30                 ;org 1E30h
.text$mn:00001E30 ; COMDAT (pick any)
.text$mn:00001E30                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001E30
.text$mn:00001E30 ; =============== S U B R O U T I N E =======================================
.text$mn:00001E30
.text$mn:00001E30 ; Attributes: bp-based frame
.text$mn:00001E30
.text$mn:00001E30 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Alloc_proxy(void)
.text$mn:00001E30                 public ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
.text$mn:00001E30 ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00001E30                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+38p
.text$mn:00001E30
.text$mn:00001E30 var_10          = byte ptr -10h
.text$mn:00001E30 var_8           = dword ptr -8
.text$mn:00001E30 var_1           = byte ptr -1
.text$mn:00001E30
.text$mn:00001E30                 push    ebp
.text$mn:00001E31                 mov     ebp, esp
.text$mn:00001E33                 sub     esp, 10h
.text$mn:00001E36                 mov     [ebp+var_8], ecx
.text$mn:00001E39                 lea     ecx, [ebp+var_1]
.text$mn:00001E3C                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:00001E41                 push    1
.text$mn:00001E43                 lea     ecx, [ebp+var_1]
.text$mn:00001E46                 call    ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate(uint)
.text$mn:00001E4B                 mov     ecx, [ebp+var_8]
.text$mn:00001E4E                 mov     [ecx], eax
.text$mn:00001E50                 lea     ecx, [ebp+var_10] ; this
.text$mn:00001E53                 call    ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy(void)
.text$mn:00001E58                 push    eax             ; int
.text$mn:00001E59                 mov     edx, [ebp+var_8]
.text$mn:00001E5C                 mov     eax, [edx]
.text$mn:00001E5E                 push    eax             ; void *
.text$mn:00001E5F                 lea     ecx, [ebp+var_1]
.text$mn:00001E62                 call    ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:00001E67                 mov     ecx, [ebp+var_8]
.text$mn:00001E6A                 mov     edx, [ecx]
.text$mn:00001E6C                 mov     eax, [ebp+var_8]
.text$mn:00001E6F                 mov     [edx], eax
.text$mn:00001E71                 mov     esp, ebp
.text$mn:00001E73                 pop     ebp
.text$mn:00001E74                 retn
.text$mn:00001E74 ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp
.text$mn:00001E74
.text$mn:00001E74 ; ---------------------------------------------------------------------------
.text$mn:00001E75                 align 4
.text$mn:00001E75 _text$mn        ends
.text$mn:00001E75
.text$mn:00001E78 ; ===========================================================================
.text$mn:00001E78
.text$mn:00001E78 ; Segment type: Pure code
.text$mn:00001E78 ; Segment permissions: Read/Execute
.text$mn:00001E78 _text$mn        segment para public 'CODE' use32
.text$mn:00001E78                 assume cs:_text$mn
.text$mn:00001E78                 ;org 1E78h
.text$mn:00001E78 ; COMDAT (pick any)
.text$mn:00001E78                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001E78
.text$mn:00001E78 ; =============== S U B R O U T I N E =======================================
.text$mn:00001E78
.text$mn:00001E78 ; Attributes: bp-based frame
.text$mn:00001E78
.text$mn:00001E78 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Copy(unsigned int, unsigned int)
.text$mn:00001E78                 public ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00001E78 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
.text$mn:00001E78                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+37p
.text$mn:00001E78
.text$mn:00001E78 var_20          = dword ptr -20h
.text$mn:00001E78 var_1C          = dword ptr -1Ch
.text$mn:00001E78 var_18          = dword ptr -18h
.text$mn:00001E78 var_11          = byte ptr -11h
.text$mn:00001E78 var_10          = dword ptr -10h
.text$mn:00001E78 var_C           = byte ptr -0Ch
.text$mn:00001E78 var_4           = dword ptr -4
.text$mn:00001E78 arg_0           = dword ptr  8
.text$mn:00001E78
.text$mn:00001E78 ; FUNCTION CHUNK AT .text$mn:00001F9A SIZE 00000009 BYTES
.text$mn:00001E78
.text$mn:00001E78                 push    ebp
.text$mn:00001E79                 mov     ebp, esp
.text$mn:00001E7B                 push    0FFFFFFFFh
.text$mn:00001E7D                 push    offset __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00001E82                 mov     eax, large fs:0
.text$mn:00001E88                 push    eax
.text$mn:00001E89                 push    ecx
.text$mn:00001E8A                 sub     esp, 10h
.text$mn:00001E8D                 push    ebx
.text$mn:00001E8E                 push    esi
.text$mn:00001E8F                 push    edi
.text$mn:00001E90                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001E95                 xor     eax, ebp
.text$mn:00001E97                 push    eax
.text$mn:00001E98                 lea     eax, [ebp+var_C]
.text$mn:00001E9B                 mov     large fs:0, eax
.text$mn:00001EA1                 mov     [ebp+var_10], esp
.text$mn:00001EA4                 mov     [ebp+var_18], ecx
.text$mn:00001EA7                 mov     eax, [ebp+arg_0]
.text$mn:00001EAA                 or      eax, 0Fh
.text$mn:00001EAD                 mov     [ebp+var_1C], eax
.text$mn:00001EB0                 mov     ecx, [ebp+var_18]
.text$mn:00001EB3                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00001EB8                 cmp     eax, [ebp+var_1C]
.text$mn:00001EBB                 jnb     short loc_1EC5
.text$mn:00001EBD                 mov     ecx, [ebp+arg_0]
.text$mn:00001EC0                 mov     [ebp+var_1C], ecx
.text$mn:00001EC3                 jmp     short loc_1F17
.text$mn:00001EC5 ; ---------------------------------------------------------------------------
.text$mn:00001EC5
.text$mn:00001EC5 loc_1EC5:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+43j
.text$mn:00001EC5                 mov     edx, [ebp+var_18]
.text$mn:00001EC8                 mov     ecx, [edx+18h]
.text$mn:00001ECB                 shr     ecx, 1
.text$mn:00001ECD                 mov     eax, [ebp+var_1C]
.text$mn:00001ED0                 xor     edx, edx
.text$mn:00001ED2                 mov     esi, 3
.text$mn:00001ED7                 div     esi
.text$mn:00001ED9                 cmp     ecx, eax
.text$mn:00001EDB                 ja      short loc_1EDF
.text$mn:00001EDD                 jmp     short loc_1F17
.text$mn:00001EDF ; ---------------------------------------------------------------------------
.text$mn:00001EDF
.text$mn:00001EDF loc_1EDF:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+63j
.text$mn:00001EDF                 mov     ecx, [ebp+var_18]
.text$mn:00001EE2                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00001EE7                 mov     edx, [ebp+var_18]
.text$mn:00001EEA                 mov     ecx, [edx+18h]
.text$mn:00001EED                 shr     ecx, 1
.text$mn:00001EEF                 sub     eax, ecx
.text$mn:00001EF1                 mov     edx, [ebp+var_18]
.text$mn:00001EF4                 cmp     [edx+18h], eax
.text$mn:00001EF7                 ja      short loc_1F0C
.text$mn:00001EF9                 mov     eax, [ebp+var_18]
.text$mn:00001EFC                 mov     ecx, [eax+18h]
.text$mn:00001EFF                 shr     ecx, 1
.text$mn:00001F01                 mov     edx, [ebp+var_18]
.text$mn:00001F04                 add     ecx, [edx+18h]
.text$mn:00001F07                 mov     [ebp+var_1C], ecx
.text$mn:00001F0A                 jmp     short loc_1F17
.text$mn:00001F0C ; ---------------------------------------------------------------------------
.text$mn:00001F0C
.text$mn:00001F0C loc_1F0C:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+7Fj
.text$mn:00001F0C                 mov     ecx, [ebp+var_18]
.text$mn:00001F0F                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00001F14                 mov     [ebp+var_1C], eax
.text$mn:00001F17
.text$mn:00001F17 loc_1F17:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+4Bj
.text$mn:00001F17                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+65j ...
.text$mn:00001F17                 mov     [ebp+var_4], 0
.text$mn:00001F1E                 mov     eax, [ebp+var_1C]
.text$mn:00001F21                 add     eax, 1
.text$mn:00001F24                 push    eax
.text$mn:00001F25                 lea     ecx, [ebp+var_11]
.text$mn:00001F28                 push    ecx
.text$mn:00001F29                 mov     ecx, [ebp+var_18]
.text$mn:00001F2C                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00001F31                 mov     ecx, eax
.text$mn:00001F33                 call    ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
.text$mn:00001F38                 mov     [ebp+var_20], eax
.text$mn:00001F3B                 jmp     short loc_1F9A
.text$mn:00001F3B ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp
.text$mn:00001F3B
.text$mn:00001F3D
.text$mn:00001F3D ; =============== S U B R O U T I N E =======================================
.text$mn:00001F3D
.text$mn:00001F3D
.text$mn:00001F3D __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 proc near
.text$mn:00001F3D                                         ; DATA XREF: .xdata$x:00002D70o
.text$mn:00001F3D
.text$mn:00001F3D ; FUNCTION CHUNK AT .text$mn:00001F84 SIZE 00000009 BYTES
.text$mn:00001F3D ; FUNCTION CHUNK AT .text$mn:00001F94 SIZE 00000006 BYTES
.text$mn:00001F3D
.text$mn:00001F3D                 mov     [ebp-10h], esp
.text$mn:00001F40                 mov     edx, [ebp+8]
.text$mn:00001F43                 mov     [ebp-1Ch], edx
.text$mn:00001F46                 mov     byte ptr [ebp-4], 2
.text$mn:00001F4A                 mov     eax, [ebp-1Ch]
.text$mn:00001F4D                 add     eax, 1
.text$mn:00001F50                 push    eax
.text$mn:00001F51                 lea     ecx, [ebp-12h]
.text$mn:00001F54                 push    ecx
.text$mn:00001F55                 mov     ecx, [ebp-18h]
.text$mn:00001F58                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00001F5D                 mov     ecx, eax
.text$mn:00001F5F                 call    ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
.text$mn:00001F64                 mov     [ebp-20h], eax
.text$mn:00001F67                 jmp     short loc_1F84
.text$mn:00001F67 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 endp
.text$mn:00001F67
.text$mn:00001F69
.text$mn:00001F69 ; =============== S U B R O U T I N E =======================================
.text$mn:00001F69
.text$mn:00001F69 ; Attributes: noreturn
.text$mn:00001F69
.text$mn:00001F69 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 proc near
.text$mn:00001F69                                         ; DATA XREF: .xdata$x:00002D80o
.text$mn:00001F69                 push    0               ; Size
.text$mn:00001F6B                 push    1               ; char
.text$mn:00001F6D                 mov     ecx, [ebp-18h]
.text$mn:00001F70                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00001F75                 push    0
.text$mn:00001F77                 push    0
.text$mn:00001F79                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00001F79 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 endp
.text$mn:00001F79
.text$mn:00001F7E ; ---------------------------------------------------------------------------
.text$mn:00001F7E                 mov     eax, offset $LN17
.text$mn:00001F83                 retn
.text$mn:00001F84 ; ---------------------------------------------------------------------------
.text$mn:00001F84 ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00001F84
.text$mn:00001F84 loc_1F84:                               ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+2Aj
.text$mn:00001F84                 mov     dword ptr [ebp-4], 1
.text$mn:00001F8B                 jmp     short loc_1F94
.text$mn:00001F8B ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00001F8D
.text$mn:00001F8D ; =============== S U B R O U T I N E =======================================
.text$mn:00001F8D
.text$mn:00001F8D
.text$mn:00001F8D $LN17           proc near               ; DATA XREF: .text$mn:00001F7Eo
.text$mn:00001F8D                 mov     dword ptr [ebp-4], 1
.text$mn:00001F8D $LN17           endp ; sp-analysis failed
.text$mn:00001F8D
.text$mn:00001F94 ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00001F94
.text$mn:00001F94 loc_1F94:                               ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+4Ej
.text$mn:00001F94                 mov     eax, offset $LN19
.text$mn:00001F99                 retn
.text$mn:00001F99 ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00001F9A ; ---------------------------------------------------------------------------
.text$mn:00001F9A ; START OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00001F9A
.text$mn:00001F9A loc_1F9A:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+C3j
.text$mn:00001F9A                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001FA1                 jmp     short loc_1FAA
.text$mn:00001FA1 ; END OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00001FA3
.text$mn:00001FA3 ; =============== S U B R O U T I N E =======================================
.text$mn:00001FA3
.text$mn:00001FA3
.text$mn:00001FA3 $LN19           proc near               ; DATA XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:loc_1F94o
.text$mn:00001FA3                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:00001FAA
.text$mn:00001FAA loc_1FAA:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+129j
.text$mn:00001FAA                 cmp     dword ptr [ebp+0Ch], 0
.text$mn:00001FAE                 jbe     short loc_1FC9
.text$mn:00001FB0                 mov     edx, [ebp+0Ch]
.text$mn:00001FB3                 push    edx             ; Size
.text$mn:00001FB4                 mov     ecx, [ebp-18h]
.text$mn:00001FB7                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00001FBC                 push    eax             ; Src
.text$mn:00001FBD                 mov     eax, [ebp-20h]
.text$mn:00001FC0                 push    eax             ; Dst
.text$mn:00001FC1                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00001FC6                 add     esp, 0Ch
.text$mn:00001FC9
.text$mn:00001FC9 loc_1FC9:                               ; CODE XREF: $LN19+Bj
.text$mn:00001FC9                 push    0               ; Size
.text$mn:00001FCB                 push    1               ; char
.text$mn:00001FCD                 mov     ecx, [ebp-18h]
.text$mn:00001FD0                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00001FD5                 lea     ecx, [ebp-20h]
.text$mn:00001FD8                 push    ecx             ; int
.text$mn:00001FD9                 mov     edx, [ebp-18h]
.text$mn:00001FDC                 add     edx, 4
.text$mn:00001FDF                 push    edx             ; void *
.text$mn:00001FE0                 lea     eax, [ebp-13h]
.text$mn:00001FE3                 push    eax
.text$mn:00001FE4                 mov     ecx, [ebp-18h]
.text$mn:00001FE7                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00001FEC                 mov     ecx, eax
.text$mn:00001FEE                 call    ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)
.text$mn:00001FF3                 mov     ecx, [ebp-18h]
.text$mn:00001FF6                 mov     edx, [ebp-1Ch]
.text$mn:00001FF9                 mov     [ecx+18h], edx
.text$mn:00001FFC                 mov     eax, [ebp+0Ch]
.text$mn:00001FFF                 push    eax
.text$mn:00002000                 mov     ecx, [ebp-18h]
.text$mn:00002003                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00002008                 mov     ecx, [ebp-0Ch]
.text$mn:0000200B                 mov     large fs:0, ecx
.text$mn:00002012                 pop     ecx
.text$mn:00002013                 pop     edi
.text$mn:00002014                 pop     esi
.text$mn:00002015                 pop     ebx
.text$mn:00002016                 mov     esp, ebp
.text$mn:00002018                 pop     ebp
.text$mn:00002019                 retn    8
.text$mn:00002019 $LN19           endp ; sp-analysis failed
.text$mn:00002019
.text$mn:00002019 _text$mn        ends
.text$mn:00002019
.text$x:0000201C ; ===========================================================================
.text$x:0000201C
.text$x:0000201C ; Segment type: Pure code
.text$x:0000201C ; Segment permissions: Read/Execute
.text$x:0000201C _text$x         segment para public 'CODE' use32
.text$x:0000201C                 assume cs:_text$x
.text$x:0000201C                 ;org 201Ch
.text$x:0000201C ; COMDAT (pick associative to section at 1E78)
.text$x:0000201C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000201C
.text$x:0000201C ; =============== S U B R O U T I N E =======================================
.text$x:0000201C
.text$x:0000201C
.text$x:0000201C __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
.text$x:0000201C                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+5o
.text$x:0000201C
.text$x:0000201C arg_4           = dword ptr  8
.text$x:0000201C
.text$x:0000201C                 mov     edx, [esp+arg_4]
.text$x:00002020                 lea     eax, [edx+0Ch]
.text$x:00002023                 mov     ecx, [edx-24h]
.text$x:00002026                 xor     ecx, eax
.text$x:00002028                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000202D                 mov     eax, offset __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$x:00002032                 jmp     ___CxxFrameHandler3
.text$x:00002032 __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp
.text$x:00002032
.text$x:00002032 ; ---------------------------------------------------------------------------
.text$x:00002037                 align 4
.text$x:00002037 _text$x         ends
.text$x:00002037
.text$mn:00002038 ; ===========================================================================
.text$mn:00002038
.text$mn:00002038 ; Segment type: Pure code
.text$mn:00002038 ; Segment permissions: Read/Execute
.text$mn:00002038 _text$mn        segment para public 'CODE' use32
.text$mn:00002038                 assume cs:_text$mn
.text$mn:00002038                 ;org 2038h
.text$mn:00002038 ; COMDAT (pick any)
.text$mn:00002038                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002038
.text$mn:00002038 ; =============== S U B R O U T I N E =======================================
.text$mn:00002038
.text$mn:00002038 ; Attributes: bp-based frame
.text$mn:00002038
.text$mn:00002038 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Eos(unsigned int)
.text$mn:00002038                 public ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
.text$mn:00002038 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z proc near
.text$mn:00002038                                         ; CODE XREF: $LN19+60p
.text$mn:00002038                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+83p ...
.text$mn:00002038
.text$mn:00002038 var_8           = dword ptr -8
.text$mn:00002038 var_1           = byte ptr -1
.text$mn:00002038 arg_0           = dword ptr  8
.text$mn:00002038
.text$mn:00002038                 push    ebp
.text$mn:00002039                 mov     ebp, esp
.text$mn:0000203B                 sub     esp, 8
.text$mn:0000203E                 mov     [ebp+var_8], ecx
.text$mn:00002041                 mov     [ebp+var_1], 0
.text$mn:00002045                 mov     eax, [ebp+var_8]
.text$mn:00002048                 mov     ecx, [ebp+arg_0]
.text$mn:0000204B                 mov     [eax+14h], ecx
.text$mn:0000204E                 lea     edx, [ebp+var_1]
.text$mn:00002051                 push    edx
.text$mn:00002052                 mov     ecx, [ebp+var_8]
.text$mn:00002055                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000205A                 add     eax, [ebp+arg_0]
.text$mn:0000205D                 push    eax
.text$mn:0000205E                 call    ?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign(char &,char const &)
.text$mn:00002063                 add     esp, 8
.text$mn:00002066                 mov     esp, ebp
.text$mn:00002068                 pop     ebp
.text$mn:00002069                 retn    4
.text$mn:00002069 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z endp
.text$mn:00002069
.text$mn:00002069 _text$mn        ends
.text$mn:00002069
.text$mn:0000206C ; ===========================================================================
.text$mn:0000206C
.text$mn:0000206C ; Segment type: Pure code
.text$mn:0000206C ; Segment permissions: Read/Execute
.text$mn:0000206C _text$mn        segment para public 'CODE' use32
.text$mn:0000206C                 assume cs:_text$mn
.text$mn:0000206C                 ;org 206Ch
.text$mn:0000206C ; COMDAT (pick any)
.text$mn:0000206C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000206C
.text$mn:0000206C ; =============== S U B R O U T I N E =======================================
.text$mn:0000206C
.text$mn:0000206C ; Attributes: bp-based frame
.text$mn:0000206C
.text$mn:0000206C ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Free_proxy(void)
.text$mn:0000206C                 public ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
.text$mn:0000206C ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
.text$mn:0000206C                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+30p
.text$mn:0000206C
.text$mn:0000206C var_8           = dword ptr -8
.text$mn:0000206C var_1           = byte ptr -1
.text$mn:0000206C
.text$mn:0000206C                 push    ebp
.text$mn:0000206D                 mov     ebp, esp
.text$mn:0000206F                 sub     esp, 8
.text$mn:00002072                 mov     [ebp+var_8], ecx
.text$mn:00002075                 lea     ecx, [ebp+var_1]
.text$mn:00002078                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:0000207D                 mov     ecx, [ebp+var_8] ; this
.text$mn:00002080                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00002085                 mov     eax, [ebp+var_8]
.text$mn:00002088                 mov     ecx, [eax]
.text$mn:0000208A                 push    ecx
.text$mn:0000208B                 lea     ecx, [ebp+var_1]
.text$mn:0000208E                 call    ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:00002093                 push    1               ; int
.text$mn:00002095                 mov     edx, [ebp+var_8]
.text$mn:00002098                 mov     eax, [edx]
.text$mn:0000209A                 push    eax             ; void *
.text$mn:0000209B                 lea     ecx, [ebp+var_1]
.text$mn:0000209E                 call    ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate(std::_Container_proxy *,uint)
.text$mn:000020A3                 mov     ecx, [ebp+var_8]
.text$mn:000020A6                 mov     dword ptr [ecx], 0
.text$mn:000020AC                 mov     esp, ebp
.text$mn:000020AE                 pop     ebp
.text$mn:000020AF                 retn
.text$mn:000020AF ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp
.text$mn:000020AF
.text$mn:000020AF _text$mn        ends
.text$mn:000020AF
.text$mn:000020B0 ; ===========================================================================
.text$mn:000020B0
.text$mn:000020B0 ; Segment type: Pure code
.text$mn:000020B0 ; Segment permissions: Read/Execute
.text$mn:000020B0 _text$mn        segment para public 'CODE' use32
.text$mn:000020B0                 assume cs:_text$mn
.text$mn:000020B0                 ;org 20B0h
.text$mn:000020B0 ; COMDAT (pick any)
.text$mn:000020B0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000020B0
.text$mn:000020B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000020B0
.text$mn:000020B0 ; Attributes: bp-based frame
.text$mn:000020B0
.text$mn:000020B0 ; public: struct std::_Wrap_alloc<class std::allocator<char>> __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Getal(void)const
.text$mn:000020B0                 public ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
.text$mn:000020B0 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ proc near
.text$mn:000020B0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+B4p
.text$mn:000020B0                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+1Bp ...
.text$mn:000020B0
.text$mn:000020B0 var_4           = dword ptr -4
.text$mn:000020B0 arg_0           = dword ptr  8
.text$mn:000020B0
.text$mn:000020B0                 push    ebp
.text$mn:000020B1                 mov     ebp, esp
.text$mn:000020B3                 push    ecx
.text$mn:000020B4                 mov     [ebp+var_4], ecx
.text$mn:000020B7                 mov     ecx, [ebp+arg_0]
.text$mn:000020BA                 call    ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)
.text$mn:000020BF                 mov     eax, [ebp+arg_0]
.text$mn:000020C2                 mov     esp, ebp
.text$mn:000020C4                 pop     ebp
.text$mn:000020C5                 retn    4
.text$mn:000020C5 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ endp
.text$mn:000020C5
.text$mn:000020C5 _text$mn        ends
.text$mn:000020C5
.text$mn:000020C8 ; ===========================================================================
.text$mn:000020C8
.text$mn:000020C8 ; Segment type: Pure code
.text$mn:000020C8 ; Segment permissions: Read/Execute
.text$mn:000020C8 _text$mn        segment para public 'CODE' use32
.text$mn:000020C8                 assume cs:_text$mn
.text$mn:000020C8                 ;org 20C8h
.text$mn:000020C8 ; COMDAT (pick any)
.text$mn:000020C8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000020C8
.text$mn:000020C8 ; =============== S U B R O U T I N E =======================================
.text$mn:000020C8
.text$mn:000020C8 ; Attributes: bp-based frame
.text$mn:000020C8
.text$mn:000020C8 ; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Grow(unsigned int, bool)
.text$mn:000020C8                 public ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
.text$mn:000020C8 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z proc near
.text$mn:000020C8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+6Ap
.text$mn:000020C8                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+5Fp
.text$mn:000020C8
.text$mn:000020C8 var_C           = dword ptr -0Ch
.text$mn:000020C8 Size            = dword ptr -8
.text$mn:000020C8 var_4           = dword ptr -4
.text$mn:000020C8 arg_0           = dword ptr  8
.text$mn:000020C8 arg_4           = byte ptr  0Ch
.text$mn:000020C8
.text$mn:000020C8                 push    ebp
.text$mn:000020C9                 mov     ebp, esp
.text$mn:000020CB                 sub     esp, 0Ch
.text$mn:000020CE                 mov     [ebp+var_4], ecx
.text$mn:000020D1                 mov     ecx, [ebp+var_4]
.text$mn:000020D4                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:000020D9                 cmp     eax, [ebp+arg_0]
.text$mn:000020DC                 jnb     short loc_20E6
.text$mn:000020DE                 mov     ecx, [ebp+var_4]
.text$mn:000020E1                 call    ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)
.text$mn:000020E6
.text$mn:000020E6 loc_20E6:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+14j
.text$mn:000020E6                 mov     eax, [ebp+var_4]
.text$mn:000020E9                 mov     ecx, [eax+18h]
.text$mn:000020EC                 cmp     ecx, [ebp+arg_0]
.text$mn:000020EF                 jnb     short loc_2106
.text$mn:000020F1                 mov     edx, [ebp+var_4]
.text$mn:000020F4                 mov     eax, [edx+14h]
.text$mn:000020F7                 push    eax
.text$mn:000020F8                 mov     ecx, [ebp+arg_0]
.text$mn:000020FB                 push    ecx
.text$mn:000020FC                 mov     ecx, [ebp+var_4]
.text$mn:000020FF                 call    ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)
.text$mn:00002104                 jmp     short loc_2150
.text$mn:00002106 ; ---------------------------------------------------------------------------
.text$mn:00002106
.text$mn:00002106 loc_2106:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+27j
.text$mn:00002106                 movzx   edx, [ebp+arg_4]
.text$mn:0000210A                 test    edx, edx
.text$mn:0000210C                 jz      short loc_2140
.text$mn:0000210E                 cmp     [ebp+arg_0], 10h
.text$mn:00002112                 jnb     short loc_2140
.text$mn:00002114                 mov     eax, [ebp+var_4]
.text$mn:00002117                 mov     ecx, [ebp+arg_0]
.text$mn:0000211A                 cmp     ecx, [eax+14h]
.text$mn:0000211D                 jnb     short loc_2127
.text$mn:0000211F                 mov     edx, [ebp+arg_0]
.text$mn:00002122                 mov     [ebp+Size], edx
.text$mn:00002125                 jmp     short loc_2130
.text$mn:00002127 ; ---------------------------------------------------------------------------
.text$mn:00002127
.text$mn:00002127 loc_2127:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+55j
.text$mn:00002127                 mov     eax, [ebp+var_4]
.text$mn:0000212A                 mov     ecx, [eax+14h]
.text$mn:0000212D                 mov     [ebp+Size], ecx
.text$mn:00002130
.text$mn:00002130 loc_2130:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+5Dj
.text$mn:00002130                 mov     edx, [ebp+Size]
.text$mn:00002133                 push    edx             ; Size
.text$mn:00002134                 push    1               ; char
.text$mn:00002136                 mov     ecx, [ebp+var_4]
.text$mn:00002139                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:0000213E                 jmp     short loc_2150
.text$mn:00002140 ; ---------------------------------------------------------------------------
.text$mn:00002140
.text$mn:00002140 loc_2140:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+44j
.text$mn:00002140                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+4Aj
.text$mn:00002140                 cmp     [ebp+arg_0], 0
.text$mn:00002144                 jnz     short loc_2150
.text$mn:00002146                 push    0
.text$mn:00002148                 mov     ecx, [ebp+var_4]
.text$mn:0000214B                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00002150
.text$mn:00002150 loc_2150:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+3Cj
.text$mn:00002150                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+76j ...
.text$mn:00002150                 cmp     [ebp+arg_0], 0
.text$mn:00002154                 jbe     short loc_215F
.text$mn:00002156                 mov     [ebp+var_C], 1
.text$mn:0000215D                 jmp     short loc_2166
.text$mn:0000215F ; ---------------------------------------------------------------------------
.text$mn:0000215F
.text$mn:0000215F loc_215F:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+8Cj
.text$mn:0000215F                 mov     [ebp+var_C], 0
.text$mn:00002166
.text$mn:00002166 loc_2166:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+95j
.text$mn:00002166                 mov     al, byte ptr [ebp+var_C]
.text$mn:00002169                 mov     esp, ebp
.text$mn:0000216B                 pop     ebp
.text$mn:0000216C                 retn    8
.text$mn:0000216C ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z endp
.text$mn:0000216C
.text$mn:0000216C ; ---------------------------------------------------------------------------
.text$mn:0000216F                 align 10h
.text$mn:0000216F _text$mn        ends
.text$mn:0000216F
.text$mn:00002170 ; ===========================================================================
.text$mn:00002170
.text$mn:00002170 ; Segment type: Pure code
.text$mn:00002170 ; Segment permissions: Read/Execute
.text$mn:00002170 _text$mn        segment para public 'CODE' use32
.text$mn:00002170                 assume cs:_text$mn
.text$mn:00002170                 ;org 2170h
.text$mn:00002170 ; COMDAT (pick any)
.text$mn:00002170                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002170
.text$mn:00002170 ; =============== S U B R O U T I N E =======================================
.text$mn:00002170
.text$mn:00002170 ; Attributes: bp-based frame
.text$mn:00002170
.text$mn:00002170 ; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Inside(char const *)
.text$mn:00002170                 public ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
.text$mn:00002170 ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z proc near
.text$mn:00002170                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+2Ap
.text$mn:00002170
.text$mn:00002170 var_4           = dword ptr -4
.text$mn:00002170 arg_0           = dword ptr  8
.text$mn:00002170
.text$mn:00002170                 push    ebp
.text$mn:00002171                 mov     ebp, esp
.text$mn:00002173                 push    ecx
.text$mn:00002174                 mov     [ebp+var_4], ecx
.text$mn:00002177                 cmp     [ebp+arg_0], 0
.text$mn:0000217B                 jz      short loc_219D
.text$mn:0000217D                 mov     ecx, [ebp+var_4]
.text$mn:00002180                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00002185                 cmp     [ebp+arg_0], eax
.text$mn:00002188                 jb      short loc_219D
.text$mn:0000218A                 mov     ecx, [ebp+var_4]
.text$mn:0000218D                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00002192                 mov     ecx, [ebp+var_4]
.text$mn:00002195                 add     eax, [ecx+14h]
.text$mn:00002198                 cmp     eax, [ebp+arg_0]
.text$mn:0000219B                 ja      short loc_21A3
.text$mn:0000219D
.text$mn:0000219D loc_219D:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+Bj
.text$mn:0000219D                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+18j
.text$mn:0000219D                 xor     al, al
.text$mn:0000219F                 jmp     short loc_21A5
.text$mn:000021A1 ; ---------------------------------------------------------------------------
.text$mn:000021A1                 jmp     short loc_21A5
.text$mn:000021A3 ; ---------------------------------------------------------------------------
.text$mn:000021A3
.text$mn:000021A3 loc_21A3:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+2Bj
.text$mn:000021A3                 mov     al, 1
.text$mn:000021A5
.text$mn:000021A5 loc_21A5:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+2Fj
.text$mn:000021A5                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+31j
.text$mn:000021A5                 mov     esp, ebp
.text$mn:000021A7                 pop     ebp
.text$mn:000021A8                 retn    4
.text$mn:000021A8 ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z endp
.text$mn:000021A8
.text$mn:000021A8 ; ---------------------------------------------------------------------------
.text$mn:000021AB                 align 4
.text$mn:000021AB _text$mn        ends
.text$mn:000021AB
.text$mn:000021AC ; ===========================================================================
.text$mn:000021AC
.text$mn:000021AC ; Segment type: Pure code
.text$mn:000021AC ; Segment permissions: Read/Execute
.text$mn:000021AC _text$mn        segment para public 'CODE' use32
.text$mn:000021AC                 assume cs:_text$mn
.text$mn:000021AC                 ;org 21ACh
.text$mn:000021AC ; COMDAT (pick any)
.text$mn:000021AC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000021AC
.text$mn:000021AC ; =============== S U B R O U T I N E =======================================
.text$mn:000021AC
.text$mn:000021AC ; Attributes: bp-based frame
.text$mn:000021AC
.text$mn:000021AC ; public: char * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)
.text$mn:000021AC                 public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
.text$mn:000021AC ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ proc near
.text$mn:000021AC                                         ; CODE XREF: $LN19+14p
.text$mn:000021AC                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+1Dp ...
.text$mn:000021AC
.text$mn:000021AC var_8           = dword ptr -8
.text$mn:000021AC var_4           = dword ptr -4
.text$mn:000021AC
.text$mn:000021AC                 push    ebp
.text$mn:000021AD                 mov     ebp, esp
.text$mn:000021AF                 sub     esp, 8
.text$mn:000021B2                 mov     [ebp+var_4], ecx
.text$mn:000021B5                 mov     eax, [ebp+var_4]
.text$mn:000021B8                 cmp     dword ptr [eax+18h], 10h
.text$mn:000021BC                 jb      short loc_21D2
.text$mn:000021BE                 mov     ecx, [ebp+var_4]
.text$mn:000021C1                 mov     edx, [ecx+4]
.text$mn:000021C4                 push    edx
.text$mn:000021C5                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:000021CA                 add     esp, 4
.text$mn:000021CD                 mov     [ebp+var_8], eax
.text$mn:000021D0                 jmp     short loc_21DB
.text$mn:000021D2 ; ---------------------------------------------------------------------------
.text$mn:000021D2
.text$mn:000021D2 loc_21D2:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+10j
.text$mn:000021D2                 mov     eax, [ebp+var_4]
.text$mn:000021D5                 add     eax, 4
.text$mn:000021D8                 mov     [ebp+var_8], eax
.text$mn:000021DB
.text$mn:000021DB loc_21DB:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+24j
.text$mn:000021DB                 mov     eax, [ebp+var_8]
.text$mn:000021DE                 mov     esp, ebp
.text$mn:000021E0                 pop     ebp
.text$mn:000021E1                 retn
.text$mn:000021E1 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ endp
.text$mn:000021E1
.text$mn:000021E1 ; ---------------------------------------------------------------------------
.text$mn:000021E2                 align 4
.text$mn:000021E2 _text$mn        ends
.text$mn:000021E2
.text$mn:000021E4 ; ===========================================================================
.text$mn:000021E4
.text$mn:000021E4 ; Segment type: Pure code
.text$mn:000021E4 ; Segment permissions: Read/Execute
.text$mn:000021E4 _text$mn        segment para public 'CODE' use32
.text$mn:000021E4                 assume cs:_text$mn
.text$mn:000021E4                 ;org 21E4h
.text$mn:000021E4 ; COMDAT (pick any)
.text$mn:000021E4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000021E4
.text$mn:000021E4 ; =============== S U B R O U T I N E =======================================
.text$mn:000021E4
.text$mn:000021E4 ; Attributes: bp-based frame
.text$mn:000021E4
.text$mn:000021E4 ; public: char const * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)const
.text$mn:000021E4                 public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
.text$mn:000021E4 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ proc near
.text$mn:000021E4                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+7Dp
.text$mn:000021E4
.text$mn:000021E4 var_8           = dword ptr -8
.text$mn:000021E4 var_4           = dword ptr -4
.text$mn:000021E4
.text$mn:000021E4                 push    ebp
.text$mn:000021E5                 mov     ebp, esp
.text$mn:000021E7                 sub     esp, 8
.text$mn:000021EA                 mov     [ebp+var_4], ecx
.text$mn:000021ED                 mov     eax, [ebp+var_4]
.text$mn:000021F0                 cmp     dword ptr [eax+18h], 10h
.text$mn:000021F4                 jb      short loc_220A
.text$mn:000021F6                 mov     ecx, [ebp+var_4]
.text$mn:000021F9                 mov     edx, [ecx+4]
.text$mn:000021FC                 push    edx
.text$mn:000021FD                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:00002202                 add     esp, 4
.text$mn:00002205                 mov     [ebp+var_8], eax
.text$mn:00002208                 jmp     short loc_2213
.text$mn:0000220A ; ---------------------------------------------------------------------------
.text$mn:0000220A
.text$mn:0000220A loc_220A:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+10j
.text$mn:0000220A                 mov     eax, [ebp+var_4]
.text$mn:0000220D                 add     eax, 4
.text$mn:00002210                 mov     [ebp+var_8], eax
.text$mn:00002213
.text$mn:00002213 loc_2213:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+24j
.text$mn:00002213                 mov     eax, [ebp+var_8]
.text$mn:00002216                 mov     esp, ebp
.text$mn:00002218                 pop     ebp
.text$mn:00002219                 retn
.text$mn:00002219 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ endp
.text$mn:00002219
.text$mn:00002219 ; ---------------------------------------------------------------------------
.text$mn:0000221A                 align 4
.text$mn:0000221A _text$mn        ends
.text$mn:0000221A
.text$mn:0000221C ; ===========================================================================
.text$mn:0000221C
.text$mn:0000221C ; Segment type: Pure code
.text$mn:0000221C ; Segment permissions: Read/Execute
.text$mn:0000221C _text$mn        segment para public 'CODE' use32
.text$mn:0000221C                 assume cs:_text$mn
.text$mn:0000221C                 ;org 221Ch
.text$mn:0000221C ; COMDAT (pick any)
.text$mn:0000221C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000221C
.text$mn:0000221C ; =============== S U B R O U T I N E =======================================
.text$mn:0000221C
.text$mn:0000221C ; Attributes: bp-based frame
.text$mn:0000221C
.text$mn:0000221C ; void __thiscall std::_Container_base12::_Orphan_all(std::_Container_base12 *__hidden this)
.text$mn:0000221C                 public ?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$mn:0000221C ?_Orphan_all@_Container_base12@std@@QAEXXZ proc near
.text$mn:0000221C                                         ; CODE XREF: std::_Container_base12::~_Container_base12(void)+Ap
.text$mn:0000221C                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+14p
.text$mn:0000221C
.text$mn:0000221C var_18          = byte ptr -18h
.text$mn:0000221C var_14          = dword ptr -14h
.text$mn:0000221C var_10          = dword ptr -10h
.text$mn:0000221C var_C           = dword ptr -0Ch
.text$mn:0000221C var_4           = dword ptr -4
.text$mn:0000221C
.text$mn:0000221C                 push    ebp
.text$mn:0000221D                 mov     ebp, esp
.text$mn:0000221F                 push    0FFFFFFFFh
.text$mn:00002221                 push    offset __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$mn:00002226                 mov     eax, large fs:0
.text$mn:0000222C                 push    eax
.text$mn:0000222D                 sub     esp, 0Ch
.text$mn:00002230                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002235                 xor     eax, ebp
.text$mn:00002237                 push    eax
.text$mn:00002238                 lea     eax, [ebp+var_C]
.text$mn:0000223B                 mov     large fs:0, eax
.text$mn:00002241                 mov     [ebp+var_14], ecx
.text$mn:00002244                 mov     eax, [ebp+var_14]
.text$mn:00002247                 cmp     dword ptr [eax], 0
.text$mn:0000224A                 jz      short loc_22A7
.text$mn:0000224C                 push    3               ; int
.text$mn:0000224E                 lea     ecx, [ebp+var_18] ; this
.text$mn:00002251                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:00002256                 mov     [ebp+var_4], 0
.text$mn:0000225D                 mov     ecx, [ebp+var_14]
.text$mn:00002260                 mov     edx, [ecx]
.text$mn:00002262                 add     edx, 4
.text$mn:00002265                 mov     [ebp+var_10], edx
.text$mn:00002268                 jmp     short loc_2277
.text$mn:0000226A ; ---------------------------------------------------------------------------
.text$mn:0000226A
.text$mn:0000226A loc_226A:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+6Ej
.text$mn:0000226A                 mov     eax, [ebp+var_10]
.text$mn:0000226D                 mov     ecx, [eax]
.text$mn:0000226F                 mov     edx, [ebp+var_10]
.text$mn:00002272                 mov     eax, [ecx+4]
.text$mn:00002275                 mov     [edx], eax
.text$mn:00002277
.text$mn:00002277 loc_2277:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+4Cj
.text$mn:00002277                 mov     ecx, [ebp+var_10]
.text$mn:0000227A                 cmp     dword ptr [ecx], 0
.text$mn:0000227D                 jz      short loc_228C
.text$mn:0000227F                 mov     edx, [ebp+var_10]
.text$mn:00002282                 mov     eax, [edx]
.text$mn:00002284                 mov     dword ptr [eax], 0
.text$mn:0000228A                 jmp     short loc_226A
.text$mn:0000228C ; ---------------------------------------------------------------------------
.text$mn:0000228C
.text$mn:0000228C loc_228C:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+61j
.text$mn:0000228C                 mov     ecx, [ebp+var_14]
.text$mn:0000228F                 mov     edx, [ecx]
.text$mn:00002291                 mov     dword ptr [edx+4], 0
.text$mn:00002298                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000229F                 lea     ecx, [ebp+var_18] ; this
.text$mn:000022A2                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:000022A7
.text$mn:000022A7 loc_22A7:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+2Ej
.text$mn:000022A7                 mov     ecx, [ebp+var_C]
.text$mn:000022AA                 mov     large fs:0, ecx
.text$mn:000022B1                 pop     ecx
.text$mn:000022B2                 mov     esp, ebp
.text$mn:000022B4                 pop     ebp
.text$mn:000022B5                 retn
.text$mn:000022B5 ?_Orphan_all@_Container_base12@std@@QAEXXZ endp
.text$mn:000022B5
.text$mn:000022B5 ; ---------------------------------------------------------------------------
.text$mn:000022B6                 align 4
.text$mn:000022B6 _text$mn        ends
.text$mn:000022B6
.text$x:000022B8 ; ===========================================================================
.text$x:000022B8
.text$x:000022B8 ; Segment type: Pure code
.text$x:000022B8 ; Segment permissions: Read/Execute
.text$x:000022B8 _text$x         segment para public 'CODE' use32
.text$x:000022B8                 assume cs:_text$x
.text$x:000022B8                 ;org 22B8h
.text$x:000022B8 ; COMDAT (pick associative to section at 221C)
.text$x:000022B8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000022B8
.text$x:000022B8 ; =============== S U B R O U T I N E =======================================
.text$x:000022B8
.text$x:000022B8
.text$x:000022B8 __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0 proc near
.text$x:000022B8                                         ; DATA XREF: .xdata$x:00002C34o
.text$x:000022B8                 lea     ecx, [ebp-18h]  ; this
.text$x:000022BB                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:000022BB __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0 endp
.text$x:000022BB
.text$x:000022C0
.text$x:000022C0 ; =============== S U B R O U T I N E =======================================
.text$x:000022C0
.text$x:000022C0
.text$x:000022C0 __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ proc near
.text$x:000022C0                                         ; DATA XREF: std::_Container_base12::_Orphan_all(void)+5o
.text$x:000022C0
.text$x:000022C0 arg_4           = dword ptr  8
.text$x:000022C0
.text$x:000022C0                 mov     edx, [esp+arg_4]
.text$x:000022C4                 lea     eax, [edx+0Ch]
.text$x:000022C7                 mov     ecx, [edx-10h]
.text$x:000022CA                 xor     ecx, eax
.text$x:000022CC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000022D1                 mov     eax, offset __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$x:000022D6                 jmp     ___CxxFrameHandler3
.text$x:000022D6 __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ endp
.text$x:000022D6
.text$x:000022D6 ; ---------------------------------------------------------------------------
.text$x:000022DB                 align 4
.text$x:000022DB _text$x         ends
.text$x:000022DB
.text$mn:000022DC ; ===========================================================================
.text$mn:000022DC
.text$mn:000022DC ; Segment type: Pure code
.text$mn:000022DC ; Segment permissions: Read/Execute
.text$mn:000022DC _text$mn        segment para public 'CODE' use32
.text$mn:000022DC                 assume cs:_text$mn
.text$mn:000022DC                 ;org 22DCh
.text$mn:000022DC ; COMDAT (pick any)
.text$mn:000022DC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000022DC
.text$mn:000022DC ; =============== S U B R O U T I N E =======================================
.text$mn:000022DC
.text$mn:000022DC ; Attributes: bp-based frame
.text$mn:000022DC
.text$mn:000022DC ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(char, size_t Size)
.text$mn:000022DC                 public ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
.text$mn:000022DC ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z proc near
.text$mn:000022DC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+47p
.text$mn:000022DC                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+34p ...
.text$mn:000022DC
.text$mn:000022DC var_C           = dword ptr -0Ch
.text$mn:000022DC var_8           = dword ptr -8
.text$mn:000022DC var_2           = byte ptr -2
.text$mn:000022DC var_1           = byte ptr -1
.text$mn:000022DC arg_0           = byte ptr  8
.text$mn:000022DC Size            = dword ptr  0Ch
.text$mn:000022DC
.text$mn:000022DC                 push    ebp
.text$mn:000022DD                 mov     ebp, esp
.text$mn:000022DF                 sub     esp, 0Ch
.text$mn:000022E2                 mov     [ebp+var_8], ecx
.text$mn:000022E5                 movzx   eax, [ebp+arg_0]
.text$mn:000022E9                 test    eax, eax
.text$mn:000022EB                 jnz     short loc_22EF
.text$mn:000022ED                 jmp     short loc_2362
.text$mn:000022EF ; ---------------------------------------------------------------------------
.text$mn:000022EF
.text$mn:000022EF loc_22EF:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+Fj
.text$mn:000022EF                 mov     ecx, [ebp+var_8]
.text$mn:000022F2                 cmp     dword ptr [ecx+18h], 10h
.text$mn:000022F6                 jb      short loc_2362
.text$mn:000022F8                 mov     edx, [ebp+var_8]
.text$mn:000022FB                 mov     eax, [edx+4]
.text$mn:000022FE                 mov     [ebp+var_C], eax
.text$mn:00002301                 mov     ecx, [ebp+var_8]
.text$mn:00002304                 add     ecx, 4
.text$mn:00002307                 push    ecx
.text$mn:00002308                 lea     edx, [ebp+var_1]
.text$mn:0000230B                 push    edx
.text$mn:0000230C                 mov     ecx, [ebp+var_8]
.text$mn:0000230F                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00002314                 mov     ecx, eax
.text$mn:00002316                 call    ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)
.text$mn:0000231B                 cmp     [ebp+Size], 0
.text$mn:0000231F                 jbe     short loc_2341
.text$mn:00002321                 mov     eax, [ebp+Size]
.text$mn:00002324                 push    eax             ; Size
.text$mn:00002325                 mov     ecx, [ebp+var_C]
.text$mn:00002328                 push    ecx
.text$mn:00002329                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:0000232E                 add     esp, 4
.text$mn:00002331                 push    eax             ; Src
.text$mn:00002332                 mov     edx, [ebp+var_8]
.text$mn:00002335                 add     edx, 4
.text$mn:00002338                 push    edx             ; Dst
.text$mn:00002339                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:0000233E                 add     esp, 0Ch
.text$mn:00002341
.text$mn:00002341 loc_2341:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+43j
.text$mn:00002341                 mov     eax, [ebp+var_8]
.text$mn:00002344                 mov     ecx, [eax+18h]
.text$mn:00002347                 add     ecx, 1
.text$mn:0000234A                 push    ecx             ; int
.text$mn:0000234B                 mov     edx, [ebp+var_C]
.text$mn:0000234E                 push    edx             ; void *
.text$mn:0000234F                 lea     eax, [ebp+var_2]
.text$mn:00002352                 push    eax
.text$mn:00002353                 mov     ecx, [ebp+var_8]
.text$mn:00002356                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:0000235B                 mov     ecx, eax
.text$mn:0000235D                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)
.text$mn:00002362
.text$mn:00002362 loc_2362:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+11j
.text$mn:00002362                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+1Aj
.text$mn:00002362                 mov     ecx, [ebp+var_8]
.text$mn:00002365                 mov     dword ptr [ecx+18h], 0Fh
.text$mn:0000236C                 mov     edx, [ebp+Size]
.text$mn:0000236F                 push    edx
.text$mn:00002370                 mov     ecx, [ebp+var_8]
.text$mn:00002373                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00002378                 mov     esp, ebp
.text$mn:0000237A                 pop     ebp
.text$mn:0000237B                 retn    8
.text$mn:0000237B ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z endp
.text$mn:0000237B
.text$mn:0000237B ; ---------------------------------------------------------------------------
.text$mn:0000237E                 align 10h
.text$mn:0000237E _text$mn        ends
.text$mn:0000237E
.text$mn:00002380 ; ===========================================================================
.text$mn:00002380
.text$mn:00002380 ; Segment type: Pure code
.text$mn:00002380 ; Segment permissions: Read/Execute
.text$mn:00002380 _text$mn        segment para public 'CODE' use32
.text$mn:00002380                 assume cs:_text$mn
.text$mn:00002380                 ;org 2380h
.text$mn:00002380 ; COMDAT (pick any)
.text$mn:00002380                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002380
.text$mn:00002380 ; =============== S U B R O U T I N E =======================================
.text$mn:00002380
.text$mn:00002380 ; Attributes: bp-based frame
.text$mn:00002380
.text$mn:00002380 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xlen(void)const
.text$mn:00002380                 public ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
.text$mn:00002380 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc near
.text$mn:00002380                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+19p
.text$mn:00002380
.text$mn:00002380 var_4           = dword ptr -4
.text$mn:00002380
.text$mn:00002380                 push    ebp
.text$mn:00002381                 mov     ebp, esp
.text$mn:00002383                 push    ecx
.text$mn:00002384                 mov     [ebp+var_4], ecx
.text$mn:00002387                 push    offset ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ ; "string too long"
.text$mn:0000238C                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:00002391                 mov     esp, ebp
.text$mn:00002393                 pop     ebp
.text$mn:00002394                 retn
.text$mn:00002394 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp
.text$mn:00002394
.text$mn:00002394 ; ---------------------------------------------------------------------------
.text$mn:00002395                 align 4
.text$mn:00002395 _text$mn        ends
.text$mn:00002395
.text$mn:00002398 ; ===========================================================================
.text$mn:00002398
.text$mn:00002398 ; Segment type: Pure code
.text$mn:00002398 ; Segment permissions: Read/Execute
.text$mn:00002398 _text$mn        segment para public 'CODE' use32
.text$mn:00002398                 assume cs:_text$mn
.text$mn:00002398                 ;org 2398h
.text$mn:00002398 ; COMDAT (pick any)
.text$mn:00002398                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002398
.text$mn:00002398 ; =============== S U B R O U T I N E =======================================
.text$mn:00002398
.text$mn:00002398 ; Attributes: bp-based frame
.text$mn:00002398
.text$mn:00002398 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xran(void)const
.text$mn:00002398                 public ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
.text$mn:00002398 ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc near
.text$mn:00002398                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+19p
.text$mn:00002398                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)+15p ...
.text$mn:00002398
.text$mn:00002398 var_4           = dword ptr -4
.text$mn:00002398
.text$mn:00002398                 push    ebp
.text$mn:00002399                 mov     ebp, esp
.text$mn:0000239B                 push    ecx
.text$mn:0000239C                 mov     [ebp+var_4], ecx
.text$mn:0000239F                 push    offset ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; "invalid string position"
.text$mn:000023A4                 call    ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range(char const *)
.text$mn:000023A9                 mov     esp, ebp
.text$mn:000023AB                 pop     ebp
.text$mn:000023AC                 retn
.text$mn:000023AC ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp
.text$mn:000023AC
.text$mn:000023AC ; ---------------------------------------------------------------------------
.text$mn:000023AD                 align 10h
.text$mn:000023AD _text$mn        ends
.text$mn:000023AD
.text$mn:000023B0 ; ===========================================================================
.text$mn:000023B0
.text$mn:000023B0 ; Segment type: Pure code
.text$mn:000023B0 ; Segment permissions: Read/Execute
.text$mn:000023B0 _text$mn        segment para public 'CODE' use32
.text$mn:000023B0                 assume cs:_text$mn
.text$mn:000023B0                 ;org 23B0h
.text$mn:000023B0 ; COMDAT (pick any)
.text$mn:000023B0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000023B0
.text$mn:000023B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000023B0
.text$mn:000023B0 ; Attributes: bp-based frame
.text$mn:000023B0
.text$mn:000023B0 ; public: char * __thiscall std::_Wrap_alloc<class std::allocator<char>>::allocate(unsigned int)
.text$mn:000023B0                 public ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
.text$mn:000023B0 ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z proc near
.text$mn:000023B0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+BBp
.text$mn:000023B0                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+22p
.text$mn:000023B0
.text$mn:000023B0 var_4           = dword ptr -4
.text$mn:000023B0 arg_0           = dword ptr  8
.text$mn:000023B0
.text$mn:000023B0                 push    ebp
.text$mn:000023B1                 mov     ebp, esp
.text$mn:000023B3                 push    ecx
.text$mn:000023B4                 mov     [ebp+var_4], ecx
.text$mn:000023B7                 mov     eax, [ebp+arg_0]
.text$mn:000023BA                 push    eax
.text$mn:000023BB                 mov     ecx, [ebp+var_4]
.text$mn:000023BE                 call    ?allocate@?$allocator@D@std@@QAEPADI@Z ; std::allocator<char>::allocate(uint)
.text$mn:000023C3                 mov     esp, ebp
.text$mn:000023C5                 pop     ebp
.text$mn:000023C6                 retn    4
.text$mn:000023C6 ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z endp
.text$mn:000023C6
.text$mn:000023C6 ; ---------------------------------------------------------------------------
.text$mn:000023C9                 align 4
.text$mn:000023C9 _text$mn        ends
.text$mn:000023C9
.text$mn:000023CC ; ===========================================================================
.text$mn:000023CC
.text$mn:000023CC ; Segment type: Pure code
.text$mn:000023CC ; Segment permissions: Read/Execute
.text$mn:000023CC _text$mn        segment para public 'CODE' use32
.text$mn:000023CC                 assume cs:_text$mn
.text$mn:000023CC                 ;org 23CCh
.text$mn:000023CC ; COMDAT (pick any)
.text$mn:000023CC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000023CC
.text$mn:000023CC ; =============== S U B R O U T I N E =======================================
.text$mn:000023CC
.text$mn:000023CC ; Attributes: bp-based frame
.text$mn:000023CC
.text$mn:000023CC ; public: char * __thiscall std::allocator<char>::allocate(unsigned int)
.text$mn:000023CC                 public ?allocate@?$allocator@D@std@@QAEPADI@Z
.text$mn:000023CC ?allocate@?$allocator@D@std@@QAEPADI@Z proc near
.text$mn:000023CC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::allocate(uint)+Ep
.text$mn:000023CC
.text$mn:000023CC var_4           = dword ptr -4
.text$mn:000023CC arg_0           = dword ptr  8
.text$mn:000023CC
.text$mn:000023CC                 push    ebp
.text$mn:000023CD                 mov     ebp, esp
.text$mn:000023CF                 push    ecx
.text$mn:000023D0                 mov     [ebp+var_4], ecx
.text$mn:000023D3                 push    0
.text$mn:000023D5                 mov     eax, [ebp+arg_0]
.text$mn:000023D8                 push    eax
.text$mn:000023D9                 call    ??$_Allocate@D@std@@YAPADIPAD@Z ; std::_Allocate<char>(uint,char *)
.text$mn:000023DE                 add     esp, 8
.text$mn:000023E1                 mov     esp, ebp
.text$mn:000023E3                 pop     ebp
.text$mn:000023E4                 retn    4
.text$mn:000023E4 ?allocate@?$allocator@D@std@@QAEPADI@Z endp
.text$mn:000023E4
.text$mn:000023E4 ; ---------------------------------------------------------------------------
.text$mn:000023E7                 align 4
.text$mn:000023E7 _text$mn        ends
.text$mn:000023E7
.text$mn:000023E8 ; ===========================================================================
.text$mn:000023E8
.text$mn:000023E8 ; Segment type: Pure code
.text$mn:000023E8 ; Segment permissions: Read/Execute
.text$mn:000023E8 _text$mn        segment para public 'CODE' use32
.text$mn:000023E8                 assume cs:_text$mn
.text$mn:000023E8                 ;org 23E8h
.text$mn:000023E8 ; COMDAT (pick any)
.text$mn:000023E8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000023E8
.text$mn:000023E8 ; =============== S U B R O U T I N E =======================================
.text$mn:000023E8
.text$mn:000023E8 ; Attributes: bp-based frame
.text$mn:000023E8
.text$mn:000023E8 ; public: struct std::_Container_proxy * __thiscall std::allocator<struct std::_Container_proxy>::allocate(unsigned int)
.text$mn:000023E8                 public ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z
.text$mn:000023E8 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z proc near
.text$mn:000023E8                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+16p
.text$mn:000023E8
.text$mn:000023E8 var_4           = dword ptr -4
.text$mn:000023E8 arg_0           = dword ptr  8
.text$mn:000023E8
.text$mn:000023E8                 push    ebp
.text$mn:000023E9                 mov     ebp, esp
.text$mn:000023EB                 push    ecx
.text$mn:000023EC                 mov     [ebp+var_4], ecx
.text$mn:000023EF                 push    0
.text$mn:000023F1                 mov     eax, [ebp+arg_0]
.text$mn:000023F4                 push    eax
.text$mn:000023F5                 call    ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)
.text$mn:000023FA                 add     esp, 8
.text$mn:000023FD                 mov     esp, ebp
.text$mn:000023FF                 pop     ebp
.text$mn:00002400                 retn    4
.text$mn:00002400 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z endp
.text$mn:00002400
.text$mn:00002400 ; ---------------------------------------------------------------------------
.text$mn:00002403                 align 4
.text$mn:00002403 _text$mn        ends
.text$mn:00002403
.text$mn:00002404 ; ===========================================================================
.text$mn:00002404
.text$mn:00002404 ; Segment type: Pure code
.text$mn:00002404 ; Segment permissions: Read/Execute
.text$mn:00002404 _text$mn        segment para public 'CODE' use32
.text$mn:00002404                 assume cs:_text$mn
.text$mn:00002404                 ;org 2404h
.text$mn:00002404 ; COMDAT (pick any)
.text$mn:00002404                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002404
.text$mn:00002404 ; =============== S U B R O U T I N E =======================================
.text$mn:00002404
.text$mn:00002404 ; Attributes: bp-based frame
.text$mn:00002404
.text$mn:00002404 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::assign(class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> const &, unsigned int, unsigned int)
.text$mn:00002404                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
.text$mn:00002404 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z proc near
.text$mn:00002404                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+4Fp
.text$mn:00002404
.text$mn:00002404 Size            = dword ptr -8
.text$mn:00002404 var_4           = dword ptr -4
.text$mn:00002404 arg_0           = dword ptr  8
.text$mn:00002404 arg_4           = dword ptr  0Ch
.text$mn:00002404 arg_8           = dword ptr  10h
.text$mn:00002404
.text$mn:00002404                 push    ebp
.text$mn:00002405                 mov     ebp, esp
.text$mn:00002407                 sub     esp, 8
.text$mn:0000240A                 mov     [ebp+var_4], ecx
.text$mn:0000240D                 mov     ecx, [ebp+arg_0]
.text$mn:00002410                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:00002415                 cmp     eax, [ebp+arg_4]
.text$mn:00002418                 jnb     short loc_2422
.text$mn:0000241A                 mov     ecx, [ebp+var_4]
.text$mn:0000241D                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:00002422
.text$mn:00002422 loc_2422:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+14j
.text$mn:00002422                 mov     ecx, [ebp+arg_0]
.text$mn:00002425                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:0000242A                 sub     eax, [ebp+arg_4]
.text$mn:0000242D                 mov     [ebp+Size], eax
.text$mn:00002430                 mov     eax, [ebp+arg_8]
.text$mn:00002433                 cmp     eax, [ebp+Size]
.text$mn:00002436                 jnb     short loc_243E
.text$mn:00002438                 mov     ecx, [ebp+arg_8]
.text$mn:0000243B                 mov     [ebp+Size], ecx
.text$mn:0000243E
.text$mn:0000243E loc_243E:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+32j
.text$mn:0000243E                 mov     edx, [ebp+var_4]
.text$mn:00002441                 cmp     edx, [ebp+arg_0]
.text$mn:00002444                 jnz     short loc_2465
.text$mn:00002446                 mov     eax, [ebp+arg_4]
.text$mn:00002449                 add     eax, [ebp+Size]
.text$mn:0000244C                 push    eax
.text$mn:0000244D                 mov     ecx, [ebp+var_4]
.text$mn:00002450                 call    ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)
.text$mn:00002455                 mov     ecx, [ebp+arg_4]
.text$mn:00002458                 push    ecx
.text$mn:00002459                 push    0
.text$mn:0000245B                 mov     ecx, [ebp+var_4]
.text$mn:0000245E                 call    ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)
.text$mn:00002463                 jmp     short loc_24A7
.text$mn:00002465 ; ---------------------------------------------------------------------------
.text$mn:00002465
.text$mn:00002465 loc_2465:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+40j
.text$mn:00002465                 push    0
.text$mn:00002467                 mov     edx, [ebp+Size]
.text$mn:0000246A                 push    edx
.text$mn:0000246B                 mov     ecx, [ebp+var_4]
.text$mn:0000246E                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:00002473                 movzx   eax, al
.text$mn:00002476                 test    eax, eax
.text$mn:00002478                 jz      short loc_24A7
.text$mn:0000247A                 mov     ecx, [ebp+Size]
.text$mn:0000247D                 push    ecx             ; Size
.text$mn:0000247E                 mov     ecx, [ebp+arg_0]
.text$mn:00002481                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00002486                 add     eax, [ebp+arg_4]
.text$mn:00002489                 push    eax             ; Src
.text$mn:0000248A                 mov     ecx, [ebp+var_4]
.text$mn:0000248D                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00002492                 push    eax             ; Dst
.text$mn:00002493                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00002498                 add     esp, 0Ch
.text$mn:0000249B                 mov     edx, [ebp+Size]
.text$mn:0000249E                 push    edx
.text$mn:0000249F                 mov     ecx, [ebp+var_4]
.text$mn:000024A2                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000024A7
.text$mn:000024A7 loc_24A7:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+5Fj
.text$mn:000024A7                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+74j
.text$mn:000024A7                 mov     eax, [ebp+var_4]
.text$mn:000024AA                 mov     esp, ebp
.text$mn:000024AC                 pop     ebp
.text$mn:000024AD                 retn    0Ch
.text$mn:000024AD ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z endp
.text$mn:000024AD
.text$mn:000024AD _text$mn        ends
.text$mn:000024AD
.text$mn:000024B0 ; ===========================================================================
.text$mn:000024B0
.text$mn:000024B0 ; Segment type: Pure code
.text$mn:000024B0 ; Segment permissions: Read/Execute
.text$mn:000024B0 _text$mn        segment para public 'CODE' use32
.text$mn:000024B0                 assume cs:_text$mn
.text$mn:000024B0                 ;org 24B0h
.text$mn:000024B0 ; COMDAT (pick any)
.text$mn:000024B0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000024B0
.text$mn:000024B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000024B0
.text$mn:000024B0 ; Attributes: bp-based frame
.text$mn:000024B0
.text$mn:000024B0 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char *Str)
.text$mn:000024B0                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
.text$mn:000024B0 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z proc near
.text$mn:000024B0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+53p
.text$mn:000024B0
.text$mn:000024B0 var_4           = dword ptr -4
.text$mn:000024B0 Str             = dword ptr  8
.text$mn:000024B0
.text$mn:000024B0                 push    ebp
.text$mn:000024B1                 mov     ebp, esp
.text$mn:000024B3                 push    ecx
.text$mn:000024B4                 mov     [ebp+var_4], ecx
.text$mn:000024B7                 push    490h            ; unsigned int
.text$mn:000024BC                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000024C1                 mov     eax, [ebp+Str]
.text$mn:000024C4                 push    eax             ; int
.text$mn:000024C5                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:000024CA                 add     esp, 0Ch
.text$mn:000024CD                 mov     ecx, [ebp+Str]
.text$mn:000024D0                 push    ecx             ; Str
.text$mn:000024D1                 call    ?length@?$char_traits@D@std@@SAIPBD@Z ; std::char_traits<char>::length(char const *)
.text$mn:000024D6                 add     esp, 4
.text$mn:000024D9                 push    eax             ; Size
.text$mn:000024DA                 mov     edx, [ebp+Str]
.text$mn:000024DD                 push    edx             ; Src
.text$mn:000024DE                 mov     ecx, [ebp+var_4]
.text$mn:000024E1                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)
.text$mn:000024E6                 mov     esp, ebp
.text$mn:000024E8                 pop     ebp
.text$mn:000024E9                 retn    4
.text$mn:000024E9 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z endp
.text$mn:000024E9
.text$mn:000024E9 _text$mn        ends
.text$mn:000024E9
.text$mn:000024EC ; ===========================================================================
.text$mn:000024EC
.text$mn:000024EC ; Segment type: Pure code
.text$mn:000024EC ; Segment permissions: Read/Execute
.text$mn:000024EC _text$mn        segment para public 'CODE' use32
.text$mn:000024EC                 assume cs:_text$mn
.text$mn:000024EC                 ;org 24ECh
.text$mn:000024EC ; COMDAT (pick any)
.text$mn:000024EC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000024EC
.text$mn:000024EC ; =============== S U B R O U T I N E =======================================
.text$mn:000024EC
.text$mn:000024EC ; Attributes: bp-based frame
.text$mn:000024EC
.text$mn:000024EC ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(void *Src, size_t Size)
.text$mn:000024EC                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
.text$mn:000024EC ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z proc near
.text$mn:000024EC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+31p
.text$mn:000024EC
.text$mn:000024EC var_4           = dword ptr -4
.text$mn:000024EC Src             = dword ptr  8
.text$mn:000024EC Size            = dword ptr  0Ch
.text$mn:000024EC
.text$mn:000024EC                 push    ebp
.text$mn:000024ED                 mov     ebp, esp
.text$mn:000024EF                 push    ecx
.text$mn:000024F0                 mov     [ebp+var_4], ecx
.text$mn:000024F3                 cmp     [ebp+Size], 0
.text$mn:000024F7                 jz      short loc_250F
.text$mn:000024F9                 push    47Fh            ; unsigned int
.text$mn:000024FE                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00002503                 mov     eax, [ebp+Src]
.text$mn:00002506                 push    eax             ; int
.text$mn:00002507                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:0000250C                 add     esp, 0Ch
.text$mn:0000250F
.text$mn:0000250F loc_250F:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+Bj
.text$mn:0000250F                 mov     ecx, [ebp+Src]
.text$mn:00002512                 push    ecx
.text$mn:00002513                 mov     ecx, [ebp+var_4]
.text$mn:00002516                 call    ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)
.text$mn:0000251B                 movzx   edx, al
.text$mn:0000251E                 test    edx, edx
.text$mn:00002520                 jz      short loc_2542
.text$mn:00002522                 mov     eax, [ebp+Size]
.text$mn:00002525                 push    eax
.text$mn:00002526                 mov     ecx, [ebp+var_4]
.text$mn:00002529                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000252E                 mov     ecx, [ebp+Src]
.text$mn:00002531                 sub     ecx, eax
.text$mn:00002533                 push    ecx
.text$mn:00002534                 mov     edx, [ebp+var_4]
.text$mn:00002537                 push    edx
.text$mn:00002538                 mov     ecx, [ebp+var_4]
.text$mn:0000253B                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)
.text$mn:00002540                 jmp     short loc_257F
.text$mn:00002542 ; ---------------------------------------------------------------------------
.text$mn:00002542
.text$mn:00002542 loc_2542:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+34j
.text$mn:00002542                 push    0
.text$mn:00002544                 mov     eax, [ebp+Size]
.text$mn:00002547                 push    eax
.text$mn:00002548                 mov     ecx, [ebp+var_4]
.text$mn:0000254B                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:00002550                 movzx   ecx, al
.text$mn:00002553                 test    ecx, ecx
.text$mn:00002555                 jz      short loc_257C
.text$mn:00002557                 mov     edx, [ebp+Size]
.text$mn:0000255A                 push    edx             ; Size
.text$mn:0000255B                 mov     eax, [ebp+Src]
.text$mn:0000255E                 push    eax             ; Src
.text$mn:0000255F                 mov     ecx, [ebp+var_4]
.text$mn:00002562                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00002567                 push    eax             ; Dst
.text$mn:00002568                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:0000256D                 add     esp, 0Ch
.text$mn:00002570                 mov     ecx, [ebp+Size]
.text$mn:00002573                 push    ecx
.text$mn:00002574                 mov     ecx, [ebp+var_4]
.text$mn:00002577                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:0000257C
.text$mn:0000257C loc_257C:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+69j
.text$mn:0000257C                 mov     eax, [ebp+var_4]
.text$mn:0000257F
.text$mn:0000257F loc_257F:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+54j
.text$mn:0000257F                 mov     esp, ebp
.text$mn:00002581                 pop     ebp
.text$mn:00002582                 retn    8
.text$mn:00002582 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z endp
.text$mn:00002582
.text$mn:00002582 ; ---------------------------------------------------------------------------
.text$mn:00002585                 align 4
.text$mn:00002585 _text$mn        ends
.text$mn:00002585
.text$mn:00002588 ; ===========================================================================
.text$mn:00002588
.text$mn:00002588 ; Segment type: Pure code
.text$mn:00002588 ; Segment permissions: Read/Execute
.text$mn:00002588 _text$mn        segment para public 'CODE' use32
.text$mn:00002588                 assume cs:_text$mn
.text$mn:00002588                 ;org 2588h
.text$mn:00002588 ; COMDAT (pick any)
.text$mn:00002588                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002588
.text$mn:00002588 ; =============== S U B R O U T I N E =======================================
.text$mn:00002588
.text$mn:00002588 ; Attributes: bp-based frame
.text$mn:00002588
.text$mn:00002588 ; public: static void __cdecl std::char_traits<char>::assign(char &, char const &)
.text$mn:00002588                 public ?assign@?$char_traits@D@std@@SAXAADABD@Z
.text$mn:00002588 ?assign@?$char_traits@D@std@@SAXAADABD@Z proc near
.text$mn:00002588                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+26p
.text$mn:00002588
.text$mn:00002588 arg_0           = dword ptr  8
.text$mn:00002588 arg_4           = dword ptr  0Ch
.text$mn:00002588
.text$mn:00002588                 push    ebp
.text$mn:00002589                 mov     ebp, esp
.text$mn:0000258B                 mov     eax, [ebp+arg_0]
.text$mn:0000258E                 mov     ecx, [ebp+arg_4]
.text$mn:00002591                 mov     dl, [ecx]
.text$mn:00002593                 mov     [eax], dl
.text$mn:00002595                 pop     ebp
.text$mn:00002596                 retn
.text$mn:00002596 ?assign@?$char_traits@D@std@@SAXAADABD@Z endp
.text$mn:00002596
.text$mn:00002596 ; ---------------------------------------------------------------------------
.text$mn:00002597                 align 4
.text$mn:00002597 _text$mn        ends
.text$mn:00002597
.text$mn:00002598 ; ===========================================================================
.text$mn:00002598
.text$mn:00002598 ; Segment type: Pure code
.text$mn:00002598 ; Segment permissions: Read/Execute
.text$mn:00002598 _text$mn        segment para public 'CODE' use32
.text$mn:00002598                 assume cs:_text$mn
.text$mn:00002598                 ;org 2598h
.text$mn:00002598 ; COMDAT (pick any)
.text$mn:00002598                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002598
.text$mn:00002598 ; =============== S U B R O U T I N E =======================================
.text$mn:00002598
.text$mn:00002598 ; Attributes: bp-based frame
.text$mn:00002598
.text$mn:00002598 ; const struct std::error_category *__thiscall std::error_code::category(std::error_code *__hidden this)
.text$mn:00002598                 public ?category@error_code@std@@QBEABVerror_category@2@XZ
.text$mn:00002598 ?category@error_code@std@@QBEABVerror_category@2@XZ proc near
.text$mn:00002598                                         ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+Cp
.text$mn:00002598
.text$mn:00002598 var_4           = dword ptr -4
.text$mn:00002598
.text$mn:00002598                 push    ebp
.text$mn:00002599                 mov     ebp, esp
.text$mn:0000259B                 push    ecx
.text$mn:0000259C                 mov     [ebp+var_4], ecx
.text$mn:0000259F                 mov     eax, [ebp+var_4]
.text$mn:000025A2                 mov     eax, [eax+4]
.text$mn:000025A5                 mov     esp, ebp
.text$mn:000025A7                 pop     ebp
.text$mn:000025A8                 retn
.text$mn:000025A8 ?category@error_code@std@@QBEABVerror_category@2@XZ endp
.text$mn:000025A8
.text$mn:000025A8 ; ---------------------------------------------------------------------------
.text$mn:000025A9                 align 4
.text$mn:000025A9 _text$mn        ends
.text$mn:000025A9
.text$mn:000025AC ; ===========================================================================
.text$mn:000025AC
.text$mn:000025AC ; Segment type: Pure code
.text$mn:000025AC ; Segment permissions: Read/Execute
.text$mn:000025AC _text$mn        segment para public 'CODE' use32
.text$mn:000025AC                 assume cs:_text$mn
.text$mn:000025AC                 ;org 25ACh
.text$mn:000025AC ; COMDAT (pick any)
.text$mn:000025AC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000025AC
.text$mn:000025AC ; =============== S U B R O U T I N E =======================================
.text$mn:000025AC
.text$mn:000025AC ; Attributes: bp-based frame
.text$mn:000025AC
.text$mn:000025AC ; const struct std::error_category *__thiscall std::error_condition::category(std::error_condition *__hidden this)
.text$mn:000025AC                 public ?category@error_condition@std@@QBEABVerror_category@2@XZ
.text$mn:000025AC ?category@error_condition@std@@QBEABVerror_category@2@XZ proc near
.text$mn:000025AC                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+Dp
.text$mn:000025AC                                         ; std::error_condition::operator==(std::error_condition const &)+16p
.text$mn:000025AC
.text$mn:000025AC var_4           = dword ptr -4
.text$mn:000025AC
.text$mn:000025AC                 push    ebp
.text$mn:000025AD                 mov     ebp, esp
.text$mn:000025AF                 push    ecx
.text$mn:000025B0                 mov     [ebp+var_4], ecx
.text$mn:000025B3                 mov     eax, [ebp+var_4]
.text$mn:000025B6                 mov     eax, [eax+4]
.text$mn:000025B9                 mov     esp, ebp
.text$mn:000025BB                 pop     ebp
.text$mn:000025BC                 retn
.text$mn:000025BC ?category@error_condition@std@@QBEABVerror_category@2@XZ endp
.text$mn:000025BC
.text$mn:000025BC ; ---------------------------------------------------------------------------
.text$mn:000025BD                 align 10h
.text$mn:000025BD _text$mn        ends
.text$mn:000025BD
.text$mn:000025C0 ; ===========================================================================
.text$mn:000025C0
.text$mn:000025C0 ; Segment type: Pure code
.text$mn:000025C0 ; Segment permissions: Read/Execute
.text$mn:000025C0 _text$mn        segment para public 'CODE' use32
.text$mn:000025C0                 assume cs:_text$mn
.text$mn:000025C0                 ;org 25C0h
.text$mn:000025C0 ; COMDAT (pick any)
.text$mn:000025C0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000025C0
.text$mn:000025C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000025C0
.text$mn:000025C0 ; Attributes: bp-based frame
.text$mn:000025C0
.text$mn:000025C0 ; int __cdecl std::char_traits<char>::copy(void *Dst, void *Src, size_t Size)
.text$mn:000025C0                 public ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
.text$mn:000025C0 ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z proc near ; CODE XREF: $LN19+1Ep
.text$mn:000025C0                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+5Dp ...
.text$mn:000025C0
.text$mn:000025C0 var_4           = dword ptr -4
.text$mn:000025C0 Dst             = dword ptr  8
.text$mn:000025C0 Src             = dword ptr  0Ch
.text$mn:000025C0 Size            = dword ptr  10h
.text$mn:000025C0
.text$mn:000025C0                 push    ebp
.text$mn:000025C1                 mov     ebp, esp
.text$mn:000025C3                 push    ecx
.text$mn:000025C4                 cmp     [ebp+Size], 0
.text$mn:000025C8                 jnz     short loc_25D2
.text$mn:000025CA                 mov     eax, [ebp+Dst]
.text$mn:000025CD                 mov     [ebp+var_4], eax
.text$mn:000025D0                 jmp     short loc_25E9
.text$mn:000025D2 ; ---------------------------------------------------------------------------
.text$mn:000025D2
.text$mn:000025D2 loc_25D2:                               ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+8j
.text$mn:000025D2                 mov     ecx, [ebp+Size]
.text$mn:000025D5                 push    ecx             ; Size
.text$mn:000025D6                 mov     edx, [ebp+Src]
.text$mn:000025D9                 push    edx             ; Src
.text$mn:000025DA                 mov     eax, [ebp+Dst]
.text$mn:000025DD                 push    eax             ; Dst
.text$mn:000025DE                 call    _memcpy
.text$mn:000025E3                 add     esp, 0Ch
.text$mn:000025E6                 mov     [ebp+var_4], eax
.text$mn:000025E9
.text$mn:000025E9 loc_25E9:                               ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+10j
.text$mn:000025E9                 mov     eax, [ebp+var_4]
.text$mn:000025EC                 mov     esp, ebp
.text$mn:000025EE                 pop     ebp
.text$mn:000025EF                 retn
.text$mn:000025EF ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z endp
.text$mn:000025EF
.text$mn:000025EF _text$mn        ends
.text$mn:000025EF
.text$mn:000025F0 ; ===========================================================================
.text$mn:000025F0
.text$mn:000025F0 ; Segment type: Pure code
.text$mn:000025F0 ; Segment permissions: Read/Execute
.text$mn:000025F0 _text$mn        segment para public 'CODE' use32
.text$mn:000025F0                 assume cs:_text$mn
.text$mn:000025F0                 ;org 25F0h
.text$mn:000025F0 ; COMDAT (pick any)
.text$mn:000025F0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000025F0
.text$mn:000025F0 ; =============== S U B R O U T I N E =======================================
.text$mn:000025F0
.text$mn:000025F0 ; Attributes: bp-based frame
.text$mn:000025F0
.text$mn:000025F0 ; int __stdcall std::_Wrap_alloc<std::allocator<char>>::deallocate(void *, int)
.text$mn:000025F0                 public ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
.text$mn:000025F0 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z proc near
.text$mn:000025F0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+81p
.text$mn:000025F0
.text$mn:000025F0 var_4           = dword ptr -4
.text$mn:000025F0 arg_0           = dword ptr  8
.text$mn:000025F0 arg_4           = dword ptr  0Ch
.text$mn:000025F0
.text$mn:000025F0                 push    ebp
.text$mn:000025F1                 mov     ebp, esp
.text$mn:000025F3                 push    ecx
.text$mn:000025F4                 mov     [ebp+var_4], ecx
.text$mn:000025F7                 mov     eax, [ebp+arg_4]
.text$mn:000025FA                 push    eax             ; int
.text$mn:000025FB                 mov     ecx, [ebp+arg_0]
.text$mn:000025FE                 push    ecx             ; void *
.text$mn:000025FF                 mov     ecx, [ebp+var_4]
.text$mn:00002602                 call    ?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate(char *,uint)
.text$mn:00002607                 mov     esp, ebp
.text$mn:00002609                 pop     ebp
.text$mn:0000260A                 retn    8
.text$mn:0000260A ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z endp
.text$mn:0000260A
.text$mn:0000260A ; ---------------------------------------------------------------------------
.text$mn:0000260D                 align 10h
.text$mn:0000260D _text$mn        ends
.text$mn:0000260D
.text$mn:00002610 ; ===========================================================================
.text$mn:00002610
.text$mn:00002610 ; Segment type: Pure code
.text$mn:00002610 ; Segment permissions: Read/Execute
.text$mn:00002610 _text$mn        segment para public 'CODE' use32
.text$mn:00002610                 assume cs:_text$mn
.text$mn:00002610                 ;org 2610h
.text$mn:00002610 ; COMDAT (pick any)
.text$mn:00002610                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002610
.text$mn:00002610 ; =============== S U B R O U T I N E =======================================
.text$mn:00002610
.text$mn:00002610 ; Attributes: bp-based frame
.text$mn:00002610
.text$mn:00002610 ; int __stdcall std::allocator<char>::deallocate(void *, int)
.text$mn:00002610                 public ?deallocate@?$allocator@D@std@@QAEXPADI@Z
.text$mn:00002610 ?deallocate@?$allocator@D@std@@QAEXPADI@Z proc near
.text$mn:00002610                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)+12p
.text$mn:00002610
.text$mn:00002610 var_4           = dword ptr -4
.text$mn:00002610 arg_0           = dword ptr  8
.text$mn:00002610
.text$mn:00002610                 push    ebp
.text$mn:00002611                 mov     ebp, esp
.text$mn:00002613                 push    ecx
.text$mn:00002614                 mov     [ebp+var_4], ecx
.text$mn:00002617                 mov     eax, [ebp+arg_0]
.text$mn:0000261A                 push    eax             ; void *
.text$mn:0000261B                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00002620                 add     esp, 4
.text$mn:00002623                 mov     esp, ebp
.text$mn:00002625                 pop     ebp
.text$mn:00002626                 retn    8
.text$mn:00002626 ?deallocate@?$allocator@D@std@@QAEXPADI@Z endp
.text$mn:00002626
.text$mn:00002626 ; ---------------------------------------------------------------------------
.text$mn:00002629                 align 4
.text$mn:00002629 _text$mn        ends
.text$mn:00002629
.text$mn:0000262C ; ===========================================================================
.text$mn:0000262C
.text$mn:0000262C ; Segment type: Pure code
.text$mn:0000262C ; Segment permissions: Read/Execute
.text$mn:0000262C _text$mn        segment para public 'CODE' use32
.text$mn:0000262C                 assume cs:_text$mn
.text$mn:0000262C                 ;org 262Ch
.text$mn:0000262C ; COMDAT (pick any)
.text$mn:0000262C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000262C
.text$mn:0000262C ; =============== S U B R O U T I N E =======================================
.text$mn:0000262C
.text$mn:0000262C ; Attributes: bp-based frame
.text$mn:0000262C
.text$mn:0000262C ; int __stdcall std::allocator<std::_Container_proxy>::deallocate(void *, int)
.text$mn:0000262C                 public ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z
.text$mn:0000262C ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z proc near
.text$mn:0000262C                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+32p
.text$mn:0000262C
.text$mn:0000262C var_4           = dword ptr -4
.text$mn:0000262C arg_0           = dword ptr  8
.text$mn:0000262C
.text$mn:0000262C                 push    ebp
.text$mn:0000262D                 mov     ebp, esp
.text$mn:0000262F                 push    ecx
.text$mn:00002630                 mov     [ebp+var_4], ecx
.text$mn:00002633                 mov     eax, [ebp+arg_0]
.text$mn:00002636                 push    eax             ; void *
.text$mn:00002637                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:0000263C                 add     esp, 4
.text$mn:0000263F                 mov     esp, ebp
.text$mn:00002641                 pop     ebp
.text$mn:00002642                 retn    8
.text$mn:00002642 ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z endp
.text$mn:00002642
.text$mn:00002642 ; ---------------------------------------------------------------------------
.text$mn:00002645                 align 4
.text$mn:00002645 _text$mn        ends
.text$mn:00002645
.text$mn:00002648 ; ===========================================================================
.text$mn:00002648
.text$mn:00002648 ; Segment type: Pure code
.text$mn:00002648 ; Segment permissions: Read/Execute
.text$mn:00002648 _text$mn        segment para public 'CODE' use32
.text$mn:00002648                 assume cs:_text$mn
.text$mn:00002648                 ;org 2648h
.text$mn:00002648 ; COMDAT (pick any)
.text$mn:00002648                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002648
.text$mn:00002648 ; =============== S U B R O U T I N E =======================================
.text$mn:00002648
.text$mn:00002648 ; Attributes: bp-based frame
.text$mn:00002648
.text$mn:00002648 ; public: virtual class std::error_condition __thiscall std::_System_error_category::default_error_condition(int)const
.text$mn:00002648                 public ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
.text$mn:00002648 ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z proc near
.text$mn:00002648                                         ; DATA XREF: .rdata:00003078o
.text$mn:00002648
.text$mn:00002648 var_4           = dword ptr -4
.text$mn:00002648 arg_0           = dword ptr  8
.text$mn:00002648 arg_4           = dword ptr  0Ch
.text$mn:00002648
.text$mn:00002648                 push    ebp
.text$mn:00002649                 mov     ebp, esp
.text$mn:0000264B                 push    ecx
.text$mn:0000264C                 mov     [ebp+var_4], ecx
.text$mn:0000264F                 mov     eax, [ebp+arg_4]
.text$mn:00002652                 push    eax             ; int
.text$mn:00002653                 call    ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map(int)
.text$mn:00002658                 add     esp, 4
.text$mn:0000265B                 test    eax, eax
.text$mn:0000265D                 jz      short loc_2678
.text$mn:0000265F                 call    ?generic_category@std@@YAABVerror_category@1@XZ ; std::generic_category(void)
.text$mn:00002664                 push    eax             ; struct std::error_category *
.text$mn:00002665                 mov     ecx, [ebp+arg_4]
.text$mn:00002668                 push    ecx             ; int
.text$mn:00002669                 mov     ecx, [ebp+arg_0] ; this
.text$mn:0000266C                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:00002671                 mov     eax, [ebp+arg_0]
.text$mn:00002674                 jmp     short loc_268D
.text$mn:00002676 ; ---------------------------------------------------------------------------
.text$mn:00002676                 jmp     short loc_268D
.text$mn:00002678 ; ---------------------------------------------------------------------------
.text$mn:00002678
.text$mn:00002678 loc_2678:                               ; CODE XREF: std::_System_error_category::default_error_condition(int)+15j
.text$mn:00002678                 call    ?system_category@std@@YAABVerror_category@1@XZ ; std::system_category(void)
.text$mn:0000267D                 push    eax             ; struct std::error_category *
.text$mn:0000267E                 mov     edx, [ebp+arg_4]
.text$mn:00002681                 push    edx             ; int
.text$mn:00002682                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00002685                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:0000268A                 mov     eax, [ebp+arg_0]
.text$mn:0000268D
.text$mn:0000268D loc_268D:                               ; CODE XREF: std::_System_error_category::default_error_condition(int)+2Cj
.text$mn:0000268D                                         ; std::_System_error_category::default_error_condition(int)+2Ej
.text$mn:0000268D                 mov     esp, ebp
.text$mn:0000268F                 pop     ebp
.text$mn:00002690                 retn    8
.text$mn:00002690 ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z endp
.text$mn:00002690
.text$mn:00002690 ; ---------------------------------------------------------------------------
.text$mn:00002693                 align 4
.text$mn:00002693 _text$mn        ends
.text$mn:00002693
.text$mn:00002694 ; ===========================================================================
.text$mn:00002694
.text$mn:00002694 ; Segment type: Pure code
.text$mn:00002694 ; Segment permissions: Read/Execute
.text$mn:00002694 _text$mn        segment para public 'CODE' use32
.text$mn:00002694                 assume cs:_text$mn
.text$mn:00002694                 ;org 2694h
.text$mn:00002694 ; COMDAT (pick any)
.text$mn:00002694                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002694
.text$mn:00002694 ; =============== S U B R O U T I N E =======================================
.text$mn:00002694
.text$mn:00002694 ; Attributes: bp-based frame
.text$mn:00002694
.text$mn:00002694 ; public: virtual class std::error_condition __thiscall std::error_category::default_error_condition(int)const
.text$mn:00002694                 public ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
.text$mn:00002694 ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z proc near
.text$mn:00002694                                         ; DATA XREF: .rdata:00002FE8o
.text$mn:00002694                                         ; .rdata:00003004o ...
.text$mn:00002694
.text$mn:00002694 var_4           = dword ptr -4
.text$mn:00002694 arg_0           = dword ptr  8
.text$mn:00002694 arg_4           = dword ptr  0Ch
.text$mn:00002694
.text$mn:00002694                 push    ebp
.text$mn:00002695                 mov     ebp, esp
.text$mn:00002697                 push    ecx
.text$mn:00002698                 mov     [ebp+var_4], ecx
.text$mn:0000269B                 mov     eax, [ebp+var_4]
.text$mn:0000269E                 push    eax             ; struct std::error_category *
.text$mn:0000269F                 mov     ecx, [ebp+arg_4]
.text$mn:000026A2                 push    ecx             ; int
.text$mn:000026A3                 mov     ecx, [ebp+arg_0] ; this
.text$mn:000026A6                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:000026AB                 mov     eax, [ebp+arg_0]
.text$mn:000026AE                 mov     esp, ebp
.text$mn:000026B0                 pop     ebp
.text$mn:000026B1                 retn    8
.text$mn:000026B1 ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z endp
.text$mn:000026B1
.text$mn:000026B1 _text$mn        ends
.text$mn:000026B1
.text$mn:000026B4 ; ===========================================================================
.text$mn:000026B4
.text$mn:000026B4 ; Segment type: Pure code
.text$mn:000026B4 ; Segment permissions: Read/Execute
.text$mn:000026B4 _text$mn        segment para public 'CODE' use32
.text$mn:000026B4                 assume cs:_text$mn
.text$mn:000026B4                 ;org 26B4h
.text$mn:000026B4 ; COMDAT (pick any)
.text$mn:000026B4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000026B4
.text$mn:000026B4 ; =============== S U B R O U T I N E =======================================
.text$mn:000026B4
.text$mn:000026B4 ; Attributes: bp-based frame
.text$mn:000026B4
.text$mn:000026B4 ; bool __thiscall std::error_category::equivalent(std::error_category *this, const struct std::error_code *, int)
.text$mn:000026B4                 public ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
.text$mn:000026B4 ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z proc near
.text$mn:000026B4                                         ; DATA XREF: .rdata:00002FECo
.text$mn:000026B4                                         ; .rdata:00003008o ...
.text$mn:000026B4
.text$mn:000026B4 var_8           = dword ptr -8
.text$mn:000026B4 var_4           = dword ptr -4
.text$mn:000026B4 arg_0           = dword ptr  8
.text$mn:000026B4 arg_4           = dword ptr  0Ch
.text$mn:000026B4
.text$mn:000026B4                 push    ebp
.text$mn:000026B5                 mov     ebp, esp
.text$mn:000026B7                 sub     esp, 8
.text$mn:000026BA                 mov     [ebp+var_8], ecx
.text$mn:000026BD                 mov     ecx, [ebp+arg_0] ; this
.text$mn:000026C0                 call    ?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category(void)
.text$mn:000026C5                 push    eax
.text$mn:000026C6                 mov     ecx, [ebp+var_8]
.text$mn:000026C9                 call    ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
.text$mn:000026CE                 movzx   eax, al
.text$mn:000026D1                 test    eax, eax
.text$mn:000026D3                 jz      short loc_26EB
.text$mn:000026D5                 mov     ecx, [ebp+arg_0] ; this
.text$mn:000026D8                 call    ?value@error_code@std@@QBEHXZ ; std::error_code::value(void)
.text$mn:000026DD                 cmp     eax, [ebp+arg_4]
.text$mn:000026E0                 jnz     short loc_26EB
.text$mn:000026E2                 mov     [ebp+var_4], 1
.text$mn:000026E9                 jmp     short loc_26F2
.text$mn:000026EB ; ---------------------------------------------------------------------------
.text$mn:000026EB
.text$mn:000026EB loc_26EB:                               ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+1Fj
.text$mn:000026EB                                         ; std::error_category::equivalent(std::error_code const &,int)+2Cj
.text$mn:000026EB                 mov     [ebp+var_4], 0
.text$mn:000026F2
.text$mn:000026F2 loc_26F2:                               ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+35j
.text$mn:000026F2                 mov     al, byte ptr [ebp+var_4]
.text$mn:000026F5                 mov     esp, ebp
.text$mn:000026F7                 pop     ebp
.text$mn:000026F8                 retn    8
.text$mn:000026F8 ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z endp
.text$mn:000026F8
.text$mn:000026F8 ; ---------------------------------------------------------------------------
.text$mn:000026FB                 align 4
.text$mn:000026FB _text$mn        ends
.text$mn:000026FB
.text$mn:000026FC ; ===========================================================================
.text$mn:000026FC
.text$mn:000026FC ; Segment type: Pure code
.text$mn:000026FC ; Segment permissions: Read/Execute
.text$mn:000026FC _text$mn        segment para public 'CODE' use32
.text$mn:000026FC                 assume cs:_text$mn
.text$mn:000026FC                 ;org 26FCh
.text$mn:000026FC ; COMDAT (pick any)
.text$mn:000026FC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000026FC
.text$mn:000026FC ; =============== S U B R O U T I N E =======================================
.text$mn:000026FC
.text$mn:000026FC ; Attributes: bp-based frame
.text$mn:000026FC
.text$mn:000026FC ; bool __thiscall std::error_category::equivalent(std::error_category *this, int, const struct std::error_condition *)
.text$mn:000026FC                 public ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
.text$mn:000026FC ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z proc near
.text$mn:000026FC                                         ; DATA XREF: .rdata:00002FF0o
.text$mn:000026FC                                         ; .rdata:0000300Co ...
.text$mn:000026FC
.text$mn:000026FC var_C           = byte ptr -0Ch
.text$mn:000026FC var_4           = dword ptr -4
.text$mn:000026FC arg_0           = dword ptr  8
.text$mn:000026FC arg_4           = dword ptr  0Ch
.text$mn:000026FC
.text$mn:000026FC                 push    ebp
.text$mn:000026FD                 mov     ebp, esp
.text$mn:000026FF                 sub     esp, 0Ch
.text$mn:00002702                 mov     [ebp+var_4], ecx
.text$mn:00002705                 mov     eax, [ebp+arg_4]
.text$mn:00002708                 push    eax             ; std::error_condition *
.text$mn:00002709                 mov     ecx, [ebp+arg_0]
.text$mn:0000270C                 push    ecx
.text$mn:0000270D                 lea     edx, [ebp+var_C]
.text$mn:00002710                 push    edx
.text$mn:00002711                 mov     eax, [ebp+var_4]
.text$mn:00002714                 mov     edx, [eax]
.text$mn:00002716                 mov     ecx, [ebp+var_4]
.text$mn:00002719                 mov     eax, [edx+0Ch]
.text$mn:0000271C                 call    eax
.text$mn:0000271E                 mov     ecx, eax
.text$mn:00002720                 call    ??8error_condition@std@@QBE_NABV01@@Z ; std::error_condition::operator==(std::error_condition const &)
.text$mn:00002725                 mov     esp, ebp
.text$mn:00002727                 pop     ebp
.text$mn:00002728                 retn    8
.text$mn:00002728 ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z endp
.text$mn:00002728
.text$mn:00002728 ; ---------------------------------------------------------------------------
.text$mn:0000272B                 align 4
.text$mn:0000272B _text$mn        ends
.text$mn:0000272B
.text$mn:0000272C ; ===========================================================================
.text$mn:0000272C
.text$mn:0000272C ; Segment type: Pure code
.text$mn:0000272C ; Segment permissions: Read/Execute
.text$mn:0000272C _text$mn        segment para public 'CODE' use32
.text$mn:0000272C                 assume cs:_text$mn
.text$mn:0000272C                 ;org 272Ch
.text$mn:0000272C ; COMDAT (pick any)
.text$mn:0000272C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000272C
.text$mn:0000272C ; =============== S U B R O U T I N E =======================================
.text$mn:0000272C
.text$mn:0000272C ; Attributes: bp-based frame
.text$mn:0000272C
.text$mn:0000272C ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int)
.text$mn:0000272C                 public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
.text$mn:0000272C ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z proc near
.text$mn:0000272C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+4Cp
.text$mn:0000272C
.text$mn:0000272C var_4           = dword ptr -4
.text$mn:0000272C arg_0           = dword ptr  8
.text$mn:0000272C
.text$mn:0000272C                 push    ebp
.text$mn:0000272D                 mov     ebp, esp
.text$mn:0000272F                 push    ecx
.text$mn:00002730                 mov     [ebp+var_4], ecx
.text$mn:00002733                 mov     eax, [ebp+var_4]
.text$mn:00002736                 mov     ecx, [eax+14h]
.text$mn:00002739                 cmp     ecx, [ebp+arg_0]
.text$mn:0000273C                 jnb     short loc_2746
.text$mn:0000273E                 mov     ecx, [ebp+var_4]
.text$mn:00002741                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:00002746
.text$mn:00002746 loc_2746:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)+10j
.text$mn:00002746                 mov     edx, [ebp+arg_0]
.text$mn:00002749                 push    edx
.text$mn:0000274A                 mov     ecx, [ebp+var_4]
.text$mn:0000274D                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00002752                 mov     eax, [ebp+var_4]
.text$mn:00002755                 mov     esp, ebp
.text$mn:00002757                 pop     ebp
.text$mn:00002758                 retn    4
.text$mn:00002758 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z endp
.text$mn:00002758
.text$mn:00002758 ; ---------------------------------------------------------------------------
.text$mn:0000275B                 align 4
.text$mn:0000275B _text$mn        ends
.text$mn:0000275B
.text$mn:0000275C ; ===========================================================================
.text$mn:0000275C
.text$mn:0000275C ; Segment type: Pure code
.text$mn:0000275C ; Segment permissions: Read/Execute
.text$mn:0000275C _text$mn        segment para public 'CODE' use32
.text$mn:0000275C                 assume cs:_text$mn
.text$mn:0000275C                 ;org 275Ch
.text$mn:0000275C ; COMDAT (pick any)
.text$mn:0000275C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000275C
.text$mn:0000275C ; =============== S U B R O U T I N E =======================================
.text$mn:0000275C
.text$mn:0000275C ; Attributes: bp-based frame
.text$mn:0000275C
.text$mn:0000275C ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int, unsigned int)
.text$mn:0000275C                 public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
.text$mn:0000275C ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z proc near
.text$mn:0000275C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+5Ap
.text$mn:0000275C
.text$mn:0000275C var_C           = dword ptr -0Ch
.text$mn:0000275C Dst             = dword ptr -8
.text$mn:0000275C var_4           = dword ptr -4
.text$mn:0000275C arg_0           = dword ptr  8
.text$mn:0000275C arg_4           = dword ptr  0Ch
.text$mn:0000275C
.text$mn:0000275C                 push    ebp
.text$mn:0000275D                 mov     ebp, esp
.text$mn:0000275F                 sub     esp, 0Ch
.text$mn:00002762                 mov     [ebp+var_4], ecx
.text$mn:00002765                 mov     eax, [ebp+var_4]
.text$mn:00002768                 mov     ecx, [eax+14h]
.text$mn:0000276B                 cmp     ecx, [ebp+arg_0]
.text$mn:0000276E                 jnb     short loc_2778
.text$mn:00002770                 mov     ecx, [ebp+var_4]
.text$mn:00002773                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:00002778
.text$mn:00002778 loc_2778:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+12j
.text$mn:00002778                 mov     edx, [ebp+var_4]
.text$mn:0000277B                 mov     eax, [edx+14h]
.text$mn:0000277E                 sub     eax, [ebp+arg_0]
.text$mn:00002781                 cmp     eax, [ebp+arg_4]
.text$mn:00002784                 ja      short loc_2794
.text$mn:00002786                 mov     ecx, [ebp+arg_0]
.text$mn:00002789                 push    ecx
.text$mn:0000278A                 mov     ecx, [ebp+var_4]
.text$mn:0000278D                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00002792                 jmp     short loc_27DA
.text$mn:00002794 ; ---------------------------------------------------------------------------
.text$mn:00002794
.text$mn:00002794 loc_2794:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+28j
.text$mn:00002794                 cmp     [ebp+arg_4], 0
.text$mn:00002798                 jbe     short loc_27DA
.text$mn:0000279A                 mov     ecx, [ebp+var_4]
.text$mn:0000279D                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000027A2                 add     eax, [ebp+arg_0]
.text$mn:000027A5                 mov     [ebp+Dst], eax
.text$mn:000027A8                 mov     edx, [ebp+var_4]
.text$mn:000027AB                 mov     eax, [edx+14h]
.text$mn:000027AE                 sub     eax, [ebp+arg_4]
.text$mn:000027B1                 mov     [ebp+var_C], eax
.text$mn:000027B4                 mov     ecx, [ebp+var_C]
.text$mn:000027B7                 sub     ecx, [ebp+arg_0]
.text$mn:000027BA                 push    ecx             ; Size
.text$mn:000027BB                 mov     edx, [ebp+Dst]
.text$mn:000027BE                 add     edx, [ebp+arg_4]
.text$mn:000027C1                 push    edx             ; Src
.text$mn:000027C2                 mov     eax, [ebp+Dst]
.text$mn:000027C5                 push    eax             ; Dst
.text$mn:000027C6                 call    ?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move(char *,char const *,uint)
.text$mn:000027CB                 add     esp, 0Ch
.text$mn:000027CE                 mov     ecx, [ebp+var_C]
.text$mn:000027D1                 push    ecx
.text$mn:000027D2                 mov     ecx, [ebp+var_4]
.text$mn:000027D5                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000027DA
.text$mn:000027DA loc_27DA:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+36j
.text$mn:000027DA                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+3Cj
.text$mn:000027DA                 mov     eax, [ebp+var_4]
.text$mn:000027DD                 mov     esp, ebp
.text$mn:000027DF                 pop     ebp
.text$mn:000027E0                 retn    8
.text$mn:000027E0 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z endp
.text$mn:000027E0
.text$mn:000027E0 ; ---------------------------------------------------------------------------
.text$mn:000027E3                 align 4
.text$mn:000027E3 _text$mn        ends
.text$mn:000027E3
.text$mn:000027E4 ; ===========================================================================
.text$mn:000027E4
.text$mn:000027E4 ; Segment type: Pure code
.text$mn:000027E4 ; Segment permissions: Read/Execute
.text$mn:000027E4 _text$mn        segment para public 'CODE' use32
.text$mn:000027E4                 assume cs:_text$mn
.text$mn:000027E4                 ;org 27E4h
.text$mn:000027E4 ; COMDAT (pick any)
.text$mn:000027E4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000027E4
.text$mn:000027E4 ; =============== S U B R O U T I N E =======================================
.text$mn:000027E4
.text$mn:000027E4 ; Attributes: bp-based frame
.text$mn:000027E4
.text$mn:000027E4 ; const struct std::error_category *__cdecl std::generic_category()
.text$mn:000027E4                 public ?generic_category@std@@YAABVerror_category@1@XZ
.text$mn:000027E4 ?generic_category@std@@YAABVerror_category@1@XZ proc near
.text$mn:000027E4                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+17p
.text$mn:000027E4                 push    ebp
.text$mn:000027E5                 mov     ebp, esp
.text$mn:000027E7                 mov     eax, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
.text$mn:000027EC                 pop     ebp
.text$mn:000027ED                 retn
.text$mn:000027ED ?generic_category@std@@YAABVerror_category@1@XZ endp
.text$mn:000027ED
.text$mn:000027ED ; ---------------------------------------------------------------------------
.text$mn:000027EE                 align 10h
.text$mn:000027EE _text$mn        ends
.text$mn:000027EE
.text$mn:000027F0 ; ===========================================================================
.text$mn:000027F0
.text$mn:000027F0 ; Segment type: Pure code
.text$mn:000027F0 ; Segment permissions: Read/Execute
.text$mn:000027F0 _text$mn        segment para public 'CODE' use32
.text$mn:000027F0                 assume cs:_text$mn
.text$mn:000027F0                 ;org 27F0h
.text$mn:000027F0 ; COMDAT (pick any)
.text$mn:000027F0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000027F0
.text$mn:000027F0 ; =============== S U B R O U T I N E =======================================
.text$mn:000027F0
.text$mn:000027F0 ; Attributes: bp-based frame
.text$mn:000027F0
.text$mn:000027F0 ; struct NppParameters *__cdecl NppParameters::getInstance()
.text$mn:000027F0                 public ?getInstance@NppParameters@@SAPAV1@XZ
.text$mn:000027F0 ?getInstance@NppParameters@@SAPAV1@XZ proc near
.text$mn:000027F0                                         ; CODE XREF: RunMacroDlg::initMacroList(void):loc_DC2p
.text$mn:000027F0                 push    ebp
.text$mn:000027F1                 mov     ebp, esp
.text$mn:000027F3                 mov     eax, dword ptr ds:?_pSelf@NppParameters@@0PAV1@A ; NppParameters * NppParameters::_pSelf
.text$mn:000027F8                 pop     ebp
.text$mn:000027F9                 retn
.text$mn:000027F9 ?getInstance@NppParameters@@SAPAV1@XZ endp
.text$mn:000027F9
.text$mn:000027F9 ; ---------------------------------------------------------------------------
.text$mn:000027FA                 align 4
.text$mn:000027FA _text$mn        ends
.text$mn:000027FA
.text$mn:000027FC ; ===========================================================================
.text$mn:000027FC
.text$mn:000027FC ; Segment type: Pure code
.text$mn:000027FC ; Segment permissions: Read/Execute
.text$mn:000027FC _text$mn        segment para public 'CODE' use32
.text$mn:000027FC                 assume cs:_text$mn
.text$mn:000027FC                 ;org 27FCh
.text$mn:000027FC ; COMDAT (pick any)
.text$mn:000027FC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000027FC
.text$mn:000027FC ; =============== S U B R O U T I N E =======================================
.text$mn:000027FC
.text$mn:000027FC ; Attributes: bp-based frame
.text$mn:000027FC
.text$mn:000027FC ; public: class std::vector<class MacroShortcut, class std::allocator<class MacroShortcut>> & __thiscall NppParameters::getMacroList(void)
.text$mn:000027FC                 public ?getMacroList@NppParameters@@QAEAAV?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@XZ
.text$mn:000027FC ?getMacroList@NppParameters@@QAEAAV?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@XZ proc near
.text$mn:000027FC                                         ; CODE XREF: RunMacroDlg::initMacroList(void)+2Dp
.text$mn:000027FC
.text$mn:000027FC var_4           = dword ptr -4
.text$mn:000027FC
.text$mn:000027FC                 push    ebp
.text$mn:000027FD                 mov     ebp, esp
.text$mn:000027FF                 push    ecx
.text$mn:00002800                 mov     [ebp+var_4], ecx
.text$mn:00002803                 mov     eax, [ebp+var_4]
.text$mn:00002806                 add     eax, 1C924h
.text$mn:0000280B                 mov     esp, ebp
.text$mn:0000280D                 pop     ebp
.text$mn:0000280E                 retn
.text$mn:0000280E ?getMacroList@NppParameters@@QAEAAV?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@XZ endp
.text$mn:0000280E
.text$mn:0000280E ; ---------------------------------------------------------------------------
.text$mn:0000280F                 align 10h
.text$mn:0000280F _text$mn        ends
.text$mn:0000280F
.text$mn:00002810 ; ===========================================================================
.text$mn:00002810
.text$mn:00002810 ; Segment type: Pure code
.text$mn:00002810 ; Segment permissions: Read/Execute
.text$mn:00002810 _text$mn        segment para public 'CODE' use32
.text$mn:00002810                 assume cs:_text$mn
.text$mn:00002810                 ;org 2810h
.text$mn:00002810 ; COMDAT (pick any)
.text$mn:00002810                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002810
.text$mn:00002810 ; =============== S U B R O U T I N E =======================================
.text$mn:00002810
.text$mn:00002810 ; Attributes: bp-based frame
.text$mn:00002810
.text$mn:00002810 ; const wchar_t *__thiscall Shortcut::getName(Shortcut *__hidden this)
.text$mn:00002810                 public ?getName@Shortcut@@QBEPB_WXZ
.text$mn:00002810 ?getName@Shortcut@@QBEPB_WXZ proc near  ; CODE XREF: RunMacroDlg::initMacroList(void)+BCp
.text$mn:00002810
.text$mn:00002810 var_4           = dword ptr -4
.text$mn:00002810
.text$mn:00002810                 push    ebp
.text$mn:00002811                 mov     ebp, esp
.text$mn:00002813                 push    ecx
.text$mn:00002814                 mov     [ebp+var_4], ecx
.text$mn:00002817                 mov     eax, [ebp+var_4]
.text$mn:0000281A                 add     eax, 26h ; '&'
.text$mn:0000281D                 mov     esp, ebp
.text$mn:0000281F                 pop     ebp
.text$mn:00002820                 retn
.text$mn:00002820 ?getName@Shortcut@@QBEPB_WXZ endp
.text$mn:00002820
.text$mn:00002820 ; ---------------------------------------------------------------------------
.text$mn:00002821                 align 4
.text$mn:00002821 _text$mn        ends
.text$mn:00002821
.text$mn:00002824 ; ===========================================================================
.text$mn:00002824
.text$mn:00002824 ; Segment type: Pure code
.text$mn:00002824 ; Segment permissions: Read/Execute
.text$mn:00002824 _text$mn        segment para public 'CODE' use32
.text$mn:00002824                 assume cs:_text$mn
.text$mn:00002824                 ;org 2824h
.text$mn:00002824 ; COMDAT (pick any)
.text$mn:00002824                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002824
.text$mn:00002824 ; =============== S U B R O U T I N E =======================================
.text$mn:00002824
.text$mn:00002824 ; Attributes: bp-based frame
.text$mn:00002824
.text$mn:00002824 ; bool __thiscall StaticDialog::isCheckedOrNot(StaticDialog *this, int)
.text$mn:00002824                 public ?isCheckedOrNot@StaticDialog@@QBE_NH@Z
.text$mn:00002824 ?isCheckedOrNot@StaticDialog@@QBE_NH@Z proc near
.text$mn:00002824                                         ; CODE XREF: RunMacroDlg::run_dlgProc(uint,uint,long)+130p
.text$mn:00002824                                         ; RunMacroDlg::run_dlgProc(uint,uint,long)+16Cp
.text$mn:00002824
.text$mn:00002824 var_8           = dword ptr -8
.text$mn:00002824 var_4           = dword ptr -4
.text$mn:00002824 nIDDlgItem      = dword ptr  8
.text$mn:00002824
.text$mn:00002824                 push    ebp
.text$mn:00002825                 mov     ebp, esp
.text$mn:00002827                 sub     esp, 8
.text$mn:0000282A                 mov     [ebp+var_8], ecx
.text$mn:0000282D                 push    0               ; lParam
.text$mn:0000282F                 push    0               ; wParam
.text$mn:00002831                 push    0F0h ; '='      ; Msg
.text$mn:00002836                 mov     eax, [ebp+nIDDlgItem]
.text$mn:00002839                 push    eax             ; nIDDlgItem
.text$mn:0000283A                 mov     ecx, [ebp+var_8]
.text$mn:0000283D                 mov     edx, [ecx+0Ch]
.text$mn:00002840                 push    edx             ; hDlg
.text$mn:00002841                 call    dword ptr ds:__imp__GetDlgItem@8 ; GetDlgItem(x,x)
.text$mn:00002847                 push    eax             ; hWnd
.text$mn:00002848                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:0000284E                 cmp     eax, 1
.text$mn:00002851                 jnz     short loc_285C
.text$mn:00002853                 mov     [ebp+var_4], 1
.text$mn:0000285A                 jmp     short loc_2863
.text$mn:0000285C ; ---------------------------------------------------------------------------
.text$mn:0000285C
.text$mn:0000285C loc_285C:                               ; CODE XREF: StaticDialog::isCheckedOrNot(int)+2Dj
.text$mn:0000285C                 mov     [ebp+var_4], 0
.text$mn:00002863
.text$mn:00002863 loc_2863:                               ; CODE XREF: StaticDialog::isCheckedOrNot(int)+36j
.text$mn:00002863                 mov     al, byte ptr [ebp+var_4]
.text$mn:00002866                 mov     esp, ebp
.text$mn:00002868                 pop     ebp
.text$mn:00002869                 retn    4
.text$mn:00002869 ?isCheckedOrNot@StaticDialog@@QBE_NH@Z endp
.text$mn:00002869
.text$mn:00002869 _text$mn        ends
.text$mn:00002869
.text$mn:0000286C ; ===========================================================================
.text$mn:0000286C
.text$mn:0000286C ; Segment type: Pure code
.text$mn:0000286C ; Segment permissions: Read/Execute
.text$mn:0000286C _text$mn        segment para public 'CODE' use32
.text$mn:0000286C                 assume cs:_text$mn
.text$mn:0000286C                 ;org 286Ch
.text$mn:0000286C ; COMDAT (pick any)
.text$mn:0000286C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000286C
.text$mn:0000286C ; =============== S U B R O U T I N E =======================================
.text$mn:0000286C
.text$mn:0000286C ; Attributes: bp-based frame
.text$mn:0000286C
.text$mn:0000286C ; int __cdecl std::char_traits<char>::length(char *Str)
.text$mn:0000286C                 public ?length@?$char_traits@D@std@@SAIPBD@Z
.text$mn:0000286C ?length@?$char_traits@D@std@@SAIPBD@Z proc near
.text$mn:0000286C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+21p
.text$mn:0000286C
.text$mn:0000286C var_4           = dword ptr -4
.text$mn:0000286C Str             = dword ptr  8
.text$mn:0000286C
.text$mn:0000286C                 push    ebp
.text$mn:0000286D                 mov     ebp, esp
.text$mn:0000286F                 push    ecx
.text$mn:00002870                 mov     eax, [ebp+Str]
.text$mn:00002873                 movsx   ecx, byte ptr [eax]
.text$mn:00002876                 test    ecx, ecx
.text$mn:00002878                 jnz     short loc_2883
.text$mn:0000287A                 mov     [ebp+var_4], 0
.text$mn:00002881                 jmp     short loc_2892
.text$mn:00002883 ; ---------------------------------------------------------------------------
.text$mn:00002883
.text$mn:00002883 loc_2883:                               ; CODE XREF: std::char_traits<char>::length(char const *)+Cj
.text$mn:00002883                 mov     edx, [ebp+Str]
.text$mn:00002886                 push    edx             ; Str
.text$mn:00002887                 call    _strlen
.text$mn:0000288C                 add     esp, 4
.text$mn:0000288F                 mov     [ebp+var_4], eax
.text$mn:00002892
.text$mn:00002892 loc_2892:                               ; CODE XREF: std::char_traits<char>::length(char const *)+15j
.text$mn:00002892                 mov     eax, [ebp+var_4]
.text$mn:00002895                 mov     esp, ebp
.text$mn:00002897                 pop     ebp
.text$mn:00002898                 retn
.text$mn:00002898 ?length@?$char_traits@D@std@@SAIPBD@Z endp
.text$mn:00002898
.text$mn:00002898 ; ---------------------------------------------------------------------------
.text$mn:00002899                 align 4
.text$mn:00002899 _text$mn        ends
.text$mn:00002899
.text$mn:0000289C ; ===========================================================================
.text$mn:0000289C
.text$mn:0000289C ; Segment type: Pure code
.text$mn:0000289C ; Segment permissions: Read/Execute
.text$mn:0000289C _text$mn        segment para public 'CODE' use32
.text$mn:0000289C                 assume cs:_text$mn
.text$mn:0000289C                 ;org 289Ch
.text$mn:0000289C ; COMDAT (pick any)
.text$mn:0000289C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000289C
.text$mn:0000289C ; =============== S U B R O U T I N E =======================================
.text$mn:0000289C
.text$mn:0000289C ; Attributes: bp-based frame
.text$mn:0000289C
.text$mn:0000289C ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<char>>::max_size(void)const
.text$mn:0000289C                 public ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
.text$mn:0000289C ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ proc near
.text$mn:0000289C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+17p
.text$mn:0000289C
.text$mn:0000289C var_4           = dword ptr -4
.text$mn:0000289C
.text$mn:0000289C                 push    ebp
.text$mn:0000289D                 mov     ebp, esp
.text$mn:0000289F                 push    ecx
.text$mn:000028A0                 mov     [ebp+var_4], ecx
.text$mn:000028A3                 mov     eax, [ebp+var_4]
.text$mn:000028A6                 push    eax
.text$mn:000028A7                 call    ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char> const &)
.text$mn:000028AC                 add     esp, 4
.text$mn:000028AF                 mov     esp, ebp
.text$mn:000028B1                 pop     ebp
.text$mn:000028B2                 retn
.text$mn:000028B2 ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ endp
.text$mn:000028B2
.text$mn:000028B2 ; ---------------------------------------------------------------------------
.text$mn:000028B3                 align 4
.text$mn:000028B3 _text$mn        ends
.text$mn:000028B3
.text$mn:000028B4 ; ===========================================================================
.text$mn:000028B4
.text$mn:000028B4 ; Segment type: Pure code
.text$mn:000028B4 ; Segment permissions: Read/Execute
.text$mn:000028B4 _text$mn        segment para public 'CODE' use32
.text$mn:000028B4                 assume cs:_text$mn
.text$mn:000028B4                 ;org 28B4h
.text$mn:000028B4 ; COMDAT (pick any)
.text$mn:000028B4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000028B4
.text$mn:000028B4 ; =============== S U B R O U T I N E =======================================
.text$mn:000028B4
.text$mn:000028B4 ; Attributes: bp-based frame
.text$mn:000028B4
.text$mn:000028B4 ; public: unsigned int __thiscall std::allocator<char>::max_size(void)const
.text$mn:000028B4                 public ?max_size@?$allocator@D@std@@QBEIXZ
.text$mn:000028B4 ?max_size@?$allocator@D@std@@QBEIXZ proc near
.text$mn:000028B4                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char> const &)+6p
.text$mn:000028B4
.text$mn:000028B4 var_4           = dword ptr -4
.text$mn:000028B4
.text$mn:000028B4                 push    ebp
.text$mn:000028B5                 mov     ebp, esp
.text$mn:000028B7                 push    ecx
.text$mn:000028B8                 mov     [ebp+var_4], ecx
.text$mn:000028BB                 or      eax, 0FFFFFFFFh
.text$mn:000028BE                 mov     esp, ebp
.text$mn:000028C0                 pop     ebp
.text$mn:000028C1                 retn
.text$mn:000028C1 ?max_size@?$allocator@D@std@@QBEIXZ endp
.text$mn:000028C1
.text$mn:000028C1 ; ---------------------------------------------------------------------------
.text$mn:000028C2                 align 4
.text$mn:000028C2 _text$mn        ends
.text$mn:000028C2
.text$mn:000028C4 ; ===========================================================================
.text$mn:000028C4
.text$mn:000028C4 ; Segment type: Pure code
.text$mn:000028C4 ; Segment permissions: Read/Execute
.text$mn:000028C4 _text$mn        segment para public 'CODE' use32
.text$mn:000028C4                 assume cs:_text$mn
.text$mn:000028C4                 ;org 28C4h
.text$mn:000028C4 ; COMDAT (pick any)
.text$mn:000028C4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000028C4
.text$mn:000028C4 ; =============== S U B R O U T I N E =======================================
.text$mn:000028C4
.text$mn:000028C4 ; Attributes: bp-based frame
.text$mn:000028C4
.text$mn:000028C4 ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<char>>::max_size(class std::allocator<char> const &)
.text$mn:000028C4                 public ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
.text$mn:000028C4 ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z proc near
.text$mn:000028C4                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::max_size(void)+Bp
.text$mn:000028C4
.text$mn:000028C4 arg_0           = dword ptr  8
.text$mn:000028C4
.text$mn:000028C4                 push    ebp
.text$mn:000028C5                 mov     ebp, esp
.text$mn:000028C7                 mov     ecx, [ebp+arg_0]
.text$mn:000028CA                 call    ?max_size@?$allocator@D@std@@QBEIXZ ; std::allocator<char>::max_size(void)
.text$mn:000028CF                 pop     ebp
.text$mn:000028D0                 retn
.text$mn:000028D0 ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z endp
.text$mn:000028D0
.text$mn:000028D0 ; ---------------------------------------------------------------------------
.text$mn:000028D1                 align 4
.text$mn:000028D1 _text$mn        ends
.text$mn:000028D1
.text$mn:000028D4 ; ===========================================================================
.text$mn:000028D4
.text$mn:000028D4 ; Segment type: Pure code
.text$mn:000028D4 ; Segment permissions: Read/Execute
.text$mn:000028D4 _text$mn        segment para public 'CODE' use32
.text$mn:000028D4                 assume cs:_text$mn
.text$mn:000028D4                 ;org 28D4h
.text$mn:000028D4 ; COMDAT (pick any)
.text$mn:000028D4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000028D4
.text$mn:000028D4 ; =============== S U B R O U T I N E =======================================
.text$mn:000028D4
.text$mn:000028D4 ; Attributes: bp-based frame
.text$mn:000028D4
.text$mn:000028D4 ; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::max_size(void)const
.text$mn:000028D4                 public ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
.text$mn:000028D4 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
.text$mn:000028D4                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+3Bp
.text$mn:000028D4                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+6Ap ...
.text$mn:000028D4
.text$mn:000028D4 var_10          = dword ptr -10h
.text$mn:000028D4 var_C           = dword ptr -0Ch
.text$mn:000028D4 var_8           = dword ptr -8
.text$mn:000028D4 var_1           = byte ptr -1
.text$mn:000028D4
.text$mn:000028D4                 push    ebp
.text$mn:000028D5                 mov     ebp, esp
.text$mn:000028D7                 sub     esp, 10h
.text$mn:000028DA                 mov     [ebp+var_10], ecx
.text$mn:000028DD                 lea     eax, [ebp+var_1]
.text$mn:000028E0                 push    eax
.text$mn:000028E1                 mov     ecx, [ebp+var_10]
.text$mn:000028E4                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:000028E9                 mov     ecx, eax
.text$mn:000028EB                 call    ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char>>::max_size(void)
.text$mn:000028F0                 mov     [ebp+var_8], eax
.text$mn:000028F3                 cmp     [ebp+var_8], 1
.text$mn:000028F7                 ja      short loc_2902
.text$mn:000028F9                 mov     [ebp+var_C], 1
.text$mn:00002900                 jmp     short loc_290B
.text$mn:00002902 ; ---------------------------------------------------------------------------
.text$mn:00002902
.text$mn:00002902 loc_2902:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+23j
.text$mn:00002902                 mov     ecx, [ebp+var_8]
.text$mn:00002905                 sub     ecx, 1
.text$mn:00002908                 mov     [ebp+var_C], ecx
.text$mn:0000290B
.text$mn:0000290B loc_290B:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+2Cj
.text$mn:0000290B                 mov     eax, [ebp+var_C]
.text$mn:0000290E                 mov     esp, ebp
.text$mn:00002910                 pop     ebp
.text$mn:00002911                 retn
.text$mn:00002911 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp
.text$mn:00002911
.text$mn:00002911 ; ---------------------------------------------------------------------------
.text$mn:00002912                 align 4
.text$mn:00002912 _text$mn        ends
.text$mn:00002912
.text$mn:00002914 ; ===========================================================================
.text$mn:00002914
.text$mn:00002914 ; Segment type: Pure code
.text$mn:00002914 ; Segment permissions: Read/Execute
.text$mn:00002914 _text$mn        segment para public 'CODE' use32
.text$mn:00002914                 assume cs:_text$mn
.text$mn:00002914                 ;org 2914h
.text$mn:00002914 ; COMDAT (pick any)
.text$mn:00002914                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002914
.text$mn:00002914 ; =============== S U B R O U T I N E =======================================
.text$mn:00002914
.text$mn:00002914 ; Attributes: bp-based frame
.text$mn:00002914
.text$mn:00002914 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Generic_error_category::message(int)const
.text$mn:00002914                 public ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00002914 ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:00002914                                         ; CODE XREF: std::_Iostream_error_category::message(int)+64p
.text$mn:00002914                                         ; DATA XREF: .rdata:00003000o
.text$mn:00002914
.text$mn:00002914 var_1C          = dword ptr -1Ch
.text$mn:00002914 var_18          = dword ptr -18h
.text$mn:00002914 Str             = dword ptr -14h
.text$mn:00002914 var_10          = dword ptr -10h
.text$mn:00002914 var_C           = dword ptr -0Ch
.text$mn:00002914 var_4           = dword ptr -4
.text$mn:00002914 arg_0           = dword ptr  8
.text$mn:00002914 arg_4           = dword ptr  0Ch
.text$mn:00002914
.text$mn:00002914                 push    ebp
.text$mn:00002915                 mov     ebp, esp
.text$mn:00002917                 push    0FFFFFFFFh
.text$mn:00002919                 push    offset __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:0000291E                 mov     eax, large fs:0
.text$mn:00002924                 push    eax
.text$mn:00002925                 sub     esp, 10h
.text$mn:00002928                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000292D                 xor     eax, ebp
.text$mn:0000292F                 push    eax
.text$mn:00002930                 lea     eax, [ebp+var_C]
.text$mn:00002933                 mov     large fs:0, eax
.text$mn:00002939                 mov     [ebp+var_1C], ecx
.text$mn:0000293C                 mov     [ebp+var_18], 0
.text$mn:00002943                 mov     eax, [ebp+arg_4]
.text$mn:00002946                 push    eax             ; int
.text$mn:00002947                 call    ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map(int)
.text$mn:0000294C                 add     esp, 4
.text$mn:0000294F                 mov     [ebp+var_10], eax
.text$mn:00002952                 cmp     [ebp+var_10], 0
.text$mn:00002956                 jz      short loc_2960
.text$mn:00002958                 mov     ecx, [ebp+var_10]
.text$mn:0000295B                 mov     [ebp+Str], ecx
.text$mn:0000295E                 jmp     short loc_2967
.text$mn:00002960 ; ---------------------------------------------------------------------------
.text$mn:00002960
.text$mn:00002960 loc_2960:                               ; CODE XREF: std::_Generic_error_category::message(int)+42j
.text$mn:00002960                 mov     [ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ ; "unknown error"
.text$mn:00002967
.text$mn:00002967 loc_2967:                               ; CODE XREF: std::_Generic_error_category::message(int)+4Aj
.text$mn:00002967                 mov     edx, [ebp+Str]
.text$mn:0000296A                 push    edx             ; Str
.text$mn:0000296B                 mov     ecx, [ebp+arg_0]
.text$mn:0000296E                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:00002973                 mov     [ebp+var_4], 0
.text$mn:0000297A                 mov     eax, [ebp+var_18]
.text$mn:0000297D                 or      eax, 1
.text$mn:00002980                 mov     [ebp+var_18], eax
.text$mn:00002983                 mov     eax, [ebp+arg_0]
.text$mn:00002986                 mov     ecx, [ebp+var_C]
.text$mn:00002989                 mov     large fs:0, ecx
.text$mn:00002990                 pop     ecx
.text$mn:00002991                 mov     esp, ebp
.text$mn:00002993                 pop     ebp
.text$mn:00002994                 retn    8
.text$mn:00002994 ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:00002994
.text$mn:00002994 ; ---------------------------------------------------------------------------
.text$mn:00002997                 align 4
.text$mn:00002997 _text$mn        ends
.text$mn:00002997
.text$x:00002998 ; ===========================================================================
.text$x:00002998
.text$x:00002998 ; Segment type: Pure code
.text$x:00002998 ; Segment permissions: Read/Execute
.text$x:00002998 _text$x         segment para public 'CODE' use32
.text$x:00002998                 assume cs:_text$x
.text$x:00002998                 ;org 2998h
.text$x:00002998 ; COMDAT (pick associative to section at 2914)
.text$x:00002998                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00002998
.text$x:00002998 ; =============== S U B R O U T I N E =======================================
.text$x:00002998
.text$x:00002998
.text$x:00002998 __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:00002998                                         ; DATA XREF: .xdata$x:00002E20o
.text$x:00002998                 mov     eax, [ebp-18h]
.text$x:0000299B                 and     eax, 1
.text$x:0000299E                 jz      $LN6
.text$x:000029A4                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:000029A8                 mov     ecx, [ebp+8]
.text$x:000029AB                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:000029B0 ; ---------------------------------------------------------------------------
.text$x:000029B0
.text$x:000029B0 $LN6:                                   ; CODE XREF: __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:000029B0                 retn
.text$x:000029B0 __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:000029B0
.text$x:000029B1
.text$x:000029B1 ; =============== S U B R O U T I N E =======================================
.text$x:000029B1
.text$x:000029B1
.text$x:000029B1 __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:000029B1                                         ; DATA XREF: std::_Generic_error_category::message(int)+5o
.text$x:000029B1
.text$x:000029B1 arg_4           = dword ptr  8
.text$x:000029B1
.text$x:000029B1                 mov     edx, [esp+arg_4]
.text$x:000029B5                 lea     eax, [edx+0Ch]
.text$x:000029B8                 mov     ecx, [edx-14h]
.text$x:000029BB                 xor     ecx, eax
.text$x:000029BD                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000029C2                 mov     eax, offset __ehfuncinfo$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:000029C7                 jmp     ___CxxFrameHandler3
.text$x:000029C7 __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:000029C7
.text$x:000029C7 _text$x         ends
.text$x:000029C7
.text$mn:000029CC ; ===========================================================================
.text$mn:000029CC
.text$mn:000029CC ; Segment type: Pure code
.text$mn:000029CC ; Segment permissions: Read/Execute
.text$mn:000029CC _text$mn        segment para public 'CODE' use32
.text$mn:000029CC                 assume cs:_text$mn
.text$mn:000029CC                 ;org 29CCh
.text$mn:000029CC ; COMDAT (pick any)
.text$mn:000029CC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000029CC
.text$mn:000029CC ; =============== S U B R O U T I N E =======================================
.text$mn:000029CC
.text$mn:000029CC ; Attributes: bp-based frame
.text$mn:000029CC
.text$mn:000029CC ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Iostream_error_category::message(int)const
.text$mn:000029CC                 public ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:000029CC ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:000029CC                                         ; DATA XREF: .rdata:00003034o
.text$mn:000029CC
.text$mn:000029CC var_14          = dword ptr -14h
.text$mn:000029CC var_10          = dword ptr -10h
.text$mn:000029CC var_C           = dword ptr -0Ch
.text$mn:000029CC var_4           = dword ptr -4
.text$mn:000029CC arg_0           = dword ptr  8
.text$mn:000029CC arg_4           = dword ptr  0Ch
.text$mn:000029CC
.text$mn:000029CC                 push    ebp
.text$mn:000029CD                 mov     ebp, esp
.text$mn:000029CF                 push    0FFFFFFFFh
.text$mn:000029D1                 push    offset __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:000029D6                 mov     eax, large fs:0
.text$mn:000029DC                 push    eax
.text$mn:000029DD                 sub     esp, 8
.text$mn:000029E0                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000029E5                 xor     eax, ebp
.text$mn:000029E7                 push    eax
.text$mn:000029E8                 lea     eax, [ebp+var_C]
.text$mn:000029EB                 mov     large fs:0, eax
.text$mn:000029F1                 mov     [ebp+var_14], ecx
.text$mn:000029F4                 mov     [ebp+var_10], 0
.text$mn:000029FB                 cmp     [ebp+arg_4], 1
.text$mn:000029FF                 jnz     short loc_2A25
.text$mn:00002A01                 push    offset ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ ; "iostream stream error"
.text$mn:00002A06                 mov     ecx, [ebp+arg_0]
.text$mn:00002A09                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:00002A0E                 mov     [ebp+var_4], 0
.text$mn:00002A15                 mov     eax, [ebp+var_10]
.text$mn:00002A18                 or      eax, 1
.text$mn:00002A1B                 mov     [ebp+var_10], eax
.text$mn:00002A1E                 mov     eax, [ebp+arg_0]
.text$mn:00002A21                 jmp     short loc_2A48
.text$mn:00002A23 ; ---------------------------------------------------------------------------
.text$mn:00002A23                 jmp     short loc_2A48
.text$mn:00002A25 ; ---------------------------------------------------------------------------
.text$mn:00002A25
.text$mn:00002A25 loc_2A25:                               ; CODE XREF: std::_Iostream_error_category::message(int)+33j
.text$mn:00002A25                 mov     ecx, [ebp+arg_4]
.text$mn:00002A28                 push    ecx
.text$mn:00002A29                 mov     edx, [ebp+arg_0]
.text$mn:00002A2C                 push    edx
.text$mn:00002A2D                 mov     ecx, [ebp+var_14]
.text$mn:00002A30                 call    ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
.text$mn:00002A35                 mov     [ebp+var_4], 0
.text$mn:00002A3C                 mov     eax, [ebp+var_10]
.text$mn:00002A3F                 or      eax, 1
.text$mn:00002A42                 mov     [ebp+var_10], eax
.text$mn:00002A45                 mov     eax, [ebp+arg_0]
.text$mn:00002A48
.text$mn:00002A48 loc_2A48:                               ; CODE XREF: std::_Iostream_error_category::message(int)+55j
.text$mn:00002A48                                         ; std::_Iostream_error_category::message(int)+57j
.text$mn:00002A48                 mov     ecx, [ebp+var_C]
.text$mn:00002A4B                 mov     large fs:0, ecx
.text$mn:00002A52                 pop     ecx
.text$mn:00002A53                 mov     esp, ebp
.text$mn:00002A55                 pop     ebp
.text$mn:00002A56                 retn    8
.text$mn:00002A56 ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:00002A56
.text$mn:00002A56 ; ---------------------------------------------------------------------------
.text$mn:00002A59                 align 4
.text$mn:00002A59 _text$mn        ends
.text$mn:00002A59
.text$x:00002A5C ; ===========================================================================
.text$x:00002A5C
.text$x:00002A5C ; Segment type: Pure code
.text$x:00002A5C ; Segment permissions: Read/Execute
.text$x:00002A5C _text$x         segment para public 'CODE' use32
.text$x:00002A5C                 assume cs:_text$x
.text$x:00002A5C                 ;org 2A5Ch
.text$x:00002A5C ; COMDAT (pick associative to section at 29CC)
.text$x:00002A5C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00002A5C
.text$x:00002A5C ; =============== S U B R O U T I N E =======================================
.text$x:00002A5C
.text$x:00002A5C
.text$x:00002A5C __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:00002A5C                                         ; DATA XREF: .xdata$x:00002EA4o
.text$x:00002A5C                 mov     eax, [ebp-10h]
.text$x:00002A5F                 and     eax, 1
.text$x:00002A62                 jz      $LN6_0
.text$x:00002A68                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:00002A6C                 mov     ecx, [ebp+8]
.text$x:00002A6F                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00002A74 ; ---------------------------------------------------------------------------
.text$x:00002A74
.text$x:00002A74 $LN6_0:                                 ; CODE XREF: __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:00002A74                 retn
.text$x:00002A74 __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:00002A74
.text$x:00002A75
.text$x:00002A75 ; =============== S U B R O U T I N E =======================================
.text$x:00002A75
.text$x:00002A75
.text$x:00002A75 __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:00002A75                                         ; DATA XREF: std::_Iostream_error_category::message(int)+5o
.text$x:00002A75
.text$x:00002A75 arg_4           = dword ptr  8
.text$x:00002A75
.text$x:00002A75                 mov     edx, [esp+arg_4]
.text$x:00002A79                 lea     eax, [edx+0Ch]
.text$x:00002A7C                 mov     ecx, [edx-0Ch]
.text$x:00002A7F                 xor     ecx, eax
.text$x:00002A81                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002A86                 mov     eax, offset __ehfuncinfo$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:00002A8B                 jmp     ___CxxFrameHandler3
.text$x:00002A8B __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:00002A8B
.text$x:00002A8B _text$x         ends
.text$x:00002A8B
.text$mn:00002A90 ; ===========================================================================
.text$mn:00002A90
.text$mn:00002A90 ; Segment type: Pure code
.text$mn:00002A90 ; Segment permissions: Read/Execute
.text$mn:00002A90 _text$mn        segment para public 'CODE' use32
.text$mn:00002A90                 assume cs:_text$mn
.text$mn:00002A90                 ;org 2A90h
.text$mn:00002A90 ; COMDAT (pick any)
.text$mn:00002A90                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002A90
.text$mn:00002A90 ; =============== S U B R O U T I N E =======================================
.text$mn:00002A90
.text$mn:00002A90 ; Attributes: bp-based frame
.text$mn:00002A90
.text$mn:00002A90 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_System_error_category::message(int)const
.text$mn:00002A90                 public ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00002A90 ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:00002A90                                         ; DATA XREF: .rdata:00003074o
.text$mn:00002A90
.text$mn:00002A90 var_1C          = dword ptr -1Ch
.text$mn:00002A90 var_18          = dword ptr -18h
.text$mn:00002A90 Str             = dword ptr -14h
.text$mn:00002A90 var_10          = dword ptr -10h
.text$mn:00002A90 var_C           = dword ptr -0Ch
.text$mn:00002A90 var_4           = dword ptr -4
.text$mn:00002A90 arg_0           = dword ptr  8
.text$mn:00002A90 arg_4           = dword ptr  0Ch
.text$mn:00002A90
.text$mn:00002A90                 push    ebp
.text$mn:00002A91                 mov     ebp, esp
.text$mn:00002A93                 push    0FFFFFFFFh
.text$mn:00002A95                 push    offset __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00002A9A                 mov     eax, large fs:0
.text$mn:00002AA0                 push    eax
.text$mn:00002AA1                 sub     esp, 10h
.text$mn:00002AA4                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002AA9                 xor     eax, ebp
.text$mn:00002AAB                 push    eax
.text$mn:00002AAC                 lea     eax, [ebp+var_C]
.text$mn:00002AAF                 mov     large fs:0, eax
.text$mn:00002AB5                 mov     [ebp+var_1C], ecx
.text$mn:00002AB8                 mov     [ebp+var_18], 0
.text$mn:00002ABF                 mov     eax, [ebp+arg_4]
.text$mn:00002AC2                 push    eax             ; int
.text$mn:00002AC3                 call    ?_Winerror_map@std@@YAPBDH@Z ; std::_Winerror_map(int)
.text$mn:00002AC8                 add     esp, 4
.text$mn:00002ACB                 mov     [ebp+var_10], eax
.text$mn:00002ACE                 cmp     [ebp+var_10], 0
.text$mn:00002AD2                 jz      short loc_2ADC
.text$mn:00002AD4                 mov     ecx, [ebp+var_10]
.text$mn:00002AD7                 mov     [ebp+Str], ecx
.text$mn:00002ADA                 jmp     short loc_2AE3
.text$mn:00002ADC ; ---------------------------------------------------------------------------
.text$mn:00002ADC
.text$mn:00002ADC loc_2ADC:                               ; CODE XREF: std::_System_error_category::message(int)+42j
.text$mn:00002ADC                 mov     [ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ ; "unknown error"
.text$mn:00002AE3
.text$mn:00002AE3 loc_2AE3:                               ; CODE XREF: std::_System_error_category::message(int)+4Aj
.text$mn:00002AE3                 mov     edx, [ebp+Str]
.text$mn:00002AE6                 push    edx             ; Str
.text$mn:00002AE7                 mov     ecx, [ebp+arg_0]
.text$mn:00002AEA                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:00002AEF                 mov     [ebp+var_4], 0
.text$mn:00002AF6                 mov     eax, [ebp+var_18]
.text$mn:00002AF9                 or      eax, 1
.text$mn:00002AFC                 mov     [ebp+var_18], eax
.text$mn:00002AFF                 mov     eax, [ebp+arg_0]
.text$mn:00002B02                 mov     ecx, [ebp+var_C]
.text$mn:00002B05                 mov     large fs:0, ecx
.text$mn:00002B0C                 pop     ecx
.text$mn:00002B0D                 mov     esp, ebp
.text$mn:00002B0F                 pop     ebp
.text$mn:00002B10                 retn    8
.text$mn:00002B10 ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:00002B10
.text$mn:00002B10 ; ---------------------------------------------------------------------------
.text$mn:00002B13                 align 4
.text$mn:00002B13 _text$mn        ends
.text$mn:00002B13
.text$x:00002B14 ; ===========================================================================
.text$x:00002B14
.text$x:00002B14 ; Segment type: Pure code
.text$x:00002B14 ; Segment permissions: Read/Execute
.text$x:00002B14 _text$x         segment para public 'CODE' use32
.text$x:00002B14                 assume cs:_text$x
.text$x:00002B14                 ;org 2B14h
.text$x:00002B14 ; COMDAT (pick associative to section at 2A90)
.text$x:00002B14                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00002B14
.text$x:00002B14 ; =============== S U B R O U T I N E =======================================
.text$x:00002B14
.text$x:00002B14
.text$x:00002B14 __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:00002B14                                         ; DATA XREF: .xdata$x:00002F28o
.text$x:00002B14                 mov     eax, [ebp-18h]
.text$x:00002B17                 and     eax, 1
.text$x:00002B1A                 jz      $LN6_1
.text$x:00002B20                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:00002B24                 mov     ecx, [ebp+8]
.text$x:00002B27                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00002B2C ; ---------------------------------------------------------------------------
.text$x:00002B2C
.text$x:00002B2C $LN6_1:                                 ; CODE XREF: __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:00002B2C                 retn
.text$x:00002B2C __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:00002B2C
.text$x:00002B2D
.text$x:00002B2D ; =============== S U B R O U T I N E =======================================
.text$x:00002B2D
.text$x:00002B2D
.text$x:00002B2D __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:00002B2D                                         ; DATA XREF: std::_System_error_category::message(int)+5o
.text$x:00002B2D
.text$x:00002B2D arg_4           = dword ptr  8
.text$x:00002B2D
.text$x:00002B2D                 mov     edx, [esp+arg_4]
.text$x:00002B31                 lea     eax, [edx+0Ch]
.text$x:00002B34                 mov     ecx, [edx-14h]
.text$x:00002B37                 xor     ecx, eax
.text$x:00002B39                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002B3E                 mov     eax, offset __ehfuncinfo$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:00002B43                 jmp     ___CxxFrameHandler3
.text$x:00002B43 __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:00002B43
.text$x:00002B43 _text$x         ends
.text$x:00002B43
.text$mn:00002B48 ; ===========================================================================
.text$mn:00002B48
.text$mn:00002B48 ; Segment type: Pure code
.text$mn:00002B48 ; Segment permissions: Read/Execute
.text$mn:00002B48 _text$mn        segment para public 'CODE' use32
.text$mn:00002B48                 assume cs:_text$mn
.text$mn:00002B48                 ;org 2B48h
.text$mn:00002B48 ; COMDAT (pick any)
.text$mn:00002B48                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002B48
.text$mn:00002B48 ; =============== S U B R O U T I N E =======================================
.text$mn:00002B48
.text$mn:00002B48 ; Attributes: bp-based frame
.text$mn:00002B48
.text$mn:00002B48 ; int __cdecl std::char_traits<char>::move(void *Dst, void *Src, size_t Size)
.text$mn:00002B48                 public ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
.text$mn:00002B48 ?move@?$char_traits@D@std@@SAPADPADPBDI@Z proc near
.text$mn:00002B48                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+6Ap
.text$mn:00002B48
.text$mn:00002B48 var_4           = dword ptr -4
.text$mn:00002B48 Dst             = dword ptr  8
.text$mn:00002B48 Src             = dword ptr  0Ch
.text$mn:00002B48 Size            = dword ptr  10h
.text$mn:00002B48
.text$mn:00002B48                 push    ebp
.text$mn:00002B49                 mov     ebp, esp
.text$mn:00002B4B                 push    ecx
.text$mn:00002B4C                 cmp     [ebp+Size], 0
.text$mn:00002B50                 jnz     short loc_2B5A
.text$mn:00002B52                 mov     eax, [ebp+Dst]
.text$mn:00002B55                 mov     [ebp+var_4], eax
.text$mn:00002B58                 jmp     short loc_2B71
.text$mn:00002B5A ; ---------------------------------------------------------------------------
.text$mn:00002B5A
.text$mn:00002B5A loc_2B5A:                               ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+8j
.text$mn:00002B5A                 mov     ecx, [ebp+Size]
.text$mn:00002B5D                 push    ecx             ; Size
.text$mn:00002B5E                 mov     edx, [ebp+Src]
.text$mn:00002B61                 push    edx             ; Src
.text$mn:00002B62                 mov     eax, [ebp+Dst]
.text$mn:00002B65                 push    eax             ; Dst
.text$mn:00002B66                 call    _memmove
.text$mn:00002B6B                 add     esp, 0Ch
.text$mn:00002B6E                 mov     [ebp+var_4], eax
.text$mn:00002B71
.text$mn:00002B71 loc_2B71:                               ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+10j
.text$mn:00002B71                 mov     eax, [ebp+var_4]
.text$mn:00002B74                 mov     esp, ebp
.text$mn:00002B76                 pop     ebp
.text$mn:00002B77                 retn
.text$mn:00002B77 ?move@?$char_traits@D@std@@SAPADPADPBDI@Z endp
.text$mn:00002B77
.text$mn:00002B77 _text$mn        ends
.text$mn:00002B77
.text$mn:00002B78 ; ===========================================================================
.text$mn:00002B78
.text$mn:00002B78 ; Segment type: Pure code
.text$mn:00002B78 ; Segment permissions: Read/Execute
.text$mn:00002B78 _text$mn        segment para public 'CODE' use32
.text$mn:00002B78                 assume cs:_text$mn
.text$mn:00002B78                 ;org 2B78h
.text$mn:00002B78 ; COMDAT (pick any)
.text$mn:00002B78                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002B78
.text$mn:00002B78 ; =============== S U B R O U T I N E =======================================
.text$mn:00002B78
.text$mn:00002B78 ; Attributes: bp-based frame
.text$mn:00002B78
.text$mn:00002B78 ; const char *__thiscall std::_Generic_error_category::name(std::_Generic_error_category *__hidden this)
.text$mn:00002B78                 public ?name@_Generic_error_category@std@@UBEPBDXZ
.text$mn:00002B78 ?name@_Generic_error_category@std@@UBEPBDXZ proc near
.text$mn:00002B78                                         ; DATA XREF: .rdata:00002FFCo
.text$mn:00002B78
.text$mn:00002B78 var_4           = dword ptr -4
.text$mn:00002B78
.text$mn:00002B78                 push    ebp
.text$mn:00002B79                 mov     ebp, esp
.text$mn:00002B7B                 push    ecx
.text$mn:00002B7C                 mov     [ebp+var_4], ecx
.text$mn:00002B7F                 mov     eax, offset ??_C@_07DCLBNMLN@generic?$AA@ ; "generic"
.text$mn:00002B84                 mov     esp, ebp
.text$mn:00002B86                 pop     ebp
.text$mn:00002B87                 retn
.text$mn:00002B87 ?name@_Generic_error_category@std@@UBEPBDXZ endp
.text$mn:00002B87
.text$mn:00002B87 _text$mn        ends
.text$mn:00002B87
.text$mn:00002B88 ; ===========================================================================
.text$mn:00002B88
.text$mn:00002B88 ; Segment type: Pure code
.text$mn:00002B88 ; Segment permissions: Read/Execute
.text$mn:00002B88 _text$mn        segment para public 'CODE' use32
.text$mn:00002B88                 assume cs:_text$mn
.text$mn:00002B88                 ;org 2B88h
.text$mn:00002B88 ; COMDAT (pick any)
.text$mn:00002B88                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002B88
.text$mn:00002B88 ; =============== S U B R O U T I N E =======================================
.text$mn:00002B88
.text$mn:00002B88 ; Attributes: bp-based frame
.text$mn:00002B88
.text$mn:00002B88 ; const char *__thiscall std::_Iostream_error_category::name(std::_Iostream_error_category *__hidden this)
.text$mn:00002B88                 public ?name@_Iostream_error_category@std@@UBEPBDXZ
.text$mn:00002B88 ?name@_Iostream_error_category@std@@UBEPBDXZ proc near
.text$mn:00002B88                                         ; DATA XREF: .rdata:00003030o
.text$mn:00002B88
.text$mn:00002B88 var_4           = dword ptr -4
.text$mn:00002B88
.text$mn:00002B88                 push    ebp
.text$mn:00002B89                 mov     ebp, esp
.text$mn:00002B8B                 push    ecx
.text$mn:00002B8C                 mov     [ebp+var_4], ecx
.text$mn:00002B8F                 mov     eax, offset ??_C@_08LLGCOLLL@iostream?$AA@ ; "iostream"
.text$mn:00002B94                 mov     esp, ebp
.text$mn:00002B96                 pop     ebp
.text$mn:00002B97                 retn
.text$mn:00002B97 ?name@_Iostream_error_category@std@@UBEPBDXZ endp
.text$mn:00002B97
.text$mn:00002B97 _text$mn        ends
.text$mn:00002B97
.text$mn:00002B98 ; ===========================================================================
.text$mn:00002B98
.text$mn:00002B98 ; Segment type: Pure code
.text$mn:00002B98 ; Segment permissions: Read/Execute
.text$mn:00002B98 _text$mn        segment para public 'CODE' use32
.text$mn:00002B98                 assume cs:_text$mn
.text$mn:00002B98                 ;org 2B98h
.text$mn:00002B98 ; COMDAT (pick any)
.text$mn:00002B98                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002B98
.text$mn:00002B98 ; =============== S U B R O U T I N E =======================================
.text$mn:00002B98
.text$mn:00002B98 ; Attributes: bp-based frame
.text$mn:00002B98
.text$mn:00002B98 ; const char *__thiscall std::_System_error_category::name(std::_System_error_category *__hidden this)
.text$mn:00002B98                 public ?name@_System_error_category@std@@UBEPBDXZ
.text$mn:00002B98 ?name@_System_error_category@std@@UBEPBDXZ proc near
.text$mn:00002B98                                         ; DATA XREF: .rdata:00003070o
.text$mn:00002B98
.text$mn:00002B98 var_4           = dword ptr -4
.text$mn:00002B98
.text$mn:00002B98                 push    ebp
.text$mn:00002B99                 mov     ebp, esp
.text$mn:00002B9B                 push    ecx
.text$mn:00002B9C                 mov     [ebp+var_4], ecx
.text$mn:00002B9F                 mov     eax, offset ??_C@_06FHFOAHML@system?$AA@ ; "system"
.text$mn:00002BA4                 mov     esp, ebp
.text$mn:00002BA6                 pop     ebp
.text$mn:00002BA7                 retn
.text$mn:00002BA7 ?name@_System_error_category@std@@UBEPBDXZ endp
.text$mn:00002BA7
.text$mn:00002BA7 _text$mn        ends
.text$mn:00002BA7
.text$mn:00002BA8 ; ===========================================================================
.text$mn:00002BA8
.text$mn:00002BA8 ; Segment type: Pure code
.text$mn:00002BA8 ; Segment permissions: Read/Execute
.text$mn:00002BA8 _text$mn        segment para public 'CODE' use32
.text$mn:00002BA8                 assume cs:_text$mn
.text$mn:00002BA8                 ;org 2BA8h
.text$mn:00002BA8 ; COMDAT (pick any)
.text$mn:00002BA8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002BA8
.text$mn:00002BA8 ; =============== S U B R O U T I N E =======================================
.text$mn:00002BA8
.text$mn:00002BA8 ; Attributes: bp-based frame
.text$mn:00002BA8
.text$mn:00002BA8 ; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::size(void)const
.text$mn:00002BA8                 public ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
.text$mn:00002BA8 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
.text$mn:00002BA8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+Cp
.text$mn:00002BA8                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+21p
.text$mn:00002BA8
.text$mn:00002BA8 var_4           = dword ptr -4
.text$mn:00002BA8
.text$mn:00002BA8                 push    ebp
.text$mn:00002BA9                 mov     ebp, esp
.text$mn:00002BAB                 push    ecx
.text$mn:00002BAC                 mov     [ebp+var_4], ecx
.text$mn:00002BAF                 mov     eax, [ebp+var_4]
.text$mn:00002BB2                 mov     eax, [eax+14h]
.text$mn:00002BB5                 mov     esp, ebp
.text$mn:00002BB7                 pop     ebp
.text$mn:00002BB8                 retn
.text$mn:00002BB8 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp
.text$mn:00002BB8
.text$mn:00002BB8 ; ---------------------------------------------------------------------------
.text$mn:00002BB9                 align 4
.text$mn:00002BB9 _text$mn        ends
.text$mn:00002BB9
.text$mn:00002BBC ; ===========================================================================
.text$mn:00002BBC
.text$mn:00002BBC ; Segment type: Pure code
.text$mn:00002BBC ; Segment permissions: Read/Execute
.text$mn:00002BBC _text$mn        segment para public 'CODE' use32
.text$mn:00002BBC                 assume cs:_text$mn
.text$mn:00002BBC                 ;org 2BBCh
.text$mn:00002BBC ; COMDAT (pick any)
.text$mn:00002BBC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002BBC
.text$mn:00002BBC ; =============== S U B R O U T I N E =======================================
.text$mn:00002BBC
.text$mn:00002BBC ; Attributes: bp-based frame
.text$mn:00002BBC
.text$mn:00002BBC ; public: unsigned int __thiscall std::vector<class MacroShortcut, class std::allocator<class MacroShortcut>>::size(void)const
.text$mn:00002BBC                 public ?size@?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@QBEIXZ
.text$mn:00002BBC ?size@?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@QBEIXZ proc near
.text$mn:00002BBC                                         ; CODE XREF: RunMacroDlg::initMacroList(void)+93p
.text$mn:00002BBC                                         ; std::vector<MacroShortcut,std::allocator<MacroShortcut>>::operator[](uint)+Ap
.text$mn:00002BBC
.text$mn:00002BBC var_4           = dword ptr -4
.text$mn:00002BBC
.text$mn:00002BBC                 push    ebp
.text$mn:00002BBD                 mov     ebp, esp
.text$mn:00002BBF                 push    ecx
.text$mn:00002BC0                 mov     [ebp+var_4], ecx
.text$mn:00002BC3                 mov     eax, [ebp+var_4]
.text$mn:00002BC6                 mov     ecx, [ebp+var_4]
.text$mn:00002BC9                 mov     eax, [eax+8]
.text$mn:00002BCC                 sub     eax, [ecx+4]
.text$mn:00002BCF                 cdq
.text$mn:00002BD0                 mov     ecx, 13Ch
.text$mn:00002BD5                 idiv    ecx
.text$mn:00002BD7                 mov     esp, ebp
.text$mn:00002BD9                 pop     ebp
.text$mn:00002BDA                 retn
.text$mn:00002BDA ?size@?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@QBEIXZ endp
.text$mn:00002BDA
.text$mn:00002BDA ; ---------------------------------------------------------------------------
.text$mn:00002BDB                 align 4
.text$mn:00002BDB _text$mn        ends
.text$mn:00002BDB
.text$mn:00002BDC ; ===========================================================================
.text$mn:00002BDC
.text$mn:00002BDC ; Segment type: Pure code
.text$mn:00002BDC ; Segment permissions: Read/Execute
.text$mn:00002BDC _text$mn        segment para public 'CODE' use32
.text$mn:00002BDC                 assume cs:_text$mn
.text$mn:00002BDC                 ;org 2BDCh
.text$mn:00002BDC ; COMDAT (pick any)
.text$mn:00002BDC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002BDC
.text$mn:00002BDC ; =============== S U B R O U T I N E =======================================
.text$mn:00002BDC
.text$mn:00002BDC ; Attributes: bp-based frame
.text$mn:00002BDC
.text$mn:00002BDC ; const struct std::error_category *__cdecl std::system_category()
.text$mn:00002BDC                 public ?system_category@std@@YAABVerror_category@1@XZ
.text$mn:00002BDC ?system_category@std@@YAABVerror_category@1@XZ proc near
.text$mn:00002BDC                                         ; CODE XREF: std::_System_error_category::default_error_condition(int):loc_2678p
.text$mn:00002BDC                 push    ebp
.text$mn:00002BDD                 mov     ebp, esp
.text$mn:00002BDF                 mov     eax, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_System_error_category std::_Error_objects<int>::_System_object
.text$mn:00002BE4                 pop     ebp
.text$mn:00002BE5                 retn
.text$mn:00002BE5 ?system_category@std@@YAABVerror_category@1@XZ endp
.text$mn:00002BE5
.text$mn:00002BE5 ; ---------------------------------------------------------------------------
.text$mn:00002BE6                 align 4
.text$mn:00002BE6 _text$mn        ends
.text$mn:00002BE6
.text$mn:00002BE8 ; ===========================================================================
.text$mn:00002BE8
.text$mn:00002BE8 ; Segment type: Pure code
.text$mn:00002BE8 ; Segment permissions: Read/Execute
.text$mn:00002BE8 _text$mn        segment para public 'CODE' use32
.text$mn:00002BE8                 assume cs:_text$mn
.text$mn:00002BE8                 ;org 2BE8h
.text$mn:00002BE8 ; COMDAT (pick any)
.text$mn:00002BE8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002BE8
.text$mn:00002BE8 ; =============== S U B R O U T I N E =======================================
.text$mn:00002BE8
.text$mn:00002BE8 ; Attributes: bp-based frame
.text$mn:00002BE8
.text$mn:00002BE8 ; int __thiscall std::error_code::value(std::error_code *__hidden this)
.text$mn:00002BE8                 public ?value@error_code@std@@QBEHXZ
.text$mn:00002BE8 ?value@error_code@std@@QBEHXZ proc near ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+24p
.text$mn:00002BE8
.text$mn:00002BE8 var_4           = dword ptr -4
.text$mn:00002BE8
.text$mn:00002BE8                 push    ebp
.text$mn:00002BE9                 mov     ebp, esp
.text$mn:00002BEB                 push    ecx
.text$mn:00002BEC                 mov     [ebp+var_4], ecx
.text$mn:00002BEF                 mov     eax, [ebp+var_4]
.text$mn:00002BF2                 mov     eax, [eax]
.text$mn:00002BF4                 mov     esp, ebp
.text$mn:00002BF6                 pop     ebp
.text$mn:00002BF7                 retn
.text$mn:00002BF7 ?value@error_code@std@@QBEHXZ endp
.text$mn:00002BF7
.text$mn:00002BF7 _text$mn        ends
.text$mn:00002BF7
.text$mn:00002BF8 ; ===========================================================================
.text$mn:00002BF8
.text$mn:00002BF8 ; Segment type: Pure code
.text$mn:00002BF8 ; Segment permissions: Read/Execute
.text$mn:00002BF8 _text$mn        segment para public 'CODE' use32
.text$mn:00002BF8                 assume cs:_text$mn
.text$mn:00002BF8                 ;org 2BF8h
.text$mn:00002BF8 ; COMDAT (pick any)
.text$mn:00002BF8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002BF8
.text$mn:00002BF8 ; =============== S U B R O U T I N E =======================================
.text$mn:00002BF8
.text$mn:00002BF8 ; Attributes: bp-based frame
.text$mn:00002BF8
.text$mn:00002BF8 ; int __thiscall std::error_condition::value(std::error_condition *__hidden this)
.text$mn:00002BF8                 public ?value@error_condition@std@@QBEHXZ
.text$mn:00002BF8 ?value@error_condition@std@@QBEHXZ proc near
.text$mn:00002BF8                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+2Cp
.text$mn:00002BF8                                         ; std::error_condition::operator==(std::error_condition const &)+36p
.text$mn:00002BF8
.text$mn:00002BF8 var_4           = dword ptr -4
.text$mn:00002BF8
.text$mn:00002BF8                 push    ebp
.text$mn:00002BF9                 mov     ebp, esp
.text$mn:00002BFB                 push    ecx
.text$mn:00002BFC                 mov     [ebp+var_4], ecx
.text$mn:00002BFF                 mov     eax, [ebp+var_4]
.text$mn:00002C02                 mov     eax, [eax]
.text$mn:00002C04                 mov     esp, ebp
.text$mn:00002C06                 pop     ebp
.text$mn:00002C07                 retn
.text$mn:00002C07 ?value@error_condition@std@@QBEHXZ endp
.text$mn:00002C07
.text$mn:00002C07 _text$mn        ends
.text$mn:00002C07
.text$mn:00002C08 ; ===========================================================================
.text$mn:00002C08
.text$mn:00002C08 ; Segment type: Pure code
.text$mn:00002C08 ; Segment permissions: Read/Execute
.text$mn:00002C08 _text$mn        segment para public 'CODE' use32
.text$mn:00002C08                 assume cs:_text$mn
.text$mn:00002C08                 ;org 2C08h
.text$mn:00002C08 ; COMDAT (pick any)
.text$mn:00002C08                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002C08
.text$mn:00002C08 ; =============== S U B R O U T I N E =======================================
.text$mn:00002C08
.text$mn:00002C08 ; Attributes: bp-based frame
.text$mn:00002C08
.text$mn:00002C08                 public _hypot
.text$mn:00002C08 _hypot          proc near
.text$mn:00002C08
.text$mn:00002C08 var_10          = qword ptr -10h
.text$mn:00002C08 var_8           = qword ptr -8
.text$mn:00002C08 arg_0           = qword ptr  8
.text$mn:00002C08 arg_8           = qword ptr  10h
.text$mn:00002C08
.text$mn:00002C08                 push    ebp
.text$mn:00002C09                 mov     ebp, esp
.text$mn:00002C0B                 sub     esp, 8
.text$mn:00002C0E                 movsd   xmm0, [ebp+arg_8]
.text$mn:00002C13                 movsd   [esp+8+var_8], xmm0
.text$mn:00002C18                 sub     esp, 8
.text$mn:00002C1B                 movsd   xmm0, [ebp+arg_0]
.text$mn:00002C20                 movsd   [esp+10h+var_10], xmm0
.text$mn:00002C25                 call    __hypot
.text$mn:00002C2A                 add     esp, 10h
.text$mn:00002C2D                 pop     ebp
.text$mn:00002C2E                 retn
.text$mn:00002C2E _hypot          endp
.text$mn:00002C2E
.text$mn:00002C2E ; ---------------------------------------------------------------------------
.text$mn:00002C2F                 align 10h
.text$mn:00002C2F _text$mn        ends
.text$mn:00002C2F
.xdata$x:00002C30 ; ===========================================================================
.xdata$x:00002C30
.xdata$x:00002C30 ; Segment type: Pure data
.xdata$x:00002C30 ; Segment permissions: Read
.xdata$x:00002C30 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002C30                 assume cs:_xdata$x
.xdata$x:00002C30                 ;org 2C30h
.xdata$x:00002C30 ; COMDAT (pick associative to section at 221C)
.xdata$x:00002C30 __unwindtable$?_Orphan_all@_Container_base12@std@@QAEXXZ db 0FFh
.xdata$x:00002C30                                         ; DATA XREF: .xdata$x:00002C40o
.xdata$x:00002C31                 db 0FFh
.xdata$x:00002C32                 db 0FFh
.xdata$x:00002C33                 db 0FFh
.xdata$x:00002C34                 dd offset __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0
.xdata$x:00002C38 __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ db  22h ; "
.xdata$x:00002C38                                         ; DATA XREF: __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ+11o
.xdata$x:00002C39                 db    5
.xdata$x:00002C3A                 db  93h ; ô
.xdata$x:00002C3B                 db  19h
.xdata$x:00002C3C                 db    1
.xdata$x:00002C3D                 db    0
.xdata$x:00002C3E                 db    0
.xdata$x:00002C3F                 db    0
.xdata$x:00002C40                 dd offset __unwindtable$?_Orphan_all@_Container_base12@std@@QAEXXZ
.xdata$x:00002C44                 db    0
.xdata$x:00002C45                 db    0
.xdata$x:00002C46                 db    0
.xdata$x:00002C47                 db    0
.xdata$x:00002C48                 db    0
.xdata$x:00002C49                 db    0
.xdata$x:00002C4A                 db    0
.xdata$x:00002C4B                 db    0
.xdata$x:00002C4C                 db    0
.xdata$x:00002C4D                 db    0
.xdata$x:00002C4E                 db    0
.xdata$x:00002C4F                 db    0
.xdata$x:00002C50                 db    0
.xdata$x:00002C51                 db    0
.xdata$x:00002C52                 db    0
.xdata$x:00002C53                 db    0
.xdata$x:00002C54                 db    0
.xdata$x:00002C55                 db    0
.xdata$x:00002C56                 db    0
.xdata$x:00002C57                 db    0
.xdata$x:00002C58                 db    0
.xdata$x:00002C59                 db    0
.xdata$x:00002C5A                 db    0
.xdata$x:00002C5B                 db    0
.xdata$x:00002C5B _xdata$x        ends
.xdata$x:00002C5B
.xdata$x:00002C5C ; ===========================================================================
.xdata$x:00002C5C
.xdata$x:00002C5C ; Segment type: Pure data
.xdata$x:00002C5C ; Segment permissions: Read
.xdata$x:00002C5C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002C5C                 assume cs:_xdata$x
.xdata$x:00002C5C                 ;org 2C5Ch
.xdata$x:00002C5C ; COMDAT (pick associative to section at 14FC)
.xdata$x:00002C5C __unwindtable$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00002C5C                                         ; DATA XREF: .xdata$x:00002C6Co
.xdata$x:00002C5D                 db 0FFh
.xdata$x:00002C5E                 db 0FFh
.xdata$x:00002C5F                 db 0FFh
.xdata$x:00002C60                 dd offset __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
.xdata$x:00002C64 __ehfuncinfo$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00002C64                                         ; DATA XREF: __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ+11o
.xdata$x:00002C65                 db    5
.xdata$x:00002C66                 db  93h ; ô
.xdata$x:00002C67                 db  19h
.xdata$x:00002C68                 db    1
.xdata$x:00002C69                 db    0
.xdata$x:00002C6A                 db    0
.xdata$x:00002C6B                 db    0
.xdata$x:00002C6C                 dd offset __unwindtable$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.xdata$x:00002C70                 db    0
.xdata$x:00002C71                 db    0
.xdata$x:00002C72                 db    0
.xdata$x:00002C73                 db    0
.xdata$x:00002C74                 db    0
.xdata$x:00002C75                 db    0
.xdata$x:00002C76                 db    0
.xdata$x:00002C77                 db    0
.xdata$x:00002C78                 db    0
.xdata$x:00002C79                 db    0
.xdata$x:00002C7A                 db    0
.xdata$x:00002C7B                 db    0
.xdata$x:00002C7C                 db    0
.xdata$x:00002C7D                 db    0
.xdata$x:00002C7E                 db    0
.xdata$x:00002C7F                 db    0
.xdata$x:00002C80                 db    0
.xdata$x:00002C81                 db    0
.xdata$x:00002C82                 db    0
.xdata$x:00002C83                 db    0
.xdata$x:00002C84                 db    0
.xdata$x:00002C85                 db    0
.xdata$x:00002C86                 db    0
.xdata$x:00002C87                 db    0
.xdata$x:00002C87 _xdata$x        ends
.xdata$x:00002C87
.xdata$x:00002C88 ; ===========================================================================
.xdata$x:00002C88
.xdata$x:00002C88 ; Segment type: Pure data
.xdata$x:00002C88 ; Segment permissions: Read
.xdata$x:00002C88 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002C88                 assume cs:_xdata$x
.xdata$x:00002C88                 ;org 2C88h
.xdata$x:00002C88 ; COMDAT (pick associative to section at 18E0)
.xdata$x:00002C88 __unwindtable$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00002C88                                         ; DATA XREF: .xdata$x:00002C98o
.xdata$x:00002C89                 db 0FFh
.xdata$x:00002C8A                 db 0FFh
.xdata$x:00002C8B                 db 0FFh
.xdata$x:00002C8C                 dd offset __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
.xdata$x:00002C90 __ehfuncinfo$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00002C90                                         ; DATA XREF: __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ+11o
.xdata$x:00002C91                 db    5
.xdata$x:00002C92                 db  93h ; ô
.xdata$x:00002C93                 db  19h
.xdata$x:00002C94                 db    1
.xdata$x:00002C95                 db    0
.xdata$x:00002C96                 db    0
.xdata$x:00002C97                 db    0
.xdata$x:00002C98                 dd offset __unwindtable$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.xdata$x:00002C9C                 db    0
.xdata$x:00002C9D                 db    0
.xdata$x:00002C9E                 db    0
.xdata$x:00002C9F                 db    0
.xdata$x:00002CA0                 db    0
.xdata$x:00002CA1                 db    0
.xdata$x:00002CA2                 db    0
.xdata$x:00002CA3                 db    0
.xdata$x:00002CA4                 db    0
.xdata$x:00002CA5                 db    0
.xdata$x:00002CA6                 db    0
.xdata$x:00002CA7                 db    0
.xdata$x:00002CA8                 db    0
.xdata$x:00002CA9                 db    0
.xdata$x:00002CAA                 db    0
.xdata$x:00002CAB                 db    0
.xdata$x:00002CAC                 db    0
.xdata$x:00002CAD                 db    0
.xdata$x:00002CAE                 db    0
.xdata$x:00002CAF                 db    0
.xdata$x:00002CB0                 db    0
.xdata$x:00002CB1                 db    0
.xdata$x:00002CB2                 db    0
.xdata$x:00002CB3                 db    0
.xdata$x:00002CB3 _xdata$x        ends
.xdata$x:00002CB3
.xdata$x:00002CB4 ; ===========================================================================
.xdata$x:00002CB4
.xdata$x:00002CB4 ; Segment type: Pure data
.xdata$x:00002CB4 ; Segment permissions: Read
.xdata$x:00002CB4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002CB4                 assume cs:_xdata$x
.xdata$x:00002CB4                 ;org 2CB4h
.xdata$x:00002CB4 ; COMDAT (pick associative to section at 1480)
.xdata$x:00002CB4 __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z db 0FFh
.xdata$x:00002CB4                                         ; DATA XREF: .xdata$x:00002CC4o
.xdata$x:00002CB5                 db 0FFh
.xdata$x:00002CB6                 db 0FFh
.xdata$x:00002CB7                 db 0FFh
.xdata$x:00002CB8                 dd offset __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0
.xdata$x:00002CBC __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z db  22h ; "
.xdata$x:00002CBC                                         ; DATA XREF: __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z+11o
.xdata$x:00002CBD                 db    5
.xdata$x:00002CBE                 db  93h ; ô
.xdata$x:00002CBF                 db  19h
.xdata$x:00002CC0                 db    1
.xdata$x:00002CC1                 db    0
.xdata$x:00002CC2                 db    0
.xdata$x:00002CC3                 db    0
.xdata$x:00002CC4                 dd offset __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.xdata$x:00002CC8                 align 20h
.xdata$x:00002CC8 _xdata$x        ends
.xdata$x:00002CC8
.xdata$x:00002CE0 ; ===========================================================================
.xdata$x:00002CE0
.xdata$x:00002CE0 ; Segment type: Pure data
.xdata$x:00002CE0 ; Segment permissions: Read
.xdata$x:00002CE0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002CE0                 assume cs:_xdata$x
.xdata$x:00002CE0                 ;org 2CE0h
.xdata$x:00002CE0 ; COMDAT (pick associative to section at 1868)
.xdata$x:00002CE0 __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00002CE0                                         ; DATA XREF: .xdata$x:00002CF0o
.xdata$x:00002CE1                 db 0FFh
.xdata$x:00002CE2                 db 0FFh
.xdata$x:00002CE3                 db 0FFh
.xdata$x:00002CE4                 dd offset __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0
.xdata$x:00002CE8 __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00002CE8                                         ; DATA XREF: __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:00002CE9                 db    5
.xdata$x:00002CEA                 db  93h ; ô
.xdata$x:00002CEB                 db  19h
.xdata$x:00002CEC                 db    1
.xdata$x:00002CED                 db    0
.xdata$x:00002CEE                 db    0
.xdata$x:00002CEF                 db    0
.xdata$x:00002CF0                 dd offset __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.xdata$x:00002CF4                 db    0
.xdata$x:00002CF5                 db    0
.xdata$x:00002CF6                 db    0
.xdata$x:00002CF7                 db    0
.xdata$x:00002CF8                 db    0
.xdata$x:00002CF9                 db    0
.xdata$x:00002CFA                 db    0
.xdata$x:00002CFB                 db    0
.xdata$x:00002CFC                 db    0
.xdata$x:00002CFD                 db    0
.xdata$x:00002CFE                 db    0
.xdata$x:00002CFF                 db    0
.xdata$x:00002D00                 db    0
.xdata$x:00002D01                 db    0
.xdata$x:00002D02                 db    0
.xdata$x:00002D03                 db    0
.xdata$x:00002D04                 db    0
.xdata$x:00002D05                 db    0
.xdata$x:00002D06                 db    0
.xdata$x:00002D07                 db    0
.xdata$x:00002D08                 db    0
.xdata$x:00002D09                 db    0
.xdata$x:00002D0A                 db    0
.xdata$x:00002D0B                 db    0
.xdata$x:00002D0B _xdata$x        ends
.xdata$x:00002D0B
.xdata$x:00002D0C ; ===========================================================================
.xdata$x:00002D0C
.xdata$x:00002D0C ; Segment type: Pure data
.xdata$x:00002D0C ; Segment permissions: Read
.xdata$x:00002D0C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002D0C                 assume cs:_xdata$x
.xdata$x:00002D0C                 ;org 2D0Ch
.xdata$x:00002D0C ; COMDAT (pick associative to section at 15BC)
.xdata$x:00002D0C __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z db 0FFh
.xdata$x:00002D0C                                         ; DATA XREF: .xdata$x:00002D1Co
.xdata$x:00002D0D                 db 0FFh
.xdata$x:00002D0E                 db 0FFh
.xdata$x:00002D0F                 db 0FFh
.xdata$x:00002D10                 dd offset __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0
.xdata$x:00002D14 __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z db  22h ; "
.xdata$x:00002D14                                         ; DATA XREF: __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z+11o
.xdata$x:00002D15                 db    5
.xdata$x:00002D16                 db  93h ; ô
.xdata$x:00002D17                 db  19h
.xdata$x:00002D18                 db    1
.xdata$x:00002D19                 db    0
.xdata$x:00002D1A                 db    0
.xdata$x:00002D1B                 db    0
.xdata$x:00002D1C                 dd offset __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.xdata$x:00002D20                 db    0
.xdata$x:00002D21                 db    0
.xdata$x:00002D22                 db    0
.xdata$x:00002D23                 db    0
.xdata$x:00002D24                 db    0
.xdata$x:00002D25                 db    0
.xdata$x:00002D26                 db    0
.xdata$x:00002D27                 db    0
.xdata$x:00002D28                 db    0
.xdata$x:00002D29                 db    0
.xdata$x:00002D2A                 db    0
.xdata$x:00002D2B                 db    0
.xdata$x:00002D2C                 db    0
.xdata$x:00002D2D                 db    0
.xdata$x:00002D2E                 db    0
.xdata$x:00002D2F                 db    0
.xdata$x:00002D30                 db    0
.xdata$x:00002D31                 db    0
.xdata$x:00002D32                 db    0
.xdata$x:00002D33                 db    0
.xdata$x:00002D34                 db    0
.xdata$x:00002D35                 db    0
.xdata$x:00002D36                 db    0
.xdata$x:00002D37                 db    0
.xdata$x:00002D37 _xdata$x        ends
.xdata$x:00002D37
.xdata$x:00002D38 ; ===========================================================================
.xdata$x:00002D38
.xdata$x:00002D38 ; Segment type: Pure data
.xdata$x:00002D38 ; Segment permissions: Read
.xdata$x:00002D38 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002D38                 assume cs:_xdata$x
.xdata$x:00002D38                 ;org 2D38h
.xdata$x:00002D38 ; COMDAT (pick associative to section at 1950)
.xdata$x:00002D38 __unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db 0FFh
.xdata$x:00002D38                                         ; DATA XREF: .xdata$x:00002D48o
.xdata$x:00002D39                 db 0FFh
.xdata$x:00002D3A                 db 0FFh
.xdata$x:00002D3B                 db 0FFh
.xdata$x:00002D3C                 dd offset __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0
.xdata$x:00002D40 __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db  22h ; "
.xdata$x:00002D40                                         ; DATA XREF: __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ+11o
.xdata$x:00002D41                 db    5
.xdata$x:00002D42                 db  93h ; ô
.xdata$x:00002D43                 db  19h
.xdata$x:00002D44                 db    1
.xdata$x:00002D45                 db    0
.xdata$x:00002D46                 db    0
.xdata$x:00002D47                 db    0
.xdata$x:00002D48                 dd offset __unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.xdata$x:00002D4C                 db    0
.xdata$x:00002D4D                 db    0
.xdata$x:00002D4E                 db    0
.xdata$x:00002D4F                 db    0
.xdata$x:00002D50                 db    0
.xdata$x:00002D51                 db    0
.xdata$x:00002D52                 db    0
.xdata$x:00002D53                 db    0
.xdata$x:00002D54                 db    0
.xdata$x:00002D55                 db    0
.xdata$x:00002D56                 db    0
.xdata$x:00002D57                 db    0
.xdata$x:00002D58                 db    0
.xdata$x:00002D59                 db    0
.xdata$x:00002D5A                 db    0
.xdata$x:00002D5B                 db    0
.xdata$x:00002D5C                 db    0
.xdata$x:00002D5D                 db    0
.xdata$x:00002D5E                 db    0
.xdata$x:00002D5F                 db    0
.xdata$x:00002D60                 db    0
.xdata$x:00002D61                 db    0
.xdata$x:00002D62                 db    0
.xdata$x:00002D63                 db    0
.xdata$x:00002D63 _xdata$x        ends
.xdata$x:00002D63
.xdata$x:00002D64 ; ===========================================================================
.xdata$x:00002D64
.xdata$x:00002D64 ; Segment type: Pure data
.xdata$x:00002D64 ; Segment permissions: Read
.xdata$x:00002D64 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002D64                 assume cs:_xdata$x
.xdata$x:00002D64                 ;org 2D64h
.xdata$x:00002D64 ; COMDAT (pick associative to section at 1E78)
.xdata$x:00002D64 __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 db    0
.xdata$x:00002D64                                         ; DATA XREF: .xdata$x:00002DECo
.xdata$x:00002D65                 db    0
.xdata$x:00002D66                 db    0
.xdata$x:00002D67                 db    0
.xdata$x:00002D68                 db    0
.xdata$x:00002D69                 db    0
.xdata$x:00002D6A                 db    0
.xdata$x:00002D6B                 db    0
.xdata$x:00002D6C                 db    0
.xdata$x:00002D6D                 db    0
.xdata$x:00002D6E                 db    0
.xdata$x:00002D6F                 db    0
.xdata$x:00002D70                 dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.xdata$x:00002D74 __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 db    0
.xdata$x:00002D74                                         ; DATA XREF: .xdata$x:00002DD8o
.xdata$x:00002D75                 db    0
.xdata$x:00002D76                 db    0
.xdata$x:00002D77                 db    0
.xdata$x:00002D78                 db    0
.xdata$x:00002D79                 db    0
.xdata$x:00002D7A                 db    0
.xdata$x:00002D7B                 db    0
.xdata$x:00002D7C                 db    0
.xdata$x:00002D7D                 db    0
.xdata$x:00002D7E                 db    0
.xdata$x:00002D7F                 db    0
.xdata$x:00002D80                 dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
.xdata$x:00002D84 __unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db 0FFh
.xdata$x:00002D84                                         ; DATA XREF: .xdata$x:00002DACo
.xdata$x:00002D85                 db 0FFh
.xdata$x:00002D86                 db 0FFh
.xdata$x:00002D87                 db 0FFh
.xdata$x:00002D88                 db    0
.xdata$x:00002D89                 db    0
.xdata$x:00002D8A                 db    0
.xdata$x:00002D8B                 db    0
.xdata$x:00002D8C                 db 0FFh
.xdata$x:00002D8D                 db 0FFh
.xdata$x:00002D8E                 db 0FFh
.xdata$x:00002D8F                 db 0FFh
.xdata$x:00002D90                 db    0
.xdata$x:00002D91                 db    0
.xdata$x:00002D92                 db    0
.xdata$x:00002D93                 db    0
.xdata$x:00002D94                 db    1
.xdata$x:00002D95                 db    0
.xdata$x:00002D96                 db    0
.xdata$x:00002D97                 db    0
.xdata$x:00002D98                 db    0
.xdata$x:00002D99                 db    0
.xdata$x:00002D9A                 db    0
.xdata$x:00002D9B                 db    0
.xdata$x:00002D9C                 db    1
.xdata$x:00002D9D                 db    0
.xdata$x:00002D9E                 db    0
.xdata$x:00002D9F                 db    0
.xdata$x:00002DA0                 db    0
.xdata$x:00002DA1                 db    0
.xdata$x:00002DA2                 db    0
.xdata$x:00002DA3                 db    0
.xdata$x:00002DA4 __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db  22h ; "
.xdata$x:00002DA4                                         ; DATA XREF: __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z+11o
.xdata$x:00002DA5                 db    5
.xdata$x:00002DA6                 db  93h ; ô
.xdata$x:00002DA7                 db  19h
.xdata$x:00002DA8                 db    4
.xdata$x:00002DA9                 db    0
.xdata$x:00002DAA                 db    0
.xdata$x:00002DAB                 db    0
.xdata$x:00002DAC                 dd offset __unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.xdata$x:00002DB0                 db    2
.xdata$x:00002DB1                 db    0
.xdata$x:00002DB2                 db    0
.xdata$x:00002DB3                 db    0
.xdata$x:00002DB4                 dd offset __tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.xdata$x:00002DB8                 db    0
.xdata$x:00002DB9                 db    0
.xdata$x:00002DBA                 db    0
.xdata$x:00002DBB                 db    0
.xdata$x:00002DBC                 db    0
.xdata$x:00002DBD                 db    0
.xdata$x:00002DBE                 db    0
.xdata$x:00002DBF                 db    0
.xdata$x:00002DC0                 db    0
.xdata$x:00002DC1                 db    0
.xdata$x:00002DC2                 db    0
.xdata$x:00002DC3                 db    0
.xdata$x:00002DC4                 db    0
.xdata$x:00002DC5                 db    0
.xdata$x:00002DC6                 db    0
.xdata$x:00002DC7                 db    0
.xdata$x:00002DC8 __tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db    2
.xdata$x:00002DC8                                         ; DATA XREF: .xdata$x:00002DB4o
.xdata$x:00002DC9                 db    0
.xdata$x:00002DCA                 db    0
.xdata$x:00002DCB                 db    0
.xdata$x:00002DCC                 db    2
.xdata$x:00002DCD                 db    0
.xdata$x:00002DCE                 db    0
.xdata$x:00002DCF                 db    0
.xdata$x:00002DD0                 db    3
.xdata$x:00002DD1                 db    0
.xdata$x:00002DD2                 db    0
.xdata$x:00002DD3                 db    0
.xdata$x:00002DD4                 db    1
.xdata$x:00002DD5                 db    0
.xdata$x:00002DD6                 db    0
.xdata$x:00002DD7                 db    0
.xdata$x:00002DD8                 dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
.xdata$x:00002DDC                 db    0
.xdata$x:00002DDD                 db    0
.xdata$x:00002DDE                 db    0
.xdata$x:00002DDF                 db    0
.xdata$x:00002DE0                 db    0
.xdata$x:00002DE1                 db    0
.xdata$x:00002DE2                 db    0
.xdata$x:00002DE3                 db    0
.xdata$x:00002DE4                 db    3
.xdata$x:00002DE5                 db    0
.xdata$x:00002DE6                 db    0
.xdata$x:00002DE7                 db    0
.xdata$x:00002DE8                 db    1
.xdata$x:00002DE9                 db    0
.xdata$x:00002DEA                 db    0
.xdata$x:00002DEB                 db    0
.xdata$x:00002DEC                 dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
.xdata$x:00002DEC _xdata$x        ends
.xdata$x:00002DEC
.xdata$x:00002DF0 ; ===========================================================================
.xdata$x:00002DF0
.xdata$x:00002DF0 ; Segment type: Pure data
.xdata$x:00002DF0 ; Segment permissions: Read
.xdata$x:00002DF0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002DF0                 assume cs:_xdata$x
.xdata$x:00002DF0                 ;org 2DF0h
.xdata$x:00002DF0 ; COMDAT (pick associative to section at 1690)
.xdata$x:00002DF0 __unwindtable$??0_Generic_error_category@std@@QAE@XZ db 0FFh
.xdata$x:00002DF0                                         ; DATA XREF: .xdata$x:00002E00o
.xdata$x:00002DF1                 db 0FFh
.xdata$x:00002DF2                 db 0FFh
.xdata$x:00002DF3                 db 0FFh
.xdata$x:00002DF4                 dd offset __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0
.xdata$x:00002DF8 __ehfuncinfo$??0_Generic_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:00002DF8                                         ; DATA XREF: __ehhandler$??0_Generic_error_category@std@@QAE@XZ+11o
.xdata$x:00002DF9                 db    5
.xdata$x:00002DFA                 db  93h ; ô
.xdata$x:00002DFB                 db  19h
.xdata$x:00002DFC                 db    1
.xdata$x:00002DFD                 db    0
.xdata$x:00002DFE                 db    0
.xdata$x:00002DFF                 db    0
.xdata$x:00002E00                 dd offset __unwindtable$??0_Generic_error_category@std@@QAE@XZ
.xdata$x:00002E04                 db    0
.xdata$x:00002E05                 db    0
.xdata$x:00002E06                 db    0
.xdata$x:00002E07                 db    0
.xdata$x:00002E08                 db    0
.xdata$x:00002E09                 db    0
.xdata$x:00002E0A                 db    0
.xdata$x:00002E0B                 db    0
.xdata$x:00002E0C                 db    0
.xdata$x:00002E0D                 db    0
.xdata$x:00002E0E                 db    0
.xdata$x:00002E0F                 db    0
.xdata$x:00002E10                 db    0
.xdata$x:00002E11                 db    0
.xdata$x:00002E12                 db    0
.xdata$x:00002E13                 db    0
.xdata$x:00002E14                 db    0
.xdata$x:00002E15                 db    0
.xdata$x:00002E16                 db    0
.xdata$x:00002E17                 db    0
.xdata$x:00002E18                 db    0
.xdata$x:00002E19                 db    0
.xdata$x:00002E1A                 db    0
.xdata$x:00002E1B                 db    0
.xdata$x:00002E1B _xdata$x        ends
.xdata$x:00002E1B
.xdata$x:00002E1C ; ===========================================================================
.xdata$x:00002E1C
.xdata$x:00002E1C ; Segment type: Pure data
.xdata$x:00002E1C ; Segment permissions: Read
.xdata$x:00002E1C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002E1C                 assume cs:_xdata$x
.xdata$x:00002E1C                 ;org 2E1Ch
.xdata$x:00002E1C ; COMDAT (pick associative to section at 2914)
.xdata$x:00002E1C __unwindtable$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:00002E1C                                         ; DATA XREF: .xdata$x:00002E2Co
.xdata$x:00002E1D                 db 0FFh
.xdata$x:00002E1E                 db 0FFh
.xdata$x:00002E1F                 db 0FFh
.xdata$x:00002E20                 dd offset __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:00002E24 __ehfuncinfo$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:00002E24                                         ; DATA XREF: __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:00002E25                 db    5
.xdata$x:00002E26                 db  93h ; ô
.xdata$x:00002E27                 db  19h
.xdata$x:00002E28                 db    1
.xdata$x:00002E29                 db    0
.xdata$x:00002E2A                 db    0
.xdata$x:00002E2B                 db    0
.xdata$x:00002E2C                 dd offset __unwindtable$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:00002E30                 db    0
.xdata$x:00002E31                 db    0
.xdata$x:00002E32                 db    0
.xdata$x:00002E33                 db    0
.xdata$x:00002E34                 db    0
.xdata$x:00002E35                 db    0
.xdata$x:00002E36                 db    0
.xdata$x:00002E37                 db    0
.xdata$x:00002E38                 db    0
.xdata$x:00002E39                 db    0
.xdata$x:00002E3A                 db    0
.xdata$x:00002E3B                 db    0
.xdata$x:00002E3C                 db    0
.xdata$x:00002E3D                 db    0
.xdata$x:00002E3E                 db    0
.xdata$x:00002E3F                 db    0
.xdata$x:00002E40                 db    0
.xdata$x:00002E41                 db    0
.xdata$x:00002E42                 db    0
.xdata$x:00002E43                 db    0
.xdata$x:00002E44                 db    0
.xdata$x:00002E45                 db    0
.xdata$x:00002E46                 db    0
.xdata$x:00002E47                 db    0
.xdata$x:00002E47 _xdata$x        ends
.xdata$x:00002E47
.xdata$x:00002E48 ; ===========================================================================
.xdata$x:00002E48
.xdata$x:00002E48 ; Segment type: Pure data
.xdata$x:00002E48 ; Segment permissions: Read
.xdata$x:00002E48 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002E48                 assume cs:_xdata$x
.xdata$x:00002E48                 ;org 2E48h
.xdata$x:00002E48 ; COMDAT (pick associative to section at 19E0)
.xdata$x:00002E48 __unwindtable$??1_Generic_error_category@std@@UAE@XZ db 0FFh
.xdata$x:00002E48                                         ; DATA XREF: .xdata$x:00002E58o
.xdata$x:00002E49                 db 0FFh
.xdata$x:00002E4A                 db 0FFh
.xdata$x:00002E4B                 db 0FFh
.xdata$x:00002E4C                 dd offset __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0
.xdata$x:00002E50 __ehfuncinfo$??1_Generic_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:00002E50                                         ; DATA XREF: __ehhandler$??1_Generic_error_category@std@@UAE@XZ+11o
.xdata$x:00002E51                 db    5
.xdata$x:00002E52                 db  93h ; ô
.xdata$x:00002E53                 db  19h
.xdata$x:00002E54                 db    1
.xdata$x:00002E55                 db    0
.xdata$x:00002E56                 db    0
.xdata$x:00002E57                 db    0
.xdata$x:00002E58                 dd offset __unwindtable$??1_Generic_error_category@std@@UAE@XZ
.xdata$x:00002E5C                 db    0
.xdata$x:00002E5D                 db    0
.xdata$x:00002E5E                 db    0
.xdata$x:00002E5F                 db    0
.xdata$x:00002E60                 db    0
.xdata$x:00002E61                 db    0
.xdata$x:00002E62                 db    0
.xdata$x:00002E63                 db    0
.xdata$x:00002E64                 db    0
.xdata$x:00002E65                 db    0
.xdata$x:00002E66                 db    0
.xdata$x:00002E67                 db    0
.xdata$x:00002E68                 db    0
.xdata$x:00002E69                 db    0
.xdata$x:00002E6A                 db    0
.xdata$x:00002E6B                 db    0
.xdata$x:00002E6C                 db    0
.xdata$x:00002E6D                 db    0
.xdata$x:00002E6E                 db    0
.xdata$x:00002E6F                 db    0
.xdata$x:00002E70                 db    0
.xdata$x:00002E71                 db    0
.xdata$x:00002E72                 db    0
.xdata$x:00002E73                 db    0
.xdata$x:00002E73 _xdata$x        ends
.xdata$x:00002E73
.xdata$x:00002E74 ; ===========================================================================
.xdata$x:00002E74
.xdata$x:00002E74 ; Segment type: Pure data
.xdata$x:00002E74 ; Segment permissions: Read
.xdata$x:00002E74 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002E74                 assume cs:_xdata$x
.xdata$x:00002E74                 ;org 2E74h
.xdata$x:00002E74 ; COMDAT (pick associative to section at 171C)
.xdata$x:00002E74 __unwindtable$??0_Iostream_error_category@std@@QAE@XZ db 0FFh
.xdata$x:00002E74                                         ; DATA XREF: .xdata$x:00002E84o
.xdata$x:00002E75                 db 0FFh
.xdata$x:00002E76                 db 0FFh
.xdata$x:00002E77                 db 0FFh
.xdata$x:00002E78                 dd offset __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0
.xdata$x:00002E7C __ehfuncinfo$??0_Iostream_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:00002E7C                                         ; DATA XREF: __ehhandler$??0_Iostream_error_category@std@@QAE@XZ+11o
.xdata$x:00002E7D                 db    5
.xdata$x:00002E7E                 db  93h ; ô
.xdata$x:00002E7F                 db  19h
.xdata$x:00002E80                 db    1
.xdata$x:00002E81                 db    0
.xdata$x:00002E82                 db    0
.xdata$x:00002E83                 db    0
.xdata$x:00002E84                 dd offset __unwindtable$??0_Iostream_error_category@std@@QAE@XZ
.xdata$x:00002E88                 align 20h
.xdata$x:00002E88 _xdata$x        ends
.xdata$x:00002E88
.xdata$x:00002EA0 ; ===========================================================================
.xdata$x:00002EA0
.xdata$x:00002EA0 ; Segment type: Pure data
.xdata$x:00002EA0 ; Segment permissions: Read
.xdata$x:00002EA0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002EA0                 assume cs:_xdata$x
.xdata$x:00002EA0                 ;org 2EA0h
.xdata$x:00002EA0 ; COMDAT (pick associative to section at 29CC)
.xdata$x:00002EA0 __unwindtable$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:00002EA0                                         ; DATA XREF: .xdata$x:00002EB0o
.xdata$x:00002EA1                 db 0FFh
.xdata$x:00002EA2                 db 0FFh
.xdata$x:00002EA3                 db 0FFh
.xdata$x:00002EA4                 dd offset __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:00002EA8 __ehfuncinfo$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:00002EA8                                         ; DATA XREF: __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:00002EA9                 db    5
.xdata$x:00002EAA                 db  93h ; ô
.xdata$x:00002EAB                 db  19h
.xdata$x:00002EAC                 db    1
.xdata$x:00002EAD                 db    0
.xdata$x:00002EAE                 db    0
.xdata$x:00002EAF                 db    0
.xdata$x:00002EB0                 dd offset __unwindtable$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:00002EB4                 db    0
.xdata$x:00002EB5                 db    0
.xdata$x:00002EB6                 db    0
.xdata$x:00002EB7                 db    0
.xdata$x:00002EB8                 db    0
.xdata$x:00002EB9                 db    0
.xdata$x:00002EBA                 db    0
.xdata$x:00002EBB                 db    0
.xdata$x:00002EBC                 db    0
.xdata$x:00002EBD                 db    0
.xdata$x:00002EBE                 db    0
.xdata$x:00002EBF                 db    0
.xdata$x:00002EC0                 db    0
.xdata$x:00002EC1                 db    0
.xdata$x:00002EC2                 db    0
.xdata$x:00002EC3                 db    0
.xdata$x:00002EC4                 db    0
.xdata$x:00002EC5                 db    0
.xdata$x:00002EC6                 db    0
.xdata$x:00002EC7                 db    0
.xdata$x:00002EC8                 db    0
.xdata$x:00002EC9                 db    0
.xdata$x:00002ECA                 db    0
.xdata$x:00002ECB                 db    0
.xdata$x:00002ECB _xdata$x        ends
.xdata$x:00002ECB
.xdata$x:00002ECC ; ===========================================================================
.xdata$x:00002ECC
.xdata$x:00002ECC ; Segment type: Pure data
.xdata$x:00002ECC ; Segment permissions: Read
.xdata$x:00002ECC _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002ECC                 assume cs:_xdata$x
.xdata$x:00002ECC                 ;org 2ECCh
.xdata$x:00002ECC ; COMDAT (pick associative to section at 1A50)
.xdata$x:00002ECC __unwindtable$??1_Iostream_error_category@std@@UAE@XZ db 0FFh
.xdata$x:00002ECC                                         ; DATA XREF: .xdata$x:00002EDCo
.xdata$x:00002ECD                 db 0FFh
.xdata$x:00002ECE                 db 0FFh
.xdata$x:00002ECF                 db 0FFh
.xdata$x:00002ED0                 dd offset __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0
.xdata$x:00002ED4 __ehfuncinfo$??1_Iostream_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:00002ED4                                         ; DATA XREF: __ehhandler$??1_Iostream_error_category@std@@UAE@XZ+11o
.xdata$x:00002ED5                 db    5
.xdata$x:00002ED6                 db  93h ; ô
.xdata$x:00002ED7                 db  19h
.xdata$x:00002ED8                 db    1
.xdata$x:00002ED9                 db    0
.xdata$x:00002EDA                 db    0
.xdata$x:00002EDB                 db    0
.xdata$x:00002EDC                 dd offset __unwindtable$??1_Iostream_error_category@std@@UAE@XZ
.xdata$x:00002EE0                 db    0
.xdata$x:00002EE1                 db    0
.xdata$x:00002EE2                 db    0
.xdata$x:00002EE3                 db    0
.xdata$x:00002EE4                 db    0
.xdata$x:00002EE5                 db    0
.xdata$x:00002EE6                 db    0
.xdata$x:00002EE7                 db    0
.xdata$x:00002EE8                 db    0
.xdata$x:00002EE9                 db    0
.xdata$x:00002EEA                 db    0
.xdata$x:00002EEB                 db    0
.xdata$x:00002EEC                 db    0
.xdata$x:00002EED                 db    0
.xdata$x:00002EEE                 db    0
.xdata$x:00002EEF                 db    0
.xdata$x:00002EF0                 db    0
.xdata$x:00002EF1                 db    0
.xdata$x:00002EF2                 db    0
.xdata$x:00002EF3                 db    0
.xdata$x:00002EF4                 db    0
.xdata$x:00002EF5                 db    0
.xdata$x:00002EF6                 db    0
.xdata$x:00002EF7                 db    0
.xdata$x:00002EF7 _xdata$x        ends
.xdata$x:00002EF7
.xdata$x:00002EF8 ; ===========================================================================
.xdata$x:00002EF8
.xdata$x:00002EF8 ; Segment type: Pure data
.xdata$x:00002EF8 ; Segment permissions: Read
.xdata$x:00002EF8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002EF8                 assume cs:_xdata$x
.xdata$x:00002EF8                 ;org 2EF8h
.xdata$x:00002EF8 ; COMDAT (pick associative to section at 1798)
.xdata$x:00002EF8 __unwindtable$??0_System_error_category@std@@QAE@XZ db 0FFh
.xdata$x:00002EF8                                         ; DATA XREF: .xdata$x:00002F08o
.xdata$x:00002EF9                 db 0FFh
.xdata$x:00002EFA                 db 0FFh
.xdata$x:00002EFB                 db 0FFh
.xdata$x:00002EFC                 dd offset __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0
.xdata$x:00002F00 __ehfuncinfo$??0_System_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:00002F00                                         ; DATA XREF: __ehhandler$??0_System_error_category@std@@QAE@XZ+11o
.xdata$x:00002F01                 db    5
.xdata$x:00002F02                 db  93h ; ô
.xdata$x:00002F03                 db  19h
.xdata$x:00002F04                 db    1
.xdata$x:00002F05                 db    0
.xdata$x:00002F06                 db    0
.xdata$x:00002F07                 db    0
.xdata$x:00002F08                 dd offset __unwindtable$??0_System_error_category@std@@QAE@XZ
.xdata$x:00002F0C                 db    0
.xdata$x:00002F0D                 db    0
.xdata$x:00002F0E                 db    0
.xdata$x:00002F0F                 db    0
.xdata$x:00002F10                 db    0
.xdata$x:00002F11                 db    0
.xdata$x:00002F12                 db    0
.xdata$x:00002F13                 db    0
.xdata$x:00002F14                 db    0
.xdata$x:00002F15                 db    0
.xdata$x:00002F16                 db    0
.xdata$x:00002F17                 db    0
.xdata$x:00002F18                 db    0
.xdata$x:00002F19                 db    0
.xdata$x:00002F1A                 db    0
.xdata$x:00002F1B                 db    0
.xdata$x:00002F1C                 db    0
.xdata$x:00002F1D                 db    0
.xdata$x:00002F1E                 db    0
.xdata$x:00002F1F                 db    0
.xdata$x:00002F20                 db    0
.xdata$x:00002F21                 db    0
.xdata$x:00002F22                 db    0
.xdata$x:00002F23                 db    0
.xdata$x:00002F23 _xdata$x        ends
.xdata$x:00002F23
.xdata$x:00002F24 ; ===========================================================================
.xdata$x:00002F24
.xdata$x:00002F24 ; Segment type: Pure data
.xdata$x:00002F24 ; Segment permissions: Read
.xdata$x:00002F24 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002F24                 assume cs:_xdata$x
.xdata$x:00002F24                 ;org 2F24h
.xdata$x:00002F24 ; COMDAT (pick associative to section at 2A90)
.xdata$x:00002F24 __unwindtable$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:00002F24                                         ; DATA XREF: .xdata$x:00002F34o
.xdata$x:00002F25                 db 0FFh
.xdata$x:00002F26                 db 0FFh
.xdata$x:00002F27                 db 0FFh
.xdata$x:00002F28                 dd offset __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:00002F2C __ehfuncinfo$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:00002F2C                                         ; DATA XREF: __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:00002F2D                 db    5
.xdata$x:00002F2E                 db  93h ; ô
.xdata$x:00002F2F                 db  19h
.xdata$x:00002F30                 db    1
.xdata$x:00002F31                 db    0
.xdata$x:00002F32                 db    0
.xdata$x:00002F33                 db    0
.xdata$x:00002F34                 dd offset __unwindtable$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:00002F38                 db    0
.xdata$x:00002F39                 db    0
.xdata$x:00002F3A                 db    0
.xdata$x:00002F3B                 db    0
.xdata$x:00002F3C                 db    0
.xdata$x:00002F3D                 db    0
.xdata$x:00002F3E                 db    0
.xdata$x:00002F3F                 db    0
.xdata$x:00002F40                 db    0
.xdata$x:00002F41                 db    0
.xdata$x:00002F42                 db    0
.xdata$x:00002F43                 db    0
.xdata$x:00002F44                 db    0
.xdata$x:00002F45                 db    0
.xdata$x:00002F46                 db    0
.xdata$x:00002F47                 db    0
.xdata$x:00002F48                 db    0
.xdata$x:00002F49                 db    0
.xdata$x:00002F4A                 db    0
.xdata$x:00002F4B                 db    0
.xdata$x:00002F4C                 db    0
.xdata$x:00002F4D                 db    0
.xdata$x:00002F4E                 db    0
.xdata$x:00002F4F                 db    0
.xdata$x:00002F4F _xdata$x        ends
.xdata$x:00002F4F
.xdata$x:00002F50 ; ===========================================================================
.xdata$x:00002F50
.xdata$x:00002F50 ; Segment type: Pure data
.xdata$x:00002F50 ; Segment permissions: Read
.xdata$x:00002F50 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002F50                 assume cs:_xdata$x
.xdata$x:00002F50                 ;org 2F50h
.xdata$x:00002F50 ; COMDAT (pick associative to section at 1AC0)
.xdata$x:00002F50 __unwindtable$??1_System_error_category@std@@UAE@XZ db 0FFh
.xdata$x:00002F50                                         ; DATA XREF: .xdata$x:00002F60o
.xdata$x:00002F51                 db 0FFh
.xdata$x:00002F52                 db 0FFh
.xdata$x:00002F53                 db 0FFh
.xdata$x:00002F54                 dd offset __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0
.xdata$x:00002F58 __ehfuncinfo$??1_System_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:00002F58                                         ; DATA XREF: __ehhandler$??1_System_error_category@std@@UAE@XZ+11o
.xdata$x:00002F59                 db    5
.xdata$x:00002F5A                 db  93h ; ô
.xdata$x:00002F5B                 db  19h
.xdata$x:00002F5C                 db    1
.xdata$x:00002F5D                 db    0
.xdata$x:00002F5E                 db    0
.xdata$x:00002F5F                 db    0
.xdata$x:00002F60                 dd offset __unwindtable$??1_System_error_category@std@@UAE@XZ
.xdata$x:00002F64                 db    0
.xdata$x:00002F65                 db    0
.xdata$x:00002F66                 db    0
.xdata$x:00002F67                 db    0
.xdata$x:00002F68                 db    0
.xdata$x:00002F69                 db    0
.xdata$x:00002F6A                 db    0
.xdata$x:00002F6B                 db    0
.xdata$x:00002F6C                 db    0
.xdata$x:00002F6D                 db    0
.xdata$x:00002F6E                 db    0
.xdata$x:00002F6F                 db    0
.xdata$x:00002F70                 db    0
.xdata$x:00002F71                 db    0
.xdata$x:00002F72                 db    0
.xdata$x:00002F73                 db    0
.xdata$x:00002F74                 db    0
.xdata$x:00002F75                 db    0
.xdata$x:00002F76                 db    0
.xdata$x:00002F77                 db    0
.xdata$x:00002F78                 db    0
.xdata$x:00002F79                 db    0
.xdata$x:00002F7A                 db    0
.xdata$x:00002F7B                 db    0
.xdata$x:00002F7B _xdata$x        ends
.xdata$x:00002F7B
.xdata$x:00002F7C ; ===========================================================================
.xdata$x:00002F7C
.xdata$x:00002F7C ; Segment type: Pure data
.xdata$x:00002F7C ; Segment permissions: Read
.xdata$x:00002F7C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002F7C                 assume cs:_xdata$x
.xdata$x:00002F7C                 ;org 2F7Ch
.xdata$x:00002F7C ; COMDAT (pick associative to section at 1364)
.xdata$x:00002F7C __unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z db 0FFh
.xdata$x:00002F7C                                         ; DATA XREF: .xdata$x:00002F8Co
.xdata$x:00002F7D                 db 0FFh
.xdata$x:00002F7E                 db 0FFh
.xdata$x:00002F7F                 db 0FFh
.xdata$x:00002F80                 dd offset __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0
.xdata$x:00002F84 __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z db  22h ; "
.xdata$x:00002F84                                         ; DATA XREF: __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z+11o
.xdata$x:00002F85                 db    5
.xdata$x:00002F86                 db  93h ; ô
.xdata$x:00002F87                 db  19h
.xdata$x:00002F88                 db    1
.xdata$x:00002F89                 db    0
.xdata$x:00002F8A                 db    0
.xdata$x:00002F8B                 db    0
.xdata$x:00002F8C                 dd offset __unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.xdata$x:00002F90                 db    0
.xdata$x:00002F91                 db    0
.xdata$x:00002F92                 db    0
.xdata$x:00002F93                 db    0
.xdata$x:00002F94                 db    0
.xdata$x:00002F95                 db    0
.xdata$x:00002F96                 db    0
.xdata$x:00002F97                 db    0
.xdata$x:00002F98                 db    0
.xdata$x:00002F99                 db    0
.xdata$x:00002F9A                 db    0
.xdata$x:00002F9B                 db    0
.xdata$x:00002F9C                 db    0
.xdata$x:00002F9D                 db    0
.xdata$x:00002F9E                 db    0
.xdata$x:00002F9F                 db    0
.xdata$x:00002FA0                 db    0
.xdata$x:00002FA1                 db    0
.xdata$x:00002FA2                 db    0
.xdata$x:00002FA3                 db    0
.xdata$x:00002FA4                 db    0
.xdata$x:00002FA5                 db    0
.xdata$x:00002FA6                 db    0
.xdata$x:00002FA7                 db    0
.xdata$x:00002FA7 _xdata$x        ends
.xdata$x:00002FA7
.xdata$x:00002FA8 ; ===========================================================================
.xdata$x:00002FA8
.xdata$x:00002FA8 ; Segment type: Pure data
.xdata$x:00002FA8 ; Segment permissions: Read
.xdata$x:00002FA8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002FA8                 assume cs:_xdata$x
.xdata$x:00002FA8                 ;org 2FA8h
.xdata$x:00002FA8 ; COMDAT (pick associative to section at 1290)
.xdata$x:00002FA8 __unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z db 0FFh
.xdata$x:00002FA8                                         ; DATA XREF: .xdata$x:00002FB8o
.xdata$x:00002FA9                 db 0FFh
.xdata$x:00002FAA                 db 0FFh
.xdata$x:00002FAB                 db 0FFh
.xdata$x:00002FAC                 dd offset __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0
.xdata$x:00002FB0 __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z db  22h ; "
.xdata$x:00002FB0                                         ; DATA XREF: __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z+11o
.xdata$x:00002FB1                 db    5
.xdata$x:00002FB2                 db  93h ; ô
.xdata$x:00002FB3                 db  19h
.xdata$x:00002FB4                 db    1
.xdata$x:00002FB5                 db    0
.xdata$x:00002FB6                 db    0
.xdata$x:00002FB7                 db    0
.xdata$x:00002FB8                 dd offset __unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.xdata$x:00002FBC                 db    0
.xdata$x:00002FBD                 db    0
.xdata$x:00002FBE                 db    0
.xdata$x:00002FBF                 db    0
.xdata$x:00002FC0                 db    0
.xdata$x:00002FC1                 db    0
.xdata$x:00002FC2                 db    0
.xdata$x:00002FC3                 db    0
.xdata$x:00002FC4                 db    0
.xdata$x:00002FC5                 db    0
.xdata$x:00002FC6                 db    0
.xdata$x:00002FC7                 db    0
.xdata$x:00002FC8                 db    0
.xdata$x:00002FC9                 db    0
.xdata$x:00002FCA                 db    0
.xdata$x:00002FCB                 db    0
.xdata$x:00002FCC                 db    0
.xdata$x:00002FCD                 db    0
.xdata$x:00002FCE                 db    0
.xdata$x:00002FCF                 db    0
.xdata$x:00002FD0                 db    0
.xdata$x:00002FD1                 db    0
.xdata$x:00002FD2                 db    0
.xdata$x:00002FD3                 db    0
.xdata$x:00002FD3 _xdata$x        ends
.xdata$x:00002FD3
.bss:00002FD4 ; ===========================================================================
.bss:00002FD4
.bss:00002FD4 ; Segment type: Uninitialized
.bss:00002FD4 ; Segment permissions: Read/Write
.bss:00002FD4 _bss            segment byte public 'BSS' use32
.bss:00002FD4                 assume cs:_bss
.bss:00002FD4                 ;org 2FD4h
.bss:00002FD4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:00002FD4 __Tuple_alloc   db    ? ;
.bss:00002FD5 ; std::_Ignore ignore
.bss:00002FD5 _ignore         db    ? ;               ; DATA XREF: std::`dynamic initializer for 'ignore''(void)+3o
.bss:00002FD6 _allocator_arg  db    ? ;
.bss:00002FD7 _piecewise_construct db    ? ;
.bss:00002FD7 _bss            ends
.bss:00002FD7
.rdata:00002FD8 ; ===========================================================================
.rdata:00002FD8
.rdata:00002FD8 ; Segment type: Pure data
.rdata:00002FD8 ; Segment permissions: Read
.rdata:00002FD8 _rdata          segment dword public 'DATA' use32
.rdata:00002FD8                 assume cs:_rdata
.rdata:00002FD8                 ;org 2FD8h
.rdata:00002FD8 ; COMDAT (pick largest)
.rdata:00002FD8                 dd offset ??_R4error_category@std@@6B@ ; const std::error_category::`RTTI Complete Object Locator'
.rdata:00002FDC                 public ??_7error_category@std@@6B@
.rdata:00002FDC ; const std::error_category::`vftable'
.rdata:00002FDC ??_7error_category@std@@6B@ dd offset ??_Eerror_category@std@@UAEPAXI@Z
.rdata:00002FDC                                         ; DATA XREF: std::error_category::error_category(void)+Ao
.rdata:00002FDC                                         ; std::error_category::~error_category(void)+Ao
.rdata:00002FDC                                         ; std::error_category::`vector deleting destructor'(uint)
.rdata:00002FE0                 dd offset __purecall
.rdata:00002FE4                 dd offset __purecall
.rdata:00002FE8                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:00002FEC                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00002FF0                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00002FF0 _rdata          ends
.rdata:00002FF0
.rdata:00002FF4 ; ===========================================================================
.rdata:00002FF4
.rdata:00002FF4 ; Segment type: Pure data
.rdata:00002FF4 ; Segment permissions: Read
.rdata:00002FF4 _rdata          segment dword public 'DATA' use32
.rdata:00002FF4                 assume cs:_rdata
.rdata:00002FF4                 ;org 2FF4h
.rdata:00002FF4 ; COMDAT (pick largest)
.rdata:00002FF4                 dd offset ??_R4_Generic_error_category@std@@6B@ ; const std::_Generic_error_category::`RTTI Complete Object Locator'
.rdata:00002FF8                 public ??_7_Generic_error_category@std@@6B@
.rdata:00002FF8 ; const std::_Generic_error_category::`vftable'
.rdata:00002FF8 ??_7_Generic_error_category@std@@6B@ dd offset ??_E_Generic_error_category@std@@UAEPAXI@Z
.rdata:00002FF8                                         ; DATA XREF: std::_Generic_error_category::_Generic_error_category(void)+38o
.rdata:00002FF8                                         ; std::_Generic_error_category::`vector deleting destructor'(uint)
.rdata:00002FFC                 dd offset ?name@_Generic_error_category@std@@UBEPBDXZ ; std::_Generic_error_category::name(void)
.rdata:00003000                 dd offset ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
.rdata:00003004                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:00003008                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:0000300C                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:0000300C _rdata          ends
.rdata:0000300C
.rdata:00003010 ; ===========================================================================
.rdata:00003010
.rdata:00003010 ; Segment type: Pure data
.rdata:00003010 ; Segment permissions: Read
.rdata:00003010 _rdata          segment dword public 'DATA' use32
.rdata:00003010                 assume cs:_rdata
.rdata:00003010                 ;org 3010h
.rdata:00003010 ; COMDAT (pick any)
.rdata:00003010                 public ??_C@_07DCLBNMLN@generic?$AA@
.rdata:00003010 ; `string'
.rdata:00003010 ??_C@_07DCLBNMLN@generic?$AA@ db 'generic',0
.rdata:00003010                                         ; DATA XREF: std::_Generic_error_category::name(void)+7o
.rdata:00003010 _rdata          ends
.rdata:00003010
.rdata:00003018 ; ===========================================================================
.rdata:00003018
.rdata:00003018 ; Segment type: Pure data
.rdata:00003018 ; Segment permissions: Read
.rdata:00003018 _rdata          segment dword public 'DATA' use32
.rdata:00003018                 assume cs:_rdata
.rdata:00003018                 ;org 3018h
.rdata:00003018 ; COMDAT (pick any)
.rdata:00003018                 public ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
.rdata:00003018 ; `string'
.rdata:00003018 ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ db 'unknown error',0
.rdata:00003018                                         ; DATA XREF: std::_Generic_error_category::message(int):loc_2960o
.rdata:00003018                                         ; std::_System_error_category::message(int):loc_2ADCo
.rdata:00003026                 align 4
.rdata:00003026 _rdata          ends
.rdata:00003026
.rdata:00003028 ; ===========================================================================
.rdata:00003028
.rdata:00003028 ; Segment type: Pure data
.rdata:00003028 ; Segment permissions: Read
.rdata:00003028 _rdata          segment dword public 'DATA' use32
.rdata:00003028                 assume cs:_rdata
.rdata:00003028                 ;org 3028h
.rdata:00003028 ; COMDAT (pick largest)
.rdata:00003028                 dd offset ??_R4_Iostream_error_category@std@@6B@ ; const std::_Iostream_error_category::`RTTI Complete Object Locator'
.rdata:0000302C                 public ??_7_Iostream_error_category@std@@6B@
.rdata:0000302C ; const std::_Iostream_error_category::`vftable'
.rdata:0000302C ??_7_Iostream_error_category@std@@6B@ dd offset ??_E_Iostream_error_category@std@@UAEPAXI@Z
.rdata:0000302C                                         ; DATA XREF: std::_Iostream_error_category::_Iostream_error_category(void)+38o
.rdata:0000302C                                         ; std::_Iostream_error_category::`vector deleting destructor'(uint)
.rdata:00003030                 dd offset ?name@_Iostream_error_category@std@@UBEPBDXZ ; std::_Iostream_error_category::name(void)
.rdata:00003034                 dd offset ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message(int)
.rdata:00003038                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:0000303C                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00003040                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00003040 _rdata          ends
.rdata:00003040
.rdata:00003044 ; ===========================================================================
.rdata:00003044
.rdata:00003044 ; Segment type: Pure data
.rdata:00003044 ; Segment permissions: Read
.rdata:00003044 _rdata          segment dword public 'DATA' use32
.rdata:00003044                 assume cs:_rdata
.rdata:00003044                 ;org 3044h
.rdata:00003044 ; COMDAT (pick any)
.rdata:00003044                 public ??_C@_08LLGCOLLL@iostream?$AA@
.rdata:00003044 ; `string'
.rdata:00003044 ??_C@_08LLGCOLLL@iostream?$AA@ db 'iostream',0
.rdata:00003044                                         ; DATA XREF: std::_Iostream_error_category::name(void)+7o
.rdata:0000304D                 align 10h
.rdata:0000304D _rdata          ends
.rdata:0000304D
.rdata:00003050 ; ===========================================================================
.rdata:00003050
.rdata:00003050 ; Segment type: Pure data
.rdata:00003050 ; Segment permissions: Read
.rdata:00003050 _rdata          segment dword public 'DATA' use32
.rdata:00003050                 assume cs:_rdata
.rdata:00003050                 ;org 3050h
.rdata:00003050 ; COMDAT (pick any)
.rdata:00003050                 public ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
.rdata:00003050 ; char `string'[]
.rdata:00003050 ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ db 'iostream stream error',0
.rdata:00003050                                         ; DATA XREF: std::_Iostream_error_category::message(int)+35o
.rdata:00003066                 align 4
.rdata:00003066 _rdata          ends
.rdata:00003066
.rdata:00003068 ; ===========================================================================
.rdata:00003068
.rdata:00003068 ; Segment type: Pure data
.rdata:00003068 ; Segment permissions: Read
.rdata:00003068 _rdata          segment dword public 'DATA' use32
.rdata:00003068                 assume cs:_rdata
.rdata:00003068                 ;org 3068h
.rdata:00003068 ; COMDAT (pick largest)
.rdata:00003068                 dd offset ??_R4_System_error_category@std@@6B@ ; const std::_System_error_category::`RTTI Complete Object Locator'
.rdata:0000306C                 public ??_7_System_error_category@std@@6B@
.rdata:0000306C ; const std::_System_error_category::`vftable'
.rdata:0000306C ??_7_System_error_category@std@@6B@ dd offset ??_E_System_error_category@std@@UAEPAXI@Z
.rdata:0000306C                                         ; DATA XREF: std::_System_error_category::_System_error_category(void)+38o
.rdata:0000306C                                         ; std::_System_error_category::`vector deleting destructor'(uint)
.rdata:00003070                 dd offset ?name@_System_error_category@std@@UBEPBDXZ ; std::_System_error_category::name(void)
.rdata:00003074                 dd offset ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message(int)
.rdata:00003078                 dd offset ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition(int)
.rdata:0000307C                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00003080                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00003080 _rdata          ends
.rdata:00003080
.rdata:00003084 ; ===========================================================================
.rdata:00003084
.rdata:00003084 ; Segment type: Pure data
.rdata:00003084 ; Segment permissions: Read
.rdata:00003084 _rdata          segment dword public 'DATA' use32
.rdata:00003084                 assume cs:_rdata
.rdata:00003084                 ;org 3084h
.rdata:00003084 ; COMDAT (pick any)
.rdata:00003084                 public ??_C@_06FHFOAHML@system?$AA@
.rdata:00003084 ; `string'
.rdata:00003084 ??_C@_06FHFOAHML@system?$AA@ db 'system',0
.rdata:00003084                                         ; DATA XREF: std::_System_error_category::name(void)+7o
.rdata:0000308B                 align 4
.rdata:0000308B _rdata          ends
.rdata:0000308B
.bss:0000308C ; ===========================================================================
.bss:0000308C
.bss:0000308C ; Segment type: Uninitialized
.bss:0000308C ; Segment permissions: Read/Write
.bss:0000308C _bss            segment dword public 'BSS' use32
.bss:0000308C                 assume cs:_bss
.bss:0000308C                 ;org 308Ch
.bss:0000308C ; COMDAT (pick any)
.bss:0000308C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:0000308C                 public ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
.bss:0000308C ; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
.bss:0000308C ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A db    ? ;
.bss:0000308C                                         ; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o
.bss:0000308C                                         ; `dynamic atexit destructor for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o ...
.bss:0000308D                 db    ? ;
.bss:0000308E                 db    ? ;
.bss:0000308F                 db    ? ;
.bss:0000308F _bss            ends
.bss:0000308F
.bss:00003090 ; ===========================================================================
.bss:00003090
.bss:00003090 ; Segment type: Uninitialized
.bss:00003090 ; Segment permissions: Read/Write
.bss:00003090 _bss            segment dword public 'BSS' use32
.bss:00003090                 assume cs:_bss
.bss:00003090                 ;org 3090h
.bss:00003090 ; COMDAT (pick any)
.bss:00003090                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:00003090                 public ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
.bss:00003090 ; std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object
.bss:00003090 ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A db    ? ;
.bss:00003090                                         ; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
.bss:00003090                                         ; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
.bss:00003091                 db    ? ;
.bss:00003092                 db    ? ;
.bss:00003093                 db    ? ;
.bss:00003093 _bss            ends
.bss:00003093
.bss:00003094 ; ===========================================================================
.bss:00003094
.bss:00003094 ; Segment type: Uninitialized
.bss:00003094 ; Segment permissions: Read/Write
.bss:00003094 _bss            segment dword public 'BSS' use32
.bss:00003094                 assume cs:_bss
.bss:00003094                 ;org 3094h
.bss:00003094 ; COMDAT (pick any)
.bss:00003094                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:00003094                 public ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
.bss:00003094 ; std::_System_error_category std::_Error_objects<int>::_System_object
.bss:00003094 ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A db    ? ;
.bss:00003094                                         ; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o
.bss:00003094                                         ; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o ...
.bss:00003095                 db    ? ;
.bss:00003096                 db    ? ;
.bss:00003097                 db    ? ;
.bss:00003097 _bss            ends
.bss:00003097
.bss:00003098 ; ===========================================================================
.bss:00003098
.bss:00003098 ; Segment type: Uninitialized
.bss:00003098 ; Segment permissions: Read/Write
.bss:00003098 _bss            segment dword public 'BSS' use32
.bss:00003098                 assume cs:_bss
.bss:00003098                 ;org 3098h
.bss:00003098 ; COMDAT (pick any)
.bss:00003098                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:00003098                 public ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
.bss:00003098 ; std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id
.bss:00003098 ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A db    ? ;
.bss:00003098                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)+5o
.bss:00003099                 db    ? ;
.bss:0000309A                 db    ? ;
.bss:0000309B                 db    ? ;
.bss:0000309B _bss            ends
.bss:0000309B
.bss:0000309C ; ===========================================================================
.bss:0000309C
.bss:0000309C ; Segment type: Uninitialized
.bss:0000309C ; Segment permissions: Read/Write
.bss:0000309C _bss            segment dword public 'BSS' use32
.bss:0000309C                 assume cs:_bss
.bss:0000309C                 ;org 309Ch
.bss:0000309C ; COMDAT (pick any)
.bss:0000309C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:0000309C                 public ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
.bss:0000309C ; std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id
.bss:0000309C ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A db    ? ;
.bss:0000309C                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)+5o
.bss:0000309D                 db    ? ;
.bss:0000309E                 db    ? ;
.bss:0000309F                 db    ? ;
.bss:0000309F _bss            ends
.bss:0000309F
.rdata:000030A0 ; ===========================================================================
.rdata:000030A0
.rdata:000030A0 ; Segment type: Pure data
.rdata:000030A0 ; Segment permissions: Read
.rdata:000030A0 ; Segment alignment 'qword' can not be represented in assembly
.rdata:000030A0 _rdata          segment para public 'DATA' use32
.rdata:000030A0                 assume cs:_rdata
.rdata:000030A0                 ;org 30A0h
.rdata:000030A0 ; COMDAT (pick any)
.rdata:000030A0                 public ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:000030A0 ; wchar_t `string'
.rdata:000030A0 ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:000030A0                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+Co
.rdata:000030A0                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+12o
.rdata:000030A0                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:000030A0                 unicode 0, <clude\xstring>,0
.rdata:0000312E                 align 10h
.rdata:0000312E _rdata          ends
.rdata:0000312E
.bss:00003130 ; ===========================================================================
.bss:00003130
.bss:00003130 ; Segment type: Uninitialized
.bss:00003130 ; Segment permissions: Read/Write
.bss:00003130 _bss            segment dword public 'BSS' use32
.bss:00003130                 assume cs:_bss
.bss:00003130                 ;org 3130h
.bss:00003130 ; COMDAT (pick any)
.bss:00003130                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:00003130                 public ?id@?$numpunct@D@std@@2V0locale@2@A
.bss:00003130 ; std::locale::id std::numpunct<char>::id
.bss:00003130 ?id@?$numpunct@D@std@@2V0locale@2@A db    ? ;
.bss:00003130                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::numpunct<char>::id''(void)+5o
.bss:00003131                 db    ? ;
.bss:00003132                 db    ? ;
.bss:00003133                 db    ? ;
.bss:00003133 _bss            ends
.bss:00003133
.bss:00003134 ; ===========================================================================
.bss:00003134
.bss:00003134 ; Segment type: Uninitialized
.bss:00003134 ; Segment permissions: Read/Write
.bss:00003134 _bss            segment dword public 'BSS' use32
.bss:00003134                 assume cs:_bss
.bss:00003134                 ;org 3134h
.bss:00003134 ; COMDAT (pick any)
.bss:00003134                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:00003134                 public ?id@?$numpunct@_W@std@@2V0locale@2@A
.bss:00003134 ; std::locale::id std::numpunct<wchar_t>::id
.bss:00003134 ?id@?$numpunct@_W@std@@2V0locale@2@A db    ? ;
.bss:00003134                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::numpunct<wchar_t>::id''(void)+5o
.bss:00003135                 db    ? ;
.bss:00003136                 db    ? ;
.bss:00003137                 db    ? ;
.bss:00003137 _bss            ends
.bss:00003137
.rdata:00003138 ; ===========================================================================
.rdata:00003138
.rdata:00003138 ; Segment type: Pure data
.rdata:00003138 ; Segment permissions: Read
.rdata:00003138 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00003138 _rdata          segment para public 'DATA' use32
.rdata:00003138                 assume cs:_rdata
.rdata:00003138                 ;org 3138h
.rdata:00003138 ; COMDAT (pick any)
.rdata:00003138                 public ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:00003138 ; wchar_t `string'
.rdata:00003138 ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:00003138                                         ; DATA XREF: std::vector<MacroShortcut,std::allocator<MacroShortcut>>::operator[](uint)+19o
.rdata:00003138                                         ; std::vector<MacroShortcut,std::allocator<MacroShortcut>>::operator[](uint)+49o ...
.rdata:00003138                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:00003138                 unicode 0, <clude\vector>,0
.rdata:00003138 _rdata          ends
.rdata:00003138
.rdata:000031C4 ; ===========================================================================
.rdata:000031C4
.rdata:000031C4 ; Segment type: Pure data
.rdata:000031C4 ; Segment permissions: Read
.rdata:000031C4 _rdata          segment dword public 'DATA' use32
.rdata:000031C4                 assume cs:_rdata
.rdata:000031C4                 ;org 31C4h
.rdata:000031C4 ; COMDAT (pick any)
.rdata:000031C4                 public ??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@
.rdata:000031C4 ; wchar_t `string'
.rdata:000031C4 ??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@:
.rdata:000031C4                                         ; DATA XREF: std::vector<MacroShortcut,std::allocator<MacroShortcut>>::operator[](uint)+1Eo
.rdata:000031C4                 unicode 0, <vector subscript out of range>,0
.rdata:000031C4 _rdata          ends
.rdata:000031C4
.rdata:00003200 ; ===========================================================================
.rdata:00003200
.rdata:00003200 ; Segment type: Pure data
.rdata:00003200 ; Segment permissions: Read
.rdata:00003200 _rdata          segment dword public 'DATA' use32
.rdata:00003200                 assume cs:_rdata
.rdata:00003200                 ;org 3200h
.rdata:00003200 ; COMDAT (pick any)
.rdata:00003200                 public ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@
.rdata:00003200 ; `string'
.rdata:00003200 ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ db 'Standard C++ Libraries Out of Range',0
.rdata:00003200                                         ; DATA XREF: std::vector<MacroShortcut,std::allocator<MacroShortcut>>::operator[](uint)+2Bo
.rdata:00003200 _rdata          ends
.rdata:00003200
.rdata:00003224 ; ===========================================================================
.rdata:00003224
.rdata:00003224 ; Segment type: Pure data
.rdata:00003224 ; Segment permissions: Read
.rdata:00003224 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00003224 _rdata          segment para public 'DATA' use32
.rdata:00003224                 assume cs:_rdata
.rdata:00003224                 ;org 3224h
.rdata:00003224 ; COMDAT (pick any)
.rdata:00003224                 public ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@
.rdata:00003224 ; `string'
.rdata:00003224 ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@:
.rdata:00003224                                         ; DATA XREF: std::vector<MacroShortcut,std::allocator<MacroShortcut>>::operator[](uint):loc_1C14o
.rdata:00003224                 unicode 0, <"Standard C++ Libraries Out of Range" && 0>,0
.rdata:0000327A                 align 4
.rdata:0000327A _rdata          ends
.rdata:0000327A
.rdata:0000327C ; ===========================================================================
.rdata:0000327C
.rdata:0000327C ; Segment type: Pure data
.rdata:0000327C ; Segment permissions: Read
.rdata:0000327C _rdata          segment dword public 'DATA' use32
.rdata:0000327C                 assume cs:_rdata
.rdata:0000327C                 ;org 327Ch
.rdata:0000327C ; COMDAT (pick any)
.rdata:0000327C                 public ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
.rdata:0000327C ; `string'
.rdata:0000327C ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@:
.rdata:0000327C                                         ; DATA XREF: std::vector<MacroShortcut,std::allocator<MacroShortcut>>::operator[](uint)+3Do
.rdata:0000327C                 unicode 0, <%s>,0
.rdata:00003282                 align 4
.rdata:00003282 _rdata          ends
.rdata:00003282
.rdata:00003284 ; ===========================================================================
.rdata:00003284
.rdata:00003284 ; Segment type: Pure data
.rdata:00003284 ; Segment permissions: Read
.rdata:00003284 _rdata          segment dword public 'DATA' use32
.rdata:00003284                 assume cs:_rdata
.rdata:00003284                 ;org 3284h
.rdata:00003284 ; COMDAT (pick any)
.rdata:00003284                 public ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@
.rdata:00003284 ; `string'
.rdata:00003284 ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@:
.rdata:00003284                                         ; DATA XREF: std::vector<MacroShortcut,std::allocator<MacroShortcut>>::operator[](uint)+6Fo
.rdata:00003284                 unicode 0, <"out of range">,0
.rdata:000032A2                 align 4
.rdata:000032A2 _rdata          ends
.rdata:000032A2
.rdata:000032A4 ; ===========================================================================
.rdata:000032A4
.rdata:000032A4 ; Segment type: Pure data
.rdata:000032A4 ; Segment permissions: Read
.rdata:000032A4 ; Segment alignment 'qword' can not be represented in assembly
.rdata:000032A4 _rdata          segment para public 'DATA' use32
.rdata:000032A4                 assume cs:_rdata
.rdata:000032A4                 ;org 32A4h
.rdata:000032A4 ; COMDAT (pick any)
.rdata:000032A4                 public ??_C@_1LC@OPANGMDH@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAM?$AAa?$AAc?$AAr?$AAo?$AAS?$AAh?$AAo?$AAr?$AAt?$AAc?$AAu?$AAt?$AA?0@
.rdata:000032A4 ; `string'
.rdata:000032A4 ??_C@_1LC@OPANGMDH@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAM?$AAa?$AAc?$AAr?$AAo?$AAS?$AAh?$AAo?$AAr?$AAt?$AAc?$AAu?$AAt?$AA?0@:
.rdata:000032A4                                         ; DATA XREF: std::vector<MacroShortcut,std::allocator<MacroShortcut>>::operator[](uint)+6Ao
.rdata:000032A4                 unicode 0, <std::vector>
.rdata:000032A4                 dw 3Ch
.rdata:000032A4                 unicode 0, <class MacroShortcut,class std::allocator>
.rdata:000032A4                 dw 3Ch
.rdata:000032A4                 unicode 0, <class MacroShortcut>
.rdata:000032A4                 dw 3Eh
.rdata:000032A4                 unicode 0, < >
.rdata:000032A4                 dw 3Eh
.rdata:000032A4                 unicode 0, <::operator []>,0
.rdata:00003356                 align 4
.rdata:00003356 _rdata          ends
.rdata:00003356
.rdata:00003358 ; ===========================================================================
.rdata:00003358
.rdata:00003358 ; Segment type: Pure data
.rdata:00003358 ; Segment permissions: Read
.rdata:00003358 _rdata          segment dword public 'DATA' use32
.rdata:00003358                 assume cs:_rdata
.rdata:00003358                 ;org 3358h
.rdata:00003358 ; COMDAT (pick any)
.rdata:00003358                 public ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
.rdata:00003358 ; char `string'[]
.rdata:00003358 ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ db 'string too long',0
.rdata:00003358                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+7o
.rdata:00003358 _rdata          ends
.rdata:00003358
.rdata:00003368 ; ===========================================================================
.rdata:00003368
.rdata:00003368 ; Segment type: Pure data
.rdata:00003368 ; Segment permissions: Read
.rdata:00003368 _rdata          segment dword public 'DATA' use32
.rdata:00003368                 assume cs:_rdata
.rdata:00003368                 ;org 3368h
.rdata:00003368 ; COMDAT (pick any)
.rdata:00003368                 public ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
.rdata:00003368 ; char `string'[]
.rdata:00003368 ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ db 'invalid string position',0
.rdata:00003368                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+7o
.rdata:00003368 _rdata          ends
.rdata:00003368
.rdata:00003380 ; ===========================================================================
.rdata:00003380
.rdata:00003380 ; Segment type: Pure data
.rdata:00003380 ; Segment permissions: Read
.rdata:00003380 _rdata          segment dword public 'DATA' use32
.rdata:00003380                 assume cs:_rdata
.rdata:00003380                 ;org 3380h
.rdata:00003380 ; COMDAT (pick any)
.rdata:00003380                 public ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
.rdata:00003380 ; wchar_t `string'
.rdata:00003380 ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@:
.rdata:00003380                                         ; DATA XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+11o
.rdata:00003380                 unicode 0, <invalid null pointer>,0
.rdata:000033AA                 align 4
.rdata:000033AA _rdata          ends
.rdata:000033AA
.rdata$r:000033AC ; ===========================================================================
.rdata$r:000033AC
.rdata$r:000033AC ; Segment type: Pure data
.rdata$r:000033AC ; Segment permissions: Read
.rdata$r:000033AC _rdata$r        segment dword public 'DATA' use32
.rdata$r:000033AC                 assume cs:_rdata$r
.rdata$r:000033AC                 ;org 33ACh
.rdata$r:000033AC ; COMDAT (pick any)
.rdata$r:000033AC                 public ??_R4error_category@std@@6B@
.rdata$r:000033AC ; const std::error_category::`RTTI Complete Object Locator'
.rdata$r:000033AC ??_R4error_category@std@@6B@ db    0    ; DATA XREF: .rdata:00002FD8o
.rdata$r:000033AD                 db    0
.rdata$r:000033AE                 db    0
.rdata$r:000033AF                 db    0
.rdata$r:000033B0                 db    0
.rdata$r:000033B1                 db    0
.rdata$r:000033B2                 db    0
.rdata$r:000033B3                 db    0
.rdata$r:000033B4                 db    0
.rdata$r:000033B5                 db    0
.rdata$r:000033B6                 db    0
.rdata$r:000033B7                 db    0
.rdata$r:000033B8                 dd offset ??_R0?AVerror_category@std@@@8 ; std::error_category `RTTI Type Descriptor'
.rdata$r:000033BC                 dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000033BC _rdata$r        ends
.rdata$r:000033BC
.data$r:000033C0 ; ===========================================================================
.data$r:000033C0
.data$r:000033C0 ; Segment type: Pure data
.data$r:000033C0 ; Segment permissions: Read/Write
.data$r:000033C0 _data$r         segment dword public 'DATA' use32
.data$r:000033C0                 assume cs:_data$r
.data$r:000033C0                 ;org 33C0h
.data$r:000033C0 ; COMDAT (pick any)
.data$r:000033C0                 public ??_R0?AVerror_category@std@@@8
.data$r:000033C0 ; class std::error_category `RTTI Type Descriptor'
.data$r:000033C0 ??_R0?AVerror_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:000033C0                                         ; DATA XREF: .rdata$r:000033B8o
.data$r:000033C0                                         ; .rdata$r:std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:000033C0                                         ; const type_info::`vftable'
.data$r:000033C4                 align 8
.data$r:000033C8 a_?averror_cate db '.?AVerror_category@std@@',0
.data$r:000033E1                 align 4
.data$r:000033E1 _data$r         ends
.data$r:000033E1
.rdata$r:000033E4 ; ===========================================================================
.rdata$r:000033E4
.rdata$r:000033E4 ; Segment type: Pure data
.rdata$r:000033E4 ; Segment permissions: Read
.rdata$r:000033E4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000033E4                 assume cs:_rdata$r
.rdata$r:000033E4                 ;org 33E4h
.rdata$r:000033E4 ; COMDAT (pick any)
.rdata$r:000033E4                 public ??_R3error_category@std@@8
.rdata$r:000033E4 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000033E4 ??_R3error_category@std@@8 db    0      ; DATA XREF: .rdata$r:000033BCo
.rdata$r:000033E4                                         ; .rdata$r:00003414o
.rdata$r:000033E5                 db    0
.rdata$r:000033E6                 db    0
.rdata$r:000033E7                 db    0
.rdata$r:000033E8                 db    0
.rdata$r:000033E9                 db    0
.rdata$r:000033EA                 db    0
.rdata$r:000033EB                 db    0
.rdata$r:000033EC                 db    1
.rdata$r:000033ED                 db    0
.rdata$r:000033EE                 db    0
.rdata$r:000033EF                 db    0
.rdata$r:000033F0                 dd offset ??_R2error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
.rdata$r:000033F0 _rdata$r        ends
.rdata$r:000033F0
.rdata$r:000033F4 ; ===========================================================================
.rdata$r:000033F4
.rdata$r:000033F4 ; Segment type: Pure data
.rdata$r:000033F4 ; Segment permissions: Read
.rdata$r:000033F4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000033F4                 assume cs:_rdata$r
.rdata$r:000033F4                 ;org 33F4h
.rdata$r:000033F4 ; COMDAT (pick any)
.rdata$r:000033F4                 public ??_R2error_category@std@@8
.rdata$r:000033F4 ; std::error_category::`RTTI Base Class Array'
.rdata$r:000033F4 ??_R2error_category@std@@8 dd offset ??_R1A@?0A@EA@error_category@std@@8
.rdata$r:000033F4                                         ; DATA XREF: .rdata$r:000033F0o
.rdata$r:000033F4                                         ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000033F8                 db    0
.rdata$r:000033F9                 align 4
.rdata$r:000033F9 _rdata$r        ends
.rdata$r:000033F9
.rdata$r:000033FC ; ===========================================================================
.rdata$r:000033FC
.rdata$r:000033FC ; Segment type: Pure data
.rdata$r:000033FC ; Segment permissions: Read
.rdata$r:000033FC _rdata$r        segment dword public 'DATA' use32
.rdata$r:000033FC                 assume cs:_rdata$r
.rdata$r:000033FC                 ;org 33FCh
.rdata$r:000033FC ; COMDAT (pick any)
.rdata$r:000033FC                 public ??_R1A@?0A@EA@error_category@std@@8
.rdata$r:000033FC ; std::error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:000033FC ??_R1A@?0A@EA@error_category@std@@8 dd offset ??_R0?AVerror_category@std@@@8
.rdata$r:000033FC                                         ; DATA XREF: .rdata$r:std::error_category::`RTTI Base Class Array'o
.rdata$r:000033FC                                         ; .rdata$r:0000346Co ...
.rdata$r:000033FC                                         ; std::error_category `RTTI Type Descriptor'
.rdata$r:00003400                 db    0
.rdata$r:00003401                 db    0
.rdata$r:00003402                 db    0
.rdata$r:00003403                 db    0
.rdata$r:00003404                 db    0
.rdata$r:00003405                 db    0
.rdata$r:00003406                 db    0
.rdata$r:00003407                 db    0
.rdata$r:00003408                 db 0FFh
.rdata$r:00003409                 db 0FFh
.rdata$r:0000340A                 db 0FFh
.rdata$r:0000340B                 db 0FFh
.rdata$r:0000340C                 db    0
.rdata$r:0000340D                 db    0
.rdata$r:0000340E                 db    0
.rdata$r:0000340F                 db    0
.rdata$r:00003410                 db  40h ; @
.rdata$r:00003411                 db    0
.rdata$r:00003412                 db    0
.rdata$r:00003413                 db    0
.rdata$r:00003414                 dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00003414 _rdata$r        ends
.rdata$r:00003414
.rdata$r:00003418 ; ===========================================================================
.rdata$r:00003418
.rdata$r:00003418 ; Segment type: Pure data
.rdata$r:00003418 ; Segment permissions: Read
.rdata$r:00003418 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003418                 assume cs:_rdata$r
.rdata$r:00003418                 ;org 3418h
.rdata$r:00003418 ; COMDAT (pick any)
.rdata$r:00003418                 public ??_R4_Generic_error_category@std@@6B@
.rdata$r:00003418 ; const std::_Generic_error_category::`RTTI Complete Object Locator'
.rdata$r:00003418 ??_R4_Generic_error_category@std@@6B@ db    0
.rdata$r:00003418                                         ; DATA XREF: .rdata:00002FF4o
.rdata$r:00003419                 db    0
.rdata$r:0000341A                 db    0
.rdata$r:0000341B                 db    0
.rdata$r:0000341C                 db    0
.rdata$r:0000341D                 db    0
.rdata$r:0000341E                 db    0
.rdata$r:0000341F                 db    0
.rdata$r:00003420                 db    0
.rdata$r:00003421                 db    0
.rdata$r:00003422                 db    0
.rdata$r:00003423                 db    0
.rdata$r:00003424                 dd offset ??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category `RTTI Type Descriptor'
.rdata$r:00003428                 dd offset ??_R3_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00003428 _rdata$r        ends
.rdata$r:00003428
.data$r:0000342C ; ===========================================================================
.data$r:0000342C
.data$r:0000342C ; Segment type: Pure data
.data$r:0000342C ; Segment permissions: Read/Write
.data$r:0000342C _data$r         segment dword public 'DATA' use32
.data$r:0000342C                 assume cs:_data$r
.data$r:0000342C                 ;org 342Ch
.data$r:0000342C ; COMDAT (pick any)
.data$r:0000342C                 public ??_R0?AV_Generic_error_category@std@@@8
.data$r:0000342C ; class std::_Generic_error_category `RTTI Type Descriptor'
.data$r:0000342C ??_R0?AV_Generic_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:0000342C                                         ; DATA XREF: .rdata$r:00003424o
.data$r:0000342C                                         ; .rdata$r:std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:0000342C                                         ; const type_info::`vftable'
.data$r:00003430                 db    0
.data$r:00003431                 db    0
.data$r:00003432                 db    0
.data$r:00003433                 db    0
.data$r:00003434                 db  2Eh ; .
.data$r:00003435                 db  3Fh ; ?
.data$r:00003436                 db  41h ; A
.data$r:00003437                 db  56h ; V
.data$r:00003438                 db  5Fh ; _
.data$r:00003439                 db  47h ; G
.data$r:0000343A                 db  65h ; e
.data$r:0000343B                 db  6Eh ; n
.data$r:0000343C                 db  65h ; e
.data$r:0000343D                 db  72h ; r
.data$r:0000343E                 db  69h ; i
.data$r:0000343F                 db  63h ; c
.data$r:00003440                 db  5Fh ; _
.data$r:00003441                 db  65h ; e
.data$r:00003442                 db  72h ; r
.data$r:00003443                 db  72h ; r
.data$r:00003444                 db  6Fh ; o
.data$r:00003445                 db  72h ; r
.data$r:00003446                 db  5Fh ; _
.data$r:00003447                 db  63h ; c
.data$r:00003448                 db  61h ; a
.data$r:00003449                 db  74h ; t
.data$r:0000344A                 db  65h ; e
.data$r:0000344B                 db  67h ; g
.data$r:0000344C                 db  6Fh ; o
.data$r:0000344D                 db  72h ; r
.data$r:0000344E                 db  79h ; y
.data$r:0000344F                 db  40h ; @
.data$r:00003450                 db  73h ; s
.data$r:00003451                 db  74h ; t
.data$r:00003452                 db  64h ; d
.data$r:00003453                 db  40h ; @
.data$r:00003454                 db  40h ; @
.data$r:00003455                 db    0
.data$r:00003456                 align 4
.data$r:00003456 _data$r         ends
.data$r:00003456
.rdata$r:00003458 ; ===========================================================================
.rdata$r:00003458
.rdata$r:00003458 ; Segment type: Pure data
.rdata$r:00003458 ; Segment permissions: Read
.rdata$r:00003458 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003458                 assume cs:_rdata$r
.rdata$r:00003458                 ;org 3458h
.rdata$r:00003458 ; COMDAT (pick any)
.rdata$r:00003458                 public ??_R3_Generic_error_category@std@@8
.rdata$r:00003458 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00003458 ??_R3_Generic_error_category@std@@8 db    0
.rdata$r:00003458                                         ; DATA XREF: .rdata$r:00003428o
.rdata$r:00003458                                         ; .rdata$r:0000348Co
.rdata$r:00003459                 db    0
.rdata$r:0000345A                 db    0
.rdata$r:0000345B                 db    0
.rdata$r:0000345C                 db    0
.rdata$r:0000345D                 db    0
.rdata$r:0000345E                 db    0
.rdata$r:0000345F                 db    0
.rdata$r:00003460                 db    2
.rdata$r:00003461                 db    0
.rdata$r:00003462                 db    0
.rdata$r:00003463                 db    0
.rdata$r:00003464                 dd offset ??_R2_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
.rdata$r:00003464 _rdata$r        ends
.rdata$r:00003464
.rdata$r:00003468 ; ===========================================================================
.rdata$r:00003468
.rdata$r:00003468 ; Segment type: Pure data
.rdata$r:00003468 ; Segment permissions: Read
.rdata$r:00003468 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003468                 assume cs:_rdata$r
.rdata$r:00003468                 ;org 3468h
.rdata$r:00003468 ; COMDAT (pick any)
.rdata$r:00003468                 public ??_R2_Generic_error_category@std@@8
.rdata$r:00003468 ; std::_Generic_error_category::`RTTI Base Class Array'
.rdata$r:00003468 ??_R2_Generic_error_category@std@@8 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8
.rdata$r:00003468                                         ; DATA XREF: .rdata$r:00003464o
.rdata$r:00003468                                         ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000346C                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00003470                 db    0
.rdata$r:00003471                 align 4
.rdata$r:00003471 _rdata$r        ends
.rdata$r:00003471
.rdata$r:00003474 ; ===========================================================================
.rdata$r:00003474
.rdata$r:00003474 ; Segment type: Pure data
.rdata$r:00003474 ; Segment permissions: Read
.rdata$r:00003474 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003474                 assume cs:_rdata$r
.rdata$r:00003474                 ;org 3474h
.rdata$r:00003474 ; COMDAT (pick any)
.rdata$r:00003474                 public ??_R1A@?0A@EA@_Generic_error_category@std@@8
.rdata$r:00003474 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00003474 ??_R1A@?0A@EA@_Generic_error_category@std@@8 dd offset ??_R0?AV_Generic_error_category@std@@@8
.rdata$r:00003474                                         ; DATA XREF: .rdata$r:std::_Generic_error_category::`RTTI Base Class Array'o
.rdata$r:00003474                                         ; .rdata$r:000034E4o ...
.rdata$r:00003474                                         ; std::_Generic_error_category `RTTI Type Descriptor'
.rdata$r:00003478                 db    1
.rdata$r:00003479                 db    0
.rdata$r:0000347A                 db    0
.rdata$r:0000347B                 db    0
.rdata$r:0000347C                 db    0
.rdata$r:0000347D                 db    0
.rdata$r:0000347E                 db    0
.rdata$r:0000347F                 db    0
.rdata$r:00003480                 db 0FFh
.rdata$r:00003481                 db 0FFh
.rdata$r:00003482                 db 0FFh
.rdata$r:00003483                 db 0FFh
.rdata$r:00003484                 db    0
.rdata$r:00003485                 db    0
.rdata$r:00003486                 db    0
.rdata$r:00003487                 db    0
.rdata$r:00003488                 db  40h ; @
.rdata$r:00003489                 db    0
.rdata$r:0000348A                 db    0
.rdata$r:0000348B                 db    0
.rdata$r:0000348C                 dd offset ??_R3_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000348C _rdata$r        ends
.rdata$r:0000348C
.rdata$r:00003490 ; ===========================================================================
.rdata$r:00003490
.rdata$r:00003490 ; Segment type: Pure data
.rdata$r:00003490 ; Segment permissions: Read
.rdata$r:00003490 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003490                 assume cs:_rdata$r
.rdata$r:00003490                 ;org 3490h
.rdata$r:00003490 ; COMDAT (pick any)
.rdata$r:00003490                 public ??_R4_Iostream_error_category@std@@6B@
.rdata$r:00003490 ; const std::_Iostream_error_category::`RTTI Complete Object Locator'
.rdata$r:00003490 ??_R4_Iostream_error_category@std@@6B@ db    0
.rdata$r:00003490                                         ; DATA XREF: .rdata:00003028o
.rdata$r:00003491                 db    0
.rdata$r:00003492                 db    0
.rdata$r:00003493                 db    0
.rdata$r:00003494                 db    0
.rdata$r:00003495                 db    0
.rdata$r:00003496                 db    0
.rdata$r:00003497                 db    0
.rdata$r:00003498                 db    0
.rdata$r:00003499                 db    0
.rdata$r:0000349A                 db    0
.rdata$r:0000349B                 db    0
.rdata$r:0000349C                 dd offset ??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category `RTTI Type Descriptor'
.rdata$r:000034A0                 dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000034A0 _rdata$r        ends
.rdata$r:000034A0
.data$r:000034A4 ; ===========================================================================
.data$r:000034A4
.data$r:000034A4 ; Segment type: Pure data
.data$r:000034A4 ; Segment permissions: Read/Write
.data$r:000034A4 _data$r         segment dword public 'DATA' use32
.data$r:000034A4                 assume cs:_data$r
.data$r:000034A4                 ;org 34A4h
.data$r:000034A4 ; COMDAT (pick any)
.data$r:000034A4                 public ??_R0?AV_Iostream_error_category@std@@@8
.data$r:000034A4 ; class std::_Iostream_error_category `RTTI Type Descriptor'
.data$r:000034A4 ??_R0?AV_Iostream_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:000034A4                                         ; DATA XREF: .rdata$r:0000349Co
.data$r:000034A4                                         ; .rdata$r:std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:000034A4                                         ; const type_info::`vftable'
.data$r:000034A8                 db    0
.data$r:000034A9                 db    0
.data$r:000034AA                 db    0
.data$r:000034AB                 db    0
.data$r:000034AC                 db  2Eh ; .
.data$r:000034AD                 db  3Fh ; ?
.data$r:000034AE                 db  41h ; A
.data$r:000034AF                 db  56h ; V
.data$r:000034B0                 db  5Fh ; _
.data$r:000034B1                 db  49h ; I
.data$r:000034B2                 db  6Fh ; o
.data$r:000034B3                 db  73h ; s
.data$r:000034B4                 db  74h ; t
.data$r:000034B5                 db  72h ; r
.data$r:000034B6                 db  65h ; e
.data$r:000034B7                 db  61h ; a
.data$r:000034B8                 db  6Dh ; m
.data$r:000034B9                 db  5Fh ; _
.data$r:000034BA                 db  65h ; e
.data$r:000034BB                 db  72h ; r
.data$r:000034BC                 db  72h ; r
.data$r:000034BD                 db  6Fh ; o
.data$r:000034BE                 db  72h ; r
.data$r:000034BF                 db  5Fh ; _
.data$r:000034C0                 db  63h ; c
.data$r:000034C1                 db  61h ; a
.data$r:000034C2                 db  74h ; t
.data$r:000034C3                 db  65h ; e
.data$r:000034C4                 db  67h ; g
.data$r:000034C5                 db  6Fh ; o
.data$r:000034C6                 db  72h ; r
.data$r:000034C7                 db  79h ; y
.data$r:000034C8                 db  40h ; @
.data$r:000034C9                 db  73h ; s
.data$r:000034CA                 db  74h ; t
.data$r:000034CB                 db  64h ; d
.data$r:000034CC                 db  40h ; @
.data$r:000034CD                 db  40h ; @
.data$r:000034CE                 db    0
.data$r:000034CF                 align 10h
.data$r:000034CF _data$r         ends
.data$r:000034CF
.rdata$r:000034D0 ; ===========================================================================
.rdata$r:000034D0
.rdata$r:000034D0 ; Segment type: Pure data
.rdata$r:000034D0 ; Segment permissions: Read
.rdata$r:000034D0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000034D0                 assume cs:_rdata$r
.rdata$r:000034D0                 ;org 34D0h
.rdata$r:000034D0 ; COMDAT (pick any)
.rdata$r:000034D0                 public ??_R3_Iostream_error_category@std@@8
.rdata$r:000034D0 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000034D0 ??_R3_Iostream_error_category@std@@8 db    0
.rdata$r:000034D0                                         ; DATA XREF: .rdata$r:000034A0o
.rdata$r:000034D0                                         ; .rdata$r:00003508o
.rdata$r:000034D1                 db    0
.rdata$r:000034D2                 db    0
.rdata$r:000034D3                 db    0
.rdata$r:000034D4                 db    0
.rdata$r:000034D5                 db    0
.rdata$r:000034D6                 db    0
.rdata$r:000034D7                 db    0
.rdata$r:000034D8                 db    3
.rdata$r:000034D9                 db    0
.rdata$r:000034DA                 db    0
.rdata$r:000034DB                 db    0
.rdata$r:000034DC                 dd offset ??_R2_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
.rdata$r:000034DC _rdata$r        ends
.rdata$r:000034DC
.rdata$r:000034E0 ; ===========================================================================
.rdata$r:000034E0
.rdata$r:000034E0 ; Segment type: Pure data
.rdata$r:000034E0 ; Segment permissions: Read
.rdata$r:000034E0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000034E0                 assume cs:_rdata$r
.rdata$r:000034E0                 ;org 34E0h
.rdata$r:000034E0 ; COMDAT (pick any)
.rdata$r:000034E0                 public ??_R2_Iostream_error_category@std@@8
.rdata$r:000034E0 ; std::_Iostream_error_category::`RTTI Base Class Array'
.rdata$r:000034E0 ??_R2_Iostream_error_category@std@@8 dd offset ??_R1A@?0A@EA@_Iostream_error_category@std@@8
.rdata$r:000034E0                                         ; DATA XREF: .rdata$r:000034DCo
.rdata$r:000034E0                                         ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000034E4                 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000034E8                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000034EC                 db    0
.rdata$r:000034ED                 align 10h
.rdata$r:000034ED _rdata$r        ends
.rdata$r:000034ED
.rdata$r:000034F0 ; ===========================================================================
.rdata$r:000034F0
.rdata$r:000034F0 ; Segment type: Pure data
.rdata$r:000034F0 ; Segment permissions: Read
.rdata$r:000034F0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000034F0                 assume cs:_rdata$r
.rdata$r:000034F0                 ;org 34F0h
.rdata$r:000034F0 ; COMDAT (pick any)
.rdata$r:000034F0                 public ??_R1A@?0A@EA@_Iostream_error_category@std@@8
.rdata$r:000034F0 ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:000034F0 ??_R1A@?0A@EA@_Iostream_error_category@std@@8 dd offset ??_R0?AV_Iostream_error_category@std@@@8
.rdata$r:000034F0                                         ; DATA XREF: .rdata$r:std::_Iostream_error_category::`RTTI Base Class Array'o
.rdata$r:000034F0                                         ; std::_Iostream_error_category `RTTI Type Descriptor'
.rdata$r:000034F4                 db    2
.rdata$r:000034F5                 db    0
.rdata$r:000034F6                 db    0
.rdata$r:000034F7                 db    0
.rdata$r:000034F8                 db    0
.rdata$r:000034F9                 db    0
.rdata$r:000034FA                 db    0
.rdata$r:000034FB                 db    0
.rdata$r:000034FC                 db 0FFh
.rdata$r:000034FD                 db 0FFh
.rdata$r:000034FE                 db 0FFh
.rdata$r:000034FF                 db 0FFh
.rdata$r:00003500                 db    0
.rdata$r:00003501                 db    0
.rdata$r:00003502                 db    0
.rdata$r:00003503                 db    0
.rdata$r:00003504                 db  40h ; @
.rdata$r:00003505                 db    0
.rdata$r:00003506                 db    0
.rdata$r:00003507                 db    0
.rdata$r:00003508                 dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00003508 _rdata$r        ends
.rdata$r:00003508
.rdata$r:0000350C ; ===========================================================================
.rdata$r:0000350C
.rdata$r:0000350C ; Segment type: Pure data
.rdata$r:0000350C ; Segment permissions: Read
.rdata$r:0000350C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000350C                 assume cs:_rdata$r
.rdata$r:0000350C                 ;org 350Ch
.rdata$r:0000350C ; COMDAT (pick any)
.rdata$r:0000350C                 public ??_R4_System_error_category@std@@6B@
.rdata$r:0000350C ; const std::_System_error_category::`RTTI Complete Object Locator'
.rdata$r:0000350C ??_R4_System_error_category@std@@6B@ db    0 ; DATA XREF: .rdata:00003068o
.rdata$r:0000350D                 db    0
.rdata$r:0000350E                 db    0
.rdata$r:0000350F                 db    0
.rdata$r:00003510                 db    0
.rdata$r:00003511                 db    0
.rdata$r:00003512                 db    0
.rdata$r:00003513                 db    0
.rdata$r:00003514                 db    0
.rdata$r:00003515                 db    0
.rdata$r:00003516                 db    0
.rdata$r:00003517                 db    0
.rdata$r:00003518                 dd offset ??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category `RTTI Type Descriptor'
.rdata$r:0000351C                 dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000351C _rdata$r        ends
.rdata$r:0000351C
.data$r:00003520 ; ===========================================================================
.data$r:00003520
.data$r:00003520 ; Segment type: Pure data
.data$r:00003520 ; Segment permissions: Read/Write
.data$r:00003520 _data$r         segment dword public 'DATA' use32
.data$r:00003520                 assume cs:_data$r
.data$r:00003520                 ;org 3520h
.data$r:00003520 ; COMDAT (pick any)
.data$r:00003520                 public ??_R0?AV_System_error_category@std@@@8
.data$r:00003520 ; class std::_System_error_category `RTTI Type Descriptor'
.data$r:00003520 ??_R0?AV_System_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00003520                                         ; DATA XREF: .rdata$r:00003518o
.data$r:00003520                                         ; .rdata$r:std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00003520                                         ; const type_info::`vftable'
.data$r:00003524                 align 8
.data$r:00003528 a_?av_system_er db '.?AV_System_error_category@std@@',0
.data$r:00003549                 align 4
.data$r:00003549 _data$r         ends
.data$r:00003549
.rdata$r:0000354C ; ===========================================================================
.rdata$r:0000354C
.rdata$r:0000354C ; Segment type: Pure data
.rdata$r:0000354C ; Segment permissions: Read
.rdata$r:0000354C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000354C                 assume cs:_rdata$r
.rdata$r:0000354C                 ;org 354Ch
.rdata$r:0000354C ; COMDAT (pick any)
.rdata$r:0000354C                 public ??_R3_System_error_category@std@@8
.rdata$r:0000354C ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000354C ??_R3_System_error_category@std@@8 db    0 ; DATA XREF: .rdata$r:0000351Co
.rdata$r:0000354C                                         ; .rdata$r:00003584o
.rdata$r:0000354D                 db    0
.rdata$r:0000354E                 db    0
.rdata$r:0000354F                 db    0
.rdata$r:00003550                 db    0
.rdata$r:00003551                 db    0
.rdata$r:00003552                 db    0
.rdata$r:00003553                 db    0
.rdata$r:00003554                 db    3
.rdata$r:00003555                 db    0
.rdata$r:00003556                 db    0
.rdata$r:00003557                 db    0
.rdata$r:00003558                 dd offset ??_R2_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
.rdata$r:00003558 _rdata$r        ends
.rdata$r:00003558
.rdata$r:0000355C ; ===========================================================================
.rdata$r:0000355C
.rdata$r:0000355C ; Segment type: Pure data
.rdata$r:0000355C ; Segment permissions: Read
.rdata$r:0000355C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000355C                 assume cs:_rdata$r
.rdata$r:0000355C                 ;org 355Ch
.rdata$r:0000355C ; COMDAT (pick any)
.rdata$r:0000355C                 public ??_R2_System_error_category@std@@8
.rdata$r:0000355C ; std::_System_error_category::`RTTI Base Class Array'
.rdata$r:0000355C ??_R2_System_error_category@std@@8 dd offset ??_R1A@?0A@EA@_System_error_category@std@@8
.rdata$r:0000355C                                         ; DATA XREF: .rdata$r:00003558o
.rdata$r:0000355C                                         ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00003560                 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00003564                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00003568                 db    0
.rdata$r:00003569                 align 4
.rdata$r:00003569 _rdata$r        ends
.rdata$r:00003569
.rdata$r:0000356C ; ===========================================================================
.rdata$r:0000356C
.rdata$r:0000356C ; Segment type: Pure data
.rdata$r:0000356C ; Segment permissions: Read
.rdata$r:0000356C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000356C                 assume cs:_rdata$r
.rdata$r:0000356C                 ;org 356Ch
.rdata$r:0000356C ; COMDAT (pick any)
.rdata$r:0000356C                 public ??_R1A@?0A@EA@_System_error_category@std@@8
.rdata$r:0000356C ; std::_System_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000356C ??_R1A@?0A@EA@_System_error_category@std@@8 dd offset ??_R0?AV_System_error_category@std@@@8
.rdata$r:0000356C                                         ; DATA XREF: .rdata$r:std::_System_error_category::`RTTI Base Class Array'o
.rdata$r:0000356C                                         ; std::_System_error_category `RTTI Type Descriptor'
.rdata$r:00003570                 db    2
.rdata$r:00003571                 db    0
.rdata$r:00003572                 db    0
.rdata$r:00003573                 db    0
.rdata$r:00003574                 db    0
.rdata$r:00003575                 db    0
.rdata$r:00003576                 db    0
.rdata$r:00003577                 db    0
.rdata$r:00003578                 db 0FFh
.rdata$r:00003579                 db 0FFh
.rdata$r:0000357A                 db 0FFh
.rdata$r:0000357B                 db 0FFh
.rdata$r:0000357C                 db    0
.rdata$r:0000357D                 db    0
.rdata$r:0000357E                 db    0
.rdata$r:0000357F                 db    0
.rdata$r:00003580                 db  40h ; @
.rdata$r:00003581                 db    0
.rdata$r:00003582                 db    0
.rdata$r:00003583                 db    0
.rdata$r:00003584                 dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00003584 _rdata$r        ends
.rdata$r:00003584
.CRT$XCU:00003588 ; ===========================================================================
.CRT$XCU:00003588
.CRT$XCU:00003588 ; Segment type: Pure data
.CRT$XCU:00003588 ; Segment permissions: Read
.CRT$XCU:00003588 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00003588                 assume cs:_CRT$XCU
.CRT$XCU:00003588                 ;org 3588h
.CRT$XCU:00003588 _piecewise_construct$initializer$ dd offset ??__Epiecewise_construct@std@@YAXXZ ; std::`dynamic initializer for 'piecewise_construct''(void)
.CRT$XCU:0000358C _allocator_arg$initializer$ dd offset ??__Eallocator_arg@std@@YAXXZ ; std::`dynamic initializer for 'allocator_arg''(void)
.CRT$XCU:00003590 _ignore$initializer$ dd offset ??__Eignore@std@@YAXXZ ; std::`dynamic initializer for 'ignore''(void)
.CRT$XCU:00003594 __Tuple_alloc$initializer$ dd offset ??__E_Tuple_alloc@std@@YAXXZ ; std::`dynamic initializer for '_Tuple_alloc''(void)
.CRT$XCU:00003594 _CRT$XCU        ends
.CRT$XCU:00003594
.CRT$XCU:00003598 ; ===========================================================================
.CRT$XCU:00003598
.CRT$XCU:00003598 ; Segment type: Pure data
.CRT$XCU:00003598 ; Segment permissions: Read
.CRT$XCU:00003598 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00003598                 assume cs:_CRT$XCU
.CRT$XCU:00003598                 ;org 3598h
.CRT$XCU:00003598 ; COMDAT (pick associative to section at 308C)
.CRT$XCU:00003598 ; public: static void (__cdecl *std::_Error_objects<int>::_Generic_object$initializer$)(void)
.CRT$XCU:00003598 ?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
.CRT$XCU:00003598 _CRT$XCU        ends
.CRT$XCU:00003598
.CRT$XCU:0000359C ; ===========================================================================
.CRT$XCU:0000359C
.CRT$XCU:0000359C ; Segment type: Pure data
.CRT$XCU:0000359C ; Segment permissions: Read
.CRT$XCU:0000359C _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0000359C                 assume cs:_CRT$XCU
.CRT$XCU:0000359C                 ;org 359Ch
.CRT$XCU:0000359C ; COMDAT (pick associative to section at 3090)
.CRT$XCU:0000359C ; public: static void (__cdecl *std::_Error_objects<int>::_Iostream_object$initializer$)(void)
.CRT$XCU:0000359C ?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
.CRT$XCU:0000359C _CRT$XCU        ends
.CRT$XCU:0000359C
.CRT$XCU:000035A0 ; ===========================================================================
.CRT$XCU:000035A0
.CRT$XCU:000035A0 ; Segment type: Pure data
.CRT$XCU:000035A0 ; Segment permissions: Read
.CRT$XCU:000035A0 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:000035A0                 assume cs:_CRT$XCU
.CRT$XCU:000035A0                 ;org 35A0h
.CRT$XCU:000035A0 ; COMDAT (pick associative to section at 3094)
.CRT$XCU:000035A0 ; public: static void (__cdecl *std::_Error_objects<int>::_System_object$initializer$)(void)
.CRT$XCU:000035A0 ?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)
.CRT$XCU:000035A0 _CRT$XCU        ends
.CRT$XCU:000035A0
.CRT$XCU:000035A4 ; ===========================================================================
.CRT$XCU:000035A4
.CRT$XCU:000035A4 ; Segment type: Pure data
.CRT$XCU:000035A4 ; Segment permissions: Read
.CRT$XCU:000035A4 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:000035A4                 assume cs:_CRT$XCU
.CRT$XCU:000035A4                 ;org 35A4h
.CRT$XCU:000035A4 ; COMDAT (pick associative to section at 3098)
.CRT$XCU:000035A4 ; public: static void (__cdecl *std::num_put<char, class std::back_insert_iterator<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>::id$initializer$)(void)
.CRT$XCU:000035A4 ?id$initializer$@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2P6AXXZA dd offset ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)
.CRT$XCU:000035A4 _CRT$XCU        ends
.CRT$XCU:000035A4
.CRT$XCU:000035A8 ; ===========================================================================
.CRT$XCU:000035A8
.CRT$XCU:000035A8 ; Segment type: Pure data
.CRT$XCU:000035A8 ; Segment permissions: Read
.CRT$XCU:000035A8 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:000035A8                 assume cs:_CRT$XCU
.CRT$XCU:000035A8                 ;org 35A8h
.CRT$XCU:000035A8 ; COMDAT (pick associative to section at 309C)
.CRT$XCU:000035A8 ; public: static void (__cdecl *std::num_put<wchar_t, class std::back_insert_iterator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::id$initializer$)(void)
.CRT$XCU:000035A8 ?id$initializer$@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2P6AXXZA dd offset ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)
.CRT$XCU:000035A8 _CRT$XCU        ends
.CRT$XCU:000035A8
.CRT$XCU:000035AC ; ===========================================================================
.CRT$XCU:000035AC
.CRT$XCU:000035AC ; Segment type: Pure data
.CRT$XCU:000035AC ; Segment permissions: Read
.CRT$XCU:000035AC _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:000035AC                 assume cs:_CRT$XCU
.CRT$XCU:000035AC                 ;org 35ACh
.CRT$XCU:000035AC ; COMDAT (pick associative to section at 3130)
.CRT$XCU:000035AC ; public: static void (__cdecl *std::numpunct<char>::id$initializer$)(void)
.CRT$XCU:000035AC ?id$initializer$@?$numpunct@D@std@@2P6AXXZA dd offset ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::numpunct<char>::id''(void)
.CRT$XCU:000035AC _CRT$XCU        ends
.CRT$XCU:000035AC
.CRT$XCU:000035B0 ; ===========================================================================
.CRT$XCU:000035B0
.CRT$XCU:000035B0 ; Segment type: Pure data
.CRT$XCU:000035B0 ; Segment permissions: Read
.CRT$XCU:000035B0 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:000035B0                 assume cs:_CRT$XCU
.CRT$XCU:000035B0                 ;org 35B0h
.CRT$XCU:000035B0 ; COMDAT (pick associative to section at 3134)
.CRT$XCU:000035B0 ; public: static void (__cdecl *std::numpunct<wchar_t>::id$initializer$)(void)
.CRT$XCU:000035B0 ?id$initializer$@?$numpunct@_W@std@@2P6AXXZA dd offset ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::numpunct<wchar_t>::id''(void)
.CRT$XCU:000035B0 _CRT$XCU        ends
.CRT$XCU:000035B0
UNDEF:000035C0 ; ===========================================================================
UNDEF:000035C0
UNDEF:000035C0 ; Segment type: Externs
UNDEF:000035C0 ; UNDEF
UNDEF:000035C0                 extrn __purecall:near   ; DATA XREF: .rdata:00002FE0o
UNDEF:000035C0                                         ; .rdata:00002FE4o
UNDEF:000035C4 ; void *__cdecl operator new(unsigned int)
UNDEF:000035C4                 extrn ??2@YAPAXI@Z:near ; CODE XREF: std::_Allocate<char>(uint,char *)+1Dp
UNDEF:000035C4                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+23p
UNDEF:000035C8 ; void __cdecl operator delete(void *)
UNDEF:000035C8                 extrn ??3@YAXPAX@Z:near ; CODE XREF: std::_Generic_error_category::`scalar deleting destructor'(uint)+1Bp
UNDEF:000035C8                                         ; std::_Iostream_error_category::`scalar deleting destructor'(uint)+1Bp ...
UNDEF:000035CC ; int __cdecl atexit(void (__cdecl *)())
UNDEF:000035CC                 extrn _atexit:near      ; CODE XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+12p
UNDEF:000035CC                                         ; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+12p ...
UNDEF:000035D0                 extrn __invalid_parameter:near
UNDEF:000035D0                                         ; CODE XREF: std::vector<MacroShortcut,std::allocator<MacroShortcut>>::operator[](uint)+74p
UNDEF:000035D4 ; void *__cdecl memcpy(void *Dst, const void *Src, size_t Size)
UNDEF:000035D4                 extrn _memcpy:near      ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+1Ep
UNDEF:000035D8 ; size_t __cdecl strlen(const char *Str)
UNDEF:000035D8                 extrn _strlen:near      ; CODE XREF: std::char_traits<char>::length(char const *)+1Bp
UNDEF:000035DC ; void *__cdecl memmove(void *Dst, const void *Src, size_t Size)
UNDEF:000035DC                 extrn _memmove:near     ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+1Ep
UNDEF:000035E0 ; LRESULT __stdcall SendMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
UNDEF:000035E0                 extrn __imp__SendMessageW@16:near
UNDEF:000035E0                                         ; CODE XREF: RunMacroDlg::initMacroList(void)+60p
UNDEF:000035E0                                         ; RunMacroDlg::getMacro2Exec(void)+19p ...
UNDEF:000035E4 ; BOOL __stdcall ShowWindow(HWND hWnd, int nCmdShow)
UNDEF:000035E4                 extrn __imp__ShowWindow@8:near
UNDEF:000035E4                                         ; CODE XREF: RunMacroDlg::run_dlgProc(uint,uint,long)+118p
UNDEF:000035E4                                         ; DATA XREF: RunMacroDlg::run_dlgProc(uint,uint,long)+118r
UNDEF:000035E8 ; HWND __stdcall GetDlgItem(HWND hDlg, int nIDDlgItem)
UNDEF:000035E8                 extrn __imp__GetDlgItem@8:near
UNDEF:000035E8                                         ; CODE XREF: StaticDialog::isCheckedOrNot(int)+1Dp
UNDEF:000035E8                                         ; DATA XREF: StaticDialog::isCheckedOrNot(int)+1Dr
UNDEF:000035EC ; BOOL __stdcall SetDlgItemInt(HWND hDlg, int nIDDlgItem, UINT uValue, BOOL bSigned)
UNDEF:000035EC                 extrn __imp__SetDlgItemInt@16:near
UNDEF:000035EC                                         ; CODE XREF: RunMacroDlg::run_dlgProc(uint,uint,long)+44p
UNDEF:000035EC                                         ; DATA XREF: RunMacroDlg::run_dlgProc(uint,uint,long)+44r
UNDEF:000035F0 ; UINT __stdcall GetDlgItemInt(HWND hDlg, int nIDDlgItem, BOOL *lpTranslated, BOOL bSigned)
UNDEF:000035F0                 extrn __imp__GetDlgItemInt@16:near
UNDEF:000035F0                                         ; CODE XREF: RunMacroDlg::run_dlgProc(uint,uint,long)+156p
UNDEF:000035F0                                         ; DATA XREF: RunMacroDlg::run_dlgProc(uint,uint,long)+156r
UNDEF:000035F4 ; LRESULT __stdcall SendDlgItemMessageW(HWND hDlg, int nIDDlgItem, UINT Msg, WPARAM wParam, LPARAM lParam)
UNDEF:000035F4                 extrn __imp__SendDlgItemMessageW@20:near
UNDEF:000035F4                                         ; CODE XREF: RunMacroDlg::initMacroList(void)+4Ap
UNDEF:000035F4                                         ; RunMacroDlg::initMacroList(void)+83p ...
UNDEF:000035F8 ; void __thiscall StaticDialog::goToCenter(StaticDialog *__hidden this)
UNDEF:000035F8                 extrn ?goToCenter@StaticDialog@@QAEXXZ:near
UNDEF:000035F8                                         ; CODE XREF: RunMacroDlg::run_dlgProc(uint,uint,long)+9Bp
UNDEF:000035FC ; _DWORD __thiscall std::_Lockit::_Lockit(std::_Lockit *__hidden this, int)
UNDEF:000035FC                 extrn ??0_Lockit@std@@QAE@H@Z:near
UNDEF:000035FC                                         ; CODE XREF: std::_Container_base12::_Orphan_all(void)+35p
UNDEF:00003600 ; _DWORD __thiscall std::_Lockit::~_Lockit(std::_Lockit *__hidden this)
UNDEF:00003600                 extrn ??1_Lockit@std@@QAE@XZ:near
UNDEF:00003600                                         ; CODE XREF: std::_Container_base12::_Orphan_all(void)+86p
UNDEF:00003600                                         ; __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0+3j
UNDEF:00003604                 extrn __hypot:near      ; CODE XREF: _hypot+1Dp
UNDEF:00003608                 extrn __CrtDbgReportW:near
UNDEF:00003608                                         ; CODE XREF: std::vector<MacroShortcut,std::allocator<MacroShortcut>>::operator[](uint)+50p
UNDEF:0000360C ; void __cdecl std::_Debug_message(const wchar_t *, const wchar_t *, unsigned int)
UNDEF:0000360C                 extrn ?_Debug_message@std@@YAXPB_W0I@Z:near
UNDEF:0000360C                                         ; CODE XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+16p
UNDEF:0000360C                                         ; std::vector<MacroShortcut,std::allocator<MacroShortcut>>::operator[](uint)+23p
UNDEF:00003610 ; void __cdecl std::_Xbad_alloc()
UNDEF:00003610                 extrn ?_Xbad_alloc@std@@YAXXZ:near
UNDEF:00003610                                         ; CODE XREF: std::_Allocate<char>(uint,char *):loc_11EEp
UNDEF:00003610                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *):loc_1230p
UNDEF:00003614 ; void __cdecl std::_Xlength_error(const char *)
UNDEF:00003614                 extrn ?_Xlength_error@std@@YAXPBD@Z:near
UNDEF:00003614                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+Cp
UNDEF:00003618 ; void __cdecl std::_Xout_of_range(const char *)
UNDEF:00003618                 extrn ?_Xout_of_range@std@@YAXPBD@Z:near
UNDEF:00003618                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+Cp
UNDEF:0000361C ; public: virtual void * __thiscall std::error_category::`vector deleting destructor'(unsigned int)
UNDEF:0000361C                 extrn ??_Eerror_category@std@@UAEPAXI@Z:near ; weak
UNDEF:0000361C                                         ; DATA XREF: .rdata:const std::error_category::`vftable'o
UNDEF:00003620 ; const char *__cdecl std::_Syserror_map(int)
UNDEF:00003620                 extrn ?_Syserror_map@std@@YAPBDH@Z:near
UNDEF:00003620                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+Bp
UNDEF:00003620                                         ; std::_Generic_error_category::message(int)+33p
UNDEF:00003624 ; const char *__cdecl std::_Winerror_map(int)
UNDEF:00003624                 extrn ?_Winerror_map@std@@YAPBDH@Z:near
UNDEF:00003624                                         ; CODE XREF: std::_System_error_category::message(int)+33p
UNDEF:00003628 ; public: virtual void * __thiscall std::_Generic_error_category::`vector deleting destructor'(unsigned int)
UNDEF:00003628                 extrn ??_E_Generic_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00003628                                         ; DATA XREF: .rdata:const std::_Generic_error_category::`vftable'o
UNDEF:0000362C ; public: virtual void * __thiscall std::_Iostream_error_category::`vector deleting destructor'(unsigned int)
UNDEF:0000362C                 extrn ??_E_Iostream_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:0000362C                                         ; DATA XREF: .rdata:const std::_Iostream_error_category::`vftable'o
UNDEF:00003630 ; public: virtual void * __thiscall std::_System_error_category::`vector deleting destructor'(unsigned int)
UNDEF:00003630                 extrn ??_E_System_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00003630                                         ; DATA XREF: .rdata:const std::_System_error_category::`vftable'o
UNDEF:00003634 ; __fastcall __security_check_cookie(x)
UNDEF:00003634                 extrn @__security_check_cookie@4:near
UNDEF:00003634                                         ; CODE XREF: __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z+Cp
UNDEF:00003634                                         ; __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z+Cp ...
UNDEF:00003638 ; __stdcall _CxxThrowException(x, x)
UNDEF:00003638                 extrn __CxxThrowException@8:near
UNDEF:00003638                                         ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1+10p
UNDEF:0000363C                 extrn ___CxxFrameHandler3:near
UNDEF:0000363C                                         ; CODE XREF: __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z+16j
UNDEF:0000363C                                         ; __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z+16j ...
UNDEF:00003640 ; const type_info::`vftable'
UNDEF:00003640                 extrn ??_7type_info@@6B@:near
UNDEF:00003640                                         ; DATA XREF: .data$r:std::error_category `RTTI Type Descriptor'o
UNDEF:00003640                                         ; .data$r:std::_Generic_error_category `RTTI Type Descriptor'o ...
UNDEF:00003644 ; private: static class NppParameters * NppParameters::_pSelf
UNDEF:00003644                 extrn ?_pSelf@NppParameters@@0PAV1@A:near
UNDEF:00003644                                         ; DATA XREF: NppParameters::getInstance(void)+3r
UNDEF:00003648                 extrn ___security_cookie:near
UNDEF:00003648                                         ; DATA XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+14r
UNDEF:00003648                                         ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+14r ...
UNDEF:0000364C                 extrn __fltused:near
UNDEF:0000364C
UNDEF:0000364C
UNDEF:0000364C                 end