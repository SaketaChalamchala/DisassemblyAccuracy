.bss:00000000 ;
.bss:00000000 ; +-------------------------------------------------------------------------+
.bss:00000000 ; |   This file has been generated by The Interactive Disassembler (IDA)    |
.bss:00000000 ; |           Copyright (c) 2015 Hex-Rays, <support@hex-rays.com>           |
.bss:00000000 ; |                      License info: 48-3677-7074-51                      |
.bss:00000000 ; |             Michalis Polychronakis, Stony Brook University              |
.bss:00000000 ; +-------------------------------------------------------------------------+
.bss:00000000 ;
.bss:00000000 ; Input MD5   : A295C9E4599F19ABBBC99EA528FECD7F
.bss:00000000 ; Input CRC32 : 89A4BAA8
.bss:00000000
.bss:00000000 ; File Name   : C:\workspace\notepad-plus-plus-6.7.9.2\PowerEditor\visual.net\Unicode Debug\DockingSplitter.obj
.bss:00000000 ; Format      : COFF (X386MAGIC)
.bss:00000000 ; includelib "uuid.lib"
.bss:00000000 ; includelib "libcpmtd"
.bss:00000000 ; must resolve: ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
.bss:00000000 ; must resolve: ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
.bss:00000000 ; must resolve: ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
.bss:00000000 ; must resolve: ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
.bss:00000000 ; must resolve: ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
.bss:00000000 ; must resolve: ?id@?$numpunct@D@std@@2V0locale@2@A
.bss:00000000 ; must resolve: ?id@?$numpunct@_W@std@@2V0locale@2@A
.bss:00000000 ; includelib "LIBCMTD"
.bss:00000000 ; includelib "OLDNAMES"
.bss:00000000
.bss:00000000                 include uni.inc ; see unicode subdir of ida for info on unicode
.bss:00000000
.bss:00000000                 .686p
.bss:00000000                 .mmx
.bss:00000000                 .model flat
.bss:00000000
.bss:00000000 ; ===========================================================================
.bss:00000000
.bss:00000000 ; Segment type: Uninitialized
.bss:00000000 ; Segment permissions: Read/Write
.bss:00000000 _bss            segment dword public 'BSS' use32
.bss:00000000                 assume cs:_bss
.bss:00000000                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00000000                 public ?_isVertReg@DockingSplitter@@0HA
.bss:00000000 ; private: static int DockingSplitter::_isVertReg
.bss:00000000 ?_isVertReg@DockingSplitter@@0HA dd ?   ; DATA XREF: DockingSplitter::init(HINSTANCE__ *,HWND__ *,HWND__ *,uint):loc_1CCr
.bss:00000000                                         ; DockingSplitter::init(HINSTANCE__ *,HWND__ *,HWND__ *,uint):loc_261w
.bss:00000004                 public ?_isHoriReg@DockingSplitter@@0HA
.bss:00000004 ; private: static int DockingSplitter::_isHoriReg
.bss:00000004 ?_isHoriReg@DockingSplitter@@0HA dd ?   ; DATA XREF: DockingSplitter::init(HINSTANCE__ *,HWND__ *,HWND__ *,uint):loc_1BBr
.bss:00000004                                         ; DockingSplitter::init(HINSTANCE__ *,HWND__ *,HWND__ *,uint)+FDw
.bss:00000008 ; HWND hWndMouse
.bss:00000008 _hWndMouse      dd ?                    ; DATA XREF: DockingSplitter::runProc(HWND__ *,uint,uint,long)+87w
.bss:00000008                                         ; hookProcMouse(uint,uint,long)+49r ...
.bss:0000000C ; HHOOK hookMouse
.bss:0000000C _hookMouse      dd ?                    ; DATA XREF: DockingSplitter::runProc(HWND__ *,uint,uint,long)+A6w
.bss:0000000C                                         ; DockingSplitter::runProc(HWND__ *,uint,uint,long)+ABr ...
.bss:00000010 _allocator_arg  db    ? ;
.bss:00000011 _piecewise_construct db    ? ;
.bss:00000012                 align 4
.bss:00000012 _bss            ends
.bss:00000012
.rdata:00000014 ; ===========================================================================
.rdata:00000014
.rdata:00000014 ; Segment type: Pure data
.rdata:00000014 ; Segment permissions: Read
.rdata:00000014 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00000014 _rdata          segment para public 'DATA' use32
.rdata:00000014                 assume cs:_rdata
.rdata:00000014                 ;org 14h
.rdata:00000014 $SG123139:                              ; DATA XREF: DockingSplitter::init(HINSTANCE__ *,HWND__ *,HWND__ *,uint)+43o
.rdata:00000014                 unicode 0, <nsdockspliter>,0
.rdata:00000030 $SG123144:                              ; DATA XREF: DockingSplitter::init(HINSTANCE__ *,HWND__ *,HWND__ *,uint)+5Co
.rdata:00000030                 unicode 0, <wedockspliter>,0
.rdata:0000004C ; char _SG123152[]
.rdata:0000004C $SG123152       db 'DockingSplitter::init : RegisterClass() function failed',0
.rdata:0000004C                                         ; DATA XREF: DockingSplitter::init(HINSTANCE__ *,HWND__ *,HWND__ *,uint)+D8o
.rdata:00000084 ; const WCHAR _SG123161
.rdata:00000084 $SG123161       dw 0                    ; DATA XREF: DockingSplitter::init(HINSTANCE__ *,HWND__ *,HWND__ *,uint)+140o
.rdata:00000086                 align 4
.rdata:00000088 ; char _SG123165[]
.rdata:00000088 $SG123165       db 'DockingSplitter::init : CreateWindowEx() function return null',0
.rdata:00000088                                         ; DATA XREF: DockingSplitter::init(HINSTANCE__ *,HWND__ *,HWND__ *,uint)+160o
.rdata:000000C6                 align 4
.rdata:000000C8 ; const WCHAR _SG123200
.rdata:000000C8 $SG123200:                              ; DATA XREF: DockingSplitter::runProc(HWND__ *,uint,uint,long)+C7o
.rdata:000000C8                 unicode 0, <GetLastError() returned %lu>,0
.rdata:00000100                 db    0
.rdata:00000101                 db    0
.rdata:00000102                 db    0
.rdata:00000103                 db    0
.rdata:00000104 ; const WCHAR _SG123201
.rdata:00000104 $SG123201:                              ; DATA XREF: DockingSplitter::runProc(HWND__ *,uint,uint,long)+DEo
.rdata:00000104                 unicode 0, <SetWindowsHookEx(MOUSE) failed on runProc>,0
.rdata:00000104 _rdata          ends
.rdata:00000104
.text$mn:00000158 ; ===========================================================================
.text$mn:00000158
.text$mn:00000158 ; Segment type: Pure code
.text$mn:00000158 ; Segment permissions: Read/Execute
.text$mn:00000158 _text$mn        segment para public 'CODE' use32
.text$mn:00000158                 assume cs:_text$mn
.text$mn:00000158                 ;org 158h
.text$mn:00000158                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000158
.text$mn:00000158 ; =============== S U B R O U T I N E =======================================
.text$mn:00000158
.text$mn:00000158 ; Attributes: bp-based frame
.text$mn:00000158
.text$mn:00000158 ; void __thiscall DockingSplitter::init(DockingSplitter *this, HINSTANCE, HWND, HWND, unsigned int)
.text$mn:00000158                 public ?init@DockingSplitter@@QAEXPAUHINSTANCE__@@PAUHWND__@@1I@Z
.text$mn:00000158 ?init@DockingSplitter@@QAEXPAUHINSTANCE__@@PAUHWND__@@1I@Z proc near
.text$mn:00000158
.text$mn:00000158 WndClass        = WNDCLASSW ptr -44h
.text$mn:00000158 var_1C          = byte ptr -1Ch
.text$mn:00000158 var_10          = byte ptr -10h
.text$mn:00000158 lpParam         = dword ptr -4
.text$mn:00000158 arg_0           = dword ptr  8
.text$mn:00000158 arg_4           = dword ptr  0Ch
.text$mn:00000158 arg_8           = dword ptr  10h
.text$mn:00000158 arg_C           = dword ptr  14h
.text$mn:00000158
.text$mn:00000158                 push    ebp
.text$mn:00000159                 mov     ebp, esp
.text$mn:0000015B                 sub     esp, 44h
.text$mn:0000015E                 mov     [ebp+lpParam], ecx
.text$mn:00000161                 mov     eax, [ebp+arg_4]
.text$mn:00000164                 push    eax             ; HWND
.text$mn:00000165                 mov     ecx, [ebp+arg_0]
.text$mn:00000168                 push    ecx             ; HINSTANCE
.text$mn:00000169                 mov     ecx, [ebp+lpParam] ; this
.text$mn:0000016C                 call    ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z ; Window::init(HINSTANCE__ *,HWND__ *)
.text$mn:00000171                 mov     edx, [ebp+lpParam]
.text$mn:00000174                 mov     eax, [ebp+arg_8]
.text$mn:00000177                 mov     [edx+10h], eax
.text$mn:0000017A                 mov     ecx, [ebp+lpParam]
.text$mn:0000017D                 mov     edx, [ebp+arg_C]
.text$mn:00000180                 mov     [ecx+20h], edx
.text$mn:00000183                 mov     eax, [ebp+arg_C]
.text$mn:00000186                 and     eax, 2
.text$mn:00000189                 jz      short loc_1A4
.text$mn:0000018B                 push    7F85h           ; lpCursorName
.text$mn:00000190                 push    0               ; hInstance
.text$mn:00000192                 call    dword ptr ds:__imp__LoadCursorW@8 ; LoadCursorW(x,x)
.text$mn:00000198                 mov     [ebp+WndClass.hCursor], eax
.text$mn:0000019B                 mov     [ebp+WndClass.lpszClassName], offset $SG123139 ; "nsdockspliter"
.text$mn:000001A2                 jmp     short loc_1BB
.text$mn:000001A4 ; ---------------------------------------------------------------------------
.text$mn:000001A4
.text$mn:000001A4 loc_1A4:                                ; CODE XREF: DockingSplitter::init(HINSTANCE__ *,HWND__ *,HWND__ *,uint)+31j
.text$mn:000001A4                 push    7F84h           ; lpCursorName
.text$mn:000001A9                 push    0               ; hInstance
.text$mn:000001AB                 call    dword ptr ds:__imp__LoadCursorW@8 ; LoadCursorW(x,x)
.text$mn:000001B1                 mov     [ebp+WndClass.hCursor], eax
.text$mn:000001B4                 mov     [ebp+WndClass.lpszClassName], offset $SG123144 ; "wedockspliter"
.text$mn:000001BB
.text$mn:000001BB loc_1BB:                                ; CODE XREF: DockingSplitter::init(HINSTANCE__ *,HWND__ *,HWND__ *,uint)+4Aj
.text$mn:000001BB                 cmp     ds:?_isHoriReg@DockingSplitter@@0HA, 0 ; int DockingSplitter::_isHoriReg
.text$mn:000001C2                 jnz     short loc_1CC
.text$mn:000001C4                 mov     ecx, [ebp+arg_C]
.text$mn:000001C7                 and     ecx, 2
.text$mn:000001CA                 jnz     short loc_1E5
.text$mn:000001CC
.text$mn:000001CC loc_1CC:                                ; CODE XREF: DockingSplitter::init(HINSTANCE__ *,HWND__ *,HWND__ *,uint)+6Aj
.text$mn:000001CC                 cmp     ds:?_isVertReg@DockingSplitter@@0HA, 0 ; int DockingSplitter::_isVertReg
.text$mn:000001D3                 jnz     loc_26B
.text$mn:000001D9                 mov     edx, [ebp+arg_C]
.text$mn:000001DC                 and     edx, 1
.text$mn:000001DF                 jz      loc_26B
.text$mn:000001E5
.text$mn:000001E5 loc_1E5:                                ; CODE XREF: DockingSplitter::init(HINSTANCE__ *,HWND__ *,HWND__ *,uint)+72j
.text$mn:000001E5                 mov     [ebp+WndClass.style], 3
.text$mn:000001EC                 mov     [ebp+WndClass.lpfnWndProc], offset ?staticWinProc@DockingSplitter@@KGJPAUHWND__@@IIJ@Z ; DockingSplitter::staticWinProc(HWND__ *,uint,uint,long)
.text$mn:000001F3                 mov     [ebp+WndClass.cbClsExtra], 0
.text$mn:000001FA                 mov     [ebp+WndClass.cbWndExtra], 0
.text$mn:00000201                 mov     eax, [ebp+lpParam]
.text$mn:00000204                 mov     ecx, [eax+4]
.text$mn:00000207                 mov     [ebp+WndClass.hInstance], ecx
.text$mn:0000020A                 mov     [ebp+WndClass.hIcon], 0
.text$mn:00000211                 mov     [ebp+WndClass.hbrBackground], 10h
.text$mn:00000218                 mov     [ebp+WndClass.lpszMenuName], 0
.text$mn:0000021F                 lea     edx, [ebp+WndClass]
.text$mn:00000222                 push    edx             ; lpWndClass
.text$mn:00000223                 call    dword ptr ds:__imp__RegisterClassW@4 ; RegisterClassW(x)
.text$mn:00000229                 movzx   eax, ax
.text$mn:0000022C                 test    eax, eax
.text$mn:0000022E                 jnz     short loc_24D
.text$mn:00000230                 push    offset $SG123152 ; "DockingSplitter::init : RegisterClass()"...
.text$mn:00000235                 lea     ecx, [ebp+var_10] ; this
.text$mn:00000238                 call    ??0runtime_error@std@@QAE@PBD@Z ; std::runtime_error::runtime_error(char const *)
.text$mn:0000023D                 push    offset __TI2?AVruntime_error@std@@
.text$mn:00000242                 lea     ecx, [ebp+var_10]
.text$mn:00000245                 push    ecx
.text$mn:00000246                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:0000024B ; ---------------------------------------------------------------------------
.text$mn:0000024B                 jmp     short loc_26B
.text$mn:0000024D ; ---------------------------------------------------------------------------
.text$mn:0000024D
.text$mn:0000024D loc_24D:                                ; CODE XREF: DockingSplitter::init(HINSTANCE__ *,HWND__ *,HWND__ *,uint)+D6j
.text$mn:0000024D                 mov     edx, [ebp+arg_C]
.text$mn:00000250                 and     edx, 2
.text$mn:00000253                 jz      short loc_261
.text$mn:00000255                 mov     ds:?_isHoriReg@DockingSplitter@@0HA, 1 ; int DockingSplitter::_isHoriReg
.text$mn:0000025F                 jmp     short loc_26B
.text$mn:00000261 ; ---------------------------------------------------------------------------
.text$mn:00000261
.text$mn:00000261 loc_261:                                ; CODE XREF: DockingSplitter::init(HINSTANCE__ *,HWND__ *,HWND__ *,uint)+FBj
.text$mn:00000261                 mov     ds:?_isVertReg@DockingSplitter@@0HA, 1 ; int DockingSplitter::_isVertReg
.text$mn:0000026B
.text$mn:0000026B loc_26B:                                ; CODE XREF: DockingSplitter::init(HINSTANCE__ *,HWND__ *,HWND__ *,uint)+7Bj
.text$mn:0000026B                                         ; DockingSplitter::init(HINSTANCE__ *,HWND__ *,HWND__ *,uint)+87j ...
.text$mn:0000026B                 mov     eax, [ebp+lpParam]
.text$mn:0000026E                 push    eax             ; lpParam
.text$mn:0000026F                 mov     ecx, [ebp+lpParam]
.text$mn:00000272                 mov     edx, [ecx+4]
.text$mn:00000275                 push    edx             ; hInstance
.text$mn:00000276                 push    0               ; hMenu
.text$mn:00000278                 mov     eax, [ebp+lpParam]
.text$mn:0000027B                 mov     ecx, [eax+8]
.text$mn:0000027E                 push    ecx             ; hWndParent
.text$mn:0000027F                 push    80000000h       ; nHeight
.text$mn:00000284                 push    80000000h       ; nWidth
.text$mn:00000289                 push    80000000h       ; Y
.text$mn:0000028E                 push    80000000h       ; X
.text$mn:00000293                 push    50000000h       ; dwStyle
.text$mn:00000298                 push    offset $SG123161 ; lpWindowName
.text$mn:0000029D                 mov     edx, [ebp+WndClass.lpszClassName]
.text$mn:000002A0                 push    edx             ; lpClassName
.text$mn:000002A1                 push    0               ; dwExStyle
.text$mn:000002A3                 call    dword ptr ds:__imp__CreateWindowExW@48 ; CreateWindowExW(x,x,x,x,x,x,x,x,x,x,x,x)
.text$mn:000002A9                 mov     ecx, [ebp+lpParam]
.text$mn:000002AC                 mov     [ecx+0Ch], eax
.text$mn:000002AF                 mov     edx, [ebp+lpParam]
.text$mn:000002B2                 cmp     dword ptr [edx+0Ch], 0
.text$mn:000002B6                 jnz     short loc_2D3
.text$mn:000002B8                 push    offset $SG123165 ; "DockingSplitter::init : CreateWindowEx("...
.text$mn:000002BD                 lea     ecx, [ebp+var_1C] ; this
.text$mn:000002C0                 call    ??0runtime_error@std@@QAE@PBD@Z ; std::runtime_error::runtime_error(char const *)
.text$mn:000002C5                 push    offset __TI2?AVruntime_error@std@@
.text$mn:000002CA                 lea     eax, [ebp+var_1C]
.text$mn:000002CD                 push    eax
.text$mn:000002CE                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:000002D3 ; ---------------------------------------------------------------------------
.text$mn:000002D3
.text$mn:000002D3 loc_2D3:                                ; CODE XREF: DockingSplitter::init(HINSTANCE__ *,HWND__ *,HWND__ *,uint)+15Ej
.text$mn:000002D3                 mov     esp, ebp
.text$mn:000002D5                 pop     ebp
.text$mn:000002D6                 retn    10h
.text$mn:000002D6 ?init@DockingSplitter@@QAEXPAUHINSTANCE__@@PAUHWND__@@1I@Z endp
.text$mn:000002D6
.text$mn:000002D6 ; ---------------------------------------------------------------------------
.text$mn:000002D9                 db 0Fh dup(0CCh)
.text$mn:000002E8
.text$mn:000002E8 ; =============== S U B R O U T I N E =======================================
.text$mn:000002E8
.text$mn:000002E8 ; Attributes: bp-based frame
.text$mn:000002E8
.text$mn:000002E8 ; __int32 __stdcall DockingSplitter::staticWinProc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
.text$mn:000002E8                 public ?staticWinProc@DockingSplitter@@KGJPAUHWND__@@IIJ@Z
.text$mn:000002E8 ?staticWinProc@DockingSplitter@@KGJPAUHWND__@@IIJ@Z proc near
.text$mn:000002E8                                         ; DATA XREF: DockingSplitter::init(HINSTANCE__ *,HWND__ *,HWND__ *,uint)+94o
.text$mn:000002E8
.text$mn:000002E8 var_8           = dword ptr -8
.text$mn:000002E8 dwNewLong       = dword ptr -4
.text$mn:000002E8 hWnd            = dword ptr  8
.text$mn:000002E8 Msg             = dword ptr  0Ch
.text$mn:000002E8 wParam          = dword ptr  10h
.text$mn:000002E8 lParam          = dword ptr  14h
.text$mn:000002E8
.text$mn:000002E8                 push    ebp
.text$mn:000002E9                 mov     ebp, esp
.text$mn:000002EB                 sub     esp, 8
.text$mn:000002EE                 mov     [ebp+dwNewLong], 0
.text$mn:000002F5                 mov     eax, [ebp+Msg]
.text$mn:000002F8                 mov     [ebp+var_8], eax
.text$mn:000002FB                 cmp     [ebp+var_8], 81h ; 'ü'
.text$mn:00000302                 jz      short loc_306
.text$mn:00000304                 jmp     short loc_32E
.text$mn:00000306 ; ---------------------------------------------------------------------------
.text$mn:00000306
.text$mn:00000306 loc_306:                                ; CODE XREF: DockingSplitter::staticWinProc(HWND__ *,uint,uint,long)+1Aj
.text$mn:00000306                 mov     ecx, [ebp+lParam]
.text$mn:00000309                 mov     edx, [ecx]
.text$mn:0000030B                 mov     [ebp+dwNewLong], edx
.text$mn:0000030E                 mov     eax, [ebp+dwNewLong]
.text$mn:00000311                 mov     ecx, [ebp+hWnd]
.text$mn:00000314                 mov     [eax+0Ch], ecx
.text$mn:00000317                 mov     edx, [ebp+dwNewLong]
.text$mn:0000031A                 push    edx             ; dwNewLong
.text$mn:0000031B                 push    0FFFFFFEBh      ; nIndex
.text$mn:0000031D                 mov     eax, [ebp+hWnd]
.text$mn:00000320                 push    eax             ; hWnd
.text$mn:00000321                 call    dword ptr ds:__imp__SetWindowLongW@12 ; SetWindowLongW(x,x,x)
.text$mn:00000327                 mov     eax, 1
.text$mn:0000032C                 jmp     short loc_373
.text$mn:0000032E ; ---------------------------------------------------------------------------
.text$mn:0000032E
.text$mn:0000032E loc_32E:                                ; CODE XREF: DockingSplitter::staticWinProc(HWND__ *,uint,uint,long)+1Cj
.text$mn:0000032E                 push    0FFFFFFEBh      ; nIndex
.text$mn:00000330                 mov     ecx, [ebp+hWnd]
.text$mn:00000333                 push    ecx             ; hWnd
.text$mn:00000334                 call    dword ptr ds:__imp__GetWindowLongW@8 ; GetWindowLongW(x,x)
.text$mn:0000033A                 mov     [ebp+dwNewLong], eax
.text$mn:0000033D                 cmp     [ebp+dwNewLong], 0
.text$mn:00000341                 jnz     short loc_35B
.text$mn:00000343                 mov     edx, [ebp+lParam]
.text$mn:00000346                 push    edx             ; lParam
.text$mn:00000347                 mov     eax, [ebp+wParam]
.text$mn:0000034A                 push    eax             ; wParam
.text$mn:0000034B                 mov     ecx, [ebp+Msg]
.text$mn:0000034E                 push    ecx             ; Msg
.text$mn:0000034F                 mov     edx, [ebp+hWnd]
.text$mn:00000352                 push    edx             ; hWnd
.text$mn:00000353                 call    dword ptr ds:__imp__DefWindowProcW@16 ; DefWindowProcW(x,x,x,x)
.text$mn:00000359                 jmp     short loc_373
.text$mn:0000035B ; ---------------------------------------------------------------------------
.text$mn:0000035B
.text$mn:0000035B loc_35B:                                ; CODE XREF: DockingSplitter::staticWinProc(HWND__ *,uint,uint,long)+59j
.text$mn:0000035B                 mov     eax, [ebp+lParam]
.text$mn:0000035E                 push    eax             ; __int32
.text$mn:0000035F                 mov     ecx, [ebp+wParam]
.text$mn:00000362                 push    ecx             ; wParam
.text$mn:00000363                 mov     edx, [ebp+Msg]
.text$mn:00000366                 push    edx             ; Msg
.text$mn:00000367                 mov     eax, [ebp+hWnd]
.text$mn:0000036A                 push    eax             ; hWnd
.text$mn:0000036B                 mov     ecx, [ebp+dwNewLong] ; this
.text$mn:0000036E                 call    ?runProc@DockingSplitter@@IAEJPAUHWND__@@IIJ@Z ; DockingSplitter::runProc(HWND__ *,uint,uint,long)
.text$mn:00000373
.text$mn:00000373 loc_373:                                ; CODE XREF: DockingSplitter::staticWinProc(HWND__ *,uint,uint,long)+44j
.text$mn:00000373                                         ; DockingSplitter::staticWinProc(HWND__ *,uint,uint,long)+71j
.text$mn:00000373                 mov     esp, ebp
.text$mn:00000375                 pop     ebp
.text$mn:00000376                 retn    10h
.text$mn:00000376 ?staticWinProc@DockingSplitter@@KGJPAUHWND__@@IIJ@Z endp
.text$mn:00000376
.text$mn:00000376 ; ---------------------------------------------------------------------------
.text$mn:00000379                 db 0Fh dup(0CCh)
.text$mn:00000388
.text$mn:00000388 ; =============== S U B R O U T I N E =======================================
.text$mn:00000388
.text$mn:00000388 ; Attributes: bp-based frame
.text$mn:00000388
.text$mn:00000388 ; __int32 __thiscall DockingSplitter::runProc(DockingSplitter *this, HWND hWnd, UINT Msg, WPARAM wParam, __int32)
.text$mn:00000388                 public ?runProc@DockingSplitter@@IAEJPAUHWND__@@IIJ@Z
.text$mn:00000388 ?runProc@DockingSplitter@@IAEJPAUHWND__@@IIJ@Z proc near
.text$mn:00000388                                         ; CODE XREF: DockingSplitter::staticWinProc(HWND__ *,uint,uint,long)+86p
.text$mn:00000388
.text$mn:00000388 var_118         = dword ptr -118h
.text$mn:00000388 Point           = tagPOINT ptr -114h
.text$mn:00000388 var_10C         = dword ptr -10Ch
.text$mn:00000388 var_108         = dword ptr -108h
.text$mn:00000388 Text            = word ptr -104h
.text$mn:00000388 var_4           = dword ptr -4
.text$mn:00000388 hWnd            = dword ptr  8
.text$mn:00000388 Msg             = dword ptr  0Ch
.text$mn:00000388 wParam          = dword ptr  10h
.text$mn:00000388 lParam          = dword ptr  14h
.text$mn:00000388
.text$mn:00000388                 push    ebp
.text$mn:00000389                 mov     ebp, esp
.text$mn:0000038B                 sub     esp, 118h
.text$mn:00000391                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000396                 xor     eax, ebp
.text$mn:00000398                 mov     [ebp+var_4], eax
.text$mn:0000039B                 mov     [ebp+var_108], ecx
.text$mn:000003A1                 mov     eax, [ebp+Msg]
.text$mn:000003A4                 mov     [ebp+var_10C], eax
.text$mn:000003AA                 cmp     [ebp+var_10C], 200h
.text$mn:000003B4                 ja      short loc_3EB
.text$mn:000003B6                 cmp     [ebp+var_10C], 200h
.text$mn:000003C0                 jz      loc_4E8
.text$mn:000003C6                 cmp     [ebp+var_10C], 0A0h ; 'á'
.text$mn:000003D0                 jz      loc_4E8
.text$mn:000003D6                 cmp     [ebp+var_10C], 0A2h ; 'ó'
.text$mn:000003E0                 jz      loc_4AE
.text$mn:000003E6                 jmp     loc_5AD
.text$mn:000003EB ; ---------------------------------------------------------------------------
.text$mn:000003EB
.text$mn:000003EB loc_3EB:                                ; CODE XREF: DockingSplitter::runProc(HWND__ *,uint,uint,long)+2Cj
.text$mn:000003EB                 cmp     [ebp+var_10C], 201h
.text$mn:000003F5                 jz      short loc_40C
.text$mn:000003F7                 cmp     [ebp+var_10C], 202h
.text$mn:00000401                 jz      loc_4AE
.text$mn:00000407                 jmp     loc_5AD
.text$mn:0000040C ; ---------------------------------------------------------------------------
.text$mn:0000040C
.text$mn:0000040C loc_40C:                                ; CODE XREF: DockingSplitter::runProc(HWND__ *,uint,uint,long)+6Dj
.text$mn:0000040C                 mov     ecx, [ebp+hWnd]
.text$mn:0000040F                 mov     ds:_hWndMouse, ecx
.text$mn:00000415                 push    0               ; dwThreadId
.text$mn:00000417                 mov     edx, [ebp+var_108]
.text$mn:0000041D                 mov     eax, [edx+4]
.text$mn:00000420                 push    eax             ; hmod
.text$mn:00000421                 push    offset ?hookProcMouse@@YGJIIJ@Z ; lpfn
.text$mn:00000426                 push    0Eh             ; idHook
.text$mn:00000428                 call    dword ptr ds:__imp__SetWindowsHookExW@16 ; SetWindowsHookExW(x,x,x,x)
.text$mn:0000042E                 mov     ds:_hookMouse, eax
.text$mn:00000433                 cmp     ds:_hookMouse, 0
.text$mn:0000043A                 jnz     short loc_47C
.text$mn:0000043C                 call    dword ptr ds:__imp__GetLastError@0 ; GetLastError()
.text$mn:00000442                 mov     [ebp+var_118], eax
.text$mn:00000448                 mov     ecx, [ebp+var_118]
.text$mn:0000044E                 push    ecx
.text$mn:0000044F                 push    offset $SG123200 ; "GetLastError() returned %lu"
.text$mn:00000454                 lea     edx, [ebp+Text]
.text$mn:0000045A                 push    edx             ; LPWSTR
.text$mn:0000045B                 call    dword ptr ds:__imp__wsprintfW
.text$mn:00000461                 add     esp, 0Ch
.text$mn:00000464                 push    10h             ; uType
.text$mn:00000466                 push    offset $SG123201 ; "SetWindowsHookEx(MOUSE) failed on runPr"...
.text$mn:0000046B                 lea     eax, [ebp+Text]
.text$mn:00000471                 push    eax             ; lpText
.text$mn:00000472                 push    0               ; hWnd
.text$mn:00000474                 call    dword ptr ds:__imp__MessageBoxW@16 ; MessageBoxW(x,x,x,x)
.text$mn:0000047A                 jmp     short loc_4A9
.text$mn:0000047C ; ---------------------------------------------------------------------------
.text$mn:0000047C
.text$mn:0000047C loc_47C:                                ; CODE XREF: DockingSplitter::runProc(HWND__ *,uint,uint,long)+B2j
.text$mn:0000047C                 mov     ecx, [ebp+var_108]
.text$mn:00000482                 mov     edx, [ecx+0Ch]
.text$mn:00000485                 push    edx             ; hWnd
.text$mn:00000486                 call    dword ptr ds:__imp__SetCapture@4 ; SetCapture(x)
.text$mn:0000048C                 mov     eax, [ebp+var_108]
.text$mn:00000492                 add     eax, 18h
.text$mn:00000495                 push    eax             ; lpPoint
.text$mn:00000496                 call    dword ptr ds:__imp__GetCursorPos@4 ; GetCursorPos(x)
.text$mn:0000049C                 mov     ecx, [ebp+var_108]
.text$mn:000004A2                 mov     dword ptr [ecx+14h], 1
.text$mn:000004A9
.text$mn:000004A9 loc_4A9:                                ; CODE XREF: DockingSplitter::runProc(HWND__ *,uint,uint,long)+F2j
.text$mn:000004A9                 jmp     loc_5AD
.text$mn:000004AE ; ---------------------------------------------------------------------------
.text$mn:000004AE
.text$mn:000004AE loc_4AE:                                ; CODE XREF: DockingSplitter::runProc(HWND__ *,uint,uint,long)+58j
.text$mn:000004AE                                         ; DockingSplitter::runProc(HWND__ *,uint,uint,long)+79j
.text$mn:000004AE                 cmp     ds:_hookMouse, 0
.text$mn:000004B5                 jz      short loc_4D6
.text$mn:000004B7                 mov     edx, ds:_hookMouse
.text$mn:000004BD                 push    edx             ; hhk
.text$mn:000004BE                 call    dword ptr ds:__imp__UnhookWindowsHookEx@4 ; UnhookWindowsHookEx(x)
.text$mn:000004C4                 push    0               ; hWnd
.text$mn:000004C6                 call    dword ptr ds:__imp__SetCapture@4 ; SetCapture(x)
.text$mn:000004CC                 mov     ds:_hookMouse, 0
.text$mn:000004D6
.text$mn:000004D6 loc_4D6:                                ; CODE XREF: DockingSplitter::runProc(HWND__ *,uint,uint,long)+12Dj
.text$mn:000004D6                 mov     eax, [ebp+var_108]
.text$mn:000004DC                 mov     dword ptr [eax+14h], 0
.text$mn:000004E3                 jmp     loc_5AD
.text$mn:000004E8 ; ---------------------------------------------------------------------------
.text$mn:000004E8
.text$mn:000004E8 loc_4E8:                                ; CODE XREF: DockingSplitter::runProc(HWND__ *,uint,uint,long)+38j
.text$mn:000004E8                                         ; DockingSplitter::runProc(HWND__ *,uint,uint,long)+48j
.text$mn:000004E8                 mov     ecx, [ebp+var_108]
.text$mn:000004EE                 cmp     dword ptr [ecx+14h], 1
.text$mn:000004F2                 jnz     loc_5AD
.text$mn:000004F8                 lea     edx, [ebp+Point]
.text$mn:000004FE                 push    edx             ; lpPoint
.text$mn:000004FF                 call    dword ptr ds:__imp__GetCursorPos@4 ; GetCursorPos(x)
.text$mn:00000505                 mov     eax, [ebp+var_108]
.text$mn:0000050B                 mov     ecx, [eax+20h]
.text$mn:0000050E                 and     ecx, 2
.text$mn:00000511                 jz      short loc_555
.text$mn:00000513                 mov     edx, [ebp+var_108]
.text$mn:00000519                 mov     eax, [edx+1Ch]
.text$mn:0000051C                 cmp     eax, [ebp+Point.y]
.text$mn:00000522                 jz      short loc_555
.text$mn:00000524                 mov     ecx, [ebp+var_108]
.text$mn:0000052A                 mov     edx, [ecx+0Ch]
.text$mn:0000052D                 push    edx             ; lParam
.text$mn:0000052E                 mov     eax, [ebp+var_108]
.text$mn:00000534                 mov     ecx, [eax+1Ch]
.text$mn:00000537                 sub     ecx, [ebp+Point.y]
.text$mn:0000053D                 push    ecx             ; wParam
.text$mn:0000053E                 push    500Bh           ; Msg
.text$mn:00000543                 mov     edx, [ebp+var_108]
.text$mn:00000549                 mov     eax, [edx+10h]
.text$mn:0000054C                 push    eax             ; hWnd
.text$mn:0000054D                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000553                 jmp     short loc_595
.text$mn:00000555 ; ---------------------------------------------------------------------------
.text$mn:00000555
.text$mn:00000555 loc_555:                                ; CODE XREF: DockingSplitter::runProc(HWND__ *,uint,uint,long)+189j
.text$mn:00000555                                         ; DockingSplitter::runProc(HWND__ *,uint,uint,long)+19Aj
.text$mn:00000555                 mov     ecx, [ebp+var_108]
.text$mn:0000055B                 mov     edx, [ecx+18h]
.text$mn:0000055E                 cmp     edx, [ebp+Point.x]
.text$mn:00000564                 jz      short loc_595
.text$mn:00000566                 mov     eax, [ebp+var_108]
.text$mn:0000056C                 mov     ecx, [eax+0Ch]
.text$mn:0000056F                 push    ecx             ; lParam
.text$mn:00000570                 mov     edx, [ebp+var_108]
.text$mn:00000576                 mov     eax, [edx+18h]
.text$mn:00000579                 sub     eax, [ebp+Point.x]
.text$mn:0000057F                 push    eax             ; wParam
.text$mn:00000580                 push    500Bh           ; Msg
.text$mn:00000585                 mov     ecx, [ebp+var_108]
.text$mn:0000058B                 mov     edx, [ecx+10h]
.text$mn:0000058E                 push    edx             ; hWnd
.text$mn:0000058F                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000595
.text$mn:00000595 loc_595:                                ; CODE XREF: DockingSplitter::runProc(HWND__ *,uint,uint,long)+1CBj
.text$mn:00000595                                         ; DockingSplitter::runProc(HWND__ *,uint,uint,long)+1DCj
.text$mn:00000595                 mov     eax, [ebp+var_108]
.text$mn:0000059B                 mov     ecx, [ebp+Point.x]
.text$mn:000005A1                 mov     [eax+18h], ecx
.text$mn:000005A4                 mov     edx, [ebp+Point.y]
.text$mn:000005AA                 mov     [eax+1Ch], edx
.text$mn:000005AD
.text$mn:000005AD loc_5AD:                                ; CODE XREF: DockingSplitter::runProc(HWND__ *,uint,uint,long)+5Ej
.text$mn:000005AD                                         ; DockingSplitter::runProc(HWND__ *,uint,uint,long)+7Fj ...
.text$mn:000005AD                 mov     eax, [ebp+lParam]
.text$mn:000005B0                 push    eax             ; lParam
.text$mn:000005B1                 mov     ecx, [ebp+wParam]
.text$mn:000005B4                 push    ecx             ; wParam
.text$mn:000005B5                 mov     edx, [ebp+Msg]
.text$mn:000005B8                 push    edx             ; Msg
.text$mn:000005B9                 mov     eax, [ebp+hWnd]
.text$mn:000005BC                 push    eax             ; hWnd
.text$mn:000005BD                 call    dword ptr ds:__imp__DefWindowProcW@16 ; DefWindowProcW(x,x,x,x)
.text$mn:000005C3                 mov     ecx, [ebp+var_4]
.text$mn:000005C6                 xor     ecx, ebp
.text$mn:000005C8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:000005CD                 mov     esp, ebp
.text$mn:000005CF                 pop     ebp
.text$mn:000005D0                 retn    10h
.text$mn:000005D0 ?runProc@DockingSplitter@@IAEJPAUHWND__@@IIJ@Z endp
.text$mn:000005D0
.text$mn:000005D0 ; ---------------------------------------------------------------------------
.text$mn:000005D3                 align 8
.text$mn:000005D8
.text$mn:000005D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000005D8
.text$mn:000005D8 ; Attributes: bp-based frame
.text$mn:000005D8
.text$mn:000005D8 ; LRESULT __stdcall hookProcMouse(int code, WPARAM wParam, LPARAM lParam)
.text$mn:000005D8 ?hookProcMouse@@YGJIIJ@Z proc near      ; DATA XREF: DockingSplitter::runProc(HWND__ *,uint,uint,long)+99o
.text$mn:000005D8
.text$mn:000005D8 var_4           = dword ptr -4
.text$mn:000005D8 code            = dword ptr  8
.text$mn:000005D8 wParam          = dword ptr  0Ch
.text$mn:000005D8 lParam          = dword ptr  10h
.text$mn:000005D8
.text$mn:000005D8                 push    ebp
.text$mn:000005D9                 mov     ebp, esp
.text$mn:000005DB                 push    ecx
.text$mn:000005DC                 cmp     [ebp+code], 0
.text$mn:000005E0                 jb      short loc_64C
.text$mn:000005E2                 mov     eax, [ebp+wParam]
.text$mn:000005E5                 mov     [ebp+var_4], eax
.text$mn:000005E8                 cmp     [ebp+var_4], 200h
.text$mn:000005EF                 ja      short loc_60E
.text$mn:000005F1                 cmp     [ebp+var_4], 200h
.text$mn:000005F8                 jz      short loc_619
.text$mn:000005FA                 cmp     [ebp+var_4], 0A0h ; 'á'
.text$mn:00000601                 jz      short loc_619
.text$mn:00000603                 cmp     [ebp+var_4], 0A2h ; 'ó'
.text$mn:0000060A                 jz      short loc_630
.text$mn:0000060C                 jmp     short loc_64C
.text$mn:0000060E ; ---------------------------------------------------------------------------
.text$mn:0000060E
.text$mn:0000060E loc_60E:                                ; CODE XREF: hookProcMouse(uint,uint,long)+17j
.text$mn:0000060E                 cmp     [ebp+var_4], 202h
.text$mn:00000615                 jz      short loc_630
.text$mn:00000617                 jmp     short loc_64C
.text$mn:00000619 ; ---------------------------------------------------------------------------
.text$mn:00000619
.text$mn:00000619 loc_619:                                ; CODE XREF: hookProcMouse(uint,uint,long)+20j
.text$mn:00000619                                         ; hookProcMouse(uint,uint,long)+29j
.text$mn:00000619                 push    0               ; lParam
.text$mn:0000061B                 push    0               ; wParam
.text$mn:0000061D                 mov     ecx, [ebp+wParam]
.text$mn:00000620                 push    ecx             ; Msg
.text$mn:00000621                 mov     edx, ds:_hWndMouse
.text$mn:00000627                 push    edx             ; hWnd
.text$mn:00000628                 call    dword ptr ds:__imp__PostMessageW@16 ; PostMessageW(x,x,x,x)
.text$mn:0000062E                 jmp     short loc_64C
.text$mn:00000630 ; ---------------------------------------------------------------------------
.text$mn:00000630
.text$mn:00000630 loc_630:                                ; CODE XREF: hookProcMouse(uint,uint,long)+32j
.text$mn:00000630                                         ; hookProcMouse(uint,uint,long)+3Dj
.text$mn:00000630                 push    0               ; lParam
.text$mn:00000632                 push    0               ; wParam
.text$mn:00000634                 mov     eax, [ebp+wParam]
.text$mn:00000637                 push    eax             ; Msg
.text$mn:00000638                 mov     ecx, ds:_hWndMouse
.text$mn:0000063E                 push    ecx             ; hWnd
.text$mn:0000063F                 call    dword ptr ds:__imp__PostMessageW@16 ; PostMessageW(x,x,x,x)
.text$mn:00000645                 mov     eax, 1
.text$mn:0000064A                 jmp     short loc_665
.text$mn:0000064C ; ---------------------------------------------------------------------------
.text$mn:0000064C
.text$mn:0000064C loc_64C:                                ; CODE XREF: hookProcMouse(uint,uint,long)+8j
.text$mn:0000064C                                         ; hookProcMouse(uint,uint,long)+34j ...
.text$mn:0000064C                 mov     edx, [ebp+lParam]
.text$mn:0000064F                 push    edx             ; lParam
.text$mn:00000650                 mov     eax, [ebp+wParam]
.text$mn:00000653                 push    eax             ; wParam
.text$mn:00000654                 mov     ecx, [ebp+code]
.text$mn:00000657                 push    ecx             ; nCode
.text$mn:00000658                 mov     edx, ds:_hookMouse
.text$mn:0000065E                 push    edx             ; hhk
.text$mn:0000065F                 call    dword ptr ds:__imp__CallNextHookEx@16 ; CallNextHookEx(x,x,x,x)
.text$mn:00000665
.text$mn:00000665 loc_665:                                ; CODE XREF: hookProcMouse(uint,uint,long)+72j
.text$mn:00000665                 mov     esp, ebp
.text$mn:00000667                 pop     ebp
.text$mn:00000668                 retn    0Ch
.text$mn:00000668 ?hookProcMouse@@YGJIIJ@Z endp
.text$mn:00000668
.text$mn:00000668 ; ---------------------------------------------------------------------------
.text$mn:0000066B                 align 4
.text$mn:0000066B _text$mn        ends
.text$mn:0000066B
.text$mn:0000066C ; ===========================================================================
.text$mn:0000066C
.text$mn:0000066C ; Segment type: Pure code
.text$mn:0000066C ; Segment permissions: Read/Execute
.text$mn:0000066C _text$mn        segment para public 'CODE' use32
.text$mn:0000066C                 assume cs:_text$mn
.text$mn:0000066C                 ;org 66Ch
.text$mn:0000066C ; COMDAT (pick any)
.text$mn:0000066C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000066C
.text$mn:0000066C ; =============== S U B R O U T I N E =======================================
.text$mn:0000066C
.text$mn:0000066C ; Attributes: bp-based frame
.text$mn:0000066C
.text$mn:0000066C ; char * __cdecl std::_Allocate<char>(unsigned int, char *)
.text$mn:0000066C                 public ??$_Allocate@D@std@@YAPADIPAD@Z
.text$mn:0000066C ??$_Allocate@D@std@@YAPADIPAD@Z proc near
.text$mn:0000066C                                         ; CODE XREF: std::allocator<char>::allocate(uint)+Dp
.text$mn:0000066C
.text$mn:0000066C var_4           = dword ptr -4
.text$mn:0000066C arg_0           = dword ptr  8
.text$mn:0000066C
.text$mn:0000066C                 push    ebp
.text$mn:0000066D                 mov     ebp, esp
.text$mn:0000066F                 push    ecx
.text$mn:00000670                 mov     [ebp+var_4], 0
.text$mn:00000677                 cmp     [ebp+arg_0], 0
.text$mn:0000067B                 jnz     short loc_67F
.text$mn:0000067D                 jmp     short loc_69F
.text$mn:0000067F ; ---------------------------------------------------------------------------
.text$mn:0000067F
.text$mn:0000067F loc_67F:                                ; CODE XREF: std::_Allocate<char>(uint,char *)+Fj
.text$mn:0000067F                 cmp     [ebp+arg_0], 0FFFFFFFFh
.text$mn:00000683                 ja      short loc_69A
.text$mn:00000685                 mov     eax, [ebp+arg_0]
.text$mn:00000688                 push    eax             ; unsigned int
.text$mn:00000689                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:0000068E                 add     esp, 4
.text$mn:00000691                 mov     [ebp+var_4], eax
.text$mn:00000694                 cmp     [ebp+var_4], 0
.text$mn:00000698                 jnz     short loc_69F
.text$mn:0000069A
.text$mn:0000069A loc_69A:                                ; CODE XREF: std::_Allocate<char>(uint,char *)+17j
.text$mn:0000069A                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:0000069F
.text$mn:0000069F loc_69F:                                ; CODE XREF: std::_Allocate<char>(uint,char *)+11j
.text$mn:0000069F                                         ; std::_Allocate<char>(uint,char *)+2Cj
.text$mn:0000069F                 mov     eax, [ebp+var_4]
.text$mn:000006A2                 mov     esp, ebp
.text$mn:000006A4                 pop     ebp
.text$mn:000006A5                 retn
.text$mn:000006A5 ??$_Allocate@D@std@@YAPADIPAD@Z endp
.text$mn:000006A5
.text$mn:000006A5 ; ---------------------------------------------------------------------------
.text$mn:000006A6                 align 4
.text$mn:000006A6 _text$mn        ends
.text$mn:000006A6
.text$mn:000006A8 ; ===========================================================================
.text$mn:000006A8
.text$mn:000006A8 ; Segment type: Pure code
.text$mn:000006A8 ; Segment permissions: Read/Execute
.text$mn:000006A8 _text$mn        segment para public 'CODE' use32
.text$mn:000006A8                 assume cs:_text$mn
.text$mn:000006A8                 ;org 6A8h
.text$mn:000006A8 ; COMDAT (pick any)
.text$mn:000006A8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000006A8
.text$mn:000006A8 ; =============== S U B R O U T I N E =======================================
.text$mn:000006A8
.text$mn:000006A8 ; Attributes: bp-based frame
.text$mn:000006A8
.text$mn:000006A8 ; struct std::_Container_proxy * __cdecl std::_Allocate<struct std::_Container_proxy>(unsigned int, struct std::_Container_proxy *)
.text$mn:000006A8                 public ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z
.text$mn:000006A8 ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z proc near
.text$mn:000006A8                                         ; CODE XREF: std::allocator<std::_Container_proxy>::allocate(uint)+Dp
.text$mn:000006A8
.text$mn:000006A8 var_4           = dword ptr -4
.text$mn:000006A8 arg_0           = dword ptr  8
.text$mn:000006A8
.text$mn:000006A8                 push    ebp
.text$mn:000006A9                 mov     ebp, esp
.text$mn:000006AB                 push    ecx
.text$mn:000006AC                 mov     [ebp+var_4], 0
.text$mn:000006B3                 cmp     [ebp+arg_0], 0
.text$mn:000006B7                 jnz     short loc_6BB
.text$mn:000006B9                 jmp     short loc_6E1
.text$mn:000006BB ; ---------------------------------------------------------------------------
.text$mn:000006BB
.text$mn:000006BB loc_6BB:                                ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+Fj
.text$mn:000006BB                 cmp     [ebp+arg_0], 1FFFFFFFh
.text$mn:000006C2                 ja      short loc_6DC
.text$mn:000006C4                 mov     eax, [ebp+arg_0]
.text$mn:000006C7                 shl     eax, 3
.text$mn:000006CA                 push    eax             ; unsigned int
.text$mn:000006CB                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:000006D0                 add     esp, 4
.text$mn:000006D3                 mov     [ebp+var_4], eax
.text$mn:000006D6                 cmp     [ebp+var_4], 0
.text$mn:000006DA                 jnz     short loc_6E1
.text$mn:000006DC
.text$mn:000006DC loc_6DC:                                ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+1Aj
.text$mn:000006DC                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:000006E1
.text$mn:000006E1 loc_6E1:                                ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+11j
.text$mn:000006E1                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+32j
.text$mn:000006E1                 mov     eax, [ebp+var_4]
.text$mn:000006E4                 mov     esp, ebp
.text$mn:000006E6                 pop     ebp
.text$mn:000006E7                 retn
.text$mn:000006E7 ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z endp
.text$mn:000006E7
.text$mn:000006E7 _text$mn        ends
.text$mn:000006E7
.text$mn:000006E8 ; ===========================================================================
.text$mn:000006E8
.text$mn:000006E8 ; Segment type: Pure code
.text$mn:000006E8 ; Segment permissions: Read/Execute
.text$mn:000006E8 _text$mn        segment para public 'CODE' use32
.text$mn:000006E8                 assume cs:_text$mn
.text$mn:000006E8                 ;org 6E8h
.text$mn:000006E8 ; COMDAT (pick any)
.text$mn:000006E8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000006E8
.text$mn:000006E8 ; =============== S U B R O U T I N E =======================================
.text$mn:000006E8
.text$mn:000006E8 ; Attributes: bp-based frame
.text$mn:000006E8
.text$mn:000006E8 ; int __cdecl std::_Debug_pointer<char>(int, wchar_t *, unsigned int)
.text$mn:000006E8                 public ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z
.text$mn:000006E8 ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z proc near
.text$mn:000006E8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+15p
.text$mn:000006E8                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+1Bp
.text$mn:000006E8
.text$mn:000006E8 arg_0           = dword ptr  8
.text$mn:000006E8 arg_4           = dword ptr  0Ch
.text$mn:000006E8 arg_8           = dword ptr  10h
.text$mn:000006E8
.text$mn:000006E8                 push    ebp
.text$mn:000006E9                 mov     ebp, esp
.text$mn:000006EB                 cmp     [ebp+arg_0], 0
.text$mn:000006EF                 jnz     short loc_706
.text$mn:000006F1                 mov     eax, [ebp+arg_8]
.text$mn:000006F4                 push    eax             ; unsigned int
.text$mn:000006F5                 mov     ecx, [ebp+arg_4]
.text$mn:000006F8                 push    ecx             ; wchar_t *
.text$mn:000006F9                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:000006FE                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00000703                 add     esp, 0Ch
.text$mn:00000706
.text$mn:00000706 loc_706:                                ; CODE XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+7j
.text$mn:00000706                 pop     ebp
.text$mn:00000707                 retn
.text$mn:00000707 ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z endp
.text$mn:00000707
.text$mn:00000707 _text$mn        ends
.text$mn:00000707
.text$mn:00000708 ; ===========================================================================
.text$mn:00000708
.text$mn:00000708 ; Segment type: Pure code
.text$mn:00000708 ; Segment permissions: Read/Execute
.text$mn:00000708 _text$mn        segment para public 'CODE' use32
.text$mn:00000708                 assume cs:_text$mn
.text$mn:00000708                 ;org 708h
.text$mn:00000708 ; COMDAT (pick any)
.text$mn:00000708                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000708
.text$mn:00000708 ; =============== S U B R O U T I N E =======================================
.text$mn:00000708
.text$mn:00000708 ; Attributes: bp-based frame
.text$mn:00000708
.text$mn:00000708 ; char * __cdecl std::addressof<char>(char &)
.text$mn:00000708                 public ??$addressof@D@std@@YAPADAAD@Z
.text$mn:00000708 ??$addressof@D@std@@YAPADAAD@Z proc near
.text$mn:00000708                                         ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+19p
.text$mn:00000708                                         ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)+19p ...
.text$mn:00000708
.text$mn:00000708 arg_0           = dword ptr  8
.text$mn:00000708
.text$mn:00000708                 push    ebp
.text$mn:00000709                 mov     ebp, esp
.text$mn:0000070B                 mov     eax, [ebp+arg_0]
.text$mn:0000070E                 pop     ebp
.text$mn:0000070F                 retn
.text$mn:0000070F ??$addressof@D@std@@YAPADAAD@Z endp
.text$mn:0000070F
.text$mn:0000070F _text$mn        ends
.text$mn:0000070F
.text$mn:00000710 ; ===========================================================================
.text$mn:00000710
.text$mn:00000710 ; Segment type: Pure code
.text$mn:00000710 ; Segment permissions: Read/Execute
.text$mn:00000710 _text$mn        segment para public 'CODE' use32
.text$mn:00000710                 assume cs:_text$mn
.text$mn:00000710                 ;org 710h
.text$mn:00000710 ; COMDAT (pick any)
.text$mn:00000710                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000710
.text$mn:00000710 ; =============== S U B R O U T I N E =======================================
.text$mn:00000710
.text$mn:00000710 ; Attributes: bp-based frame
.text$mn:00000710
.text$mn:00000710 ; int __stdcall std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(void *, int)
.text$mn:00000710                 public ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
.text$mn:00000710 ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z proc near
.text$mn:00000710                                         ; CODE XREF: $LN19+4Bp
.text$mn:00000710
.text$mn:00000710 var_4           = dword ptr -4
.text$mn:00000710 arg_0           = dword ptr  8
.text$mn:00000710 arg_4           = dword ptr  0Ch
.text$mn:00000710
.text$mn:00000710                 push    ebp
.text$mn:00000711                 mov     ebp, esp
.text$mn:00000713                 push    ecx
.text$mn:00000714                 mov     [ebp+var_4], ecx
.text$mn:00000717                 mov     eax, [ebp+arg_4]
.text$mn:0000071A                 push    eax
.text$mn:0000071B                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:00000720                 add     esp, 4
.text$mn:00000723                 push    eax             ; int
.text$mn:00000724                 mov     ecx, [ebp+arg_0]
.text$mn:00000727                 push    ecx             ; void *
.text$mn:00000728                 mov     edx, [ebp+var_4]
.text$mn:0000072B                 push    edx             ; int
.text$mn:0000072C                 call    ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(std::allocator<char> &,char * *,char * &)
.text$mn:00000731                 add     esp, 0Ch
.text$mn:00000734                 mov     esp, ebp
.text$mn:00000736                 pop     ebp
.text$mn:00000737                 retn    8
.text$mn:00000737 ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z endp
.text$mn:00000737
.text$mn:00000737 ; ---------------------------------------------------------------------------
.text$mn:0000073A                 align 4
.text$mn:0000073A _text$mn        ends
.text$mn:0000073A
.text$mn:0000073C ; ===========================================================================
.text$mn:0000073C
.text$mn:0000073C ; Segment type: Pure code
.text$mn:0000073C ; Segment permissions: Read/Execute
.text$mn:0000073C _text$mn        segment para public 'CODE' use32
.text$mn:0000073C                 assume cs:_text$mn
.text$mn:0000073C                 ;org 73Ch
.text$mn:0000073C ; COMDAT (pick any)
.text$mn:0000073C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000073C
.text$mn:0000073C ; =============== S U B R O U T I N E =======================================
.text$mn:0000073C
.text$mn:0000073C ; Attributes: bp-based frame
.text$mn:0000073C
.text$mn:0000073C ; int __stdcall std::allocator<char>::construct<char *,char * &>(void *, int)
.text$mn:0000073C                 public ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$mn:0000073C ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
.text$mn:0000073C                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(std::allocator<char> &,char * *,char * &)+17p
.text$mn:0000073C
.text$mn:0000073C var_1C          = dword ptr -1Ch
.text$mn:0000073C var_18          = dword ptr -18h
.text$mn:0000073C var_14          = dword ptr -14h
.text$mn:0000073C var_10          = dword ptr -10h
.text$mn:0000073C var_C           = dword ptr -0Ch
.text$mn:0000073C var_4           = dword ptr -4
.text$mn:0000073C arg_0           = dword ptr  8
.text$mn:0000073C arg_4           = dword ptr  0Ch
.text$mn:0000073C
.text$mn:0000073C                 push    ebp
.text$mn:0000073D                 mov     ebp, esp
.text$mn:0000073F                 push    0FFFFFFFFh
.text$mn:00000741                 push    offset __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$mn:00000746                 mov     eax, large fs:0
.text$mn:0000074C                 push    eax
.text$mn:0000074D                 sub     esp, 10h
.text$mn:00000750                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000755                 xor     eax, ebp
.text$mn:00000757                 push    eax
.text$mn:00000758                 lea     eax, [ebp+var_C]
.text$mn:0000075B                 mov     large fs:0, eax
.text$mn:00000761                 mov     [ebp+var_18], ecx
.text$mn:00000764                 mov     eax, [ebp+arg_0]
.text$mn:00000767                 push    eax             ; void *
.text$mn:00000768                 push    4               ; unsigned int
.text$mn:0000076A                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:0000076F                 add     esp, 8
.text$mn:00000772                 mov     [ebp+var_10], eax
.text$mn:00000775                 mov     [ebp+var_4], 0
.text$mn:0000077C                 cmp     [ebp+var_10], 0
.text$mn:00000780                 jz      short loc_79D
.text$mn:00000782                 mov     ecx, [ebp+arg_4]
.text$mn:00000785                 push    ecx
.text$mn:00000786                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:0000078B                 add     esp, 4
.text$mn:0000078E                 mov     edx, [ebp+var_10]
.text$mn:00000791                 mov     eax, [eax]
.text$mn:00000793                 mov     [edx], eax
.text$mn:00000795                 mov     ecx, [ebp+var_10]
.text$mn:00000798                 mov     [ebp+var_14], ecx
.text$mn:0000079B                 jmp     short loc_7A4
.text$mn:0000079D ; ---------------------------------------------------------------------------
.text$mn:0000079D
.text$mn:0000079D loc_79D:                                ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+44j
.text$mn:0000079D                 mov     [ebp+var_14], 0
.text$mn:000007A4
.text$mn:000007A4 loc_7A4:                                ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+5Fj
.text$mn:000007A4                 mov     edx, [ebp+var_14]
.text$mn:000007A7                 mov     [ebp+var_1C], edx
.text$mn:000007AA                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000007B1                 mov     ecx, [ebp+var_C]
.text$mn:000007B4                 mov     large fs:0, ecx
.text$mn:000007BB                 pop     ecx
.text$mn:000007BC                 mov     esp, ebp
.text$mn:000007BE                 pop     ebp
.text$mn:000007BF                 retn    8
.text$mn:000007BF ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp
.text$mn:000007BF
.text$mn:000007BF ; ---------------------------------------------------------------------------
.text$mn:000007C2                 align 4
.text$mn:000007C2 _text$mn        ends
.text$mn:000007C2
.text$x:000007C4 ; ===========================================================================
.text$x:000007C4
.text$x:000007C4 ; Segment type: Pure code
.text$x:000007C4 ; Segment permissions: Read/Execute
.text$x:000007C4 _text$x         segment para public 'CODE' use32
.text$x:000007C4                 assume cs:_text$x
.text$x:000007C4                 ;org 7C4h
.text$x:000007C4 ; COMDAT (pick associative to section at 73C)
.text$x:000007C4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000007C4
.text$x:000007C4 ; =============== S U B R O U T I N E =======================================
.text$x:000007C4
.text$x:000007C4
.text$x:000007C4 __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 proc near
.text$x:000007C4                                         ; DATA XREF: .xdata$x:00002544o
.text$x:000007C4                 mov     eax, [ebp+8]
.text$x:000007C7                 push    eax
.text$x:000007C8                 mov     eax, [ebp-10h]
.text$x:000007CB                 push    eax             ; void *
.text$x:000007CC                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:000007D1                 add     esp, 8
.text$x:000007D4                 retn
.text$x:000007D4 __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 endp
.text$x:000007D4
.text$x:000007D5
.text$x:000007D5 ; =============== S U B R O U T I N E =======================================
.text$x:000007D5
.text$x:000007D5
.text$x:000007D5 __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
.text$x:000007D5                                         ; DATA XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+5o
.text$x:000007D5
.text$x:000007D5 arg_4           = dword ptr  8
.text$x:000007D5
.text$x:000007D5                 mov     edx, [esp+arg_4]
.text$x:000007D9                 lea     eax, [edx+0Ch]
.text$x:000007DC                 mov     ecx, [edx-14h]
.text$x:000007DF                 xor     ecx, eax
.text$x:000007E1                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000007E6                 mov     eax, offset __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$x:000007EB                 jmp     ___CxxFrameHandler3
.text$x:000007EB __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp
.text$x:000007EB
.text$x:000007EB _text$x         ends
.text$x:000007EB
.text$mn:000007F0 ; ===========================================================================
.text$mn:000007F0
.text$mn:000007F0 ; Segment type: Pure code
.text$mn:000007F0 ; Segment permissions: Read/Execute
.text$mn:000007F0 _text$mn        segment para public 'CODE' use32
.text$mn:000007F0                 assume cs:_text$mn
.text$mn:000007F0                 ;org 7F0h
.text$mn:000007F0 ; COMDAT (pick any)
.text$mn:000007F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000007F0
.text$mn:000007F0 ; =============== S U B R O U T I N E =======================================
.text$mn:000007F0
.text$mn:000007F0 ; Attributes: bp-based frame
.text$mn:000007F0
.text$mn:000007F0 ; int __cdecl std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(int, void *, int)
.text$mn:000007F0                 public ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
.text$mn:000007F0 ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z proc near
.text$mn:000007F0                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)+1Cp
.text$mn:000007F0
.text$mn:000007F0 arg_0           = dword ptr  8
.text$mn:000007F0 arg_4           = dword ptr  0Ch
.text$mn:000007F0 arg_8           = dword ptr  10h
.text$mn:000007F0
.text$mn:000007F0                 push    ebp
.text$mn:000007F1                 mov     ebp, esp
.text$mn:000007F3                 mov     eax, [ebp+arg_8]
.text$mn:000007F6                 push    eax
.text$mn:000007F7                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:000007FC                 add     esp, 4
.text$mn:000007FF                 push    eax             ; int
.text$mn:00000800                 mov     ecx, [ebp+arg_4]
.text$mn:00000803                 push    ecx             ; void *
.text$mn:00000804                 mov     ecx, [ebp+arg_0]
.text$mn:00000807                 call    ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)
.text$mn:0000080C                 pop     ebp
.text$mn:0000080D                 retn
.text$mn:0000080D ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z endp
.text$mn:0000080D
.text$mn:0000080D ; ---------------------------------------------------------------------------
.text$mn:0000080E                 align 10h
.text$mn:0000080E _text$mn        ends
.text$mn:0000080E
.text$mn:00000810 ; ===========================================================================
.text$mn:00000810
.text$mn:00000810 ; Segment type: Pure code
.text$mn:00000810 ; Segment permissions: Read/Execute
.text$mn:00000810 _text$mn        segment para public 'CODE' use32
.text$mn:00000810                 assume cs:_text$mn
.text$mn:00000810                 ;org 810h
.text$mn:00000810 ; COMDAT (pick any)
.text$mn:00000810                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000810
.text$mn:00000810 ; =============== S U B R O U T I N E =======================================
.text$mn:00000810
.text$mn:00000810 ; Attributes: bp-based frame
.text$mn:00000810
.text$mn:00000810 ; int __stdcall std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(void *, int)
.text$mn:00000810                 public ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:00000810 ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$mn:00000810                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+32p
.text$mn:00000810
.text$mn:00000810 var_1C          = dword ptr -1Ch
.text$mn:00000810 var_18          = dword ptr -18h
.text$mn:00000810 var_14          = dword ptr -14h
.text$mn:00000810 var_10          = dword ptr -10h
.text$mn:00000810 var_C           = dword ptr -0Ch
.text$mn:00000810 var_4           = dword ptr -4
.text$mn:00000810 arg_0           = dword ptr  8
.text$mn:00000810 arg_4           = dword ptr  0Ch
.text$mn:00000810
.text$mn:00000810                 push    ebp
.text$mn:00000811                 mov     ebp, esp
.text$mn:00000813                 push    0FFFFFFFFh
.text$mn:00000815                 push    offset __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:0000081A                 mov     eax, large fs:0
.text$mn:00000820                 push    eax
.text$mn:00000821                 sub     esp, 10h
.text$mn:00000824                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000829                 xor     eax, ebp
.text$mn:0000082B                 push    eax
.text$mn:0000082C                 lea     eax, [ebp+var_C]
.text$mn:0000082F                 mov     large fs:0, eax
.text$mn:00000835                 mov     [ebp+var_18], ecx
.text$mn:00000838                 mov     eax, [ebp+arg_0]
.text$mn:0000083B                 push    eax             ; void *
.text$mn:0000083C                 push    8               ; unsigned int
.text$mn:0000083E                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00000843                 add     esp, 8
.text$mn:00000846                 mov     [ebp+var_10], eax
.text$mn:00000849                 mov     [ebp+var_4], 0
.text$mn:00000850                 cmp     [ebp+var_10], 0
.text$mn:00000854                 jz      short loc_877
.text$mn:00000856                 mov     ecx, [ebp+arg_4]
.text$mn:00000859                 push    ecx
.text$mn:0000085A                 call    ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>(std::_Container_proxy &)
.text$mn:0000085F                 add     esp, 4
.text$mn:00000862                 mov     edx, [eax]
.text$mn:00000864                 mov     eax, [eax+4]
.text$mn:00000867                 mov     ecx, [ebp+var_10]
.text$mn:0000086A                 mov     [ecx], edx
.text$mn:0000086C                 mov     [ecx+4], eax
.text$mn:0000086F                 mov     edx, [ebp+var_10]
.text$mn:00000872                 mov     [ebp+var_14], edx
.text$mn:00000875                 jmp     short loc_87E
.text$mn:00000877 ; ---------------------------------------------------------------------------
.text$mn:00000877
.text$mn:00000877 loc_877:                                ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+44j
.text$mn:00000877                 mov     [ebp+var_14], 0
.text$mn:0000087E
.text$mn:0000087E loc_87E:                                ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+65j
.text$mn:0000087E                 mov     eax, [ebp+var_14]
.text$mn:00000881                 mov     [ebp+var_1C], eax
.text$mn:00000884                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000088B                 mov     ecx, [ebp+var_C]
.text$mn:0000088E                 mov     large fs:0, ecx
.text$mn:00000895                 pop     ecx
.text$mn:00000896                 mov     esp, ebp
.text$mn:00000898                 pop     ebp
.text$mn:00000899                 retn    8
.text$mn:00000899 ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$mn:00000899
.text$mn:00000899 _text$mn        ends
.text$mn:00000899
.text$x:0000089C ; ===========================================================================
.text$x:0000089C
.text$x:0000089C ; Segment type: Pure code
.text$x:0000089C ; Segment permissions: Read/Execute
.text$x:0000089C _text$x         segment para public 'CODE' use32
.text$x:0000089C                 assume cs:_text$x
.text$x:0000089C                 ;org 89Ch
.text$x:0000089C ; COMDAT (pick associative to section at 810)
.text$x:0000089C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000089C
.text$x:0000089C ; =============== S U B R O U T I N E =======================================
.text$x:0000089C
.text$x:0000089C
.text$x:0000089C __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 proc near
.text$x:0000089C                                         ; DATA XREF: .xdata$x:00002518o
.text$x:0000089C                 mov     eax, [ebp+8]
.text$x:0000089F                 push    eax
.text$x:000008A0                 mov     eax, [ebp-10h]
.text$x:000008A3                 push    eax             ; void *
.text$x:000008A4                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:000008A9                 add     esp, 8
.text$x:000008AC                 retn
.text$x:000008AC __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 endp
.text$x:000008AC
.text$x:000008AD
.text$x:000008AD ; =============== S U B R O U T I N E =======================================
.text$x:000008AD
.text$x:000008AD
.text$x:000008AD __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$x:000008AD                                         ; DATA XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+5o
.text$x:000008AD
.text$x:000008AD arg_4           = dword ptr  8
.text$x:000008AD
.text$x:000008AD                 mov     edx, [esp+arg_4]
.text$x:000008B1                 lea     eax, [edx+0Ch]
.text$x:000008B4                 mov     ecx, [edx-14h]
.text$x:000008B7                 xor     ecx, eax
.text$x:000008B9                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000008BE                 mov     eax, offset __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$x:000008C3                 jmp     ___CxxFrameHandler3
.text$x:000008C3 __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$x:000008C3
.text$x:000008C3 _text$x         ends
.text$x:000008C3
.text$mn:000008C8 ; ===========================================================================
.text$mn:000008C8
.text$mn:000008C8 ; Segment type: Pure code
.text$mn:000008C8 ; Segment permissions: Read/Execute
.text$mn:000008C8 _text$mn        segment para public 'CODE' use32
.text$mn:000008C8                 assume cs:_text$mn
.text$mn:000008C8                 ;org 8C8h
.text$mn:000008C8 ; COMDAT (pick any)
.text$mn:000008C8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000008C8
.text$mn:000008C8 ; =============== S U B R O U T I N E =======================================
.text$mn:000008C8
.text$mn:000008C8 ; Attributes: bp-based frame
.text$mn:000008C8
.text$mn:000008C8 ; public: void __thiscall std::_Wrap_alloc<class std::allocator<char>>::destroy<char *>(char * *)
.text$mn:000008C8                 public ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
.text$mn:000008C8 ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z proc near
.text$mn:000008C8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+3Ap
.text$mn:000008C8
.text$mn:000008C8 var_4           = dword ptr -4
.text$mn:000008C8 arg_0           = dword ptr  8
.text$mn:000008C8
.text$mn:000008C8                 push    ebp
.text$mn:000008C9                 mov     ebp, esp
.text$mn:000008CB                 push    ecx
.text$mn:000008CC                 mov     [ebp+var_4], ecx
.text$mn:000008CF                 mov     eax, [ebp+arg_0]
.text$mn:000008D2                 push    eax
.text$mn:000008D3                 mov     ecx, [ebp+var_4]
.text$mn:000008D6                 push    ecx
.text$mn:000008D7                 call    ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char * *)
.text$mn:000008DC                 add     esp, 8
.text$mn:000008DF                 mov     esp, ebp
.text$mn:000008E1                 pop     ebp
.text$mn:000008E2                 retn    4
.text$mn:000008E2 ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z endp
.text$mn:000008E2
.text$mn:000008E2 ; ---------------------------------------------------------------------------
.text$mn:000008E5                 align 4
.text$mn:000008E5 _text$mn        ends
.text$mn:000008E5
.text$mn:000008E8 ; ===========================================================================
.text$mn:000008E8
.text$mn:000008E8 ; Segment type: Pure code
.text$mn:000008E8 ; Segment permissions: Read/Execute
.text$mn:000008E8 _text$mn        segment para public 'CODE' use32
.text$mn:000008E8                 assume cs:_text$mn
.text$mn:000008E8                 ;org 8E8h
.text$mn:000008E8 ; COMDAT (pick any)
.text$mn:000008E8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000008E8
.text$mn:000008E8 ; =============== S U B R O U T I N E =======================================
.text$mn:000008E8
.text$mn:000008E8 ; Attributes: bp-based frame
.text$mn:000008E8
.text$mn:000008E8 ; public: void __thiscall std::allocator<char>::destroy<char *>(char * *)
.text$mn:000008E8                 public ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
.text$mn:000008E8 ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z proc near
.text$mn:000008E8                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char * *)+Ap
.text$mn:000008E8
.text$mn:000008E8 var_4           = dword ptr -4
.text$mn:000008E8
.text$mn:000008E8                 push    ebp
.text$mn:000008E9                 mov     ebp, esp
.text$mn:000008EB                 push    ecx
.text$mn:000008EC                 mov     [ebp+var_4], ecx
.text$mn:000008EF                 mov     esp, ebp
.text$mn:000008F1                 pop     ebp
.text$mn:000008F2                 retn    4
.text$mn:000008F2 ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z endp
.text$mn:000008F2
.text$mn:000008F2 ; ---------------------------------------------------------------------------
.text$mn:000008F5                 align 4
.text$mn:000008F5 _text$mn        ends
.text$mn:000008F5
.text$mn:000008F8 ; ===========================================================================
.text$mn:000008F8
.text$mn:000008F8 ; Segment type: Pure code
.text$mn:000008F8 ; Segment permissions: Read/Execute
.text$mn:000008F8 _text$mn        segment para public 'CODE' use32
.text$mn:000008F8                 assume cs:_text$mn
.text$mn:000008F8                 ;org 8F8h
.text$mn:000008F8 ; COMDAT (pick any)
.text$mn:000008F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000008F8
.text$mn:000008F8 ; =============== S U B R O U T I N E =======================================
.text$mn:000008F8
.text$mn:000008F8 ; Attributes: bp-based frame
.text$mn:000008F8
.text$mn:000008F8 ; public: static void __cdecl std::allocator_traits<class std::allocator<char>>::destroy<char *>(class std::allocator<char> &, char * *)
.text$mn:000008F8                 public ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
.text$mn:000008F8 ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z proc near
.text$mn:000008F8                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)+Fp
.text$mn:000008F8
.text$mn:000008F8 arg_0           = dword ptr  8
.text$mn:000008F8 arg_4           = dword ptr  0Ch
.text$mn:000008F8
.text$mn:000008F8                 push    ebp
.text$mn:000008F9                 mov     ebp, esp
.text$mn:000008FB                 mov     eax, [ebp+arg_4]
.text$mn:000008FE                 push    eax
.text$mn:000008FF                 mov     ecx, [ebp+arg_0]
.text$mn:00000902                 call    ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ; std::allocator<char>::destroy<char *>(char * *)
.text$mn:00000907                 pop     ebp
.text$mn:00000908                 retn
.text$mn:00000908 ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z endp
.text$mn:00000908
.text$mn:00000908 ; ---------------------------------------------------------------------------
.text$mn:00000909                 align 4
.text$mn:00000909 _text$mn        ends
.text$mn:00000909
.text$mn:0000090C ; ===========================================================================
.text$mn:0000090C
.text$mn:0000090C ; Segment type: Pure code
.text$mn:0000090C ; Segment permissions: Read/Execute
.text$mn:0000090C _text$mn        segment para public 'CODE' use32
.text$mn:0000090C                 assume cs:_text$mn
.text$mn:0000090C                 ;org 90Ch
.text$mn:0000090C ; COMDAT (pick any)
.text$mn:0000090C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000090C
.text$mn:0000090C ; =============== S U B R O U T I N E =======================================
.text$mn:0000090C
.text$mn:0000090C ; Attributes: bp-based frame
.text$mn:0000090C
.text$mn:0000090C ; public: void __thiscall std::allocator<struct std::_Container_proxy>::destroy<struct std::_Container_proxy>(struct std::_Container_proxy *)
.text$mn:0000090C                 public ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z
.text$mn:0000090C ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z proc near
.text$mn:0000090C                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+22p
.text$mn:0000090C
.text$mn:0000090C var_4           = dword ptr -4
.text$mn:0000090C
.text$mn:0000090C                 push    ebp
.text$mn:0000090D                 mov     ebp, esp
.text$mn:0000090F                 push    ecx
.text$mn:00000910                 mov     [ebp+var_4], ecx
.text$mn:00000913                 mov     esp, ebp
.text$mn:00000915                 pop     ebp
.text$mn:00000916                 retn    4
.text$mn:00000916 ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z endp
.text$mn:00000916
.text$mn:00000916 ; ---------------------------------------------------------------------------
.text$mn:00000919                 align 4
.text$mn:00000919 _text$mn        ends
.text$mn:00000919
.text$mn:0000091C ; ===========================================================================
.text$mn:0000091C
.text$mn:0000091C ; Segment type: Pure code
.text$mn:0000091C ; Segment permissions: Read/Execute
.text$mn:0000091C _text$mn        segment para public 'CODE' use32
.text$mn:0000091C                 assume cs:_text$mn
.text$mn:0000091C                 ;org 91Ch
.text$mn:0000091C ; COMDAT (pick any)
.text$mn:0000091C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000091C
.text$mn:0000091C ; =============== S U B R O U T I N E =======================================
.text$mn:0000091C
.text$mn:0000091C ; Attributes: bp-based frame
.text$mn:0000091C
.text$mn:0000091C ; char * & __cdecl std::forward<char * &>(char * &)
.text$mn:0000091C                 public ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
.text$mn:0000091C ??$forward@AAPAD@std@@YAAAPADAAPAD@Z proc near
.text$mn:0000091C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)+Bp
.text$mn:0000091C                                         ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)+4Ap ...
.text$mn:0000091C
.text$mn:0000091C arg_0           = dword ptr  8
.text$mn:0000091C
.text$mn:0000091C                 push    ebp
.text$mn:0000091D                 mov     ebp, esp
.text$mn:0000091F                 mov     eax, [ebp+arg_0]
.text$mn:00000922                 pop     ebp
.text$mn:00000923                 retn
.text$mn:00000923 ??$forward@AAPAD@std@@YAAAPADAAPAD@Z endp
.text$mn:00000923
.text$mn:00000923 _text$mn        ends
.text$mn:00000923
.text$mn:00000924 ; ===========================================================================
.text$mn:00000924
.text$mn:00000924 ; Segment type: Pure code
.text$mn:00000924 ; Segment permissions: Read/Execute
.text$mn:00000924 _text$mn        segment para public 'CODE' use32
.text$mn:00000924                 assume cs:_text$mn
.text$mn:00000924                 ;org 924h
.text$mn:00000924 ; COMDAT (pick any)
.text$mn:00000924                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000924
.text$mn:00000924 ; =============== S U B R O U T I N E =======================================
.text$mn:00000924
.text$mn:00000924 ; Attributes: bp-based frame
.text$mn:00000924
.text$mn:00000924 ; struct std::_Container_proxy && __cdecl std::forward<struct std::_Container_proxy>(struct std::_Container_proxy &)
.text$mn:00000924                 public ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z
.text$mn:00000924 ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z proc near
.text$mn:00000924                                         ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+4Ap
.text$mn:00000924
.text$mn:00000924 arg_0           = dword ptr  8
.text$mn:00000924
.text$mn:00000924                 push    ebp
.text$mn:00000925                 mov     ebp, esp
.text$mn:00000927                 mov     eax, [ebp+arg_0]
.text$mn:0000092A                 pop     ebp
.text$mn:0000092B                 retn
.text$mn:0000092B ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z endp
.text$mn:0000092B
.text$mn:0000092B _text$mn        ends
.text$mn:0000092B
.text$mn:0000092C ; ===========================================================================
.text$mn:0000092C
.text$mn:0000092C ; Segment type: Pure code
.text$mn:0000092C ; Segment permissions: Read/Execute
.text$mn:0000092C _text$mn        segment para public 'CODE' use32
.text$mn:0000092C                 assume cs:_text$mn
.text$mn:0000092C                 ;org 92Ch
.text$mn:0000092C ; COMDAT (pick any)
.text$mn:0000092C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000092C
.text$mn:0000092C ; =============== S U B R O U T I N E =======================================
.text$mn:0000092C
.text$mn:0000092C ; Attributes: bp-based frame
.text$mn:0000092C
.text$mn:0000092C ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>(class std::allocator<char> const &)
.text$mn:0000092C                 public ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$mn:0000092C ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
.text$mn:0000092C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+34p
.text$mn:0000092C
.text$mn:0000092C var_10          = dword ptr -10h
.text$mn:0000092C var_C           = dword ptr -0Ch
.text$mn:0000092C var_4           = dword ptr -4
.text$mn:0000092C
.text$mn:0000092C                 push    ebp
.text$mn:0000092D                 mov     ebp, esp
.text$mn:0000092F                 push    0FFFFFFFFh
.text$mn:00000931                 push    offset __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$mn:00000936                 mov     eax, large fs:0
.text$mn:0000093C                 push    eax
.text$mn:0000093D                 push    ecx
.text$mn:0000093E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000943                 xor     eax, ebp
.text$mn:00000945                 push    eax
.text$mn:00000946                 lea     eax, [ebp+var_C]
.text$mn:00000949                 mov     large fs:0, eax
.text$mn:0000094F                 mov     [ebp+var_10], ecx
.text$mn:00000952                 mov     ecx, [ebp+var_10]
.text$mn:00000955                 call    ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)
.text$mn:0000095A                 mov     [ebp+var_4], 0
.text$mn:00000961                 mov     ecx, [ebp+var_10]
.text$mn:00000964                 call    ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)
.text$mn:00000969                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000970                 mov     eax, [ebp+var_10]
.text$mn:00000973                 mov     ecx, [ebp+var_C]
.text$mn:00000976                 mov     large fs:0, ecx
.text$mn:0000097D                 pop     ecx
.text$mn:0000097E                 mov     esp, ebp
.text$mn:00000980                 pop     ebp
.text$mn:00000981                 retn    4
.text$mn:00000981 ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp
.text$mn:00000981
.text$mn:00000981 _text$mn        ends
.text$mn:00000981
.text$x:00000984 ; ===========================================================================
.text$x:00000984
.text$x:00000984 ; Segment type: Pure code
.text$x:00000984 ; Segment permissions: Read/Execute
.text$x:00000984 _text$x         segment para public 'CODE' use32
.text$x:00000984                 assume cs:_text$x
.text$x:00000984                 ;org 984h
.text$x:00000984 ; COMDAT (pick associative to section at 92C)
.text$x:00000984                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000984
.text$x:00000984 ; =============== S U B R O U T I N E =======================================
.text$x:00000984
.text$x:00000984
.text$x:00000984 __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 proc near
.text$x:00000984                                         ; DATA XREF: .xdata$x:000021CCo
.text$x:00000984                 mov     ecx, [ebp-10h]
.text$x:00000987                 jmp     ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$x:00000987 __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 endp
.text$x:00000987
.text$x:0000098C
.text$x:0000098C ; =============== S U B R O U T I N E =======================================
.text$x:0000098C
.text$x:0000098C
.text$x:0000098C __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
.text$x:0000098C                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+5o
.text$x:0000098C
.text$x:0000098C arg_4           = dword ptr  8
.text$x:0000098C
.text$x:0000098C                 mov     edx, [esp+arg_4]
.text$x:00000990                 lea     eax, [edx+0Ch]
.text$x:00000993                 mov     ecx, [edx-8]
.text$x:00000996                 xor     ecx, eax
.text$x:00000998                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000099D                 mov     eax, offset __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$x:000009A2                 jmp     ___CxxFrameHandler3
.text$x:000009A2 __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp
.text$x:000009A2
.text$x:000009A2 ; ---------------------------------------------------------------------------
.text$x:000009A7                 align 4
.text$x:000009A7 _text$x         ends
.text$x:000009A7
.text$mn:000009A8 ; ===========================================================================
.text$mn:000009A8
.text$mn:000009A8 ; Segment type: Pure code
.text$mn:000009A8 ; Segment permissions: Read/Execute
.text$mn:000009A8 _text$mn        segment para public 'CODE' use32
.text$mn:000009A8                 assume cs:_text$mn
.text$mn:000009A8                 ;org 9A8h
.text$mn:000009A8 ; COMDAT (pick any)
.text$mn:000009A8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000009A8
.text$mn:000009A8 ; =============== S U B R O U T I N E =======================================
.text$mn:000009A8
.text$mn:000009A8 ; Attributes: bp-based frame
.text$mn:000009A8
.text$mn:000009A8 ; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::_String_val<struct std::_Simple_types<char>>(void)
.text$mn:000009A8                 public ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:000009A8 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$mn:000009A8                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+29p
.text$mn:000009A8
.text$mn:000009A8 var_10          = dword ptr -10h
.text$mn:000009A8 var_C           = dword ptr -0Ch
.text$mn:000009A8 var_4           = dword ptr -4
.text$mn:000009A8
.text$mn:000009A8                 push    ebp
.text$mn:000009A9                 mov     ebp, esp
.text$mn:000009AB                 push    0FFFFFFFFh
.text$mn:000009AD                 push    offset __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:000009B2                 mov     eax, large fs:0
.text$mn:000009B8                 push    eax
.text$mn:000009B9                 push    ecx
.text$mn:000009BA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000009BF                 xor     eax, ebp
.text$mn:000009C1                 push    eax
.text$mn:000009C2                 lea     eax, [ebp+var_C]
.text$mn:000009C5                 mov     large fs:0, eax
.text$mn:000009CB                 mov     [ebp+var_10], ecx
.text$mn:000009CE                 mov     ecx, [ebp+var_10] ; this
.text$mn:000009D1                 call    ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
.text$mn:000009D6                 mov     [ebp+var_4], 0
.text$mn:000009DD                 mov     eax, [ebp+var_10]
.text$mn:000009E0                 mov     dword ptr [eax+14h], 0
.text$mn:000009E7                 mov     ecx, [ebp+var_10]
.text$mn:000009EA                 mov     dword ptr [ecx+18h], 0
.text$mn:000009F1                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000009F8                 mov     eax, [ebp+var_10]
.text$mn:000009FB                 mov     ecx, [ebp+var_C]
.text$mn:000009FE                 mov     large fs:0, ecx
.text$mn:00000A05                 pop     ecx
.text$mn:00000A06                 mov     esp, ebp
.text$mn:00000A08                 pop     ebp
.text$mn:00000A09                 retn
.text$mn:00000A09 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$mn:00000A09
.text$mn:00000A09 ; ---------------------------------------------------------------------------
.text$mn:00000A0A                 align 4
.text$mn:00000A0A _text$mn        ends
.text$mn:00000A0A
.text$x:00000A0C ; ===========================================================================
.text$x:00000A0C
.text$x:00000A0C ; Segment type: Pure code
.text$x:00000A0C ; Segment permissions: Read/Execute
.text$x:00000A0C _text$x         segment para public 'CODE' use32
.text$x:00000A0C                 assume cs:_text$x
.text$x:00000A0C                 ;org 0A0Ch
.text$x:00000A0C ; COMDAT (pick associative to section at 9A8)
.text$x:00000A0C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000A0C
.text$x:00000A0C ; =============== S U B R O U T I N E =======================================
.text$x:00000A0C
.text$x:00000A0C
.text$x:00000A0C __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 proc near
.text$x:00000A0C                                         ; DATA XREF: .xdata$x:00002174o
.text$x:00000A0C                 mov     ecx, [ebp-10h]  ; this
.text$x:00000A0F                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00000A0F __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 endp
.text$x:00000A0F
.text$x:00000A14
.text$x:00000A14 ; =============== S U B R O U T I N E =======================================
.text$x:00000A14
.text$x:00000A14
.text$x:00000A14 __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$x:00000A14                                         ; DATA XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+5o
.text$x:00000A14
.text$x:00000A14 arg_4           = dword ptr  8
.text$x:00000A14
.text$x:00000A14                 mov     edx, [esp+arg_4]
.text$x:00000A18                 lea     eax, [edx+0Ch]
.text$x:00000A1B                 mov     ecx, [edx-8]
.text$x:00000A1E                 xor     ecx, eax
.text$x:00000A20                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000A25                 mov     eax, offset __ehfuncinfo$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$x:00000A2A                 jmp     ___CxxFrameHandler3
.text$x:00000A2A __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$x:00000A2A
.text$x:00000A2A ; ---------------------------------------------------------------------------
.text$x:00000A2F                 align 10h
.text$x:00000A2F _text$x         ends
.text$x:00000A2F
.text$mn:00000A30 ; ===========================================================================
.text$mn:00000A30
.text$mn:00000A30 ; Segment type: Pure code
.text$mn:00000A30 ; Segment permissions: Read/Execute
.text$mn:00000A30 _text$mn        segment para public 'CODE' use32
.text$mn:00000A30                 assume cs:_text$mn
.text$mn:00000A30                 ;org 0A30h
.text$mn:00000A30 ; COMDAT (pick any)
.text$mn:00000A30                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000A30
.text$mn:00000A30 ; =============== S U B R O U T I N E =======================================
.text$mn:00000A30
.text$mn:00000A30 ; Attributes: bp-based frame
.text$mn:00000A30
.text$mn:00000A30 ; public: __thiscall std::_Wrap_alloc<class std::allocator<char>>::_Wrap_alloc<class std::allocator<char>>(void)
.text$mn:00000A30                 public ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
.text$mn:00000A30 ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ proc near
.text$mn:00000A30                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)+Ap
.text$mn:00000A30
.text$mn:00000A30 var_4           = dword ptr -4
.text$mn:00000A30
.text$mn:00000A30                 push    ebp
.text$mn:00000A31                 mov     ebp, esp
.text$mn:00000A33                 push    ecx
.text$mn:00000A34                 mov     [ebp+var_4], ecx
.text$mn:00000A37                 mov     ecx, [ebp+var_4]
.text$mn:00000A3A                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:00000A3F                 mov     eax, [ebp+var_4]
.text$mn:00000A42                 mov     esp, ebp
.text$mn:00000A44                 pop     ebp
.text$mn:00000A45                 retn
.text$mn:00000A45 ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ endp
.text$mn:00000A45
.text$mn:00000A45 ; ---------------------------------------------------------------------------
.text$mn:00000A46                 align 4
.text$mn:00000A46 _text$mn        ends
.text$mn:00000A46
.text$mn:00000A48 ; ===========================================================================
.text$mn:00000A48
.text$mn:00000A48 ; Segment type: Pure code
.text$mn:00000A48 ; Segment permissions: Read/Execute
.text$mn:00000A48 _text$mn        segment para public 'CODE' use32
.text$mn:00000A48                 assume cs:_text$mn
.text$mn:00000A48                 ;org 0A48h
.text$mn:00000A48 ; COMDAT (pick any)
.text$mn:00000A48                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000A48
.text$mn:00000A48 ; =============== S U B R O U T I N E =======================================
.text$mn:00000A48
.text$mn:00000A48 ; Attributes: bp-based frame
.text$mn:00000A48
.text$mn:00000A48 ; public: __thiscall std::allocator<char>::allocator<char>(void)
.text$mn:00000A48                 public ??0?$allocator@D@std@@QAE@XZ
.text$mn:00000A48 ??0?$allocator@D@std@@QAE@XZ proc near  ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)+Ap
.text$mn:00000A48                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+2Bp
.text$mn:00000A48
.text$mn:00000A48 var_4           = dword ptr -4
.text$mn:00000A48
.text$mn:00000A48                 push    ebp
.text$mn:00000A49                 mov     ebp, esp
.text$mn:00000A4B                 push    ecx
.text$mn:00000A4C                 mov     [ebp+var_4], ecx
.text$mn:00000A4F                 mov     eax, [ebp+var_4]
.text$mn:00000A52                 mov     esp, ebp
.text$mn:00000A54                 pop     ebp
.text$mn:00000A55                 retn
.text$mn:00000A55 ??0?$allocator@D@std@@QAE@XZ endp
.text$mn:00000A55
.text$mn:00000A55 ; ---------------------------------------------------------------------------
.text$mn:00000A56                 align 4
.text$mn:00000A56 _text$mn        ends
.text$mn:00000A56
.text$mn:00000A58 ; ===========================================================================
.text$mn:00000A58
.text$mn:00000A58 ; Segment type: Pure code
.text$mn:00000A58 ; Segment permissions: Read/Execute
.text$mn:00000A58 _text$mn        segment para public 'CODE' use32
.text$mn:00000A58                 assume cs:_text$mn
.text$mn:00000A58                 ;org 0A58h
.text$mn:00000A58 ; COMDAT (pick any)
.text$mn:00000A58                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000A58
.text$mn:00000A58 ; =============== S U B R O U T I N E =======================================
.text$mn:00000A58
.text$mn:00000A58 ; Attributes: bp-based frame
.text$mn:00000A58
.text$mn:00000A58 ; public: __thiscall std::allocator<struct std::_Container_proxy>::allocator<struct std::_Container_proxy>(void)
.text$mn:00000A58                 public ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ
.text$mn:00000A58 ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ proc near
.text$mn:00000A58                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+Cp
.text$mn:00000A58                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+Cp
.text$mn:00000A58
.text$mn:00000A58 var_4           = dword ptr -4
.text$mn:00000A58
.text$mn:00000A58                 push    ebp
.text$mn:00000A59                 mov     ebp, esp
.text$mn:00000A5B                 push    ecx
.text$mn:00000A5C                 mov     [ebp+var_4], ecx
.text$mn:00000A5F                 mov     eax, [ebp+var_4]
.text$mn:00000A62                 mov     esp, ebp
.text$mn:00000A64                 pop     ebp
.text$mn:00000A65                 retn
.text$mn:00000A65 ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ endp
.text$mn:00000A65
.text$mn:00000A65 ; ---------------------------------------------------------------------------
.text$mn:00000A66                 align 4
.text$mn:00000A66 _text$mn        ends
.text$mn:00000A66
.text$mn:00000A68 ; ===========================================================================
.text$mn:00000A68
.text$mn:00000A68 ; Segment type: Pure code
.text$mn:00000A68 ; Segment permissions: Read/Execute
.text$mn:00000A68 _text$mn        segment para public 'CODE' use32
.text$mn:00000A68                 assume cs:_text$mn
.text$mn:00000A68                 ;org 0A68h
.text$mn:00000A68 ; COMDAT (pick any)
.text$mn:00000A68                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000A68
.text$mn:00000A68 ; =============== S U B R O U T I N E =======================================
.text$mn:00000A68
.text$mn:00000A68 ; Attributes: bp-based frame
.text$mn:00000A68
.text$mn:00000A68 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char *Str)
.text$mn:00000A68                 public ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$mn:00000A68 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
.text$mn:00000A68                                         ; CODE XREF: std::_Generic_error_category::message(int)+5Ap
.text$mn:00000A68                                         ; std::_Iostream_error_category::message(int)+3Dp ...
.text$mn:00000A68
.text$mn:00000A68 var_14          = dword ptr -14h
.text$mn:00000A68 var_D           = byte ptr -0Dh
.text$mn:00000A68 var_C           = dword ptr -0Ch
.text$mn:00000A68 var_4           = dword ptr -4
.text$mn:00000A68 Str             = dword ptr  8
.text$mn:00000A68
.text$mn:00000A68                 push    ebp
.text$mn:00000A69                 mov     ebp, esp
.text$mn:00000A6B                 push    0FFFFFFFFh
.text$mn:00000A6D                 push    offset __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$mn:00000A72                 mov     eax, large fs:0
.text$mn:00000A78                 push    eax
.text$mn:00000A79                 sub     esp, 8
.text$mn:00000A7C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000A81                 xor     eax, ebp
.text$mn:00000A83                 push    eax
.text$mn:00000A84                 lea     eax, [ebp+var_C]
.text$mn:00000A87                 mov     large fs:0, eax
.text$mn:00000A8D                 mov     [ebp+var_14], ecx
.text$mn:00000A90                 lea     ecx, [ebp+var_D]
.text$mn:00000A93                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:00000A98                 push    eax
.text$mn:00000A99                 mov     ecx, [ebp+var_14]
.text$mn:00000A9C                 call    ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)
.text$mn:00000AA1                 mov     [ebp+var_4], 0
.text$mn:00000AA8                 push    0               ; Size
.text$mn:00000AAA                 push    0               ; char
.text$mn:00000AAC                 mov     ecx, [ebp+var_14]
.text$mn:00000AAF                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00000AB4                 mov     eax, [ebp+Str]
.text$mn:00000AB7                 push    eax             ; Str
.text$mn:00000AB8                 mov     ecx, [ebp+var_14]
.text$mn:00000ABB                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)
.text$mn:00000AC0                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000AC7                 mov     eax, [ebp+var_14]
.text$mn:00000ACA                 mov     ecx, [ebp+var_C]
.text$mn:00000ACD                 mov     large fs:0, ecx
.text$mn:00000AD4                 pop     ecx
.text$mn:00000AD5                 mov     esp, ebp
.text$mn:00000AD7                 pop     ebp
.text$mn:00000AD8                 retn    4
.text$mn:00000AD8 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp
.text$mn:00000AD8
.text$mn:00000AD8 ; ---------------------------------------------------------------------------
.text$mn:00000ADB                 align 4
.text$mn:00000ADB _text$mn        ends
.text$mn:00000ADB
.text$x:00000ADC ; ===========================================================================
.text$x:00000ADC
.text$x:00000ADC ; Segment type: Pure code
.text$x:00000ADC ; Segment permissions: Read/Execute
.text$x:00000ADC _text$x         segment para public 'CODE' use32
.text$x:00000ADC                 assume cs:_text$x
.text$x:00000ADC                 ;org 0ADCh
.text$x:00000ADC ; COMDAT (pick associative to section at A68)
.text$x:00000ADC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000ADC
.text$x:00000ADC ; =============== S U B R O U T I N E =======================================
.text$x:00000ADC
.text$x:00000ADC
.text$x:00000ADC __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 proc near
.text$x:00000ADC                                         ; DATA XREF: .xdata$x:00002224o
.text$x:00000ADC                 mov     ecx, [ebp-14h]
.text$x:00000ADF                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:00000ADF __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 endp
.text$x:00000ADF
.text$x:00000AE4
.text$x:00000AE4 ; =============== S U B R O U T I N E =======================================
.text$x:00000AE4
.text$x:00000AE4
.text$x:00000AE4 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
.text$x:00000AE4                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+5o
.text$x:00000AE4
.text$x:00000AE4 arg_4           = dword ptr  8
.text$x:00000AE4
.text$x:00000AE4                 mov     edx, [esp+arg_4]
.text$x:00000AE8                 lea     eax, [edx+0Ch]
.text$x:00000AEB                 mov     ecx, [edx-0Ch]
.text$x:00000AEE                 xor     ecx, eax
.text$x:00000AF0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000AF5                 mov     eax, offset __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$x:00000AFA                 jmp     ___CxxFrameHandler3
.text$x:00000AFA __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp
.text$x:00000AFA
.text$x:00000AFA ; ---------------------------------------------------------------------------
.text$x:00000AFF                 align 10h
.text$x:00000AFF _text$x         ends
.text$x:00000AFF
.text$mn:00000B00 ; ===========================================================================
.text$mn:00000B00
.text$mn:00000B00 ; Segment type: Pure code
.text$mn:00000B00 ; Segment permissions: Read/Execute
.text$mn:00000B00 _text$mn        segment para public 'CODE' use32
.text$mn:00000B00                 assume cs:_text$mn
.text$mn:00000B00                 ;org 0B00h
.text$mn:00000B00 ; COMDAT (pick any)
.text$mn:00000B00                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000B00
.text$mn:00000B00 ; =============== S U B R O U T I N E =======================================
.text$mn:00000B00
.text$mn:00000B00 ; Attributes: bp-based frame
.text$mn:00000B00
.text$mn:00000B00 ; _DWORD __thiscall std::_Container_base12::_Container_base12(std::_Container_base12 *__hidden this)
.text$mn:00000B00                 public ??0_Container_base12@std@@QAE@XZ
.text$mn:00000B00 ??0_Container_base12@std@@QAE@XZ proc near
.text$mn:00000B00                                         ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+29p
.text$mn:00000B00
.text$mn:00000B00 var_4           = dword ptr -4
.text$mn:00000B00
.text$mn:00000B00                 push    ebp
.text$mn:00000B01                 mov     ebp, esp
.text$mn:00000B03                 push    ecx
.text$mn:00000B04                 mov     [ebp+var_4], ecx
.text$mn:00000B07                 mov     eax, [ebp+var_4]
.text$mn:00000B0A                 mov     dword ptr [eax], 0
.text$mn:00000B10                 mov     eax, [ebp+var_4]
.text$mn:00000B13                 mov     esp, ebp
.text$mn:00000B15                 pop     ebp
.text$mn:00000B16                 retn
.text$mn:00000B16 ??0_Container_base12@std@@QAE@XZ endp
.text$mn:00000B16
.text$mn:00000B16 ; ---------------------------------------------------------------------------
.text$mn:00000B17                 align 4
.text$mn:00000B17 _text$mn        ends
.text$mn:00000B17
.text$mn:00000B18 ; ===========================================================================
.text$mn:00000B18
.text$mn:00000B18 ; Segment type: Pure code
.text$mn:00000B18 ; Segment permissions: Read/Execute
.text$mn:00000B18 _text$mn        segment para public 'CODE' use32
.text$mn:00000B18                 assume cs:_text$mn
.text$mn:00000B18                 ;org 0B18h
.text$mn:00000B18 ; COMDAT (pick any)
.text$mn:00000B18                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000B18
.text$mn:00000B18 ; =============== S U B R O U T I N E =======================================
.text$mn:00000B18
.text$mn:00000B18 ; Attributes: bp-based frame
.text$mn:00000B18
.text$mn:00000B18 ; _DWORD __thiscall std::_Container_proxy::_Container_proxy(std::_Container_proxy *__hidden this)
.text$mn:00000B18                 public ??0_Container_proxy@std@@QAE@XZ
.text$mn:00000B18 ??0_Container_proxy@std@@QAE@XZ proc near
.text$mn:00000B18                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+23p
.text$mn:00000B18
.text$mn:00000B18 var_4           = dword ptr -4
.text$mn:00000B18
.text$mn:00000B18                 push    ebp
.text$mn:00000B19                 mov     ebp, esp
.text$mn:00000B1B                 push    ecx
.text$mn:00000B1C                 mov     [ebp+var_4], ecx
.text$mn:00000B1F                 mov     eax, [ebp+var_4]
.text$mn:00000B22                 mov     dword ptr [eax], 0
.text$mn:00000B28                 mov     ecx, [ebp+var_4]
.text$mn:00000B2B                 mov     dword ptr [ecx+4], 0
.text$mn:00000B32                 mov     eax, [ebp+var_4]
.text$mn:00000B35                 mov     esp, ebp
.text$mn:00000B37                 pop     ebp
.text$mn:00000B38                 retn
.text$mn:00000B38 ??0_Container_proxy@std@@QAE@XZ endp
.text$mn:00000B38
.text$mn:00000B38 ; ---------------------------------------------------------------------------
.text$mn:00000B39                 align 4
.text$mn:00000B39 _text$mn        ends
.text$mn:00000B39
.text$mn:00000B3C ; ===========================================================================
.text$mn:00000B3C
.text$mn:00000B3C ; Segment type: Pure code
.text$mn:00000B3C ; Segment permissions: Read/Execute
.text$mn:00000B3C _text$mn        segment para public 'CODE' use32
.text$mn:00000B3C                 assume cs:_text$mn
.text$mn:00000B3C                 ;org 0B3Ch
.text$mn:00000B3C ; COMDAT (pick any)
.text$mn:00000B3C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000B3C
.text$mn:00000B3C ; =============== S U B R O U T I N E =======================================
.text$mn:00000B3C
.text$mn:00000B3C ; Attributes: bp-based frame
.text$mn:00000B3C
.text$mn:00000B3C ; _DWORD __thiscall std::_Generic_error_category::_Generic_error_category(std::_Generic_error_category *__hidden this)
.text$mn:00000B3C                 public ??0_Generic_error_category@std@@QAE@XZ
.text$mn:00000B3C ??0_Generic_error_category@std@@QAE@XZ proc near
.text$mn:00000B3C                                         ; CODE XREF: std::_Iostream_error_category::_Iostream_error_category(void)+29p
.text$mn:00000B3C                                         ; std::_System_error_category::_System_error_category(void)+29p ...
.text$mn:00000B3C
.text$mn:00000B3C var_10          = dword ptr -10h
.text$mn:00000B3C var_C           = dword ptr -0Ch
.text$mn:00000B3C var_4           = dword ptr -4
.text$mn:00000B3C
.text$mn:00000B3C                 push    ebp
.text$mn:00000B3D                 mov     ebp, esp
.text$mn:00000B3F                 push    0FFFFFFFFh
.text$mn:00000B41                 push    offset __ehhandler$??0_Generic_error_category@std@@QAE@XZ
.text$mn:00000B46                 mov     eax, large fs:0
.text$mn:00000B4C                 push    eax
.text$mn:00000B4D                 push    ecx
.text$mn:00000B4E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000B53                 xor     eax, ebp
.text$mn:00000B55                 push    eax
.text$mn:00000B56                 lea     eax, [ebp+var_C]
.text$mn:00000B59                 mov     large fs:0, eax
.text$mn:00000B5F                 mov     [ebp+var_10], ecx
.text$mn:00000B62                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000B65                 call    ??0error_category@std@@QAE@XZ ; std::error_category::error_category(void)
.text$mn:00000B6A                 mov     [ebp+var_4], 0
.text$mn:00000B71                 mov     eax, [ebp+var_10]
.text$mn:00000B74                 mov     dword ptr [eax], offset ??_7_Generic_error_category@std@@6B@ ; const std::_Generic_error_category::`vftable'
.text$mn:00000B7A                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000B81                 mov     eax, [ebp+var_10]
.text$mn:00000B84                 mov     ecx, [ebp+var_C]
.text$mn:00000B87                 mov     large fs:0, ecx
.text$mn:00000B8E                 pop     ecx
.text$mn:00000B8F                 mov     esp, ebp
.text$mn:00000B91                 pop     ebp
.text$mn:00000B92                 retn
.text$mn:00000B92 ??0_Generic_error_category@std@@QAE@XZ endp
.text$mn:00000B92
.text$mn:00000B92 ; ---------------------------------------------------------------------------
.text$mn:00000B93                 align 4
.text$mn:00000B93 _text$mn        ends
.text$mn:00000B93
.text$x:00000B94 ; ===========================================================================
.text$x:00000B94
.text$x:00000B94 ; Segment type: Pure code
.text$x:00000B94 ; Segment permissions: Read/Execute
.text$x:00000B94 _text$x         segment para public 'CODE' use32
.text$x:00000B94                 assume cs:_text$x
.text$x:00000B94                 ;org 0B94h
.text$x:00000B94 ; COMDAT (pick associative to section at B3C)
.text$x:00000B94                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000B94
.text$x:00000B94 ; =============== S U B R O U T I N E =======================================
.text$x:00000B94
.text$x:00000B94
.text$x:00000B94 __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0 proc near
.text$x:00000B94                                         ; DATA XREF: .xdata$x:0000238Co
.text$x:00000B94                 mov     ecx, [ebp-10h]  ; this
.text$x:00000B97                 jmp     ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$x:00000B97 __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0 endp
.text$x:00000B97
.text$x:00000B9C
.text$x:00000B9C ; =============== S U B R O U T I N E =======================================
.text$x:00000B9C
.text$x:00000B9C
.text$x:00000B9C __ehhandler$??0_Generic_error_category@std@@QAE@XZ proc near
.text$x:00000B9C                                         ; DATA XREF: std::_Generic_error_category::_Generic_error_category(void)+5o
.text$x:00000B9C
.text$x:00000B9C arg_4           = dword ptr  8
.text$x:00000B9C
.text$x:00000B9C                 mov     edx, [esp+arg_4]
.text$x:00000BA0                 lea     eax, [edx+0Ch]
.text$x:00000BA3                 mov     ecx, [edx-8]
.text$x:00000BA6                 xor     ecx, eax
.text$x:00000BA8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000BAD                 mov     eax, offset __ehfuncinfo$??0_Generic_error_category@std@@QAE@XZ
.text$x:00000BB2                 jmp     ___CxxFrameHandler3
.text$x:00000BB2 __ehhandler$??0_Generic_error_category@std@@QAE@XZ endp
.text$x:00000BB2
.text$x:00000BB2 ; ---------------------------------------------------------------------------
.text$x:00000BB7                 align 4
.text$x:00000BB7 _text$x         ends
.text$x:00000BB7
.text$mn:00000BB8 ; ===========================================================================
.text$mn:00000BB8
.text$mn:00000BB8 ; Segment type: Pure code
.text$mn:00000BB8 ; Segment permissions: Read/Execute
.text$mn:00000BB8 _text$mn        segment para public 'CODE' use32
.text$mn:00000BB8                 assume cs:_text$mn
.text$mn:00000BB8                 ;org 0BB8h
.text$mn:00000BB8 ; COMDAT (pick any)
.text$mn:00000BB8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000BB8
.text$mn:00000BB8 ; =============== S U B R O U T I N E =======================================
.text$mn:00000BB8
.text$mn:00000BB8 ; Attributes: bp-based frame
.text$mn:00000BB8
.text$mn:00000BB8 ; _DWORD __thiscall std::_Iostream_error_category::_Iostream_error_category(std::_Iostream_error_category *__hidden this)
.text$mn:00000BB8                 public ??0_Iostream_error_category@std@@QAE@XZ
.text$mn:00000BB8 ??0_Iostream_error_category@std@@QAE@XZ proc near
.text$mn:00000BB8                                         ; CODE XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p
.text$mn:00000BB8
.text$mn:00000BB8 var_10          = dword ptr -10h
.text$mn:00000BB8 var_C           = dword ptr -0Ch
.text$mn:00000BB8 var_4           = dword ptr -4
.text$mn:00000BB8
.text$mn:00000BB8                 push    ebp
.text$mn:00000BB9                 mov     ebp, esp
.text$mn:00000BBB                 push    0FFFFFFFFh
.text$mn:00000BBD                 push    offset __ehhandler$??0_Iostream_error_category@std@@QAE@XZ
.text$mn:00000BC2                 mov     eax, large fs:0
.text$mn:00000BC8                 push    eax
.text$mn:00000BC9                 push    ecx
.text$mn:00000BCA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000BCF                 xor     eax, ebp
.text$mn:00000BD1                 push    eax
.text$mn:00000BD2                 lea     eax, [ebp+var_C]
.text$mn:00000BD5                 mov     large fs:0, eax
.text$mn:00000BDB                 mov     [ebp+var_10], ecx
.text$mn:00000BDE                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000BE1                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$mn:00000BE6                 mov     [ebp+var_4], 0
.text$mn:00000BED                 mov     eax, [ebp+var_10]
.text$mn:00000BF0                 mov     dword ptr [eax], offset ??_7_Iostream_error_category@std@@6B@ ; const std::_Iostream_error_category::`vftable'
.text$mn:00000BF6                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000BFD                 mov     eax, [ebp+var_10]
.text$mn:00000C00                 mov     ecx, [ebp+var_C]
.text$mn:00000C03                 mov     large fs:0, ecx
.text$mn:00000C0A                 pop     ecx
.text$mn:00000C0B                 mov     esp, ebp
.text$mn:00000C0D                 pop     ebp
.text$mn:00000C0E                 retn
.text$mn:00000C0E ??0_Iostream_error_category@std@@QAE@XZ endp
.text$mn:00000C0E
.text$mn:00000C0E ; ---------------------------------------------------------------------------
.text$mn:00000C0F                 align 10h
.text$mn:00000C0F _text$mn        ends
.text$mn:00000C0F
.text$x:00000C10 ; ===========================================================================
.text$x:00000C10
.text$x:00000C10 ; Segment type: Pure code
.text$x:00000C10 ; Segment permissions: Read/Execute
.text$x:00000C10 _text$x         segment para public 'CODE' use32
.text$x:00000C10                 assume cs:_text$x
.text$x:00000C10                 ;org 0C10h
.text$x:00000C10 ; COMDAT (pick associative to section at BB8)
.text$x:00000C10                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000C10
.text$x:00000C10 ; =============== S U B R O U T I N E =======================================
.text$x:00000C10
.text$x:00000C10
.text$x:00000C10 __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0 proc near
.text$x:00000C10                                         ; DATA XREF: .xdata$x:00002410o
.text$x:00000C10                 mov     ecx, [ebp-10h]  ; this
.text$x:00000C13                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00000C13 __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0 endp
.text$x:00000C13
.text$x:00000C18
.text$x:00000C18 ; =============== S U B R O U T I N E =======================================
.text$x:00000C18
.text$x:00000C18
.text$x:00000C18 __ehhandler$??0_Iostream_error_category@std@@QAE@XZ proc near
.text$x:00000C18                                         ; DATA XREF: std::_Iostream_error_category::_Iostream_error_category(void)+5o
.text$x:00000C18
.text$x:00000C18 arg_4           = dword ptr  8
.text$x:00000C18
.text$x:00000C18                 mov     edx, [esp+arg_4]
.text$x:00000C1C                 lea     eax, [edx+0Ch]
.text$x:00000C1F                 mov     ecx, [edx-8]
.text$x:00000C22                 xor     ecx, eax
.text$x:00000C24                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000C29                 mov     eax, offset __ehfuncinfo$??0_Iostream_error_category@std@@QAE@XZ
.text$x:00000C2E                 jmp     ___CxxFrameHandler3
.text$x:00000C2E __ehhandler$??0_Iostream_error_category@std@@QAE@XZ endp
.text$x:00000C2E
.text$x:00000C2E ; ---------------------------------------------------------------------------
.text$x:00000C33                 align 4
.text$x:00000C33 _text$x         ends
.text$x:00000C33
.text$mn:00000C34 ; ===========================================================================
.text$mn:00000C34
.text$mn:00000C34 ; Segment type: Pure code
.text$mn:00000C34 ; Segment permissions: Read/Execute
.text$mn:00000C34 _text$mn        segment para public 'CODE' use32
.text$mn:00000C34                 assume cs:_text$mn
.text$mn:00000C34                 ;org 0C34h
.text$mn:00000C34 ; COMDAT (pick any)
.text$mn:00000C34                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000C34
.text$mn:00000C34 ; =============== S U B R O U T I N E =======================================
.text$mn:00000C34
.text$mn:00000C34 ; Attributes: bp-based frame
.text$mn:00000C34
.text$mn:00000C34 ; _DWORD __thiscall std::_System_error_category::_System_error_category(std::_System_error_category *__hidden this)
.text$mn:00000C34                 public ??0_System_error_category@std@@QAE@XZ
.text$mn:00000C34 ??0_System_error_category@std@@QAE@XZ proc near
.text$mn:00000C34                                         ; CODE XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p
.text$mn:00000C34
.text$mn:00000C34 var_10          = dword ptr -10h
.text$mn:00000C34 var_C           = dword ptr -0Ch
.text$mn:00000C34 var_4           = dword ptr -4
.text$mn:00000C34
.text$mn:00000C34                 push    ebp
.text$mn:00000C35                 mov     ebp, esp
.text$mn:00000C37                 push    0FFFFFFFFh
.text$mn:00000C39                 push    offset __ehhandler$??0_System_error_category@std@@QAE@XZ
.text$mn:00000C3E                 mov     eax, large fs:0
.text$mn:00000C44                 push    eax
.text$mn:00000C45                 push    ecx
.text$mn:00000C46                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000C4B                 xor     eax, ebp
.text$mn:00000C4D                 push    eax
.text$mn:00000C4E                 lea     eax, [ebp+var_C]
.text$mn:00000C51                 mov     large fs:0, eax
.text$mn:00000C57                 mov     [ebp+var_10], ecx
.text$mn:00000C5A                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000C5D                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$mn:00000C62                 mov     [ebp+var_4], 0
.text$mn:00000C69                 mov     eax, [ebp+var_10]
.text$mn:00000C6C                 mov     dword ptr [eax], offset ??_7_System_error_category@std@@6B@ ; const std::_System_error_category::`vftable'
.text$mn:00000C72                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000C79                 mov     eax, [ebp+var_10]
.text$mn:00000C7C                 mov     ecx, [ebp+var_C]
.text$mn:00000C7F                 mov     large fs:0, ecx
.text$mn:00000C86                 pop     ecx
.text$mn:00000C87                 mov     esp, ebp
.text$mn:00000C89                 pop     ebp
.text$mn:00000C8A                 retn
.text$mn:00000C8A ??0_System_error_category@std@@QAE@XZ endp
.text$mn:00000C8A
.text$mn:00000C8A ; ---------------------------------------------------------------------------
.text$mn:00000C8B                 align 4
.text$mn:00000C8B _text$mn        ends
.text$mn:00000C8B
.text$x:00000C8C ; ===========================================================================
.text$x:00000C8C
.text$x:00000C8C ; Segment type: Pure code
.text$x:00000C8C ; Segment permissions: Read/Execute
.text$x:00000C8C _text$x         segment para public 'CODE' use32
.text$x:00000C8C                 assume cs:_text$x
.text$x:00000C8C                 ;org 0C8Ch
.text$x:00000C8C ; COMDAT (pick associative to section at C34)
.text$x:00000C8C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000C8C
.text$x:00000C8C ; =============== S U B R O U T I N E =======================================
.text$x:00000C8C
.text$x:00000C8C
.text$x:00000C8C __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0 proc near
.text$x:00000C8C                                         ; DATA XREF: .xdata$x:00002494o
.text$x:00000C8C                 mov     ecx, [ebp-10h]  ; this
.text$x:00000C8F                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00000C8F __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0 endp
.text$x:00000C8F
.text$x:00000C94
.text$x:00000C94 ; =============== S U B R O U T I N E =======================================
.text$x:00000C94
.text$x:00000C94
.text$x:00000C94 __ehhandler$??0_System_error_category@std@@QAE@XZ proc near
.text$x:00000C94                                         ; DATA XREF: std::_System_error_category::_System_error_category(void)+5o
.text$x:00000C94
.text$x:00000C94 arg_4           = dword ptr  8
.text$x:00000C94
.text$x:00000C94                 mov     edx, [esp+arg_4]
.text$x:00000C98                 lea     eax, [edx+0Ch]
.text$x:00000C9B                 mov     ecx, [edx-8]
.text$x:00000C9E                 xor     ecx, eax
.text$x:00000CA0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000CA5                 mov     eax, offset __ehfuncinfo$??0_System_error_category@std@@QAE@XZ
.text$x:00000CAA                 jmp     ___CxxFrameHandler3
.text$x:00000CAA __ehhandler$??0_System_error_category@std@@QAE@XZ endp
.text$x:00000CAA
.text$x:00000CAA ; ---------------------------------------------------------------------------
.text$x:00000CAF                 align 10h
.text$x:00000CAF _text$x         ends
.text$x:00000CAF
.text$mn:00000CB0 ; ===========================================================================
.text$mn:00000CB0
.text$mn:00000CB0 ; Segment type: Pure code
.text$mn:00000CB0 ; Segment permissions: Read/Execute
.text$mn:00000CB0 _text$mn        segment para public 'CODE' use32
.text$mn:00000CB0                 assume cs:_text$mn
.text$mn:00000CB0                 ;org 0CB0h
.text$mn:00000CB0 ; COMDAT (pick any)
.text$mn:00000CB0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000CB0
.text$mn:00000CB0 ; =============== S U B R O U T I N E =======================================
.text$mn:00000CB0
.text$mn:00000CB0 ; Attributes: bp-based frame
.text$mn:00000CB0
.text$mn:00000CB0 ; _DWORD __thiscall std::error_category::error_category(std::error_category *__hidden this)
.text$mn:00000CB0                 public ??0error_category@std@@QAE@XZ
.text$mn:00000CB0 ??0error_category@std@@QAE@XZ proc near ; CODE XREF: std::_Generic_error_category::_Generic_error_category(void)+29p
.text$mn:00000CB0
.text$mn:00000CB0 var_4           = dword ptr -4
.text$mn:00000CB0
.text$mn:00000CB0                 push    ebp
.text$mn:00000CB1                 mov     ebp, esp
.text$mn:00000CB3                 push    ecx
.text$mn:00000CB4                 mov     [ebp+var_4], ecx
.text$mn:00000CB7                 mov     eax, [ebp+var_4]
.text$mn:00000CBA                 mov     dword ptr [eax], offset ??_7error_category@std@@6B@ ; const std::error_category::`vftable'
.text$mn:00000CC0                 mov     eax, [ebp+var_4]
.text$mn:00000CC3                 mov     esp, ebp
.text$mn:00000CC5                 pop     ebp
.text$mn:00000CC6                 retn
.text$mn:00000CC6 ??0error_category@std@@QAE@XZ endp
.text$mn:00000CC6
.text$mn:00000CC6 ; ---------------------------------------------------------------------------
.text$mn:00000CC7                 align 4
.text$mn:00000CC7 _text$mn        ends
.text$mn:00000CC7
.text$mn:00000CC8 ; ===========================================================================
.text$mn:00000CC8
.text$mn:00000CC8 ; Segment type: Pure code
.text$mn:00000CC8 ; Segment permissions: Read/Execute
.text$mn:00000CC8 _text$mn        segment para public 'CODE' use32
.text$mn:00000CC8                 assume cs:_text$mn
.text$mn:00000CC8                 ;org 0CC8h
.text$mn:00000CC8 ; COMDAT (pick any)
.text$mn:00000CC8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000CC8
.text$mn:00000CC8 ; =============== S U B R O U T I N E =======================================
.text$mn:00000CC8
.text$mn:00000CC8 ; Attributes: bp-based frame
.text$mn:00000CC8
.text$mn:00000CC8 ; _DWORD __thiscall std::error_condition::error_condition(std::error_condition *this, int, const struct std::error_category *)
.text$mn:00000CC8                 public ??0error_condition@std@@QAE@HABVerror_category@1@@Z
.text$mn:00000CC8 ??0error_condition@std@@QAE@HABVerror_category@1@@Z proc near
.text$mn:00000CC8                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+24p
.text$mn:00000CC8                                         ; std::_System_error_category::default_error_condition(int)+3Dp ...
.text$mn:00000CC8
.text$mn:00000CC8 var_4           = dword ptr -4
.text$mn:00000CC8 arg_0           = dword ptr  8
.text$mn:00000CC8 arg_4           = dword ptr  0Ch
.text$mn:00000CC8
.text$mn:00000CC8                 push    ebp
.text$mn:00000CC9                 mov     ebp, esp
.text$mn:00000CCB                 push    ecx
.text$mn:00000CCC                 mov     [ebp+var_4], ecx
.text$mn:00000CCF                 mov     eax, [ebp+var_4]
.text$mn:00000CD2                 mov     ecx, [ebp+arg_0]
.text$mn:00000CD5                 mov     [eax], ecx
.text$mn:00000CD7                 mov     edx, [ebp+var_4]
.text$mn:00000CDA                 mov     eax, [ebp+arg_4]
.text$mn:00000CDD                 mov     [edx+4], eax
.text$mn:00000CE0                 mov     eax, [ebp+var_4]
.text$mn:00000CE3                 mov     esp, ebp
.text$mn:00000CE5                 pop     ebp
.text$mn:00000CE6                 retn    8
.text$mn:00000CE6 ??0error_condition@std@@QAE@HABVerror_category@1@@Z endp
.text$mn:00000CE6
.text$mn:00000CE6 ; ---------------------------------------------------------------------------
.text$mn:00000CE9                 align 4
.text$mn:00000CE9 _text$mn        ends
.text$mn:00000CE9
.text$mn:00000CEC ; ===========================================================================
.text$mn:00000CEC
.text$mn:00000CEC ; Segment type: Pure code
.text$mn:00000CEC ; Segment permissions: Read/Execute
.text$mn:00000CEC _text$mn        segment para public 'CODE' use32
.text$mn:00000CEC                 assume cs:_text$mn
.text$mn:00000CEC                 ;org 0CECh
.text$mn:00000CEC ; COMDAT (pick any)
.text$mn:00000CEC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000CEC
.text$mn:00000CEC ; =============== S U B R O U T I N E =======================================
.text$mn:00000CEC
.text$mn:00000CEC ; Attributes: bp-based frame
.text$mn:00000CEC
.text$mn:00000CEC ; _DWORD __thiscall std::locale::id::id(std::locale::id *this, unsigned int)
.text$mn:00000CEC                 public ??0id@locale@std@@QAE@I@Z
.text$mn:00000CEC ??0id@locale@std@@QAE@I@Z proc near     ; CODE XREF: `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)+Ap
.text$mn:00000CEC                                         ; `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)+Ap ...
.text$mn:00000CEC
.text$mn:00000CEC var_4           = dword ptr -4
.text$mn:00000CEC arg_0           = dword ptr  8
.text$mn:00000CEC
.text$mn:00000CEC                 push    ebp
.text$mn:00000CED                 mov     ebp, esp
.text$mn:00000CEF                 push    ecx
.text$mn:00000CF0                 mov     [ebp+var_4], ecx
.text$mn:00000CF3                 mov     eax, [ebp+var_4]
.text$mn:00000CF6                 mov     ecx, [ebp+arg_0]
.text$mn:00000CF9                 mov     [eax], ecx
.text$mn:00000CFB                 mov     eax, [ebp+var_4]
.text$mn:00000CFE                 mov     esp, ebp
.text$mn:00000D00                 pop     ebp
.text$mn:00000D01                 retn    4
.text$mn:00000D01 ??0id@locale@std@@QAE@I@Z endp
.text$mn:00000D01
.text$mn:00000D01 _text$mn        ends
.text$mn:00000D01
.text$mn:00000D04 ; ===========================================================================
.text$mn:00000D04
.text$mn:00000D04 ; Segment type: Pure code
.text$mn:00000D04 ; Segment permissions: Read/Execute
.text$mn:00000D04 _text$mn        segment para public 'CODE' use32
.text$mn:00000D04                 assume cs:_text$mn
.text$mn:00000D04                 ;org 0D04h
.text$mn:00000D04 ; COMDAT (pick any)
.text$mn:00000D04                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000D04
.text$mn:00000D04 ; =============== S U B R O U T I N E =======================================
.text$mn:00000D04
.text$mn:00000D04 ; Attributes: bp-based frame
.text$mn:00000D04
.text$mn:00000D04 ; _DWORD __thiscall std::runtime_error::runtime_error(std::runtime_error *this, const struct std::runtime_error *)
.text$mn:00000D04                 public ??0runtime_error@std@@QAE@ABV01@@Z
.text$mn:00000D04 ??0runtime_error@std@@QAE@ABV01@@Z proc near
.text$mn:00000D04                                         ; DATA XREF: .xdata$x:000025CCo
.text$mn:00000D04
.text$mn:00000D04 var_10          = dword ptr -10h
.text$mn:00000D04 var_C           = dword ptr -0Ch
.text$mn:00000D04 var_4           = dword ptr -4
.text$mn:00000D04 arg_0           = dword ptr  8
.text$mn:00000D04
.text$mn:00000D04                 push    ebp
.text$mn:00000D05                 mov     ebp, esp
.text$mn:00000D07                 push    0FFFFFFFFh
.text$mn:00000D09                 push    offset __ehhandler$??0runtime_error@std@@QAE@ABV01@@Z
.text$mn:00000D0E                 mov     eax, large fs:0
.text$mn:00000D14                 push    eax
.text$mn:00000D15                 push    ecx
.text$mn:00000D16                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000D1B                 xor     eax, ebp
.text$mn:00000D1D                 push    eax
.text$mn:00000D1E                 lea     eax, [ebp+var_C]
.text$mn:00000D21                 mov     large fs:0, eax
.text$mn:00000D27                 mov     [ebp+var_10], ecx
.text$mn:00000D2A                 mov     eax, [ebp+arg_0]
.text$mn:00000D2D                 push    eax             ; struct std::exception *
.text$mn:00000D2E                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000D31                 call    ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception(std::exception const &)
.text$mn:00000D36                 mov     [ebp+var_4], 0
.text$mn:00000D3D                 mov     ecx, [ebp+var_10]
.text$mn:00000D40                 mov     dword ptr [ecx], offset ??_7runtime_error@std@@6B@ ; const std::runtime_error::`vftable'
.text$mn:00000D46                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000D4D                 mov     eax, [ebp+var_10]
.text$mn:00000D50                 mov     ecx, [ebp+var_C]
.text$mn:00000D53                 mov     large fs:0, ecx
.text$mn:00000D5A                 pop     ecx
.text$mn:00000D5B                 mov     esp, ebp
.text$mn:00000D5D                 pop     ebp
.text$mn:00000D5E                 retn    4
.text$mn:00000D5E ??0runtime_error@std@@QAE@ABV01@@Z endp
.text$mn:00000D5E
.text$mn:00000D5E ; ---------------------------------------------------------------------------
.text$mn:00000D61                 align 4
.text$mn:00000D61 _text$mn        ends
.text$mn:00000D61
.text$x:00000D64 ; ===========================================================================
.text$x:00000D64
.text$x:00000D64 ; Segment type: Pure code
.text$x:00000D64 ; Segment permissions: Read/Execute
.text$x:00000D64 _text$x         segment para public 'CODE' use32
.text$x:00000D64                 assume cs:_text$x
.text$x:00000D64                 ;org 0D64h
.text$x:00000D64 ; COMDAT (pick associative to section at D04)
.text$x:00000D64                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000D64
.text$x:00000D64 ; =============== S U B R O U T I N E =======================================
.text$x:00000D64
.text$x:00000D64
.text$x:00000D64 __unwindfunclet$??0runtime_error@std@@QAE@ABV01@@Z$0 proc near
.text$x:00000D64                                         ; DATA XREF: .xdata$x:00002360o
.text$x:00000D64                 mov     ecx, [ebp-10h]  ; this
.text$x:00000D67                 jmp     ??1exception@std@@UAE@XZ ; std::exception::~exception(void)
.text$x:00000D67 __unwindfunclet$??0runtime_error@std@@QAE@ABV01@@Z$0 endp
.text$x:00000D67
.text$x:00000D6C
.text$x:00000D6C ; =============== S U B R O U T I N E =======================================
.text$x:00000D6C
.text$x:00000D6C
.text$x:00000D6C __ehhandler$??0runtime_error@std@@QAE@ABV01@@Z proc near
.text$x:00000D6C                                         ; DATA XREF: std::runtime_error::runtime_error(std::runtime_error const &)+5o
.text$x:00000D6C
.text$x:00000D6C arg_4           = dword ptr  8
.text$x:00000D6C
.text$x:00000D6C                 mov     edx, [esp+arg_4]
.text$x:00000D70                 lea     eax, [edx+0Ch]
.text$x:00000D73                 mov     ecx, [edx-8]
.text$x:00000D76                 xor     ecx, eax
.text$x:00000D78                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000D7D                 mov     eax, offset __ehfuncinfo$??0runtime_error@std@@QAE@ABV01@@Z
.text$x:00000D82                 jmp     ___CxxFrameHandler3
.text$x:00000D82 __ehhandler$??0runtime_error@std@@QAE@ABV01@@Z endp
.text$x:00000D82
.text$x:00000D82 ; ---------------------------------------------------------------------------
.text$x:00000D87                 align 4
.text$x:00000D87 _text$x         ends
.text$x:00000D87
.text$mn:00000D88 ; ===========================================================================
.text$mn:00000D88
.text$mn:00000D88 ; Segment type: Pure code
.text$mn:00000D88 ; Segment permissions: Read/Execute
.text$mn:00000D88 _text$mn        segment para public 'CODE' use32
.text$mn:00000D88                 assume cs:_text$mn
.text$mn:00000D88                 ;org 0D88h
.text$mn:00000D88 ; COMDAT (pick any)
.text$mn:00000D88                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000D88
.text$mn:00000D88 ; =============== S U B R O U T I N E =======================================
.text$mn:00000D88
.text$mn:00000D88 ; Attributes: bp-based frame
.text$mn:00000D88
.text$mn:00000D88 ; _DWORD __thiscall std::runtime_error::runtime_error(std::runtime_error *this, const char *)
.text$mn:00000D88                 public ??0runtime_error@std@@QAE@PBD@Z
.text$mn:00000D88 ??0runtime_error@std@@QAE@PBD@Z proc near
.text$mn:00000D88                                         ; CODE XREF: DockingSplitter::init(HINSTANCE__ *,HWND__ *,HWND__ *,uint)+E0p
.text$mn:00000D88                                         ; DockingSplitter::init(HINSTANCE__ *,HWND__ *,HWND__ *,uint)+168p
.text$mn:00000D88
.text$mn:00000D88 var_10          = dword ptr -10h
.text$mn:00000D88 var_C           = dword ptr -0Ch
.text$mn:00000D88 var_4           = dword ptr -4
.text$mn:00000D88 arg_0           = dword ptr  8
.text$mn:00000D88
.text$mn:00000D88                 push    ebp
.text$mn:00000D89                 mov     ebp, esp
.text$mn:00000D8B                 push    0FFFFFFFFh
.text$mn:00000D8D                 push    offset __ehhandler$??0runtime_error@std@@QAE@PBD@Z
.text$mn:00000D92                 mov     eax, large fs:0
.text$mn:00000D98                 push    eax
.text$mn:00000D99                 push    ecx
.text$mn:00000D9A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000D9F                 xor     eax, ebp
.text$mn:00000DA1                 push    eax
.text$mn:00000DA2                 lea     eax, [ebp+var_C]
.text$mn:00000DA5                 mov     large fs:0, eax
.text$mn:00000DAB                 mov     [ebp+var_10], ecx
.text$mn:00000DAE                 lea     eax, [ebp+arg_0]
.text$mn:00000DB1                 push    eax             ; char **
.text$mn:00000DB2                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000DB5                 call    ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception(char const * const &)
.text$mn:00000DBA                 mov     [ebp+var_4], 0
.text$mn:00000DC1                 mov     ecx, [ebp+var_10]
.text$mn:00000DC4                 mov     dword ptr [ecx], offset ??_7runtime_error@std@@6B@ ; const std::runtime_error::`vftable'
.text$mn:00000DCA                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000DD1                 mov     eax, [ebp+var_10]
.text$mn:00000DD4                 mov     ecx, [ebp+var_C]
.text$mn:00000DD7                 mov     large fs:0, ecx
.text$mn:00000DDE                 pop     ecx
.text$mn:00000DDF                 mov     esp, ebp
.text$mn:00000DE1                 pop     ebp
.text$mn:00000DE2                 retn    4
.text$mn:00000DE2 ??0runtime_error@std@@QAE@PBD@Z endp
.text$mn:00000DE2
.text$mn:00000DE2 ; ---------------------------------------------------------------------------
.text$mn:00000DE5                 align 4
.text$mn:00000DE5 _text$mn        ends
.text$mn:00000DE5
.text$x:00000DE8 ; ===========================================================================
.text$x:00000DE8
.text$x:00000DE8 ; Segment type: Pure code
.text$x:00000DE8 ; Segment permissions: Read/Execute
.text$x:00000DE8 _text$x         segment para public 'CODE' use32
.text$x:00000DE8                 assume cs:_text$x
.text$x:00000DE8                 ;org 0DE8h
.text$x:00000DE8 ; COMDAT (pick associative to section at D88)
.text$x:00000DE8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000DE8
.text$x:00000DE8 ; =============== S U B R O U T I N E =======================================
.text$x:00000DE8
.text$x:00000DE8
.text$x:00000DE8 __unwindfunclet$??0runtime_error@std@@QAE@PBD@Z$0 proc near
.text$x:00000DE8                                         ; DATA XREF: .xdata$x:00002308o
.text$x:00000DE8                 mov     ecx, [ebp-10h]  ; this
.text$x:00000DEB                 jmp     ??1exception@std@@UAE@XZ ; std::exception::~exception(void)
.text$x:00000DEB __unwindfunclet$??0runtime_error@std@@QAE@PBD@Z$0 endp
.text$x:00000DEB
.text$x:00000DF0
.text$x:00000DF0 ; =============== S U B R O U T I N E =======================================
.text$x:00000DF0
.text$x:00000DF0
.text$x:00000DF0 __ehhandler$??0runtime_error@std@@QAE@PBD@Z proc near
.text$x:00000DF0                                         ; DATA XREF: std::runtime_error::runtime_error(char const *)+5o
.text$x:00000DF0
.text$x:00000DF0 arg_4           = dword ptr  8
.text$x:00000DF0
.text$x:00000DF0                 mov     edx, [esp+arg_4]
.text$x:00000DF4                 lea     eax, [edx+0Ch]
.text$x:00000DF7                 mov     ecx, [edx-8]
.text$x:00000DFA                 xor     ecx, eax
.text$x:00000DFC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000E01                 mov     eax, offset __ehfuncinfo$??0runtime_error@std@@QAE@PBD@Z
.text$x:00000E06                 jmp     ___CxxFrameHandler3
.text$x:00000E06 __ehhandler$??0runtime_error@std@@QAE@PBD@Z endp
.text$x:00000E06
.text$x:00000E06 ; ---------------------------------------------------------------------------
.text$x:00000E0B                 align 4
.text$x:00000E0B _text$x         ends
.text$x:00000E0B
.text$mn:00000E0C ; ===========================================================================
.text$mn:00000E0C
.text$mn:00000E0C ; Segment type: Pure code
.text$mn:00000E0C ; Segment permissions: Read/Execute
.text$mn:00000E0C _text$mn        segment para public 'CODE' use32
.text$mn:00000E0C                 assume cs:_text$mn
.text$mn:00000E0C                 ;org 0E0Ch
.text$mn:00000E0C ; COMDAT (pick any)
.text$mn:00000E0C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000E0C
.text$mn:00000E0C ; =============== S U B R O U T I N E =======================================
.text$mn:00000E0C
.text$mn:00000E0C ; Attributes: bp-based frame
.text$mn:00000E0C
.text$mn:00000E0C ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::~_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>(void)
.text$mn:00000E0C                 public ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$mn:00000E0C ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00000E0C                                         ; CODE XREF: __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0+3j
.text$mn:00000E0C                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+43p ...
.text$mn:00000E0C
.text$mn:00000E0C var_10          = dword ptr -10h
.text$mn:00000E0C var_C           = dword ptr -0Ch
.text$mn:00000E0C var_4           = dword ptr -4
.text$mn:00000E0C
.text$mn:00000E0C                 push    ebp
.text$mn:00000E0D                 mov     ebp, esp
.text$mn:00000E0F                 push    0FFFFFFFFh
.text$mn:00000E11                 push    offset __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$mn:00000E16                 mov     eax, large fs:0
.text$mn:00000E1C                 push    eax
.text$mn:00000E1D                 push    ecx
.text$mn:00000E1E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000E23                 xor     eax, ebp
.text$mn:00000E25                 push    eax
.text$mn:00000E26                 lea     eax, [ebp+var_C]
.text$mn:00000E29                 mov     large fs:0, eax
.text$mn:00000E2F                 mov     [ebp+var_10], ecx
.text$mn:00000E32                 mov     [ebp+var_4], 0
.text$mn:00000E39                 mov     ecx, [ebp+var_10]
.text$mn:00000E3C                 call    ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)
.text$mn:00000E41                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000E48                 mov     ecx, [ebp+var_10]
.text$mn:00000E4B                 call    ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$mn:00000E50                 mov     ecx, [ebp+var_C]
.text$mn:00000E53                 mov     large fs:0, ecx
.text$mn:00000E5A                 pop     ecx
.text$mn:00000E5B                 mov     esp, ebp
.text$mn:00000E5D                 pop     ebp
.text$mn:00000E5E                 retn
.text$mn:00000E5E ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp
.text$mn:00000E5E
.text$mn:00000E5E ; ---------------------------------------------------------------------------
.text$mn:00000E5F                 align 10h
.text$mn:00000E5F _text$mn        ends
.text$mn:00000E5F
.text$x:00000E60 ; ===========================================================================
.text$x:00000E60
.text$x:00000E60 ; Segment type: Pure code
.text$x:00000E60 ; Segment permissions: Read/Execute
.text$x:00000E60 _text$x         segment para public 'CODE' use32
.text$x:00000E60                 assume cs:_text$x
.text$x:00000E60                 ;org 0E60h
.text$x:00000E60 ; COMDAT (pick associative to section at E0C)
.text$x:00000E60                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000E60
.text$x:00000E60 ; =============== S U B R O U T I N E =======================================
.text$x:00000E60
.text$x:00000E60
.text$x:00000E60 __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00000E60                                         ; DATA XREF: .xdata$x:000021F8o
.text$x:00000E60                 mov     ecx, [ebp-10h]
.text$x:00000E63                 jmp     ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$x:00000E63 __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:00000E63
.text$x:00000E68
.text$x:00000E68 ; =============== S U B R O U T I N E =======================================
.text$x:00000E68
.text$x:00000E68
.text$x:00000E68 __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
.text$x:00000E68                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+5o
.text$x:00000E68
.text$x:00000E68 arg_4           = dword ptr  8
.text$x:00000E68
.text$x:00000E68                 mov     edx, [esp+arg_4]
.text$x:00000E6C                 lea     eax, [edx+0Ch]
.text$x:00000E6F                 mov     ecx, [edx-8]
.text$x:00000E72                 xor     ecx, eax
.text$x:00000E74                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000E79                 mov     eax, offset __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$x:00000E7E                 jmp     ___CxxFrameHandler3
.text$x:00000E7E __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp
.text$x:00000E7E
.text$x:00000E7E ; ---------------------------------------------------------------------------
.text$x:00000E83                 align 4
.text$x:00000E83 _text$x         ends
.text$x:00000E83
.text$mn:00000E84 ; ===========================================================================
.text$mn:00000E84
.text$mn:00000E84 ; Segment type: Pure code
.text$mn:00000E84 ; Segment permissions: Read/Execute
.text$mn:00000E84 _text$mn        segment para public 'CODE' use32
.text$mn:00000E84                 assume cs:_text$mn
.text$mn:00000E84                 ;org 0E84h
.text$mn:00000E84 ; COMDAT (pick any)
.text$mn:00000E84                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000E84
.text$mn:00000E84 ; =============== S U B R O U T I N E =======================================
.text$mn:00000E84
.text$mn:00000E84 ; Attributes: bp-based frame
.text$mn:00000E84
.text$mn:00000E84 ; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::~_String_val<struct std::_Simple_types<char>>(void)
.text$mn:00000E84                 public ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00000E84 ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$mn:00000E84                                         ; CODE XREF: __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0+3j
.text$mn:00000E84                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+3Fp ...
.text$mn:00000E84
.text$mn:00000E84 var_10          = dword ptr -10h
.text$mn:00000E84 var_C           = dword ptr -0Ch
.text$mn:00000E84 var_4           = dword ptr -4
.text$mn:00000E84
.text$mn:00000E84                 push    ebp
.text$mn:00000E85                 mov     ebp, esp
.text$mn:00000E87                 push    0FFFFFFFFh
.text$mn:00000E89                 push    offset __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00000E8E                 mov     eax, large fs:0
.text$mn:00000E94                 push    eax
.text$mn:00000E95                 push    ecx
.text$mn:00000E96                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000E9B                 xor     eax, ebp
.text$mn:00000E9D                 push    eax
.text$mn:00000E9E                 lea     eax, [ebp+var_C]
.text$mn:00000EA1                 mov     large fs:0, eax
.text$mn:00000EA7                 mov     [ebp+var_10], ecx
.text$mn:00000EAA                 mov     [ebp+var_4], 0
.text$mn:00000EB1                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000EB8                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000EBB                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:00000EC0                 mov     ecx, [ebp+var_C]
.text$mn:00000EC3                 mov     large fs:0, ecx
.text$mn:00000ECA                 pop     ecx
.text$mn:00000ECB                 mov     esp, ebp
.text$mn:00000ECD                 pop     ebp
.text$mn:00000ECE                 retn
.text$mn:00000ECE ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$mn:00000ECE
.text$mn:00000ECE ; ---------------------------------------------------------------------------
.text$mn:00000ECF                 align 10h
.text$mn:00000ECF _text$mn        ends
.text$mn:00000ECF
.text$x:00000ED0 ; ===========================================================================
.text$x:00000ED0
.text$x:00000ED0 ; Segment type: Pure code
.text$x:00000ED0 ; Segment permissions: Read/Execute
.text$x:00000ED0 _text$x         segment para public 'CODE' use32
.text$x:00000ED0                 assume cs:_text$x
.text$x:00000ED0                 ;org 0ED0h
.text$x:00000ED0 ; COMDAT (pick associative to section at E84)
.text$x:00000ED0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000ED0
.text$x:00000ED0 ; =============== S U B R O U T I N E =======================================
.text$x:00000ED0
.text$x:00000ED0
.text$x:00000ED0 __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 proc near
.text$x:00000ED0                                         ; DATA XREF: .xdata$x:000021A0o
.text$x:00000ED0                 mov     ecx, [ebp-10h]  ; this
.text$x:00000ED3                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00000ED3 __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 endp
.text$x:00000ED3
.text$x:00000ED8
.text$x:00000ED8 ; =============== S U B R O U T I N E =======================================
.text$x:00000ED8
.text$x:00000ED8
.text$x:00000ED8 __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$x:00000ED8                                         ; DATA XREF: std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)+5o
.text$x:00000ED8
.text$x:00000ED8 arg_4           = dword ptr  8
.text$x:00000ED8
.text$x:00000ED8                 mov     edx, [esp+arg_4]
.text$x:00000EDC                 lea     eax, [edx+0Ch]
.text$x:00000EDF                 mov     ecx, [edx-8]
.text$x:00000EE2                 xor     ecx, eax
.text$x:00000EE4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000EE9                 mov     eax, offset __ehfuncinfo$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$x:00000EEE                 jmp     ___CxxFrameHandler3
.text$x:00000EEE __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$x:00000EEE
.text$x:00000EEE ; ---------------------------------------------------------------------------
.text$x:00000EF3                 align 4
.text$x:00000EF3 _text$x         ends
.text$x:00000EF3
.text$mn:00000EF4 ; ===========================================================================
.text$mn:00000EF4
.text$mn:00000EF4 ; Segment type: Pure code
.text$mn:00000EF4 ; Segment permissions: Read/Execute
.text$mn:00000EF4 _text$mn        segment para public 'CODE' use32
.text$mn:00000EF4                 assume cs:_text$mn
.text$mn:00000EF4                 ;org 0EF4h
.text$mn:00000EF4 ; COMDAT (pick any)
.text$mn:00000EF4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000EF4
.text$mn:00000EF4 ; =============== S U B R O U T I N E =======================================
.text$mn:00000EF4
.text$mn:00000EF4 ; Attributes: bp-based frame
.text$mn:00000EF4
.text$mn:00000EF4 ; public: __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::~basic_string<char, struct std::char_traits<char>, class std::allocator<char>>(void)
.text$mn:00000EF4                 public ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:00000EF4 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$mn:00000EF4                                         ; CODE XREF: __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+13j
.text$mn:00000EF4                                         ; __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+13j ...
.text$mn:00000EF4
.text$mn:00000EF4 var_10          = dword ptr -10h
.text$mn:00000EF4 var_C           = dword ptr -0Ch
.text$mn:00000EF4 var_4           = dword ptr -4
.text$mn:00000EF4
.text$mn:00000EF4                 push    ebp
.text$mn:00000EF5                 mov     ebp, esp
.text$mn:00000EF7                 push    0FFFFFFFFh
.text$mn:00000EF9                 push    offset __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:00000EFE                 mov     eax, large fs:0
.text$mn:00000F04                 push    eax
.text$mn:00000F05                 push    ecx
.text$mn:00000F06                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000F0B                 xor     eax, ebp
.text$mn:00000F0D                 push    eax
.text$mn:00000F0E                 lea     eax, [ebp+var_C]
.text$mn:00000F11                 mov     large fs:0, eax
.text$mn:00000F17                 mov     [ebp+var_10], ecx
.text$mn:00000F1A                 mov     [ebp+var_4], 0
.text$mn:00000F21                 push    0               ; Size
.text$mn:00000F23                 push    1               ; char
.text$mn:00000F25                 mov     ecx, [ebp+var_10]
.text$mn:00000F28                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00000F2D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000F34                 mov     ecx, [ebp+var_10]
.text$mn:00000F37                 call    ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$mn:00000F3C                 mov     ecx, [ebp+var_C]
.text$mn:00000F3F                 mov     large fs:0, ecx
.text$mn:00000F46                 pop     ecx
.text$mn:00000F47                 mov     esp, ebp
.text$mn:00000F49                 pop     ebp
.text$mn:00000F4A                 retn
.text$mn:00000F4A ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$mn:00000F4A
.text$mn:00000F4A ; ---------------------------------------------------------------------------
.text$mn:00000F4B                 align 4
.text$mn:00000F4B _text$mn        ends
.text$mn:00000F4B
.text$x:00000F4C ; ===========================================================================
.text$x:00000F4C
.text$x:00000F4C ; Segment type: Pure code
.text$x:00000F4C ; Segment permissions: Read/Execute
.text$x:00000F4C _text$x         segment para public 'CODE' use32
.text$x:00000F4C                 assume cs:_text$x
.text$x:00000F4C                 ;org 0F4Ch
.text$x:00000F4C ; COMDAT (pick associative to section at EF4)
.text$x:00000F4C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000F4C
.text$x:00000F4C ; =============== S U B R O U T I N E =======================================
.text$x:00000F4C
.text$x:00000F4C
.text$x:00000F4C __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 proc near
.text$x:00000F4C                                         ; DATA XREF: .xdata$x:00002250o
.text$x:00000F4C                 mov     ecx, [ebp-10h]
.text$x:00000F4F                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:00000F4F __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 endp
.text$x:00000F4F
.text$x:00000F54
.text$x:00000F54 ; =============== S U B R O U T I N E =======================================
.text$x:00000F54
.text$x:00000F54
.text$x:00000F54 __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$x:00000F54                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+5o
.text$x:00000F54
.text$x:00000F54 arg_4           = dword ptr  8
.text$x:00000F54
.text$x:00000F54                 mov     edx, [esp+arg_4]
.text$x:00000F58                 lea     eax, [edx+0Ch]
.text$x:00000F5B                 mov     ecx, [edx-8]
.text$x:00000F5E                 xor     ecx, eax
.text$x:00000F60                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000F65                 mov     eax, offset __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$x:00000F6A                 jmp     ___CxxFrameHandler3
.text$x:00000F6A __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$x:00000F6A
.text$x:00000F6A ; ---------------------------------------------------------------------------
.text$x:00000F6F                 align 10h
.text$x:00000F6F _text$x         ends
.text$x:00000F6F
.text$mn:00000F70 ; ===========================================================================
.text$mn:00000F70
.text$mn:00000F70 ; Segment type: Pure code
.text$mn:00000F70 ; Segment permissions: Read/Execute
.text$mn:00000F70 _text$mn        segment para public 'CODE' use32
.text$mn:00000F70                 assume cs:_text$mn
.text$mn:00000F70                 ;org 0F70h
.text$mn:00000F70 ; COMDAT (pick any)
.text$mn:00000F70                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000F70
.text$mn:00000F70 ; =============== S U B R O U T I N E =======================================
.text$mn:00000F70
.text$mn:00000F70 ; Attributes: bp-based frame
.text$mn:00000F70
.text$mn:00000F70 ; _DWORD __thiscall std::_Container_base12::~_Container_base12(std::_Container_base12 *__hidden this)
.text$mn:00000F70                 public ??1_Container_base12@std@@QAE@XZ
.text$mn:00000F70 ??1_Container_base12@std@@QAE@XZ proc near
.text$mn:00000F70                                         ; CODE XREF: __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0+3j
.text$mn:00000F70                                         ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)+37p ...
.text$mn:00000F70
.text$mn:00000F70 var_4           = dword ptr -4
.text$mn:00000F70
.text$mn:00000F70                 push    ebp
.text$mn:00000F71                 mov     ebp, esp
.text$mn:00000F73                 push    ecx
.text$mn:00000F74                 mov     [ebp+var_4], ecx
.text$mn:00000F77                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000F7A                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00000F7F                 mov     esp, ebp
.text$mn:00000F81                 pop     ebp
.text$mn:00000F82                 retn
.text$mn:00000F82 ??1_Container_base12@std@@QAE@XZ endp
.text$mn:00000F82
.text$mn:00000F82 ; ---------------------------------------------------------------------------
.text$mn:00000F83                 align 4
.text$mn:00000F83 _text$mn        ends
.text$mn:00000F83
.text$mn:00000F84 ; ===========================================================================
.text$mn:00000F84
.text$mn:00000F84 ; Segment type: Pure code
.text$mn:00000F84 ; Segment permissions: Read/Execute
.text$mn:00000F84 _text$mn        segment para public 'CODE' use32
.text$mn:00000F84                 assume cs:_text$mn
.text$mn:00000F84                 ;org 0F84h
.text$mn:00000F84 ; COMDAT (pick any)
.text$mn:00000F84                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000F84
.text$mn:00000F84 ; =============== S U B R O U T I N E =======================================
.text$mn:00000F84
.text$mn:00000F84 ; Attributes: bp-based frame
.text$mn:00000F84
.text$mn:00000F84 ; _DWORD __thiscall std::_Generic_error_category::~_Generic_error_category(std::_Generic_error_category *__hidden this)
.text$mn:00000F84                 public ??1_Generic_error_category@std@@UAE@XZ
.text$mn:00000F84 ??1_Generic_error_category@std@@UAE@XZ proc near
.text$mn:00000F84                                         ; CODE XREF: __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0+3j
.text$mn:00000F84                                         ; __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0+3j ...
.text$mn:00000F84
.text$mn:00000F84 var_10          = dword ptr -10h
.text$mn:00000F84 var_C           = dword ptr -0Ch
.text$mn:00000F84 var_4           = dword ptr -4
.text$mn:00000F84
.text$mn:00000F84                 push    ebp
.text$mn:00000F85                 mov     ebp, esp
.text$mn:00000F87                 push    0FFFFFFFFh
.text$mn:00000F89                 push    offset __ehhandler$??1_Generic_error_category@std@@UAE@XZ
.text$mn:00000F8E                 mov     eax, large fs:0
.text$mn:00000F94                 push    eax
.text$mn:00000F95                 push    ecx
.text$mn:00000F96                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000F9B                 xor     eax, ebp
.text$mn:00000F9D                 push    eax
.text$mn:00000F9E                 lea     eax, [ebp+var_C]
.text$mn:00000FA1                 mov     large fs:0, eax
.text$mn:00000FA7                 mov     [ebp+var_10], ecx
.text$mn:00000FAA                 mov     [ebp+var_4], 0
.text$mn:00000FB1                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000FB8                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000FBB                 call    ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$mn:00000FC0                 mov     ecx, [ebp+var_C]
.text$mn:00000FC3                 mov     large fs:0, ecx
.text$mn:00000FCA                 pop     ecx
.text$mn:00000FCB                 mov     esp, ebp
.text$mn:00000FCD                 pop     ebp
.text$mn:00000FCE                 retn
.text$mn:00000FCE ??1_Generic_error_category@std@@UAE@XZ endp
.text$mn:00000FCE
.text$mn:00000FCE ; ---------------------------------------------------------------------------
.text$mn:00000FCF                 align 10h
.text$mn:00000FCF _text$mn        ends
.text$mn:00000FCF
.text$x:00000FD0 ; ===========================================================================
.text$x:00000FD0
.text$x:00000FD0 ; Segment type: Pure code
.text$x:00000FD0 ; Segment permissions: Read/Execute
.text$x:00000FD0 _text$x         segment para public 'CODE' use32
.text$x:00000FD0                 assume cs:_text$x
.text$x:00000FD0                 ;org 0FD0h
.text$x:00000FD0 ; COMDAT (pick associative to section at F84)
.text$x:00000FD0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000FD0
.text$x:00000FD0 ; =============== S U B R O U T I N E =======================================
.text$x:00000FD0
.text$x:00000FD0
.text$x:00000FD0 __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0 proc near
.text$x:00000FD0                                         ; DATA XREF: .xdata$x:000023E4o
.text$x:00000FD0                 mov     ecx, [ebp-10h]  ; this
.text$x:00000FD3                 jmp     ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$x:00000FD3 __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0 endp
.text$x:00000FD3
.text$x:00000FD8
.text$x:00000FD8 ; =============== S U B R O U T I N E =======================================
.text$x:00000FD8
.text$x:00000FD8
.text$x:00000FD8 __ehhandler$??1_Generic_error_category@std@@UAE@XZ proc near
.text$x:00000FD8                                         ; DATA XREF: std::_Generic_error_category::~_Generic_error_category(void)+5o
.text$x:00000FD8
.text$x:00000FD8 arg_4           = dword ptr  8
.text$x:00000FD8
.text$x:00000FD8                 mov     edx, [esp+arg_4]
.text$x:00000FDC                 lea     eax, [edx+0Ch]
.text$x:00000FDF                 mov     ecx, [edx-8]
.text$x:00000FE2                 xor     ecx, eax
.text$x:00000FE4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000FE9                 mov     eax, offset __ehfuncinfo$??1_Generic_error_category@std@@UAE@XZ
.text$x:00000FEE                 jmp     ___CxxFrameHandler3
.text$x:00000FEE __ehhandler$??1_Generic_error_category@std@@UAE@XZ endp
.text$x:00000FEE
.text$x:00000FEE ; ---------------------------------------------------------------------------
.text$x:00000FF3                 align 4
.text$x:00000FF3 _text$x         ends
.text$x:00000FF3
.text$mn:00000FF4 ; ===========================================================================
.text$mn:00000FF4
.text$mn:00000FF4 ; Segment type: Pure code
.text$mn:00000FF4 ; Segment permissions: Read/Execute
.text$mn:00000FF4 _text$mn        segment para public 'CODE' use32
.text$mn:00000FF4                 assume cs:_text$mn
.text$mn:00000FF4                 ;org 0FF4h
.text$mn:00000FF4 ; COMDAT (pick any)
.text$mn:00000FF4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000FF4
.text$mn:00000FF4 ; =============== S U B R O U T I N E =======================================
.text$mn:00000FF4
.text$mn:00000FF4 ; Attributes: bp-based frame
.text$mn:00000FF4
.text$mn:00000FF4 ; _DWORD __thiscall std::_Iostream_error_category::~_Iostream_error_category(std::_Iostream_error_category *__hidden this)
.text$mn:00000FF4                 public ??1_Iostream_error_category@std@@UAE@XZ
.text$mn:00000FF4 ??1_Iostream_error_category@std@@UAE@XZ proc near
.text$mn:00000FF4                                         ; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+Ap
.text$mn:00000FF4                                         ; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p
.text$mn:00000FF4
.text$mn:00000FF4 var_10          = dword ptr -10h
.text$mn:00000FF4 var_C           = dword ptr -0Ch
.text$mn:00000FF4 var_4           = dword ptr -4
.text$mn:00000FF4
.text$mn:00000FF4                 push    ebp
.text$mn:00000FF5                 mov     ebp, esp
.text$mn:00000FF7                 push    0FFFFFFFFh
.text$mn:00000FF9                 push    offset __ehhandler$??1_Iostream_error_category@std@@UAE@XZ
.text$mn:00000FFE                 mov     eax, large fs:0
.text$mn:00001004                 push    eax
.text$mn:00001005                 push    ecx
.text$mn:00001006                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000100B                 xor     eax, ebp
.text$mn:0000100D                 push    eax
.text$mn:0000100E                 lea     eax, [ebp+var_C]
.text$mn:00001011                 mov     large fs:0, eax
.text$mn:00001017                 mov     [ebp+var_10], ecx
.text$mn:0000101A                 mov     [ebp+var_4], 0
.text$mn:00001021                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001028                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000102B                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:00001030                 mov     ecx, [ebp+var_C]
.text$mn:00001033                 mov     large fs:0, ecx
.text$mn:0000103A                 pop     ecx
.text$mn:0000103B                 mov     esp, ebp
.text$mn:0000103D                 pop     ebp
.text$mn:0000103E                 retn
.text$mn:0000103E ??1_Iostream_error_category@std@@UAE@XZ endp
.text$mn:0000103E
.text$mn:0000103E ; ---------------------------------------------------------------------------
.text$mn:0000103F                 align 10h
.text$mn:0000103F _text$mn        ends
.text$mn:0000103F
.text$x:00001040 ; ===========================================================================
.text$x:00001040
.text$x:00001040 ; Segment type: Pure code
.text$x:00001040 ; Segment permissions: Read/Execute
.text$x:00001040 _text$x         segment para public 'CODE' use32
.text$x:00001040                 assume cs:_text$x
.text$x:00001040                 ;org 1040h
.text$x:00001040 ; COMDAT (pick associative to section at FF4)
.text$x:00001040                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001040
.text$x:00001040 ; =============== S U B R O U T I N E =======================================
.text$x:00001040
.text$x:00001040
.text$x:00001040 __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0 proc near
.text$x:00001040                                         ; DATA XREF: .xdata$x:00002468o
.text$x:00001040                 mov     ecx, [ebp-10h]  ; this
.text$x:00001043                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00001043 __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0 endp
.text$x:00001043
.text$x:00001048
.text$x:00001048 ; =============== S U B R O U T I N E =======================================
.text$x:00001048
.text$x:00001048
.text$x:00001048 __ehhandler$??1_Iostream_error_category@std@@UAE@XZ proc near
.text$x:00001048                                         ; DATA XREF: std::_Iostream_error_category::~_Iostream_error_category(void)+5o
.text$x:00001048
.text$x:00001048 arg_4           = dword ptr  8
.text$x:00001048
.text$x:00001048                 mov     edx, [esp+arg_4]
.text$x:0000104C                 lea     eax, [edx+0Ch]
.text$x:0000104F                 mov     ecx, [edx-8]
.text$x:00001052                 xor     ecx, eax
.text$x:00001054                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001059                 mov     eax, offset __ehfuncinfo$??1_Iostream_error_category@std@@UAE@XZ
.text$x:0000105E                 jmp     ___CxxFrameHandler3
.text$x:0000105E __ehhandler$??1_Iostream_error_category@std@@UAE@XZ endp
.text$x:0000105E
.text$x:0000105E ; ---------------------------------------------------------------------------
.text$x:00001063                 align 4
.text$x:00001063 _text$x         ends
.text$x:00001063
.text$mn:00001064 ; ===========================================================================
.text$mn:00001064
.text$mn:00001064 ; Segment type: Pure code
.text$mn:00001064 ; Segment permissions: Read/Execute
.text$mn:00001064 _text$mn        segment para public 'CODE' use32
.text$mn:00001064                 assume cs:_text$mn
.text$mn:00001064                 ;org 1064h
.text$mn:00001064 ; COMDAT (pick any)
.text$mn:00001064                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001064
.text$mn:00001064 ; =============== S U B R O U T I N E =======================================
.text$mn:00001064
.text$mn:00001064 ; Attributes: bp-based frame
.text$mn:00001064
.text$mn:00001064 ; _DWORD __thiscall std::_System_error_category::~_System_error_category(std::_System_error_category *__hidden this)
.text$mn:00001064                 public ??1_System_error_category@std@@UAE@XZ
.text$mn:00001064 ??1_System_error_category@std@@UAE@XZ proc near
.text$mn:00001064                                         ; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+Ap
.text$mn:00001064                                         ; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p
.text$mn:00001064
.text$mn:00001064 var_10          = dword ptr -10h
.text$mn:00001064 var_C           = dword ptr -0Ch
.text$mn:00001064 var_4           = dword ptr -4
.text$mn:00001064
.text$mn:00001064                 push    ebp
.text$mn:00001065                 mov     ebp, esp
.text$mn:00001067                 push    0FFFFFFFFh
.text$mn:00001069                 push    offset __ehhandler$??1_System_error_category@std@@UAE@XZ
.text$mn:0000106E                 mov     eax, large fs:0
.text$mn:00001074                 push    eax
.text$mn:00001075                 push    ecx
.text$mn:00001076                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000107B                 xor     eax, ebp
.text$mn:0000107D                 push    eax
.text$mn:0000107E                 lea     eax, [ebp+var_C]
.text$mn:00001081                 mov     large fs:0, eax
.text$mn:00001087                 mov     [ebp+var_10], ecx
.text$mn:0000108A                 mov     [ebp+var_4], 0
.text$mn:00001091                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001098                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000109B                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:000010A0                 mov     ecx, [ebp+var_C]
.text$mn:000010A3                 mov     large fs:0, ecx
.text$mn:000010AA                 pop     ecx
.text$mn:000010AB                 mov     esp, ebp
.text$mn:000010AD                 pop     ebp
.text$mn:000010AE                 retn
.text$mn:000010AE ??1_System_error_category@std@@UAE@XZ endp
.text$mn:000010AE
.text$mn:000010AE ; ---------------------------------------------------------------------------
.text$mn:000010AF                 align 10h
.text$mn:000010AF _text$mn        ends
.text$mn:000010AF
.text$x:000010B0 ; ===========================================================================
.text$x:000010B0
.text$x:000010B0 ; Segment type: Pure code
.text$x:000010B0 ; Segment permissions: Read/Execute
.text$x:000010B0 _text$x         segment para public 'CODE' use32
.text$x:000010B0                 assume cs:_text$x
.text$x:000010B0                 ;org 10B0h
.text$x:000010B0 ; COMDAT (pick associative to section at 1064)
.text$x:000010B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000010B0
.text$x:000010B0 ; =============== S U B R O U T I N E =======================================
.text$x:000010B0
.text$x:000010B0
.text$x:000010B0 __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0 proc near
.text$x:000010B0                                         ; DATA XREF: .xdata$x:000024ECo
.text$x:000010B0                 mov     ecx, [ebp-10h]  ; this
.text$x:000010B3                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:000010B3 __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0 endp
.text$x:000010B3
.text$x:000010B8
.text$x:000010B8 ; =============== S U B R O U T I N E =======================================
.text$x:000010B8
.text$x:000010B8
.text$x:000010B8 __ehhandler$??1_System_error_category@std@@UAE@XZ proc near
.text$x:000010B8                                         ; DATA XREF: std::_System_error_category::~_System_error_category(void)+5o
.text$x:000010B8
.text$x:000010B8 arg_4           = dword ptr  8
.text$x:000010B8
.text$x:000010B8                 mov     edx, [esp+arg_4]
.text$x:000010BC                 lea     eax, [edx+0Ch]
.text$x:000010BF                 mov     ecx, [edx-8]
.text$x:000010C2                 xor     ecx, eax
.text$x:000010C4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000010C9                 mov     eax, offset __ehfuncinfo$??1_System_error_category@std@@UAE@XZ
.text$x:000010CE                 jmp     ___CxxFrameHandler3
.text$x:000010CE __ehhandler$??1_System_error_category@std@@UAE@XZ endp
.text$x:000010CE
.text$x:000010CE ; ---------------------------------------------------------------------------
.text$x:000010D3                 align 4
.text$x:000010D3 _text$x         ends
.text$x:000010D3
.text$mn:000010D4 ; ===========================================================================
.text$mn:000010D4
.text$mn:000010D4 ; Segment type: Pure code
.text$mn:000010D4 ; Segment permissions: Read/Execute
.text$mn:000010D4 _text$mn        segment para public 'CODE' use32
.text$mn:000010D4                 assume cs:_text$mn
.text$mn:000010D4                 ;org 10D4h
.text$mn:000010D4 ; COMDAT (pick any)
.text$mn:000010D4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000010D4
.text$mn:000010D4 ; =============== S U B R O U T I N E =======================================
.text$mn:000010D4
.text$mn:000010D4 ; Attributes: bp-based frame
.text$mn:000010D4
.text$mn:000010D4 ; _DWORD __thiscall std::error_category::~error_category(std::error_category *__hidden this)
.text$mn:000010D4                 public ??1error_category@std@@UAE@XZ
.text$mn:000010D4 ??1error_category@std@@UAE@XZ proc near ; CODE XREF: __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0+3j
.text$mn:000010D4                                         ; std::_Generic_error_category::~_Generic_error_category(void)+37p ...
.text$mn:000010D4
.text$mn:000010D4 var_4           = dword ptr -4
.text$mn:000010D4
.text$mn:000010D4                 push    ebp
.text$mn:000010D5                 mov     ebp, esp
.text$mn:000010D7                 push    ecx
.text$mn:000010D8                 mov     [ebp+var_4], ecx
.text$mn:000010DB                 mov     eax, [ebp+var_4]
.text$mn:000010DE                 mov     dword ptr [eax], offset ??_7error_category@std@@6B@ ; const std::error_category::`vftable'
.text$mn:000010E4                 mov     esp, ebp
.text$mn:000010E6                 pop     ebp
.text$mn:000010E7                 retn
.text$mn:000010E7 ??1error_category@std@@UAE@XZ endp
.text$mn:000010E7
.text$mn:000010E7 _text$mn        ends
.text$mn:000010E7
.text$mn:000010E8 ; ===========================================================================
.text$mn:000010E8
.text$mn:000010E8 ; Segment type: Pure code
.text$mn:000010E8 ; Segment permissions: Read/Execute
.text$mn:000010E8 _text$mn        segment para public 'CODE' use32
.text$mn:000010E8                 assume cs:_text$mn
.text$mn:000010E8                 ;org 10E8h
.text$mn:000010E8 ; COMDAT (pick any)
.text$mn:000010E8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000010E8
.text$mn:000010E8 ; =============== S U B R O U T I N E =======================================
.text$mn:000010E8
.text$mn:000010E8 ; Attributes: bp-based frame
.text$mn:000010E8
.text$mn:000010E8 ; _DWORD __thiscall std::runtime_error::~runtime_error(std::runtime_error *__hidden this)
.text$mn:000010E8                 public ??1runtime_error@std@@UAE@XZ
.text$mn:000010E8 ??1runtime_error@std@@UAE@XZ proc near  ; CODE XREF: std::runtime_error::`scalar deleting destructor'(uint)+Ap
.text$mn:000010E8                                         ; DATA XREF: .xdata$x:0000257Co
.text$mn:000010E8
.text$mn:000010E8 var_10          = dword ptr -10h
.text$mn:000010E8 var_C           = dword ptr -0Ch
.text$mn:000010E8 var_4           = dword ptr -4
.text$mn:000010E8
.text$mn:000010E8                 push    ebp
.text$mn:000010E9                 mov     ebp, esp
.text$mn:000010EB                 push    0FFFFFFFFh
.text$mn:000010ED                 push    offset __ehhandler$??1runtime_error@std@@UAE@XZ
.text$mn:000010F2                 mov     eax, large fs:0
.text$mn:000010F8                 push    eax
.text$mn:000010F9                 push    ecx
.text$mn:000010FA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000010FF                 xor     eax, ebp
.text$mn:00001101                 push    eax
.text$mn:00001102                 lea     eax, [ebp+var_C]
.text$mn:00001105                 mov     large fs:0, eax
.text$mn:0000110B                 mov     [ebp+var_10], ecx
.text$mn:0000110E                 mov     [ebp+var_4], 0
.text$mn:00001115                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000111C                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000111F                 call    ??1exception@std@@UAE@XZ ; std::exception::~exception(void)
.text$mn:00001124                 mov     ecx, [ebp+var_C]
.text$mn:00001127                 mov     large fs:0, ecx
.text$mn:0000112E                 pop     ecx
.text$mn:0000112F                 mov     esp, ebp
.text$mn:00001131                 pop     ebp
.text$mn:00001132                 retn
.text$mn:00001132 ??1runtime_error@std@@UAE@XZ endp
.text$mn:00001132
.text$mn:00001132 ; ---------------------------------------------------------------------------
.text$mn:00001133                 align 4
.text$mn:00001133 _text$mn        ends
.text$mn:00001133
.text$x:00001134 ; ===========================================================================
.text$x:00001134
.text$x:00001134 ; Segment type: Pure code
.text$x:00001134 ; Segment permissions: Read/Execute
.text$x:00001134 _text$x         segment para public 'CODE' use32
.text$x:00001134                 assume cs:_text$x
.text$x:00001134                 ;org 1134h
.text$x:00001134 ; COMDAT (pick associative to section at 10E8)
.text$x:00001134                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001134
.text$x:00001134 ; =============== S U B R O U T I N E =======================================
.text$x:00001134
.text$x:00001134
.text$x:00001134 __unwindfunclet$??1runtime_error@std@@UAE@XZ$0 proc near
.text$x:00001134                                         ; DATA XREF: .xdata$x:00002334o
.text$x:00001134                 mov     ecx, [ebp-10h]  ; this
.text$x:00001137                 jmp     ??1exception@std@@UAE@XZ ; std::exception::~exception(void)
.text$x:00001137 __unwindfunclet$??1runtime_error@std@@UAE@XZ$0 endp
.text$x:00001137
.text$x:0000113C
.text$x:0000113C ; =============== S U B R O U T I N E =======================================
.text$x:0000113C
.text$x:0000113C
.text$x:0000113C __ehhandler$??1runtime_error@std@@UAE@XZ proc near
.text$x:0000113C                                         ; DATA XREF: std::runtime_error::~runtime_error(void)+5o
.text$x:0000113C
.text$x:0000113C arg_4           = dword ptr  8
.text$x:0000113C
.text$x:0000113C                 mov     edx, [esp+arg_4]
.text$x:00001140                 lea     eax, [edx+0Ch]
.text$x:00001143                 mov     ecx, [edx-8]
.text$x:00001146                 xor     ecx, eax
.text$x:00001148                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000114D                 mov     eax, offset __ehfuncinfo$??1runtime_error@std@@UAE@XZ
.text$x:00001152                 jmp     ___CxxFrameHandler3
.text$x:00001152 __ehhandler$??1runtime_error@std@@UAE@XZ endp
.text$x:00001152
.text$x:00001152 ; ---------------------------------------------------------------------------
.text$x:00001157                 align 4
.text$x:00001157 _text$x         ends
.text$x:00001157
.text$mn:00001158 ; ===========================================================================
.text$mn:00001158
.text$mn:00001158 ; Segment type: Pure code
.text$mn:00001158 ; Segment permissions: Read/Execute
.text$mn:00001158 _text$mn        segment para public 'CODE' use32
.text$mn:00001158                 assume cs:_text$mn
.text$mn:00001158                 ;org 1158h
.text$mn:00001158 ; COMDAT (pick any)
.text$mn:00001158                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001158
.text$mn:00001158 ; =============== S U B R O U T I N E =======================================
.text$mn:00001158
.text$mn:00001158 ; Attributes: bp-based frame
.text$mn:00001158
.text$mn:00001158 ; void *__cdecl operator new(unsigned int, void *)
.text$mn:00001158                 public ??2@YAPAXIPAX@Z
.text$mn:00001158 ??2@YAPAXIPAX@Z proc near               ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+2Ep
.text$mn:00001158                                         ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+2Ep
.text$mn:00001158
.text$mn:00001158 arg_4           = dword ptr  0Ch
.text$mn:00001158
.text$mn:00001158                 push    ebp
.text$mn:00001159                 mov     ebp, esp
.text$mn:0000115B                 mov     eax, [ebp+arg_4]
.text$mn:0000115E                 pop     ebp
.text$mn:0000115F                 retn
.text$mn:0000115F ??2@YAPAXIPAX@Z endp
.text$mn:0000115F
.text$mn:0000115F _text$mn        ends
.text$mn:0000115F
.text$mn:00001160 ; ===========================================================================
.text$mn:00001160
.text$mn:00001160 ; Segment type: Pure code
.text$mn:00001160 ; Segment permissions: Read/Execute
.text$mn:00001160 _text$mn        segment para public 'CODE' use32
.text$mn:00001160                 assume cs:_text$mn
.text$mn:00001160                 ;org 1160h
.text$mn:00001160 ; COMDAT (pick any)
.text$mn:00001160                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001160
.text$mn:00001160 ; =============== S U B R O U T I N E =======================================
.text$mn:00001160
.text$mn:00001160 ; Attributes: bp-based frame
.text$mn:00001160
.text$mn:00001160 ; void __cdecl operator delete(void *)
.text$mn:00001160                 public ??3@YAXPAX0@Z
.text$mn:00001160 ??3@YAXPAX0@Z   proc near               ; CODE XREF: __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0+8p
.text$mn:00001160                                         ; __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0+8p
.text$mn:00001160                 push    ebp
.text$mn:00001161                 mov     ebp, esp
.text$mn:00001163                 pop     ebp
.text$mn:00001164                 retn
.text$mn:00001164 ??3@YAXPAX0@Z   endp
.text$mn:00001164
.text$mn:00001164 ; ---------------------------------------------------------------------------
.text$mn:00001165                 align 4
.text$mn:00001165 _text$mn        ends
.text$mn:00001165
.text$mn:00001168 ; ===========================================================================
.text$mn:00001168
.text$mn:00001168 ; Segment type: Pure code
.text$mn:00001168 ; Segment permissions: Read/Execute
.text$mn:00001168 _text$mn        segment para public 'CODE' use32
.text$mn:00001168                 assume cs:_text$mn
.text$mn:00001168                 ;org 1168h
.text$mn:00001168 ; COMDAT (pick any)
.text$mn:00001168                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001168
.text$mn:00001168 ; =============== S U B R O U T I N E =======================================
.text$mn:00001168
.text$mn:00001168 ; Attributes: bp-based frame
.text$mn:00001168
.text$mn:00001168 ; public: bool __thiscall std::error_category::operator==(class std::error_category const &)const
.text$mn:00001168                 public ??8error_category@std@@QBE_NABV01@@Z
.text$mn:00001168 ??8error_category@std@@QBE_NABV01@@Z proc near
.text$mn:00001168                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+1Dp
.text$mn:00001168                                         ; std::error_category::equivalent(std::error_code const &,int)+15p
.text$mn:00001168
.text$mn:00001168 var_8           = dword ptr -8
.text$mn:00001168 var_4           = dword ptr -4
.text$mn:00001168 arg_0           = dword ptr  8
.text$mn:00001168
.text$mn:00001168                 push    ebp
.text$mn:00001169                 mov     ebp, esp
.text$mn:0000116B                 sub     esp, 8
.text$mn:0000116E                 mov     [ebp+var_8], ecx
.text$mn:00001171                 mov     eax, [ebp+var_8]
.text$mn:00001174                 cmp     eax, [ebp+arg_0]
.text$mn:00001177                 jnz     short loc_1182
.text$mn:00001179                 mov     [ebp+var_4], 1
.text$mn:00001180                 jmp     short loc_1189
.text$mn:00001182 ; ---------------------------------------------------------------------------
.text$mn:00001182
.text$mn:00001182 loc_1182:                               ; CODE XREF: std::error_category::operator==(std::error_category const &)+Fj
.text$mn:00001182                 mov     [ebp+var_4], 0
.text$mn:00001189
.text$mn:00001189 loc_1189:                               ; CODE XREF: std::error_category::operator==(std::error_category const &)+18j
.text$mn:00001189                 mov     al, byte ptr [ebp+var_4]
.text$mn:0000118C                 mov     esp, ebp
.text$mn:0000118E                 pop     ebp
.text$mn:0000118F                 retn    4
.text$mn:0000118F ??8error_category@std@@QBE_NABV01@@Z endp
.text$mn:0000118F
.text$mn:0000118F ; ---------------------------------------------------------------------------
.text$mn:00001192                 align 4
.text$mn:00001192 _text$mn        ends
.text$mn:00001192
.text$mn:00001194 ; ===========================================================================
.text$mn:00001194
.text$mn:00001194 ; Segment type: Pure code
.text$mn:00001194 ; Segment permissions: Read/Execute
.text$mn:00001194 _text$mn        segment para public 'CODE' use32
.text$mn:00001194                 assume cs:_text$mn
.text$mn:00001194                 ;org 1194h
.text$mn:00001194 ; COMDAT (pick any)
.text$mn:00001194                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001194
.text$mn:00001194 ; =============== S U B R O U T I N E =======================================
.text$mn:00001194
.text$mn:00001194 ; Attributes: bp-based frame
.text$mn:00001194
.text$mn:00001194 ; int __stdcall std::error_condition::operator==(std::error_condition *)
.text$mn:00001194                 public ??8error_condition@std@@QBE_NABV01@@Z
.text$mn:00001194 ??8error_condition@std@@QBE_NABV01@@Z proc near
.text$mn:00001194                                         ; CODE XREF: std::error_category::equivalent(int,std::error_condition const &)+24p
.text$mn:00001194
.text$mn:00001194 var_8           = dword ptr -8
.text$mn:00001194 var_4           = dword ptr -4
.text$mn:00001194 arg_0           = dword ptr  8
.text$mn:00001194
.text$mn:00001194                 push    ebp
.text$mn:00001195                 mov     ebp, esp
.text$mn:00001197                 sub     esp, 8
.text$mn:0000119A                 push    esi
.text$mn:0000119B                 mov     [ebp+var_4], ecx
.text$mn:0000119E                 mov     ecx, [ebp+arg_0] ; this
.text$mn:000011A1                 call    ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
.text$mn:000011A6                 push    eax
.text$mn:000011A7                 mov     ecx, [ebp+var_4] ; this
.text$mn:000011AA                 call    ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
.text$mn:000011AF                 mov     ecx, eax
.text$mn:000011B1                 call    ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
.text$mn:000011B6                 movzx   eax, al
.text$mn:000011B9                 test    eax, eax
.text$mn:000011BB                 jz      short loc_11DC
.text$mn:000011BD                 mov     ecx, [ebp+var_4] ; this
.text$mn:000011C0                 call    ?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
.text$mn:000011C5                 mov     esi, eax
.text$mn:000011C7                 mov     ecx, [ebp+arg_0] ; this
.text$mn:000011CA                 call    ?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
.text$mn:000011CF                 cmp     esi, eax
.text$mn:000011D1                 jnz     short loc_11DC
.text$mn:000011D3                 mov     [ebp+var_8], 1
.text$mn:000011DA                 jmp     short loc_11E3
.text$mn:000011DC ; ---------------------------------------------------------------------------
.text$mn:000011DC
.text$mn:000011DC loc_11DC:                               ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+27j
.text$mn:000011DC                                         ; std::error_condition::operator==(std::error_condition const &)+3Dj
.text$mn:000011DC                 mov     [ebp+var_8], 0
.text$mn:000011E3
.text$mn:000011E3 loc_11E3:                               ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+46j
.text$mn:000011E3                 mov     al, byte ptr [ebp+var_8]
.text$mn:000011E6                 pop     esi
.text$mn:000011E7                 mov     esp, ebp
.text$mn:000011E9                 pop     ebp
.text$mn:000011EA                 retn    4
.text$mn:000011EA ??8error_condition@std@@QBE_NABV01@@Z endp
.text$mn:000011EA
.text$mn:000011EA ; ---------------------------------------------------------------------------
.text$mn:000011ED                 align 10h
.text$mn:000011ED _text$mn        ends
.text$mn:000011ED
.text$mn:000011F0 ; ===========================================================================
.text$mn:000011F0
.text$mn:000011F0 ; Segment type: Pure code
.text$mn:000011F0 ; Segment permissions: Read/Execute
.text$mn:000011F0 _text$mn        segment para public 'CODE' use32
.text$mn:000011F0                 assume cs:_text$mn
.text$mn:000011F0                 ;org 11F0h
.text$mn:000011F0 ; COMDAT (pick any)
.text$mn:000011F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000011F0
.text$mn:000011F0 ; =============== S U B R O U T I N E =======================================
.text$mn:000011F0
.text$mn:000011F0 ; Attributes: bp-based frame
.text$mn:000011F0
.text$mn:000011F0 ; public: virtual void * __thiscall std::_Generic_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:000011F0                 public ??_G_Generic_error_category@std@@UAEPAXI@Z
.text$mn:000011F0 ??_G_Generic_error_category@std@@UAEPAXI@Z proc near
.text$mn:000011F0
.text$mn:000011F0 var_4           = dword ptr -4
.text$mn:000011F0 arg_0           = dword ptr  8
.text$mn:000011F0
.text$mn:000011F0                 push    ebp
.text$mn:000011F1                 mov     ebp, esp
.text$mn:000011F3                 push    ecx
.text$mn:000011F4                 mov     [ebp+var_4], ecx
.text$mn:000011F7                 mov     ecx, [ebp+var_4] ; this
.text$mn:000011FA                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:000011FF                 mov     eax, [ebp+arg_0]
.text$mn:00001202                 and     eax, 1
.text$mn:00001205                 jz      short loc_1213
.text$mn:00001207                 mov     ecx, [ebp+var_4]
.text$mn:0000120A                 push    ecx             ; void *
.text$mn:0000120B                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00001210                 add     esp, 4
.text$mn:00001213
.text$mn:00001213 loc_1213:                               ; CODE XREF: std::_Generic_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00001213                 mov     eax, [ebp+var_4]
.text$mn:00001216                 mov     esp, ebp
.text$mn:00001218                 pop     ebp
.text$mn:00001219                 retn    4
.text$mn:00001219 ??_G_Generic_error_category@std@@UAEPAXI@Z endp
.text$mn:00001219
.text$mn:00001219 _text$mn        ends
.text$mn:00001219
.text$mn:0000121C ; ===========================================================================
.text$mn:0000121C
.text$mn:0000121C ; Segment type: Pure code
.text$mn:0000121C ; Segment permissions: Read/Execute
.text$mn:0000121C _text$mn        segment para public 'CODE' use32
.text$mn:0000121C                 assume cs:_text$mn
.text$mn:0000121C                 ;org 121Ch
.text$mn:0000121C ; COMDAT (pick any)
.text$mn:0000121C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000121C
.text$mn:0000121C ; =============== S U B R O U T I N E =======================================
.text$mn:0000121C
.text$mn:0000121C ; Attributes: bp-based frame
.text$mn:0000121C
.text$mn:0000121C ; public: virtual void * __thiscall std::_Iostream_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:0000121C                 public ??_G_Iostream_error_category@std@@UAEPAXI@Z
.text$mn:0000121C ??_G_Iostream_error_category@std@@UAEPAXI@Z proc near
.text$mn:0000121C
.text$mn:0000121C var_4           = dword ptr -4
.text$mn:0000121C arg_0           = dword ptr  8
.text$mn:0000121C
.text$mn:0000121C                 push    ebp
.text$mn:0000121D                 mov     ebp, esp
.text$mn:0000121F                 push    ecx
.text$mn:00001220                 mov     [ebp+var_4], ecx
.text$mn:00001223                 mov     ecx, [ebp+var_4] ; this
.text$mn:00001226                 call    ??1_Iostream_error_category@std@@UAE@XZ ; std::_Iostream_error_category::~_Iostream_error_category(void)
.text$mn:0000122B                 mov     eax, [ebp+arg_0]
.text$mn:0000122E                 and     eax, 1
.text$mn:00001231                 jz      short loc_123F
.text$mn:00001233                 mov     ecx, [ebp+var_4]
.text$mn:00001236                 push    ecx             ; void *
.text$mn:00001237                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:0000123C                 add     esp, 4
.text$mn:0000123F
.text$mn:0000123F loc_123F:                               ; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:0000123F                 mov     eax, [ebp+var_4]
.text$mn:00001242                 mov     esp, ebp
.text$mn:00001244                 pop     ebp
.text$mn:00001245                 retn    4
.text$mn:00001245 ??_G_Iostream_error_category@std@@UAEPAXI@Z endp
.text$mn:00001245
.text$mn:00001245 _text$mn        ends
.text$mn:00001245
.text$mn:00001248 ; ===========================================================================
.text$mn:00001248
.text$mn:00001248 ; Segment type: Pure code
.text$mn:00001248 ; Segment permissions: Read/Execute
.text$mn:00001248 _text$mn        segment para public 'CODE' use32
.text$mn:00001248                 assume cs:_text$mn
.text$mn:00001248                 ;org 1248h
.text$mn:00001248 ; COMDAT (pick any)
.text$mn:00001248                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001248
.text$mn:00001248 ; =============== S U B R O U T I N E =======================================
.text$mn:00001248
.text$mn:00001248 ; Attributes: bp-based frame
.text$mn:00001248
.text$mn:00001248 ; public: virtual void * __thiscall std::_System_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00001248                 public ??_G_System_error_category@std@@UAEPAXI@Z
.text$mn:00001248 ??_G_System_error_category@std@@UAEPAXI@Z proc near
.text$mn:00001248
.text$mn:00001248 var_4           = dword ptr -4
.text$mn:00001248 arg_0           = dword ptr  8
.text$mn:00001248
.text$mn:00001248                 push    ebp
.text$mn:00001249                 mov     ebp, esp
.text$mn:0000124B                 push    ecx
.text$mn:0000124C                 mov     [ebp+var_4], ecx
.text$mn:0000124F                 mov     ecx, [ebp+var_4] ; this
.text$mn:00001252                 call    ??1_System_error_category@std@@UAE@XZ ; std::_System_error_category::~_System_error_category(void)
.text$mn:00001257                 mov     eax, [ebp+arg_0]
.text$mn:0000125A                 and     eax, 1
.text$mn:0000125D                 jz      short loc_126B
.text$mn:0000125F                 mov     ecx, [ebp+var_4]
.text$mn:00001262                 push    ecx             ; void *
.text$mn:00001263                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00001268                 add     esp, 4
.text$mn:0000126B
.text$mn:0000126B loc_126B:                               ; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:0000126B                 mov     eax, [ebp+var_4]
.text$mn:0000126E                 mov     esp, ebp
.text$mn:00001270                 pop     ebp
.text$mn:00001271                 retn    4
.text$mn:00001271 ??_G_System_error_category@std@@UAEPAXI@Z endp
.text$mn:00001271
.text$mn:00001271 _text$mn        ends
.text$mn:00001271
.text$mn:00001274 ; ===========================================================================
.text$mn:00001274
.text$mn:00001274 ; Segment type: Pure code
.text$mn:00001274 ; Segment permissions: Read/Execute
.text$mn:00001274 _text$mn        segment para public 'CODE' use32
.text$mn:00001274                 assume cs:_text$mn
.text$mn:00001274                 ;org 1274h
.text$mn:00001274 ; COMDAT (pick any)
.text$mn:00001274                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001274
.text$mn:00001274 ; =============== S U B R O U T I N E =======================================
.text$mn:00001274
.text$mn:00001274 ; Attributes: bp-based frame
.text$mn:00001274
.text$mn:00001274 ; public: virtual void * __thiscall std::error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00001274                 public ??_Gerror_category@std@@UAEPAXI@Z
.text$mn:00001274 ??_Gerror_category@std@@UAEPAXI@Z proc near
.text$mn:00001274
.text$mn:00001274 var_4           = dword ptr -4
.text$mn:00001274 arg_0           = dword ptr  8
.text$mn:00001274
.text$mn:00001274                 push    ebp
.text$mn:00001275                 mov     ebp, esp
.text$mn:00001277                 push    ecx
.text$mn:00001278                 mov     [ebp+var_4], ecx
.text$mn:0000127B                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000127E                 call    ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$mn:00001283                 mov     eax, [ebp+arg_0]
.text$mn:00001286                 and     eax, 1
.text$mn:00001289                 jz      short loc_1297
.text$mn:0000128B                 mov     ecx, [ebp+var_4]
.text$mn:0000128E                 push    ecx             ; void *
.text$mn:0000128F                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00001294                 add     esp, 4
.text$mn:00001297
.text$mn:00001297 loc_1297:                               ; CODE XREF: std::error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00001297                 mov     eax, [ebp+var_4]
.text$mn:0000129A                 mov     esp, ebp
.text$mn:0000129C                 pop     ebp
.text$mn:0000129D                 retn    4
.text$mn:0000129D ??_Gerror_category@std@@UAEPAXI@Z endp
.text$mn:0000129D
.text$mn:0000129D _text$mn        ends
.text$mn:0000129D
.text$mn:000012A0 ; ===========================================================================
.text$mn:000012A0
.text$mn:000012A0 ; Segment type: Pure code
.text$mn:000012A0 ; Segment permissions: Read/Execute
.text$mn:000012A0 _text$mn        segment para public 'CODE' use32
.text$mn:000012A0                 assume cs:_text$mn
.text$mn:000012A0                 ;org 12A0h
.text$mn:000012A0 ; COMDAT (pick any)
.text$mn:000012A0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000012A0
.text$mn:000012A0 ; =============== S U B R O U T I N E =======================================
.text$mn:000012A0
.text$mn:000012A0 ; Attributes: bp-based frame
.text$mn:000012A0
.text$mn:000012A0 ; public: virtual void * __thiscall std::runtime_error::`scalar deleting destructor'(unsigned int)
.text$mn:000012A0                 public ??_Gruntime_error@std@@UAEPAXI@Z
.text$mn:000012A0 ??_Gruntime_error@std@@UAEPAXI@Z proc near
.text$mn:000012A0
.text$mn:000012A0 var_4           = dword ptr -4
.text$mn:000012A0 arg_0           = dword ptr  8
.text$mn:000012A0
.text$mn:000012A0                 push    ebp
.text$mn:000012A1                 mov     ebp, esp
.text$mn:000012A3                 push    ecx
.text$mn:000012A4                 mov     [ebp+var_4], ecx
.text$mn:000012A7                 mov     ecx, [ebp+var_4] ; this
.text$mn:000012AA                 call    ??1runtime_error@std@@UAE@XZ ; std::runtime_error::~runtime_error(void)
.text$mn:000012AF                 mov     eax, [ebp+arg_0]
.text$mn:000012B2                 and     eax, 1
.text$mn:000012B5                 jz      short loc_12C3
.text$mn:000012B7                 mov     ecx, [ebp+var_4]
.text$mn:000012BA                 push    ecx             ; void *
.text$mn:000012BB                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:000012C0                 add     esp, 4
.text$mn:000012C3
.text$mn:000012C3 loc_12C3:                               ; CODE XREF: std::runtime_error::`scalar deleting destructor'(uint)+15j
.text$mn:000012C3                 mov     eax, [ebp+var_4]
.text$mn:000012C6                 mov     esp, ebp
.text$mn:000012C8                 pop     ebp
.text$mn:000012C9                 retn    4
.text$mn:000012C9 ??_Gruntime_error@std@@UAEPAXI@Z endp
.text$mn:000012C9
.text$mn:000012C9 _text$mn        ends
.text$mn:000012C9
.text$di:000012CC ; ===========================================================================
.text$di:000012CC
.text$di:000012CC ; Segment type: Pure code
.text$di:000012CC ; Segment permissions: Read/Execute
.text$di:000012CC _text$di        segment para public 'CODE' use32
.text$di:000012CC                 assume cs:_text$di
.text$di:000012CC                 ;org 12CCh
.text$di:000012CC ; COMDAT (pick any)
.text$di:000012CC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:000012CC
.text$di:000012CC ; =============== S U B R O U T I N E =======================================
.text$di:000012CC
.text$di:000012CC ; Attributes: bp-based frame
.text$di:000012CC
.text$di:000012CC ; void __cdecl `dynamic initializer for 'public: static class std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
.text$di:000012CC ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc near
.text$di:000012CC                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Generic_object$initializer$)(void)o
.text$di:000012CC                 push    ebp
.text$di:000012CD                 mov     ebp, esp
.text$di:000012CF                 mov     ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
.text$di:000012D4                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$di:000012D9                 push    offset ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:000012DE                 call    _atexit
.text$di:000012E3                 add     esp, 4
.text$di:000012E6                 pop     ebp
.text$di:000012E7                 retn
.text$di:000012E7 ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp
.text$di:000012E7
.text$di:000012E7 _text$di        ends
.text$di:000012E7
.text$di:000012E8 ; ===========================================================================
.text$di:000012E8
.text$di:000012E8 ; Segment type: Pure code
.text$di:000012E8 ; Segment permissions: Read/Execute
.text$di:000012E8 _text$di        segment para public 'CODE' use32
.text$di:000012E8                 assume cs:_text$di
.text$di:000012E8                 ;org 12E8h
.text$di:000012E8 ; COMDAT (pick any)
.text$di:000012E8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:000012E8
.text$di:000012E8 ; =============== S U B R O U T I N E =======================================
.text$di:000012E8
.text$di:000012E8 ; Attributes: bp-based frame
.text$di:000012E8
.text$di:000012E8 ; void __cdecl `dynamic initializer for 'public: static class std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
.text$di:000012E8 ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
.text$di:000012E8                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Iostream_object$initializer$)(void)o
.text$di:000012E8                 push    ebp
.text$di:000012E9                 mov     ebp, esp
.text$di:000012EB                 mov     ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
.text$di:000012F0                 call    ??0_Iostream_error_category@std@@QAE@XZ ; std::_Iostream_error_category::_Iostream_error_category(void)
.text$di:000012F5                 push    offset ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:000012FA                 call    _atexit
.text$di:000012FF                 add     esp, 4
.text$di:00001302                 pop     ebp
.text$di:00001303                 retn
.text$di:00001303 ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp
.text$di:00001303
.text$di:00001303 _text$di        ends
.text$di:00001303
.text$di:00001304 ; ===========================================================================
.text$di:00001304
.text$di:00001304 ; Segment type: Pure code
.text$di:00001304 ; Segment permissions: Read/Execute
.text$di:00001304 _text$di        segment para public 'CODE' use32
.text$di:00001304                 assume cs:_text$di
.text$di:00001304                 ;org 1304h
.text$di:00001304 ; COMDAT (pick any)
.text$di:00001304                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00001304
.text$di:00001304 ; =============== S U B R O U T I N E =======================================
.text$di:00001304
.text$di:00001304 ; Attributes: bp-based frame
.text$di:00001304
.text$di:00001304 ; void __cdecl `dynamic initializer for 'public: static class std::_System_error_category std::_Error_objects<int>::_System_object''(void)
.text$di:00001304 ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
.text$di:00001304                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_System_object$initializer$)(void)o
.text$di:00001304                 push    ebp
.text$di:00001305                 mov     ebp, esp
.text$di:00001307                 mov     ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
.text$di:0000130C                 call    ??0_System_error_category@std@@QAE@XZ ; std::_System_error_category::_System_error_category(void)
.text$di:00001311                 push    offset ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:00001316                 call    _atexit
.text$di:0000131B                 add     esp, 4
.text$di:0000131E                 pop     ebp
.text$di:0000131F                 retn
.text$di:0000131F ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp
.text$di:0000131F
.text$di:0000131F _text$di        ends
.text$di:0000131F
.text$di:00001320 ; ===========================================================================
.text$di:00001320
.text$di:00001320 ; Segment type: Pure code
.text$di:00001320 ; Segment permissions: Read/Execute
.text$di:00001320 _text$di        segment para public 'CODE' use32
.text$di:00001320                 assume cs:_text$di
.text$di:00001320                 ;org 1320h
.text$di:00001320 ; COMDAT (pick any)
.text$di:00001320                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00001320
.text$di:00001320 ; =============== S U B R O U T I N E =======================================
.text$di:00001320
.text$di:00001320 ; Attributes: bp-based frame
.text$di:00001320
.text$di:00001320 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::num_put<char, class std::back_insert_iterator<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>::id''(void)
.text$di:00001320 ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00001320                                         ; DATA XREF: .CRT$XCU:void (*std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id$initializer$)(void)o
.text$di:00001320                 push    ebp
.text$di:00001321                 mov     ebp, esp
.text$di:00001323                 push    0               ; unsigned int
.text$di:00001325                 mov     ecx, offset ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; this
.text$di:0000132A                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:0000132F                 pop     ebp
.text$di:00001330                 retn
.text$di:00001330 ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00001330
.text$di:00001330 ; ---------------------------------------------------------------------------
.text$di:00001331                 align 4
.text$di:00001331 _text$di        ends
.text$di:00001331
.text$di:00001334 ; ===========================================================================
.text$di:00001334
.text$di:00001334 ; Segment type: Pure code
.text$di:00001334 ; Segment permissions: Read/Execute
.text$di:00001334 _text$di        segment para public 'CODE' use32
.text$di:00001334                 assume cs:_text$di
.text$di:00001334                 ;org 1334h
.text$di:00001334 ; COMDAT (pick any)
.text$di:00001334                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00001334
.text$di:00001334 ; =============== S U B R O U T I N E =======================================
.text$di:00001334
.text$di:00001334 ; Attributes: bp-based frame
.text$di:00001334
.text$di:00001334 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::num_put<wchar_t, class std::back_insert_iterator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::id''(void)
.text$di:00001334 ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00001334                                         ; DATA XREF: .CRT$XCU:void (*std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id$initializer$)(void)o
.text$di:00001334                 push    ebp
.text$di:00001335                 mov     ebp, esp
.text$di:00001337                 push    0               ; unsigned int
.text$di:00001339                 mov     ecx, offset ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; this
.text$di:0000133E                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00001343                 pop     ebp
.text$di:00001344                 retn
.text$di:00001344 ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00001344
.text$di:00001344 ; ---------------------------------------------------------------------------
.text$di:00001345                 align 4
.text$di:00001345 _text$di        ends
.text$di:00001345
.text$di:00001348 ; ===========================================================================
.text$di:00001348
.text$di:00001348 ; Segment type: Pure code
.text$di:00001348 ; Segment permissions: Read/Execute
.text$di:00001348 _text$di        segment para public 'CODE' use32
.text$di:00001348                 assume cs:_text$di
.text$di:00001348                 ;org 1348h
.text$di:00001348 ; COMDAT (pick any)
.text$di:00001348                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00001348
.text$di:00001348 ; =============== S U B R O U T I N E =======================================
.text$di:00001348
.text$di:00001348 ; Attributes: bp-based frame
.text$di:00001348
.text$di:00001348 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::numpunct<char>::id''(void)
.text$di:00001348 ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00001348                                         ; DATA XREF: .CRT$XCU:void (*std::numpunct<char>::id$initializer$)(void)o
.text$di:00001348                 push    ebp
.text$di:00001349                 mov     ebp, esp
.text$di:0000134B                 push    0               ; unsigned int
.text$di:0000134D                 mov     ecx, offset ?id@?$numpunct@D@std@@2V0locale@2@A ; this
.text$di:00001352                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00001357                 pop     ebp
.text$di:00001358                 retn
.text$di:00001358 ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00001358
.text$di:00001358 ; ---------------------------------------------------------------------------
.text$di:00001359                 align 4
.text$di:00001359 _text$di        ends
.text$di:00001359
.text$di:0000135C ; ===========================================================================
.text$di:0000135C
.text$di:0000135C ; Segment type: Pure code
.text$di:0000135C ; Segment permissions: Read/Execute
.text$di:0000135C _text$di        segment para public 'CODE' use32
.text$di:0000135C                 assume cs:_text$di
.text$di:0000135C                 ;org 135Ch
.text$di:0000135C ; COMDAT (pick any)
.text$di:0000135C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:0000135C
.text$di:0000135C ; =============== S U B R O U T I N E =======================================
.text$di:0000135C
.text$di:0000135C ; Attributes: bp-based frame
.text$di:0000135C
.text$di:0000135C ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::numpunct<wchar_t>::id''(void)
.text$di:0000135C ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:0000135C                                         ; DATA XREF: .CRT$XCU:void (*std::numpunct<wchar_t>::id$initializer$)(void)o
.text$di:0000135C                 push    ebp
.text$di:0000135D                 mov     ebp, esp
.text$di:0000135F                 push    0               ; unsigned int
.text$di:00001361                 mov     ecx, offset ?id@?$numpunct@_W@std@@2V0locale@2@A ; this
.text$di:00001366                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:0000136B                 pop     ebp
.text$di:0000136C                 retn
.text$di:0000136C ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ endp
.text$di:0000136C
.text$di:0000136C ; ---------------------------------------------------------------------------
.text$di:0000136D                 align 10h
.text$di:0000136D _text$di        ends
.text$di:0000136D
.text$di:00001370 ; ===========================================================================
.text$di:00001370
.text$di:00001370 ; Segment type: Pure code
.text$di:00001370 ; Segment permissions: Read/Execute
.text$di:00001370 _text$di        segment para public 'CODE' use32
.text$di:00001370                 assume cs:_text$di
.text$di:00001370                 ;org 1370h
.text$di:00001370 ; COMDAT (pick any)
.text$di:00001370                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00001370
.text$di:00001370 ; =============== S U B R O U T I N E =======================================
.text$di:00001370
.text$di:00001370 ; Attributes: bp-based frame
.text$di:00001370
.text$di:00001370 ; void __cdecl std::`dynamic initializer for 'allocator_arg''(void)
.text$di:00001370 ??__Eallocator_arg@std@@YAXXZ proc near ; DATA XREF: .CRT$XCU:_allocator_arg$initializer$o
.text$di:00001370
.text$di:00001370 var_1           = byte ptr -1
.text$di:00001370
.text$di:00001370                 push    ebp
.text$di:00001371                 mov     ebp, esp
.text$di:00001373                 push    ecx
.text$di:00001374                 xor     eax, eax
.text$di:00001376                 mov     [ebp+var_1], al
.text$di:00001379                 mov     esp, ebp
.text$di:0000137B                 pop     ebp
.text$di:0000137C                 retn
.text$di:0000137C ??__Eallocator_arg@std@@YAXXZ endp
.text$di:0000137C
.text$di:0000137C ; ---------------------------------------------------------------------------
.text$di:0000137D                 align 10h
.text$di:0000137D _text$di        ends
.text$di:0000137D
.text$di:00001380 ; ===========================================================================
.text$di:00001380
.text$di:00001380 ; Segment type: Pure code
.text$di:00001380 ; Segment permissions: Read/Execute
.text$di:00001380 _text$di        segment para public 'CODE' use32
.text$di:00001380                 assume cs:_text$di
.text$di:00001380                 ;org 1380h
.text$di:00001380 ; COMDAT (pick any)
.text$di:00001380                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00001380
.text$di:00001380 ; =============== S U B R O U T I N E =======================================
.text$di:00001380
.text$di:00001380 ; Attributes: bp-based frame
.text$di:00001380
.text$di:00001380 ; void __cdecl std::`dynamic initializer for 'piecewise_construct''(void)
.text$di:00001380 ??__Epiecewise_construct@std@@YAXXZ proc near
.text$di:00001380                                         ; DATA XREF: .CRT$XCU:_piecewise_construct$initializer$o
.text$di:00001380
.text$di:00001380 var_1           = byte ptr -1
.text$di:00001380
.text$di:00001380                 push    ebp
.text$di:00001381                 mov     ebp, esp
.text$di:00001383                 push    ecx
.text$di:00001384                 xor     eax, eax
.text$di:00001386                 mov     [ebp+var_1], al
.text$di:00001389                 mov     esp, ebp
.text$di:0000138B                 pop     ebp
.text$di:0000138C                 retn
.text$di:0000138C ??__Epiecewise_construct@std@@YAXXZ endp
.text$di:0000138C
.text$di:0000138C ; ---------------------------------------------------------------------------
.text$di:0000138D                 align 10h
.text$di:0000138D _text$di        ends
.text$di:0000138D
.text$yd:00001390 ; ===========================================================================
.text$yd:00001390
.text$yd:00001390 ; Segment type: Pure code
.text$yd:00001390 ; Segment permissions: Read/Execute
.text$yd:00001390 _text$yd        segment para public 'CODE' use32
.text$yd:00001390                 assume cs:_text$yd
.text$yd:00001390                 ;org 1390h
.text$yd:00001390 ; COMDAT (pick any)
.text$yd:00001390                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$yd:00001390
.text$yd:00001390 ; =============== S U B R O U T I N E =======================================
.text$yd:00001390
.text$yd:00001390 ; Attributes: bp-based frame
.text$yd:00001390
.text$yd:00001390 ; void __cdecl `dynamic atexit destructor for 'public: static std::_Generic_error_category std::_Error_objects<int>::_Generic_object''()
.text$yd:00001390 ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc near
.text$yd:00001390                                         ; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+Do
.text$yd:00001390                 push    ebp
.text$yd:00001391                 mov     ebp, esp
.text$yd:00001393                 mov     ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
.text$yd:00001398                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$yd:0000139D                 pop     ebp
.text$yd:0000139E                 retn
.text$yd:0000139E ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp
.text$yd:0000139E
.text$yd:0000139E ; ---------------------------------------------------------------------------
.text$yd:0000139F                 align 10h
.text$yd:0000139F _text$yd        ends
.text$yd:0000139F
.text$yd:000013A0 ; ===========================================================================
.text$yd:000013A0
.text$yd:000013A0 ; Segment type: Pure code
.text$yd:000013A0 ; Segment permissions: Read/Execute
.text$yd:000013A0 _text$yd        segment para public 'CODE' use32
.text$yd:000013A0                 assume cs:_text$yd
.text$yd:000013A0                 ;org 13A0h
.text$yd:000013A0 ; COMDAT (pick any)
.text$yd:000013A0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$yd:000013A0
.text$yd:000013A0 ; =============== S U B R O U T I N E =======================================
.text$yd:000013A0
.text$yd:000013A0 ; Attributes: bp-based frame
.text$yd:000013A0
.text$yd:000013A0 ; void __cdecl `dynamic atexit destructor for 'public: static std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''()
.text$yd:000013A0 ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
.text$yd:000013A0                                         ; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+Do
.text$yd:000013A0                 push    ebp
.text$yd:000013A1                 mov     ebp, esp
.text$yd:000013A3                 mov     ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
.text$yd:000013A8                 call    ??1_Iostream_error_category@std@@UAE@XZ ; std::_Iostream_error_category::~_Iostream_error_category(void)
.text$yd:000013AD                 pop     ebp
.text$yd:000013AE                 retn
.text$yd:000013AE ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp
.text$yd:000013AE
.text$yd:000013AE ; ---------------------------------------------------------------------------
.text$yd:000013AF                 align 10h
.text$yd:000013AF _text$yd        ends
.text$yd:000013AF
.text$yd:000013B0 ; ===========================================================================
.text$yd:000013B0
.text$yd:000013B0 ; Segment type: Pure code
.text$yd:000013B0 ; Segment permissions: Read/Execute
.text$yd:000013B0 _text$yd        segment para public 'CODE' use32
.text$yd:000013B0                 assume cs:_text$yd
.text$yd:000013B0                 ;org 13B0h
.text$yd:000013B0 ; COMDAT (pick any)
.text$yd:000013B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$yd:000013B0
.text$yd:000013B0 ; =============== S U B R O U T I N E =======================================
.text$yd:000013B0
.text$yd:000013B0 ; Attributes: bp-based frame
.text$yd:000013B0
.text$yd:000013B0 ; void __cdecl `dynamic atexit destructor for 'public: static std::_System_error_category std::_Error_objects<int>::_System_object''()
.text$yd:000013B0 ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
.text$yd:000013B0                                         ; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+Do
.text$yd:000013B0                 push    ebp
.text$yd:000013B1                 mov     ebp, esp
.text$yd:000013B3                 mov     ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
.text$yd:000013B8                 call    ??1_System_error_category@std@@UAE@XZ ; std::_System_error_category::~_System_error_category(void)
.text$yd:000013BD                 pop     ebp
.text$yd:000013BE                 retn
.text$yd:000013BE ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp
.text$yd:000013BE
.text$yd:000013BE ; ---------------------------------------------------------------------------
.text$yd:000013BF                 align 10h
.text$yd:000013BF _text$yd        ends
.text$yd:000013BF
.text$mn:000013C0 ; ===========================================================================
.text$mn:000013C0
.text$mn:000013C0 ; Segment type: Pure code
.text$mn:000013C0 ; Segment permissions: Read/Execute
.text$mn:000013C0 _text$mn        segment para public 'CODE' use32
.text$mn:000013C0                 assume cs:_text$mn
.text$mn:000013C0                 ;org 13C0h
.text$mn:000013C0 ; COMDAT (pick any)
.text$mn:000013C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000013C0
.text$mn:000013C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000013C0
.text$mn:000013C0 ; Attributes: bp-based frame
.text$mn:000013C0
.text$mn:000013C0 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Alloc_proxy(void)
.text$mn:000013C0                 public ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
.text$mn:000013C0 ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
.text$mn:000013C0                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+38p
.text$mn:000013C0
.text$mn:000013C0 var_10          = byte ptr -10h
.text$mn:000013C0 var_8           = dword ptr -8
.text$mn:000013C0 var_1           = byte ptr -1
.text$mn:000013C0
.text$mn:000013C0                 push    ebp
.text$mn:000013C1                 mov     ebp, esp
.text$mn:000013C3                 sub     esp, 10h
.text$mn:000013C6                 mov     [ebp+var_8], ecx
.text$mn:000013C9                 lea     ecx, [ebp+var_1]
.text$mn:000013CC                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:000013D1                 push    1
.text$mn:000013D3                 lea     ecx, [ebp+var_1]
.text$mn:000013D6                 call    ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate(uint)
.text$mn:000013DB                 mov     ecx, [ebp+var_8]
.text$mn:000013DE                 mov     [ecx], eax
.text$mn:000013E0                 lea     ecx, [ebp+var_10] ; this
.text$mn:000013E3                 call    ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy(void)
.text$mn:000013E8                 push    eax             ; int
.text$mn:000013E9                 mov     edx, [ebp+var_8]
.text$mn:000013EC                 mov     eax, [edx]
.text$mn:000013EE                 push    eax             ; void *
.text$mn:000013EF                 lea     ecx, [ebp+var_1]
.text$mn:000013F2                 call    ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:000013F7                 mov     ecx, [ebp+var_8]
.text$mn:000013FA                 mov     edx, [ecx]
.text$mn:000013FC                 mov     eax, [ebp+var_8]
.text$mn:000013FF                 mov     [edx], eax
.text$mn:00001401                 mov     esp, ebp
.text$mn:00001403                 pop     ebp
.text$mn:00001404                 retn
.text$mn:00001404 ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp
.text$mn:00001404
.text$mn:00001404 ; ---------------------------------------------------------------------------
.text$mn:00001405                 align 4
.text$mn:00001405 _text$mn        ends
.text$mn:00001405
.text$mn:00001408 ; ===========================================================================
.text$mn:00001408
.text$mn:00001408 ; Segment type: Pure code
.text$mn:00001408 ; Segment permissions: Read/Execute
.text$mn:00001408 _text$mn        segment para public 'CODE' use32
.text$mn:00001408                 assume cs:_text$mn
.text$mn:00001408                 ;org 1408h
.text$mn:00001408 ; COMDAT (pick any)
.text$mn:00001408                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001408
.text$mn:00001408 ; =============== S U B R O U T I N E =======================================
.text$mn:00001408
.text$mn:00001408 ; Attributes: bp-based frame
.text$mn:00001408
.text$mn:00001408 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Copy(unsigned int, unsigned int)
.text$mn:00001408                 public ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00001408 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
.text$mn:00001408                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+37p
.text$mn:00001408
.text$mn:00001408 var_20          = dword ptr -20h
.text$mn:00001408 var_1C          = dword ptr -1Ch
.text$mn:00001408 var_18          = dword ptr -18h
.text$mn:00001408 var_11          = byte ptr -11h
.text$mn:00001408 var_10          = dword ptr -10h
.text$mn:00001408 var_C           = byte ptr -0Ch
.text$mn:00001408 var_4           = dword ptr -4
.text$mn:00001408 arg_0           = dword ptr  8
.text$mn:00001408
.text$mn:00001408 ; FUNCTION CHUNK AT .text$mn:0000152A SIZE 00000009 BYTES
.text$mn:00001408
.text$mn:00001408                 push    ebp
.text$mn:00001409                 mov     ebp, esp
.text$mn:0000140B                 push    0FFFFFFFFh
.text$mn:0000140D                 push    offset __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00001412                 mov     eax, large fs:0
.text$mn:00001418                 push    eax
.text$mn:00001419                 push    ecx
.text$mn:0000141A                 sub     esp, 10h
.text$mn:0000141D                 push    ebx
.text$mn:0000141E                 push    esi
.text$mn:0000141F                 push    edi
.text$mn:00001420                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001425                 xor     eax, ebp
.text$mn:00001427                 push    eax
.text$mn:00001428                 lea     eax, [ebp+var_C]
.text$mn:0000142B                 mov     large fs:0, eax
.text$mn:00001431                 mov     [ebp+var_10], esp
.text$mn:00001434                 mov     [ebp+var_18], ecx
.text$mn:00001437                 mov     eax, [ebp+arg_0]
.text$mn:0000143A                 or      eax, 0Fh
.text$mn:0000143D                 mov     [ebp+var_1C], eax
.text$mn:00001440                 mov     ecx, [ebp+var_18]
.text$mn:00001443                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00001448                 cmp     eax, [ebp+var_1C]
.text$mn:0000144B                 jnb     short loc_1455
.text$mn:0000144D                 mov     ecx, [ebp+arg_0]
.text$mn:00001450                 mov     [ebp+var_1C], ecx
.text$mn:00001453                 jmp     short loc_14A7
.text$mn:00001455 ; ---------------------------------------------------------------------------
.text$mn:00001455
.text$mn:00001455 loc_1455:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+43j
.text$mn:00001455                 mov     edx, [ebp+var_18]
.text$mn:00001458                 mov     ecx, [edx+18h]
.text$mn:0000145B                 shr     ecx, 1
.text$mn:0000145D                 mov     eax, [ebp+var_1C]
.text$mn:00001460                 xor     edx, edx
.text$mn:00001462                 mov     esi, 3
.text$mn:00001467                 div     esi
.text$mn:00001469                 cmp     ecx, eax
.text$mn:0000146B                 ja      short loc_146F
.text$mn:0000146D                 jmp     short loc_14A7
.text$mn:0000146F ; ---------------------------------------------------------------------------
.text$mn:0000146F
.text$mn:0000146F loc_146F:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+63j
.text$mn:0000146F                 mov     ecx, [ebp+var_18]
.text$mn:00001472                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00001477                 mov     edx, [ebp+var_18]
.text$mn:0000147A                 mov     ecx, [edx+18h]
.text$mn:0000147D                 shr     ecx, 1
.text$mn:0000147F                 sub     eax, ecx
.text$mn:00001481                 mov     edx, [ebp+var_18]
.text$mn:00001484                 cmp     [edx+18h], eax
.text$mn:00001487                 ja      short loc_149C
.text$mn:00001489                 mov     eax, [ebp+var_18]
.text$mn:0000148C                 mov     ecx, [eax+18h]
.text$mn:0000148F                 shr     ecx, 1
.text$mn:00001491                 mov     edx, [ebp+var_18]
.text$mn:00001494                 add     ecx, [edx+18h]
.text$mn:00001497                 mov     [ebp+var_1C], ecx
.text$mn:0000149A                 jmp     short loc_14A7
.text$mn:0000149C ; ---------------------------------------------------------------------------
.text$mn:0000149C
.text$mn:0000149C loc_149C:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+7Fj
.text$mn:0000149C                 mov     ecx, [ebp+var_18]
.text$mn:0000149F                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:000014A4                 mov     [ebp+var_1C], eax
.text$mn:000014A7
.text$mn:000014A7 loc_14A7:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+4Bj
.text$mn:000014A7                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+65j ...
.text$mn:000014A7                 mov     [ebp+var_4], 0
.text$mn:000014AE                 mov     eax, [ebp+var_1C]
.text$mn:000014B1                 add     eax, 1
.text$mn:000014B4                 push    eax
.text$mn:000014B5                 lea     ecx, [ebp+var_11]
.text$mn:000014B8                 push    ecx
.text$mn:000014B9                 mov     ecx, [ebp+var_18]
.text$mn:000014BC                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:000014C1                 mov     ecx, eax
.text$mn:000014C3                 call    ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
.text$mn:000014C8                 mov     [ebp+var_20], eax
.text$mn:000014CB                 jmp     short loc_152A
.text$mn:000014CB ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp
.text$mn:000014CB
.text$mn:000014CD
.text$mn:000014CD ; =============== S U B R O U T I N E =======================================
.text$mn:000014CD
.text$mn:000014CD
.text$mn:000014CD __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 proc near
.text$mn:000014CD                                         ; DATA XREF: .xdata$x:00002284o
.text$mn:000014CD
.text$mn:000014CD ; FUNCTION CHUNK AT .text$mn:00001514 SIZE 00000009 BYTES
.text$mn:000014CD ; FUNCTION CHUNK AT .text$mn:00001524 SIZE 00000006 BYTES
.text$mn:000014CD
.text$mn:000014CD                 mov     [ebp-10h], esp
.text$mn:000014D0                 mov     edx, [ebp+8]
.text$mn:000014D3                 mov     [ebp-1Ch], edx
.text$mn:000014D6                 mov     byte ptr [ebp-4], 2
.text$mn:000014DA                 mov     eax, [ebp-1Ch]
.text$mn:000014DD                 add     eax, 1
.text$mn:000014E0                 push    eax
.text$mn:000014E1                 lea     ecx, [ebp-12h]
.text$mn:000014E4                 push    ecx
.text$mn:000014E5                 mov     ecx, [ebp-18h]
.text$mn:000014E8                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:000014ED                 mov     ecx, eax
.text$mn:000014EF                 call    ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
.text$mn:000014F4                 mov     [ebp-20h], eax
.text$mn:000014F7                 jmp     short loc_1514
.text$mn:000014F7 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 endp
.text$mn:000014F7
.text$mn:000014F9
.text$mn:000014F9 ; =============== S U B R O U T I N E =======================================
.text$mn:000014F9
.text$mn:000014F9 ; Attributes: noreturn
.text$mn:000014F9
.text$mn:000014F9 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 proc near
.text$mn:000014F9                                         ; DATA XREF: .xdata$x:00002294o
.text$mn:000014F9                 push    0               ; Size
.text$mn:000014FB                 push    1               ; char
.text$mn:000014FD                 mov     ecx, [ebp-18h]
.text$mn:00001500                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00001505                 push    0
.text$mn:00001507                 push    0
.text$mn:00001509                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00001509 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 endp
.text$mn:00001509
.text$mn:0000150E ; ---------------------------------------------------------------------------
.text$mn:0000150E                 mov     eax, offset $LN17
.text$mn:00001513                 retn
.text$mn:00001514 ; ---------------------------------------------------------------------------
.text$mn:00001514 ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00001514
.text$mn:00001514 loc_1514:                               ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+2Aj
.text$mn:00001514                 mov     dword ptr [ebp-4], 1
.text$mn:0000151B                 jmp     short loc_1524
.text$mn:0000151B ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:0000151D
.text$mn:0000151D ; =============== S U B R O U T I N E =======================================
.text$mn:0000151D
.text$mn:0000151D
.text$mn:0000151D $LN17           proc near               ; DATA XREF: .text$mn:0000150Eo
.text$mn:0000151D                 mov     dword ptr [ebp-4], 1
.text$mn:0000151D $LN17           endp ; sp-analysis failed
.text$mn:0000151D
.text$mn:00001524 ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00001524
.text$mn:00001524 loc_1524:                               ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+4Ej
.text$mn:00001524                 mov     eax, offset $LN19
.text$mn:00001529                 retn
.text$mn:00001529 ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:0000152A ; ---------------------------------------------------------------------------
.text$mn:0000152A ; START OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:0000152A
.text$mn:0000152A loc_152A:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+C3j
.text$mn:0000152A                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001531                 jmp     short loc_153A
.text$mn:00001531 ; END OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00001533
.text$mn:00001533 ; =============== S U B R O U T I N E =======================================
.text$mn:00001533
.text$mn:00001533
.text$mn:00001533 $LN19           proc near               ; DATA XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:loc_1524o
.text$mn:00001533                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:0000153A
.text$mn:0000153A loc_153A:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+129j
.text$mn:0000153A                 cmp     dword ptr [ebp+0Ch], 0
.text$mn:0000153E                 jbe     short loc_1559
.text$mn:00001540                 mov     edx, [ebp+0Ch]
.text$mn:00001543                 push    edx             ; Size
.text$mn:00001544                 mov     ecx, [ebp-18h]
.text$mn:00001547                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000154C                 push    eax             ; Src
.text$mn:0000154D                 mov     eax, [ebp-20h]
.text$mn:00001550                 push    eax             ; Dst
.text$mn:00001551                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00001556                 add     esp, 0Ch
.text$mn:00001559
.text$mn:00001559 loc_1559:                               ; CODE XREF: $LN19+Bj
.text$mn:00001559                 push    0               ; Size
.text$mn:0000155B                 push    1               ; char
.text$mn:0000155D                 mov     ecx, [ebp-18h]
.text$mn:00001560                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00001565                 lea     ecx, [ebp-20h]
.text$mn:00001568                 push    ecx             ; int
.text$mn:00001569                 mov     edx, [ebp-18h]
.text$mn:0000156C                 add     edx, 4
.text$mn:0000156F                 push    edx             ; void *
.text$mn:00001570                 lea     eax, [ebp-13h]
.text$mn:00001573                 push    eax
.text$mn:00001574                 mov     ecx, [ebp-18h]
.text$mn:00001577                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:0000157C                 mov     ecx, eax
.text$mn:0000157E                 call    ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)
.text$mn:00001583                 mov     ecx, [ebp-18h]
.text$mn:00001586                 mov     edx, [ebp-1Ch]
.text$mn:00001589                 mov     [ecx+18h], edx
.text$mn:0000158C                 mov     eax, [ebp+0Ch]
.text$mn:0000158F                 push    eax
.text$mn:00001590                 mov     ecx, [ebp-18h]
.text$mn:00001593                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00001598                 mov     ecx, [ebp-0Ch]
.text$mn:0000159B                 mov     large fs:0, ecx
.text$mn:000015A2                 pop     ecx
.text$mn:000015A3                 pop     edi
.text$mn:000015A4                 pop     esi
.text$mn:000015A5                 pop     ebx
.text$mn:000015A6                 mov     esp, ebp
.text$mn:000015A8                 pop     ebp
.text$mn:000015A9                 retn    8
.text$mn:000015A9 $LN19           endp ; sp-analysis failed
.text$mn:000015A9
.text$mn:000015A9 _text$mn        ends
.text$mn:000015A9
.text$x:000015AC ; ===========================================================================
.text$x:000015AC
.text$x:000015AC ; Segment type: Pure code
.text$x:000015AC ; Segment permissions: Read/Execute
.text$x:000015AC _text$x         segment para public 'CODE' use32
.text$x:000015AC                 assume cs:_text$x
.text$x:000015AC                 ;org 15ACh
.text$x:000015AC ; COMDAT (pick associative to section at 1408)
.text$x:000015AC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000015AC
.text$x:000015AC ; =============== S U B R O U T I N E =======================================
.text$x:000015AC
.text$x:000015AC
.text$x:000015AC __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
.text$x:000015AC                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+5o
.text$x:000015AC
.text$x:000015AC arg_4           = dword ptr  8
.text$x:000015AC
.text$x:000015AC                 mov     edx, [esp+arg_4]
.text$x:000015B0                 lea     eax, [edx+0Ch]
.text$x:000015B3                 mov     ecx, [edx-24h]
.text$x:000015B6                 xor     ecx, eax
.text$x:000015B8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000015BD                 mov     eax, offset __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$x:000015C2                 jmp     ___CxxFrameHandler3
.text$x:000015C2 __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp
.text$x:000015C2
.text$x:000015C2 ; ---------------------------------------------------------------------------
.text$x:000015C7                 align 4
.text$x:000015C7 _text$x         ends
.text$x:000015C7
.text$mn:000015C8 ; ===========================================================================
.text$mn:000015C8
.text$mn:000015C8 ; Segment type: Pure code
.text$mn:000015C8 ; Segment permissions: Read/Execute
.text$mn:000015C8 _text$mn        segment para public 'CODE' use32
.text$mn:000015C8                 assume cs:_text$mn
.text$mn:000015C8                 ;org 15C8h
.text$mn:000015C8 ; COMDAT (pick any)
.text$mn:000015C8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000015C8
.text$mn:000015C8 ; =============== S U B R O U T I N E =======================================
.text$mn:000015C8
.text$mn:000015C8 ; Attributes: bp-based frame
.text$mn:000015C8
.text$mn:000015C8 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Eos(unsigned int)
.text$mn:000015C8                 public ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
.text$mn:000015C8 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z proc near
.text$mn:000015C8                                         ; CODE XREF: $LN19+60p
.text$mn:000015C8                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+83p ...
.text$mn:000015C8
.text$mn:000015C8 var_8           = dword ptr -8
.text$mn:000015C8 var_1           = byte ptr -1
.text$mn:000015C8 arg_0           = dword ptr  8
.text$mn:000015C8
.text$mn:000015C8                 push    ebp
.text$mn:000015C9                 mov     ebp, esp
.text$mn:000015CB                 sub     esp, 8
.text$mn:000015CE                 mov     [ebp+var_8], ecx
.text$mn:000015D1                 mov     [ebp+var_1], 0
.text$mn:000015D5                 mov     eax, [ebp+var_8]
.text$mn:000015D8                 mov     ecx, [ebp+arg_0]
.text$mn:000015DB                 mov     [eax+14h], ecx
.text$mn:000015DE                 lea     edx, [ebp+var_1]
.text$mn:000015E1                 push    edx
.text$mn:000015E2                 mov     ecx, [ebp+var_8]
.text$mn:000015E5                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000015EA                 add     eax, [ebp+arg_0]
.text$mn:000015ED                 push    eax
.text$mn:000015EE                 call    ?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign(char &,char const &)
.text$mn:000015F3                 add     esp, 8
.text$mn:000015F6                 mov     esp, ebp
.text$mn:000015F8                 pop     ebp
.text$mn:000015F9                 retn    4
.text$mn:000015F9 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z endp
.text$mn:000015F9
.text$mn:000015F9 _text$mn        ends
.text$mn:000015F9
.text$mn:000015FC ; ===========================================================================
.text$mn:000015FC
.text$mn:000015FC ; Segment type: Pure code
.text$mn:000015FC ; Segment permissions: Read/Execute
.text$mn:000015FC _text$mn        segment para public 'CODE' use32
.text$mn:000015FC                 assume cs:_text$mn
.text$mn:000015FC                 ;org 15FCh
.text$mn:000015FC ; COMDAT (pick any)
.text$mn:000015FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000015FC
.text$mn:000015FC ; =============== S U B R O U T I N E =======================================
.text$mn:000015FC
.text$mn:000015FC ; Attributes: bp-based frame
.text$mn:000015FC
.text$mn:000015FC ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Free_proxy(void)
.text$mn:000015FC                 public ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
.text$mn:000015FC ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
.text$mn:000015FC                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+30p
.text$mn:000015FC
.text$mn:000015FC var_8           = dword ptr -8
.text$mn:000015FC var_1           = byte ptr -1
.text$mn:000015FC
.text$mn:000015FC                 push    ebp
.text$mn:000015FD                 mov     ebp, esp
.text$mn:000015FF                 sub     esp, 8
.text$mn:00001602                 mov     [ebp+var_8], ecx
.text$mn:00001605                 lea     ecx, [ebp+var_1]
.text$mn:00001608                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:0000160D                 mov     ecx, [ebp+var_8] ; this
.text$mn:00001610                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00001615                 mov     eax, [ebp+var_8]
.text$mn:00001618                 mov     ecx, [eax]
.text$mn:0000161A                 push    ecx
.text$mn:0000161B                 lea     ecx, [ebp+var_1]
.text$mn:0000161E                 call    ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:00001623                 push    1               ; int
.text$mn:00001625                 mov     edx, [ebp+var_8]
.text$mn:00001628                 mov     eax, [edx]
.text$mn:0000162A                 push    eax             ; void *
.text$mn:0000162B                 lea     ecx, [ebp+var_1]
.text$mn:0000162E                 call    ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate(std::_Container_proxy *,uint)
.text$mn:00001633                 mov     ecx, [ebp+var_8]
.text$mn:00001636                 mov     dword ptr [ecx], 0
.text$mn:0000163C                 mov     esp, ebp
.text$mn:0000163E                 pop     ebp
.text$mn:0000163F                 retn
.text$mn:0000163F ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp
.text$mn:0000163F
.text$mn:0000163F _text$mn        ends
.text$mn:0000163F
.text$mn:00001640 ; ===========================================================================
.text$mn:00001640
.text$mn:00001640 ; Segment type: Pure code
.text$mn:00001640 ; Segment permissions: Read/Execute
.text$mn:00001640 _text$mn        segment para public 'CODE' use32
.text$mn:00001640                 assume cs:_text$mn
.text$mn:00001640                 ;org 1640h
.text$mn:00001640 ; COMDAT (pick any)
.text$mn:00001640                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001640
.text$mn:00001640 ; =============== S U B R O U T I N E =======================================
.text$mn:00001640
.text$mn:00001640 ; Attributes: bp-based frame
.text$mn:00001640
.text$mn:00001640 ; public: struct std::_Wrap_alloc<class std::allocator<char>> __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Getal(void)const
.text$mn:00001640                 public ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
.text$mn:00001640 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ proc near
.text$mn:00001640                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+B4p
.text$mn:00001640                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+1Bp ...
.text$mn:00001640
.text$mn:00001640 var_4           = dword ptr -4
.text$mn:00001640 arg_0           = dword ptr  8
.text$mn:00001640
.text$mn:00001640                 push    ebp
.text$mn:00001641                 mov     ebp, esp
.text$mn:00001643                 push    ecx
.text$mn:00001644                 mov     [ebp+var_4], ecx
.text$mn:00001647                 mov     ecx, [ebp+arg_0]
.text$mn:0000164A                 call    ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)
.text$mn:0000164F                 mov     eax, [ebp+arg_0]
.text$mn:00001652                 mov     esp, ebp
.text$mn:00001654                 pop     ebp
.text$mn:00001655                 retn    4
.text$mn:00001655 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ endp
.text$mn:00001655
.text$mn:00001655 _text$mn        ends
.text$mn:00001655
.text$mn:00001658 ; ===========================================================================
.text$mn:00001658
.text$mn:00001658 ; Segment type: Pure code
.text$mn:00001658 ; Segment permissions: Read/Execute
.text$mn:00001658 _text$mn        segment para public 'CODE' use32
.text$mn:00001658                 assume cs:_text$mn
.text$mn:00001658                 ;org 1658h
.text$mn:00001658 ; COMDAT (pick any)
.text$mn:00001658                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001658
.text$mn:00001658 ; =============== S U B R O U T I N E =======================================
.text$mn:00001658
.text$mn:00001658 ; Attributes: bp-based frame
.text$mn:00001658
.text$mn:00001658 ; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Grow(unsigned int, bool)
.text$mn:00001658                 public ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
.text$mn:00001658 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z proc near
.text$mn:00001658                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+6Ap
.text$mn:00001658                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+5Fp
.text$mn:00001658
.text$mn:00001658 var_C           = dword ptr -0Ch
.text$mn:00001658 Size            = dword ptr -8
.text$mn:00001658 var_4           = dword ptr -4
.text$mn:00001658 arg_0           = dword ptr  8
.text$mn:00001658 arg_4           = byte ptr  0Ch
.text$mn:00001658
.text$mn:00001658                 push    ebp
.text$mn:00001659                 mov     ebp, esp
.text$mn:0000165B                 sub     esp, 0Ch
.text$mn:0000165E                 mov     [ebp+var_4], ecx
.text$mn:00001661                 mov     ecx, [ebp+var_4]
.text$mn:00001664                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00001669                 cmp     eax, [ebp+arg_0]
.text$mn:0000166C                 jnb     short loc_1676
.text$mn:0000166E                 mov     ecx, [ebp+var_4]
.text$mn:00001671                 call    ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)
.text$mn:00001676
.text$mn:00001676 loc_1676:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+14j
.text$mn:00001676                 mov     eax, [ebp+var_4]
.text$mn:00001679                 mov     ecx, [eax+18h]
.text$mn:0000167C                 cmp     ecx, [ebp+arg_0]
.text$mn:0000167F                 jnb     short loc_1696
.text$mn:00001681                 mov     edx, [ebp+var_4]
.text$mn:00001684                 mov     eax, [edx+14h]
.text$mn:00001687                 push    eax
.text$mn:00001688                 mov     ecx, [ebp+arg_0]
.text$mn:0000168B                 push    ecx
.text$mn:0000168C                 mov     ecx, [ebp+var_4]
.text$mn:0000168F                 call    ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)
.text$mn:00001694                 jmp     short loc_16E0
.text$mn:00001696 ; ---------------------------------------------------------------------------
.text$mn:00001696
.text$mn:00001696 loc_1696:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+27j
.text$mn:00001696                 movzx   edx, [ebp+arg_4]
.text$mn:0000169A                 test    edx, edx
.text$mn:0000169C                 jz      short loc_16D0
.text$mn:0000169E                 cmp     [ebp+arg_0], 10h
.text$mn:000016A2                 jnb     short loc_16D0
.text$mn:000016A4                 mov     eax, [ebp+var_4]
.text$mn:000016A7                 mov     ecx, [ebp+arg_0]
.text$mn:000016AA                 cmp     ecx, [eax+14h]
.text$mn:000016AD                 jnb     short loc_16B7
.text$mn:000016AF                 mov     edx, [ebp+arg_0]
.text$mn:000016B2                 mov     [ebp+Size], edx
.text$mn:000016B5                 jmp     short loc_16C0
.text$mn:000016B7 ; ---------------------------------------------------------------------------
.text$mn:000016B7
.text$mn:000016B7 loc_16B7:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+55j
.text$mn:000016B7                 mov     eax, [ebp+var_4]
.text$mn:000016BA                 mov     ecx, [eax+14h]
.text$mn:000016BD                 mov     [ebp+Size], ecx
.text$mn:000016C0
.text$mn:000016C0 loc_16C0:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+5Dj
.text$mn:000016C0                 mov     edx, [ebp+Size]
.text$mn:000016C3                 push    edx             ; Size
.text$mn:000016C4                 push    1               ; char
.text$mn:000016C6                 mov     ecx, [ebp+var_4]
.text$mn:000016C9                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:000016CE                 jmp     short loc_16E0
.text$mn:000016D0 ; ---------------------------------------------------------------------------
.text$mn:000016D0
.text$mn:000016D0 loc_16D0:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+44j
.text$mn:000016D0                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+4Aj
.text$mn:000016D0                 cmp     [ebp+arg_0], 0
.text$mn:000016D4                 jnz     short loc_16E0
.text$mn:000016D6                 push    0
.text$mn:000016D8                 mov     ecx, [ebp+var_4]
.text$mn:000016DB                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000016E0
.text$mn:000016E0 loc_16E0:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+3Cj
.text$mn:000016E0                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+76j ...
.text$mn:000016E0                 cmp     [ebp+arg_0], 0
.text$mn:000016E4                 jbe     short loc_16EF
.text$mn:000016E6                 mov     [ebp+var_C], 1
.text$mn:000016ED                 jmp     short loc_16F6
.text$mn:000016EF ; ---------------------------------------------------------------------------
.text$mn:000016EF
.text$mn:000016EF loc_16EF:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+8Cj
.text$mn:000016EF                 mov     [ebp+var_C], 0
.text$mn:000016F6
.text$mn:000016F6 loc_16F6:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+95j
.text$mn:000016F6                 mov     al, byte ptr [ebp+var_C]
.text$mn:000016F9                 mov     esp, ebp
.text$mn:000016FB                 pop     ebp
.text$mn:000016FC                 retn    8
.text$mn:000016FC ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z endp
.text$mn:000016FC
.text$mn:000016FC ; ---------------------------------------------------------------------------
.text$mn:000016FF                 align 10h
.text$mn:000016FF _text$mn        ends
.text$mn:000016FF
.text$mn:00001700 ; ===========================================================================
.text$mn:00001700
.text$mn:00001700 ; Segment type: Pure code
.text$mn:00001700 ; Segment permissions: Read/Execute
.text$mn:00001700 _text$mn        segment para public 'CODE' use32
.text$mn:00001700                 assume cs:_text$mn
.text$mn:00001700                 ;org 1700h
.text$mn:00001700 ; COMDAT (pick any)
.text$mn:00001700                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001700
.text$mn:00001700 ; =============== S U B R O U T I N E =======================================
.text$mn:00001700
.text$mn:00001700 ; Attributes: bp-based frame
.text$mn:00001700
.text$mn:00001700 ; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Inside(char const *)
.text$mn:00001700                 public ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
.text$mn:00001700 ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z proc near
.text$mn:00001700                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+2Ap
.text$mn:00001700
.text$mn:00001700 var_4           = dword ptr -4
.text$mn:00001700 arg_0           = dword ptr  8
.text$mn:00001700
.text$mn:00001700                 push    ebp
.text$mn:00001701                 mov     ebp, esp
.text$mn:00001703                 push    ecx
.text$mn:00001704                 mov     [ebp+var_4], ecx
.text$mn:00001707                 cmp     [ebp+arg_0], 0
.text$mn:0000170B                 jz      short loc_172D
.text$mn:0000170D                 mov     ecx, [ebp+var_4]
.text$mn:00001710                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00001715                 cmp     [ebp+arg_0], eax
.text$mn:00001718                 jb      short loc_172D
.text$mn:0000171A                 mov     ecx, [ebp+var_4]
.text$mn:0000171D                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00001722                 mov     ecx, [ebp+var_4]
.text$mn:00001725                 add     eax, [ecx+14h]
.text$mn:00001728                 cmp     eax, [ebp+arg_0]
.text$mn:0000172B                 ja      short loc_1733
.text$mn:0000172D
.text$mn:0000172D loc_172D:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+Bj
.text$mn:0000172D                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+18j
.text$mn:0000172D                 xor     al, al
.text$mn:0000172F                 jmp     short loc_1735
.text$mn:00001731 ; ---------------------------------------------------------------------------
.text$mn:00001731                 jmp     short loc_1735
.text$mn:00001733 ; ---------------------------------------------------------------------------
.text$mn:00001733
.text$mn:00001733 loc_1733:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+2Bj
.text$mn:00001733                 mov     al, 1
.text$mn:00001735
.text$mn:00001735 loc_1735:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+2Fj
.text$mn:00001735                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+31j
.text$mn:00001735                 mov     esp, ebp
.text$mn:00001737                 pop     ebp
.text$mn:00001738                 retn    4
.text$mn:00001738 ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z endp
.text$mn:00001738
.text$mn:00001738 ; ---------------------------------------------------------------------------
.text$mn:0000173B                 align 4
.text$mn:0000173B _text$mn        ends
.text$mn:0000173B
.text$mn:0000173C ; ===========================================================================
.text$mn:0000173C
.text$mn:0000173C ; Segment type: Pure code
.text$mn:0000173C ; Segment permissions: Read/Execute
.text$mn:0000173C _text$mn        segment para public 'CODE' use32
.text$mn:0000173C                 assume cs:_text$mn
.text$mn:0000173C                 ;org 173Ch
.text$mn:0000173C ; COMDAT (pick any)
.text$mn:0000173C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000173C
.text$mn:0000173C ; =============== S U B R O U T I N E =======================================
.text$mn:0000173C
.text$mn:0000173C ; Attributes: bp-based frame
.text$mn:0000173C
.text$mn:0000173C ; public: char * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000173C                 public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
.text$mn:0000173C ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ proc near
.text$mn:0000173C                                         ; CODE XREF: $LN19+14p
.text$mn:0000173C                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+1Dp ...
.text$mn:0000173C
.text$mn:0000173C var_8           = dword ptr -8
.text$mn:0000173C var_4           = dword ptr -4
.text$mn:0000173C
.text$mn:0000173C                 push    ebp
.text$mn:0000173D                 mov     ebp, esp
.text$mn:0000173F                 sub     esp, 8
.text$mn:00001742                 mov     [ebp+var_4], ecx
.text$mn:00001745                 mov     eax, [ebp+var_4]
.text$mn:00001748                 cmp     dword ptr [eax+18h], 10h
.text$mn:0000174C                 jb      short loc_1762
.text$mn:0000174E                 mov     ecx, [ebp+var_4]
.text$mn:00001751                 mov     edx, [ecx+4]
.text$mn:00001754                 push    edx
.text$mn:00001755                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:0000175A                 add     esp, 4
.text$mn:0000175D                 mov     [ebp+var_8], eax
.text$mn:00001760                 jmp     short loc_176B
.text$mn:00001762 ; ---------------------------------------------------------------------------
.text$mn:00001762
.text$mn:00001762 loc_1762:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+10j
.text$mn:00001762                 mov     eax, [ebp+var_4]
.text$mn:00001765                 add     eax, 4
.text$mn:00001768                 mov     [ebp+var_8], eax
.text$mn:0000176B
.text$mn:0000176B loc_176B:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+24j
.text$mn:0000176B                 mov     eax, [ebp+var_8]
.text$mn:0000176E                 mov     esp, ebp
.text$mn:00001770                 pop     ebp
.text$mn:00001771                 retn
.text$mn:00001771 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ endp
.text$mn:00001771
.text$mn:00001771 ; ---------------------------------------------------------------------------
.text$mn:00001772                 align 4
.text$mn:00001772 _text$mn        ends
.text$mn:00001772
.text$mn:00001774 ; ===========================================================================
.text$mn:00001774
.text$mn:00001774 ; Segment type: Pure code
.text$mn:00001774 ; Segment permissions: Read/Execute
.text$mn:00001774 _text$mn        segment para public 'CODE' use32
.text$mn:00001774                 assume cs:_text$mn
.text$mn:00001774                 ;org 1774h
.text$mn:00001774 ; COMDAT (pick any)
.text$mn:00001774                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001774
.text$mn:00001774 ; =============== S U B R O U T I N E =======================================
.text$mn:00001774
.text$mn:00001774 ; Attributes: bp-based frame
.text$mn:00001774
.text$mn:00001774 ; public: char const * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)const
.text$mn:00001774                 public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
.text$mn:00001774 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ proc near
.text$mn:00001774                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+7Dp
.text$mn:00001774
.text$mn:00001774 var_8           = dword ptr -8
.text$mn:00001774 var_4           = dword ptr -4
.text$mn:00001774
.text$mn:00001774                 push    ebp
.text$mn:00001775                 mov     ebp, esp
.text$mn:00001777                 sub     esp, 8
.text$mn:0000177A                 mov     [ebp+var_4], ecx
.text$mn:0000177D                 mov     eax, [ebp+var_4]
.text$mn:00001780                 cmp     dword ptr [eax+18h], 10h
.text$mn:00001784                 jb      short loc_179A
.text$mn:00001786                 mov     ecx, [ebp+var_4]
.text$mn:00001789                 mov     edx, [ecx+4]
.text$mn:0000178C                 push    edx
.text$mn:0000178D                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:00001792                 add     esp, 4
.text$mn:00001795                 mov     [ebp+var_8], eax
.text$mn:00001798                 jmp     short loc_17A3
.text$mn:0000179A ; ---------------------------------------------------------------------------
.text$mn:0000179A
.text$mn:0000179A loc_179A:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+10j
.text$mn:0000179A                 mov     eax, [ebp+var_4]
.text$mn:0000179D                 add     eax, 4
.text$mn:000017A0                 mov     [ebp+var_8], eax
.text$mn:000017A3
.text$mn:000017A3 loc_17A3:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+24j
.text$mn:000017A3                 mov     eax, [ebp+var_8]
.text$mn:000017A6                 mov     esp, ebp
.text$mn:000017A8                 pop     ebp
.text$mn:000017A9                 retn
.text$mn:000017A9 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ endp
.text$mn:000017A9
.text$mn:000017A9 ; ---------------------------------------------------------------------------
.text$mn:000017AA                 align 4
.text$mn:000017AA _text$mn        ends
.text$mn:000017AA
.text$mn:000017AC ; ===========================================================================
.text$mn:000017AC
.text$mn:000017AC ; Segment type: Pure code
.text$mn:000017AC ; Segment permissions: Read/Execute
.text$mn:000017AC _text$mn        segment para public 'CODE' use32
.text$mn:000017AC                 assume cs:_text$mn
.text$mn:000017AC                 ;org 17ACh
.text$mn:000017AC ; COMDAT (pick any)
.text$mn:000017AC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000017AC
.text$mn:000017AC ; =============== S U B R O U T I N E =======================================
.text$mn:000017AC
.text$mn:000017AC ; Attributes: bp-based frame
.text$mn:000017AC
.text$mn:000017AC ; void __thiscall std::_Container_base12::_Orphan_all(std::_Container_base12 *__hidden this)
.text$mn:000017AC                 public ?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$mn:000017AC ?_Orphan_all@_Container_base12@std@@QAEXXZ proc near
.text$mn:000017AC                                         ; CODE XREF: std::_Container_base12::~_Container_base12(void)+Ap
.text$mn:000017AC                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+14p
.text$mn:000017AC
.text$mn:000017AC var_18          = byte ptr -18h
.text$mn:000017AC var_14          = dword ptr -14h
.text$mn:000017AC var_10          = dword ptr -10h
.text$mn:000017AC var_C           = dword ptr -0Ch
.text$mn:000017AC var_4           = dword ptr -4
.text$mn:000017AC
.text$mn:000017AC                 push    ebp
.text$mn:000017AD                 mov     ebp, esp
.text$mn:000017AF                 push    0FFFFFFFFh
.text$mn:000017B1                 push    offset __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$mn:000017B6                 mov     eax, large fs:0
.text$mn:000017BC                 push    eax
.text$mn:000017BD                 sub     esp, 0Ch
.text$mn:000017C0                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000017C5                 xor     eax, ebp
.text$mn:000017C7                 push    eax
.text$mn:000017C8                 lea     eax, [ebp+var_C]
.text$mn:000017CB                 mov     large fs:0, eax
.text$mn:000017D1                 mov     [ebp+var_14], ecx
.text$mn:000017D4                 mov     eax, [ebp+var_14]
.text$mn:000017D7                 cmp     dword ptr [eax], 0
.text$mn:000017DA                 jz      short loc_1837
.text$mn:000017DC                 push    3               ; int
.text$mn:000017DE                 lea     ecx, [ebp+var_18] ; this
.text$mn:000017E1                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:000017E6                 mov     [ebp+var_4], 0
.text$mn:000017ED                 mov     ecx, [ebp+var_14]
.text$mn:000017F0                 mov     edx, [ecx]
.text$mn:000017F2                 add     edx, 4
.text$mn:000017F5                 mov     [ebp+var_10], edx
.text$mn:000017F8                 jmp     short loc_1807
.text$mn:000017FA ; ---------------------------------------------------------------------------
.text$mn:000017FA
.text$mn:000017FA loc_17FA:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+6Ej
.text$mn:000017FA                 mov     eax, [ebp+var_10]
.text$mn:000017FD                 mov     ecx, [eax]
.text$mn:000017FF                 mov     edx, [ebp+var_10]
.text$mn:00001802                 mov     eax, [ecx+4]
.text$mn:00001805                 mov     [edx], eax
.text$mn:00001807
.text$mn:00001807 loc_1807:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+4Cj
.text$mn:00001807                 mov     ecx, [ebp+var_10]
.text$mn:0000180A                 cmp     dword ptr [ecx], 0
.text$mn:0000180D                 jz      short loc_181C
.text$mn:0000180F                 mov     edx, [ebp+var_10]
.text$mn:00001812                 mov     eax, [edx]
.text$mn:00001814                 mov     dword ptr [eax], 0
.text$mn:0000181A                 jmp     short loc_17FA
.text$mn:0000181C ; ---------------------------------------------------------------------------
.text$mn:0000181C
.text$mn:0000181C loc_181C:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+61j
.text$mn:0000181C                 mov     ecx, [ebp+var_14]
.text$mn:0000181F                 mov     edx, [ecx]
.text$mn:00001821                 mov     dword ptr [edx+4], 0
.text$mn:00001828                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000182F                 lea     ecx, [ebp+var_18] ; this
.text$mn:00001832                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:00001837
.text$mn:00001837 loc_1837:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+2Ej
.text$mn:00001837                 mov     ecx, [ebp+var_C]
.text$mn:0000183A                 mov     large fs:0, ecx
.text$mn:00001841                 pop     ecx
.text$mn:00001842                 mov     esp, ebp
.text$mn:00001844                 pop     ebp
.text$mn:00001845                 retn
.text$mn:00001845 ?_Orphan_all@_Container_base12@std@@QAEXXZ endp
.text$mn:00001845
.text$mn:00001845 ; ---------------------------------------------------------------------------
.text$mn:00001846                 align 4
.text$mn:00001846 _text$mn        ends
.text$mn:00001846
.text$x:00001848 ; ===========================================================================
.text$x:00001848
.text$x:00001848 ; Segment type: Pure code
.text$x:00001848 ; Segment permissions: Read/Execute
.text$x:00001848 _text$x         segment para public 'CODE' use32
.text$x:00001848                 assume cs:_text$x
.text$x:00001848                 ;org 1848h
.text$x:00001848 ; COMDAT (pick associative to section at 17AC)
.text$x:00001848                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001848
.text$x:00001848 ; =============== S U B R O U T I N E =======================================
.text$x:00001848
.text$x:00001848
.text$x:00001848 __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0 proc near
.text$x:00001848                                         ; DATA XREF: .xdata$x:00002148o
.text$x:00001848                 lea     ecx, [ebp-18h]  ; this
.text$x:0000184B                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:0000184B __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0 endp
.text$x:0000184B
.text$x:00001850
.text$x:00001850 ; =============== S U B R O U T I N E =======================================
.text$x:00001850
.text$x:00001850
.text$x:00001850 __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ proc near
.text$x:00001850                                         ; DATA XREF: std::_Container_base12::_Orphan_all(void)+5o
.text$x:00001850
.text$x:00001850 arg_4           = dword ptr  8
.text$x:00001850
.text$x:00001850                 mov     edx, [esp+arg_4]
.text$x:00001854                 lea     eax, [edx+0Ch]
.text$x:00001857                 mov     ecx, [edx-10h]
.text$x:0000185A                 xor     ecx, eax
.text$x:0000185C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001861                 mov     eax, offset __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$x:00001866                 jmp     ___CxxFrameHandler3
.text$x:00001866 __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ endp
.text$x:00001866
.text$x:00001866 ; ---------------------------------------------------------------------------
.text$x:0000186B                 align 4
.text$x:0000186B _text$x         ends
.text$x:0000186B
.text$mn:0000186C ; ===========================================================================
.text$mn:0000186C
.text$mn:0000186C ; Segment type: Pure code
.text$mn:0000186C ; Segment permissions: Read/Execute
.text$mn:0000186C _text$mn        segment para public 'CODE' use32
.text$mn:0000186C                 assume cs:_text$mn
.text$mn:0000186C                 ;org 186Ch
.text$mn:0000186C ; COMDAT (pick any)
.text$mn:0000186C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000186C
.text$mn:0000186C ; =============== S U B R O U T I N E =======================================
.text$mn:0000186C
.text$mn:0000186C ; Attributes: bp-based frame
.text$mn:0000186C
.text$mn:0000186C ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(char, size_t Size)
.text$mn:0000186C                 public ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
.text$mn:0000186C ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z proc near
.text$mn:0000186C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+47p
.text$mn:0000186C                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+34p ...
.text$mn:0000186C
.text$mn:0000186C var_C           = dword ptr -0Ch
.text$mn:0000186C var_8           = dword ptr -8
.text$mn:0000186C var_2           = byte ptr -2
.text$mn:0000186C var_1           = byte ptr -1
.text$mn:0000186C arg_0           = byte ptr  8
.text$mn:0000186C Size            = dword ptr  0Ch
.text$mn:0000186C
.text$mn:0000186C                 push    ebp
.text$mn:0000186D                 mov     ebp, esp
.text$mn:0000186F                 sub     esp, 0Ch
.text$mn:00001872                 mov     [ebp+var_8], ecx
.text$mn:00001875                 movzx   eax, [ebp+arg_0]
.text$mn:00001879                 test    eax, eax
.text$mn:0000187B                 jnz     short loc_187F
.text$mn:0000187D                 jmp     short loc_18F2
.text$mn:0000187F ; ---------------------------------------------------------------------------
.text$mn:0000187F
.text$mn:0000187F loc_187F:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+Fj
.text$mn:0000187F                 mov     ecx, [ebp+var_8]
.text$mn:00001882                 cmp     dword ptr [ecx+18h], 10h
.text$mn:00001886                 jb      short loc_18F2
.text$mn:00001888                 mov     edx, [ebp+var_8]
.text$mn:0000188B                 mov     eax, [edx+4]
.text$mn:0000188E                 mov     [ebp+var_C], eax
.text$mn:00001891                 mov     ecx, [ebp+var_8]
.text$mn:00001894                 add     ecx, 4
.text$mn:00001897                 push    ecx
.text$mn:00001898                 lea     edx, [ebp+var_1]
.text$mn:0000189B                 push    edx
.text$mn:0000189C                 mov     ecx, [ebp+var_8]
.text$mn:0000189F                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:000018A4                 mov     ecx, eax
.text$mn:000018A6                 call    ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)
.text$mn:000018AB                 cmp     [ebp+Size], 0
.text$mn:000018AF                 jbe     short loc_18D1
.text$mn:000018B1                 mov     eax, [ebp+Size]
.text$mn:000018B4                 push    eax             ; Size
.text$mn:000018B5                 mov     ecx, [ebp+var_C]
.text$mn:000018B8                 push    ecx
.text$mn:000018B9                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:000018BE                 add     esp, 4
.text$mn:000018C1                 push    eax             ; Src
.text$mn:000018C2                 mov     edx, [ebp+var_8]
.text$mn:000018C5                 add     edx, 4
.text$mn:000018C8                 push    edx             ; Dst
.text$mn:000018C9                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:000018CE                 add     esp, 0Ch
.text$mn:000018D1
.text$mn:000018D1 loc_18D1:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+43j
.text$mn:000018D1                 mov     eax, [ebp+var_8]
.text$mn:000018D4                 mov     ecx, [eax+18h]
.text$mn:000018D7                 add     ecx, 1
.text$mn:000018DA                 push    ecx             ; int
.text$mn:000018DB                 mov     edx, [ebp+var_C]
.text$mn:000018DE                 push    edx             ; void *
.text$mn:000018DF                 lea     eax, [ebp+var_2]
.text$mn:000018E2                 push    eax
.text$mn:000018E3                 mov     ecx, [ebp+var_8]
.text$mn:000018E6                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:000018EB                 mov     ecx, eax
.text$mn:000018ED                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)
.text$mn:000018F2
.text$mn:000018F2 loc_18F2:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+11j
.text$mn:000018F2                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+1Aj
.text$mn:000018F2                 mov     ecx, [ebp+var_8]
.text$mn:000018F5                 mov     dword ptr [ecx+18h], 0Fh
.text$mn:000018FC                 mov     edx, [ebp+Size]
.text$mn:000018FF                 push    edx
.text$mn:00001900                 mov     ecx, [ebp+var_8]
.text$mn:00001903                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00001908                 mov     esp, ebp
.text$mn:0000190A                 pop     ebp
.text$mn:0000190B                 retn    8
.text$mn:0000190B ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z endp
.text$mn:0000190B
.text$mn:0000190B ; ---------------------------------------------------------------------------
.text$mn:0000190E                 align 10h
.text$mn:0000190E _text$mn        ends
.text$mn:0000190E
.text$mn:00001910 ; ===========================================================================
.text$mn:00001910
.text$mn:00001910 ; Segment type: Pure code
.text$mn:00001910 ; Segment permissions: Read/Execute
.text$mn:00001910 _text$mn        segment para public 'CODE' use32
.text$mn:00001910                 assume cs:_text$mn
.text$mn:00001910                 ;org 1910h
.text$mn:00001910 ; COMDAT (pick any)
.text$mn:00001910                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001910
.text$mn:00001910 ; =============== S U B R O U T I N E =======================================
.text$mn:00001910
.text$mn:00001910 ; Attributes: bp-based frame
.text$mn:00001910
.text$mn:00001910 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xlen(void)const
.text$mn:00001910                 public ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
.text$mn:00001910 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc near
.text$mn:00001910                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+19p
.text$mn:00001910
.text$mn:00001910 var_4           = dword ptr -4
.text$mn:00001910
.text$mn:00001910                 push    ebp
.text$mn:00001911                 mov     ebp, esp
.text$mn:00001913                 push    ecx
.text$mn:00001914                 mov     [ebp+var_4], ecx
.text$mn:00001917                 push    offset ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ ; "string too long"
.text$mn:0000191C                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:00001921                 mov     esp, ebp
.text$mn:00001923                 pop     ebp
.text$mn:00001924                 retn
.text$mn:00001924 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp
.text$mn:00001924
.text$mn:00001924 ; ---------------------------------------------------------------------------
.text$mn:00001925                 align 4
.text$mn:00001925 _text$mn        ends
.text$mn:00001925
.text$mn:00001928 ; ===========================================================================
.text$mn:00001928
.text$mn:00001928 ; Segment type: Pure code
.text$mn:00001928 ; Segment permissions: Read/Execute
.text$mn:00001928 _text$mn        segment para public 'CODE' use32
.text$mn:00001928                 assume cs:_text$mn
.text$mn:00001928                 ;org 1928h
.text$mn:00001928 ; COMDAT (pick any)
.text$mn:00001928                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001928
.text$mn:00001928 ; =============== S U B R O U T I N E =======================================
.text$mn:00001928
.text$mn:00001928 ; Attributes: bp-based frame
.text$mn:00001928
.text$mn:00001928 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xran(void)const
.text$mn:00001928                 public ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
.text$mn:00001928 ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc near
.text$mn:00001928                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+19p
.text$mn:00001928                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)+15p ...
.text$mn:00001928
.text$mn:00001928 var_4           = dword ptr -4
.text$mn:00001928
.text$mn:00001928                 push    ebp
.text$mn:00001929                 mov     ebp, esp
.text$mn:0000192B                 push    ecx
.text$mn:0000192C                 mov     [ebp+var_4], ecx
.text$mn:0000192F                 push    offset ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; "invalid string position"
.text$mn:00001934                 call    ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range(char const *)
.text$mn:00001939                 mov     esp, ebp
.text$mn:0000193B                 pop     ebp
.text$mn:0000193C                 retn
.text$mn:0000193C ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp
.text$mn:0000193C
.text$mn:0000193C ; ---------------------------------------------------------------------------
.text$mn:0000193D                 align 10h
.text$mn:0000193D _text$mn        ends
.text$mn:0000193D
.text$mn:00001940 ; ===========================================================================
.text$mn:00001940
.text$mn:00001940 ; Segment type: Pure code
.text$mn:00001940 ; Segment permissions: Read/Execute
.text$mn:00001940 _text$mn        segment para public 'CODE' use32
.text$mn:00001940                 assume cs:_text$mn
.text$mn:00001940                 ;org 1940h
.text$mn:00001940 ; COMDAT (pick any)
.text$mn:00001940                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001940
.text$mn:00001940 ; =============== S U B R O U T I N E =======================================
.text$mn:00001940
.text$mn:00001940 ; Attributes: bp-based frame
.text$mn:00001940
.text$mn:00001940 ; public: char * __thiscall std::_Wrap_alloc<class std::allocator<char>>::allocate(unsigned int)
.text$mn:00001940                 public ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
.text$mn:00001940 ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z proc near
.text$mn:00001940                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+BBp
.text$mn:00001940                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+22p
.text$mn:00001940
.text$mn:00001940 var_4           = dword ptr -4
.text$mn:00001940 arg_0           = dword ptr  8
.text$mn:00001940
.text$mn:00001940                 push    ebp
.text$mn:00001941                 mov     ebp, esp
.text$mn:00001943                 push    ecx
.text$mn:00001944                 mov     [ebp+var_4], ecx
.text$mn:00001947                 mov     eax, [ebp+arg_0]
.text$mn:0000194A                 push    eax
.text$mn:0000194B                 mov     ecx, [ebp+var_4]
.text$mn:0000194E                 call    ?allocate@?$allocator@D@std@@QAEPADI@Z ; std::allocator<char>::allocate(uint)
.text$mn:00001953                 mov     esp, ebp
.text$mn:00001955                 pop     ebp
.text$mn:00001956                 retn    4
.text$mn:00001956 ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z endp
.text$mn:00001956
.text$mn:00001956 ; ---------------------------------------------------------------------------
.text$mn:00001959                 align 4
.text$mn:00001959 _text$mn        ends
.text$mn:00001959
.text$mn:0000195C ; ===========================================================================
.text$mn:0000195C
.text$mn:0000195C ; Segment type: Pure code
.text$mn:0000195C ; Segment permissions: Read/Execute
.text$mn:0000195C _text$mn        segment para public 'CODE' use32
.text$mn:0000195C                 assume cs:_text$mn
.text$mn:0000195C                 ;org 195Ch
.text$mn:0000195C ; COMDAT (pick any)
.text$mn:0000195C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000195C
.text$mn:0000195C ; =============== S U B R O U T I N E =======================================
.text$mn:0000195C
.text$mn:0000195C ; Attributes: bp-based frame
.text$mn:0000195C
.text$mn:0000195C ; public: char * __thiscall std::allocator<char>::allocate(unsigned int)
.text$mn:0000195C                 public ?allocate@?$allocator@D@std@@QAEPADI@Z
.text$mn:0000195C ?allocate@?$allocator@D@std@@QAEPADI@Z proc near
.text$mn:0000195C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::allocate(uint)+Ep
.text$mn:0000195C
.text$mn:0000195C var_4           = dword ptr -4
.text$mn:0000195C arg_0           = dword ptr  8
.text$mn:0000195C
.text$mn:0000195C                 push    ebp
.text$mn:0000195D                 mov     ebp, esp
.text$mn:0000195F                 push    ecx
.text$mn:00001960                 mov     [ebp+var_4], ecx
.text$mn:00001963                 push    0
.text$mn:00001965                 mov     eax, [ebp+arg_0]
.text$mn:00001968                 push    eax
.text$mn:00001969                 call    ??$_Allocate@D@std@@YAPADIPAD@Z ; std::_Allocate<char>(uint,char *)
.text$mn:0000196E                 add     esp, 8
.text$mn:00001971                 mov     esp, ebp
.text$mn:00001973                 pop     ebp
.text$mn:00001974                 retn    4
.text$mn:00001974 ?allocate@?$allocator@D@std@@QAEPADI@Z endp
.text$mn:00001974
.text$mn:00001974 ; ---------------------------------------------------------------------------
.text$mn:00001977                 align 4
.text$mn:00001977 _text$mn        ends
.text$mn:00001977
.text$mn:00001978 ; ===========================================================================
.text$mn:00001978
.text$mn:00001978 ; Segment type: Pure code
.text$mn:00001978 ; Segment permissions: Read/Execute
.text$mn:00001978 _text$mn        segment para public 'CODE' use32
.text$mn:00001978                 assume cs:_text$mn
.text$mn:00001978                 ;org 1978h
.text$mn:00001978 ; COMDAT (pick any)
.text$mn:00001978                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001978
.text$mn:00001978 ; =============== S U B R O U T I N E =======================================
.text$mn:00001978
.text$mn:00001978 ; Attributes: bp-based frame
.text$mn:00001978
.text$mn:00001978 ; public: struct std::_Container_proxy * __thiscall std::allocator<struct std::_Container_proxy>::allocate(unsigned int)
.text$mn:00001978                 public ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z
.text$mn:00001978 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z proc near
.text$mn:00001978                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+16p
.text$mn:00001978
.text$mn:00001978 var_4           = dword ptr -4
.text$mn:00001978 arg_0           = dword ptr  8
.text$mn:00001978
.text$mn:00001978                 push    ebp
.text$mn:00001979                 mov     ebp, esp
.text$mn:0000197B                 push    ecx
.text$mn:0000197C                 mov     [ebp+var_4], ecx
.text$mn:0000197F                 push    0
.text$mn:00001981                 mov     eax, [ebp+arg_0]
.text$mn:00001984                 push    eax
.text$mn:00001985                 call    ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)
.text$mn:0000198A                 add     esp, 8
.text$mn:0000198D                 mov     esp, ebp
.text$mn:0000198F                 pop     ebp
.text$mn:00001990                 retn    4
.text$mn:00001990 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z endp
.text$mn:00001990
.text$mn:00001990 ; ---------------------------------------------------------------------------
.text$mn:00001993                 align 4
.text$mn:00001993 _text$mn        ends
.text$mn:00001993
.text$mn:00001994 ; ===========================================================================
.text$mn:00001994
.text$mn:00001994 ; Segment type: Pure code
.text$mn:00001994 ; Segment permissions: Read/Execute
.text$mn:00001994 _text$mn        segment para public 'CODE' use32
.text$mn:00001994                 assume cs:_text$mn
.text$mn:00001994                 ;org 1994h
.text$mn:00001994 ; COMDAT (pick any)
.text$mn:00001994                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001994
.text$mn:00001994 ; =============== S U B R O U T I N E =======================================
.text$mn:00001994
.text$mn:00001994 ; Attributes: bp-based frame
.text$mn:00001994
.text$mn:00001994 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::assign(class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> const &, unsigned int, unsigned int)
.text$mn:00001994                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
.text$mn:00001994 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z proc near
.text$mn:00001994                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+4Fp
.text$mn:00001994
.text$mn:00001994 Size            = dword ptr -8
.text$mn:00001994 var_4           = dword ptr -4
.text$mn:00001994 arg_0           = dword ptr  8
.text$mn:00001994 arg_4           = dword ptr  0Ch
.text$mn:00001994 arg_8           = dword ptr  10h
.text$mn:00001994
.text$mn:00001994                 push    ebp
.text$mn:00001995                 mov     ebp, esp
.text$mn:00001997                 sub     esp, 8
.text$mn:0000199A                 mov     [ebp+var_4], ecx
.text$mn:0000199D                 mov     ecx, [ebp+arg_0]
.text$mn:000019A0                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:000019A5                 cmp     eax, [ebp+arg_4]
.text$mn:000019A8                 jnb     short loc_19B2
.text$mn:000019AA                 mov     ecx, [ebp+var_4]
.text$mn:000019AD                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:000019B2
.text$mn:000019B2 loc_19B2:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+14j
.text$mn:000019B2                 mov     ecx, [ebp+arg_0]
.text$mn:000019B5                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:000019BA                 sub     eax, [ebp+arg_4]
.text$mn:000019BD                 mov     [ebp+Size], eax
.text$mn:000019C0                 mov     eax, [ebp+arg_8]
.text$mn:000019C3                 cmp     eax, [ebp+Size]
.text$mn:000019C6                 jnb     short loc_19CE
.text$mn:000019C8                 mov     ecx, [ebp+arg_8]
.text$mn:000019CB                 mov     [ebp+Size], ecx
.text$mn:000019CE
.text$mn:000019CE loc_19CE:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+32j
.text$mn:000019CE                 mov     edx, [ebp+var_4]
.text$mn:000019D1                 cmp     edx, [ebp+arg_0]
.text$mn:000019D4                 jnz     short loc_19F5
.text$mn:000019D6                 mov     eax, [ebp+arg_4]
.text$mn:000019D9                 add     eax, [ebp+Size]
.text$mn:000019DC                 push    eax
.text$mn:000019DD                 mov     ecx, [ebp+var_4]
.text$mn:000019E0                 call    ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)
.text$mn:000019E5                 mov     ecx, [ebp+arg_4]
.text$mn:000019E8                 push    ecx
.text$mn:000019E9                 push    0
.text$mn:000019EB                 mov     ecx, [ebp+var_4]
.text$mn:000019EE                 call    ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)
.text$mn:000019F3                 jmp     short loc_1A37
.text$mn:000019F5 ; ---------------------------------------------------------------------------
.text$mn:000019F5
.text$mn:000019F5 loc_19F5:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+40j
.text$mn:000019F5                 push    0
.text$mn:000019F7                 mov     edx, [ebp+Size]
.text$mn:000019FA                 push    edx
.text$mn:000019FB                 mov     ecx, [ebp+var_4]
.text$mn:000019FE                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:00001A03                 movzx   eax, al
.text$mn:00001A06                 test    eax, eax
.text$mn:00001A08                 jz      short loc_1A37
.text$mn:00001A0A                 mov     ecx, [ebp+Size]
.text$mn:00001A0D                 push    ecx             ; Size
.text$mn:00001A0E                 mov     ecx, [ebp+arg_0]
.text$mn:00001A11                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00001A16                 add     eax, [ebp+arg_4]
.text$mn:00001A19                 push    eax             ; Src
.text$mn:00001A1A                 mov     ecx, [ebp+var_4]
.text$mn:00001A1D                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00001A22                 push    eax             ; Dst
.text$mn:00001A23                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00001A28                 add     esp, 0Ch
.text$mn:00001A2B                 mov     edx, [ebp+Size]
.text$mn:00001A2E                 push    edx
.text$mn:00001A2F                 mov     ecx, [ebp+var_4]
.text$mn:00001A32                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00001A37
.text$mn:00001A37 loc_1A37:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+5Fj
.text$mn:00001A37                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+74j
.text$mn:00001A37                 mov     eax, [ebp+var_4]
.text$mn:00001A3A                 mov     esp, ebp
.text$mn:00001A3C                 pop     ebp
.text$mn:00001A3D                 retn    0Ch
.text$mn:00001A3D ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z endp
.text$mn:00001A3D
.text$mn:00001A3D _text$mn        ends
.text$mn:00001A3D
.text$mn:00001A40 ; ===========================================================================
.text$mn:00001A40
.text$mn:00001A40 ; Segment type: Pure code
.text$mn:00001A40 ; Segment permissions: Read/Execute
.text$mn:00001A40 _text$mn        segment para public 'CODE' use32
.text$mn:00001A40                 assume cs:_text$mn
.text$mn:00001A40                 ;org 1A40h
.text$mn:00001A40 ; COMDAT (pick any)
.text$mn:00001A40                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001A40
.text$mn:00001A40 ; =============== S U B R O U T I N E =======================================
.text$mn:00001A40
.text$mn:00001A40 ; Attributes: bp-based frame
.text$mn:00001A40
.text$mn:00001A40 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char *Str)
.text$mn:00001A40                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
.text$mn:00001A40 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z proc near
.text$mn:00001A40                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+53p
.text$mn:00001A40
.text$mn:00001A40 var_4           = dword ptr -4
.text$mn:00001A40 Str             = dword ptr  8
.text$mn:00001A40
.text$mn:00001A40                 push    ebp
.text$mn:00001A41                 mov     ebp, esp
.text$mn:00001A43                 push    ecx
.text$mn:00001A44                 mov     [ebp+var_4], ecx
.text$mn:00001A47                 push    490h            ; unsigned int
.text$mn:00001A4C                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00001A51                 mov     eax, [ebp+Str]
.text$mn:00001A54                 push    eax             ; int
.text$mn:00001A55                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:00001A5A                 add     esp, 0Ch
.text$mn:00001A5D                 mov     ecx, [ebp+Str]
.text$mn:00001A60                 push    ecx             ; Str
.text$mn:00001A61                 call    ?length@?$char_traits@D@std@@SAIPBD@Z ; std::char_traits<char>::length(char const *)
.text$mn:00001A66                 add     esp, 4
.text$mn:00001A69                 push    eax             ; Size
.text$mn:00001A6A                 mov     edx, [ebp+Str]
.text$mn:00001A6D                 push    edx             ; Src
.text$mn:00001A6E                 mov     ecx, [ebp+var_4]
.text$mn:00001A71                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)
.text$mn:00001A76                 mov     esp, ebp
.text$mn:00001A78                 pop     ebp
.text$mn:00001A79                 retn    4
.text$mn:00001A79 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z endp
.text$mn:00001A79
.text$mn:00001A79 _text$mn        ends
.text$mn:00001A79
.text$mn:00001A7C ; ===========================================================================
.text$mn:00001A7C
.text$mn:00001A7C ; Segment type: Pure code
.text$mn:00001A7C ; Segment permissions: Read/Execute
.text$mn:00001A7C _text$mn        segment para public 'CODE' use32
.text$mn:00001A7C                 assume cs:_text$mn
.text$mn:00001A7C                 ;org 1A7Ch
.text$mn:00001A7C ; COMDAT (pick any)
.text$mn:00001A7C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001A7C
.text$mn:00001A7C ; =============== S U B R O U T I N E =======================================
.text$mn:00001A7C
.text$mn:00001A7C ; Attributes: bp-based frame
.text$mn:00001A7C
.text$mn:00001A7C ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(void *Src, size_t Size)
.text$mn:00001A7C                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
.text$mn:00001A7C ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z proc near
.text$mn:00001A7C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+31p
.text$mn:00001A7C
.text$mn:00001A7C var_4           = dword ptr -4
.text$mn:00001A7C Src             = dword ptr  8
.text$mn:00001A7C Size            = dword ptr  0Ch
.text$mn:00001A7C
.text$mn:00001A7C                 push    ebp
.text$mn:00001A7D                 mov     ebp, esp
.text$mn:00001A7F                 push    ecx
.text$mn:00001A80                 mov     [ebp+var_4], ecx
.text$mn:00001A83                 cmp     [ebp+Size], 0
.text$mn:00001A87                 jz      short loc_1A9F
.text$mn:00001A89                 push    47Fh            ; unsigned int
.text$mn:00001A8E                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00001A93                 mov     eax, [ebp+Src]
.text$mn:00001A96                 push    eax             ; int
.text$mn:00001A97                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:00001A9C                 add     esp, 0Ch
.text$mn:00001A9F
.text$mn:00001A9F loc_1A9F:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+Bj
.text$mn:00001A9F                 mov     ecx, [ebp+Src]
.text$mn:00001AA2                 push    ecx
.text$mn:00001AA3                 mov     ecx, [ebp+var_4]
.text$mn:00001AA6                 call    ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)
.text$mn:00001AAB                 movzx   edx, al
.text$mn:00001AAE                 test    edx, edx
.text$mn:00001AB0                 jz      short loc_1AD2
.text$mn:00001AB2                 mov     eax, [ebp+Size]
.text$mn:00001AB5                 push    eax
.text$mn:00001AB6                 mov     ecx, [ebp+var_4]
.text$mn:00001AB9                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00001ABE                 mov     ecx, [ebp+Src]
.text$mn:00001AC1                 sub     ecx, eax
.text$mn:00001AC3                 push    ecx
.text$mn:00001AC4                 mov     edx, [ebp+var_4]
.text$mn:00001AC7                 push    edx
.text$mn:00001AC8                 mov     ecx, [ebp+var_4]
.text$mn:00001ACB                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)
.text$mn:00001AD0                 jmp     short loc_1B0F
.text$mn:00001AD2 ; ---------------------------------------------------------------------------
.text$mn:00001AD2
.text$mn:00001AD2 loc_1AD2:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+34j
.text$mn:00001AD2                 push    0
.text$mn:00001AD4                 mov     eax, [ebp+Size]
.text$mn:00001AD7                 push    eax
.text$mn:00001AD8                 mov     ecx, [ebp+var_4]
.text$mn:00001ADB                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:00001AE0                 movzx   ecx, al
.text$mn:00001AE3                 test    ecx, ecx
.text$mn:00001AE5                 jz      short loc_1B0C
.text$mn:00001AE7                 mov     edx, [ebp+Size]
.text$mn:00001AEA                 push    edx             ; Size
.text$mn:00001AEB                 mov     eax, [ebp+Src]
.text$mn:00001AEE                 push    eax             ; Src
.text$mn:00001AEF                 mov     ecx, [ebp+var_4]
.text$mn:00001AF2                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00001AF7                 push    eax             ; Dst
.text$mn:00001AF8                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00001AFD                 add     esp, 0Ch
.text$mn:00001B00                 mov     ecx, [ebp+Size]
.text$mn:00001B03                 push    ecx
.text$mn:00001B04                 mov     ecx, [ebp+var_4]
.text$mn:00001B07                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00001B0C
.text$mn:00001B0C loc_1B0C:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+69j
.text$mn:00001B0C                 mov     eax, [ebp+var_4]
.text$mn:00001B0F
.text$mn:00001B0F loc_1B0F:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+54j
.text$mn:00001B0F                 mov     esp, ebp
.text$mn:00001B11                 pop     ebp
.text$mn:00001B12                 retn    8
.text$mn:00001B12 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z endp
.text$mn:00001B12
.text$mn:00001B12 ; ---------------------------------------------------------------------------
.text$mn:00001B15                 align 4
.text$mn:00001B15 _text$mn        ends
.text$mn:00001B15
.text$mn:00001B18 ; ===========================================================================
.text$mn:00001B18
.text$mn:00001B18 ; Segment type: Pure code
.text$mn:00001B18 ; Segment permissions: Read/Execute
.text$mn:00001B18 _text$mn        segment para public 'CODE' use32
.text$mn:00001B18                 assume cs:_text$mn
.text$mn:00001B18                 ;org 1B18h
.text$mn:00001B18 ; COMDAT (pick any)
.text$mn:00001B18                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001B18
.text$mn:00001B18 ; =============== S U B R O U T I N E =======================================
.text$mn:00001B18
.text$mn:00001B18 ; Attributes: bp-based frame
.text$mn:00001B18
.text$mn:00001B18 ; public: static void __cdecl std::char_traits<char>::assign(char &, char const &)
.text$mn:00001B18                 public ?assign@?$char_traits@D@std@@SAXAADABD@Z
.text$mn:00001B18 ?assign@?$char_traits@D@std@@SAXAADABD@Z proc near
.text$mn:00001B18                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+26p
.text$mn:00001B18
.text$mn:00001B18 arg_0           = dword ptr  8
.text$mn:00001B18 arg_4           = dword ptr  0Ch
.text$mn:00001B18
.text$mn:00001B18                 push    ebp
.text$mn:00001B19                 mov     ebp, esp
.text$mn:00001B1B                 mov     eax, [ebp+arg_0]
.text$mn:00001B1E                 mov     ecx, [ebp+arg_4]
.text$mn:00001B21                 mov     dl, [ecx]
.text$mn:00001B23                 mov     [eax], dl
.text$mn:00001B25                 pop     ebp
.text$mn:00001B26                 retn
.text$mn:00001B26 ?assign@?$char_traits@D@std@@SAXAADABD@Z endp
.text$mn:00001B26
.text$mn:00001B26 ; ---------------------------------------------------------------------------
.text$mn:00001B27                 align 4
.text$mn:00001B27 _text$mn        ends
.text$mn:00001B27
.text$mn:00001B28 ; ===========================================================================
.text$mn:00001B28
.text$mn:00001B28 ; Segment type: Pure code
.text$mn:00001B28 ; Segment permissions: Read/Execute
.text$mn:00001B28 _text$mn        segment para public 'CODE' use32
.text$mn:00001B28                 assume cs:_text$mn
.text$mn:00001B28                 ;org 1B28h
.text$mn:00001B28 ; COMDAT (pick any)
.text$mn:00001B28                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001B28
.text$mn:00001B28 ; =============== S U B R O U T I N E =======================================
.text$mn:00001B28
.text$mn:00001B28 ; Attributes: bp-based frame
.text$mn:00001B28
.text$mn:00001B28 ; const struct std::error_category *__thiscall std::error_code::category(std::error_code *__hidden this)
.text$mn:00001B28                 public ?category@error_code@std@@QBEABVerror_category@2@XZ
.text$mn:00001B28 ?category@error_code@std@@QBEABVerror_category@2@XZ proc near
.text$mn:00001B28                                         ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+Cp
.text$mn:00001B28
.text$mn:00001B28 var_4           = dword ptr -4
.text$mn:00001B28
.text$mn:00001B28                 push    ebp
.text$mn:00001B29                 mov     ebp, esp
.text$mn:00001B2B                 push    ecx
.text$mn:00001B2C                 mov     [ebp+var_4], ecx
.text$mn:00001B2F                 mov     eax, [ebp+var_4]
.text$mn:00001B32                 mov     eax, [eax+4]
.text$mn:00001B35                 mov     esp, ebp
.text$mn:00001B37                 pop     ebp
.text$mn:00001B38                 retn
.text$mn:00001B38 ?category@error_code@std@@QBEABVerror_category@2@XZ endp
.text$mn:00001B38
.text$mn:00001B38 ; ---------------------------------------------------------------------------
.text$mn:00001B39                 align 4
.text$mn:00001B39 _text$mn        ends
.text$mn:00001B39
.text$mn:00001B3C ; ===========================================================================
.text$mn:00001B3C
.text$mn:00001B3C ; Segment type: Pure code
.text$mn:00001B3C ; Segment permissions: Read/Execute
.text$mn:00001B3C _text$mn        segment para public 'CODE' use32
.text$mn:00001B3C                 assume cs:_text$mn
.text$mn:00001B3C                 ;org 1B3Ch
.text$mn:00001B3C ; COMDAT (pick any)
.text$mn:00001B3C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001B3C
.text$mn:00001B3C ; =============== S U B R O U T I N E =======================================
.text$mn:00001B3C
.text$mn:00001B3C ; Attributes: bp-based frame
.text$mn:00001B3C
.text$mn:00001B3C ; const struct std::error_category *__thiscall std::error_condition::category(std::error_condition *__hidden this)
.text$mn:00001B3C                 public ?category@error_condition@std@@QBEABVerror_category@2@XZ
.text$mn:00001B3C ?category@error_condition@std@@QBEABVerror_category@2@XZ proc near
.text$mn:00001B3C                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+Dp
.text$mn:00001B3C                                         ; std::error_condition::operator==(std::error_condition const &)+16p
.text$mn:00001B3C
.text$mn:00001B3C var_4           = dword ptr -4
.text$mn:00001B3C
.text$mn:00001B3C                 push    ebp
.text$mn:00001B3D                 mov     ebp, esp
.text$mn:00001B3F                 push    ecx
.text$mn:00001B40                 mov     [ebp+var_4], ecx
.text$mn:00001B43                 mov     eax, [ebp+var_4]
.text$mn:00001B46                 mov     eax, [eax+4]
.text$mn:00001B49                 mov     esp, ebp
.text$mn:00001B4B                 pop     ebp
.text$mn:00001B4C                 retn
.text$mn:00001B4C ?category@error_condition@std@@QBEABVerror_category@2@XZ endp
.text$mn:00001B4C
.text$mn:00001B4C ; ---------------------------------------------------------------------------
.text$mn:00001B4D                 align 10h
.text$mn:00001B4D _text$mn        ends
.text$mn:00001B4D
.text$mn:00001B50 ; ===========================================================================
.text$mn:00001B50
.text$mn:00001B50 ; Segment type: Pure code
.text$mn:00001B50 ; Segment permissions: Read/Execute
.text$mn:00001B50 _text$mn        segment para public 'CODE' use32
.text$mn:00001B50                 assume cs:_text$mn
.text$mn:00001B50                 ;org 1B50h
.text$mn:00001B50 ; COMDAT (pick any)
.text$mn:00001B50                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001B50
.text$mn:00001B50 ; =============== S U B R O U T I N E =======================================
.text$mn:00001B50
.text$mn:00001B50 ; Attributes: bp-based frame
.text$mn:00001B50
.text$mn:00001B50 ; int __cdecl std::char_traits<char>::copy(void *Dst, void *Src, size_t Size)
.text$mn:00001B50                 public ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
.text$mn:00001B50 ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z proc near ; CODE XREF: $LN19+1Ep
.text$mn:00001B50                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+5Dp ...
.text$mn:00001B50
.text$mn:00001B50 var_4           = dword ptr -4
.text$mn:00001B50 Dst             = dword ptr  8
.text$mn:00001B50 Src             = dword ptr  0Ch
.text$mn:00001B50 Size            = dword ptr  10h
.text$mn:00001B50
.text$mn:00001B50                 push    ebp
.text$mn:00001B51                 mov     ebp, esp
.text$mn:00001B53                 push    ecx
.text$mn:00001B54                 cmp     [ebp+Size], 0
.text$mn:00001B58                 jnz     short loc_1B62
.text$mn:00001B5A                 mov     eax, [ebp+Dst]
.text$mn:00001B5D                 mov     [ebp+var_4], eax
.text$mn:00001B60                 jmp     short loc_1B79
.text$mn:00001B62 ; ---------------------------------------------------------------------------
.text$mn:00001B62
.text$mn:00001B62 loc_1B62:                               ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+8j
.text$mn:00001B62                 mov     ecx, [ebp+Size]
.text$mn:00001B65                 push    ecx             ; Size
.text$mn:00001B66                 mov     edx, [ebp+Src]
.text$mn:00001B69                 push    edx             ; Src
.text$mn:00001B6A                 mov     eax, [ebp+Dst]
.text$mn:00001B6D                 push    eax             ; Dst
.text$mn:00001B6E                 call    _memcpy
.text$mn:00001B73                 add     esp, 0Ch
.text$mn:00001B76                 mov     [ebp+var_4], eax
.text$mn:00001B79
.text$mn:00001B79 loc_1B79:                               ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+10j
.text$mn:00001B79                 mov     eax, [ebp+var_4]
.text$mn:00001B7C                 mov     esp, ebp
.text$mn:00001B7E                 pop     ebp
.text$mn:00001B7F                 retn
.text$mn:00001B7F ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z endp
.text$mn:00001B7F
.text$mn:00001B7F _text$mn        ends
.text$mn:00001B7F
.text$mn:00001B80 ; ===========================================================================
.text$mn:00001B80
.text$mn:00001B80 ; Segment type: Pure code
.text$mn:00001B80 ; Segment permissions: Read/Execute
.text$mn:00001B80 _text$mn        segment para public 'CODE' use32
.text$mn:00001B80                 assume cs:_text$mn
.text$mn:00001B80                 ;org 1B80h
.text$mn:00001B80 ; COMDAT (pick any)
.text$mn:00001B80                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001B80
.text$mn:00001B80 ; =============== S U B R O U T I N E =======================================
.text$mn:00001B80
.text$mn:00001B80 ; Attributes: bp-based frame
.text$mn:00001B80
.text$mn:00001B80 ; int __stdcall std::_Wrap_alloc<std::allocator<char>>::deallocate(void *, int)
.text$mn:00001B80                 public ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
.text$mn:00001B80 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z proc near
.text$mn:00001B80                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+81p
.text$mn:00001B80
.text$mn:00001B80 var_4           = dword ptr -4
.text$mn:00001B80 arg_0           = dword ptr  8
.text$mn:00001B80 arg_4           = dword ptr  0Ch
.text$mn:00001B80
.text$mn:00001B80                 push    ebp
.text$mn:00001B81                 mov     ebp, esp
.text$mn:00001B83                 push    ecx
.text$mn:00001B84                 mov     [ebp+var_4], ecx
.text$mn:00001B87                 mov     eax, [ebp+arg_4]
.text$mn:00001B8A                 push    eax             ; int
.text$mn:00001B8B                 mov     ecx, [ebp+arg_0]
.text$mn:00001B8E                 push    ecx             ; void *
.text$mn:00001B8F                 mov     ecx, [ebp+var_4]
.text$mn:00001B92                 call    ?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate(char *,uint)
.text$mn:00001B97                 mov     esp, ebp
.text$mn:00001B99                 pop     ebp
.text$mn:00001B9A                 retn    8
.text$mn:00001B9A ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z endp
.text$mn:00001B9A
.text$mn:00001B9A ; ---------------------------------------------------------------------------
.text$mn:00001B9D                 align 10h
.text$mn:00001B9D _text$mn        ends
.text$mn:00001B9D
.text$mn:00001BA0 ; ===========================================================================
.text$mn:00001BA0
.text$mn:00001BA0 ; Segment type: Pure code
.text$mn:00001BA0 ; Segment permissions: Read/Execute
.text$mn:00001BA0 _text$mn        segment para public 'CODE' use32
.text$mn:00001BA0                 assume cs:_text$mn
.text$mn:00001BA0                 ;org 1BA0h
.text$mn:00001BA0 ; COMDAT (pick any)
.text$mn:00001BA0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001BA0
.text$mn:00001BA0 ; =============== S U B R O U T I N E =======================================
.text$mn:00001BA0
.text$mn:00001BA0 ; Attributes: bp-based frame
.text$mn:00001BA0
.text$mn:00001BA0 ; int __stdcall std::allocator<char>::deallocate(void *, int)
.text$mn:00001BA0                 public ?deallocate@?$allocator@D@std@@QAEXPADI@Z
.text$mn:00001BA0 ?deallocate@?$allocator@D@std@@QAEXPADI@Z proc near
.text$mn:00001BA0                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)+12p
.text$mn:00001BA0
.text$mn:00001BA0 var_4           = dword ptr -4
.text$mn:00001BA0 arg_0           = dword ptr  8
.text$mn:00001BA0
.text$mn:00001BA0                 push    ebp
.text$mn:00001BA1                 mov     ebp, esp
.text$mn:00001BA3                 push    ecx
.text$mn:00001BA4                 mov     [ebp+var_4], ecx
.text$mn:00001BA7                 mov     eax, [ebp+arg_0]
.text$mn:00001BAA                 push    eax             ; void *
.text$mn:00001BAB                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00001BB0                 add     esp, 4
.text$mn:00001BB3                 mov     esp, ebp
.text$mn:00001BB5                 pop     ebp
.text$mn:00001BB6                 retn    8
.text$mn:00001BB6 ?deallocate@?$allocator@D@std@@QAEXPADI@Z endp
.text$mn:00001BB6
.text$mn:00001BB6 ; ---------------------------------------------------------------------------
.text$mn:00001BB9                 align 4
.text$mn:00001BB9 _text$mn        ends
.text$mn:00001BB9
.text$mn:00001BBC ; ===========================================================================
.text$mn:00001BBC
.text$mn:00001BBC ; Segment type: Pure code
.text$mn:00001BBC ; Segment permissions: Read/Execute
.text$mn:00001BBC _text$mn        segment para public 'CODE' use32
.text$mn:00001BBC                 assume cs:_text$mn
.text$mn:00001BBC                 ;org 1BBCh
.text$mn:00001BBC ; COMDAT (pick any)
.text$mn:00001BBC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001BBC
.text$mn:00001BBC ; =============== S U B R O U T I N E =======================================
.text$mn:00001BBC
.text$mn:00001BBC ; Attributes: bp-based frame
.text$mn:00001BBC
.text$mn:00001BBC ; int __stdcall std::allocator<std::_Container_proxy>::deallocate(void *, int)
.text$mn:00001BBC                 public ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z
.text$mn:00001BBC ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z proc near
.text$mn:00001BBC                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+32p
.text$mn:00001BBC
.text$mn:00001BBC var_4           = dword ptr -4
.text$mn:00001BBC arg_0           = dword ptr  8
.text$mn:00001BBC
.text$mn:00001BBC                 push    ebp
.text$mn:00001BBD                 mov     ebp, esp
.text$mn:00001BBF                 push    ecx
.text$mn:00001BC0                 mov     [ebp+var_4], ecx
.text$mn:00001BC3                 mov     eax, [ebp+arg_0]
.text$mn:00001BC6                 push    eax             ; void *
.text$mn:00001BC7                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00001BCC                 add     esp, 4
.text$mn:00001BCF                 mov     esp, ebp
.text$mn:00001BD1                 pop     ebp
.text$mn:00001BD2                 retn    8
.text$mn:00001BD2 ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z endp
.text$mn:00001BD2
.text$mn:00001BD2 ; ---------------------------------------------------------------------------
.text$mn:00001BD5                 align 4
.text$mn:00001BD5 _text$mn        ends
.text$mn:00001BD5
.text$mn:00001BD8 ; ===========================================================================
.text$mn:00001BD8
.text$mn:00001BD8 ; Segment type: Pure code
.text$mn:00001BD8 ; Segment permissions: Read/Execute
.text$mn:00001BD8 _text$mn        segment para public 'CODE' use32
.text$mn:00001BD8                 assume cs:_text$mn
.text$mn:00001BD8                 ;org 1BD8h
.text$mn:00001BD8 ; COMDAT (pick any)
.text$mn:00001BD8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001BD8
.text$mn:00001BD8 ; =============== S U B R O U T I N E =======================================
.text$mn:00001BD8
.text$mn:00001BD8 ; Attributes: bp-based frame
.text$mn:00001BD8
.text$mn:00001BD8 ; public: virtual class std::error_condition __thiscall std::_System_error_category::default_error_condition(int)const
.text$mn:00001BD8                 public ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
.text$mn:00001BD8 ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z proc near
.text$mn:00001BD8                                         ; DATA XREF: .rdata:000026A8o
.text$mn:00001BD8
.text$mn:00001BD8 var_4           = dword ptr -4
.text$mn:00001BD8 arg_0           = dword ptr  8
.text$mn:00001BD8 arg_4           = dword ptr  0Ch
.text$mn:00001BD8
.text$mn:00001BD8                 push    ebp
.text$mn:00001BD9                 mov     ebp, esp
.text$mn:00001BDB                 push    ecx
.text$mn:00001BDC                 mov     [ebp+var_4], ecx
.text$mn:00001BDF                 mov     eax, [ebp+arg_4]
.text$mn:00001BE2                 push    eax             ; int
.text$mn:00001BE3                 call    ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map(int)
.text$mn:00001BE8                 add     esp, 4
.text$mn:00001BEB                 test    eax, eax
.text$mn:00001BED                 jz      short loc_1C08
.text$mn:00001BEF                 call    ?generic_category@std@@YAABVerror_category@1@XZ ; std::generic_category(void)
.text$mn:00001BF4                 push    eax             ; struct std::error_category *
.text$mn:00001BF5                 mov     ecx, [ebp+arg_4]
.text$mn:00001BF8                 push    ecx             ; int
.text$mn:00001BF9                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00001BFC                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:00001C01                 mov     eax, [ebp+arg_0]
.text$mn:00001C04                 jmp     short loc_1C1D
.text$mn:00001C06 ; ---------------------------------------------------------------------------
.text$mn:00001C06                 jmp     short loc_1C1D
.text$mn:00001C08 ; ---------------------------------------------------------------------------
.text$mn:00001C08
.text$mn:00001C08 loc_1C08:                               ; CODE XREF: std::_System_error_category::default_error_condition(int)+15j
.text$mn:00001C08                 call    ?system_category@std@@YAABVerror_category@1@XZ ; std::system_category(void)
.text$mn:00001C0D                 push    eax             ; struct std::error_category *
.text$mn:00001C0E                 mov     edx, [ebp+arg_4]
.text$mn:00001C11                 push    edx             ; int
.text$mn:00001C12                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00001C15                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:00001C1A                 mov     eax, [ebp+arg_0]
.text$mn:00001C1D
.text$mn:00001C1D loc_1C1D:                               ; CODE XREF: std::_System_error_category::default_error_condition(int)+2Cj
.text$mn:00001C1D                                         ; std::_System_error_category::default_error_condition(int)+2Ej
.text$mn:00001C1D                 mov     esp, ebp
.text$mn:00001C1F                 pop     ebp
.text$mn:00001C20                 retn    8
.text$mn:00001C20 ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z endp
.text$mn:00001C20
.text$mn:00001C20 ; ---------------------------------------------------------------------------
.text$mn:00001C23                 align 4
.text$mn:00001C23 _text$mn        ends
.text$mn:00001C23
.text$mn:00001C24 ; ===========================================================================
.text$mn:00001C24
.text$mn:00001C24 ; Segment type: Pure code
.text$mn:00001C24 ; Segment permissions: Read/Execute
.text$mn:00001C24 _text$mn        segment para public 'CODE' use32
.text$mn:00001C24                 assume cs:_text$mn
.text$mn:00001C24                 ;org 1C24h
.text$mn:00001C24 ; COMDAT (pick any)
.text$mn:00001C24                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001C24
.text$mn:00001C24 ; =============== S U B R O U T I N E =======================================
.text$mn:00001C24
.text$mn:00001C24 ; Attributes: bp-based frame
.text$mn:00001C24
.text$mn:00001C24 ; public: virtual class std::error_condition __thiscall std::error_category::default_error_condition(int)const
.text$mn:00001C24                 public ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
.text$mn:00001C24 ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z proc near
.text$mn:00001C24                                         ; DATA XREF: .rdata:00002618o
.text$mn:00001C24                                         ; .rdata:00002634o ...
.text$mn:00001C24
.text$mn:00001C24 var_4           = dword ptr -4
.text$mn:00001C24 arg_0           = dword ptr  8
.text$mn:00001C24 arg_4           = dword ptr  0Ch
.text$mn:00001C24
.text$mn:00001C24                 push    ebp
.text$mn:00001C25                 mov     ebp, esp
.text$mn:00001C27                 push    ecx
.text$mn:00001C28                 mov     [ebp+var_4], ecx
.text$mn:00001C2B                 mov     eax, [ebp+var_4]
.text$mn:00001C2E                 push    eax             ; struct std::error_category *
.text$mn:00001C2F                 mov     ecx, [ebp+arg_4]
.text$mn:00001C32                 push    ecx             ; int
.text$mn:00001C33                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00001C36                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:00001C3B                 mov     eax, [ebp+arg_0]
.text$mn:00001C3E                 mov     esp, ebp
.text$mn:00001C40                 pop     ebp
.text$mn:00001C41                 retn    8
.text$mn:00001C41 ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z endp
.text$mn:00001C41
.text$mn:00001C41 _text$mn        ends
.text$mn:00001C41
.text$mn:00001C44 ; ===========================================================================
.text$mn:00001C44
.text$mn:00001C44 ; Segment type: Pure code
.text$mn:00001C44 ; Segment permissions: Read/Execute
.text$mn:00001C44 _text$mn        segment para public 'CODE' use32
.text$mn:00001C44                 assume cs:_text$mn
.text$mn:00001C44                 ;org 1C44h
.text$mn:00001C44 ; COMDAT (pick any)
.text$mn:00001C44                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001C44
.text$mn:00001C44 ; =============== S U B R O U T I N E =======================================
.text$mn:00001C44
.text$mn:00001C44 ; Attributes: bp-based frame
.text$mn:00001C44
.text$mn:00001C44 ; bool __thiscall std::error_category::equivalent(std::error_category *this, const struct std::error_code *, int)
.text$mn:00001C44                 public ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
.text$mn:00001C44 ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z proc near
.text$mn:00001C44                                         ; DATA XREF: .rdata:0000261Co
.text$mn:00001C44                                         ; .rdata:00002638o ...
.text$mn:00001C44
.text$mn:00001C44 var_8           = dword ptr -8
.text$mn:00001C44 var_4           = dword ptr -4
.text$mn:00001C44 arg_0           = dword ptr  8
.text$mn:00001C44 arg_4           = dword ptr  0Ch
.text$mn:00001C44
.text$mn:00001C44                 push    ebp
.text$mn:00001C45                 mov     ebp, esp
.text$mn:00001C47                 sub     esp, 8
.text$mn:00001C4A                 mov     [ebp+var_8], ecx
.text$mn:00001C4D                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00001C50                 call    ?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category(void)
.text$mn:00001C55                 push    eax
.text$mn:00001C56                 mov     ecx, [ebp+var_8]
.text$mn:00001C59                 call    ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
.text$mn:00001C5E                 movzx   eax, al
.text$mn:00001C61                 test    eax, eax
.text$mn:00001C63                 jz      short loc_1C7B
.text$mn:00001C65                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00001C68                 call    ?value@error_code@std@@QBEHXZ ; std::error_code::value(void)
.text$mn:00001C6D                 cmp     eax, [ebp+arg_4]
.text$mn:00001C70                 jnz     short loc_1C7B
.text$mn:00001C72                 mov     [ebp+var_4], 1
.text$mn:00001C79                 jmp     short loc_1C82
.text$mn:00001C7B ; ---------------------------------------------------------------------------
.text$mn:00001C7B
.text$mn:00001C7B loc_1C7B:                               ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+1Fj
.text$mn:00001C7B                                         ; std::error_category::equivalent(std::error_code const &,int)+2Cj
.text$mn:00001C7B                 mov     [ebp+var_4], 0
.text$mn:00001C82
.text$mn:00001C82 loc_1C82:                               ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+35j
.text$mn:00001C82                 mov     al, byte ptr [ebp+var_4]
.text$mn:00001C85                 mov     esp, ebp
.text$mn:00001C87                 pop     ebp
.text$mn:00001C88                 retn    8
.text$mn:00001C88 ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z endp
.text$mn:00001C88
.text$mn:00001C88 ; ---------------------------------------------------------------------------
.text$mn:00001C8B                 align 4
.text$mn:00001C8B _text$mn        ends
.text$mn:00001C8B
.text$mn:00001C8C ; ===========================================================================
.text$mn:00001C8C
.text$mn:00001C8C ; Segment type: Pure code
.text$mn:00001C8C ; Segment permissions: Read/Execute
.text$mn:00001C8C _text$mn        segment para public 'CODE' use32
.text$mn:00001C8C                 assume cs:_text$mn
.text$mn:00001C8C                 ;org 1C8Ch
.text$mn:00001C8C ; COMDAT (pick any)
.text$mn:00001C8C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001C8C
.text$mn:00001C8C ; =============== S U B R O U T I N E =======================================
.text$mn:00001C8C
.text$mn:00001C8C ; Attributes: bp-based frame
.text$mn:00001C8C
.text$mn:00001C8C ; bool __thiscall std::error_category::equivalent(std::error_category *this, int, const struct std::error_condition *)
.text$mn:00001C8C                 public ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
.text$mn:00001C8C ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z proc near
.text$mn:00001C8C                                         ; DATA XREF: .rdata:00002620o
.text$mn:00001C8C                                         ; .rdata:0000263Co ...
.text$mn:00001C8C
.text$mn:00001C8C var_C           = byte ptr -0Ch
.text$mn:00001C8C var_4           = dword ptr -4
.text$mn:00001C8C arg_0           = dword ptr  8
.text$mn:00001C8C arg_4           = dword ptr  0Ch
.text$mn:00001C8C
.text$mn:00001C8C                 push    ebp
.text$mn:00001C8D                 mov     ebp, esp
.text$mn:00001C8F                 sub     esp, 0Ch
.text$mn:00001C92                 mov     [ebp+var_4], ecx
.text$mn:00001C95                 mov     eax, [ebp+arg_4]
.text$mn:00001C98                 push    eax             ; std::error_condition *
.text$mn:00001C99                 mov     ecx, [ebp+arg_0]
.text$mn:00001C9C                 push    ecx
.text$mn:00001C9D                 lea     edx, [ebp+var_C]
.text$mn:00001CA0                 push    edx
.text$mn:00001CA1                 mov     eax, [ebp+var_4]
.text$mn:00001CA4                 mov     edx, [eax]
.text$mn:00001CA6                 mov     ecx, [ebp+var_4]
.text$mn:00001CA9                 mov     eax, [edx+0Ch]
.text$mn:00001CAC                 call    eax
.text$mn:00001CAE                 mov     ecx, eax
.text$mn:00001CB0                 call    ??8error_condition@std@@QBE_NABV01@@Z ; std::error_condition::operator==(std::error_condition const &)
.text$mn:00001CB5                 mov     esp, ebp
.text$mn:00001CB7                 pop     ebp
.text$mn:00001CB8                 retn    8
.text$mn:00001CB8 ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z endp
.text$mn:00001CB8
.text$mn:00001CB8 ; ---------------------------------------------------------------------------
.text$mn:00001CBB                 align 4
.text$mn:00001CBB _text$mn        ends
.text$mn:00001CBB
.text$mn:00001CBC ; ===========================================================================
.text$mn:00001CBC
.text$mn:00001CBC ; Segment type: Pure code
.text$mn:00001CBC ; Segment permissions: Read/Execute
.text$mn:00001CBC _text$mn        segment para public 'CODE' use32
.text$mn:00001CBC                 assume cs:_text$mn
.text$mn:00001CBC                 ;org 1CBCh
.text$mn:00001CBC ; COMDAT (pick any)
.text$mn:00001CBC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001CBC
.text$mn:00001CBC ; =============== S U B R O U T I N E =======================================
.text$mn:00001CBC
.text$mn:00001CBC ; Attributes: bp-based frame
.text$mn:00001CBC
.text$mn:00001CBC ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int)
.text$mn:00001CBC                 public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
.text$mn:00001CBC ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z proc near
.text$mn:00001CBC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+4Cp
.text$mn:00001CBC
.text$mn:00001CBC var_4           = dword ptr -4
.text$mn:00001CBC arg_0           = dword ptr  8
.text$mn:00001CBC
.text$mn:00001CBC                 push    ebp
.text$mn:00001CBD                 mov     ebp, esp
.text$mn:00001CBF                 push    ecx
.text$mn:00001CC0                 mov     [ebp+var_4], ecx
.text$mn:00001CC3                 mov     eax, [ebp+var_4]
.text$mn:00001CC6                 mov     ecx, [eax+14h]
.text$mn:00001CC9                 cmp     ecx, [ebp+arg_0]
.text$mn:00001CCC                 jnb     short loc_1CD6
.text$mn:00001CCE                 mov     ecx, [ebp+var_4]
.text$mn:00001CD1                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:00001CD6
.text$mn:00001CD6 loc_1CD6:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)+10j
.text$mn:00001CD6                 mov     edx, [ebp+arg_0]
.text$mn:00001CD9                 push    edx
.text$mn:00001CDA                 mov     ecx, [ebp+var_4]
.text$mn:00001CDD                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00001CE2                 mov     eax, [ebp+var_4]
.text$mn:00001CE5                 mov     esp, ebp
.text$mn:00001CE7                 pop     ebp
.text$mn:00001CE8                 retn    4
.text$mn:00001CE8 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z endp
.text$mn:00001CE8
.text$mn:00001CE8 ; ---------------------------------------------------------------------------
.text$mn:00001CEB                 align 4
.text$mn:00001CEB _text$mn        ends
.text$mn:00001CEB
.text$mn:00001CEC ; ===========================================================================
.text$mn:00001CEC
.text$mn:00001CEC ; Segment type: Pure code
.text$mn:00001CEC ; Segment permissions: Read/Execute
.text$mn:00001CEC _text$mn        segment para public 'CODE' use32
.text$mn:00001CEC                 assume cs:_text$mn
.text$mn:00001CEC                 ;org 1CECh
.text$mn:00001CEC ; COMDAT (pick any)
.text$mn:00001CEC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001CEC
.text$mn:00001CEC ; =============== S U B R O U T I N E =======================================
.text$mn:00001CEC
.text$mn:00001CEC ; Attributes: bp-based frame
.text$mn:00001CEC
.text$mn:00001CEC ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int, unsigned int)
.text$mn:00001CEC                 public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
.text$mn:00001CEC ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z proc near
.text$mn:00001CEC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+5Ap
.text$mn:00001CEC
.text$mn:00001CEC var_C           = dword ptr -0Ch
.text$mn:00001CEC Dst             = dword ptr -8
.text$mn:00001CEC var_4           = dword ptr -4
.text$mn:00001CEC arg_0           = dword ptr  8
.text$mn:00001CEC arg_4           = dword ptr  0Ch
.text$mn:00001CEC
.text$mn:00001CEC                 push    ebp
.text$mn:00001CED                 mov     ebp, esp
.text$mn:00001CEF                 sub     esp, 0Ch
.text$mn:00001CF2                 mov     [ebp+var_4], ecx
.text$mn:00001CF5                 mov     eax, [ebp+var_4]
.text$mn:00001CF8                 mov     ecx, [eax+14h]
.text$mn:00001CFB                 cmp     ecx, [ebp+arg_0]
.text$mn:00001CFE                 jnb     short loc_1D08
.text$mn:00001D00                 mov     ecx, [ebp+var_4]
.text$mn:00001D03                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:00001D08
.text$mn:00001D08 loc_1D08:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+12j
.text$mn:00001D08                 mov     edx, [ebp+var_4]
.text$mn:00001D0B                 mov     eax, [edx+14h]
.text$mn:00001D0E                 sub     eax, [ebp+arg_0]
.text$mn:00001D11                 cmp     eax, [ebp+arg_4]
.text$mn:00001D14                 ja      short loc_1D24
.text$mn:00001D16                 mov     ecx, [ebp+arg_0]
.text$mn:00001D19                 push    ecx
.text$mn:00001D1A                 mov     ecx, [ebp+var_4]
.text$mn:00001D1D                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00001D22                 jmp     short loc_1D6A
.text$mn:00001D24 ; ---------------------------------------------------------------------------
.text$mn:00001D24
.text$mn:00001D24 loc_1D24:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+28j
.text$mn:00001D24                 cmp     [ebp+arg_4], 0
.text$mn:00001D28                 jbe     short loc_1D6A
.text$mn:00001D2A                 mov     ecx, [ebp+var_4]
.text$mn:00001D2D                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00001D32                 add     eax, [ebp+arg_0]
.text$mn:00001D35                 mov     [ebp+Dst], eax
.text$mn:00001D38                 mov     edx, [ebp+var_4]
.text$mn:00001D3B                 mov     eax, [edx+14h]
.text$mn:00001D3E                 sub     eax, [ebp+arg_4]
.text$mn:00001D41                 mov     [ebp+var_C], eax
.text$mn:00001D44                 mov     ecx, [ebp+var_C]
.text$mn:00001D47                 sub     ecx, [ebp+arg_0]
.text$mn:00001D4A                 push    ecx             ; Size
.text$mn:00001D4B                 mov     edx, [ebp+Dst]
.text$mn:00001D4E                 add     edx, [ebp+arg_4]
.text$mn:00001D51                 push    edx             ; Src
.text$mn:00001D52                 mov     eax, [ebp+Dst]
.text$mn:00001D55                 push    eax             ; Dst
.text$mn:00001D56                 call    ?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move(char *,char const *,uint)
.text$mn:00001D5B                 add     esp, 0Ch
.text$mn:00001D5E                 mov     ecx, [ebp+var_C]
.text$mn:00001D61                 push    ecx
.text$mn:00001D62                 mov     ecx, [ebp+var_4]
.text$mn:00001D65                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00001D6A
.text$mn:00001D6A loc_1D6A:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+36j
.text$mn:00001D6A                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+3Cj
.text$mn:00001D6A                 mov     eax, [ebp+var_4]
.text$mn:00001D6D                 mov     esp, ebp
.text$mn:00001D6F                 pop     ebp
.text$mn:00001D70                 retn    8
.text$mn:00001D70 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z endp
.text$mn:00001D70
.text$mn:00001D70 ; ---------------------------------------------------------------------------
.text$mn:00001D73                 align 4
.text$mn:00001D73 _text$mn        ends
.text$mn:00001D73
.text$mn:00001D74 ; ===========================================================================
.text$mn:00001D74
.text$mn:00001D74 ; Segment type: Pure code
.text$mn:00001D74 ; Segment permissions: Read/Execute
.text$mn:00001D74 _text$mn        segment para public 'CODE' use32
.text$mn:00001D74                 assume cs:_text$mn
.text$mn:00001D74                 ;org 1D74h
.text$mn:00001D74 ; COMDAT (pick any)
.text$mn:00001D74                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001D74
.text$mn:00001D74 ; =============== S U B R O U T I N E =======================================
.text$mn:00001D74
.text$mn:00001D74 ; Attributes: bp-based frame
.text$mn:00001D74
.text$mn:00001D74 ; const struct std::error_category *__cdecl std::generic_category()
.text$mn:00001D74                 public ?generic_category@std@@YAABVerror_category@1@XZ
.text$mn:00001D74 ?generic_category@std@@YAABVerror_category@1@XZ proc near
.text$mn:00001D74                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+17p
.text$mn:00001D74                 push    ebp
.text$mn:00001D75                 mov     ebp, esp
.text$mn:00001D77                 mov     eax, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
.text$mn:00001D7C                 pop     ebp
.text$mn:00001D7D                 retn
.text$mn:00001D7D ?generic_category@std@@YAABVerror_category@1@XZ endp
.text$mn:00001D7D
.text$mn:00001D7D ; ---------------------------------------------------------------------------
.text$mn:00001D7E                 align 10h
.text$mn:00001D7E _text$mn        ends
.text$mn:00001D7E
.text$mn:00001D80 ; ===========================================================================
.text$mn:00001D80
.text$mn:00001D80 ; Segment type: Pure code
.text$mn:00001D80 ; Segment permissions: Read/Execute
.text$mn:00001D80 _text$mn        segment para public 'CODE' use32
.text$mn:00001D80                 assume cs:_text$mn
.text$mn:00001D80                 ;org 1D80h
.text$mn:00001D80 ; COMDAT (pick any)
.text$mn:00001D80                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001D80
.text$mn:00001D80 ; =============== S U B R O U T I N E =======================================
.text$mn:00001D80
.text$mn:00001D80 ; Attributes: bp-based frame
.text$mn:00001D80
.text$mn:00001D80 ; void __thiscall Window::init(Window *this, HINSTANCE, HWND)
.text$mn:00001D80                 public ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z
.text$mn:00001D80 ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z proc near
.text$mn:00001D80                                         ; CODE XREF: DockingSplitter::init(HINSTANCE__ *,HWND__ *,HWND__ *,uint)+14p
.text$mn:00001D80
.text$mn:00001D80 var_4           = dword ptr -4
.text$mn:00001D80 arg_0           = dword ptr  8
.text$mn:00001D80 arg_4           = dword ptr  0Ch
.text$mn:00001D80
.text$mn:00001D80                 push    ebp
.text$mn:00001D81                 mov     ebp, esp
.text$mn:00001D83                 push    ecx
.text$mn:00001D84                 mov     [ebp+var_4], ecx
.text$mn:00001D87                 mov     eax, [ebp+var_4]
.text$mn:00001D8A                 mov     ecx, [ebp+arg_0]
.text$mn:00001D8D                 mov     [eax+4], ecx
.text$mn:00001D90                 mov     edx, [ebp+var_4]
.text$mn:00001D93                 mov     eax, [ebp+arg_4]
.text$mn:00001D96                 mov     [edx+8], eax
.text$mn:00001D99                 mov     esp, ebp
.text$mn:00001D9B                 pop     ebp
.text$mn:00001D9C                 retn    8
.text$mn:00001D9C ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z endp
.text$mn:00001D9C
.text$mn:00001D9C ; ---------------------------------------------------------------------------
.text$mn:00001D9F                 align 10h
.text$mn:00001D9F _text$mn        ends
.text$mn:00001D9F
.text$mn:00001DA0 ; ===========================================================================
.text$mn:00001DA0
.text$mn:00001DA0 ; Segment type: Pure code
.text$mn:00001DA0 ; Segment permissions: Read/Execute
.text$mn:00001DA0 _text$mn        segment para public 'CODE' use32
.text$mn:00001DA0                 assume cs:_text$mn
.text$mn:00001DA0                 ;org 1DA0h
.text$mn:00001DA0 ; COMDAT (pick any)
.text$mn:00001DA0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001DA0
.text$mn:00001DA0 ; =============== S U B R O U T I N E =======================================
.text$mn:00001DA0
.text$mn:00001DA0 ; Attributes: bp-based frame
.text$mn:00001DA0
.text$mn:00001DA0 ; int __cdecl std::char_traits<char>::length(char *Str)
.text$mn:00001DA0                 public ?length@?$char_traits@D@std@@SAIPBD@Z
.text$mn:00001DA0 ?length@?$char_traits@D@std@@SAIPBD@Z proc near
.text$mn:00001DA0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+21p
.text$mn:00001DA0
.text$mn:00001DA0 var_4           = dword ptr -4
.text$mn:00001DA0 Str             = dword ptr  8
.text$mn:00001DA0
.text$mn:00001DA0                 push    ebp
.text$mn:00001DA1                 mov     ebp, esp
.text$mn:00001DA3                 push    ecx
.text$mn:00001DA4                 mov     eax, [ebp+Str]
.text$mn:00001DA7                 movsx   ecx, byte ptr [eax]
.text$mn:00001DAA                 test    ecx, ecx
.text$mn:00001DAC                 jnz     short loc_1DB7
.text$mn:00001DAE                 mov     [ebp+var_4], 0
.text$mn:00001DB5                 jmp     short loc_1DC6
.text$mn:00001DB7 ; ---------------------------------------------------------------------------
.text$mn:00001DB7
.text$mn:00001DB7 loc_1DB7:                               ; CODE XREF: std::char_traits<char>::length(char const *)+Cj
.text$mn:00001DB7                 mov     edx, [ebp+Str]
.text$mn:00001DBA                 push    edx             ; Str
.text$mn:00001DBB                 call    _strlen
.text$mn:00001DC0                 add     esp, 4
.text$mn:00001DC3                 mov     [ebp+var_4], eax
.text$mn:00001DC6
.text$mn:00001DC6 loc_1DC6:                               ; CODE XREF: std::char_traits<char>::length(char const *)+15j
.text$mn:00001DC6                 mov     eax, [ebp+var_4]
.text$mn:00001DC9                 mov     esp, ebp
.text$mn:00001DCB                 pop     ebp
.text$mn:00001DCC                 retn
.text$mn:00001DCC ?length@?$char_traits@D@std@@SAIPBD@Z endp
.text$mn:00001DCC
.text$mn:00001DCC ; ---------------------------------------------------------------------------
.text$mn:00001DCD                 align 10h
.text$mn:00001DCD _text$mn        ends
.text$mn:00001DCD
.text$mn:00001DD0 ; ===========================================================================
.text$mn:00001DD0
.text$mn:00001DD0 ; Segment type: Pure code
.text$mn:00001DD0 ; Segment permissions: Read/Execute
.text$mn:00001DD0 _text$mn        segment para public 'CODE' use32
.text$mn:00001DD0                 assume cs:_text$mn
.text$mn:00001DD0                 ;org 1DD0h
.text$mn:00001DD0 ; COMDAT (pick any)
.text$mn:00001DD0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001DD0
.text$mn:00001DD0 ; =============== S U B R O U T I N E =======================================
.text$mn:00001DD0
.text$mn:00001DD0 ; Attributes: bp-based frame
.text$mn:00001DD0
.text$mn:00001DD0 ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<char>>::max_size(void)const
.text$mn:00001DD0                 public ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
.text$mn:00001DD0 ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ proc near
.text$mn:00001DD0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+17p
.text$mn:00001DD0
.text$mn:00001DD0 var_4           = dword ptr -4
.text$mn:00001DD0
.text$mn:00001DD0                 push    ebp
.text$mn:00001DD1                 mov     ebp, esp
.text$mn:00001DD3                 push    ecx
.text$mn:00001DD4                 mov     [ebp+var_4], ecx
.text$mn:00001DD7                 mov     eax, [ebp+var_4]
.text$mn:00001DDA                 push    eax
.text$mn:00001DDB                 call    ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char> const &)
.text$mn:00001DE0                 add     esp, 4
.text$mn:00001DE3                 mov     esp, ebp
.text$mn:00001DE5                 pop     ebp
.text$mn:00001DE6                 retn
.text$mn:00001DE6 ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ endp
.text$mn:00001DE6
.text$mn:00001DE6 ; ---------------------------------------------------------------------------
.text$mn:00001DE7                 align 4
.text$mn:00001DE7 _text$mn        ends
.text$mn:00001DE7
.text$mn:00001DE8 ; ===========================================================================
.text$mn:00001DE8
.text$mn:00001DE8 ; Segment type: Pure code
.text$mn:00001DE8 ; Segment permissions: Read/Execute
.text$mn:00001DE8 _text$mn        segment para public 'CODE' use32
.text$mn:00001DE8                 assume cs:_text$mn
.text$mn:00001DE8                 ;org 1DE8h
.text$mn:00001DE8 ; COMDAT (pick any)
.text$mn:00001DE8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001DE8
.text$mn:00001DE8 ; =============== S U B R O U T I N E =======================================
.text$mn:00001DE8
.text$mn:00001DE8 ; Attributes: bp-based frame
.text$mn:00001DE8
.text$mn:00001DE8 ; public: unsigned int __thiscall std::allocator<char>::max_size(void)const
.text$mn:00001DE8                 public ?max_size@?$allocator@D@std@@QBEIXZ
.text$mn:00001DE8 ?max_size@?$allocator@D@std@@QBEIXZ proc near
.text$mn:00001DE8                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char> const &)+6p
.text$mn:00001DE8
.text$mn:00001DE8 var_4           = dword ptr -4
.text$mn:00001DE8
.text$mn:00001DE8                 push    ebp
.text$mn:00001DE9                 mov     ebp, esp
.text$mn:00001DEB                 push    ecx
.text$mn:00001DEC                 mov     [ebp+var_4], ecx
.text$mn:00001DEF                 or      eax, 0FFFFFFFFh
.text$mn:00001DF2                 mov     esp, ebp
.text$mn:00001DF4                 pop     ebp
.text$mn:00001DF5                 retn
.text$mn:00001DF5 ?max_size@?$allocator@D@std@@QBEIXZ endp
.text$mn:00001DF5
.text$mn:00001DF5 ; ---------------------------------------------------------------------------
.text$mn:00001DF6                 align 4
.text$mn:00001DF6 _text$mn        ends
.text$mn:00001DF6
.text$mn:00001DF8 ; ===========================================================================
.text$mn:00001DF8
.text$mn:00001DF8 ; Segment type: Pure code
.text$mn:00001DF8 ; Segment permissions: Read/Execute
.text$mn:00001DF8 _text$mn        segment para public 'CODE' use32
.text$mn:00001DF8                 assume cs:_text$mn
.text$mn:00001DF8                 ;org 1DF8h
.text$mn:00001DF8 ; COMDAT (pick any)
.text$mn:00001DF8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001DF8
.text$mn:00001DF8 ; =============== S U B R O U T I N E =======================================
.text$mn:00001DF8
.text$mn:00001DF8 ; Attributes: bp-based frame
.text$mn:00001DF8
.text$mn:00001DF8 ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<char>>::max_size(class std::allocator<char> const &)
.text$mn:00001DF8                 public ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
.text$mn:00001DF8 ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z proc near
.text$mn:00001DF8                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::max_size(void)+Bp
.text$mn:00001DF8
.text$mn:00001DF8 arg_0           = dword ptr  8
.text$mn:00001DF8
.text$mn:00001DF8                 push    ebp
.text$mn:00001DF9                 mov     ebp, esp
.text$mn:00001DFB                 mov     ecx, [ebp+arg_0]
.text$mn:00001DFE                 call    ?max_size@?$allocator@D@std@@QBEIXZ ; std::allocator<char>::max_size(void)
.text$mn:00001E03                 pop     ebp
.text$mn:00001E04                 retn
.text$mn:00001E04 ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z endp
.text$mn:00001E04
.text$mn:00001E04 ; ---------------------------------------------------------------------------
.text$mn:00001E05                 align 4
.text$mn:00001E05 _text$mn        ends
.text$mn:00001E05
.text$mn:00001E08 ; ===========================================================================
.text$mn:00001E08
.text$mn:00001E08 ; Segment type: Pure code
.text$mn:00001E08 ; Segment permissions: Read/Execute
.text$mn:00001E08 _text$mn        segment para public 'CODE' use32
.text$mn:00001E08                 assume cs:_text$mn
.text$mn:00001E08                 ;org 1E08h
.text$mn:00001E08 ; COMDAT (pick any)
.text$mn:00001E08                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001E08
.text$mn:00001E08 ; =============== S U B R O U T I N E =======================================
.text$mn:00001E08
.text$mn:00001E08 ; Attributes: bp-based frame
.text$mn:00001E08
.text$mn:00001E08 ; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::max_size(void)const
.text$mn:00001E08                 public ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
.text$mn:00001E08 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
.text$mn:00001E08                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+3Bp
.text$mn:00001E08                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+6Ap ...
.text$mn:00001E08
.text$mn:00001E08 var_10          = dword ptr -10h
.text$mn:00001E08 var_C           = dword ptr -0Ch
.text$mn:00001E08 var_8           = dword ptr -8
.text$mn:00001E08 var_1           = byte ptr -1
.text$mn:00001E08
.text$mn:00001E08                 push    ebp
.text$mn:00001E09                 mov     ebp, esp
.text$mn:00001E0B                 sub     esp, 10h
.text$mn:00001E0E                 mov     [ebp+var_10], ecx
.text$mn:00001E11                 lea     eax, [ebp+var_1]
.text$mn:00001E14                 push    eax
.text$mn:00001E15                 mov     ecx, [ebp+var_10]
.text$mn:00001E18                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00001E1D                 mov     ecx, eax
.text$mn:00001E1F                 call    ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char>>::max_size(void)
.text$mn:00001E24                 mov     [ebp+var_8], eax
.text$mn:00001E27                 cmp     [ebp+var_8], 1
.text$mn:00001E2B                 ja      short loc_1E36
.text$mn:00001E2D                 mov     [ebp+var_C], 1
.text$mn:00001E34                 jmp     short loc_1E3F
.text$mn:00001E36 ; ---------------------------------------------------------------------------
.text$mn:00001E36
.text$mn:00001E36 loc_1E36:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+23j
.text$mn:00001E36                 mov     ecx, [ebp+var_8]
.text$mn:00001E39                 sub     ecx, 1
.text$mn:00001E3C                 mov     [ebp+var_C], ecx
.text$mn:00001E3F
.text$mn:00001E3F loc_1E3F:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+2Cj
.text$mn:00001E3F                 mov     eax, [ebp+var_C]
.text$mn:00001E42                 mov     esp, ebp
.text$mn:00001E44                 pop     ebp
.text$mn:00001E45                 retn
.text$mn:00001E45 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp
.text$mn:00001E45
.text$mn:00001E45 ; ---------------------------------------------------------------------------
.text$mn:00001E46                 align 4
.text$mn:00001E46 _text$mn        ends
.text$mn:00001E46
.text$mn:00001E48 ; ===========================================================================
.text$mn:00001E48
.text$mn:00001E48 ; Segment type: Pure code
.text$mn:00001E48 ; Segment permissions: Read/Execute
.text$mn:00001E48 _text$mn        segment para public 'CODE' use32
.text$mn:00001E48                 assume cs:_text$mn
.text$mn:00001E48                 ;org 1E48h
.text$mn:00001E48 ; COMDAT (pick any)
.text$mn:00001E48                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001E48
.text$mn:00001E48 ; =============== S U B R O U T I N E =======================================
.text$mn:00001E48
.text$mn:00001E48 ; Attributes: bp-based frame
.text$mn:00001E48
.text$mn:00001E48 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Generic_error_category::message(int)const
.text$mn:00001E48                 public ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00001E48 ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:00001E48                                         ; CODE XREF: std::_Iostream_error_category::message(int)+64p
.text$mn:00001E48                                         ; DATA XREF: .rdata:00002630o
.text$mn:00001E48
.text$mn:00001E48 var_1C          = dword ptr -1Ch
.text$mn:00001E48 var_18          = dword ptr -18h
.text$mn:00001E48 Str             = dword ptr -14h
.text$mn:00001E48 var_10          = dword ptr -10h
.text$mn:00001E48 var_C           = dword ptr -0Ch
.text$mn:00001E48 var_4           = dword ptr -4
.text$mn:00001E48 arg_0           = dword ptr  8
.text$mn:00001E48 arg_4           = dword ptr  0Ch
.text$mn:00001E48
.text$mn:00001E48                 push    ebp
.text$mn:00001E49                 mov     ebp, esp
.text$mn:00001E4B                 push    0FFFFFFFFh
.text$mn:00001E4D                 push    offset __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00001E52                 mov     eax, large fs:0
.text$mn:00001E58                 push    eax
.text$mn:00001E59                 sub     esp, 10h
.text$mn:00001E5C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001E61                 xor     eax, ebp
.text$mn:00001E63                 push    eax
.text$mn:00001E64                 lea     eax, [ebp+var_C]
.text$mn:00001E67                 mov     large fs:0, eax
.text$mn:00001E6D                 mov     [ebp+var_1C], ecx
.text$mn:00001E70                 mov     [ebp+var_18], 0
.text$mn:00001E77                 mov     eax, [ebp+arg_4]
.text$mn:00001E7A                 push    eax             ; int
.text$mn:00001E7B                 call    ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map(int)
.text$mn:00001E80                 add     esp, 4
.text$mn:00001E83                 mov     [ebp+var_10], eax
.text$mn:00001E86                 cmp     [ebp+var_10], 0
.text$mn:00001E8A                 jz      short loc_1E94
.text$mn:00001E8C                 mov     ecx, [ebp+var_10]
.text$mn:00001E8F                 mov     [ebp+Str], ecx
.text$mn:00001E92                 jmp     short loc_1E9B
.text$mn:00001E94 ; ---------------------------------------------------------------------------
.text$mn:00001E94
.text$mn:00001E94 loc_1E94:                               ; CODE XREF: std::_Generic_error_category::message(int)+42j
.text$mn:00001E94                 mov     [ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ ; "unknown error"
.text$mn:00001E9B
.text$mn:00001E9B loc_1E9B:                               ; CODE XREF: std::_Generic_error_category::message(int)+4Aj
.text$mn:00001E9B                 mov     edx, [ebp+Str]
.text$mn:00001E9E                 push    edx             ; Str
.text$mn:00001E9F                 mov     ecx, [ebp+arg_0]
.text$mn:00001EA2                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:00001EA7                 mov     [ebp+var_4], 0
.text$mn:00001EAE                 mov     eax, [ebp+var_18]
.text$mn:00001EB1                 or      eax, 1
.text$mn:00001EB4                 mov     [ebp+var_18], eax
.text$mn:00001EB7                 mov     eax, [ebp+arg_0]
.text$mn:00001EBA                 mov     ecx, [ebp+var_C]
.text$mn:00001EBD                 mov     large fs:0, ecx
.text$mn:00001EC4                 pop     ecx
.text$mn:00001EC5                 mov     esp, ebp
.text$mn:00001EC7                 pop     ebp
.text$mn:00001EC8                 retn    8
.text$mn:00001EC8 ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:00001EC8
.text$mn:00001EC8 ; ---------------------------------------------------------------------------
.text$mn:00001ECB                 align 4
.text$mn:00001ECB _text$mn        ends
.text$mn:00001ECB
.text$x:00001ECC ; ===========================================================================
.text$x:00001ECC
.text$x:00001ECC ; Segment type: Pure code
.text$x:00001ECC ; Segment permissions: Read/Execute
.text$x:00001ECC _text$x         segment para public 'CODE' use32
.text$x:00001ECC                 assume cs:_text$x
.text$x:00001ECC                 ;org 1ECCh
.text$x:00001ECC ; COMDAT (pick associative to section at 1E48)
.text$x:00001ECC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001ECC
.text$x:00001ECC ; =============== S U B R O U T I N E =======================================
.text$x:00001ECC
.text$x:00001ECC
.text$x:00001ECC __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:00001ECC                                         ; DATA XREF: .xdata$x:000023B8o
.text$x:00001ECC                 mov     eax, [ebp-18h]
.text$x:00001ECF                 and     eax, 1
.text$x:00001ED2                 jz      $LN6
.text$x:00001ED8                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:00001EDC                 mov     ecx, [ebp+8]
.text$x:00001EDF                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00001EE4 ; ---------------------------------------------------------------------------
.text$x:00001EE4
.text$x:00001EE4 $LN6:                                   ; CODE XREF: __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:00001EE4                 retn
.text$x:00001EE4 __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:00001EE4
.text$x:00001EE5
.text$x:00001EE5 ; =============== S U B R O U T I N E =======================================
.text$x:00001EE5
.text$x:00001EE5
.text$x:00001EE5 __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:00001EE5                                         ; DATA XREF: std::_Generic_error_category::message(int)+5o
.text$x:00001EE5
.text$x:00001EE5 arg_4           = dword ptr  8
.text$x:00001EE5
.text$x:00001EE5                 mov     edx, [esp+arg_4]
.text$x:00001EE9                 lea     eax, [edx+0Ch]
.text$x:00001EEC                 mov     ecx, [edx-14h]
.text$x:00001EEF                 xor     ecx, eax
.text$x:00001EF1                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001EF6                 mov     eax, offset __ehfuncinfo$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:00001EFB                 jmp     ___CxxFrameHandler3
.text$x:00001EFB __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:00001EFB
.text$x:00001EFB _text$x         ends
.text$x:00001EFB
.text$mn:00001F00 ; ===========================================================================
.text$mn:00001F00
.text$mn:00001F00 ; Segment type: Pure code
.text$mn:00001F00 ; Segment permissions: Read/Execute
.text$mn:00001F00 _text$mn        segment para public 'CODE' use32
.text$mn:00001F00                 assume cs:_text$mn
.text$mn:00001F00                 ;org 1F00h
.text$mn:00001F00 ; COMDAT (pick any)
.text$mn:00001F00                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001F00
.text$mn:00001F00 ; =============== S U B R O U T I N E =======================================
.text$mn:00001F00
.text$mn:00001F00 ; Attributes: bp-based frame
.text$mn:00001F00
.text$mn:00001F00 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Iostream_error_category::message(int)const
.text$mn:00001F00                 public ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00001F00 ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:00001F00                                         ; DATA XREF: .rdata:00002664o
.text$mn:00001F00
.text$mn:00001F00 var_14          = dword ptr -14h
.text$mn:00001F00 var_10          = dword ptr -10h
.text$mn:00001F00 var_C           = dword ptr -0Ch
.text$mn:00001F00 var_4           = dword ptr -4
.text$mn:00001F00 arg_0           = dword ptr  8
.text$mn:00001F00 arg_4           = dword ptr  0Ch
.text$mn:00001F00
.text$mn:00001F00                 push    ebp
.text$mn:00001F01                 mov     ebp, esp
.text$mn:00001F03                 push    0FFFFFFFFh
.text$mn:00001F05                 push    offset __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00001F0A                 mov     eax, large fs:0
.text$mn:00001F10                 push    eax
.text$mn:00001F11                 sub     esp, 8
.text$mn:00001F14                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001F19                 xor     eax, ebp
.text$mn:00001F1B                 push    eax
.text$mn:00001F1C                 lea     eax, [ebp+var_C]
.text$mn:00001F1F                 mov     large fs:0, eax
.text$mn:00001F25                 mov     [ebp+var_14], ecx
.text$mn:00001F28                 mov     [ebp+var_10], 0
.text$mn:00001F2F                 cmp     [ebp+arg_4], 1
.text$mn:00001F33                 jnz     short loc_1F59
.text$mn:00001F35                 push    offset ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ ; "iostream stream error"
.text$mn:00001F3A                 mov     ecx, [ebp+arg_0]
.text$mn:00001F3D                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:00001F42                 mov     [ebp+var_4], 0
.text$mn:00001F49                 mov     eax, [ebp+var_10]
.text$mn:00001F4C                 or      eax, 1
.text$mn:00001F4F                 mov     [ebp+var_10], eax
.text$mn:00001F52                 mov     eax, [ebp+arg_0]
.text$mn:00001F55                 jmp     short loc_1F7C
.text$mn:00001F57 ; ---------------------------------------------------------------------------
.text$mn:00001F57                 jmp     short loc_1F7C
.text$mn:00001F59 ; ---------------------------------------------------------------------------
.text$mn:00001F59
.text$mn:00001F59 loc_1F59:                               ; CODE XREF: std::_Iostream_error_category::message(int)+33j
.text$mn:00001F59                 mov     ecx, [ebp+arg_4]
.text$mn:00001F5C                 push    ecx
.text$mn:00001F5D                 mov     edx, [ebp+arg_0]
.text$mn:00001F60                 push    edx
.text$mn:00001F61                 mov     ecx, [ebp+var_14]
.text$mn:00001F64                 call    ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
.text$mn:00001F69                 mov     [ebp+var_4], 0
.text$mn:00001F70                 mov     eax, [ebp+var_10]
.text$mn:00001F73                 or      eax, 1
.text$mn:00001F76                 mov     [ebp+var_10], eax
.text$mn:00001F79                 mov     eax, [ebp+arg_0]
.text$mn:00001F7C
.text$mn:00001F7C loc_1F7C:                               ; CODE XREF: std::_Iostream_error_category::message(int)+55j
.text$mn:00001F7C                                         ; std::_Iostream_error_category::message(int)+57j
.text$mn:00001F7C                 mov     ecx, [ebp+var_C]
.text$mn:00001F7F                 mov     large fs:0, ecx
.text$mn:00001F86                 pop     ecx
.text$mn:00001F87                 mov     esp, ebp
.text$mn:00001F89                 pop     ebp
.text$mn:00001F8A                 retn    8
.text$mn:00001F8A ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:00001F8A
.text$mn:00001F8A ; ---------------------------------------------------------------------------
.text$mn:00001F8D                 align 10h
.text$mn:00001F8D _text$mn        ends
.text$mn:00001F8D
.text$x:00001F90 ; ===========================================================================
.text$x:00001F90
.text$x:00001F90 ; Segment type: Pure code
.text$x:00001F90 ; Segment permissions: Read/Execute
.text$x:00001F90 _text$x         segment para public 'CODE' use32
.text$x:00001F90                 assume cs:_text$x
.text$x:00001F90                 ;org 1F90h
.text$x:00001F90 ; COMDAT (pick associative to section at 1F00)
.text$x:00001F90                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001F90
.text$x:00001F90 ; =============== S U B R O U T I N E =======================================
.text$x:00001F90
.text$x:00001F90
.text$x:00001F90 __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:00001F90                                         ; DATA XREF: .xdata$x:0000243Co
.text$x:00001F90                 mov     eax, [ebp-10h]
.text$x:00001F93                 and     eax, 1
.text$x:00001F96                 jz      $LN6_0
.text$x:00001F9C                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:00001FA0                 mov     ecx, [ebp+8]
.text$x:00001FA3                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00001FA8 ; ---------------------------------------------------------------------------
.text$x:00001FA8
.text$x:00001FA8 $LN6_0:                                 ; CODE XREF: __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:00001FA8                 retn
.text$x:00001FA8 __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:00001FA8
.text$x:00001FA9
.text$x:00001FA9 ; =============== S U B R O U T I N E =======================================
.text$x:00001FA9
.text$x:00001FA9
.text$x:00001FA9 __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:00001FA9                                         ; DATA XREF: std::_Iostream_error_category::message(int)+5o
.text$x:00001FA9
.text$x:00001FA9 arg_4           = dword ptr  8
.text$x:00001FA9
.text$x:00001FA9                 mov     edx, [esp+arg_4]
.text$x:00001FAD                 lea     eax, [edx+0Ch]
.text$x:00001FB0                 mov     ecx, [edx-0Ch]
.text$x:00001FB3                 xor     ecx, eax
.text$x:00001FB5                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001FBA                 mov     eax, offset __ehfuncinfo$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:00001FBF                 jmp     ___CxxFrameHandler3
.text$x:00001FBF __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:00001FBF
.text$x:00001FBF _text$x         ends
.text$x:00001FBF
.text$mn:00001FC4 ; ===========================================================================
.text$mn:00001FC4
.text$mn:00001FC4 ; Segment type: Pure code
.text$mn:00001FC4 ; Segment permissions: Read/Execute
.text$mn:00001FC4 _text$mn        segment para public 'CODE' use32
.text$mn:00001FC4                 assume cs:_text$mn
.text$mn:00001FC4                 ;org 1FC4h
.text$mn:00001FC4 ; COMDAT (pick any)
.text$mn:00001FC4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001FC4
.text$mn:00001FC4 ; =============== S U B R O U T I N E =======================================
.text$mn:00001FC4
.text$mn:00001FC4 ; Attributes: bp-based frame
.text$mn:00001FC4
.text$mn:00001FC4 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_System_error_category::message(int)const
.text$mn:00001FC4                 public ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00001FC4 ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:00001FC4                                         ; DATA XREF: .rdata:000026A4o
.text$mn:00001FC4
.text$mn:00001FC4 var_1C          = dword ptr -1Ch
.text$mn:00001FC4 var_18          = dword ptr -18h
.text$mn:00001FC4 Str             = dword ptr -14h
.text$mn:00001FC4 var_10          = dword ptr -10h
.text$mn:00001FC4 var_C           = dword ptr -0Ch
.text$mn:00001FC4 var_4           = dword ptr -4
.text$mn:00001FC4 arg_0           = dword ptr  8
.text$mn:00001FC4 arg_4           = dword ptr  0Ch
.text$mn:00001FC4
.text$mn:00001FC4                 push    ebp
.text$mn:00001FC5                 mov     ebp, esp
.text$mn:00001FC7                 push    0FFFFFFFFh
.text$mn:00001FC9                 push    offset __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00001FCE                 mov     eax, large fs:0
.text$mn:00001FD4                 push    eax
.text$mn:00001FD5                 sub     esp, 10h
.text$mn:00001FD8                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001FDD                 xor     eax, ebp
.text$mn:00001FDF                 push    eax
.text$mn:00001FE0                 lea     eax, [ebp+var_C]
.text$mn:00001FE3                 mov     large fs:0, eax
.text$mn:00001FE9                 mov     [ebp+var_1C], ecx
.text$mn:00001FEC                 mov     [ebp+var_18], 0
.text$mn:00001FF3                 mov     eax, [ebp+arg_4]
.text$mn:00001FF6                 push    eax             ; int
.text$mn:00001FF7                 call    ?_Winerror_map@std@@YAPBDH@Z ; std::_Winerror_map(int)
.text$mn:00001FFC                 add     esp, 4
.text$mn:00001FFF                 mov     [ebp+var_10], eax
.text$mn:00002002                 cmp     [ebp+var_10], 0
.text$mn:00002006                 jz      short loc_2010
.text$mn:00002008                 mov     ecx, [ebp+var_10]
.text$mn:0000200B                 mov     [ebp+Str], ecx
.text$mn:0000200E                 jmp     short loc_2017
.text$mn:00002010 ; ---------------------------------------------------------------------------
.text$mn:00002010
.text$mn:00002010 loc_2010:                               ; CODE XREF: std::_System_error_category::message(int)+42j
.text$mn:00002010                 mov     [ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ ; "unknown error"
.text$mn:00002017
.text$mn:00002017 loc_2017:                               ; CODE XREF: std::_System_error_category::message(int)+4Aj
.text$mn:00002017                 mov     edx, [ebp+Str]
.text$mn:0000201A                 push    edx             ; Str
.text$mn:0000201B                 mov     ecx, [ebp+arg_0]
.text$mn:0000201E                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:00002023                 mov     [ebp+var_4], 0
.text$mn:0000202A                 mov     eax, [ebp+var_18]
.text$mn:0000202D                 or      eax, 1
.text$mn:00002030                 mov     [ebp+var_18], eax
.text$mn:00002033                 mov     eax, [ebp+arg_0]
.text$mn:00002036                 mov     ecx, [ebp+var_C]
.text$mn:00002039                 mov     large fs:0, ecx
.text$mn:00002040                 pop     ecx
.text$mn:00002041                 mov     esp, ebp
.text$mn:00002043                 pop     ebp
.text$mn:00002044                 retn    8
.text$mn:00002044 ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:00002044
.text$mn:00002044 ; ---------------------------------------------------------------------------
.text$mn:00002047                 align 4
.text$mn:00002047 _text$mn        ends
.text$mn:00002047
.text$x:00002048 ; ===========================================================================
.text$x:00002048
.text$x:00002048 ; Segment type: Pure code
.text$x:00002048 ; Segment permissions: Read/Execute
.text$x:00002048 _text$x         segment para public 'CODE' use32
.text$x:00002048                 assume cs:_text$x
.text$x:00002048                 ;org 2048h
.text$x:00002048 ; COMDAT (pick associative to section at 1FC4)
.text$x:00002048                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002048
.text$x:00002048 ; =============== S U B R O U T I N E =======================================
.text$x:00002048
.text$x:00002048
.text$x:00002048 __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:00002048                                         ; DATA XREF: .xdata$x:000024C0o
.text$x:00002048                 mov     eax, [ebp-18h]
.text$x:0000204B                 and     eax, 1
.text$x:0000204E                 jz      $LN6_1
.text$x:00002054                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:00002058                 mov     ecx, [ebp+8]
.text$x:0000205B                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00002060 ; ---------------------------------------------------------------------------
.text$x:00002060
.text$x:00002060 $LN6_1:                                 ; CODE XREF: __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:00002060                 retn
.text$x:00002060 __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:00002060
.text$x:00002061
.text$x:00002061 ; =============== S U B R O U T I N E =======================================
.text$x:00002061
.text$x:00002061
.text$x:00002061 __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:00002061                                         ; DATA XREF: std::_System_error_category::message(int)+5o
.text$x:00002061
.text$x:00002061 arg_4           = dword ptr  8
.text$x:00002061
.text$x:00002061                 mov     edx, [esp+arg_4]
.text$x:00002065                 lea     eax, [edx+0Ch]
.text$x:00002068                 mov     ecx, [edx-14h]
.text$x:0000206B                 xor     ecx, eax
.text$x:0000206D                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002072                 mov     eax, offset __ehfuncinfo$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:00002077                 jmp     ___CxxFrameHandler3
.text$x:00002077 __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:00002077
.text$x:00002077 _text$x         ends
.text$x:00002077
.text$mn:0000207C ; ===========================================================================
.text$mn:0000207C
.text$mn:0000207C ; Segment type: Pure code
.text$mn:0000207C ; Segment permissions: Read/Execute
.text$mn:0000207C _text$mn        segment para public 'CODE' use32
.text$mn:0000207C                 assume cs:_text$mn
.text$mn:0000207C                 ;org 207Ch
.text$mn:0000207C ; COMDAT (pick any)
.text$mn:0000207C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000207C
.text$mn:0000207C ; =============== S U B R O U T I N E =======================================
.text$mn:0000207C
.text$mn:0000207C ; Attributes: bp-based frame
.text$mn:0000207C
.text$mn:0000207C ; int __cdecl std::char_traits<char>::move(void *Dst, void *Src, size_t Size)
.text$mn:0000207C                 public ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
.text$mn:0000207C ?move@?$char_traits@D@std@@SAPADPADPBDI@Z proc near
.text$mn:0000207C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+6Ap
.text$mn:0000207C
.text$mn:0000207C var_4           = dword ptr -4
.text$mn:0000207C Dst             = dword ptr  8
.text$mn:0000207C Src             = dword ptr  0Ch
.text$mn:0000207C Size            = dword ptr  10h
.text$mn:0000207C
.text$mn:0000207C                 push    ebp
.text$mn:0000207D                 mov     ebp, esp
.text$mn:0000207F                 push    ecx
.text$mn:00002080                 cmp     [ebp+Size], 0
.text$mn:00002084                 jnz     short loc_208E
.text$mn:00002086                 mov     eax, [ebp+Dst]
.text$mn:00002089                 mov     [ebp+var_4], eax
.text$mn:0000208C                 jmp     short loc_20A5
.text$mn:0000208E ; ---------------------------------------------------------------------------
.text$mn:0000208E
.text$mn:0000208E loc_208E:                               ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+8j
.text$mn:0000208E                 mov     ecx, [ebp+Size]
.text$mn:00002091                 push    ecx             ; Size
.text$mn:00002092                 mov     edx, [ebp+Src]
.text$mn:00002095                 push    edx             ; Src
.text$mn:00002096                 mov     eax, [ebp+Dst]
.text$mn:00002099                 push    eax             ; Dst
.text$mn:0000209A                 call    _memmove
.text$mn:0000209F                 add     esp, 0Ch
.text$mn:000020A2                 mov     [ebp+var_4], eax
.text$mn:000020A5
.text$mn:000020A5 loc_20A5:                               ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+10j
.text$mn:000020A5                 mov     eax, [ebp+var_4]
.text$mn:000020A8                 mov     esp, ebp
.text$mn:000020AA                 pop     ebp
.text$mn:000020AB                 retn
.text$mn:000020AB ?move@?$char_traits@D@std@@SAPADPADPBDI@Z endp
.text$mn:000020AB
.text$mn:000020AB _text$mn        ends
.text$mn:000020AB
.text$mn:000020AC ; ===========================================================================
.text$mn:000020AC
.text$mn:000020AC ; Segment type: Pure code
.text$mn:000020AC ; Segment permissions: Read/Execute
.text$mn:000020AC _text$mn        segment para public 'CODE' use32
.text$mn:000020AC                 assume cs:_text$mn
.text$mn:000020AC                 ;org 20ACh
.text$mn:000020AC ; COMDAT (pick any)
.text$mn:000020AC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000020AC
.text$mn:000020AC ; =============== S U B R O U T I N E =======================================
.text$mn:000020AC
.text$mn:000020AC ; Attributes: bp-based frame
.text$mn:000020AC
.text$mn:000020AC ; const char *__thiscall std::_Generic_error_category::name(std::_Generic_error_category *__hidden this)
.text$mn:000020AC                 public ?name@_Generic_error_category@std@@UBEPBDXZ
.text$mn:000020AC ?name@_Generic_error_category@std@@UBEPBDXZ proc near
.text$mn:000020AC                                         ; DATA XREF: .rdata:0000262Co
.text$mn:000020AC
.text$mn:000020AC var_4           = dword ptr -4
.text$mn:000020AC
.text$mn:000020AC                 push    ebp
.text$mn:000020AD                 mov     ebp, esp
.text$mn:000020AF                 push    ecx
.text$mn:000020B0                 mov     [ebp+var_4], ecx
.text$mn:000020B3                 mov     eax, offset ??_C@_07DCLBNMLN@generic?$AA@ ; "generic"
.text$mn:000020B8                 mov     esp, ebp
.text$mn:000020BA                 pop     ebp
.text$mn:000020BB                 retn
.text$mn:000020BB ?name@_Generic_error_category@std@@UBEPBDXZ endp
.text$mn:000020BB
.text$mn:000020BB _text$mn        ends
.text$mn:000020BB
.text$mn:000020BC ; ===========================================================================
.text$mn:000020BC
.text$mn:000020BC ; Segment type: Pure code
.text$mn:000020BC ; Segment permissions: Read/Execute
.text$mn:000020BC _text$mn        segment para public 'CODE' use32
.text$mn:000020BC                 assume cs:_text$mn
.text$mn:000020BC                 ;org 20BCh
.text$mn:000020BC ; COMDAT (pick any)
.text$mn:000020BC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000020BC
.text$mn:000020BC ; =============== S U B R O U T I N E =======================================
.text$mn:000020BC
.text$mn:000020BC ; Attributes: bp-based frame
.text$mn:000020BC
.text$mn:000020BC ; const char *__thiscall std::_Iostream_error_category::name(std::_Iostream_error_category *__hidden this)
.text$mn:000020BC                 public ?name@_Iostream_error_category@std@@UBEPBDXZ
.text$mn:000020BC ?name@_Iostream_error_category@std@@UBEPBDXZ proc near
.text$mn:000020BC                                         ; DATA XREF: .rdata:00002660o
.text$mn:000020BC
.text$mn:000020BC var_4           = dword ptr -4
.text$mn:000020BC
.text$mn:000020BC                 push    ebp
.text$mn:000020BD                 mov     ebp, esp
.text$mn:000020BF                 push    ecx
.text$mn:000020C0                 mov     [ebp+var_4], ecx
.text$mn:000020C3                 mov     eax, offset ??_C@_08LLGCOLLL@iostream?$AA@ ; "iostream"
.text$mn:000020C8                 mov     esp, ebp
.text$mn:000020CA                 pop     ebp
.text$mn:000020CB                 retn
.text$mn:000020CB ?name@_Iostream_error_category@std@@UBEPBDXZ endp
.text$mn:000020CB
.text$mn:000020CB _text$mn        ends
.text$mn:000020CB
.text$mn:000020CC ; ===========================================================================
.text$mn:000020CC
.text$mn:000020CC ; Segment type: Pure code
.text$mn:000020CC ; Segment permissions: Read/Execute
.text$mn:000020CC _text$mn        segment para public 'CODE' use32
.text$mn:000020CC                 assume cs:_text$mn
.text$mn:000020CC                 ;org 20CCh
.text$mn:000020CC ; COMDAT (pick any)
.text$mn:000020CC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000020CC
.text$mn:000020CC ; =============== S U B R O U T I N E =======================================
.text$mn:000020CC
.text$mn:000020CC ; Attributes: bp-based frame
.text$mn:000020CC
.text$mn:000020CC ; const char *__thiscall std::_System_error_category::name(std::_System_error_category *__hidden this)
.text$mn:000020CC                 public ?name@_System_error_category@std@@UBEPBDXZ
.text$mn:000020CC ?name@_System_error_category@std@@UBEPBDXZ proc near
.text$mn:000020CC                                         ; DATA XREF: .rdata:000026A0o
.text$mn:000020CC
.text$mn:000020CC var_4           = dword ptr -4
.text$mn:000020CC
.text$mn:000020CC                 push    ebp
.text$mn:000020CD                 mov     ebp, esp
.text$mn:000020CF                 push    ecx
.text$mn:000020D0                 mov     [ebp+var_4], ecx
.text$mn:000020D3                 mov     eax, offset ??_C@_06FHFOAHML@system?$AA@ ; "system"
.text$mn:000020D8                 mov     esp, ebp
.text$mn:000020DA                 pop     ebp
.text$mn:000020DB                 retn
.text$mn:000020DB ?name@_System_error_category@std@@UBEPBDXZ endp
.text$mn:000020DB
.text$mn:000020DB _text$mn        ends
.text$mn:000020DB
.text$mn:000020DC ; ===========================================================================
.text$mn:000020DC
.text$mn:000020DC ; Segment type: Pure code
.text$mn:000020DC ; Segment permissions: Read/Execute
.text$mn:000020DC _text$mn        segment para public 'CODE' use32
.text$mn:000020DC                 assume cs:_text$mn
.text$mn:000020DC                 ;org 20DCh
.text$mn:000020DC ; COMDAT (pick any)
.text$mn:000020DC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000020DC
.text$mn:000020DC ; =============== S U B R O U T I N E =======================================
.text$mn:000020DC
.text$mn:000020DC ; Attributes: bp-based frame
.text$mn:000020DC
.text$mn:000020DC ; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::size(void)const
.text$mn:000020DC                 public ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
.text$mn:000020DC ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
.text$mn:000020DC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+Cp
.text$mn:000020DC                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+21p
.text$mn:000020DC
.text$mn:000020DC var_4           = dword ptr -4
.text$mn:000020DC
.text$mn:000020DC                 push    ebp
.text$mn:000020DD                 mov     ebp, esp
.text$mn:000020DF                 push    ecx
.text$mn:000020E0                 mov     [ebp+var_4], ecx
.text$mn:000020E3                 mov     eax, [ebp+var_4]
.text$mn:000020E6                 mov     eax, [eax+14h]
.text$mn:000020E9                 mov     esp, ebp
.text$mn:000020EB                 pop     ebp
.text$mn:000020EC                 retn
.text$mn:000020EC ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp
.text$mn:000020EC
.text$mn:000020EC ; ---------------------------------------------------------------------------
.text$mn:000020ED                 align 10h
.text$mn:000020ED _text$mn        ends
.text$mn:000020ED
.text$mn:000020F0 ; ===========================================================================
.text$mn:000020F0
.text$mn:000020F0 ; Segment type: Pure code
.text$mn:000020F0 ; Segment permissions: Read/Execute
.text$mn:000020F0 _text$mn        segment para public 'CODE' use32
.text$mn:000020F0                 assume cs:_text$mn
.text$mn:000020F0                 ;org 20F0h
.text$mn:000020F0 ; COMDAT (pick any)
.text$mn:000020F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000020F0
.text$mn:000020F0 ; =============== S U B R O U T I N E =======================================
.text$mn:000020F0
.text$mn:000020F0 ; Attributes: bp-based frame
.text$mn:000020F0
.text$mn:000020F0 ; const struct std::error_category *__cdecl std::system_category()
.text$mn:000020F0                 public ?system_category@std@@YAABVerror_category@1@XZ
.text$mn:000020F0 ?system_category@std@@YAABVerror_category@1@XZ proc near
.text$mn:000020F0                                         ; CODE XREF: std::_System_error_category::default_error_condition(int):loc_1C08p
.text$mn:000020F0                 push    ebp
.text$mn:000020F1                 mov     ebp, esp
.text$mn:000020F3                 mov     eax, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_System_error_category std::_Error_objects<int>::_System_object
.text$mn:000020F8                 pop     ebp
.text$mn:000020F9                 retn
.text$mn:000020F9 ?system_category@std@@YAABVerror_category@1@XZ endp
.text$mn:000020F9
.text$mn:000020F9 ; ---------------------------------------------------------------------------
.text$mn:000020FA                 align 4
.text$mn:000020FA _text$mn        ends
.text$mn:000020FA
.text$mn:000020FC ; ===========================================================================
.text$mn:000020FC
.text$mn:000020FC ; Segment type: Pure code
.text$mn:000020FC ; Segment permissions: Read/Execute
.text$mn:000020FC _text$mn        segment para public 'CODE' use32
.text$mn:000020FC                 assume cs:_text$mn
.text$mn:000020FC                 ;org 20FCh
.text$mn:000020FC ; COMDAT (pick any)
.text$mn:000020FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000020FC
.text$mn:000020FC ; =============== S U B R O U T I N E =======================================
.text$mn:000020FC
.text$mn:000020FC ; Attributes: bp-based frame
.text$mn:000020FC
.text$mn:000020FC ; int __thiscall std::error_code::value(std::error_code *__hidden this)
.text$mn:000020FC                 public ?value@error_code@std@@QBEHXZ
.text$mn:000020FC ?value@error_code@std@@QBEHXZ proc near ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+24p
.text$mn:000020FC
.text$mn:000020FC var_4           = dword ptr -4
.text$mn:000020FC
.text$mn:000020FC                 push    ebp
.text$mn:000020FD                 mov     ebp, esp
.text$mn:000020FF                 push    ecx
.text$mn:00002100                 mov     [ebp+var_4], ecx
.text$mn:00002103                 mov     eax, [ebp+var_4]
.text$mn:00002106                 mov     eax, [eax]
.text$mn:00002108                 mov     esp, ebp
.text$mn:0000210A                 pop     ebp
.text$mn:0000210B                 retn
.text$mn:0000210B ?value@error_code@std@@QBEHXZ endp
.text$mn:0000210B
.text$mn:0000210B _text$mn        ends
.text$mn:0000210B
.text$mn:0000210C ; ===========================================================================
.text$mn:0000210C
.text$mn:0000210C ; Segment type: Pure code
.text$mn:0000210C ; Segment permissions: Read/Execute
.text$mn:0000210C _text$mn        segment para public 'CODE' use32
.text$mn:0000210C                 assume cs:_text$mn
.text$mn:0000210C                 ;org 210Ch
.text$mn:0000210C ; COMDAT (pick any)
.text$mn:0000210C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000210C
.text$mn:0000210C ; =============== S U B R O U T I N E =======================================
.text$mn:0000210C
.text$mn:0000210C ; Attributes: bp-based frame
.text$mn:0000210C
.text$mn:0000210C ; int __thiscall std::error_condition::value(std::error_condition *__hidden this)
.text$mn:0000210C                 public ?value@error_condition@std@@QBEHXZ
.text$mn:0000210C ?value@error_condition@std@@QBEHXZ proc near
.text$mn:0000210C                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+2Cp
.text$mn:0000210C                                         ; std::error_condition::operator==(std::error_condition const &)+36p
.text$mn:0000210C
.text$mn:0000210C var_4           = dword ptr -4
.text$mn:0000210C
.text$mn:0000210C                 push    ebp
.text$mn:0000210D                 mov     ebp, esp
.text$mn:0000210F                 push    ecx
.text$mn:00002110                 mov     [ebp+var_4], ecx
.text$mn:00002113                 mov     eax, [ebp+var_4]
.text$mn:00002116                 mov     eax, [eax]
.text$mn:00002118                 mov     esp, ebp
.text$mn:0000211A                 pop     ebp
.text$mn:0000211B                 retn
.text$mn:0000211B ?value@error_condition@std@@QBEHXZ endp
.text$mn:0000211B
.text$mn:0000211B _text$mn        ends
.text$mn:0000211B
.text$mn:0000211C ; ===========================================================================
.text$mn:0000211C
.text$mn:0000211C ; Segment type: Pure code
.text$mn:0000211C ; Segment permissions: Read/Execute
.text$mn:0000211C _text$mn        segment para public 'CODE' use32
.text$mn:0000211C                 assume cs:_text$mn
.text$mn:0000211C                 ;org 211Ch
.text$mn:0000211C ; COMDAT (pick any)
.text$mn:0000211C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000211C
.text$mn:0000211C ; =============== S U B R O U T I N E =======================================
.text$mn:0000211C
.text$mn:0000211C ; Attributes: bp-based frame
.text$mn:0000211C
.text$mn:0000211C                 public _hypot
.text$mn:0000211C _hypot          proc near
.text$mn:0000211C
.text$mn:0000211C var_10          = qword ptr -10h
.text$mn:0000211C var_8           = qword ptr -8
.text$mn:0000211C arg_0           = qword ptr  8
.text$mn:0000211C arg_8           = qword ptr  10h
.text$mn:0000211C
.text$mn:0000211C                 push    ebp
.text$mn:0000211D                 mov     ebp, esp
.text$mn:0000211F                 sub     esp, 8
.text$mn:00002122                 movsd   xmm0, [ebp+arg_8]
.text$mn:00002127                 movsd   [esp+8+var_8], xmm0
.text$mn:0000212C                 sub     esp, 8
.text$mn:0000212F                 movsd   xmm0, [ebp+arg_0]
.text$mn:00002134                 movsd   [esp+10h+var_10], xmm0
.text$mn:00002139                 call    __hypot
.text$mn:0000213E                 add     esp, 10h
.text$mn:00002141                 pop     ebp
.text$mn:00002142                 retn
.text$mn:00002142 _hypot          endp
.text$mn:00002142
.text$mn:00002142 ; ---------------------------------------------------------------------------
.text$mn:00002143                 align 4
.text$mn:00002143 _text$mn        ends
.text$mn:00002143
.xdata$x:00002144 ; ===========================================================================
.xdata$x:00002144
.xdata$x:00002144 ; Segment type: Pure data
.xdata$x:00002144 ; Segment permissions: Read
.xdata$x:00002144 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002144                 assume cs:_xdata$x
.xdata$x:00002144                 ;org 2144h
.xdata$x:00002144 ; COMDAT (pick associative to section at 17AC)
.xdata$x:00002144 __unwindtable$?_Orphan_all@_Container_base12@std@@QAEXXZ db 0FFh
.xdata$x:00002144                                         ; DATA XREF: .xdata$x:00002154o
.xdata$x:00002145                 db 0FFh
.xdata$x:00002146                 db 0FFh
.xdata$x:00002147                 db 0FFh
.xdata$x:00002148                 dd offset __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0
.xdata$x:0000214C __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ db  22h ; "
.xdata$x:0000214C                                         ; DATA XREF: __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ+11o
.xdata$x:0000214D                 db    5
.xdata$x:0000214E                 db  93h ; ô
.xdata$x:0000214F                 db  19h
.xdata$x:00002150                 db    1
.xdata$x:00002151                 db    0
.xdata$x:00002152                 db    0
.xdata$x:00002153                 db    0
.xdata$x:00002154                 dd offset __unwindtable$?_Orphan_all@_Container_base12@std@@QAEXXZ
.xdata$x:00002158                 db    0
.xdata$x:00002159                 db    0
.xdata$x:0000215A                 db    0
.xdata$x:0000215B                 db    0
.xdata$x:0000215C                 db    0
.xdata$x:0000215D                 db    0
.xdata$x:0000215E                 db    0
.xdata$x:0000215F                 db    0
.xdata$x:00002160                 db    0
.xdata$x:00002161                 db    0
.xdata$x:00002162                 db    0
.xdata$x:00002163                 db    0
.xdata$x:00002164                 db    0
.xdata$x:00002165                 db    0
.xdata$x:00002166                 db    0
.xdata$x:00002167                 db    0
.xdata$x:00002168                 db    0
.xdata$x:00002169                 db    0
.xdata$x:0000216A                 db    0
.xdata$x:0000216B                 db    0
.xdata$x:0000216C                 db    0
.xdata$x:0000216D                 db    0
.xdata$x:0000216E                 db    0
.xdata$x:0000216F                 db    0
.xdata$x:0000216F _xdata$x        ends
.xdata$x:0000216F
.xdata$x:00002170 ; ===========================================================================
.xdata$x:00002170
.xdata$x:00002170 ; Segment type: Pure data
.xdata$x:00002170 ; Segment permissions: Read
.xdata$x:00002170 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002170                 assume cs:_xdata$x
.xdata$x:00002170                 ;org 2170h
.xdata$x:00002170 ; COMDAT (pick associative to section at 9A8)
.xdata$x:00002170 __unwindtable$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00002170                                         ; DATA XREF: .xdata$x:00002180o
.xdata$x:00002171                 db 0FFh
.xdata$x:00002172                 db 0FFh
.xdata$x:00002173                 db 0FFh
.xdata$x:00002174                 dd offset __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
.xdata$x:00002178 __ehfuncinfo$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00002178                                         ; DATA XREF: __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ+11o
.xdata$x:00002179                 db    5
.xdata$x:0000217A                 db  93h ; ô
.xdata$x:0000217B                 db  19h
.xdata$x:0000217C                 db    1
.xdata$x:0000217D                 db    0
.xdata$x:0000217E                 db    0
.xdata$x:0000217F                 db    0
.xdata$x:00002180                 dd offset __unwindtable$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.xdata$x:00002184                 db    0
.xdata$x:00002185                 db    0
.xdata$x:00002186                 db    0
.xdata$x:00002187                 db    0
.xdata$x:00002188                 db    0
.xdata$x:00002189                 db    0
.xdata$x:0000218A                 db    0
.xdata$x:0000218B                 db    0
.xdata$x:0000218C                 db    0
.xdata$x:0000218D                 db    0
.xdata$x:0000218E                 db    0
.xdata$x:0000218F                 db    0
.xdata$x:00002190                 db    0
.xdata$x:00002191                 db    0
.xdata$x:00002192                 db    0
.xdata$x:00002193                 db    0
.xdata$x:00002194                 db    0
.xdata$x:00002195                 db    0
.xdata$x:00002196                 db    0
.xdata$x:00002197                 db    0
.xdata$x:00002198                 db    0
.xdata$x:00002199                 db    0
.xdata$x:0000219A                 db    0
.xdata$x:0000219B                 db    0
.xdata$x:0000219B _xdata$x        ends
.xdata$x:0000219B
.xdata$x:0000219C ; ===========================================================================
.xdata$x:0000219C
.xdata$x:0000219C ; Segment type: Pure data
.xdata$x:0000219C ; Segment permissions: Read
.xdata$x:0000219C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000219C                 assume cs:_xdata$x
.xdata$x:0000219C                 ;org 219Ch
.xdata$x:0000219C ; COMDAT (pick associative to section at E84)
.xdata$x:0000219C __unwindtable$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000219C                                         ; DATA XREF: .xdata$x:000021ACo
.xdata$x:0000219D                 db 0FFh
.xdata$x:0000219E                 db 0FFh
.xdata$x:0000219F                 db 0FFh
.xdata$x:000021A0                 dd offset __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
.xdata$x:000021A4 __ehfuncinfo$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:000021A4                                         ; DATA XREF: __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ+11o
.xdata$x:000021A5                 db    5
.xdata$x:000021A6                 db  93h ; ô
.xdata$x:000021A7                 db  19h
.xdata$x:000021A8                 db    1
.xdata$x:000021A9                 db    0
.xdata$x:000021AA                 db    0
.xdata$x:000021AB                 db    0
.xdata$x:000021AC                 dd offset __unwindtable$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.xdata$x:000021B0                 db    0
.xdata$x:000021B1                 db    0
.xdata$x:000021B2                 db    0
.xdata$x:000021B3                 db    0
.xdata$x:000021B4                 db    0
.xdata$x:000021B5                 db    0
.xdata$x:000021B6                 db    0
.xdata$x:000021B7                 db    0
.xdata$x:000021B8                 db    0
.xdata$x:000021B9                 db    0
.xdata$x:000021BA                 db    0
.xdata$x:000021BB                 db    0
.xdata$x:000021BC                 db    0
.xdata$x:000021BD                 db    0
.xdata$x:000021BE                 db    0
.xdata$x:000021BF                 db    0
.xdata$x:000021C0                 db    0
.xdata$x:000021C1                 db    0
.xdata$x:000021C2                 db    0
.xdata$x:000021C3                 db    0
.xdata$x:000021C4                 db    0
.xdata$x:000021C5                 db    0
.xdata$x:000021C6                 db    0
.xdata$x:000021C7                 db    0
.xdata$x:000021C7 _xdata$x        ends
.xdata$x:000021C7
.xdata$x:000021C8 ; ===========================================================================
.xdata$x:000021C8
.xdata$x:000021C8 ; Segment type: Pure data
.xdata$x:000021C8 ; Segment permissions: Read
.xdata$x:000021C8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000021C8                 assume cs:_xdata$x
.xdata$x:000021C8                 ;org 21C8h
.xdata$x:000021C8 ; COMDAT (pick associative to section at 92C)
.xdata$x:000021C8 __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z db 0FFh
.xdata$x:000021C8                                         ; DATA XREF: .xdata$x:000021D8o
.xdata$x:000021C9                 db 0FFh
.xdata$x:000021CA                 db 0FFh
.xdata$x:000021CB                 db 0FFh
.xdata$x:000021CC                 dd offset __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0
.xdata$x:000021D0 __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z db  22h ; "
.xdata$x:000021D0                                         ; DATA XREF: __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z+11o
.xdata$x:000021D1                 db    5
.xdata$x:000021D2                 db  93h ; ô
.xdata$x:000021D3                 db  19h
.xdata$x:000021D4                 db    1
.xdata$x:000021D5                 db    0
.xdata$x:000021D6                 db    0
.xdata$x:000021D7                 db    0
.xdata$x:000021D8                 dd offset __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.xdata$x:000021DC                 db    0
.xdata$x:000021DD                 db    0
.xdata$x:000021DE                 db    0
.xdata$x:000021DF                 db    0
.xdata$x:000021E0                 db    0
.xdata$x:000021E1                 db    0
.xdata$x:000021E2                 db    0
.xdata$x:000021E3                 db    0
.xdata$x:000021E4                 db    0
.xdata$x:000021E5                 db    0
.xdata$x:000021E6                 db    0
.xdata$x:000021E7                 db    0
.xdata$x:000021E8                 db    0
.xdata$x:000021E9                 db    0
.xdata$x:000021EA                 db    0
.xdata$x:000021EB                 db    0
.xdata$x:000021EC                 db    0
.xdata$x:000021ED                 db    0
.xdata$x:000021EE                 db    0
.xdata$x:000021EF                 db    0
.xdata$x:000021F0                 db    0
.xdata$x:000021F1                 db    0
.xdata$x:000021F2                 db    0
.xdata$x:000021F3                 db    0
.xdata$x:000021F3 _xdata$x        ends
.xdata$x:000021F3
.xdata$x:000021F4 ; ===========================================================================
.xdata$x:000021F4
.xdata$x:000021F4 ; Segment type: Pure data
.xdata$x:000021F4 ; Segment permissions: Read
.xdata$x:000021F4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000021F4                 assume cs:_xdata$x
.xdata$x:000021F4                 ;org 21F4h
.xdata$x:000021F4 ; COMDAT (pick associative to section at E0C)
.xdata$x:000021F4 __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:000021F4                                         ; DATA XREF: .xdata$x:00002204o
.xdata$x:000021F5                 db 0FFh
.xdata$x:000021F6                 db 0FFh
.xdata$x:000021F7                 db 0FFh
.xdata$x:000021F8                 dd offset __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0
.xdata$x:000021FC __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:000021FC                                         ; DATA XREF: __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:000021FD                 db    5
.xdata$x:000021FE                 db  93h ; ô
.xdata$x:000021FF                 db  19h
.xdata$x:00002200                 db    1
.xdata$x:00002201                 db    0
.xdata$x:00002202                 db    0
.xdata$x:00002203                 db    0
.xdata$x:00002204                 dd offset __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.xdata$x:00002208                 align 20h
.xdata$x:00002208 _xdata$x        ends
.xdata$x:00002208
.xdata$x:00002220 ; ===========================================================================
.xdata$x:00002220
.xdata$x:00002220 ; Segment type: Pure data
.xdata$x:00002220 ; Segment permissions: Read
.xdata$x:00002220 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002220                 assume cs:_xdata$x
.xdata$x:00002220                 ;org 2220h
.xdata$x:00002220 ; COMDAT (pick associative to section at A68)
.xdata$x:00002220 __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z db 0FFh
.xdata$x:00002220                                         ; DATA XREF: .xdata$x:00002230o
.xdata$x:00002221                 db 0FFh
.xdata$x:00002222                 db 0FFh
.xdata$x:00002223                 db 0FFh
.xdata$x:00002224                 dd offset __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0
.xdata$x:00002228 __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z db  22h ; "
.xdata$x:00002228                                         ; DATA XREF: __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z+11o
.xdata$x:00002229                 db    5
.xdata$x:0000222A                 db  93h ; ô
.xdata$x:0000222B                 db  19h
.xdata$x:0000222C                 db    1
.xdata$x:0000222D                 db    0
.xdata$x:0000222E                 db    0
.xdata$x:0000222F                 db    0
.xdata$x:00002230                 dd offset __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.xdata$x:00002234                 db    0
.xdata$x:00002235                 db    0
.xdata$x:00002236                 db    0
.xdata$x:00002237                 db    0
.xdata$x:00002238                 db    0
.xdata$x:00002239                 db    0
.xdata$x:0000223A                 db    0
.xdata$x:0000223B                 db    0
.xdata$x:0000223C                 db    0
.xdata$x:0000223D                 db    0
.xdata$x:0000223E                 db    0
.xdata$x:0000223F                 db    0
.xdata$x:00002240                 db    0
.xdata$x:00002241                 db    0
.xdata$x:00002242                 db    0
.xdata$x:00002243                 db    0
.xdata$x:00002244                 db    0
.xdata$x:00002245                 db    0
.xdata$x:00002246                 db    0
.xdata$x:00002247                 db    0
.xdata$x:00002248                 db    0
.xdata$x:00002249                 db    0
.xdata$x:0000224A                 db    0
.xdata$x:0000224B                 db    0
.xdata$x:0000224B _xdata$x        ends
.xdata$x:0000224B
.xdata$x:0000224C ; ===========================================================================
.xdata$x:0000224C
.xdata$x:0000224C ; Segment type: Pure data
.xdata$x:0000224C ; Segment permissions: Read
.xdata$x:0000224C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000224C                 assume cs:_xdata$x
.xdata$x:0000224C                 ;org 224Ch
.xdata$x:0000224C ; COMDAT (pick associative to section at EF4)
.xdata$x:0000224C __unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db 0FFh
.xdata$x:0000224C                                         ; DATA XREF: .xdata$x:0000225Co
.xdata$x:0000224D                 db 0FFh
.xdata$x:0000224E                 db 0FFh
.xdata$x:0000224F                 db 0FFh
.xdata$x:00002250                 dd offset __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0
.xdata$x:00002254 __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db  22h ; "
.xdata$x:00002254                                         ; DATA XREF: __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ+11o
.xdata$x:00002255                 db    5
.xdata$x:00002256                 db  93h ; ô
.xdata$x:00002257                 db  19h
.xdata$x:00002258                 db    1
.xdata$x:00002259                 db    0
.xdata$x:0000225A                 db    0
.xdata$x:0000225B                 db    0
.xdata$x:0000225C                 dd offset __unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.xdata$x:00002260                 db    0
.xdata$x:00002261                 db    0
.xdata$x:00002262                 db    0
.xdata$x:00002263                 db    0
.xdata$x:00002264                 db    0
.xdata$x:00002265                 db    0
.xdata$x:00002266                 db    0
.xdata$x:00002267                 db    0
.xdata$x:00002268                 db    0
.xdata$x:00002269                 db    0
.xdata$x:0000226A                 db    0
.xdata$x:0000226B                 db    0
.xdata$x:0000226C                 db    0
.xdata$x:0000226D                 db    0
.xdata$x:0000226E                 db    0
.xdata$x:0000226F                 db    0
.xdata$x:00002270                 db    0
.xdata$x:00002271                 db    0
.xdata$x:00002272                 db    0
.xdata$x:00002273                 db    0
.xdata$x:00002274                 db    0
.xdata$x:00002275                 db    0
.xdata$x:00002276                 db    0
.xdata$x:00002277                 db    0
.xdata$x:00002277 _xdata$x        ends
.xdata$x:00002277
.xdata$x:00002278 ; ===========================================================================
.xdata$x:00002278
.xdata$x:00002278 ; Segment type: Pure data
.xdata$x:00002278 ; Segment permissions: Read
.xdata$x:00002278 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002278                 assume cs:_xdata$x
.xdata$x:00002278                 ;org 2278h
.xdata$x:00002278 ; COMDAT (pick associative to section at 1408)
.xdata$x:00002278 __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 db    0
.xdata$x:00002278                                         ; DATA XREF: .xdata$x:00002300o
.xdata$x:00002279                 db    0
.xdata$x:0000227A                 db    0
.xdata$x:0000227B                 db    0
.xdata$x:0000227C                 db    0
.xdata$x:0000227D                 db    0
.xdata$x:0000227E                 db    0
.xdata$x:0000227F                 db    0
.xdata$x:00002280                 db    0
.xdata$x:00002281                 db    0
.xdata$x:00002282                 db    0
.xdata$x:00002283                 db    0
.xdata$x:00002284                 dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.xdata$x:00002288 __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 db    0
.xdata$x:00002288                                         ; DATA XREF: .xdata$x:000022ECo
.xdata$x:00002289                 db    0
.xdata$x:0000228A                 db    0
.xdata$x:0000228B                 db    0
.xdata$x:0000228C                 db    0
.xdata$x:0000228D                 db    0
.xdata$x:0000228E                 db    0
.xdata$x:0000228F                 db    0
.xdata$x:00002290                 db    0
.xdata$x:00002291                 db    0
.xdata$x:00002292                 db    0
.xdata$x:00002293                 db    0
.xdata$x:00002294                 dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
.xdata$x:00002298 __unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db 0FFh
.xdata$x:00002298                                         ; DATA XREF: .xdata$x:000022C0o
.xdata$x:00002299                 db 0FFh
.xdata$x:0000229A                 db 0FFh
.xdata$x:0000229B                 db 0FFh
.xdata$x:0000229C                 db    0
.xdata$x:0000229D                 db    0
.xdata$x:0000229E                 db    0
.xdata$x:0000229F                 db    0
.xdata$x:000022A0                 db 0FFh
.xdata$x:000022A1                 db 0FFh
.xdata$x:000022A2                 db 0FFh
.xdata$x:000022A3                 db 0FFh
.xdata$x:000022A4                 db    0
.xdata$x:000022A5                 db    0
.xdata$x:000022A6                 db    0
.xdata$x:000022A7                 db    0
.xdata$x:000022A8                 db    1
.xdata$x:000022A9                 db    0
.xdata$x:000022AA                 db    0
.xdata$x:000022AB                 db    0
.xdata$x:000022AC                 db    0
.xdata$x:000022AD                 db    0
.xdata$x:000022AE                 db    0
.xdata$x:000022AF                 db    0
.xdata$x:000022B0                 db    1
.xdata$x:000022B1                 db    0
.xdata$x:000022B2                 db    0
.xdata$x:000022B3                 db    0
.xdata$x:000022B4                 db    0
.xdata$x:000022B5                 db    0
.xdata$x:000022B6                 db    0
.xdata$x:000022B7                 db    0
.xdata$x:000022B8 __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db  22h ; "
.xdata$x:000022B8                                         ; DATA XREF: __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z+11o
.xdata$x:000022B9                 db    5
.xdata$x:000022BA                 db  93h ; ô
.xdata$x:000022BB                 db  19h
.xdata$x:000022BC                 db    4
.xdata$x:000022BD                 db    0
.xdata$x:000022BE                 db    0
.xdata$x:000022BF                 db    0
.xdata$x:000022C0                 dd offset __unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.xdata$x:000022C4                 db    2
.xdata$x:000022C5                 db    0
.xdata$x:000022C6                 db    0
.xdata$x:000022C7                 db    0
.xdata$x:000022C8                 dd offset __tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.xdata$x:000022CC                 db    0
.xdata$x:000022CD                 db    0
.xdata$x:000022CE                 db    0
.xdata$x:000022CF                 db    0
.xdata$x:000022D0                 db    0
.xdata$x:000022D1                 db    0
.xdata$x:000022D2                 db    0
.xdata$x:000022D3                 db    0
.xdata$x:000022D4                 db    0
.xdata$x:000022D5                 db    0
.xdata$x:000022D6                 db    0
.xdata$x:000022D7                 db    0
.xdata$x:000022D8                 db    0
.xdata$x:000022D9                 db    0
.xdata$x:000022DA                 db    0
.xdata$x:000022DB                 db    0
.xdata$x:000022DC __tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db    2
.xdata$x:000022DC                                         ; DATA XREF: .xdata$x:000022C8o
.xdata$x:000022DD                 db    0
.xdata$x:000022DE                 db    0
.xdata$x:000022DF                 db    0
.xdata$x:000022E0                 db    2
.xdata$x:000022E1                 db    0
.xdata$x:000022E2                 db    0
.xdata$x:000022E3                 db    0
.xdata$x:000022E4                 db    3
.xdata$x:000022E5                 db    0
.xdata$x:000022E6                 db    0
.xdata$x:000022E7                 db    0
.xdata$x:000022E8                 db    1
.xdata$x:000022E9                 db    0
.xdata$x:000022EA                 db    0
.xdata$x:000022EB                 db    0
.xdata$x:000022EC                 dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
.xdata$x:000022F0                 db    0
.xdata$x:000022F1                 db    0
.xdata$x:000022F2                 db    0
.xdata$x:000022F3                 db    0
.xdata$x:000022F4                 db    0
.xdata$x:000022F5                 db    0
.xdata$x:000022F6                 db    0
.xdata$x:000022F7                 db    0
.xdata$x:000022F8                 db    3
.xdata$x:000022F9                 db    0
.xdata$x:000022FA                 db    0
.xdata$x:000022FB                 db    0
.xdata$x:000022FC                 db    1
.xdata$x:000022FD                 db    0
.xdata$x:000022FE                 db    0
.xdata$x:000022FF                 db    0
.xdata$x:00002300                 dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
.xdata$x:00002300 _xdata$x        ends
.xdata$x:00002300
.xdata$x:00002304 ; ===========================================================================
.xdata$x:00002304
.xdata$x:00002304 ; Segment type: Pure data
.xdata$x:00002304 ; Segment permissions: Read
.xdata$x:00002304 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002304                 assume cs:_xdata$x
.xdata$x:00002304                 ;org 2304h
.xdata$x:00002304 ; COMDAT (pick associative to section at D88)
.xdata$x:00002304 __unwindtable$??0runtime_error@std@@QAE@PBD@Z db 0FFh
.xdata$x:00002304                                         ; DATA XREF: .xdata$x:00002314o
.xdata$x:00002305                 db 0FFh
.xdata$x:00002306                 db 0FFh
.xdata$x:00002307                 db 0FFh
.xdata$x:00002308                 dd offset __unwindfunclet$??0runtime_error@std@@QAE@PBD@Z$0
.xdata$x:0000230C __ehfuncinfo$??0runtime_error@std@@QAE@PBD@Z db  22h ; "
.xdata$x:0000230C                                         ; DATA XREF: __ehhandler$??0runtime_error@std@@QAE@PBD@Z+11o
.xdata$x:0000230D                 db    5
.xdata$x:0000230E                 db  93h ; ô
.xdata$x:0000230F                 db  19h
.xdata$x:00002310                 db    1
.xdata$x:00002311                 db    0
.xdata$x:00002312                 db    0
.xdata$x:00002313                 db    0
.xdata$x:00002314                 dd offset __unwindtable$??0runtime_error@std@@QAE@PBD@Z
.xdata$x:00002318                 db    0
.xdata$x:00002319                 db    0
.xdata$x:0000231A                 db    0
.xdata$x:0000231B                 db    0
.xdata$x:0000231C                 db    0
.xdata$x:0000231D                 db    0
.xdata$x:0000231E                 db    0
.xdata$x:0000231F                 db    0
.xdata$x:00002320                 db    0
.xdata$x:00002321                 db    0
.xdata$x:00002322                 db    0
.xdata$x:00002323                 db    0
.xdata$x:00002324                 db    0
.xdata$x:00002325                 db    0
.xdata$x:00002326                 db    0
.xdata$x:00002327                 db    0
.xdata$x:00002328                 db    0
.xdata$x:00002329                 db    0
.xdata$x:0000232A                 db    0
.xdata$x:0000232B                 db    0
.xdata$x:0000232C                 db    0
.xdata$x:0000232D                 db    0
.xdata$x:0000232E                 db    0
.xdata$x:0000232F                 db    0
.xdata$x:0000232F _xdata$x        ends
.xdata$x:0000232F
.xdata$x:00002330 ; ===========================================================================
.xdata$x:00002330
.xdata$x:00002330 ; Segment type: Pure data
.xdata$x:00002330 ; Segment permissions: Read
.xdata$x:00002330 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002330                 assume cs:_xdata$x
.xdata$x:00002330                 ;org 2330h
.xdata$x:00002330 ; COMDAT (pick associative to section at 10E8)
.xdata$x:00002330 __unwindtable$??1runtime_error@std@@UAE@XZ db 0FFh
.xdata$x:00002330                                         ; DATA XREF: .xdata$x:00002340o
.xdata$x:00002331                 db 0FFh
.xdata$x:00002332                 db 0FFh
.xdata$x:00002333                 db 0FFh
.xdata$x:00002334                 dd offset __unwindfunclet$??1runtime_error@std@@UAE@XZ$0
.xdata$x:00002338 __ehfuncinfo$??1runtime_error@std@@UAE@XZ db  22h ; "
.xdata$x:00002338                                         ; DATA XREF: __ehhandler$??1runtime_error@std@@UAE@XZ+11o
.xdata$x:00002339                 db    5
.xdata$x:0000233A                 db  93h ; ô
.xdata$x:0000233B                 db  19h
.xdata$x:0000233C                 db    1
.xdata$x:0000233D                 db    0
.xdata$x:0000233E                 db    0
.xdata$x:0000233F                 db    0
.xdata$x:00002340                 dd offset __unwindtable$??1runtime_error@std@@UAE@XZ
.xdata$x:00002344                 db    0
.xdata$x:00002345                 db    0
.xdata$x:00002346                 db    0
.xdata$x:00002347                 db    0
.xdata$x:00002348                 db    0
.xdata$x:00002349                 db    0
.xdata$x:0000234A                 db    0
.xdata$x:0000234B                 db    0
.xdata$x:0000234C                 db    0
.xdata$x:0000234D                 db    0
.xdata$x:0000234E                 db    0
.xdata$x:0000234F                 db    0
.xdata$x:00002350                 db    0
.xdata$x:00002351                 db    0
.xdata$x:00002352                 db    0
.xdata$x:00002353                 db    0
.xdata$x:00002354                 db    0
.xdata$x:00002355                 db    0
.xdata$x:00002356                 db    0
.xdata$x:00002357                 db    0
.xdata$x:00002358                 db    0
.xdata$x:00002359                 db    0
.xdata$x:0000235A                 db    0
.xdata$x:0000235B                 db    0
.xdata$x:0000235B _xdata$x        ends
.xdata$x:0000235B
.xdata$x:0000235C ; ===========================================================================
.xdata$x:0000235C
.xdata$x:0000235C ; Segment type: Pure data
.xdata$x:0000235C ; Segment permissions: Read
.xdata$x:0000235C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000235C                 assume cs:_xdata$x
.xdata$x:0000235C                 ;org 235Ch
.xdata$x:0000235C ; COMDAT (pick associative to section at D04)
.xdata$x:0000235C __unwindtable$??0runtime_error@std@@QAE@ABV01@@Z db 0FFh
.xdata$x:0000235C                                         ; DATA XREF: .xdata$x:0000236Co
.xdata$x:0000235D                 db 0FFh
.xdata$x:0000235E                 db 0FFh
.xdata$x:0000235F                 db 0FFh
.xdata$x:00002360                 dd offset __unwindfunclet$??0runtime_error@std@@QAE@ABV01@@Z$0
.xdata$x:00002364 __ehfuncinfo$??0runtime_error@std@@QAE@ABV01@@Z db  22h ; "
.xdata$x:00002364                                         ; DATA XREF: __ehhandler$??0runtime_error@std@@QAE@ABV01@@Z+11o
.xdata$x:00002365                 db    5
.xdata$x:00002366                 db  93h ; ô
.xdata$x:00002367                 db  19h
.xdata$x:00002368                 db    1
.xdata$x:00002369                 db    0
.xdata$x:0000236A                 db    0
.xdata$x:0000236B                 db    0
.xdata$x:0000236C                 dd offset __unwindtable$??0runtime_error@std@@QAE@ABV01@@Z
.xdata$x:00002370                 db    0
.xdata$x:00002371                 db    0
.xdata$x:00002372                 db    0
.xdata$x:00002373                 db    0
.xdata$x:00002374                 db    0
.xdata$x:00002375                 db    0
.xdata$x:00002376                 db    0
.xdata$x:00002377                 db    0
.xdata$x:00002378                 db    0
.xdata$x:00002379                 db    0
.xdata$x:0000237A                 db    0
.xdata$x:0000237B                 db    0
.xdata$x:0000237C                 db    0
.xdata$x:0000237D                 db    0
.xdata$x:0000237E                 db    0
.xdata$x:0000237F                 db    0
.xdata$x:00002380                 db    0
.xdata$x:00002381                 db    0
.xdata$x:00002382                 db    0
.xdata$x:00002383                 db    0
.xdata$x:00002384                 db    0
.xdata$x:00002385                 db    0
.xdata$x:00002386                 db    0
.xdata$x:00002387                 db    0
.xdata$x:00002387 _xdata$x        ends
.xdata$x:00002387
.xdata$x:00002388 ; ===========================================================================
.xdata$x:00002388
.xdata$x:00002388 ; Segment type: Pure data
.xdata$x:00002388 ; Segment permissions: Read
.xdata$x:00002388 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002388                 assume cs:_xdata$x
.xdata$x:00002388                 ;org 2388h
.xdata$x:00002388 ; COMDAT (pick associative to section at B3C)
.xdata$x:00002388 __unwindtable$??0_Generic_error_category@std@@QAE@XZ db 0FFh
.xdata$x:00002388                                         ; DATA XREF: .xdata$x:00002398o
.xdata$x:00002389                 db 0FFh
.xdata$x:0000238A                 db 0FFh
.xdata$x:0000238B                 db 0FFh
.xdata$x:0000238C                 dd offset __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0
.xdata$x:00002390 __ehfuncinfo$??0_Generic_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:00002390                                         ; DATA XREF: __ehhandler$??0_Generic_error_category@std@@QAE@XZ+11o
.xdata$x:00002391                 db    5
.xdata$x:00002392                 db  93h ; ô
.xdata$x:00002393                 db  19h
.xdata$x:00002394                 db    1
.xdata$x:00002395                 db    0
.xdata$x:00002396                 db    0
.xdata$x:00002397                 db    0
.xdata$x:00002398                 dd offset __unwindtable$??0_Generic_error_category@std@@QAE@XZ
.xdata$x:0000239C                 db    0
.xdata$x:0000239D                 db    0
.xdata$x:0000239E                 db    0
.xdata$x:0000239F                 db    0
.xdata$x:000023A0                 db    0
.xdata$x:000023A1                 db    0
.xdata$x:000023A2                 db    0
.xdata$x:000023A3                 db    0
.xdata$x:000023A4                 db    0
.xdata$x:000023A5                 db    0
.xdata$x:000023A6                 db    0
.xdata$x:000023A7                 db    0
.xdata$x:000023A8                 db    0
.xdata$x:000023A9                 db    0
.xdata$x:000023AA                 db    0
.xdata$x:000023AB                 db    0
.xdata$x:000023AC                 db    0
.xdata$x:000023AD                 db    0
.xdata$x:000023AE                 db    0
.xdata$x:000023AF                 db    0
.xdata$x:000023B0                 db    0
.xdata$x:000023B1                 db    0
.xdata$x:000023B2                 db    0
.xdata$x:000023B3                 db    0
.xdata$x:000023B3 _xdata$x        ends
.xdata$x:000023B3
.xdata$x:000023B4 ; ===========================================================================
.xdata$x:000023B4
.xdata$x:000023B4 ; Segment type: Pure data
.xdata$x:000023B4 ; Segment permissions: Read
.xdata$x:000023B4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000023B4                 assume cs:_xdata$x
.xdata$x:000023B4                 ;org 23B4h
.xdata$x:000023B4 ; COMDAT (pick associative to section at 1E48)
.xdata$x:000023B4 __unwindtable$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:000023B4                                         ; DATA XREF: .xdata$x:000023C4o
.xdata$x:000023B5                 db 0FFh
.xdata$x:000023B6                 db 0FFh
.xdata$x:000023B7                 db 0FFh
.xdata$x:000023B8                 dd offset __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:000023BC __ehfuncinfo$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:000023BC                                         ; DATA XREF: __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:000023BD                 db    5
.xdata$x:000023BE                 db  93h ; ô
.xdata$x:000023BF                 db  19h
.xdata$x:000023C0                 db    1
.xdata$x:000023C1                 db    0
.xdata$x:000023C2                 db    0
.xdata$x:000023C3                 db    0
.xdata$x:000023C4                 dd offset __unwindtable$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:000023C8                 align 20h
.xdata$x:000023C8 _xdata$x        ends
.xdata$x:000023C8
.xdata$x:000023E0 ; ===========================================================================
.xdata$x:000023E0
.xdata$x:000023E0 ; Segment type: Pure data
.xdata$x:000023E0 ; Segment permissions: Read
.xdata$x:000023E0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000023E0                 assume cs:_xdata$x
.xdata$x:000023E0                 ;org 23E0h
.xdata$x:000023E0 ; COMDAT (pick associative to section at F84)
.xdata$x:000023E0 __unwindtable$??1_Generic_error_category@std@@UAE@XZ db 0FFh
.xdata$x:000023E0                                         ; DATA XREF: .xdata$x:000023F0o
.xdata$x:000023E1                 db 0FFh
.xdata$x:000023E2                 db 0FFh
.xdata$x:000023E3                 db 0FFh
.xdata$x:000023E4                 dd offset __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0
.xdata$x:000023E8 __ehfuncinfo$??1_Generic_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:000023E8                                         ; DATA XREF: __ehhandler$??1_Generic_error_category@std@@UAE@XZ+11o
.xdata$x:000023E9                 db    5
.xdata$x:000023EA                 db  93h ; ô
.xdata$x:000023EB                 db  19h
.xdata$x:000023EC                 db    1
.xdata$x:000023ED                 db    0
.xdata$x:000023EE                 db    0
.xdata$x:000023EF                 db    0
.xdata$x:000023F0                 dd offset __unwindtable$??1_Generic_error_category@std@@UAE@XZ
.xdata$x:000023F4                 db    0
.xdata$x:000023F5                 db    0
.xdata$x:000023F6                 db    0
.xdata$x:000023F7                 db    0
.xdata$x:000023F8                 db    0
.xdata$x:000023F9                 db    0
.xdata$x:000023FA                 db    0
.xdata$x:000023FB                 db    0
.xdata$x:000023FC                 db    0
.xdata$x:000023FD                 db    0
.xdata$x:000023FE                 db    0
.xdata$x:000023FF                 db    0
.xdata$x:00002400                 db    0
.xdata$x:00002401                 db    0
.xdata$x:00002402                 db    0
.xdata$x:00002403                 db    0
.xdata$x:00002404                 db    0
.xdata$x:00002405                 db    0
.xdata$x:00002406                 db    0
.xdata$x:00002407                 db    0
.xdata$x:00002408                 db    0
.xdata$x:00002409                 db    0
.xdata$x:0000240A                 db    0
.xdata$x:0000240B                 db    0
.xdata$x:0000240B _xdata$x        ends
.xdata$x:0000240B
.xdata$x:0000240C ; ===========================================================================
.xdata$x:0000240C
.xdata$x:0000240C ; Segment type: Pure data
.xdata$x:0000240C ; Segment permissions: Read
.xdata$x:0000240C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000240C                 assume cs:_xdata$x
.xdata$x:0000240C                 ;org 240Ch
.xdata$x:0000240C ; COMDAT (pick associative to section at BB8)
.xdata$x:0000240C __unwindtable$??0_Iostream_error_category@std@@QAE@XZ db 0FFh
.xdata$x:0000240C                                         ; DATA XREF: .xdata$x:0000241Co
.xdata$x:0000240D                 db 0FFh
.xdata$x:0000240E                 db 0FFh
.xdata$x:0000240F                 db 0FFh
.xdata$x:00002410                 dd offset __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0
.xdata$x:00002414 __ehfuncinfo$??0_Iostream_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:00002414                                         ; DATA XREF: __ehhandler$??0_Iostream_error_category@std@@QAE@XZ+11o
.xdata$x:00002415                 db    5
.xdata$x:00002416                 db  93h ; ô
.xdata$x:00002417                 db  19h
.xdata$x:00002418                 db    1
.xdata$x:00002419                 db    0
.xdata$x:0000241A                 db    0
.xdata$x:0000241B                 db    0
.xdata$x:0000241C                 dd offset __unwindtable$??0_Iostream_error_category@std@@QAE@XZ
.xdata$x:00002420                 db    0
.xdata$x:00002421                 db    0
.xdata$x:00002422                 db    0
.xdata$x:00002423                 db    0
.xdata$x:00002424                 db    0
.xdata$x:00002425                 db    0
.xdata$x:00002426                 db    0
.xdata$x:00002427                 db    0
.xdata$x:00002428                 db    0
.xdata$x:00002429                 db    0
.xdata$x:0000242A                 db    0
.xdata$x:0000242B                 db    0
.xdata$x:0000242C                 db    0
.xdata$x:0000242D                 db    0
.xdata$x:0000242E                 db    0
.xdata$x:0000242F                 db    0
.xdata$x:00002430                 db    0
.xdata$x:00002431                 db    0
.xdata$x:00002432                 db    0
.xdata$x:00002433                 db    0
.xdata$x:00002434                 db    0
.xdata$x:00002435                 db    0
.xdata$x:00002436                 db    0
.xdata$x:00002437                 db    0
.xdata$x:00002437 _xdata$x        ends
.xdata$x:00002437
.xdata$x:00002438 ; ===========================================================================
.xdata$x:00002438
.xdata$x:00002438 ; Segment type: Pure data
.xdata$x:00002438 ; Segment permissions: Read
.xdata$x:00002438 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002438                 assume cs:_xdata$x
.xdata$x:00002438                 ;org 2438h
.xdata$x:00002438 ; COMDAT (pick associative to section at 1F00)
.xdata$x:00002438 __unwindtable$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:00002438                                         ; DATA XREF: .xdata$x:00002448o
.xdata$x:00002439                 db 0FFh
.xdata$x:0000243A                 db 0FFh
.xdata$x:0000243B                 db 0FFh
.xdata$x:0000243C                 dd offset __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:00002440 __ehfuncinfo$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:00002440                                         ; DATA XREF: __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:00002441                 db    5
.xdata$x:00002442                 db  93h ; ô
.xdata$x:00002443                 db  19h
.xdata$x:00002444                 db    1
.xdata$x:00002445                 db    0
.xdata$x:00002446                 db    0
.xdata$x:00002447                 db    0
.xdata$x:00002448                 dd offset __unwindtable$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:0000244C                 db    0
.xdata$x:0000244D                 db    0
.xdata$x:0000244E                 db    0
.xdata$x:0000244F                 db    0
.xdata$x:00002450                 db    0
.xdata$x:00002451                 db    0
.xdata$x:00002452                 db    0
.xdata$x:00002453                 db    0
.xdata$x:00002454                 db    0
.xdata$x:00002455                 db    0
.xdata$x:00002456                 db    0
.xdata$x:00002457                 db    0
.xdata$x:00002458                 db    0
.xdata$x:00002459                 db    0
.xdata$x:0000245A                 db    0
.xdata$x:0000245B                 db    0
.xdata$x:0000245C                 db    0
.xdata$x:0000245D                 db    0
.xdata$x:0000245E                 db    0
.xdata$x:0000245F                 db    0
.xdata$x:00002460                 db    0
.xdata$x:00002461                 db    0
.xdata$x:00002462                 db    0
.xdata$x:00002463                 db    0
.xdata$x:00002463 _xdata$x        ends
.xdata$x:00002463
.xdata$x:00002464 ; ===========================================================================
.xdata$x:00002464
.xdata$x:00002464 ; Segment type: Pure data
.xdata$x:00002464 ; Segment permissions: Read
.xdata$x:00002464 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002464                 assume cs:_xdata$x
.xdata$x:00002464                 ;org 2464h
.xdata$x:00002464 ; COMDAT (pick associative to section at FF4)
.xdata$x:00002464 __unwindtable$??1_Iostream_error_category@std@@UAE@XZ db 0FFh
.xdata$x:00002464                                         ; DATA XREF: .xdata$x:00002474o
.xdata$x:00002465                 db 0FFh
.xdata$x:00002466                 db 0FFh
.xdata$x:00002467                 db 0FFh
.xdata$x:00002468                 dd offset __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0
.xdata$x:0000246C __ehfuncinfo$??1_Iostream_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:0000246C                                         ; DATA XREF: __ehhandler$??1_Iostream_error_category@std@@UAE@XZ+11o
.xdata$x:0000246D                 db    5
.xdata$x:0000246E                 db  93h ; ô
.xdata$x:0000246F                 db  19h
.xdata$x:00002470                 db    1
.xdata$x:00002471                 db    0
.xdata$x:00002472                 db    0
.xdata$x:00002473                 db    0
.xdata$x:00002474                 dd offset __unwindtable$??1_Iostream_error_category@std@@UAE@XZ
.xdata$x:00002478                 db    0
.xdata$x:00002479                 db    0
.xdata$x:0000247A                 db    0
.xdata$x:0000247B                 db    0
.xdata$x:0000247C                 db    0
.xdata$x:0000247D                 db    0
.xdata$x:0000247E                 db    0
.xdata$x:0000247F                 db    0
.xdata$x:00002480                 db    0
.xdata$x:00002481                 db    0
.xdata$x:00002482                 db    0
.xdata$x:00002483                 db    0
.xdata$x:00002484                 db    0
.xdata$x:00002485                 db    0
.xdata$x:00002486                 db    0
.xdata$x:00002487                 db    0
.xdata$x:00002488                 db    0
.xdata$x:00002489                 db    0
.xdata$x:0000248A                 db    0
.xdata$x:0000248B                 db    0
.xdata$x:0000248C                 db    0
.xdata$x:0000248D                 db    0
.xdata$x:0000248E                 db    0
.xdata$x:0000248F                 db    0
.xdata$x:0000248F _xdata$x        ends
.xdata$x:0000248F
.xdata$x:00002490 ; ===========================================================================
.xdata$x:00002490
.xdata$x:00002490 ; Segment type: Pure data
.xdata$x:00002490 ; Segment permissions: Read
.xdata$x:00002490 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002490                 assume cs:_xdata$x
.xdata$x:00002490                 ;org 2490h
.xdata$x:00002490 ; COMDAT (pick associative to section at C34)
.xdata$x:00002490 __unwindtable$??0_System_error_category@std@@QAE@XZ db 0FFh
.xdata$x:00002490                                         ; DATA XREF: .xdata$x:000024A0o
.xdata$x:00002491                 db 0FFh
.xdata$x:00002492                 db 0FFh
.xdata$x:00002493                 db 0FFh
.xdata$x:00002494                 dd offset __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0
.xdata$x:00002498 __ehfuncinfo$??0_System_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:00002498                                         ; DATA XREF: __ehhandler$??0_System_error_category@std@@QAE@XZ+11o
.xdata$x:00002499                 db    5
.xdata$x:0000249A                 db  93h ; ô
.xdata$x:0000249B                 db  19h
.xdata$x:0000249C                 db    1
.xdata$x:0000249D                 db    0
.xdata$x:0000249E                 db    0
.xdata$x:0000249F                 db    0
.xdata$x:000024A0                 dd offset __unwindtable$??0_System_error_category@std@@QAE@XZ
.xdata$x:000024A4                 db    0
.xdata$x:000024A5                 db    0
.xdata$x:000024A6                 db    0
.xdata$x:000024A7                 db    0
.xdata$x:000024A8                 db    0
.xdata$x:000024A9                 db    0
.xdata$x:000024AA                 db    0
.xdata$x:000024AB                 db    0
.xdata$x:000024AC                 db    0
.xdata$x:000024AD                 db    0
.xdata$x:000024AE                 db    0
.xdata$x:000024AF                 db    0
.xdata$x:000024B0                 db    0
.xdata$x:000024B1                 db    0
.xdata$x:000024B2                 db    0
.xdata$x:000024B3                 db    0
.xdata$x:000024B4                 db    0
.xdata$x:000024B5                 db    0
.xdata$x:000024B6                 db    0
.xdata$x:000024B7                 db    0
.xdata$x:000024B8                 db    0
.xdata$x:000024B9                 db    0
.xdata$x:000024BA                 db    0
.xdata$x:000024BB                 db    0
.xdata$x:000024BB _xdata$x        ends
.xdata$x:000024BB
.xdata$x:000024BC ; ===========================================================================
.xdata$x:000024BC
.xdata$x:000024BC ; Segment type: Pure data
.xdata$x:000024BC ; Segment permissions: Read
.xdata$x:000024BC _xdata$x        segment dword public 'DATA' use32
.xdata$x:000024BC                 assume cs:_xdata$x
.xdata$x:000024BC                 ;org 24BCh
.xdata$x:000024BC ; COMDAT (pick associative to section at 1FC4)
.xdata$x:000024BC __unwindtable$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:000024BC                                         ; DATA XREF: .xdata$x:000024CCo
.xdata$x:000024BD                 db 0FFh
.xdata$x:000024BE                 db 0FFh
.xdata$x:000024BF                 db 0FFh
.xdata$x:000024C0                 dd offset __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:000024C4 __ehfuncinfo$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:000024C4                                         ; DATA XREF: __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:000024C5                 db    5
.xdata$x:000024C6                 db  93h ; ô
.xdata$x:000024C7                 db  19h
.xdata$x:000024C8                 db    1
.xdata$x:000024C9                 db    0
.xdata$x:000024CA                 db    0
.xdata$x:000024CB                 db    0
.xdata$x:000024CC                 dd offset __unwindtable$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:000024D0                 db    0
.xdata$x:000024D1                 db    0
.xdata$x:000024D2                 db    0
.xdata$x:000024D3                 db    0
.xdata$x:000024D4                 db    0
.xdata$x:000024D5                 db    0
.xdata$x:000024D6                 db    0
.xdata$x:000024D7                 db    0
.xdata$x:000024D8                 db    0
.xdata$x:000024D9                 db    0
.xdata$x:000024DA                 db    0
.xdata$x:000024DB                 db    0
.xdata$x:000024DC                 db    0
.xdata$x:000024DD                 db    0
.xdata$x:000024DE                 db    0
.xdata$x:000024DF                 db    0
.xdata$x:000024E0                 db    0
.xdata$x:000024E1                 db    0
.xdata$x:000024E2                 db    0
.xdata$x:000024E3                 db    0
.xdata$x:000024E4                 db    0
.xdata$x:000024E5                 db    0
.xdata$x:000024E6                 db    0
.xdata$x:000024E7                 db    0
.xdata$x:000024E7 _xdata$x        ends
.xdata$x:000024E7
.xdata$x:000024E8 ; ===========================================================================
.xdata$x:000024E8
.xdata$x:000024E8 ; Segment type: Pure data
.xdata$x:000024E8 ; Segment permissions: Read
.xdata$x:000024E8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000024E8                 assume cs:_xdata$x
.xdata$x:000024E8                 ;org 24E8h
.xdata$x:000024E8 ; COMDAT (pick associative to section at 1064)
.xdata$x:000024E8 __unwindtable$??1_System_error_category@std@@UAE@XZ db 0FFh
.xdata$x:000024E8                                         ; DATA XREF: .xdata$x:000024F8o
.xdata$x:000024E9                 db 0FFh
.xdata$x:000024EA                 db 0FFh
.xdata$x:000024EB                 db 0FFh
.xdata$x:000024EC                 dd offset __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0
.xdata$x:000024F0 __ehfuncinfo$??1_System_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:000024F0                                         ; DATA XREF: __ehhandler$??1_System_error_category@std@@UAE@XZ+11o
.xdata$x:000024F1                 db    5
.xdata$x:000024F2                 db  93h ; ô
.xdata$x:000024F3                 db  19h
.xdata$x:000024F4                 db    1
.xdata$x:000024F5                 db    0
.xdata$x:000024F6                 db    0
.xdata$x:000024F7                 db    0
.xdata$x:000024F8                 dd offset __unwindtable$??1_System_error_category@std@@UAE@XZ
.xdata$x:000024FC                 db    0
.xdata$x:000024FD                 db    0
.xdata$x:000024FE                 db    0
.xdata$x:000024FF                 db    0
.xdata$x:00002500                 db    0
.xdata$x:00002501                 db    0
.xdata$x:00002502                 db    0
.xdata$x:00002503                 db    0
.xdata$x:00002504                 db    0
.xdata$x:00002505                 db    0
.xdata$x:00002506                 db    0
.xdata$x:00002507                 db    0
.xdata$x:00002508                 db    0
.xdata$x:00002509                 db    0
.xdata$x:0000250A                 db    0
.xdata$x:0000250B                 db    0
.xdata$x:0000250C                 db    0
.xdata$x:0000250D                 db    0
.xdata$x:0000250E                 db    0
.xdata$x:0000250F                 db    0
.xdata$x:00002510                 db    0
.xdata$x:00002511                 db    0
.xdata$x:00002512                 db    0
.xdata$x:00002513                 db    0
.xdata$x:00002513 _xdata$x        ends
.xdata$x:00002513
.xdata$x:00002514 ; ===========================================================================
.xdata$x:00002514
.xdata$x:00002514 ; Segment type: Pure data
.xdata$x:00002514 ; Segment permissions: Read
.xdata$x:00002514 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002514                 assume cs:_xdata$x
.xdata$x:00002514                 ;org 2514h
.xdata$x:00002514 ; COMDAT (pick associative to section at 810)
.xdata$x:00002514 __unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z db 0FFh
.xdata$x:00002514                                         ; DATA XREF: .xdata$x:00002524o
.xdata$x:00002515                 db 0FFh
.xdata$x:00002516                 db 0FFh
.xdata$x:00002517                 db 0FFh
.xdata$x:00002518                 dd offset __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0
.xdata$x:0000251C __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z db  22h ; "
.xdata$x:0000251C                                         ; DATA XREF: __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z+11o
.xdata$x:0000251D                 db    5
.xdata$x:0000251E                 db  93h ; ô
.xdata$x:0000251F                 db  19h
.xdata$x:00002520                 db    1
.xdata$x:00002521                 db    0
.xdata$x:00002522                 db    0
.xdata$x:00002523                 db    0
.xdata$x:00002524                 dd offset __unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.xdata$x:00002528                 align 20h
.xdata$x:00002528 _xdata$x        ends
.xdata$x:00002528
.xdata$x:00002540 ; ===========================================================================
.xdata$x:00002540
.xdata$x:00002540 ; Segment type: Pure data
.xdata$x:00002540 ; Segment permissions: Read
.xdata$x:00002540 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002540                 assume cs:_xdata$x
.xdata$x:00002540                 ;org 2540h
.xdata$x:00002540 ; COMDAT (pick associative to section at 73C)
.xdata$x:00002540 __unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z db 0FFh
.xdata$x:00002540                                         ; DATA XREF: .xdata$x:00002550o
.xdata$x:00002541                 db 0FFh
.xdata$x:00002542                 db 0FFh
.xdata$x:00002543                 db 0FFh
.xdata$x:00002544                 dd offset __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0
.xdata$x:00002548 __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z db  22h ; "
.xdata$x:00002548                                         ; DATA XREF: __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z+11o
.xdata$x:00002549                 db    5
.xdata$x:0000254A                 db  93h ; ô
.xdata$x:0000254B                 db  19h
.xdata$x:0000254C                 db    1
.xdata$x:0000254D                 db    0
.xdata$x:0000254E                 db    0
.xdata$x:0000254F                 db    0
.xdata$x:00002550                 dd offset __unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.xdata$x:00002554                 db    0
.xdata$x:00002555                 db    0
.xdata$x:00002556                 db    0
.xdata$x:00002557                 db    0
.xdata$x:00002558                 db    0
.xdata$x:00002559                 db    0
.xdata$x:0000255A                 db    0
.xdata$x:0000255B                 db    0
.xdata$x:0000255C                 db    0
.xdata$x:0000255D                 db    0
.xdata$x:0000255E                 db    0
.xdata$x:0000255F                 db    0
.xdata$x:00002560                 db    0
.xdata$x:00002561                 db    0
.xdata$x:00002562                 db    0
.xdata$x:00002563                 db    0
.xdata$x:00002564                 db    0
.xdata$x:00002565                 db    0
.xdata$x:00002566                 db    0
.xdata$x:00002567                 db    0
.xdata$x:00002568                 db    0
.xdata$x:00002569                 db    0
.xdata$x:0000256A                 db    0
.xdata$x:0000256B                 db    0
.xdata$x:0000256B _xdata$x        ends
.xdata$x:0000256B
.rdata:0000256C ; ===========================================================================
.rdata:0000256C
.rdata:0000256C ; Segment type: Pure data
.rdata:0000256C ; Segment permissions: Read
.rdata:0000256C _rdata          segment dword public 'DATA' use32
.rdata:0000256C                 assume cs:_rdata
.rdata:0000256C                 ;org 256Ch
.rdata:0000256C ; COMDAT (pick largest)
.rdata:0000256C                 dd offset ??_R4runtime_error@std@@6B@ ; const std::runtime_error::`RTTI Complete Object Locator'
.rdata:00002570                 public ??_7runtime_error@std@@6B@
.rdata:00002570 ; const std::runtime_error::`vftable'
.rdata:00002570 ??_7runtime_error@std@@6B@ dd offset ??_Eruntime_error@std@@UAEPAXI@Z
.rdata:00002570                                         ; DATA XREF: std::runtime_error::runtime_error(std::runtime_error const &)+3Co
.rdata:00002570                                         ; std::runtime_error::runtime_error(char const *)+3Co
.rdata:00002570                                         ; std::runtime_error::`vector deleting destructor'(uint)
.rdata:00002574                 dd offset ?what@exception@std@@UBEPBDXZ ; std::exception::what(void)
.rdata:00002574 _rdata          ends
.rdata:00002574
.xdata$x:00002578 ; ===========================================================================
.xdata$x:00002578
.xdata$x:00002578 ; Segment type: Pure data
.xdata$x:00002578 ; Segment permissions: Read
.xdata$x:00002578 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002578                 assume cs:_xdata$x
.xdata$x:00002578                 ;org 2578h
.xdata$x:00002578 ; COMDAT (pick any)
.xdata$x:00002578                 public __TI2?AVruntime_error@std@@
.xdata$x:00002578 __TI2?AVruntime_error@std@@ db    0     ; DATA XREF: DockingSplitter::init(HINSTANCE__ *,HWND__ *,HWND__ *,uint)+E5o
.xdata$x:00002578                                         ; DockingSplitter::init(HINSTANCE__ *,HWND__ *,HWND__ *,uint)+16Do
.xdata$x:00002579                 db    0
.xdata$x:0000257A                 db    0
.xdata$x:0000257B                 db    0
.xdata$x:0000257C                 dd offset ??1runtime_error@std@@UAE@XZ ; std::runtime_error::~runtime_error(void)
.xdata$x:00002580                 db    0
.xdata$x:00002581                 db    0
.xdata$x:00002582                 db    0
.xdata$x:00002583                 db    0
.xdata$x:00002584                 dd offset __CTA2?AVruntime_error@std@@
.xdata$x:00002584 _xdata$x        ends
.xdata$x:00002584
.xdata$x:00002588 ; ===========================================================================
.xdata$x:00002588
.xdata$x:00002588 ; Segment type: Pure data
.xdata$x:00002588 ; Segment permissions: Read
.xdata$x:00002588 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002588                 assume cs:_xdata$x
.xdata$x:00002588                 ;org 2588h
.xdata$x:00002588 ; COMDAT (pick any)
.xdata$x:00002588                 public __CTA2?AVruntime_error@std@@
.xdata$x:00002588 __CTA2?AVruntime_error@std@@ db    2    ; DATA XREF: .xdata$x:00002584o
.xdata$x:00002589                 db    0
.xdata$x:0000258A                 db    0
.xdata$x:0000258B                 db    0
.xdata$x:0000258C                 dd offset __CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
.xdata$x:00002590                 dd offset __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
.xdata$x:00002590 _xdata$x        ends
.xdata$x:00002590
.data$r:00002594 ; ===========================================================================
.data$r:00002594
.data$r:00002594 ; Segment type: Pure data
.data$r:00002594 ; Segment permissions: Read/Write
.data$r:00002594 _data$r         segment dword public 'DATA' use32
.data$r:00002594                 assume cs:_data$r
.data$r:00002594                 ;org 2594h
.data$r:00002594 ; COMDAT (pick any)
.data$r:00002594                 public ??_R0?AVruntime_error@std@@@8
.data$r:00002594 ; class std::runtime_error `RTTI Type Descriptor'
.data$r:00002594 ??_R0?AVruntime_error@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00002594                                         ; DATA XREF: .xdata$x:000025B8o
.data$r:00002594                                         ; .rdata$r:000027FCo ...
.data$r:00002594                                         ; const type_info::`vftable'
.data$r:00002598                 db    0
.data$r:00002599                 db    0
.data$r:0000259A                 db    0
.data$r:0000259B                 db    0
.data$r:0000259C                 db  2Eh ; .
.data$r:0000259D                 db  3Fh ; ?
.data$r:0000259E                 db  41h ; A
.data$r:0000259F                 db  56h ; V
.data$r:000025A0                 db  72h ; r
.data$r:000025A1                 db  75h ; u
.data$r:000025A2                 db  6Eh ; n
.data$r:000025A3                 db  74h ; t
.data$r:000025A4                 db  69h ; i
.data$r:000025A5                 db  6Dh ; m
.data$r:000025A6                 db  65h ; e
.data$r:000025A7                 db  5Fh ; _
.data$r:000025A8                 db  65h ; e
.data$r:000025A9                 db  72h ; r
.data$r:000025AA                 db  72h ; r
.data$r:000025AB                 db  6Fh ; o
.data$r:000025AC                 db  72h ; r
.data$r:000025AD                 db  40h ; @
.data$r:000025AE                 db  73h ; s
.data$r:000025AF                 db  74h ; t
.data$r:000025B0                 db  64h ; d
.data$r:000025B1                 db  40h ; @
.data$r:000025B2                 db  40h ; @
.data$r:000025B3                 db    0
.data$r:000025B3 _data$r         ends
.data$r:000025B3
.xdata$x:000025B4 ; ===========================================================================
.xdata$x:000025B4
.xdata$x:000025B4 ; Segment type: Pure data
.xdata$x:000025B4 ; Segment permissions: Read
.xdata$x:000025B4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000025B4                 assume cs:_xdata$x
.xdata$x:000025B4                 ;org 25B4h
.xdata$x:000025B4 ; COMDAT (pick any)
.xdata$x:000025B4                 public __CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
.xdata$x:000025B4 __CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12 db    0
.xdata$x:000025B4                                         ; DATA XREF: .xdata$x:0000258Co
.xdata$x:000025B5                 db    0
.xdata$x:000025B6                 db    0
.xdata$x:000025B7                 db    0
.xdata$x:000025B8                 dd offset ??_R0?AVruntime_error@std@@@8 ; std::runtime_error `RTTI Type Descriptor'
.xdata$x:000025BC                 align 10h
.xdata$x:000025C0                 db 0FFh
.xdata$x:000025C1                 db 0FFh
.xdata$x:000025C2                 db 0FFh
.xdata$x:000025C3                 db 0FFh
.xdata$x:000025C4                 db    0
.xdata$x:000025C5                 db    0
.xdata$x:000025C6                 db    0
.xdata$x:000025C7                 db    0
.xdata$x:000025C8                 db  0Ch
.xdata$x:000025C9                 db    0
.xdata$x:000025CA                 db    0
.xdata$x:000025CB                 db    0
.xdata$x:000025CC                 dd offset ??0runtime_error@std@@QAE@ABV01@@Z ; std::runtime_error::runtime_error(std::runtime_error const &)
.xdata$x:000025CC _xdata$x        ends
.xdata$x:000025CC
.data$r:000025D0 ; ===========================================================================
.data$r:000025D0
.data$r:000025D0 ; Segment type: Pure data
.data$r:000025D0 ; Segment permissions: Read/Write
.data$r:000025D0 _data$r         segment dword public 'DATA' use32
.data$r:000025D0                 assume cs:_data$r
.data$r:000025D0                 ;org 25D0h
.data$r:000025D0 ; COMDAT (pick any)
.data$r:000025D0                 public ??_R0?AVexception@std@@@8
.data$r:000025D0 ; class std::exception `RTTI Type Descriptor'
.data$r:000025D0 ??_R0?AVexception@std@@@8 dd offset ??_7type_info@@6B@
.data$r:000025D0                                         ; DATA XREF: .xdata$x:000025F0o
.data$r:000025D0                                         ; .rdata$r:std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:000025D0                                         ; const type_info::`vftable'
.data$r:000025D4                 align 8
.data$r:000025D8 a_?avexception@ db '.?AVexception@std@@',0
.data$r:000025D8 _data$r         ends
.data$r:000025D8
.xdata$x:000025EC ; ===========================================================================
.xdata$x:000025EC
.xdata$x:000025EC ; Segment type: Pure data
.xdata$x:000025EC ; Segment permissions: Read
.xdata$x:000025EC _xdata$x        segment dword public 'DATA' use32
.xdata$x:000025EC                 assume cs:_xdata$x
.xdata$x:000025EC                 ;org 25ECh
.xdata$x:000025EC ; COMDAT (pick any)
.xdata$x:000025EC                 public __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
.xdata$x:000025EC __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 db    0
.xdata$x:000025EC                                         ; DATA XREF: .xdata$x:00002590o
.xdata$x:000025ED                 db    0
.xdata$x:000025EE                 db    0
.xdata$x:000025EF                 db    0
.xdata$x:000025F0                 dd offset ??_R0?AVexception@std@@@8 ; std::exception `RTTI Type Descriptor'
.xdata$x:000025F4                 align 8
.xdata$x:000025F8                 db 0FFh
.xdata$x:000025F9                 db 0FFh
.xdata$x:000025FA                 db 0FFh
.xdata$x:000025FB                 db 0FFh
.xdata$x:000025FC                 db    0
.xdata$x:000025FD                 db    0
.xdata$x:000025FE                 db    0
.xdata$x:000025FF                 db    0
.xdata$x:00002600                 db  0Ch
.xdata$x:00002601                 db    0
.xdata$x:00002602                 db    0
.xdata$x:00002603                 db    0
.xdata$x:00002604                 dd offset ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception(std::exception const &)
.xdata$x:00002604 _xdata$x        ends
.xdata$x:00002604
.rdata:00002608 ; ===========================================================================
.rdata:00002608
.rdata:00002608 ; Segment type: Pure data
.rdata:00002608 ; Segment permissions: Read
.rdata:00002608 _rdata          segment dword public 'DATA' use32
.rdata:00002608                 assume cs:_rdata
.rdata:00002608                 ;org 2608h
.rdata:00002608 ; COMDAT (pick largest)
.rdata:00002608                 dd offset ??_R4error_category@std@@6B@ ; const std::error_category::`RTTI Complete Object Locator'
.rdata:0000260C                 public ??_7error_category@std@@6B@
.rdata:0000260C ; const std::error_category::`vftable'
.rdata:0000260C ??_7error_category@std@@6B@ dd offset ??_Eerror_category@std@@UAEPAXI@Z
.rdata:0000260C                                         ; DATA XREF: std::error_category::error_category(void)+Ao
.rdata:0000260C                                         ; std::error_category::~error_category(void)+Ao
.rdata:0000260C                                         ; std::error_category::`vector deleting destructor'(uint)
.rdata:00002610                 dd offset __purecall
.rdata:00002614                 dd offset __purecall
.rdata:00002618                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:0000261C                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00002620                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00002620 _rdata          ends
.rdata:00002620
.rdata:00002624 ; ===========================================================================
.rdata:00002624
.rdata:00002624 ; Segment type: Pure data
.rdata:00002624 ; Segment permissions: Read
.rdata:00002624 _rdata          segment dword public 'DATA' use32
.rdata:00002624                 assume cs:_rdata
.rdata:00002624                 ;org 2624h
.rdata:00002624 ; COMDAT (pick largest)
.rdata:00002624                 dd offset ??_R4_Generic_error_category@std@@6B@ ; const std::_Generic_error_category::`RTTI Complete Object Locator'
.rdata:00002628                 public ??_7_Generic_error_category@std@@6B@
.rdata:00002628 ; const std::_Generic_error_category::`vftable'
.rdata:00002628 ??_7_Generic_error_category@std@@6B@ dd offset ??_E_Generic_error_category@std@@UAEPAXI@Z
.rdata:00002628                                         ; DATA XREF: std::_Generic_error_category::_Generic_error_category(void)+38o
.rdata:00002628                                         ; std::_Generic_error_category::`vector deleting destructor'(uint)
.rdata:0000262C                 dd offset ?name@_Generic_error_category@std@@UBEPBDXZ ; std::_Generic_error_category::name(void)
.rdata:00002630                 dd offset ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
.rdata:00002634                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:00002638                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:0000263C                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:0000263C _rdata          ends
.rdata:0000263C
.rdata:00002640 ; ===========================================================================
.rdata:00002640
.rdata:00002640 ; Segment type: Pure data
.rdata:00002640 ; Segment permissions: Read
.rdata:00002640 _rdata          segment dword public 'DATA' use32
.rdata:00002640                 assume cs:_rdata
.rdata:00002640                 ;org 2640h
.rdata:00002640 ; COMDAT (pick any)
.rdata:00002640                 public ??_C@_07DCLBNMLN@generic?$AA@
.rdata:00002640 ; `string'
.rdata:00002640 ??_C@_07DCLBNMLN@generic?$AA@ db 'generic',0
.rdata:00002640                                         ; DATA XREF: std::_Generic_error_category::name(void)+7o
.rdata:00002640 _rdata          ends
.rdata:00002640
.rdata:00002648 ; ===========================================================================
.rdata:00002648
.rdata:00002648 ; Segment type: Pure data
.rdata:00002648 ; Segment permissions: Read
.rdata:00002648 _rdata          segment dword public 'DATA' use32
.rdata:00002648                 assume cs:_rdata
.rdata:00002648                 ;org 2648h
.rdata:00002648 ; COMDAT (pick any)
.rdata:00002648                 public ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
.rdata:00002648 ; `string'
.rdata:00002648 ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ db 'unknown error',0
.rdata:00002648                                         ; DATA XREF: std::_Generic_error_category::message(int):loc_1E94o
.rdata:00002648                                         ; std::_System_error_category::message(int):loc_2010o
.rdata:00002656                 align 4
.rdata:00002656 _rdata          ends
.rdata:00002656
.rdata:00002658 ; ===========================================================================
.rdata:00002658
.rdata:00002658 ; Segment type: Pure data
.rdata:00002658 ; Segment permissions: Read
.rdata:00002658 _rdata          segment dword public 'DATA' use32
.rdata:00002658                 assume cs:_rdata
.rdata:00002658                 ;org 2658h
.rdata:00002658 ; COMDAT (pick largest)
.rdata:00002658                 dd offset ??_R4_Iostream_error_category@std@@6B@ ; const std::_Iostream_error_category::`RTTI Complete Object Locator'
.rdata:0000265C                 public ??_7_Iostream_error_category@std@@6B@
.rdata:0000265C ; const std::_Iostream_error_category::`vftable'
.rdata:0000265C ??_7_Iostream_error_category@std@@6B@ dd offset ??_E_Iostream_error_category@std@@UAEPAXI@Z
.rdata:0000265C                                         ; DATA XREF: std::_Iostream_error_category::_Iostream_error_category(void)+38o
.rdata:0000265C                                         ; std::_Iostream_error_category::`vector deleting destructor'(uint)
.rdata:00002660                 dd offset ?name@_Iostream_error_category@std@@UBEPBDXZ ; std::_Iostream_error_category::name(void)
.rdata:00002664                 dd offset ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message(int)
.rdata:00002668                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:0000266C                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00002670                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00002670 _rdata          ends
.rdata:00002670
.rdata:00002674 ; ===========================================================================
.rdata:00002674
.rdata:00002674 ; Segment type: Pure data
.rdata:00002674 ; Segment permissions: Read
.rdata:00002674 _rdata          segment dword public 'DATA' use32
.rdata:00002674                 assume cs:_rdata
.rdata:00002674                 ;org 2674h
.rdata:00002674 ; COMDAT (pick any)
.rdata:00002674                 public ??_C@_08LLGCOLLL@iostream?$AA@
.rdata:00002674 ; `string'
.rdata:00002674 ??_C@_08LLGCOLLL@iostream?$AA@ db 'iostream',0
.rdata:00002674                                         ; DATA XREF: std::_Iostream_error_category::name(void)+7o
.rdata:0000267D                 align 10h
.rdata:0000267D _rdata          ends
.rdata:0000267D
.rdata:00002680 ; ===========================================================================
.rdata:00002680
.rdata:00002680 ; Segment type: Pure data
.rdata:00002680 ; Segment permissions: Read
.rdata:00002680 _rdata          segment dword public 'DATA' use32
.rdata:00002680                 assume cs:_rdata
.rdata:00002680                 ;org 2680h
.rdata:00002680 ; COMDAT (pick any)
.rdata:00002680                 public ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
.rdata:00002680 ; char `string'[]
.rdata:00002680 ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ db 'iostream stream error',0
.rdata:00002680                                         ; DATA XREF: std::_Iostream_error_category::message(int)+35o
.rdata:00002696                 align 4
.rdata:00002696 _rdata          ends
.rdata:00002696
.rdata:00002698 ; ===========================================================================
.rdata:00002698
.rdata:00002698 ; Segment type: Pure data
.rdata:00002698 ; Segment permissions: Read
.rdata:00002698 _rdata          segment dword public 'DATA' use32
.rdata:00002698                 assume cs:_rdata
.rdata:00002698                 ;org 2698h
.rdata:00002698 ; COMDAT (pick largest)
.rdata:00002698                 dd offset ??_R4_System_error_category@std@@6B@ ; const std::_System_error_category::`RTTI Complete Object Locator'
.rdata:0000269C                 public ??_7_System_error_category@std@@6B@
.rdata:0000269C ; const std::_System_error_category::`vftable'
.rdata:0000269C ??_7_System_error_category@std@@6B@ dd offset ??_E_System_error_category@std@@UAEPAXI@Z
.rdata:0000269C                                         ; DATA XREF: std::_System_error_category::_System_error_category(void)+38o
.rdata:0000269C                                         ; std::_System_error_category::`vector deleting destructor'(uint)
.rdata:000026A0                 dd offset ?name@_System_error_category@std@@UBEPBDXZ ; std::_System_error_category::name(void)
.rdata:000026A4                 dd offset ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message(int)
.rdata:000026A8                 dd offset ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition(int)
.rdata:000026AC                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:000026B0                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:000026B0 _rdata          ends
.rdata:000026B0
.rdata:000026B4 ; ===========================================================================
.rdata:000026B4
.rdata:000026B4 ; Segment type: Pure data
.rdata:000026B4 ; Segment permissions: Read
.rdata:000026B4 _rdata          segment dword public 'DATA' use32
.rdata:000026B4                 assume cs:_rdata
.rdata:000026B4                 ;org 26B4h
.rdata:000026B4 ; COMDAT (pick any)
.rdata:000026B4                 public ??_C@_06FHFOAHML@system?$AA@
.rdata:000026B4 ; `string'
.rdata:000026B4 ??_C@_06FHFOAHML@system?$AA@ db 'system',0
.rdata:000026B4                                         ; DATA XREF: std::_System_error_category::name(void)+7o
.rdata:000026BB                 align 4
.rdata:000026BB _rdata          ends
.rdata:000026BB
.bss:000026BC ; ===========================================================================
.bss:000026BC
.bss:000026BC ; Segment type: Uninitialized
.bss:000026BC ; Segment permissions: Read/Write
.bss:000026BC _bss            segment dword public 'BSS' use32
.bss:000026BC                 assume cs:_bss
.bss:000026BC                 ;org 26BCh
.bss:000026BC ; COMDAT (pick any)
.bss:000026BC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:000026BC                 public ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
.bss:000026BC ; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
.bss:000026BC ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A db    ? ;
.bss:000026BC                                         ; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o
.bss:000026BC                                         ; `dynamic atexit destructor for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o ...
.bss:000026BD                 db    ? ;
.bss:000026BE                 db    ? ;
.bss:000026BF                 db    ? ;
.bss:000026BF _bss            ends
.bss:000026BF
.bss:000026C0 ; ===========================================================================
.bss:000026C0
.bss:000026C0 ; Segment type: Uninitialized
.bss:000026C0 ; Segment permissions: Read/Write
.bss:000026C0 _bss            segment dword public 'BSS' use32
.bss:000026C0                 assume cs:_bss
.bss:000026C0                 ;org 26C0h
.bss:000026C0 ; COMDAT (pick any)
.bss:000026C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:000026C0                 public ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
.bss:000026C0 ; std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object
.bss:000026C0 ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A db    ? ;
.bss:000026C0                                         ; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
.bss:000026C0                                         ; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
.bss:000026C1                 db    ? ;
.bss:000026C2                 db    ? ;
.bss:000026C3                 db    ? ;
.bss:000026C3 _bss            ends
.bss:000026C3
.bss:000026C4 ; ===========================================================================
.bss:000026C4
.bss:000026C4 ; Segment type: Uninitialized
.bss:000026C4 ; Segment permissions: Read/Write
.bss:000026C4 _bss            segment dword public 'BSS' use32
.bss:000026C4                 assume cs:_bss
.bss:000026C4                 ;org 26C4h
.bss:000026C4 ; COMDAT (pick any)
.bss:000026C4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:000026C4                 public ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
.bss:000026C4 ; std::_System_error_category std::_Error_objects<int>::_System_object
.bss:000026C4 ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A db    ? ;
.bss:000026C4                                         ; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o
.bss:000026C4                                         ; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o ...
.bss:000026C5                 db    ? ;
.bss:000026C6                 db    ? ;
.bss:000026C7                 db    ? ;
.bss:000026C7 _bss            ends
.bss:000026C7
.bss:000026C8 ; ===========================================================================
.bss:000026C8
.bss:000026C8 ; Segment type: Uninitialized
.bss:000026C8 ; Segment permissions: Read/Write
.bss:000026C8 _bss            segment dword public 'BSS' use32
.bss:000026C8                 assume cs:_bss
.bss:000026C8                 ;org 26C8h
.bss:000026C8 ; COMDAT (pick any)
.bss:000026C8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:000026C8                 public ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
.bss:000026C8 ; std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id
.bss:000026C8 ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A db    ? ;
.bss:000026C8                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)+5o
.bss:000026C9                 db    ? ;
.bss:000026CA                 db    ? ;
.bss:000026CB                 db    ? ;
.bss:000026CB _bss            ends
.bss:000026CB
.bss:000026CC ; ===========================================================================
.bss:000026CC
.bss:000026CC ; Segment type: Uninitialized
.bss:000026CC ; Segment permissions: Read/Write
.bss:000026CC _bss            segment dword public 'BSS' use32
.bss:000026CC                 assume cs:_bss
.bss:000026CC                 ;org 26CCh
.bss:000026CC ; COMDAT (pick any)
.bss:000026CC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:000026CC                 public ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
.bss:000026CC ; std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id
.bss:000026CC ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A db    ? ;
.bss:000026CC                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)+5o
.bss:000026CD                 db    ? ;
.bss:000026CE                 db    ? ;
.bss:000026CF                 db    ? ;
.bss:000026CF _bss            ends
.bss:000026CF
.rdata:000026D0 ; ===========================================================================
.rdata:000026D0
.rdata:000026D0 ; Segment type: Pure data
.rdata:000026D0 ; Segment permissions: Read
.rdata:000026D0 ; Segment alignment 'qword' can not be represented in assembly
.rdata:000026D0 _rdata          segment para public 'DATA' use32
.rdata:000026D0                 assume cs:_rdata
.rdata:000026D0                 ;org 26D0h
.rdata:000026D0 ; COMDAT (pick any)
.rdata:000026D0                 public ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:000026D0 ; wchar_t `string'
.rdata:000026D0 ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:000026D0                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+Co
.rdata:000026D0                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+12o
.rdata:000026D0                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:000026D0                 unicode 0, <clude\xstring>,0
.rdata:0000275E                 align 10h
.rdata:0000275E _rdata          ends
.rdata:0000275E
.bss:00002760 ; ===========================================================================
.bss:00002760
.bss:00002760 ; Segment type: Uninitialized
.bss:00002760 ; Segment permissions: Read/Write
.bss:00002760 _bss            segment dword public 'BSS' use32
.bss:00002760                 assume cs:_bss
.bss:00002760                 ;org 2760h
.bss:00002760 ; COMDAT (pick any)
.bss:00002760                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00002760                 public ?id@?$numpunct@D@std@@2V0locale@2@A
.bss:00002760 ; std::locale::id std::numpunct<char>::id
.bss:00002760 ?id@?$numpunct@D@std@@2V0locale@2@A db    ? ;
.bss:00002760                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::numpunct<char>::id''(void)+5o
.bss:00002761                 db    ? ;
.bss:00002762                 db    ? ;
.bss:00002763                 db    ? ;
.bss:00002763 _bss            ends
.bss:00002763
.bss:00002764 ; ===========================================================================
.bss:00002764
.bss:00002764 ; Segment type: Uninitialized
.bss:00002764 ; Segment permissions: Read/Write
.bss:00002764 _bss            segment dword public 'BSS' use32
.bss:00002764                 assume cs:_bss
.bss:00002764                 ;org 2764h
.bss:00002764 ; COMDAT (pick any)
.bss:00002764                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00002764                 public ?id@?$numpunct@_W@std@@2V0locale@2@A
.bss:00002764 ; std::locale::id std::numpunct<wchar_t>::id
.bss:00002764 ?id@?$numpunct@_W@std@@2V0locale@2@A db    ? ;
.bss:00002764                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::numpunct<wchar_t>::id''(void)+5o
.bss:00002765                 db    ? ;
.bss:00002766                 db    ? ;
.bss:00002767                 db    ? ;
.bss:00002767 _bss            ends
.bss:00002767
.rdata:00002768 ; ===========================================================================
.rdata:00002768
.rdata:00002768 ; Segment type: Pure data
.rdata:00002768 ; Segment permissions: Read
.rdata:00002768 _rdata          segment dword public 'DATA' use32
.rdata:00002768                 assume cs:_rdata
.rdata:00002768                 ;org 2768h
.rdata:00002768 ; COMDAT (pick any)
.rdata:00002768                 public ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
.rdata:00002768 ; char `string'[]
.rdata:00002768 ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ db 'string too long',0
.rdata:00002768                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+7o
.rdata:00002768 _rdata          ends
.rdata:00002768
.rdata:00002778 ; ===========================================================================
.rdata:00002778
.rdata:00002778 ; Segment type: Pure data
.rdata:00002778 ; Segment permissions: Read
.rdata:00002778 _rdata          segment dword public 'DATA' use32
.rdata:00002778                 assume cs:_rdata
.rdata:00002778                 ;org 2778h
.rdata:00002778 ; COMDAT (pick any)
.rdata:00002778                 public ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
.rdata:00002778 ; char `string'[]
.rdata:00002778 ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ db 'invalid string position',0
.rdata:00002778                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+7o
.rdata:00002778 _rdata          ends
.rdata:00002778
.rdata:00002790 ; ===========================================================================
.rdata:00002790
.rdata:00002790 ; Segment type: Pure data
.rdata:00002790 ; Segment permissions: Read
.rdata:00002790 _rdata          segment dword public 'DATA' use32
.rdata:00002790                 assume cs:_rdata
.rdata:00002790                 ;org 2790h
.rdata:00002790 ; COMDAT (pick any)
.rdata:00002790                 public ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
.rdata:00002790 ; wchar_t `string'
.rdata:00002790 ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@:
.rdata:00002790                                         ; DATA XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+11o
.rdata:00002790                 unicode 0, <invalid null pointer>,0
.rdata:000027BA                 align 4
.rdata:000027BA _rdata          ends
.rdata:000027BA
.rdata$r:000027BC ; ===========================================================================
.rdata$r:000027BC
.rdata$r:000027BC ; Segment type: Pure data
.rdata$r:000027BC ; Segment permissions: Read
.rdata$r:000027BC _rdata$r        segment dword public 'DATA' use32
.rdata$r:000027BC                 assume cs:_rdata$r
.rdata$r:000027BC                 ;org 27BCh
.rdata$r:000027BC ; COMDAT (pick any)
.rdata$r:000027BC                 public ??_R1A@?0A@EA@exception@std@@8
.rdata$r:000027BC ; std::exception::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:000027BC ??_R1A@?0A@EA@exception@std@@8 dd offset ??_R0?AVexception@std@@@8
.rdata$r:000027BC                                         ; DATA XREF: .rdata$r:std::exception::`RTTI Base Class Array'o
.rdata$r:000027BC                                         ; .rdata$r:00002818o
.rdata$r:000027BC                                         ; std::exception `RTTI Type Descriptor'
.rdata$r:000027C0                 db    0
.rdata$r:000027C1                 db    0
.rdata$r:000027C2                 db    0
.rdata$r:000027C3                 db    0
.rdata$r:000027C4                 db    0
.rdata$r:000027C5                 db    0
.rdata$r:000027C6                 db    0
.rdata$r:000027C7                 db    0
.rdata$r:000027C8                 db 0FFh
.rdata$r:000027C9                 db 0FFh
.rdata$r:000027CA                 db 0FFh
.rdata$r:000027CB                 db 0FFh
.rdata$r:000027CC                 db    0
.rdata$r:000027CD                 db    0
.rdata$r:000027CE                 db    0
.rdata$r:000027CF                 db    0
.rdata$r:000027D0                 db  40h ; @
.rdata$r:000027D1                 db    0
.rdata$r:000027D2                 db    0
.rdata$r:000027D3                 db    0
.rdata$r:000027D4                 dd offset ??_R3exception@std@@8 ; std::exception::`RTTI Class Hierarchy Descriptor'
.rdata$r:000027D4 _rdata$r        ends
.rdata$r:000027D4
.rdata$r:000027D8 ; ===========================================================================
.rdata$r:000027D8
.rdata$r:000027D8 ; Segment type: Pure data
.rdata$r:000027D8 ; Segment permissions: Read
.rdata$r:000027D8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000027D8                 assume cs:_rdata$r
.rdata$r:000027D8                 ;org 27D8h
.rdata$r:000027D8 ; COMDAT (pick any)
.rdata$r:000027D8                 public ??_R3exception@std@@8
.rdata$r:000027D8 ; std::exception::`RTTI Class Hierarchy Descriptor'
.rdata$r:000027D8 ??_R3exception@std@@8 db    0           ; DATA XREF: .rdata$r:000027D4o
.rdata$r:000027D9                 db    0
.rdata$r:000027DA                 db    0
.rdata$r:000027DB                 db    0
.rdata$r:000027DC                 db    0
.rdata$r:000027DD                 db    0
.rdata$r:000027DE                 db    0
.rdata$r:000027DF                 db    0
.rdata$r:000027E0                 db    1
.rdata$r:000027E1                 db    0
.rdata$r:000027E2                 db    0
.rdata$r:000027E3                 db    0
.rdata$r:000027E4                 dd offset ??_R2exception@std@@8 ; std::exception::`RTTI Base Class Array'
.rdata$r:000027E4 _rdata$r        ends
.rdata$r:000027E4
.rdata$r:000027E8 ; ===========================================================================
.rdata$r:000027E8
.rdata$r:000027E8 ; Segment type: Pure data
.rdata$r:000027E8 ; Segment permissions: Read
.rdata$r:000027E8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000027E8                 assume cs:_rdata$r
.rdata$r:000027E8                 ;org 27E8h
.rdata$r:000027E8 ; COMDAT (pick any)
.rdata$r:000027E8                 public ??_R2exception@std@@8
.rdata$r:000027E8 ; std::exception::`RTTI Base Class Array'
.rdata$r:000027E8 ??_R2exception@std@@8 dd offset ??_R1A@?0A@EA@exception@std@@8
.rdata$r:000027E8                                         ; DATA XREF: .rdata$r:000027E4o
.rdata$r:000027E8                                         ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000027EC                 db    0
.rdata$r:000027ED                 align 10h
.rdata$r:000027ED _rdata$r        ends
.rdata$r:000027ED
.rdata$r:000027F0 ; ===========================================================================
.rdata$r:000027F0
.rdata$r:000027F0 ; Segment type: Pure data
.rdata$r:000027F0 ; Segment permissions: Read
.rdata$r:000027F0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000027F0                 assume cs:_rdata$r
.rdata$r:000027F0                 ;org 27F0h
.rdata$r:000027F0 ; COMDAT (pick any)
.rdata$r:000027F0                 public ??_R4runtime_error@std@@6B@
.rdata$r:000027F0 ; const std::runtime_error::`RTTI Complete Object Locator'
.rdata$r:000027F0 ??_R4runtime_error@std@@6B@ db    0     ; DATA XREF: .rdata:0000256Co
.rdata$r:000027F1                 db    0
.rdata$r:000027F2                 db    0
.rdata$r:000027F3                 db    0
.rdata$r:000027F4                 db    0
.rdata$r:000027F5                 db    0
.rdata$r:000027F6                 db    0
.rdata$r:000027F7                 db    0
.rdata$r:000027F8                 db    0
.rdata$r:000027F9                 db    0
.rdata$r:000027FA                 db    0
.rdata$r:000027FB                 db    0
.rdata$r:000027FC                 dd offset ??_R0?AVruntime_error@std@@@8 ; std::runtime_error `RTTI Type Descriptor'
.rdata$r:00002800                 dd offset ??_R3runtime_error@std@@8 ; std::runtime_error::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002800 _rdata$r        ends
.rdata$r:00002800
.rdata$r:00002804 ; ===========================================================================
.rdata$r:00002804
.rdata$r:00002804 ; Segment type: Pure data
.rdata$r:00002804 ; Segment permissions: Read
.rdata$r:00002804 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002804                 assume cs:_rdata$r
.rdata$r:00002804                 ;org 2804h
.rdata$r:00002804 ; COMDAT (pick any)
.rdata$r:00002804                 public ??_R3runtime_error@std@@8
.rdata$r:00002804 ; std::runtime_error::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002804 ??_R3runtime_error@std@@8 db    0       ; DATA XREF: .rdata$r:00002800o
.rdata$r:00002804                                         ; .rdata$r:00002838o
.rdata$r:00002805                 db    0
.rdata$r:00002806                 db    0
.rdata$r:00002807                 db    0
.rdata$r:00002808                 db    0
.rdata$r:00002809                 db    0
.rdata$r:0000280A                 db    0
.rdata$r:0000280B                 db    0
.rdata$r:0000280C                 db    2
.rdata$r:0000280D                 db    0
.rdata$r:0000280E                 db    0
.rdata$r:0000280F                 db    0
.rdata$r:00002810                 dd offset ??_R2runtime_error@std@@8 ; std::runtime_error::`RTTI Base Class Array'
.rdata$r:00002810 _rdata$r        ends
.rdata$r:00002810
.rdata$r:00002814 ; ===========================================================================
.rdata$r:00002814
.rdata$r:00002814 ; Segment type: Pure data
.rdata$r:00002814 ; Segment permissions: Read
.rdata$r:00002814 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002814                 assume cs:_rdata$r
.rdata$r:00002814                 ;org 2814h
.rdata$r:00002814 ; COMDAT (pick any)
.rdata$r:00002814                 public ??_R2runtime_error@std@@8
.rdata$r:00002814 ; std::runtime_error::`RTTI Base Class Array'
.rdata$r:00002814 ??_R2runtime_error@std@@8 dd offset ??_R1A@?0A@EA@runtime_error@std@@8
.rdata$r:00002814                                         ; DATA XREF: .rdata$r:00002810o
.rdata$r:00002814                                         ; std::runtime_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002818                 dd offset ??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000281C                 db    0
.rdata$r:0000281D                 align 10h
.rdata$r:0000281D _rdata$r        ends
.rdata$r:0000281D
.rdata$r:00002820 ; ===========================================================================
.rdata$r:00002820
.rdata$r:00002820 ; Segment type: Pure data
.rdata$r:00002820 ; Segment permissions: Read
.rdata$r:00002820 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002820                 assume cs:_rdata$r
.rdata$r:00002820                 ;org 2820h
.rdata$r:00002820 ; COMDAT (pick any)
.rdata$r:00002820                 public ??_R1A@?0A@EA@runtime_error@std@@8
.rdata$r:00002820 ; std::runtime_error::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00002820 ??_R1A@?0A@EA@runtime_error@std@@8 dd offset ??_R0?AVruntime_error@std@@@8
.rdata$r:00002820                                         ; DATA XREF: .rdata$r:std::runtime_error::`RTTI Base Class Array'o
.rdata$r:00002820                                         ; std::runtime_error `RTTI Type Descriptor'
.rdata$r:00002824                 db    1
.rdata$r:00002825                 db    0
.rdata$r:00002826                 db    0
.rdata$r:00002827                 db    0
.rdata$r:00002828                 db    0
.rdata$r:00002829                 db    0
.rdata$r:0000282A                 db    0
.rdata$r:0000282B                 db    0
.rdata$r:0000282C                 db 0FFh
.rdata$r:0000282D                 db 0FFh
.rdata$r:0000282E                 db 0FFh
.rdata$r:0000282F                 db 0FFh
.rdata$r:00002830                 db    0
.rdata$r:00002831                 db    0
.rdata$r:00002832                 db    0
.rdata$r:00002833                 db    0
.rdata$r:00002834                 db  40h ; @
.rdata$r:00002835                 db    0
.rdata$r:00002836                 db    0
.rdata$r:00002837                 db    0
.rdata$r:00002838                 dd offset ??_R3runtime_error@std@@8 ; std::runtime_error::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002838 _rdata$r        ends
.rdata$r:00002838
.rdata$r:0000283C ; ===========================================================================
.rdata$r:0000283C
.rdata$r:0000283C ; Segment type: Pure data
.rdata$r:0000283C ; Segment permissions: Read
.rdata$r:0000283C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000283C                 assume cs:_rdata$r
.rdata$r:0000283C                 ;org 283Ch
.rdata$r:0000283C ; COMDAT (pick any)
.rdata$r:0000283C                 public ??_R4error_category@std@@6B@
.rdata$r:0000283C ; const std::error_category::`RTTI Complete Object Locator'
.rdata$r:0000283C ??_R4error_category@std@@6B@ db    0    ; DATA XREF: .rdata:00002608o
.rdata$r:0000283D                 db    0
.rdata$r:0000283E                 db    0
.rdata$r:0000283F                 db    0
.rdata$r:00002840                 db    0
.rdata$r:00002841                 db    0
.rdata$r:00002842                 db    0
.rdata$r:00002843                 db    0
.rdata$r:00002844                 db    0
.rdata$r:00002845                 db    0
.rdata$r:00002846                 db    0
.rdata$r:00002847                 db    0
.rdata$r:00002848                 dd offset ??_R0?AVerror_category@std@@@8 ; std::error_category `RTTI Type Descriptor'
.rdata$r:0000284C                 dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000284C _rdata$r        ends
.rdata$r:0000284C
.data$r:00002850 ; ===========================================================================
.data$r:00002850
.data$r:00002850 ; Segment type: Pure data
.data$r:00002850 ; Segment permissions: Read/Write
.data$r:00002850 _data$r         segment dword public 'DATA' use32
.data$r:00002850                 assume cs:_data$r
.data$r:00002850                 ;org 2850h
.data$r:00002850 ; COMDAT (pick any)
.data$r:00002850                 public ??_R0?AVerror_category@std@@@8
.data$r:00002850 ; class std::error_category `RTTI Type Descriptor'
.data$r:00002850 ??_R0?AVerror_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00002850                                         ; DATA XREF: .rdata$r:00002848o
.data$r:00002850                                         ; .rdata$r:std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00002850                                         ; const type_info::`vftable'
.data$r:00002854                 align 8
.data$r:00002858 a_?averror_cate db '.?AVerror_category@std@@',0
.data$r:00002871                 align 4
.data$r:00002871 _data$r         ends
.data$r:00002871
.rdata$r:00002874 ; ===========================================================================
.rdata$r:00002874
.rdata$r:00002874 ; Segment type: Pure data
.rdata$r:00002874 ; Segment permissions: Read
.rdata$r:00002874 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002874                 assume cs:_rdata$r
.rdata$r:00002874                 ;org 2874h
.rdata$r:00002874 ; COMDAT (pick any)
.rdata$r:00002874                 public ??_R3error_category@std@@8
.rdata$r:00002874 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002874 ??_R3error_category@std@@8 db    0      ; DATA XREF: .rdata$r:0000284Co
.rdata$r:00002874                                         ; .rdata$r:000028A4o
.rdata$r:00002875                 db    0
.rdata$r:00002876                 db    0
.rdata$r:00002877                 db    0
.rdata$r:00002878                 db    0
.rdata$r:00002879                 db    0
.rdata$r:0000287A                 db    0
.rdata$r:0000287B                 db    0
.rdata$r:0000287C                 db    1
.rdata$r:0000287D                 db    0
.rdata$r:0000287E                 db    0
.rdata$r:0000287F                 db    0
.rdata$r:00002880                 dd offset ??_R2error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
.rdata$r:00002880 _rdata$r        ends
.rdata$r:00002880
.rdata$r:00002884 ; ===========================================================================
.rdata$r:00002884
.rdata$r:00002884 ; Segment type: Pure data
.rdata$r:00002884 ; Segment permissions: Read
.rdata$r:00002884 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002884                 assume cs:_rdata$r
.rdata$r:00002884                 ;org 2884h
.rdata$r:00002884 ; COMDAT (pick any)
.rdata$r:00002884                 public ??_R2error_category@std@@8
.rdata$r:00002884 ; std::error_category::`RTTI Base Class Array'
.rdata$r:00002884 ??_R2error_category@std@@8 dd offset ??_R1A@?0A@EA@error_category@std@@8
.rdata$r:00002884                                         ; DATA XREF: .rdata$r:00002880o
.rdata$r:00002884                                         ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002888                 db    0
.rdata$r:00002889                 align 4
.rdata$r:00002889 _rdata$r        ends
.rdata$r:00002889
.rdata$r:0000288C ; ===========================================================================
.rdata$r:0000288C
.rdata$r:0000288C ; Segment type: Pure data
.rdata$r:0000288C ; Segment permissions: Read
.rdata$r:0000288C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000288C                 assume cs:_rdata$r
.rdata$r:0000288C                 ;org 288Ch
.rdata$r:0000288C ; COMDAT (pick any)
.rdata$r:0000288C                 public ??_R1A@?0A@EA@error_category@std@@8
.rdata$r:0000288C ; std::error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000288C ??_R1A@?0A@EA@error_category@std@@8 dd offset ??_R0?AVerror_category@std@@@8
.rdata$r:0000288C                                         ; DATA XREF: .rdata$r:std::error_category::`RTTI Base Class Array'o
.rdata$r:0000288C                                         ; .rdata$r:000028FCo ...
.rdata$r:0000288C                                         ; std::error_category `RTTI Type Descriptor'
.rdata$r:00002890                 db    0
.rdata$r:00002891                 db    0
.rdata$r:00002892                 db    0
.rdata$r:00002893                 db    0
.rdata$r:00002894                 db    0
.rdata$r:00002895                 db    0
.rdata$r:00002896                 db    0
.rdata$r:00002897                 db    0
.rdata$r:00002898                 db 0FFh
.rdata$r:00002899                 db 0FFh
.rdata$r:0000289A                 db 0FFh
.rdata$r:0000289B                 db 0FFh
.rdata$r:0000289C                 db    0
.rdata$r:0000289D                 db    0
.rdata$r:0000289E                 db    0
.rdata$r:0000289F                 db    0
.rdata$r:000028A0                 db  40h ; @
.rdata$r:000028A1                 db    0
.rdata$r:000028A2                 db    0
.rdata$r:000028A3                 db    0
.rdata$r:000028A4                 dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000028A4 _rdata$r        ends
.rdata$r:000028A4
.rdata$r:000028A8 ; ===========================================================================
.rdata$r:000028A8
.rdata$r:000028A8 ; Segment type: Pure data
.rdata$r:000028A8 ; Segment permissions: Read
.rdata$r:000028A8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000028A8                 assume cs:_rdata$r
.rdata$r:000028A8                 ;org 28A8h
.rdata$r:000028A8 ; COMDAT (pick any)
.rdata$r:000028A8                 public ??_R4_Generic_error_category@std@@6B@
.rdata$r:000028A8 ; const std::_Generic_error_category::`RTTI Complete Object Locator'
.rdata$r:000028A8 ??_R4_Generic_error_category@std@@6B@ db    0
.rdata$r:000028A8                                         ; DATA XREF: .rdata:00002624o
.rdata$r:000028A9                 db    0
.rdata$r:000028AA                 db    0
.rdata$r:000028AB                 db    0
.rdata$r:000028AC                 db    0
.rdata$r:000028AD                 db    0
.rdata$r:000028AE                 db    0
.rdata$r:000028AF                 db    0
.rdata$r:000028B0                 db    0
.rdata$r:000028B1                 db    0
.rdata$r:000028B2                 db    0
.rdata$r:000028B3                 db    0
.rdata$r:000028B4                 dd offset ??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category `RTTI Type Descriptor'
.rdata$r:000028B8                 dd offset ??_R3_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000028B8 _rdata$r        ends
.rdata$r:000028B8
.data$r:000028BC ; ===========================================================================
.data$r:000028BC
.data$r:000028BC ; Segment type: Pure data
.data$r:000028BC ; Segment permissions: Read/Write
.data$r:000028BC _data$r         segment dword public 'DATA' use32
.data$r:000028BC                 assume cs:_data$r
.data$r:000028BC                 ;org 28BCh
.data$r:000028BC ; COMDAT (pick any)
.data$r:000028BC                 public ??_R0?AV_Generic_error_category@std@@@8
.data$r:000028BC ; class std::_Generic_error_category `RTTI Type Descriptor'
.data$r:000028BC ??_R0?AV_Generic_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:000028BC                                         ; DATA XREF: .rdata$r:000028B4o
.data$r:000028BC                                         ; .rdata$r:std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:000028BC                                         ; const type_info::`vftable'
.data$r:000028C0                 db    0
.data$r:000028C1                 db    0
.data$r:000028C2                 db    0
.data$r:000028C3                 db    0
.data$r:000028C4                 db  2Eh ; .
.data$r:000028C5                 db  3Fh ; ?
.data$r:000028C6                 db  41h ; A
.data$r:000028C7                 db  56h ; V
.data$r:000028C8                 db  5Fh ; _
.data$r:000028C9                 db  47h ; G
.data$r:000028CA                 db  65h ; e
.data$r:000028CB                 db  6Eh ; n
.data$r:000028CC                 db  65h ; e
.data$r:000028CD                 db  72h ; r
.data$r:000028CE                 db  69h ; i
.data$r:000028CF                 db  63h ; c
.data$r:000028D0                 db  5Fh ; _
.data$r:000028D1                 db  65h ; e
.data$r:000028D2                 db  72h ; r
.data$r:000028D3                 db  72h ; r
.data$r:000028D4                 db  6Fh ; o
.data$r:000028D5                 db  72h ; r
.data$r:000028D6                 db  5Fh ; _
.data$r:000028D7                 db  63h ; c
.data$r:000028D8                 db  61h ; a
.data$r:000028D9                 db  74h ; t
.data$r:000028DA                 db  65h ; e
.data$r:000028DB                 db  67h ; g
.data$r:000028DC                 db  6Fh ; o
.data$r:000028DD                 db  72h ; r
.data$r:000028DE                 db  79h ; y
.data$r:000028DF                 db  40h ; @
.data$r:000028E0                 db  73h ; s
.data$r:000028E1                 db  74h ; t
.data$r:000028E2                 db  64h ; d
.data$r:000028E3                 db  40h ; @
.data$r:000028E4                 db  40h ; @
.data$r:000028E5                 db    0
.data$r:000028E6                 align 4
.data$r:000028E6 _data$r         ends
.data$r:000028E6
.rdata$r:000028E8 ; ===========================================================================
.rdata$r:000028E8
.rdata$r:000028E8 ; Segment type: Pure data
.rdata$r:000028E8 ; Segment permissions: Read
.rdata$r:000028E8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000028E8                 assume cs:_rdata$r
.rdata$r:000028E8                 ;org 28E8h
.rdata$r:000028E8 ; COMDAT (pick any)
.rdata$r:000028E8                 public ??_R3_Generic_error_category@std@@8
.rdata$r:000028E8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000028E8 ??_R3_Generic_error_category@std@@8 db    0
.rdata$r:000028E8                                         ; DATA XREF: .rdata$r:000028B8o
.rdata$r:000028E8                                         ; .rdata$r:0000291Co
.rdata$r:000028E9                 db    0
.rdata$r:000028EA                 db    0
.rdata$r:000028EB                 db    0
.rdata$r:000028EC                 db    0
.rdata$r:000028ED                 db    0
.rdata$r:000028EE                 db    0
.rdata$r:000028EF                 db    0
.rdata$r:000028F0                 db    2
.rdata$r:000028F1                 db    0
.rdata$r:000028F2                 db    0
.rdata$r:000028F3                 db    0
.rdata$r:000028F4                 dd offset ??_R2_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
.rdata$r:000028F4 _rdata$r        ends
.rdata$r:000028F4
.rdata$r:000028F8 ; ===========================================================================
.rdata$r:000028F8
.rdata$r:000028F8 ; Segment type: Pure data
.rdata$r:000028F8 ; Segment permissions: Read
.rdata$r:000028F8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000028F8                 assume cs:_rdata$r
.rdata$r:000028F8                 ;org 28F8h
.rdata$r:000028F8 ; COMDAT (pick any)
.rdata$r:000028F8                 public ??_R2_Generic_error_category@std@@8
.rdata$r:000028F8 ; std::_Generic_error_category::`RTTI Base Class Array'
.rdata$r:000028F8 ??_R2_Generic_error_category@std@@8 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8
.rdata$r:000028F8                                         ; DATA XREF: .rdata$r:000028F4o
.rdata$r:000028F8                                         ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000028FC                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002900                 db    0
.rdata$r:00002901                 align 4
.rdata$r:00002901 _rdata$r        ends
.rdata$r:00002901
.rdata$r:00002904 ; ===========================================================================
.rdata$r:00002904
.rdata$r:00002904 ; Segment type: Pure data
.rdata$r:00002904 ; Segment permissions: Read
.rdata$r:00002904 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002904                 assume cs:_rdata$r
.rdata$r:00002904                 ;org 2904h
.rdata$r:00002904 ; COMDAT (pick any)
.rdata$r:00002904                 public ??_R1A@?0A@EA@_Generic_error_category@std@@8
.rdata$r:00002904 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00002904 ??_R1A@?0A@EA@_Generic_error_category@std@@8 dd offset ??_R0?AV_Generic_error_category@std@@@8
.rdata$r:00002904                                         ; DATA XREF: .rdata$r:std::_Generic_error_category::`RTTI Base Class Array'o
.rdata$r:00002904                                         ; .rdata$r:00002974o ...
.rdata$r:00002904                                         ; std::_Generic_error_category `RTTI Type Descriptor'
.rdata$r:00002908                 db    1
.rdata$r:00002909                 db    0
.rdata$r:0000290A                 db    0
.rdata$r:0000290B                 db    0
.rdata$r:0000290C                 db    0
.rdata$r:0000290D                 db    0
.rdata$r:0000290E                 db    0
.rdata$r:0000290F                 db    0
.rdata$r:00002910                 db 0FFh
.rdata$r:00002911                 db 0FFh
.rdata$r:00002912                 db 0FFh
.rdata$r:00002913                 db 0FFh
.rdata$r:00002914                 db    0
.rdata$r:00002915                 db    0
.rdata$r:00002916                 db    0
.rdata$r:00002917                 db    0
.rdata$r:00002918                 db  40h ; @
.rdata$r:00002919                 db    0
.rdata$r:0000291A                 db    0
.rdata$r:0000291B                 db    0
.rdata$r:0000291C                 dd offset ??_R3_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000291C _rdata$r        ends
.rdata$r:0000291C
.rdata$r:00002920 ; ===========================================================================
.rdata$r:00002920
.rdata$r:00002920 ; Segment type: Pure data
.rdata$r:00002920 ; Segment permissions: Read
.rdata$r:00002920 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002920                 assume cs:_rdata$r
.rdata$r:00002920                 ;org 2920h
.rdata$r:00002920 ; COMDAT (pick any)
.rdata$r:00002920                 public ??_R4_Iostream_error_category@std@@6B@
.rdata$r:00002920 ; const std::_Iostream_error_category::`RTTI Complete Object Locator'
.rdata$r:00002920 ??_R4_Iostream_error_category@std@@6B@ db    0
.rdata$r:00002920                                         ; DATA XREF: .rdata:00002658o
.rdata$r:00002921                 db    0
.rdata$r:00002922                 db    0
.rdata$r:00002923                 db    0
.rdata$r:00002924                 db    0
.rdata$r:00002925                 db    0
.rdata$r:00002926                 db    0
.rdata$r:00002927                 db    0
.rdata$r:00002928                 db    0
.rdata$r:00002929                 db    0
.rdata$r:0000292A                 db    0
.rdata$r:0000292B                 db    0
.rdata$r:0000292C                 dd offset ??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category `RTTI Type Descriptor'
.rdata$r:00002930                 dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002930 _rdata$r        ends
.rdata$r:00002930
.data$r:00002934 ; ===========================================================================
.data$r:00002934
.data$r:00002934 ; Segment type: Pure data
.data$r:00002934 ; Segment permissions: Read/Write
.data$r:00002934 _data$r         segment dword public 'DATA' use32
.data$r:00002934                 assume cs:_data$r
.data$r:00002934                 ;org 2934h
.data$r:00002934 ; COMDAT (pick any)
.data$r:00002934                 public ??_R0?AV_Iostream_error_category@std@@@8
.data$r:00002934 ; class std::_Iostream_error_category `RTTI Type Descriptor'
.data$r:00002934 ??_R0?AV_Iostream_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00002934                                         ; DATA XREF: .rdata$r:0000292Co
.data$r:00002934                                         ; .rdata$r:std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00002934                                         ; const type_info::`vftable'
.data$r:00002938                 db    0
.data$r:00002939                 db    0
.data$r:0000293A                 db    0
.data$r:0000293B                 db    0
.data$r:0000293C                 db  2Eh ; .
.data$r:0000293D                 db  3Fh ; ?
.data$r:0000293E                 db  41h ; A
.data$r:0000293F                 db  56h ; V
.data$r:00002940                 db  5Fh ; _
.data$r:00002941                 db  49h ; I
.data$r:00002942                 db  6Fh ; o
.data$r:00002943                 db  73h ; s
.data$r:00002944                 db  74h ; t
.data$r:00002945                 db  72h ; r
.data$r:00002946                 db  65h ; e
.data$r:00002947                 db  61h ; a
.data$r:00002948                 db  6Dh ; m
.data$r:00002949                 db  5Fh ; _
.data$r:0000294A                 db  65h ; e
.data$r:0000294B                 db  72h ; r
.data$r:0000294C                 db  72h ; r
.data$r:0000294D                 db  6Fh ; o
.data$r:0000294E                 db  72h ; r
.data$r:0000294F                 db  5Fh ; _
.data$r:00002950                 db  63h ; c
.data$r:00002951                 db  61h ; a
.data$r:00002952                 db  74h ; t
.data$r:00002953                 db  65h ; e
.data$r:00002954                 db  67h ; g
.data$r:00002955                 db  6Fh ; o
.data$r:00002956                 db  72h ; r
.data$r:00002957                 db  79h ; y
.data$r:00002958                 db  40h ; @
.data$r:00002959                 db  73h ; s
.data$r:0000295A                 db  74h ; t
.data$r:0000295B                 db  64h ; d
.data$r:0000295C                 db  40h ; @
.data$r:0000295D                 db  40h ; @
.data$r:0000295E                 db    0
.data$r:0000295F                 align 10h
.data$r:0000295F _data$r         ends
.data$r:0000295F
.rdata$r:00002960 ; ===========================================================================
.rdata$r:00002960
.rdata$r:00002960 ; Segment type: Pure data
.rdata$r:00002960 ; Segment permissions: Read
.rdata$r:00002960 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002960                 assume cs:_rdata$r
.rdata$r:00002960                 ;org 2960h
.rdata$r:00002960 ; COMDAT (pick any)
.rdata$r:00002960                 public ??_R3_Iostream_error_category@std@@8
.rdata$r:00002960 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002960 ??_R3_Iostream_error_category@std@@8 db    0
.rdata$r:00002960                                         ; DATA XREF: .rdata$r:00002930o
.rdata$r:00002960                                         ; .rdata$r:00002998o
.rdata$r:00002961                 db    0
.rdata$r:00002962                 db    0
.rdata$r:00002963                 db    0
.rdata$r:00002964                 db    0
.rdata$r:00002965                 db    0
.rdata$r:00002966                 db    0
.rdata$r:00002967                 db    0
.rdata$r:00002968                 db    3
.rdata$r:00002969                 db    0
.rdata$r:0000296A                 db    0
.rdata$r:0000296B                 db    0
.rdata$r:0000296C                 dd offset ??_R2_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
.rdata$r:0000296C _rdata$r        ends
.rdata$r:0000296C
.rdata$r:00002970 ; ===========================================================================
.rdata$r:00002970
.rdata$r:00002970 ; Segment type: Pure data
.rdata$r:00002970 ; Segment permissions: Read
.rdata$r:00002970 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002970                 assume cs:_rdata$r
.rdata$r:00002970                 ;org 2970h
.rdata$r:00002970 ; COMDAT (pick any)
.rdata$r:00002970                 public ??_R2_Iostream_error_category@std@@8
.rdata$r:00002970 ; std::_Iostream_error_category::`RTTI Base Class Array'
.rdata$r:00002970 ??_R2_Iostream_error_category@std@@8 dd offset ??_R1A@?0A@EA@_Iostream_error_category@std@@8
.rdata$r:00002970                                         ; DATA XREF: .rdata$r:0000296Co
.rdata$r:00002970                                         ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002974                 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002978                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000297C                 db    0
.rdata$r:0000297D                 align 10h
.rdata$r:0000297D _rdata$r        ends
.rdata$r:0000297D
.rdata$r:00002980 ; ===========================================================================
.rdata$r:00002980
.rdata$r:00002980 ; Segment type: Pure data
.rdata$r:00002980 ; Segment permissions: Read
.rdata$r:00002980 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002980                 assume cs:_rdata$r
.rdata$r:00002980                 ;org 2980h
.rdata$r:00002980 ; COMDAT (pick any)
.rdata$r:00002980                 public ??_R1A@?0A@EA@_Iostream_error_category@std@@8
.rdata$r:00002980 ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00002980 ??_R1A@?0A@EA@_Iostream_error_category@std@@8 dd offset ??_R0?AV_Iostream_error_category@std@@@8
.rdata$r:00002980                                         ; DATA XREF: .rdata$r:std::_Iostream_error_category::`RTTI Base Class Array'o
.rdata$r:00002980                                         ; std::_Iostream_error_category `RTTI Type Descriptor'
.rdata$r:00002984                 db    2
.rdata$r:00002985                 db    0
.rdata$r:00002986                 db    0
.rdata$r:00002987                 db    0
.rdata$r:00002988                 db    0
.rdata$r:00002989                 db    0
.rdata$r:0000298A                 db    0
.rdata$r:0000298B                 db    0
.rdata$r:0000298C                 db 0FFh
.rdata$r:0000298D                 db 0FFh
.rdata$r:0000298E                 db 0FFh
.rdata$r:0000298F                 db 0FFh
.rdata$r:00002990                 db    0
.rdata$r:00002991                 db    0
.rdata$r:00002992                 db    0
.rdata$r:00002993                 db    0
.rdata$r:00002994                 db  40h ; @
.rdata$r:00002995                 db    0
.rdata$r:00002996                 db    0
.rdata$r:00002997                 db    0
.rdata$r:00002998                 dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002998 _rdata$r        ends
.rdata$r:00002998
.rdata$r:0000299C ; ===========================================================================
.rdata$r:0000299C
.rdata$r:0000299C ; Segment type: Pure data
.rdata$r:0000299C ; Segment permissions: Read
.rdata$r:0000299C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000299C                 assume cs:_rdata$r
.rdata$r:0000299C                 ;org 299Ch
.rdata$r:0000299C ; COMDAT (pick any)
.rdata$r:0000299C                 public ??_R4_System_error_category@std@@6B@
.rdata$r:0000299C ; const std::_System_error_category::`RTTI Complete Object Locator'
.rdata$r:0000299C ??_R4_System_error_category@std@@6B@ db    0 ; DATA XREF: .rdata:00002698o
.rdata$r:0000299D                 db    0
.rdata$r:0000299E                 db    0
.rdata$r:0000299F                 db    0
.rdata$r:000029A0                 db    0
.rdata$r:000029A1                 db    0
.rdata$r:000029A2                 db    0
.rdata$r:000029A3                 db    0
.rdata$r:000029A4                 db    0
.rdata$r:000029A5                 db    0
.rdata$r:000029A6                 db    0
.rdata$r:000029A7                 db    0
.rdata$r:000029A8                 dd offset ??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category `RTTI Type Descriptor'
.rdata$r:000029AC                 dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000029AC _rdata$r        ends
.rdata$r:000029AC
.data$r:000029B0 ; ===========================================================================
.data$r:000029B0
.data$r:000029B0 ; Segment type: Pure data
.data$r:000029B0 ; Segment permissions: Read/Write
.data$r:000029B0 _data$r         segment dword public 'DATA' use32
.data$r:000029B0                 assume cs:_data$r
.data$r:000029B0                 ;org 29B0h
.data$r:000029B0 ; COMDAT (pick any)
.data$r:000029B0                 public ??_R0?AV_System_error_category@std@@@8
.data$r:000029B0 ; class std::_System_error_category `RTTI Type Descriptor'
.data$r:000029B0 ??_R0?AV_System_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:000029B0                                         ; DATA XREF: .rdata$r:000029A8o
.data$r:000029B0                                         ; .rdata$r:std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:000029B0                                         ; const type_info::`vftable'
.data$r:000029B4                 align 8
.data$r:000029B8 a_?av_system_er db '.?AV_System_error_category@std@@',0
.data$r:000029D9                 align 4
.data$r:000029D9 _data$r         ends
.data$r:000029D9
.rdata$r:000029DC ; ===========================================================================
.rdata$r:000029DC
.rdata$r:000029DC ; Segment type: Pure data
.rdata$r:000029DC ; Segment permissions: Read
.rdata$r:000029DC _rdata$r        segment dword public 'DATA' use32
.rdata$r:000029DC                 assume cs:_rdata$r
.rdata$r:000029DC                 ;org 29DCh
.rdata$r:000029DC ; COMDAT (pick any)
.rdata$r:000029DC                 public ??_R3_System_error_category@std@@8
.rdata$r:000029DC ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000029DC ??_R3_System_error_category@std@@8 db    0 ; DATA XREF: .rdata$r:000029ACo
.rdata$r:000029DC                                         ; .rdata$r:00002A14o
.rdata$r:000029DD                 db    0
.rdata$r:000029DE                 db    0
.rdata$r:000029DF                 db    0
.rdata$r:000029E0                 db    0
.rdata$r:000029E1                 db    0
.rdata$r:000029E2                 db    0
.rdata$r:000029E3                 db    0
.rdata$r:000029E4                 db    3
.rdata$r:000029E5                 db    0
.rdata$r:000029E6                 db    0
.rdata$r:000029E7                 db    0
.rdata$r:000029E8                 dd offset ??_R2_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
.rdata$r:000029E8 _rdata$r        ends
.rdata$r:000029E8
.rdata$r:000029EC ; ===========================================================================
.rdata$r:000029EC
.rdata$r:000029EC ; Segment type: Pure data
.rdata$r:000029EC ; Segment permissions: Read
.rdata$r:000029EC _rdata$r        segment dword public 'DATA' use32
.rdata$r:000029EC                 assume cs:_rdata$r
.rdata$r:000029EC                 ;org 29ECh
.rdata$r:000029EC ; COMDAT (pick any)
.rdata$r:000029EC                 public ??_R2_System_error_category@std@@8
.rdata$r:000029EC ; std::_System_error_category::`RTTI Base Class Array'
.rdata$r:000029EC ??_R2_System_error_category@std@@8 dd offset ??_R1A@?0A@EA@_System_error_category@std@@8
.rdata$r:000029EC                                         ; DATA XREF: .rdata$r:000029E8o
.rdata$r:000029EC                                         ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000029F0                 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000029F4                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000029F8                 db    0
.rdata$r:000029F9                 align 4
.rdata$r:000029F9 _rdata$r        ends
.rdata$r:000029F9
.rdata$r:000029FC ; ===========================================================================
.rdata$r:000029FC
.rdata$r:000029FC ; Segment type: Pure data
.rdata$r:000029FC ; Segment permissions: Read
.rdata$r:000029FC _rdata$r        segment dword public 'DATA' use32
.rdata$r:000029FC                 assume cs:_rdata$r
.rdata$r:000029FC                 ;org 29FCh
.rdata$r:000029FC ; COMDAT (pick any)
.rdata$r:000029FC                 public ??_R1A@?0A@EA@_System_error_category@std@@8
.rdata$r:000029FC ; std::_System_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:000029FC ??_R1A@?0A@EA@_System_error_category@std@@8 dd offset ??_R0?AV_System_error_category@std@@@8
.rdata$r:000029FC                                         ; DATA XREF: .rdata$r:std::_System_error_category::`RTTI Base Class Array'o
.rdata$r:000029FC                                         ; std::_System_error_category `RTTI Type Descriptor'
.rdata$r:00002A00                 db    2
.rdata$r:00002A01                 db    0
.rdata$r:00002A02                 db    0
.rdata$r:00002A03                 db    0
.rdata$r:00002A04                 db    0
.rdata$r:00002A05                 db    0
.rdata$r:00002A06                 db    0
.rdata$r:00002A07                 db    0
.rdata$r:00002A08                 db 0FFh
.rdata$r:00002A09                 db 0FFh
.rdata$r:00002A0A                 db 0FFh
.rdata$r:00002A0B                 db 0FFh
.rdata$r:00002A0C                 db    0
.rdata$r:00002A0D                 db    0
.rdata$r:00002A0E                 db    0
.rdata$r:00002A0F                 db    0
.rdata$r:00002A10                 db  40h ; @
.rdata$r:00002A11                 db    0
.rdata$r:00002A12                 db    0
.rdata$r:00002A13                 db    0
.rdata$r:00002A14                 dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002A14 _rdata$r        ends
.rdata$r:00002A14
.CRT$XCU:00002A18 ; ===========================================================================
.CRT$XCU:00002A18
.CRT$XCU:00002A18 ; Segment type: Pure data
.CRT$XCU:00002A18 ; Segment permissions: Read
.CRT$XCU:00002A18 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00002A18                 assume cs:_CRT$XCU
.CRT$XCU:00002A18                 ;org 2A18h
.CRT$XCU:00002A18 _piecewise_construct$initializer$ dd offset ??__Epiecewise_construct@std@@YAXXZ ; std::`dynamic initializer for 'piecewise_construct''(void)
.CRT$XCU:00002A1C _allocator_arg$initializer$ dd offset ??__Eallocator_arg@std@@YAXXZ ; std::`dynamic initializer for 'allocator_arg''(void)
.CRT$XCU:00002A1C _CRT$XCU        ends
.CRT$XCU:00002A1C
.CRT$XCU:00002A20 ; ===========================================================================
.CRT$XCU:00002A20
.CRT$XCU:00002A20 ; Segment type: Pure data
.CRT$XCU:00002A20 ; Segment permissions: Read
.CRT$XCU:00002A20 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00002A20                 assume cs:_CRT$XCU
.CRT$XCU:00002A20                 ;org 2A20h
.CRT$XCU:00002A20 ; COMDAT (pick associative to section at 26BC)
.CRT$XCU:00002A20 ; public: static void (__cdecl *std::_Error_objects<int>::_Generic_object$initializer$)(void)
.CRT$XCU:00002A20 ?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
.CRT$XCU:00002A20 _CRT$XCU        ends
.CRT$XCU:00002A20
.CRT$XCU:00002A24 ; ===========================================================================
.CRT$XCU:00002A24
.CRT$XCU:00002A24 ; Segment type: Pure data
.CRT$XCU:00002A24 ; Segment permissions: Read
.CRT$XCU:00002A24 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00002A24                 assume cs:_CRT$XCU
.CRT$XCU:00002A24                 ;org 2A24h
.CRT$XCU:00002A24 ; COMDAT (pick associative to section at 26C0)
.CRT$XCU:00002A24 ; public: static void (__cdecl *std::_Error_objects<int>::_Iostream_object$initializer$)(void)
.CRT$XCU:00002A24 ?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
.CRT$XCU:00002A24 _CRT$XCU        ends
.CRT$XCU:00002A24
.CRT$XCU:00002A28 ; ===========================================================================
.CRT$XCU:00002A28
.CRT$XCU:00002A28 ; Segment type: Pure data
.CRT$XCU:00002A28 ; Segment permissions: Read
.CRT$XCU:00002A28 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00002A28                 assume cs:_CRT$XCU
.CRT$XCU:00002A28                 ;org 2A28h
.CRT$XCU:00002A28 ; COMDAT (pick associative to section at 26C4)
.CRT$XCU:00002A28 ; public: static void (__cdecl *std::_Error_objects<int>::_System_object$initializer$)(void)
.CRT$XCU:00002A28 ?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)
.CRT$XCU:00002A28 _CRT$XCU        ends
.CRT$XCU:00002A28
.CRT$XCU:00002A2C ; ===========================================================================
.CRT$XCU:00002A2C
.CRT$XCU:00002A2C ; Segment type: Pure data
.CRT$XCU:00002A2C ; Segment permissions: Read
.CRT$XCU:00002A2C _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00002A2C                 assume cs:_CRT$XCU
.CRT$XCU:00002A2C                 ;org 2A2Ch
.CRT$XCU:00002A2C ; COMDAT (pick associative to section at 26C8)
.CRT$XCU:00002A2C ; public: static void (__cdecl *std::num_put<char, class std::back_insert_iterator<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>::id$initializer$)(void)
.CRT$XCU:00002A2C ?id$initializer$@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2P6AXXZA dd offset ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)
.CRT$XCU:00002A2C _CRT$XCU        ends
.CRT$XCU:00002A2C
.CRT$XCU:00002A30 ; ===========================================================================
.CRT$XCU:00002A30
.CRT$XCU:00002A30 ; Segment type: Pure data
.CRT$XCU:00002A30 ; Segment permissions: Read
.CRT$XCU:00002A30 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00002A30                 assume cs:_CRT$XCU
.CRT$XCU:00002A30                 ;org 2A30h
.CRT$XCU:00002A30 ; COMDAT (pick associative to section at 26CC)
.CRT$XCU:00002A30 ; public: static void (__cdecl *std::num_put<wchar_t, class std::back_insert_iterator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::id$initializer$)(void)
.CRT$XCU:00002A30 ?id$initializer$@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2P6AXXZA dd offset ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)
.CRT$XCU:00002A30 _CRT$XCU        ends
.CRT$XCU:00002A30
.CRT$XCU:00002A34 ; ===========================================================================
.CRT$XCU:00002A34
.CRT$XCU:00002A34 ; Segment type: Pure data
.CRT$XCU:00002A34 ; Segment permissions: Read
.CRT$XCU:00002A34 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00002A34                 assume cs:_CRT$XCU
.CRT$XCU:00002A34                 ;org 2A34h
.CRT$XCU:00002A34 ; COMDAT (pick associative to section at 2760)
.CRT$XCU:00002A34 ; public: static void (__cdecl *std::numpunct<char>::id$initializer$)(void)
.CRT$XCU:00002A34 ?id$initializer$@?$numpunct@D@std@@2P6AXXZA dd offset ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::numpunct<char>::id''(void)
.CRT$XCU:00002A34 _CRT$XCU        ends
.CRT$XCU:00002A34
.CRT$XCU:00002A38 ; ===========================================================================
.CRT$XCU:00002A38
.CRT$XCU:00002A38 ; Segment type: Pure data
.CRT$XCU:00002A38 ; Segment permissions: Read
.CRT$XCU:00002A38 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00002A38                 assume cs:_CRT$XCU
.CRT$XCU:00002A38                 ;org 2A38h
.CRT$XCU:00002A38 ; COMDAT (pick associative to section at 2764)
.CRT$XCU:00002A38 ; public: static void (__cdecl *std::numpunct<wchar_t>::id$initializer$)(void)
.CRT$XCU:00002A38 ?id$initializer$@?$numpunct@_W@std@@2P6AXXZA dd offset ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::numpunct<wchar_t>::id''(void)
.CRT$XCU:00002A38 _CRT$XCU        ends
.CRT$XCU:00002A38
UNDEF:00002A40 ; ===========================================================================
UNDEF:00002A40
UNDEF:00002A40 ; Segment type: Externs
UNDEF:00002A40 ; UNDEF
UNDEF:00002A40                 extrn __purecall:near   ; DATA XREF: .rdata:00002610o
UNDEF:00002A40                                         ; .rdata:00002614o
UNDEF:00002A44 ; void *__cdecl operator new(unsigned int)
UNDEF:00002A44                 extrn ??2@YAPAXI@Z:near ; CODE XREF: std::_Allocate<char>(uint,char *)+1Dp
UNDEF:00002A44                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+23p
UNDEF:00002A48 ; void __cdecl operator delete(void *)
UNDEF:00002A48                 extrn ??3@YAXPAX@Z:near ; CODE XREF: std::_Generic_error_category::`scalar deleting destructor'(uint)+1Bp
UNDEF:00002A48                                         ; std::_Iostream_error_category::`scalar deleting destructor'(uint)+1Bp ...
UNDEF:00002A4C ; int __cdecl atexit(void (__cdecl *)())
UNDEF:00002A4C                 extrn _atexit:near      ; CODE XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+12p
UNDEF:00002A4C                                         ; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+12p ...
UNDEF:00002A50 ; void *__cdecl memcpy(void *Dst, const void *Src, size_t Size)
UNDEF:00002A50                 extrn _memcpy:near      ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+1Ep
UNDEF:00002A54 ; size_t __cdecl strlen(const char *Str)
UNDEF:00002A54                 extrn _strlen:near      ; CODE XREF: std::char_traits<char>::length(char const *)+1Bp
UNDEF:00002A58 ; void *__cdecl memmove(void *Dst, const void *Src, size_t Size)
UNDEF:00002A58                 extrn _memmove:near     ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+1Ep
UNDEF:00002A5C ; DWORD __stdcall GetLastError()
UNDEF:00002A5C                 extrn __imp__GetLastError@0:near
UNDEF:00002A5C                                         ; CODE XREF: DockingSplitter::runProc(HWND__ *,uint,uint,long)+B4p
UNDEF:00002A5C                                         ; DATA XREF: DockingSplitter::runProc(HWND__ *,uint,uint,long)+B4r
UNDEF:00002A60 ; int _wsprintfW(LPWSTR, LPCWSTR, ...)
UNDEF:00002A60                 extrn __imp__wsprintfW:near
UNDEF:00002A60                                         ; CODE XREF: DockingSplitter::runProc(HWND__ *,uint,uint,long)+D3p
UNDEF:00002A60                                         ; DATA XREF: DockingSplitter::runProc(HWND__ *,uint,uint,long)+D3r
UNDEF:00002A64 ; LRESULT __stdcall SendMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
UNDEF:00002A64                 extrn __imp__SendMessageW@16:near
UNDEF:00002A64                                         ; CODE XREF: DockingSplitter::runProc(HWND__ *,uint,uint,long)+1C5p
UNDEF:00002A64                                         ; DockingSplitter::runProc(HWND__ *,uint,uint,long)+207p
UNDEF:00002A64                                         ; DATA XREF: ...
UNDEF:00002A68 ; BOOL __stdcall PostMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
UNDEF:00002A68                 extrn __imp__PostMessageW@16:near
UNDEF:00002A68                                         ; CODE XREF: hookProcMouse(uint,uint,long)+50p
UNDEF:00002A68                                         ; hookProcMouse(uint,uint,long)+67p
UNDEF:00002A68                                         ; DATA XREF: ...
UNDEF:00002A6C ; LRESULT __stdcall DefWindowProcW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
UNDEF:00002A6C                 extrn __imp__DefWindowProcW@16:near
UNDEF:00002A6C                                         ; CODE XREF: DockingSplitter::staticWinProc(HWND__ *,uint,uint,long)+6Bp
UNDEF:00002A6C                                         ; DockingSplitter::runProc(HWND__ *,uint,uint,long)+235p
UNDEF:00002A6C                                         ; DATA XREF: ...
UNDEF:00002A70 ; ATOM __stdcall RegisterClassW(const WNDCLASSW *lpWndClass)
UNDEF:00002A70                 extrn __imp__RegisterClassW@4:near
UNDEF:00002A70                                         ; CODE XREF: DockingSplitter::init(HINSTANCE__ *,HWND__ *,HWND__ *,uint)+CBp
UNDEF:00002A70                                         ; DATA XREF: DockingSplitter::init(HINSTANCE__ *,HWND__ *,HWND__ *,uint)+CBr
UNDEF:00002A74 ; HWND __stdcall CreateWindowExW(DWORD dwExStyle, LPCWSTR lpClassName, LPCWSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam)
UNDEF:00002A74                 extrn __imp__CreateWindowExW@48:near
UNDEF:00002A74                                         ; CODE XREF: DockingSplitter::init(HINSTANCE__ *,HWND__ *,HWND__ *,uint)+14Bp
UNDEF:00002A74                                         ; DATA XREF: DockingSplitter::init(HINSTANCE__ *,HWND__ *,HWND__ *,uint)+14Br
UNDEF:00002A78 ; HWND __stdcall SetCapture(HWND hWnd)
UNDEF:00002A78                 extrn __imp__SetCapture@4:near
UNDEF:00002A78                                         ; CODE XREF: DockingSplitter::runProc(HWND__ *,uint,uint,long)+FEp
UNDEF:00002A78                                         ; DockingSplitter::runProc(HWND__ *,uint,uint,long)+13Ep
UNDEF:00002A78                                         ; DATA XREF: ...
UNDEF:00002A7C ; int __stdcall MessageBoxW(HWND hWnd, LPCWSTR lpText, LPCWSTR lpCaption, UINT uType)
UNDEF:00002A7C                 extrn __imp__MessageBoxW@16:near
UNDEF:00002A7C                                         ; CODE XREF: DockingSplitter::runProc(HWND__ *,uint,uint,long)+ECp
UNDEF:00002A7C                                         ; DATA XREF: DockingSplitter::runProc(HWND__ *,uint,uint,long)+ECr
UNDEF:00002A80 ; BOOL __stdcall GetCursorPos(LPPOINT lpPoint)
UNDEF:00002A80                 extrn __imp__GetCursorPos@4:near
UNDEF:00002A80                                         ; CODE XREF: DockingSplitter::runProc(HWND__ *,uint,uint,long)+10Ep
UNDEF:00002A80                                         ; DockingSplitter::runProc(HWND__ *,uint,uint,long)+177p
UNDEF:00002A80                                         ; DATA XREF: ...
UNDEF:00002A84 ; LONG __stdcall GetWindowLongW(HWND hWnd, int nIndex)
UNDEF:00002A84                 extrn __imp__GetWindowLongW@8:near
UNDEF:00002A84                                         ; CODE XREF: DockingSplitter::staticWinProc(HWND__ *,uint,uint,long)+4Cp
UNDEF:00002A84                                         ; DATA XREF: DockingSplitter::staticWinProc(HWND__ *,uint,uint,long)+4Cr
UNDEF:00002A88 ; LONG __stdcall SetWindowLongW(HWND hWnd, int nIndex, LONG dwNewLong)
UNDEF:00002A88                 extrn __imp__SetWindowLongW@12:near
UNDEF:00002A88                                         ; CODE XREF: DockingSplitter::staticWinProc(HWND__ *,uint,uint,long)+39p
UNDEF:00002A88                                         ; DATA XREF: DockingSplitter::staticWinProc(HWND__ *,uint,uint,long)+39r
UNDEF:00002A8C ; HHOOK __stdcall SetWindowsHookExW(int idHook, HOOKPROC lpfn, HINSTANCE hmod, DWORD dwThreadId)
UNDEF:00002A8C                 extrn __imp__SetWindowsHookExW@16:near
UNDEF:00002A8C                                         ; CODE XREF: DockingSplitter::runProc(HWND__ *,uint,uint,long)+A0p
UNDEF:00002A8C                                         ; DATA XREF: DockingSplitter::runProc(HWND__ *,uint,uint,long)+A0r
UNDEF:00002A90 ; BOOL __stdcall UnhookWindowsHookEx(HHOOK hhk)
UNDEF:00002A90                 extrn __imp__UnhookWindowsHookEx@4:near
UNDEF:00002A90                                         ; CODE XREF: DockingSplitter::runProc(HWND__ *,uint,uint,long)+136p
UNDEF:00002A90                                         ; DATA XREF: DockingSplitter::runProc(HWND__ *,uint,uint,long)+136r
UNDEF:00002A94 ; LRESULT __stdcall CallNextHookEx(HHOOK hhk, int nCode, WPARAM wParam, LPARAM lParam)
UNDEF:00002A94                 extrn __imp__CallNextHookEx@16:near
UNDEF:00002A94                                         ; CODE XREF: hookProcMouse(uint,uint,long)+87p
UNDEF:00002A94                                         ; DATA XREF: hookProcMouse(uint,uint,long)+87r
UNDEF:00002A98 ; HCURSOR __stdcall LoadCursorW(HINSTANCE hInstance, LPCWSTR lpCursorName)
UNDEF:00002A98                 extrn __imp__LoadCursorW@8:near
UNDEF:00002A98                                         ; CODE XREF: DockingSplitter::init(HINSTANCE__ *,HWND__ *,HWND__ *,uint)+3Ap
UNDEF:00002A98                                         ; DockingSplitter::init(HINSTANCE__ *,HWND__ *,HWND__ *,uint)+53p
UNDEF:00002A98                                         ; DATA XREF: ...
UNDEF:00002A9C ; _DWORD __thiscall std::_Lockit::_Lockit(std::_Lockit *__hidden this, int)
UNDEF:00002A9C                 extrn ??0_Lockit@std@@QAE@H@Z:near
UNDEF:00002A9C                                         ; CODE XREF: std::_Container_base12::_Orphan_all(void)+35p
UNDEF:00002AA0 ; _DWORD __thiscall std::_Lockit::~_Lockit(std::_Lockit *__hidden this)
UNDEF:00002AA0                 extrn ??1_Lockit@std@@QAE@XZ:near
UNDEF:00002AA0                                         ; CODE XREF: std::_Container_base12::_Orphan_all(void)+86p
UNDEF:00002AA0                                         ; __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0+3j
UNDEF:00002AA4                 extrn __hypot:near      ; CODE XREF: _hypot+1Dp
UNDEF:00002AA8 ; _DWORD __thiscall std::exception::exception(std::exception *__hidden this, const char *const *)
UNDEF:00002AA8                 extrn ??0exception@std@@QAE@ABQBD@Z:near
UNDEF:00002AA8                                         ; CODE XREF: std::runtime_error::runtime_error(char const *)+2Dp
UNDEF:00002AAC ; _DWORD __thiscall std::exception::exception(std::exception *__hidden this, const struct std::exception *)
UNDEF:00002AAC                 extrn ??0exception@std@@QAE@ABV01@@Z:near
UNDEF:00002AAC                                         ; CODE XREF: std::runtime_error::runtime_error(std::runtime_error const &)+2Dp
UNDEF:00002AAC                                         ; DATA XREF: .xdata$x:00002604o
UNDEF:00002AB0 ; _DWORD __thiscall std::exception::~exception(std::exception *__hidden this)
UNDEF:00002AB0                 extrn ??1exception@std@@UAE@XZ:near
UNDEF:00002AB0                                         ; CODE XREF: __unwindfunclet$??0runtime_error@std@@QAE@ABV01@@Z$0+3j
UNDEF:00002AB0                                         ; __unwindfunclet$??0runtime_error@std@@QAE@PBD@Z$0+3j ...
UNDEF:00002AB4 ; public: virtual char const * __thiscall std::exception::what(void)const
UNDEF:00002AB4                 extrn ?what@exception@std@@UBEPBDXZ:near
UNDEF:00002AB4                                         ; DATA XREF: .rdata:00002574o
UNDEF:00002AB8 ; void __cdecl std::_Debug_message(const wchar_t *, const wchar_t *, unsigned int)
UNDEF:00002AB8                 extrn ?_Debug_message@std@@YAXPB_W0I@Z:near
UNDEF:00002AB8                                         ; CODE XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+16p
UNDEF:00002ABC ; void __cdecl std::_Xbad_alloc()
UNDEF:00002ABC                 extrn ?_Xbad_alloc@std@@YAXXZ:near
UNDEF:00002ABC                                         ; CODE XREF: std::_Allocate<char>(uint,char *):loc_69Ap
UNDEF:00002ABC                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *):loc_6DCp
UNDEF:00002AC0 ; void __cdecl std::_Xlength_error(const char *)
UNDEF:00002AC0                 extrn ?_Xlength_error@std@@YAXPBD@Z:near
UNDEF:00002AC0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+Cp
UNDEF:00002AC4 ; void __cdecl std::_Xout_of_range(const char *)
UNDEF:00002AC4                 extrn ?_Xout_of_range@std@@YAXPBD@Z:near
UNDEF:00002AC4                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+Cp
UNDEF:00002AC8 ; public: virtual void * __thiscall std::runtime_error::`vector deleting destructor'(unsigned int)
UNDEF:00002AC8                 extrn ??_Eruntime_error@std@@UAEPAXI@Z:near ; weak
UNDEF:00002AC8                                         ; DATA XREF: .rdata:const std::runtime_error::`vftable'o
UNDEF:00002ACC ; public: virtual void * __thiscall std::error_category::`vector deleting destructor'(unsigned int)
UNDEF:00002ACC                 extrn ??_Eerror_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00002ACC                                         ; DATA XREF: .rdata:const std::error_category::`vftable'o
UNDEF:00002AD0 ; const char *__cdecl std::_Syserror_map(int)
UNDEF:00002AD0                 extrn ?_Syserror_map@std@@YAPBDH@Z:near
UNDEF:00002AD0                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+Bp
UNDEF:00002AD0                                         ; std::_Generic_error_category::message(int)+33p
UNDEF:00002AD4 ; const char *__cdecl std::_Winerror_map(int)
UNDEF:00002AD4                 extrn ?_Winerror_map@std@@YAPBDH@Z:near
UNDEF:00002AD4                                         ; CODE XREF: std::_System_error_category::message(int)+33p
UNDEF:00002AD8 ; public: virtual void * __thiscall std::_Generic_error_category::`vector deleting destructor'(unsigned int)
UNDEF:00002AD8                 extrn ??_E_Generic_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00002AD8                                         ; DATA XREF: .rdata:const std::_Generic_error_category::`vftable'o
UNDEF:00002ADC ; public: virtual void * __thiscall std::_Iostream_error_category::`vector deleting destructor'(unsigned int)
UNDEF:00002ADC                 extrn ??_E_Iostream_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00002ADC                                         ; DATA XREF: .rdata:const std::_Iostream_error_category::`vftable'o
UNDEF:00002AE0 ; public: virtual void * __thiscall std::_System_error_category::`vector deleting destructor'(unsigned int)
UNDEF:00002AE0                 extrn ??_E_System_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00002AE0                                         ; DATA XREF: .rdata:const std::_System_error_category::`vftable'o
UNDEF:00002AE4 ; __fastcall __security_check_cookie(x)
UNDEF:00002AE4                 extrn @__security_check_cookie@4:near
UNDEF:00002AE4                                         ; CODE XREF: DockingSplitter::runProc(HWND__ *,uint,uint,long)+240p
UNDEF:00002AE4                                         ; __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z+Cp ...
UNDEF:00002AE8 ; __stdcall _CxxThrowException(x, x)
UNDEF:00002AE8                 extrn __CxxThrowException@8:near
UNDEF:00002AE8                                         ; CODE XREF: DockingSplitter::init(HINSTANCE__ *,HWND__ *,HWND__ *,uint)+EEp
UNDEF:00002AE8                                         ; DockingSplitter::init(HINSTANCE__ *,HWND__ *,HWND__ *,uint)+176p ...
UNDEF:00002AEC                 extrn ___CxxFrameHandler3:near
UNDEF:00002AEC                                         ; CODE XREF: __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z+16j
UNDEF:00002AEC                                         ; __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z+16j ...
UNDEF:00002AF0 ; const type_info::`vftable'
UNDEF:00002AF0                 extrn ??_7type_info@@6B@:near
UNDEF:00002AF0                                         ; DATA XREF: .data$r:std::runtime_error `RTTI Type Descriptor'o
UNDEF:00002AF0                                         ; .data$r:std::exception `RTTI Type Descriptor'o ...
UNDEF:00002AF4                 extrn ___security_cookie:near
UNDEF:00002AF4                                         ; DATA XREF: DockingSplitter::runProc(HWND__ *,uint,uint,long)+9r
UNDEF:00002AF4                                         ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)+14r ...
UNDEF:00002AF8                 extrn __fltused:near
UNDEF:00002AF8
UNDEF:00002AF8
UNDEF:00002AF8                 end