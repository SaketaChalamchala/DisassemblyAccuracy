.data:00000000 ;
.data:00000000 ; +-------------------------------------------------------------------------+
.data:00000000 ; |   This file has been generated by The Interactive Disassembler (IDA)    |
.data:00000000 ; |           Copyright (c) 2015 Hex-Rays, <support@hex-rays.com>           |
.data:00000000 ; |                      License info: 48-3677-7074-51                      |
.data:00000000 ; |             Michalis Polychronakis, Stony Brook University              |
.data:00000000 ; +-------------------------------------------------------------------------+
.data:00000000 ;
.data:00000000 ; Input MD5   : 9A2403C03E71D2955C110DDEE0DA1EC6
.data:00000000 ; Input CRC32 : 34B09EEC
.data:00000000
.data:00000000 ; File Name   : C:\workspace\notepad-plus-plus-6.7.9.2\PowerEditor\visual.net\Unicode Debug\WindowsDlg.obj
.data:00000000 ; Format      : COFF (X386MAGIC)
.data:00000000 ; includelib "libcpmtd"
.data:00000000 ; includelib "uuid.lib"
.data:00000000 ; must resolve: ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
.data:00000000 ; must resolve: ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
.data:00000000 ; must resolve: ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
.data:00000000 ; must resolve: ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
.data:00000000 ; must resolve: ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
.data:00000000 ; must resolve: ?id@?$numpunct@D@std@@2V0locale@2@A
.data:00000000 ; must resolve: ?id@?$numpunct@_W@std@@2V0locale@2@A
.data:00000000 ; includelib "LIBCMTD"
.data:00000000 ; includelib "OLDNAMES"
.data:00000000
.data:00000000                 include uni.inc ; see unicode subdir of ida for info on unicode
.data:00000000
.data:00000000                 .686p
.data:00000000                 .mmx
.data:00000000                 .model flat
.data:00000000
.data:00000000 ; ===========================================================================
.data:00000000
.data:00000000 ; Segment type: Pure data
.data:00000000 ; Segment permissions: Read/Write
.data:00000000 _data           segment dword public 'DATA' use32
.data:00000000                 assume cs:_data
.data:00000000 ; LPCWSTR readonlyString
.data:00000000 _readonlyString dd offset $SG132113     ; DATA XREF: WindowsDlg::run_dlgProc(uint,uint,long)+2AEr
.data:00000000                                         ; WindowsDlg::run_dlgProc(uint,uint,long)+2CCr
.data:00000000 _data           ends                    ; " [Read Only]"
.data:00000000
.rdata:00000004 ; ===========================================================================
.rdata:00000004
.rdata:00000004 ; Segment type: Pure data
.rdata:00000004 ; Segment permissions: Read
.rdata:00000004 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00000004 _rdata          segment para public 'DATA' use32
.rdata:00000004                 assume cs:_rdata
.rdata:00000004                 ;org 4
.rdata:00000004 $SG132113:                              ; DATA XREF: .data:_readonlyStringo
.rdata:00000004                 unicode 0, < [Read Only]>,0
.rdata:0000001E                 align 10h
.rdata:00000020 ; const WCHAR _SG132116
.rdata:00000020 $SG132116:                              ; DATA XREF: `dynamic initializer for 'WDN_NOTIFY''(void)+3o
.rdata:00000020                 unicode 0, <WDN_NOTIFY>,0
.rdata:00000036                 align 4
.rdata:00000038 $SG132287       db 'Call other initialize method',0
.rdata:00000038                                         ; DATA XREF: WindowsDlg::init(HINSTANCE__ *,HWND__ *)+7o
.rdata:00000055                 align 4
.rdata:00000058 $SG132341       db    0                 ; DATA XREF: WindowsDlg::run_dlgProc(uint,uint,long)+32Co
.rdata:00000059                 db    0
.rdata:0000005A                 db    0
.rdata:0000005B                 db    0
.rdata:0000005C ; wchar_t _SG132288
.rdata:0000005C $SG132288:                              ; DATA XREF: WindowsDlg::init(HINSTANCE__ *,HWND__ *)+15o
.rdata:0000005C                 unicode 0, <..\src\WinControls\WindowsDlg\WindowsDlg.cpp>,0
.rdata:000000B6                 align 4
.rdata:000000B8 ; char _SG132597[]
.rdata:000000B8 $SG132597       dd offset loc_6469      ; DATA XREF: WindowsDlg::changeDlgLang(void)+107o
.rdata:000000BC ; wchar_t _SG132289
.rdata:000000BC $SG132289:                              ; DATA XREF: WindowsDlg::init(HINSTANCE__ *,HWND__ *)+1Ao
.rdata:000000BC                 unicode 0, <!"Call other initialize method">,0
.rdata:000000FC ; char _SG132585[]
.rdata:000000FC $SG132585       db 'title',0            ; DATA XREF: WindowsDlg::changeDlgLang(void):loc_74Co
.rdata:00000102                 align 4
.rdata:00000104 ; char _SG132589[]
.rdata:00000104 $SG132589       db 'Item',0             ; DATA XREF: WindowsDlg::changeDlgLang(void):loc_7A9o
.rdata:00000109                 align 4
.rdata:0000010C ; char _SG132593[]
.rdata:0000010C $SG132593       db 'Item',0             ; DATA XREF: WindowsDlg::changeDlgLang(void):loc_7BEo
.rdata:00000111                 align 4
.rdata:00000114 ; char _SG132599[]
.rdata:00000114 $SG132599       db 'name',0             ; DATA XREF: WindowsDlg::changeDlgLang(void)+117o
.rdata:00000119                 align 4
.rdata:0000011C $SG132617:                              ; DATA XREF: WindowsDlg::onInitDialog(void)+15Bo
.rdata:0000011C                 unicode 0, <Name>,0
.rdata:00000126                 align 4
.rdata:00000128 $SG132618:                              ; DATA XREF: WindowsDlg::onInitDialog(void)+189o
.rdata:00000128                 unicode 0, <Path>,0
.rdata:00000132                 align 4
.rdata:00000134 $SG132619:                              ; DATA XREF: WindowsDlg::onInitDialog(void)+1B6o
.rdata:00000134                 unicode 0, <Type>,0
.rdata:0000013E                 align 10h
.rdata:00000140 _SIZEZERO       dd 0                    ; DATA XREF: WindowsDlg::WindowsDlg(void)+5Cr
.rdata:00000140                                         ; WindowsDlg::WindowsDlg(void)+70r
.rdata:00000144 dword_144       dd 0                    ; DATA XREF: WindowsDlg::WindowsDlg(void)+64r
.rdata:00000144                                         ; WindowsDlg::WindowsDlg(void)+78r
.rdata:00000148 ; wchar_t _SG133098
.rdata:00000148 $SG133098:                              ; DATA XREF: WindowsMenu::init(HINSTANCE__ *,HMENU__ *,wchar_t const *)+6Eo
.rdata:00000148                 unicode 0, <...>,0
.rdata:00000148 _rdata          ends
.rdata:00000148
.bss:00000150 ; ===========================================================================
.bss:00000150
.bss:00000150 ; Segment type: Uninitialized
.bss:00000150 ; Segment permissions: Read/Write
.bss:00000150 ; Segment alignment 'qword' can not be represented in assembly
.bss:00000150 _bss            segment para public 'BSS' use32
.bss:00000150                 assume cs:_bss
.bss:00000150                 ;org 150h
.bss:00000150                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:00000150                 public ?_lastKnownLocation@WindowsDlg@@1UtagRECT@@A
.bss:00000150 ; struct tagRECT WindowsDlg::_lastKnownLocation
.bss:00000150 ?_lastKnownLocation@WindowsDlg@@1UtagRECT@@A tagRECT <?>
.bss:00000150                                         ; DATA XREF: WindowsDlg::run_dlgProc(uint,uint,long):loc_959o
.bss:00000150                                         ; WindowsDlg::onInitDialog(void)+20Ar ...
.bss:00000160 __Tuple_alloc   db    ? ;
.bss:00000161 ; std::_Ignore ignore
.bss:00000161 _ignore         db    ? ;               ; DATA XREF: std::`dynamic initializer for 'ignore''(void)+3o
.bss:00000162 _allocator_arg  db    ? ;
.bss:00000163 _piecewise_construct db    ? ;
.bss:00000164                 public ?WDN_NOTIFY@@3IB
.bss:00000164 ; UINT WDN_NOTIFY
.bss:00000164 ?WDN_NOTIFY@@3IB dd ?                   ; DATA XREF: WindowsDlg::doSave(void)+3Ar
.bss:00000164                                         ; WindowsDlg::doSave(void)+DFr ...
.bss:00000168                 public ?WindowsDlgMap@@3PAVWINRECT@@A
.bss:00000168 ; struct WINRECT WindowsDlgMap
.bss:00000168 ?WindowsDlgMap@@3PAVWINRECT@@A db    ? ;
.bss:00000168                                         ; DATA XREF: WindowsDlg::WindowsDlg(void)+26o
.bss:00000168                                         ; `dynamic initializer for 'WindowsDlgMap''(void)+Co
.bss:00000169                 db    ? ;
.bss:0000016A                 db    ? ;
.bss:0000016B                 db    ? ;
.bss:0000016C                 db    ? ;
.bss:0000016D                 db    ? ;
.bss:0000016E                 db    ? ;
.bss:0000016F                 db    ? ;
.bss:00000170                 db    ? ;
.bss:00000171                 db    ? ;
.bss:00000172                 db    ? ;
.bss:00000173                 db    ? ;
.bss:00000174                 db    ? ;
.bss:00000175                 db    ? ;
.bss:00000176                 db    ? ;
.bss:00000177                 db    ? ;
.bss:00000178                 db    ? ;
.bss:00000179                 db    ? ;
.bss:0000017A                 db    ? ;
.bss:0000017B                 db    ? ;
.bss:0000017C                 db    ? ;
.bss:0000017D                 db    ? ;
.bss:0000017E                 db    ? ;
.bss:0000017F                 db    ? ;
.bss:00000180                 db    ? ;
.bss:00000181                 db    ? ;
.bss:00000182                 db    ? ;
.bss:00000183                 db    ? ;
.bss:00000184                 db    ? ;
.bss:00000185                 db    ? ;
.bss:00000186                 db    ? ;
.bss:00000187                 db    ? ;
.bss:00000188                 db    ? ;
.bss:00000189                 db    ? ;
.bss:0000018A                 db    ? ;
.bss:0000018B                 db    ? ;
.bss:0000018C unk_18C         db    ? ;               ; DATA XREF: `dynamic initializer for 'WindowsDlgMap''(void)+1Co
.bss:0000018D                 db    ? ;
.bss:0000018E                 db    ? ;
.bss:0000018F                 db    ? ;
.bss:00000190                 db    ? ;
.bss:00000191                 db    ? ;
.bss:00000192                 db    ? ;
.bss:00000193                 db    ? ;
.bss:00000194                 db    ? ;
.bss:00000195                 db    ? ;
.bss:00000196                 db    ? ;
.bss:00000197                 db    ? ;
.bss:00000198                 db    ? ;
.bss:00000199                 db    ? ;
.bss:0000019A                 db    ? ;
.bss:0000019B                 db    ? ;
.bss:0000019C                 db    ? ;
.bss:0000019D                 db    ? ;
.bss:0000019E                 db    ? ;
.bss:0000019F                 db    ? ;
.bss:000001A0                 db    ? ;
.bss:000001A1                 db    ? ;
.bss:000001A2                 db    ? ;
.bss:000001A3                 db    ? ;
.bss:000001A4                 db    ? ;
.bss:000001A5                 db    ? ;
.bss:000001A6                 db    ? ;
.bss:000001A7                 db    ? ;
.bss:000001A8                 db    ? ;
.bss:000001A9                 db    ? ;
.bss:000001AA                 db    ? ;
.bss:000001AB                 db    ? ;
.bss:000001AC                 db    ? ;
.bss:000001AD                 db    ? ;
.bss:000001AE                 db    ? ;
.bss:000001AF                 db    ? ;
.bss:000001B0 unk_1B0         db    ? ;               ; DATA XREF: `dynamic initializer for 'WindowsDlgMap''(void)+2Co
.bss:000001B1                 db    ? ;
.bss:000001B2                 db    ? ;
.bss:000001B3                 db    ? ;
.bss:000001B4                 db    ? ;
.bss:000001B5                 db    ? ;
.bss:000001B6                 db    ? ;
.bss:000001B7                 db    ? ;
.bss:000001B8                 db    ? ;
.bss:000001B9                 db    ? ;
.bss:000001BA                 db    ? ;
.bss:000001BB                 db    ? ;
.bss:000001BC                 db    ? ;
.bss:000001BD                 db    ? ;
.bss:000001BE                 db    ? ;
.bss:000001BF                 db    ? ;
.bss:000001C0                 db    ? ;
.bss:000001C1                 db    ? ;
.bss:000001C2                 db    ? ;
.bss:000001C3                 db    ? ;
.bss:000001C4                 db    ? ;
.bss:000001C5                 db    ? ;
.bss:000001C6                 db    ? ;
.bss:000001C7                 db    ? ;
.bss:000001C8                 db    ? ;
.bss:000001C9                 db    ? ;
.bss:000001CA                 db    ? ;
.bss:000001CB                 db    ? ;
.bss:000001CC                 db    ? ;
.bss:000001CD                 db    ? ;
.bss:000001CE                 db    ? ;
.bss:000001CF                 db    ? ;
.bss:000001D0                 db    ? ;
.bss:000001D1                 db    ? ;
.bss:000001D2                 db    ? ;
.bss:000001D3                 db    ? ;
.bss:000001D4 unk_1D4         db    ? ;               ; DATA XREF: `dynamic initializer for 'WindowsDlgMap''(void)+3Fo
.bss:000001D5                 db    ? ;
.bss:000001D6                 db    ? ;
.bss:000001D7                 db    ? ;
.bss:000001D8                 db    ? ;
.bss:000001D9                 db    ? ;
.bss:000001DA                 db    ? ;
.bss:000001DB                 db    ? ;
.bss:000001DC                 db    ? ;
.bss:000001DD                 db    ? ;
.bss:000001DE                 db    ? ;
.bss:000001DF                 db    ? ;
.bss:000001E0                 db    ? ;
.bss:000001E1                 db    ? ;
.bss:000001E2                 db    ? ;
.bss:000001E3                 db    ? ;
.bss:000001E4                 db    ? ;
.bss:000001E5                 db    ? ;
.bss:000001E6                 db    ? ;
.bss:000001E7                 db    ? ;
.bss:000001E8                 db    ? ;
.bss:000001E9                 db    ? ;
.bss:000001EA                 db    ? ;
.bss:000001EB                 db    ? ;
.bss:000001EC                 db    ? ;
.bss:000001ED                 db    ? ;
.bss:000001EE                 db    ? ;
.bss:000001EF                 db    ? ;
.bss:000001F0                 db    ? ;
.bss:000001F1                 db    ? ;
.bss:000001F2                 db    ? ;
.bss:000001F3                 db    ? ;
.bss:000001F4                 db    ? ;
.bss:000001F5                 db    ? ;
.bss:000001F6                 db    ? ;
.bss:000001F7                 db    ? ;
.bss:000001F8 unk_1F8         db    ? ;               ; DATA XREF: `dynamic initializer for 'WindowsDlgMap''(void)+4Fo
.bss:000001F9                 db    ? ;
.bss:000001FA                 db    ? ;
.bss:000001FB                 db    ? ;
.bss:000001FC                 db    ? ;
.bss:000001FD                 db    ? ;
.bss:000001FE                 db    ? ;
.bss:000001FF                 db    ? ;
.bss:00000200                 db    ? ;
.bss:00000201                 db    ? ;
.bss:00000202                 db    ? ;
.bss:00000203                 db    ? ;
.bss:00000204                 db    ? ;
.bss:00000205                 db    ? ;
.bss:00000206                 db    ? ;
.bss:00000207                 db    ? ;
.bss:00000208                 db    ? ;
.bss:00000209                 db    ? ;
.bss:0000020A                 db    ? ;
.bss:0000020B                 db    ? ;
.bss:0000020C                 db    ? ;
.bss:0000020D                 db    ? ;
.bss:0000020E                 db    ? ;
.bss:0000020F                 db    ? ;
.bss:00000210                 db    ? ;
.bss:00000211                 db    ? ;
.bss:00000212                 db    ? ;
.bss:00000213                 db    ? ;
.bss:00000214                 db    ? ;
.bss:00000215                 db    ? ;
.bss:00000216                 db    ? ;
.bss:00000217                 db    ? ;
.bss:00000218                 db    ? ;
.bss:00000219                 db    ? ;
.bss:0000021A                 db    ? ;
.bss:0000021B                 db    ? ;
.bss:0000021C unk_21C         db    ? ;               ; DATA XREF: `dynamic initializer for 'WindowsDlgMap''(void)+62o
.bss:0000021D                 db    ? ;
.bss:0000021E                 db    ? ;
.bss:0000021F                 db    ? ;
.bss:00000220                 db    ? ;
.bss:00000221                 db    ? ;
.bss:00000222                 db    ? ;
.bss:00000223                 db    ? ;
.bss:00000224                 db    ? ;
.bss:00000225                 db    ? ;
.bss:00000226                 db    ? ;
.bss:00000227                 db    ? ;
.bss:00000228                 db    ? ;
.bss:00000229                 db    ? ;
.bss:0000022A                 db    ? ;
.bss:0000022B                 db    ? ;
.bss:0000022C                 db    ? ;
.bss:0000022D                 db    ? ;
.bss:0000022E                 db    ? ;
.bss:0000022F                 db    ? ;
.bss:00000230                 db    ? ;
.bss:00000231                 db    ? ;
.bss:00000232                 db    ? ;
.bss:00000233                 db    ? ;
.bss:00000234                 db    ? ;
.bss:00000235                 db    ? ;
.bss:00000236                 db    ? ;
.bss:00000237                 db    ? ;
.bss:00000238                 db    ? ;
.bss:00000239                 db    ? ;
.bss:0000023A                 db    ? ;
.bss:0000023B                 db    ? ;
.bss:0000023C                 db    ? ;
.bss:0000023D                 db    ? ;
.bss:0000023E                 db    ? ;
.bss:0000023F                 db    ? ;
.bss:00000240 unk_240         db    ? ;               ; DATA XREF: `dynamic initializer for 'WindowsDlgMap''(void)+72o
.bss:00000241                 db    ? ;
.bss:00000242                 db    ? ;
.bss:00000243                 db    ? ;
.bss:00000244                 db    ? ;
.bss:00000245                 db    ? ;
.bss:00000246                 db    ? ;
.bss:00000247                 db    ? ;
.bss:00000248                 db    ? ;
.bss:00000249                 db    ? ;
.bss:0000024A                 db    ? ;
.bss:0000024B                 db    ? ;
.bss:0000024C                 db    ? ;
.bss:0000024D                 db    ? ;
.bss:0000024E                 db    ? ;
.bss:0000024F                 db    ? ;
.bss:00000250                 db    ? ;
.bss:00000251                 db    ? ;
.bss:00000252                 db    ? ;
.bss:00000253                 db    ? ;
.bss:00000254                 db    ? ;
.bss:00000255                 db    ? ;
.bss:00000256                 db    ? ;
.bss:00000257                 db    ? ;
.bss:00000258                 db    ? ;
.bss:00000259                 db    ? ;
.bss:0000025A                 db    ? ;
.bss:0000025B                 db    ? ;
.bss:0000025C                 db    ? ;
.bss:0000025D                 db    ? ;
.bss:0000025E                 db    ? ;
.bss:0000025F                 db    ? ;
.bss:00000260                 db    ? ;
.bss:00000261                 db    ? ;
.bss:00000262                 db    ? ;
.bss:00000263                 db    ? ;
.bss:00000264 unk_264         db    ? ;               ; DATA XREF: `dynamic initializer for 'WindowsDlgMap''(void)+82o
.bss:00000265                 db    ? ;
.bss:00000266                 db    ? ;
.bss:00000267                 db    ? ;
.bss:00000268                 db    ? ;
.bss:00000269                 db    ? ;
.bss:0000026A                 db    ? ;
.bss:0000026B                 db    ? ;
.bss:0000026C                 db    ? ;
.bss:0000026D                 db    ? ;
.bss:0000026E                 db    ? ;
.bss:0000026F                 db    ? ;
.bss:00000270                 db    ? ;
.bss:00000271                 db    ? ;
.bss:00000272                 db    ? ;
.bss:00000273                 db    ? ;
.bss:00000274                 db    ? ;
.bss:00000275                 db    ? ;
.bss:00000276                 db    ? ;
.bss:00000277                 db    ? ;
.bss:00000278                 db    ? ;
.bss:00000279                 db    ? ;
.bss:0000027A                 db    ? ;
.bss:0000027B                 db    ? ;
.bss:0000027C                 db    ? ;
.bss:0000027D                 db    ? ;
.bss:0000027E                 db    ? ;
.bss:0000027F                 db    ? ;
.bss:00000280                 db    ? ;
.bss:00000281                 db    ? ;
.bss:00000282                 db    ? ;
.bss:00000283                 db    ? ;
.bss:00000284                 db    ? ;
.bss:00000285                 db    ? ;
.bss:00000286                 db    ? ;
.bss:00000287                 db    ? ;
.bss:00000288 unk_288         db    ? ;               ; DATA XREF: `dynamic initializer for 'WindowsDlgMap''(void)+92o
.bss:00000289                 db    ? ;
.bss:0000028A                 db    ? ;
.bss:0000028B                 db    ? ;
.bss:0000028C                 db    ? ;
.bss:0000028D                 db    ? ;
.bss:0000028E                 db    ? ;
.bss:0000028F                 db    ? ;
.bss:00000290                 db    ? ;
.bss:00000291                 db    ? ;
.bss:00000292                 db    ? ;
.bss:00000293                 db    ? ;
.bss:00000294                 db    ? ;
.bss:00000295                 db    ? ;
.bss:00000296                 db    ? ;
.bss:00000297                 db    ? ;
.bss:00000298                 db    ? ;
.bss:00000299                 db    ? ;
.bss:0000029A                 db    ? ;
.bss:0000029B                 db    ? ;
.bss:0000029C                 db    ? ;
.bss:0000029D                 db    ? ;
.bss:0000029E                 db    ? ;
.bss:0000029F                 db    ? ;
.bss:000002A0                 db    ? ;
.bss:000002A1                 db    ? ;
.bss:000002A2                 db    ? ;
.bss:000002A3                 db    ? ;
.bss:000002A4                 db    ? ;
.bss:000002A5                 db    ? ;
.bss:000002A6                 db    ? ;
.bss:000002A7                 db    ? ;
.bss:000002A8                 db    ? ;
.bss:000002A9                 db    ? ;
.bss:000002AA                 db    ? ;
.bss:000002AB                 db    ? ;
.bss:000002AC unk_2AC         db    ? ;               ; DATA XREF: `dynamic initializer for 'WindowsDlgMap''(void)+A2o
.bss:000002AD                 db    ? ;
.bss:000002AE                 db    ? ;
.bss:000002AF                 db    ? ;
.bss:000002B0                 db    ? ;
.bss:000002B1                 db    ? ;
.bss:000002B2                 db    ? ;
.bss:000002B3                 db    ? ;
.bss:000002B4                 db    ? ;
.bss:000002B5                 db    ? ;
.bss:000002B6                 db    ? ;
.bss:000002B7                 db    ? ;
.bss:000002B8                 db    ? ;
.bss:000002B9                 db    ? ;
.bss:000002BA                 db    ? ;
.bss:000002BB                 db    ? ;
.bss:000002BC                 db    ? ;
.bss:000002BD                 db    ? ;
.bss:000002BE                 db    ? ;
.bss:000002BF                 db    ? ;
.bss:000002C0                 db    ? ;
.bss:000002C1                 db    ? ;
.bss:000002C2                 db    ? ;
.bss:000002C3                 db    ? ;
.bss:000002C4                 db    ? ;
.bss:000002C5                 db    ? ;
.bss:000002C6                 db    ? ;
.bss:000002C7                 db    ? ;
.bss:000002C8                 db    ? ;
.bss:000002C9                 db    ? ;
.bss:000002CA                 db    ? ;
.bss:000002CB                 db    ? ;
.bss:000002CC                 db    ? ;
.bss:000002CD                 db    ? ;
.bss:000002CE                 db    ? ;
.bss:000002CF                 db    ? ;
.bss:000002D0 unk_2D0         db    ? ;               ; DATA XREF: `dynamic initializer for 'WindowsDlgMap''(void)+B2o
.bss:000002D1                 db    ? ;
.bss:000002D2                 db    ? ;
.bss:000002D3                 db    ? ;
.bss:000002D4                 db    ? ;
.bss:000002D5                 db    ? ;
.bss:000002D6                 db    ? ;
.bss:000002D7                 db    ? ;
.bss:000002D8                 db    ? ;
.bss:000002D9                 db    ? ;
.bss:000002DA                 db    ? ;
.bss:000002DB                 db    ? ;
.bss:000002DC                 db    ? ;
.bss:000002DD                 db    ? ;
.bss:000002DE                 db    ? ;
.bss:000002DF                 db    ? ;
.bss:000002E0                 db    ? ;
.bss:000002E1                 db    ? ;
.bss:000002E2                 db    ? ;
.bss:000002E3                 db    ? ;
.bss:000002E4                 db    ? ;
.bss:000002E5                 db    ? ;
.bss:000002E6                 db    ? ;
.bss:000002E7                 db    ? ;
.bss:000002E8                 db    ? ;
.bss:000002E9                 db    ? ;
.bss:000002EA                 db    ? ;
.bss:000002EB                 db    ? ;
.bss:000002EC                 db    ? ;
.bss:000002ED                 db    ? ;
.bss:000002EE                 db    ? ;
.bss:000002EF                 db    ? ;
.bss:000002F0                 db    ? ;
.bss:000002F1                 db    ? ;
.bss:000002F2                 db    ? ;
.bss:000002F3                 db    ? ;
.bss:000002F4 unk_2F4         db    ? ;               ; DATA XREF: `dynamic initializer for 'WindowsDlgMap''(void)+C5o
.bss:000002F5                 db    ? ;
.bss:000002F6                 db    ? ;
.bss:000002F7                 db    ? ;
.bss:000002F8                 db    ? ;
.bss:000002F9                 db    ? ;
.bss:000002FA                 db    ? ;
.bss:000002FB                 db    ? ;
.bss:000002FC                 db    ? ;
.bss:000002FD                 db    ? ;
.bss:000002FE                 db    ? ;
.bss:000002FF                 db    ? ;
.bss:00000300                 db    ? ;
.bss:00000301                 db    ? ;
.bss:00000302                 db    ? ;
.bss:00000303                 db    ? ;
.bss:00000304                 db    ? ;
.bss:00000305                 db    ? ;
.bss:00000306                 db    ? ;
.bss:00000307                 db    ? ;
.bss:00000308                 db    ? ;
.bss:00000309                 db    ? ;
.bss:0000030A                 db    ? ;
.bss:0000030B                 db    ? ;
.bss:0000030C                 db    ? ;
.bss:0000030D                 db    ? ;
.bss:0000030E                 db    ? ;
.bss:0000030F                 db    ? ;
.bss:00000310                 db    ? ;
.bss:00000311                 db    ? ;
.bss:00000312                 db    ? ;
.bss:00000313                 db    ? ;
.bss:00000314                 db    ? ;
.bss:00000315                 db    ? ;
.bss:00000316                 db    ? ;
.bss:00000317                 db    ? ;
.bss:00000318 unk_318         db    ? ;               ; DATA XREF: `dynamic initializer for 'WindowsDlgMap''(void)+D5o
.bss:00000319                 db    ? ;
.bss:0000031A                 db    ? ;
.bss:0000031B                 db    ? ;
.bss:0000031C                 db    ? ;
.bss:0000031D                 db    ? ;
.bss:0000031E                 db    ? ;
.bss:0000031F                 db    ? ;
.bss:00000320                 db    ? ;
.bss:00000321                 db    ? ;
.bss:00000322                 db    ? ;
.bss:00000323                 db    ? ;
.bss:00000324                 db    ? ;
.bss:00000325                 db    ? ;
.bss:00000326                 db    ? ;
.bss:00000327                 db    ? ;
.bss:00000328                 db    ? ;
.bss:00000329                 db    ? ;
.bss:0000032A                 db    ? ;
.bss:0000032B                 db    ? ;
.bss:0000032C                 db    ? ;
.bss:0000032D                 db    ? ;
.bss:0000032E                 db    ? ;
.bss:0000032F                 db    ? ;
.bss:00000330                 db    ? ;
.bss:00000331                 db    ? ;
.bss:00000332                 db    ? ;
.bss:00000333                 db    ? ;
.bss:00000334                 db    ? ;
.bss:00000335                 db    ? ;
.bss:00000336                 db    ? ;
.bss:00000337                 db    ? ;
.bss:00000338                 db    ? ;
.bss:00000339                 db    ? ;
.bss:0000033A                 db    ? ;
.bss:0000033B                 db    ? ;
.bss:0000033C unk_33C         db    ? ;               ; DATA XREF: `dynamic initializer for 'WindowsDlgMap''(void)+E8o
.bss:0000033D                 db    ? ;
.bss:0000033E                 db    ? ;
.bss:0000033F                 db    ? ;
.bss:00000340                 db    ? ;
.bss:00000341                 db    ? ;
.bss:00000342                 db    ? ;
.bss:00000343                 db    ? ;
.bss:00000344                 db    ? ;
.bss:00000345                 db    ? ;
.bss:00000346                 db    ? ;
.bss:00000347                 db    ? ;
.bss:00000348                 db    ? ;
.bss:00000349                 db    ? ;
.bss:0000034A                 db    ? ;
.bss:0000034B                 db    ? ;
.bss:0000034C                 db    ? ;
.bss:0000034D                 db    ? ;
.bss:0000034E                 db    ? ;
.bss:0000034F                 db    ? ;
.bss:00000350                 db    ? ;
.bss:00000351                 db    ? ;
.bss:00000352                 db    ? ;
.bss:00000353                 db    ? ;
.bss:00000354                 db    ? ;
.bss:00000355                 db    ? ;
.bss:00000356                 db    ? ;
.bss:00000357                 db    ? ;
.bss:00000358                 db    ? ;
.bss:00000359                 db    ? ;
.bss:0000035A                 db    ? ;
.bss:0000035B                 db    ? ;
.bss:0000035C                 db    ? ;
.bss:0000035D                 db    ? ;
.bss:0000035E                 db    ? ;
.bss:0000035F                 db    ? ;
.bss:00000360 unk_360         db    ? ;               ; DATA XREF: `dynamic initializer for 'WindowsDlgMap''(void)+F8o
.bss:00000361                 db    ? ;
.bss:00000362                 db    ? ;
.bss:00000363                 db    ? ;
.bss:00000364                 db    ? ;
.bss:00000365                 db    ? ;
.bss:00000366                 db    ? ;
.bss:00000367                 db    ? ;
.bss:00000368                 db    ? ;
.bss:00000369                 db    ? ;
.bss:0000036A                 db    ? ;
.bss:0000036B                 db    ? ;
.bss:0000036C                 db    ? ;
.bss:0000036D                 db    ? ;
.bss:0000036E                 db    ? ;
.bss:0000036F                 db    ? ;
.bss:00000370                 db    ? ;
.bss:00000371                 db    ? ;
.bss:00000372                 db    ? ;
.bss:00000373                 db    ? ;
.bss:00000374                 db    ? ;
.bss:00000375                 db    ? ;
.bss:00000376                 db    ? ;
.bss:00000377                 db    ? ;
.bss:00000378                 db    ? ;
.bss:00000379                 db    ? ;
.bss:0000037A                 db    ? ;
.bss:0000037B                 db    ? ;
.bss:0000037C                 db    ? ;
.bss:0000037D                 db    ? ;
.bss:0000037E                 db    ? ;
.bss:0000037F                 db    ? ;
.bss:00000380                 db    ? ;
.bss:00000381                 db    ? ;
.bss:00000382                 db    ? ;
.bss:00000383                 db    ? ;
.bss:00000384 unk_384         db    ? ;               ; DATA XREF: `dynamic initializer for 'WindowsDlgMap''(void)+10Bo
.bss:00000385                 db    ? ;
.bss:00000386                 db    ? ;
.bss:00000387                 db    ? ;
.bss:00000388                 db    ? ;
.bss:00000389                 db    ? ;
.bss:0000038A                 db    ? ;
.bss:0000038B                 db    ? ;
.bss:0000038C                 db    ? ;
.bss:0000038D                 db    ? ;
.bss:0000038E                 db    ? ;
.bss:0000038F                 db    ? ;
.bss:00000390                 db    ? ;
.bss:00000391                 db    ? ;
.bss:00000392                 db    ? ;
.bss:00000393                 db    ? ;
.bss:00000394                 db    ? ;
.bss:00000395                 db    ? ;
.bss:00000396                 db    ? ;
.bss:00000397                 db    ? ;
.bss:00000398                 db    ? ;
.bss:00000399                 db    ? ;
.bss:0000039A                 db    ? ;
.bss:0000039B                 db    ? ;
.bss:0000039C                 db    ? ;
.bss:0000039D                 db    ? ;
.bss:0000039E                 db    ? ;
.bss:0000039F                 db    ? ;
.bss:000003A0                 db    ? ;
.bss:000003A1                 db    ? ;
.bss:000003A2                 db    ? ;
.bss:000003A3                 db    ? ;
.bss:000003A4                 db    ? ;
.bss:000003A5                 db    ? ;
.bss:000003A6                 db    ? ;
.bss:000003A7                 db    ? ;
.bss:000003A8 unk_3A8         db    ? ;               ; DATA XREF: `dynamic initializer for 'WindowsDlgMap''(void)+11Bo
.bss:000003A9                 db    ? ;
.bss:000003AA                 db    ? ;
.bss:000003AB                 db    ? ;
.bss:000003AC                 db    ? ;
.bss:000003AD                 db    ? ;
.bss:000003AE                 db    ? ;
.bss:000003AF                 db    ? ;
.bss:000003B0                 db    ? ;
.bss:000003B1                 db    ? ;
.bss:000003B2                 db    ? ;
.bss:000003B3                 db    ? ;
.bss:000003B4                 db    ? ;
.bss:000003B5                 db    ? ;
.bss:000003B6                 db    ? ;
.bss:000003B7                 db    ? ;
.bss:000003B8                 db    ? ;
.bss:000003B9                 db    ? ;
.bss:000003BA                 db    ? ;
.bss:000003BB                 db    ? ;
.bss:000003BC                 db    ? ;
.bss:000003BD                 db    ? ;
.bss:000003BE                 db    ? ;
.bss:000003BF                 db    ? ;
.bss:000003C0                 db    ? ;
.bss:000003C1                 db    ? ;
.bss:000003C2                 db    ? ;
.bss:000003C3                 db    ? ;
.bss:000003C4                 db    ? ;
.bss:000003C5                 db    ? ;
.bss:000003C6                 db    ? ;
.bss:000003C7                 db    ? ;
.bss:000003C8                 db    ? ;
.bss:000003C9                 db    ? ;
.bss:000003CA                 db    ? ;
.bss:000003CB                 db    ? ;
.bss:000003CC unk_3CC         db    ? ;               ; DATA XREF: `dynamic initializer for 'WindowsDlgMap''(void)+12Bo
.bss:000003CD                 db    ? ;
.bss:000003CE                 db    ? ;
.bss:000003CF                 db    ? ;
.bss:000003D0                 db    ? ;
.bss:000003D1                 db    ? ;
.bss:000003D2                 db    ? ;
.bss:000003D3                 db    ? ;
.bss:000003D4                 db    ? ;
.bss:000003D5                 db    ? ;
.bss:000003D6                 db    ? ;
.bss:000003D7                 db    ? ;
.bss:000003D8                 db    ? ;
.bss:000003D9                 db    ? ;
.bss:000003DA                 db    ? ;
.bss:000003DB                 db    ? ;
.bss:000003DC                 db    ? ;
.bss:000003DD                 db    ? ;
.bss:000003DE                 db    ? ;
.bss:000003DF                 db    ? ;
.bss:000003E0                 db    ? ;
.bss:000003E1                 db    ? ;
.bss:000003E2                 db    ? ;
.bss:000003E3                 db    ? ;
.bss:000003E4                 db    ? ;
.bss:000003E5                 db    ? ;
.bss:000003E6                 db    ? ;
.bss:000003E7                 db    ? ;
.bss:000003E8                 db    ? ;
.bss:000003E9                 db    ? ;
.bss:000003EA                 db    ? ;
.bss:000003EB                 db    ? ;
.bss:000003EC                 db    ? ;
.bss:000003ED                 db    ? ;
.bss:000003EE                 db    ? ;
.bss:000003EF                 db    ? ;
.bss:000003F0 unk_3F0         db    ? ;               ; DATA XREF: `dynamic initializer for 'WindowsDlgMap''(void)+13Eo
.bss:000003F1                 db    ? ;
.bss:000003F2                 db    ? ;
.bss:000003F3                 db    ? ;
.bss:000003F4                 db    ? ;
.bss:000003F5                 db    ? ;
.bss:000003F6                 db    ? ;
.bss:000003F7                 db    ? ;
.bss:000003F8                 db    ? ;
.bss:000003F9                 db    ? ;
.bss:000003FA                 db    ? ;
.bss:000003FB                 db    ? ;
.bss:000003FC                 db    ? ;
.bss:000003FD                 db    ? ;
.bss:000003FE                 db    ? ;
.bss:000003FF                 db    ? ;
.bss:00000400                 db    ? ;
.bss:00000401                 db    ? ;
.bss:00000402                 db    ? ;
.bss:00000403                 db    ? ;
.bss:00000404                 db    ? ;
.bss:00000405                 db    ? ;
.bss:00000406                 db    ? ;
.bss:00000407                 db    ? ;
.bss:00000408                 db    ? ;
.bss:00000409                 db    ? ;
.bss:0000040A                 db    ? ;
.bss:0000040B                 db    ? ;
.bss:0000040C                 db    ? ;
.bss:0000040D                 db    ? ;
.bss:0000040E                 db    ? ;
.bss:0000040F                 db    ? ;
.bss:00000410                 db    ? ;
.bss:00000411                 db    ? ;
.bss:00000412                 db    ? ;
.bss:00000413                 db    ? ;
.bss:00000414 unk_414         db    ? ;               ; DATA XREF: `dynamic initializer for 'WindowsDlgMap''(void)+151o
.bss:00000415                 db    ? ;
.bss:00000416                 db    ? ;
.bss:00000417                 db    ? ;
.bss:00000418                 db    ? ;
.bss:00000419                 db    ? ;
.bss:0000041A                 db    ? ;
.bss:0000041B                 db    ? ;
.bss:0000041C                 db    ? ;
.bss:0000041D                 db    ? ;
.bss:0000041E                 db    ? ;
.bss:0000041F                 db    ? ;
.bss:00000420                 db    ? ;
.bss:00000421                 db    ? ;
.bss:00000422                 db    ? ;
.bss:00000423                 db    ? ;
.bss:00000424                 db    ? ;
.bss:00000425                 db    ? ;
.bss:00000426                 db    ? ;
.bss:00000427                 db    ? ;
.bss:00000428                 db    ? ;
.bss:00000429                 db    ? ;
.bss:0000042A                 db    ? ;
.bss:0000042B                 db    ? ;
.bss:0000042C                 db    ? ;
.bss:0000042D                 db    ? ;
.bss:0000042E                 db    ? ;
.bss:0000042F                 db    ? ;
.bss:00000430                 db    ? ;
.bss:00000431                 db    ? ;
.bss:00000432                 db    ? ;
.bss:00000433                 db    ? ;
.bss:00000434                 db    ? ;
.bss:00000435                 db    ? ;
.bss:00000436                 db    ? ;
.bss:00000437                 db    ? ;
.bss:00000438 unk_438         db    ? ;               ; DATA XREF: `dynamic initializer for 'WindowsDlgMap''(void)+164o
.bss:00000439                 db    ? ;
.bss:0000043A                 db    ? ;
.bss:0000043B                 db    ? ;
.bss:0000043C                 db    ? ;
.bss:0000043D                 db    ? ;
.bss:0000043E                 db    ? ;
.bss:0000043F                 db    ? ;
.bss:00000440                 db    ? ;
.bss:00000441                 db    ? ;
.bss:00000442                 db    ? ;
.bss:00000443                 db    ? ;
.bss:00000444                 db    ? ;
.bss:00000445                 db    ? ;
.bss:00000446                 db    ? ;
.bss:00000447                 db    ? ;
.bss:00000448                 db    ? ;
.bss:00000449                 db    ? ;
.bss:0000044A                 db    ? ;
.bss:0000044B                 db    ? ;
.bss:0000044C                 db    ? ;
.bss:0000044D                 db    ? ;
.bss:0000044E                 db    ? ;
.bss:0000044F                 db    ? ;
.bss:00000450                 db    ? ;
.bss:00000451                 db    ? ;
.bss:00000452                 db    ? ;
.bss:00000453                 db    ? ;
.bss:00000454                 db    ? ;
.bss:00000455                 db    ? ;
.bss:00000456                 db    ? ;
.bss:00000457                 db    ? ;
.bss:00000458                 db    ? ;
.bss:00000459                 db    ? ;
.bss:0000045A                 db    ? ;
.bss:0000045B                 db    ? ;
.bss:0000045C unk_45C         db    ? ;               ; DATA XREF: `dynamic initializer for 'WindowsDlgMap''(void)+174o
.bss:0000045D                 db    ? ;
.bss:0000045E                 db    ? ;
.bss:0000045F                 db    ? ;
.bss:00000460                 db    ? ;
.bss:00000461                 db    ? ;
.bss:00000462                 db    ? ;
.bss:00000463                 db    ? ;
.bss:00000464                 db    ? ;
.bss:00000465                 db    ? ;
.bss:00000466                 db    ? ;
.bss:00000467                 db    ? ;
.bss:00000468                 db    ? ;
.bss:00000469                 db    ? ;
.bss:0000046A                 db    ? ;
.bss:0000046B                 db    ? ;
.bss:0000046C                 db    ? ;
.bss:0000046D                 db    ? ;
.bss:0000046E                 db    ? ;
.bss:0000046F                 db    ? ;
.bss:00000470                 db    ? ;
.bss:00000471                 db    ? ;
.bss:00000472                 db    ? ;
.bss:00000473                 db    ? ;
.bss:00000474                 db    ? ;
.bss:00000475                 db    ? ;
.bss:00000476                 db    ? ;
.bss:00000477                 db    ? ;
.bss:00000478                 db    ? ;
.bss:00000479                 db    ? ;
.bss:0000047A                 db    ? ;
.bss:0000047B                 db    ? ;
.bss:0000047C                 db    ? ;
.bss:0000047D                 db    ? ;
.bss:0000047E                 db    ? ;
.bss:0000047F                 db    ? ;
.bss:0000047F _bss            ends
.bss:0000047F
.text$mn:00000480 ; ===========================================================================
.text$mn:00000480
.text$mn:00000480 ; Segment type: Pure code
.text$mn:00000480 ; Segment permissions: Read/Execute
.text$mn:00000480 _text$mn        segment para public 'CODE' use32
.text$mn:00000480                 assume cs:_text$mn
.text$mn:00000480                 ;org 480h
.text$mn:00000480                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00000480
.text$mn:00000480 ; =============== S U B R O U T I N E =======================================
.text$mn:00000480
.text$mn:00000480 ; Attributes: bp-based frame
.text$mn:00000480
.text$mn:00000480 ; public: __thiscall WindowsDlg::WindowsDlg(void)
.text$mn:00000480                 public ??0WindowsDlg@@QAE@XZ
.text$mn:00000480 ??0WindowsDlg@@QAE@XZ proc near
.text$mn:00000480
.text$mn:00000480 var_10          = dword ptr -10h
.text$mn:00000480 var_C           = dword ptr -0Ch
.text$mn:00000480 var_4           = dword ptr -4
.text$mn:00000480
.text$mn:00000480                 push    ebp
.text$mn:00000481                 mov     ebp, esp
.text$mn:00000483                 push    0FFFFFFFFh
.text$mn:00000485                 push    offset __ehhandler$??0WindowsDlg@@QAE@XZ
.text$mn:0000048A                 mov     eax, large fs:0
.text$mn:00000490                 push    eax
.text$mn:00000491                 push    ecx
.text$mn:00000492                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000497                 xor     eax, ebp
.text$mn:00000499                 push    eax
.text$mn:0000049A                 lea     eax, [ebp+var_C]
.text$mn:0000049D                 mov     large fs:0, eax
.text$mn:000004A3                 mov     [ebp+var_10], ecx
.text$mn:000004A6                 push    offset ?WindowsDlgMap@@3PAVWINRECT@@A ; struct WINRECT *
.text$mn:000004AB                 mov     ecx, [ebp+var_10] ; this
.text$mn:000004AE                 call    ??0SizeableDlg@@QAE@PAVWINRECT@@@Z ; SizeableDlg::SizeableDlg(WINRECT *)
.text$mn:000004B3                 mov     [ebp+var_4], 0
.text$mn:000004BA                 mov     eax, [ebp+var_10]
.text$mn:000004BD                 mov     dword ptr [eax], offset ??_7WindowsDlg@@6B@ ; const WindowsDlg::`vftable'
.text$mn:000004C3                 mov     ecx, [ebp+var_10]
.text$mn:000004C6                 add     ecx, 40h ; '@'
.text$mn:000004C9                 call    ??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int>>::vector<int,std::allocator<int>>(void)
.text$mn:000004CE                 mov     byte ptr [ebp+var_4], 1
.text$mn:000004D2                 mov     ecx, [ebp+var_10]
.text$mn:000004D5                 mov     byte ptr [ecx+54h], 0
.text$mn:000004D9                 mov     edx, [ebp+var_10]
.text$mn:000004DC                 mov     eax, ds:_SIZEZERO
.text$mn:000004E1                 mov     [edx+2Ch], eax
.text$mn:000004E4                 mov     ecx, ds:dword_144
.text$mn:000004EA                 mov     [edx+30h], ecx
.text$mn:000004ED                 mov     edx, [ebp+var_10]
.text$mn:000004F0                 mov     eax, ds:_SIZEZERO
.text$mn:000004F5                 mov     [edx+34h], eax
.text$mn:000004F8                 mov     ecx, ds:dword_144
.text$mn:000004FE                 mov     [edx+38h], ecx
.text$mn:00000501                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000508                 mov     eax, [ebp+var_10]
.text$mn:0000050B                 mov     ecx, [ebp+var_C]
.text$mn:0000050E                 mov     large fs:0, ecx
.text$mn:00000515                 pop     ecx
.text$mn:00000516                 mov     esp, ebp
.text$mn:00000518                 pop     ebp
.text$mn:00000519                 retn
.text$mn:00000519 ??0WindowsDlg@@QAE@XZ endp
.text$mn:00000519
.text$mn:00000519 ; ---------------------------------------------------------------------------
.text$mn:0000051A                 align 10h
.text$mn:00000520
.text$mn:00000520 ; =============== S U B R O U T I N E =======================================
.text$mn:00000520
.text$mn:00000520 ; Attributes: bp-based frame
.text$mn:00000520
.text$mn:00000520 ; int __thiscall WindowsDlg::doDialog(WindowsDlg *this, struct TiXmlNodeA *)
.text$mn:00000520                 public ?doDialog@WindowsDlg@@QAEHPAVTiXmlNodeA@@@Z
.text$mn:00000520 ?doDialog@WindowsDlg@@QAEHPAVTiXmlNodeA@@@Z proc near
.text$mn:00000520
.text$mn:00000520 dwInitParam     = dword ptr -4
.text$mn:00000520 arg_0           = dword ptr  8
.text$mn:00000520
.text$mn:00000520                 push    ebp
.text$mn:00000521                 mov     ebp, esp
.text$mn:00000523                 push    ecx
.text$mn:00000524                 mov     [ebp+dwInitParam], ecx
.text$mn:00000527                 mov     eax, [ebp+dwInitParam]
.text$mn:0000052A                 mov     ecx, [ebp+arg_0]
.text$mn:0000052D                 mov     [eax+58h], ecx
.text$mn:00000530                 mov     edx, [ebp+dwInitParam]
.text$mn:00000533                 push    edx             ; dwInitParam
.text$mn:00000534                 push    offset ?dlgProc@StaticDialog@@KGHPAUHWND__@@IIJ@Z ; lpDialogFunc
.text$mn:00000539                 mov     eax, [ebp+dwInitParam]
.text$mn:0000053C                 mov     ecx, [eax+8]
.text$mn:0000053F                 push    ecx             ; hWndParent
.text$mn:00000540                 push    (offset loc_1B57+1) ; lpTemplateName
.text$mn:00000545                 mov     edx, [ebp+dwInitParam]
.text$mn:00000548                 mov     eax, [edx+4]
.text$mn:0000054B                 push    eax             ; hInstance
.text$mn:0000054C                 call    dword ptr ds:__imp__DialogBoxParamW@20 ; DialogBoxParamW(x,x,x,x,x)
.text$mn:00000552                 mov     esp, ebp
.text$mn:00000554                 pop     ebp
.text$mn:00000555                 retn    4
.text$mn:00000555 ?doDialog@WindowsDlg@@QAEHPAVTiXmlNodeA@@@Z endp
.text$mn:00000555
.text$mn:00000555 ; ---------------------------------------------------------------------------
.text$mn:00000558                 align 10h
.text$mn:00000560
.text$mn:00000560 ; =============== S U B R O U T I N E =======================================
.text$mn:00000560
.text$mn:00000560 ; Attributes: bp-based frame
.text$mn:00000560
.text$mn:00000560 ; void __thiscall WindowsDlg::init(WindowsDlg *this, HINSTANCE, HWND, struct DocTabView *)
.text$mn:00000560                 public ?init@WindowsDlg@@UAEXPAUHINSTANCE__@@PAUHWND__@@PAVDocTabView@@@Z
.text$mn:00000560 ?init@WindowsDlg@@UAEXPAUHINSTANCE__@@PAUHWND__@@PAVDocTabView@@@Z proc near
.text$mn:00000560                                         ; DATA XREF: .rdata:0000DF5Co
.text$mn:00000560
.text$mn:00000560 var_4           = dword ptr -4
.text$mn:00000560 arg_0           = dword ptr  8
.text$mn:00000560 arg_4           = dword ptr  0Ch
.text$mn:00000560 arg_8           = dword ptr  10h
.text$mn:00000560
.text$mn:00000560                 push    ebp
.text$mn:00000561                 mov     ebp, esp
.text$mn:00000563                 push    ecx
.text$mn:00000564                 mov     [ebp+var_4], ecx
.text$mn:00000567                 mov     eax, [ebp+arg_4]
.text$mn:0000056A                 push    eax             ; HWND
.text$mn:0000056B                 mov     ecx, [ebp+arg_0]
.text$mn:0000056E                 push    ecx             ; HINSTANCE
.text$mn:0000056F                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000572                 call    ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z ; Window::init(HINSTANCE__ *,HWND__ *)
.text$mn:00000577                 mov     edx, [ebp+var_4]
.text$mn:0000057A                 mov     eax, [ebp+arg_8]
.text$mn:0000057D                 mov     [edx+3Ch], eax
.text$mn:00000580                 mov     esp, ebp
.text$mn:00000582                 pop     ebp
.text$mn:00000583                 retn    0Ch
.text$mn:00000583 ?init@WindowsDlg@@UAEXPAUHINSTANCE__@@PAUHWND__@@PAVDocTabView@@@Z endp
.text$mn:00000583
.text$mn:00000583 ; ---------------------------------------------------------------------------
.text$mn:00000586                 align 10h
.text$mn:00000590
.text$mn:00000590 ; =============== S U B R O U T I N E =======================================
.text$mn:00000590
.text$mn:00000590 ; Attributes: bp-based frame
.text$mn:00000590
.text$mn:00000590 ; void __thiscall WindowsDlg::doRefresh(WindowsDlg *this, bool)
.text$mn:00000590                 public ?doRefresh@WindowsDlg@@QAEX_N@Z
.text$mn:00000590 ?doRefresh@WindowsDlg@@QAEX_N@Z proc near
.text$mn:00000590                                         ; CODE XREF: WindowsDlg::onInitDialog(void)+23Dp
.text$mn:00000590                                         ; WindowsDlg::doClose(void)+463p ...
.text$mn:00000590
.text$mn:00000590 lParam          = dword ptr -20h
.text$mn:00000590 var_1C          = dword ptr -1Ch
.text$mn:00000590 var_18          = dword ptr -18h
.text$mn:00000590 var_14          = dword ptr -14h
.text$mn:00000590 var_10          = dword ptr -10h
.text$mn:00000590 var_C           = dword ptr -0Ch
.text$mn:00000590 wParam          = dword ptr -8
.text$mn:00000590 var_4           = dword ptr -4
.text$mn:00000590 arg_0           = byte ptr  8
.text$mn:00000590
.text$mn:00000590                 push    ebp
.text$mn:00000591                 mov     ebp, esp
.text$mn:00000593                 sub     esp, 20h
.text$mn:00000596                 mov     [ebp+var_4], ecx
.text$mn:00000599                 mov     eax, [ebp+var_4]
.text$mn:0000059C                 cmp     dword ptr [eax+0Ch], 0
.text$mn:000005A0                 jz      loc_6CD
.text$mn:000005A6                 mov     ecx, [ebp+var_4]
.text$mn:000005A9                 mov     edx, [ecx]
.text$mn:000005AB                 mov     ecx, [ebp+var_4]
.text$mn:000005AE                 mov     eax, [edx+2Ch]
.text$mn:000005B1                 call    eax
.text$mn:000005B3                 movzx   ecx, al
.text$mn:000005B6                 test    ecx, ecx
.text$mn:000005B8                 jz      loc_6CD
.text$mn:000005BE                 mov     edx, [ebp+var_4]
.text$mn:000005C1                 cmp     dword ptr [edx+28h], 0
.text$mn:000005C5                 jz      loc_6CD
.text$mn:000005CB                 mov     eax, [ebp+var_4]
.text$mn:000005CE                 cmp     dword ptr [eax+3Ch], 0
.text$mn:000005D2                 jz      short loc_5E4
.text$mn:000005D4                 mov     ecx, [ebp+var_4]
.text$mn:000005D7                 mov     ecx, [ecx+3Ch]  ; this
.text$mn:000005DA                 call    ?nbItem@TabBar@@QBEHXZ ; TabBar::nbItem(void)
.text$mn:000005DF                 mov     [ebp+var_14], eax
.text$mn:000005E2                 jmp     short loc_5EB
.text$mn:000005E4 ; ---------------------------------------------------------------------------
.text$mn:000005E4
.text$mn:000005E4 loc_5E4:                                ; CODE XREF: WindowsDlg::doRefresh(bool)+42j
.text$mn:000005E4                 mov     [ebp+var_14], 0
.text$mn:000005EB
.text$mn:000005EB loc_5EB:                                ; CODE XREF: WindowsDlg::doRefresh(bool)+52j
.text$mn:000005EB                 mov     edx, [ebp+var_14]
.text$mn:000005EE                 mov     [ebp+wParam], edx
.text$mn:000005F1                 mov     ecx, [ebp+var_4]
.text$mn:000005F4                 add     ecx, 40h ; '@'
.text$mn:000005F7                 call    ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int>>::size(void)
.text$mn:000005FC                 mov     [ebp+var_10], eax
.text$mn:000005FF                 movzx   eax, [ebp+arg_0]
.text$mn:00000603                 test    eax, eax
.text$mn:00000605                 jnz     short loc_614
.text$mn:00000607                 mov     ecx, [ebp+wParam]
.text$mn:0000060A                 cmp     ecx, [ebp+var_10]
.text$mn:0000060D                 jnz     short loc_614
.text$mn:0000060F                 jmp     loc_6CD
.text$mn:00000614 ; ---------------------------------------------------------------------------
.text$mn:00000614
.text$mn:00000614 loc_614:                                ; CODE XREF: WindowsDlg::doRefresh(bool)+75j
.text$mn:00000614                                         ; WindowsDlg::doRefresh(bool)+7Dj
.text$mn:00000614                 mov     edx, [ebp+wParam]
.text$mn:00000617                 cmp     edx, [ebp+var_10]
.text$mn:0000061A                 jz      short loc_66F
.text$mn:0000061C                 mov     [ebp+var_18], 0
.text$mn:00000623                 mov     eax, [ebp+wParam]
.text$mn:00000626                 push    eax
.text$mn:00000627                 mov     ecx, [ebp+var_4]
.text$mn:0000062A                 add     ecx, 40h ; '@'
.text$mn:0000062D                 call    ?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z ; std::vector<int,std::allocator<int>>::resize(uint)
.text$mn:00000632                 mov     ecx, [ebp+var_10]
.text$mn:00000635                 cmp     ecx, [ebp+wParam]
.text$mn:00000638                 jnb     short loc_640
.text$mn:0000063A                 mov     edx, [ebp+var_10]
.text$mn:0000063D                 mov     [ebp+var_18], edx
.text$mn:00000640
.text$mn:00000640 loc_640:                                ; CODE XREF: WindowsDlg::doRefresh(bool)+A8j
.text$mn:00000640                 mov     eax, [ebp+var_18]
.text$mn:00000643                 mov     [ebp+var_C], eax
.text$mn:00000646                 jmp     short loc_651
.text$mn:00000648 ; ---------------------------------------------------------------------------
.text$mn:00000648
.text$mn:00000648 loc_648:                                ; CODE XREF: WindowsDlg::doRefresh(bool)+DDj
.text$mn:00000648                 mov     ecx, [ebp+var_C]
.text$mn:0000064B                 add     ecx, 1
.text$mn:0000064E                 mov     [ebp+var_C], ecx
.text$mn:00000651
.text$mn:00000651 loc_651:                                ; CODE XREF: WindowsDlg::doRefresh(bool)+B6j
.text$mn:00000651                 mov     edx, [ebp+var_C]
.text$mn:00000654                 cmp     edx, [ebp+wParam]
.text$mn:00000657                 jnb     short loc_66F
.text$mn:00000659                 mov     eax, [ebp+var_C]
.text$mn:0000065C                 push    eax
.text$mn:0000065D                 mov     ecx, [ebp+var_4]
.text$mn:00000660                 add     ecx, 40h ; '@'
.text$mn:00000663                 call    ??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z ; std::vector<int,std::allocator<int>>::operator[](uint)
.text$mn:00000668                 mov     ecx, [ebp+var_C]
.text$mn:0000066B                 mov     [eax], ecx
.text$mn:0000066D                 jmp     short loc_648
.text$mn:0000066F ; ---------------------------------------------------------------------------
.text$mn:0000066F
.text$mn:0000066F loc_66F:                                ; CODE XREF: WindowsDlg::doRefresh(bool)+8Aj
.text$mn:0000066F                                         ; WindowsDlg::doRefresh(bool)+C7j
.text$mn:0000066F                 movzx   edx, [ebp+arg_0]
.text$mn:00000673                 test    edx, edx
.text$mn:00000675                 jz      short loc_680
.text$mn:00000677                 mov     [ebp+var_1C], 3
.text$mn:0000067E                 jmp     short loc_687
.text$mn:00000680 ; ---------------------------------------------------------------------------
.text$mn:00000680
.text$mn:00000680 loc_680:                                ; CODE XREF: WindowsDlg::doRefresh(bool)+E5j
.text$mn:00000680                 mov     [ebp+var_1C], 2
.text$mn:00000687
.text$mn:00000687 loc_687:                                ; CODE XREF: WindowsDlg::doRefresh(bool)+EEj
.text$mn:00000687                 mov     eax, [ebp+var_1C]
.text$mn:0000068A                 mov     [ebp+lParam], eax
.text$mn:0000068D                 mov     ecx, [ebp+lParam]
.text$mn:00000690                 push    ecx             ; lParam
.text$mn:00000691                 mov     edx, [ebp+wParam]
.text$mn:00000694                 push    edx             ; wParam
.text$mn:00000695                 push    102Fh           ; Msg
.text$mn:0000069A                 mov     eax, [ebp+var_4]
.text$mn:0000069D                 mov     ecx, [eax+28h]
.text$mn:000006A0                 push    ecx             ; hWnd
.text$mn:000006A1                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:000006A7                 push    0               ; bErase
.text$mn:000006A9                 mov     edx, [ebp+var_4]
.text$mn:000006AC                 add     edx, 10h
.text$mn:000006AF                 push    edx             ; lpRect
.text$mn:000006B0                 mov     eax, [ebp+var_4]
.text$mn:000006B3                 mov     ecx, [eax+28h]
.text$mn:000006B6                 push    ecx             ; hWnd
.text$mn:000006B7                 call    dword ptr ds:__imp__InvalidateRect@12 ; InvalidateRect(x,x,x)
.text$mn:000006BD                 mov     ecx, [ebp+var_4] ; this
.text$mn:000006C0                 call    ?resetSelection@WindowsDlg@@IAEXXZ ; WindowsDlg::resetSelection(void)
.text$mn:000006C5                 mov     ecx, [ebp+var_4] ; this
.text$mn:000006C8                 call    ?updateButtonState@WindowsDlg@@IAEXXZ ; WindowsDlg::updateButtonState(void)
.text$mn:000006CD
.text$mn:000006CD loc_6CD:                                ; CODE XREF: WindowsDlg::doRefresh(bool)+10j
.text$mn:000006CD                                         ; WindowsDlg::doRefresh(bool)+28j ...
.text$mn:000006CD                 mov     esp, ebp
.text$mn:000006CF                 pop     ebp
.text$mn:000006D0                 retn    4
.text$mn:000006D0 ?doRefresh@WindowsDlg@@QAEX_N@Z endp
.text$mn:000006D0
.text$mn:000006D0 ; ---------------------------------------------------------------------------
.text$mn:000006D3                 align 10h
.text$mn:000006E0
.text$mn:000006E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000006E0
.text$mn:000006E0 ; Attributes: bp-based frame
.text$mn:000006E0
.text$mn:000006E0 ; bool __thiscall WindowsDlg::changeDlgLang(WindowsDlg *__hidden this)
.text$mn:000006E0                 public ?changeDlgLang@WindowsDlg@@QAE_NXZ
.text$mn:000006E0 ?changeDlgLang@WindowsDlg@@QAE_NXZ proc near
.text$mn:000006E0                                         ; CODE XREF: WindowsDlg::run_dlgProc(uint,uint,long)+6Bp
.text$mn:000006E0
.text$mn:000006E0 var_3C          = dword ptr -3Ch
.text$mn:000006E0 nIDDlgItem      = dword ptr -38h
.text$mn:000006E0 var_34          = dword ptr -34h
.text$mn:000006E0 lpString        = dword ptr -30h
.text$mn:000006E0 var_2C          = dword ptr -2Ch
.text$mn:000006E0 var_28          = dword ptr -28h
.text$mn:000006E0 hWnd            = dword ptr -24h
.text$mn:000006E0 var_20          = dword ptr -20h
.text$mn:000006E0 var_1C          = dword ptr -1Ch
.text$mn:000006E0 var_18          = dword ptr -18h
.text$mn:000006E0 var_14          = dword ptr -14h
.text$mn:000006E0 var_10          = dword ptr -10h
.text$mn:000006E0 var_C           = dword ptr -0Ch
.text$mn:000006E0 var_8           = dword ptr -8
.text$mn:000006E0 var_4           = dword ptr -4
.text$mn:000006E0
.text$mn:000006E0                 push    ebp
.text$mn:000006E1                 mov     ebp, esp
.text$mn:000006E3                 sub     esp, 3Ch
.text$mn:000006E6                 mov     [ebp+var_4], ecx
.text$mn:000006E9                 mov     eax, [ebp+var_4]
.text$mn:000006EC                 cmp     dword ptr [eax+58h], 0
.text$mn:000006F0                 jnz     short loc_6F9
.text$mn:000006F2                 xor     al, al
.text$mn:000006F4                 jmp     loc_86E
.text$mn:000006F9 ; ---------------------------------------------------------------------------
.text$mn:000006F9
.text$mn:000006F9 loc_6F9:                                ; CODE XREF: WindowsDlg::changeDlgLang(void)+10j
.text$mn:000006F9                 call    ?getInstance@WcharMbcsConvertor@@SAPAV1@XZ ; WcharMbcsConvertor::getInstance(void)
.text$mn:000006FE                 mov     [ebp+var_20], eax
.text$mn:00000701                 mov     [ebp+var_10], 0
.text$mn:00000708                 mov     ecx, [ebp+var_4]
.text$mn:0000070B                 mov     ecx, [ecx+58h]  ; this
.text$mn:0000070E                 call    ?GetDocument@TiXmlNodeA@@QBEPAVTiXmlDocumentA@@XZ ; TiXmlNodeA::GetDocument(void)
.text$mn:00000713                 mov     ecx, eax        ; this
.text$mn:00000715                 call    ?FirstChild@TiXmlNodeA@@QBEPAV1@XZ ; TiXmlNodeA::FirstChild(void)
.text$mn:0000071A                 mov     ecx, eax        ; this
.text$mn:0000071C                 call    ?ToDeclaration@TiXmlNodeA@@QBEPAVTiXmlDeclarationA@@XZ ; TiXmlNodeA::ToDeclaration(void)
.text$mn:00000721                 mov     [ebp+var_18], eax
.text$mn:00000724                 cmp     [ebp+var_18], 0
.text$mn:00000728                 jz      short loc_74C
.text$mn:0000072A                 mov     ecx, [ebp+var_18] ; this
.text$mn:0000072D                 call    ?Encoding@TiXmlDeclarationA@@QBEPBDXZ ; TiXmlDeclarationA::Encoding(void)
.text$mn:00000732                 mov     [ebp+var_28], eax
.text$mn:00000735                 call    ?getInstance@EncodingMapper@@SAPAV1@XZ ; EncodingMapper::getInstance(void)
.text$mn:0000073A                 mov     [ebp+var_2C], eax
.text$mn:0000073D                 mov     edx, [ebp+var_28]
.text$mn:00000740                 push    edx             ; char *
.text$mn:00000741                 mov     ecx, [ebp+var_2C] ; this
.text$mn:00000744                 call    ?getEncodingFromString@EncodingMapper@@QBEHPBD@Z ; EncodingMapper::getEncodingFromString(char const *)
.text$mn:00000749                 mov     [ebp+var_10], eax
.text$mn:0000074C
.text$mn:0000074C loc_74C:                                ; CODE XREF: WindowsDlg::changeDlgLang(void)+48j
.text$mn:0000074C                 push    offset $SG132585 ; "title"
.text$mn:00000751                 mov     eax, [ebp+var_4]
.text$mn:00000754                 mov     ecx, [eax+58h]  ; this
.text$mn:00000757                 call    ?ToElement@TiXmlNodeA@@QBEPAVTiXmlElementA@@XZ ; TiXmlNodeA::ToElement(void)
.text$mn:0000075C                 mov     ecx, eax        ; this
.text$mn:0000075E                 call    ?Attribute@TiXmlElementA@@QBEPBDPBD@Z ; TiXmlElementA::Attribute(char const *)
.text$mn:00000763                 mov     [ebp+var_C], eax
.text$mn:00000766                 cmp     [ebp+var_C], 0
.text$mn:0000076A                 jz      short loc_7A9
.text$mn:0000076C                 mov     ecx, 1
.text$mn:00000771                 imul    edx, ecx, 0
.text$mn:00000774                 mov     eax, [ebp+var_C]
.text$mn:00000777                 movsx   ecx, byte ptr [eax+edx]
.text$mn:0000077B                 test    ecx, ecx
.text$mn:0000077D                 jz      short loc_7A9
.text$mn:0000077F                 push    0               ; int *
.text$mn:00000781                 push    0               ; int *
.text$mn:00000783                 push    0FFFFFFFFh      ; int
.text$mn:00000785                 mov     edx, [ebp+var_10]
.text$mn:00000788                 push    edx             ; unsigned int
.text$mn:00000789                 mov     eax, [ebp+var_C]
.text$mn:0000078C                 push    eax             ; char *
.text$mn:0000078D                 mov     ecx, [ebp+var_20] ; this
.text$mn:00000790                 call    ?char2wchar@WcharMbcsConvertor@@QAEPB_WPBDIHPAH1@Z ; WcharMbcsConvertor::char2wchar(char const *,uint,int,int *,int *)
.text$mn:00000795                 mov     [ebp+lpString], eax
.text$mn:00000798                 mov     ecx, [ebp+lpString]
.text$mn:0000079B                 push    ecx             ; lpString
.text$mn:0000079C                 mov     edx, [ebp+var_4]
.text$mn:0000079F                 mov     eax, [edx+0Ch]
.text$mn:000007A2                 push    eax             ; hWnd
.text$mn:000007A3                 call    dword ptr ds:__imp__SetWindowTextW@8 ; SetWindowTextW(x,x)
.text$mn:000007A9
.text$mn:000007A9 loc_7A9:                                ; CODE XREF: WindowsDlg::changeDlgLang(void)+8Aj
.text$mn:000007A9                                         ; WindowsDlg::changeDlgLang(void)+9Dj
.text$mn:000007A9                 push    offset $SG132589 ; "Item"
.text$mn:000007AE                 mov     ecx, [ebp+var_4]
.text$mn:000007B1                 mov     ecx, [ecx+58h]  ; this
.text$mn:000007B4                 call    ?FirstChildElement@TiXmlNodeA@@QBEPAVTiXmlElementA@@PBD@Z ; TiXmlNodeA::FirstChildElement(char const *)
.text$mn:000007B9                 mov     [ebp+var_8], eax
.text$mn:000007BC                 jmp     short loc_7CE
.text$mn:000007BE ; ---------------------------------------------------------------------------
.text$mn:000007BE
.text$mn:000007BE loc_7BE:                                ; CODE XREF: WindowsDlg::changeDlgLang(void):loc_867j
.text$mn:000007BE                 push    offset $SG132593 ; "Item"
.text$mn:000007C3                 mov     ecx, [ebp+var_8] ; this
.text$mn:000007C6                 call    ?NextSibling@TiXmlNodeA@@QBEPAV1@PBD@Z ; TiXmlNodeA::NextSibling(char const *)
.text$mn:000007CB                 mov     [ebp+var_8], eax
.text$mn:000007CE
.text$mn:000007CE loc_7CE:                                ; CODE XREF: WindowsDlg::changeDlgLang(void)+DCj
.text$mn:000007CE                 cmp     [ebp+var_8], 0
.text$mn:000007D2                 jz      loc_86C
.text$mn:000007D8                 mov     ecx, [ebp+var_8] ; this
.text$mn:000007DB                 call    ?ToElement@TiXmlNodeA@@QBEPAVTiXmlElementA@@XZ ; TiXmlNodeA::ToElement(void)
.text$mn:000007E0                 mov     [ebp+var_1C], eax
.text$mn:000007E3                 lea     edx, [ebp+nIDDlgItem]
.text$mn:000007E6                 push    edx             ; int *
.text$mn:000007E7                 push    offset $SG132597 ; char *
.text$mn:000007EC                 mov     ecx, [ebp+var_1C] ; this
.text$mn:000007EF                 call    ?Attribute@TiXmlElementA@@QBEPBDPBDPAH@Z ; TiXmlElementA::Attribute(char const *,int *)
.text$mn:000007F4                 mov     [ebp+var_34], eax
.text$mn:000007F7                 push    offset $SG132599 ; "name"
.text$mn:000007FC                 mov     ecx, [ebp+var_1C] ; this
.text$mn:000007FF                 call    ?Attribute@TiXmlElementA@@QBEPBDPBD@Z ; TiXmlElementA::Attribute(char const *)
.text$mn:00000804                 mov     [ebp+var_14], eax
.text$mn:00000807                 cmp     [ebp+var_34], 0
.text$mn:0000080B                 jz      short loc_867
.text$mn:0000080D                 cmp     [ebp+var_14], 0
.text$mn:00000811                 jz      short loc_867
.text$mn:00000813                 mov     eax, 1
.text$mn:00000818                 imul    ecx, eax, 0
.text$mn:0000081B                 mov     edx, [ebp+var_14]
.text$mn:0000081E                 movsx   eax, byte ptr [edx+ecx]
.text$mn:00000822                 test    eax, eax
.text$mn:00000824                 jz      short loc_867
.text$mn:00000826                 mov     ecx, [ebp+nIDDlgItem]
.text$mn:00000829                 push    ecx             ; nIDDlgItem
.text$mn:0000082A                 mov     edx, [ebp+var_4]
.text$mn:0000082D                 mov     eax, [edx+0Ch]
.text$mn:00000830                 push    eax             ; hDlg
.text$mn:00000831                 call    dword ptr ds:__imp__GetDlgItem@8 ; GetDlgItem(x,x)
.text$mn:00000837                 mov     [ebp+hWnd], eax
.text$mn:0000083A                 cmp     [ebp+hWnd], 0
.text$mn:0000083E                 jz      short loc_867
.text$mn:00000840                 push    0               ; int *
.text$mn:00000842                 push    0               ; int *
.text$mn:00000844                 push    0FFFFFFFFh      ; int
.text$mn:00000846                 mov     ecx, [ebp+var_10]
.text$mn:00000849                 push    ecx             ; unsigned int
.text$mn:0000084A                 mov     edx, [ebp+var_14]
.text$mn:0000084D                 push    edx             ; char *
.text$mn:0000084E                 mov     ecx, [ebp+var_20] ; this
.text$mn:00000851                 call    ?char2wchar@WcharMbcsConvertor@@QAEPB_WPBDIHPAH1@Z ; WcharMbcsConvertor::char2wchar(char const *,uint,int,int *,int *)
.text$mn:00000856                 mov     [ebp+var_3C], eax
.text$mn:00000859                 mov     eax, [ebp+var_3C]
.text$mn:0000085C                 push    eax             ; lpString
.text$mn:0000085D                 mov     ecx, [ebp+hWnd]
.text$mn:00000860                 push    ecx             ; hWnd
.text$mn:00000861                 call    dword ptr ds:__imp__SetWindowTextW@8 ; SetWindowTextW(x,x)
.text$mn:00000867
.text$mn:00000867 loc_867:                                ; CODE XREF: WindowsDlg::changeDlgLang(void)+12Bj
.text$mn:00000867                                         ; WindowsDlg::changeDlgLang(void)+131j ...
.text$mn:00000867                 jmp     loc_7BE
.text$mn:0000086C ; ---------------------------------------------------------------------------
.text$mn:0000086C
.text$mn:0000086C loc_86C:                                ; CODE XREF: WindowsDlg::changeDlgLang(void)+F2j
.text$mn:0000086C                 mov     al, 1
.text$mn:0000086E
.text$mn:0000086E loc_86E:                                ; CODE XREF: WindowsDlg::changeDlgLang(void)+14j
.text$mn:0000086E                 mov     esp, ebp
.text$mn:00000870                 pop     ebp
.text$mn:00000871                 retn
.text$mn:00000871 ?changeDlgLang@WindowsDlg@@QAE_NXZ endp
.text$mn:00000871
.text$mn:00000871 ; ---------------------------------------------------------------------------
.text$mn:00000872                 align 10h
.text$mn:00000880
.text$mn:00000880 ; =============== S U B R O U T I N E =======================================
.text$mn:00000880
.text$mn:00000880 ; Attributes: bp-based frame
.text$mn:00000880
.text$mn:00000880 ; int __stdcall WindowsDlg::run_dlgProc(WindowsDlg *this, unsigned int, unsigned int, __int32)
.text$mn:00000880                 public ?run_dlgProc@WindowsDlg@@MAGHIIJ@Z
.text$mn:00000880 ?run_dlgProc@WindowsDlg@@MAGHIIJ@Z proc near ; DATA XREF: .rdata:0000DF48o
.text$mn:00000880
.text$mn:00000880 var_118         = dword ptr -118h
.text$mn:00000880 var_10C         = dword ptr -10Ch
.text$mn:00000880 var_108         = dword ptr -108h
.text$mn:00000880 lParam          = dword ptr -0E4h
.text$mn:00000880 var_D8          = dword ptr -0D8h
.text$mn:00000880 var_D4          = dword ptr -0D4h
.text$mn:00000880 var_B0          = byte ptr -0B0h
.text$mn:00000880 var_A0          = dword ptr -0A0h
.text$mn:00000880 var_9C          = dword ptr -9Ch
.text$mn:00000880 var_98          = dword ptr -98h
.text$mn:00000880 var_94          = dword ptr -94h
.text$mn:00000880 var_90          = byte ptr -90h
.text$mn:00000880 Source          = dword ptr -80h
.text$mn:00000880 var_7C          = dword ptr -7Ch
.text$mn:00000880 var_78          = dword ptr -78h
.text$mn:00000880 var_74          = dword ptr -74h
.text$mn:00000880 var_70          = dword ptr -70h
.text$mn:00000880 var_6C          = dword ptr -6Ch
.text$mn:00000880 var_68          = dword ptr -68h
.text$mn:00000880 var_64          = dword ptr -64h
.text$mn:00000880 var_60          = dword ptr -60h
.text$mn:00000880 var_5C          = dword ptr -5Ch
.text$mn:00000880 var_58          = dword ptr -58h
.text$mn:00000880 var_54          = dword ptr -54h
.text$mn:00000880 var_50          = dword ptr -50h
.text$mn:00000880 var_4C          = word ptr -4Ch
.text$mn:00000880 var_48          = dword ptr -48h
.text$mn:00000880 var_44          = word ptr -44h
.text$mn:00000880 lpString        = dword ptr -40h
.text$mn:00000880 var_3C          = word ptr -3Ch
.text$mn:00000880 var_38          = dword ptr -38h
.text$mn:00000880 var_34          = dword ptr -34h
.text$mn:00000880 var_30          = dword ptr -30h
.text$mn:00000880 var_2C          = dword ptr -2Ch
.text$mn:00000880 var_28          = dword ptr -28h
.text$mn:00000880 var_24          = dword ptr -24h
.text$mn:00000880 var_20          = dword ptr -20h
.text$mn:00000880 var_19          = byte ptr -19h
.text$mn:00000880 wParam          = dword ptr -18h
.text$mn:00000880 var_14          = dword ptr -14h
.text$mn:00000880 var_10          = dword ptr -10h
.text$mn:00000880 var_C           = dword ptr -0Ch
.text$mn:00000880 var_4           = dword ptr -4
.text$mn:00000880 this            = dword ptr  8
.text$mn:00000880 arg_4           = dword ptr  0Ch
.text$mn:00000880 arg_8           = dword ptr  10h
.text$mn:00000880 arg_C           = dword ptr  14h
.text$mn:00000880
.text$mn:00000880                 push    ebp
.text$mn:00000881                 mov     ebp, esp
.text$mn:00000883                 push    0FFFFFFFFh
.text$mn:00000885                 push    offset __ehhandler$?run_dlgProc@WindowsDlg@@MAGHIIJ@Z
.text$mn:0000088A                 mov     eax, large fs:0
.text$mn:00000890                 push    eax
.text$mn:00000891                 sub     esp, 10Ch
.text$mn:00000897                 push    esi
.text$mn:00000898                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000089D                 xor     eax, ebp
.text$mn:0000089F                 push    eax
.text$mn:000008A0                 lea     eax, [ebp+var_C]
.text$mn:000008A3                 mov     large fs:0, eax
.text$mn:000008A9                 mov     eax, [ebp+arg_4]
.text$mn:000008AC                 mov     [ebp+var_30], eax
.text$mn:000008AF                 cmp     [ebp+var_30], 110h
.text$mn:000008B6                 ja      short loc_8DA
.text$mn:000008B8                 cmp     [ebp+var_30], 110h
.text$mn:000008BF                 jz      short loc_8E8
.text$mn:000008C1                 cmp     [ebp+var_30], 2
.text$mn:000008C5                 jz      loc_9BF
.text$mn:000008CB                 cmp     [ebp+var_30], 4Eh ; 'N'
.text$mn:000008CF                 jz      loc_9C9
.text$mn:000008D5                 jmp     loc_FA9
.text$mn:000008DA ; ---------------------------------------------------------------------------
.text$mn:000008DA
.text$mn:000008DA loc_8DA:                                ; CODE XREF: WindowsDlg::run_dlgProc(uint,uint,long)+36j
.text$mn:000008DA                 cmp     [ebp+var_30], 111h
.text$mn:000008E1                 jz      short loc_90A
.text$mn:000008E3                 jmp     loc_FA9
.text$mn:000008E8 ; ---------------------------------------------------------------------------
.text$mn:000008E8
.text$mn:000008E8 loc_8E8:                                ; CODE XREF: WindowsDlg::run_dlgProc(uint,uint,long)+3Fj
.text$mn:000008E8                 mov     ecx, [ebp+this] ; this
.text$mn:000008EB                 call    ?changeDlgLang@WindowsDlg@@QAE_NXZ ; WindowsDlg::changeDlgLang(void)
.text$mn:000008F0                 mov     ecx, [ebp+arg_C]
.text$mn:000008F3                 push    ecx             ; __int32
.text$mn:000008F4                 mov     edx, [ebp+arg_8]
.text$mn:000008F7                 push    edx             ; unsigned int
.text$mn:000008F8                 mov     eax, [ebp+arg_4]
.text$mn:000008FB                 push    eax             ; unsigned int
.text$mn:000008FC                 mov     ecx, [ebp+this]
.text$mn:000008FF                 push    ecx             ; this
.text$mn:00000900                 call    ?run_dlgProc@SizeableDlg@@MAGHIIJ@Z ; SizeableDlg::run_dlgProc(uint,uint,long)
.text$mn:00000905                 jmp     loc_FBE
.text$mn:0000090A ; ---------------------------------------------------------------------------
.text$mn:0000090A
.text$mn:0000090A loc_90A:                                ; CODE XREF: WindowsDlg::run_dlgProc(uint,uint,long)+61j
.text$mn:0000090A                 mov     edx, [ebp+arg_8]
.text$mn:0000090D                 mov     [ebp+var_24], edx
.text$mn:00000910                 cmp     [ebp+var_24], 1B5Ah
.text$mn:00000917                 ja      short loc_933
.text$mn:00000919                 cmp     [ebp+var_24], 1B5Ah
.text$mn:00000920                 jz      short loc_984
.text$mn:00000922                 cmp     [ebp+var_24], 1
.text$mn:00000926                 jz      short loc_947
.text$mn:00000928                 cmp     [ebp+var_24], 2
.text$mn:0000092C                 jz      short loc_959
.text$mn:0000092E                 jmp     loc_9BF
.text$mn:00000933 ; ---------------------------------------------------------------------------
.text$mn:00000933
.text$mn:00000933 loc_933:                                ; CODE XREF: WindowsDlg::run_dlgProc(uint,uint,long)+97j
.text$mn:00000933                 cmp     [ebp+var_24], 1B5Bh
.text$mn:0000093A                 jz      short loc_996
.text$mn:0000093C                 cmp     [ebp+var_24], 1B5Ch
.text$mn:00000943                 jz      short loc_9A8
.text$mn:00000945                 jmp     short loc_9BF
.text$mn:00000947 ; ---------------------------------------------------------------------------
.text$mn:00000947
.text$mn:00000947 loc_947:                                ; CODE XREF: WindowsDlg::run_dlgProc(uint,uint,long)+A6j
.text$mn:00000947                 mov     ecx, [ebp+this] ; this
.text$mn:0000094A                 call    ?activateCurrent@WindowsDlg@@IAEXXZ ; WindowsDlg::activateCurrent(void)
.text$mn:0000094F                 mov     eax, 1
.text$mn:00000954                 jmp     loc_FBE
.text$mn:00000959 ; ---------------------------------------------------------------------------
.text$mn:00000959
.text$mn:00000959 loc_959:                                ; CODE XREF: WindowsDlg::run_dlgProc(uint,uint,long)+ACj
.text$mn:00000959                 push    offset ?_lastKnownLocation@WindowsDlg@@1UtagRECT@@A ; lpRect
.text$mn:0000095E                 mov     eax, [ebp+this]
.text$mn:00000961                 mov     ecx, [eax+0Ch]
.text$mn:00000964                 push    ecx             ; hWnd
.text$mn:00000965                 call    dword ptr ds:__imp__GetWindowRect@8 ; GetWindowRect(x,x)
.text$mn:0000096B                 push    2               ; nResult
.text$mn:0000096D                 mov     edx, [ebp+this]
.text$mn:00000970                 mov     eax, [edx+0Ch]
.text$mn:00000973                 push    eax             ; hDlg
.text$mn:00000974                 call    dword ptr ds:__imp__EndDialog@8 ; EndDialog(x,x)
.text$mn:0000097A                 mov     eax, 1
.text$mn:0000097F                 jmp     loc_FBE
.text$mn:00000984 ; ---------------------------------------------------------------------------
.text$mn:00000984
.text$mn:00000984 loc_984:                                ; CODE XREF: WindowsDlg::run_dlgProc(uint,uint,long)+A0j
.text$mn:00000984                 mov     ecx, [ebp+this] ; this
.text$mn:00000987                 call    ?doSave@WindowsDlg@@IAEXXZ ; WindowsDlg::doSave(void)
.text$mn:0000098C                 mov     eax, 1
.text$mn:00000991                 jmp     loc_FBE
.text$mn:00000996 ; ---------------------------------------------------------------------------
.text$mn:00000996
.text$mn:00000996 loc_996:                                ; CODE XREF: WindowsDlg::run_dlgProc(uint,uint,long)+BAj
.text$mn:00000996                 mov     ecx, [ebp+this] ; this
.text$mn:00000999                 call    ?doClose@WindowsDlg@@IAEXXZ ; WindowsDlg::doClose(void)
.text$mn:0000099E                 mov     eax, 1
.text$mn:000009A3                 jmp     loc_FBE
.text$mn:000009A8 ; ---------------------------------------------------------------------------
.text$mn:000009A8
.text$mn:000009A8 loc_9A8:                                ; CODE XREF: WindowsDlg::run_dlgProc(uint,uint,long)+C3j
.text$mn:000009A8                 mov     ecx, [ebp+this] ; this
.text$mn:000009AB                 call    ?doSortToTabs@WindowsDlg@@IAEXXZ ; WindowsDlg::doSortToTabs(void)
.text$mn:000009B0                 mov     ecx, [ebp+this]
.text$mn:000009B3                 mov     byte ptr [ecx+54h], 0
.text$mn:000009B7                 mov     ecx, [ebp+this] ; this
.text$mn:000009BA                 call    ?updateButtonState@WindowsDlg@@IAEXXZ ; WindowsDlg::updateButtonState(void)
.text$mn:000009BF
.text$mn:000009BF loc_9BF:                                ; CODE XREF: WindowsDlg::run_dlgProc(uint,uint,long)+45j
.text$mn:000009BF                                         ; WindowsDlg::run_dlgProc(uint,uint,long)+AEj ...
.text$mn:000009BF                 mov     eax, 1
.text$mn:000009C4                 jmp     loc_FBE
.text$mn:000009C9 ; ---------------------------------------------------------------------------
.text$mn:000009C9
.text$mn:000009C9 loc_9C9:                                ; CODE XREF: WindowsDlg::run_dlgProc(uint,uint,long)+4Fj
.text$mn:000009C9                 cmp     [ebp+arg_8], 1B59h
.text$mn:000009D0                 jnz     loc_FA9
.text$mn:000009D6                 mov     edx, [ebp+arg_C]
.text$mn:000009D9                 mov     [ebp+var_20], edx
.text$mn:000009DC                 mov     eax, [ebp+var_20]
.text$mn:000009DF                 cmp     dword ptr [eax+8], 0FFFFFF4Fh
.text$mn:000009E6                 jnz     loc_C55
.text$mn:000009EC                 mov     ecx, [ebp+var_20]
.text$mn:000009EF                 mov     [ebp+var_10], ecx
.text$mn:000009F2                 mov     edx, [ebp+var_10]
.text$mn:000009F5                 mov     eax, [edx+0Ch]
.text$mn:000009F8                 and     eax, 1
.text$mn:000009FB                 jz      loc_C46
.text$mn:00000A01                 mov     ecx, 2
.text$mn:00000A06                 imul    edx, ecx, 0
.text$mn:00000A09                 mov     eax, [ebp+var_10]
.text$mn:00000A0C                 mov     ecx, [eax+20h]
.text$mn:00000A0F                 xor     eax, eax
.text$mn:00000A11                 mov     [edx+ecx], ax
.text$mn:00000A15                 mov     ecx, [ebp+var_10]
.text$mn:00000A18                 mov     edx, [ecx+10h]
.text$mn:00000A1B                 mov     [ebp+var_34], edx
.text$mn:00000A1E                 mov     eax, [ebp+this]
.text$mn:00000A21                 mov     ecx, [eax+3Ch]  ; this
.text$mn:00000A24                 call    ?nbItem@TabBar@@QBEHXZ ; TabBar::nbItem(void)
.text$mn:00000A29                 cmp     [ebp+var_34], eax
.text$mn:00000A2C                 jge     short loc_A3E
.text$mn:00000A2E                 mov     ecx, [ebp+this]
.text$mn:00000A31                 add     ecx, 40h ; '@'
.text$mn:00000A34                 call    ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int>>::size(void)
.text$mn:00000A39                 cmp     [ebp+var_34], eax
.text$mn:00000A3C                 jl      short loc_A45
.text$mn:00000A3E
.text$mn:00000A3E loc_A3E:                                ; CODE XREF: WindowsDlg::run_dlgProc(uint,uint,long)+1ACj
.text$mn:00000A3E                 xor     eax, eax
.text$mn:00000A40                 jmp     loc_FBE
.text$mn:00000A45 ; ---------------------------------------------------------------------------
.text$mn:00000A45
.text$mn:00000A45 loc_A45:                                ; CODE XREF: WindowsDlg::run_dlgProc(uint,uint,long)+1BCj
.text$mn:00000A45                 mov     ecx, [ebp+var_34]
.text$mn:00000A48                 push    ecx
.text$mn:00000A49                 mov     ecx, [ebp+this]
.text$mn:00000A4C                 add     ecx, 40h ; '@'
.text$mn:00000A4F                 call    ??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z ; std::vector<int,std::allocator<int>>::operator[](uint)
.text$mn:00000A54                 mov     edx, [eax]
.text$mn:00000A56                 mov     [ebp+var_34], edx
.text$mn:00000A59                 mov     eax, [ebp+var_34]
.text$mn:00000A5C                 push    eax             ; int
.text$mn:00000A5D                 mov     ecx, [ebp+this]
.text$mn:00000A60                 mov     ecx, [ecx+3Ch]  ; this
.text$mn:00000A63                 call    ?getBufferByIndex@DocTabView@@QAEPAVBuffer@@H@Z ; DocTabView::getBufferByIndex(int)
.text$mn:00000A68                 mov     [ebp+var_74], eax
.text$mn:00000A6B                 mov     edx, [ebp+var_74]
.text$mn:00000A6E                 push    edx             ; struct Buffer *
.text$mn:00000A6F                 call    ?getInstance@FileManager@@SAPAV1@XZ ; FileManager::getInstance(void)
.text$mn:00000A74                 mov     ecx, eax        ; this
.text$mn:00000A76                 call    ?getBufferByID@FileManager@@QAEPAVBuffer@@PAV2@@Z ; FileManager::getBufferByID(Buffer *)
.text$mn:00000A7B                 mov     [ebp+var_28], eax
.text$mn:00000A7E                 mov     eax, [ebp+var_10]
.text$mn:00000A81                 cmp     dword ptr [eax+14h], 0
.text$mn:00000A85                 jnz     loc_B65
.text$mn:00000A8B                 mov     ecx, [ebp+var_10]
.text$mn:00000A8E                 mov     edx, [ecx+24h]
.text$mn:00000A91                 mov     [ebp+var_14], edx
.text$mn:00000A94                 mov     ecx, [ebp+var_28] ; this
.text$mn:00000A97                 call    ?getFileName@Buffer@@QBEPB_WXZ ; Buffer::getFileName(void)
.text$mn:00000A9C                 mov     [ebp+Source], eax
.text$mn:00000A9F                 mov     eax, [ebp+var_14]
.text$mn:00000AA2                 sub     eax, 1
.text$mn:00000AA5                 push    eax             ; Count
.text$mn:00000AA6                 mov     ecx, [ebp+Source]
.text$mn:00000AA9                 push    ecx             ; Source
.text$mn:00000AAA                 mov     edx, [ebp+var_10]
.text$mn:00000AAD                 mov     eax, [edx+20h]
.text$mn:00000AB0                 push    eax             ; Dest
.text$mn:00000AB1                 call    _wcsncpy
.text$mn:00000AB6                 add     esp, 0Ch
.text$mn:00000AB9                 mov     ecx, [ebp+var_10]
.text$mn:00000ABC                 mov     edx, [ecx+20h]
.text$mn:00000ABF                 xor     eax, eax
.text$mn:00000AC1                 mov     ecx, [ebp+var_14]
.text$mn:00000AC4                 mov     [edx+ecx*2-2], ax
.text$mn:00000AC9                 mov     edx, [ebp+var_10]
.text$mn:00000ACC                 mov     eax, [edx+20h]
.text$mn:00000ACF                 push    eax             ; lpString
.text$mn:00000AD0                 call    dword ptr ds:__imp__lstrlenW@4 ; lstrlenW(x)
.text$mn:00000AD6                 mov     [ebp+var_14], eax
.text$mn:00000AD9                 mov     ecx, [ebp+var_28] ; this
.text$mn:00000ADC                 call    ?isDirty@Buffer@@QBE_NXZ ; Buffer::isDirty(void)
.text$mn:00000AE1                 movzx   ecx, al
.text$mn:00000AE4                 test    ecx, ecx
.text$mn:00000AE6                 jz      short loc_B1F
.text$mn:00000AE8                 mov     edx, [ebp+var_10]
.text$mn:00000AEB                 mov     eax, [ebp+var_14]
.text$mn:00000AEE                 cmp     eax, [edx+24h]
.text$mn:00000AF1                 jge     short loc_B1D
.text$mn:00000AF3                 mov     ecx, [ebp+var_10]
.text$mn:00000AF6                 mov     edx, [ecx+20h]
.text$mn:00000AF9                 mov     eax, 2Ah ; '*'
.text$mn:00000AFE                 mov     ecx, [ebp+var_14]
.text$mn:00000B01                 mov     [edx+ecx*2], ax
.text$mn:00000B05                 mov     edx, [ebp+var_14]
.text$mn:00000B08                 add     edx, 1
.text$mn:00000B0B                 mov     [ebp+var_14], edx
.text$mn:00000B0E                 mov     eax, [ebp+var_10]
.text$mn:00000B11                 mov     ecx, [eax+20h]
.text$mn:00000B14                 xor     edx, edx
.text$mn:00000B16                 mov     eax, [ebp+var_14]
.text$mn:00000B19                 mov     [ecx+eax*2], dx
.text$mn:00000B1D
.text$mn:00000B1D loc_B1D:                                ; CODE XREF: WindowsDlg::run_dlgProc(uint,uint,long)+271j
.text$mn:00000B1D                 jmp     short loc_B60
.text$mn:00000B1F ; ---------------------------------------------------------------------------
.text$mn:00000B1F
.text$mn:00000B1F loc_B1F:                                ; CODE XREF: WindowsDlg::run_dlgProc(uint,uint,long)+266j
.text$mn:00000B1F                 mov     ecx, [ebp+var_28] ; this
.text$mn:00000B22                 call    ?isReadOnly@Buffer@@QBE_NXZ ; Buffer::isReadOnly(void)
.text$mn:00000B27                 movzx   ecx, al
.text$mn:00000B2A                 test    ecx, ecx
.text$mn:00000B2C                 jz      short loc_B60
.text$mn:00000B2E                 mov     edx, _readonlyString
.text$mn:00000B34                 push    edx             ; lpString
.text$mn:00000B35                 call    dword ptr ds:__imp__lstrlenW@4 ; lstrlenW(x)
.text$mn:00000B3B                 add     eax, [ebp+var_14]
.text$mn:00000B3E                 mov     [ebp+var_14], eax
.text$mn:00000B41                 mov     eax, [ebp+var_10]
.text$mn:00000B44                 mov     ecx, [ebp+var_14]
.text$mn:00000B47                 cmp     ecx, [eax+24h]
.text$mn:00000B4A                 jg      short loc_B60
.text$mn:00000B4C                 mov     edx, _readonlyString
.text$mn:00000B52                 push    edx             ; lpString2
.text$mn:00000B53                 mov     eax, [ebp+var_10]
.text$mn:00000B56                 mov     ecx, [eax+20h]
.text$mn:00000B59                 push    ecx             ; lpString1
.text$mn:00000B5A                 call    dword ptr ds:__imp__lstrcatW@8 ; lstrcatW(x,x)
.text$mn:00000B60
.text$mn:00000B60 loc_B60:                                ; CODE XREF: WindowsDlg::run_dlgProc(uint,uint,long):loc_B1Dj
.text$mn:00000B60                                         ; WindowsDlg::run_dlgProc(uint,uint,long)+2ACj ...
.text$mn:00000B60                 jmp     loc_C46
.text$mn:00000B65 ; ---------------------------------------------------------------------------
.text$mn:00000B65
.text$mn:00000B65 loc_B65:                                ; CODE XREF: WindowsDlg::run_dlgProc(uint,uint,long)+205j
.text$mn:00000B65                 mov     edx, [ebp+var_10]
.text$mn:00000B68                 cmp     dword ptr [edx+14h], 1
.text$mn:00000B6C                 jnz     loc_BF3
.text$mn:00000B72                 mov     ecx, [ebp+var_28] ; this
.text$mn:00000B75                 call    ?getFullPathName@Buffer@@QBEPB_WXZ ; Buffer::getFullPathName(void)
.text$mn:00000B7A                 mov     [ebp+lpString], eax
.text$mn:00000B7D                 mov     ecx, [ebp+var_28] ; this
.text$mn:00000B80                 call    ?getFileName@Buffer@@QBEPB_WXZ ; Buffer::getFileName(void)
.text$mn:00000B85                 mov     [ebp+var_7C], eax
.text$mn:00000B88                 mov     eax, [ebp+lpString]
.text$mn:00000B8B                 push    eax             ; lpString
.text$mn:00000B8C                 call    dword ptr ds:__imp__lstrlenW@4 ; lstrlenW(x)
.text$mn:00000B92                 mov     esi, eax
.text$mn:00000B94                 mov     ecx, [ebp+var_7C]
.text$mn:00000B97                 push    ecx             ; lpString
.text$mn:00000B98                 call    dword ptr ds:__imp__lstrlenW@4 ; lstrlenW(x)
.text$mn:00000B9E                 sub     esi, eax
.text$mn:00000BA0                 mov     [ebp+var_2C], esi
.text$mn:00000BA3                 jnz     short loc_BB3
.text$mn:00000BA5                 mov     [ebp+var_2C], 1
.text$mn:00000BAC                 mov     [ebp+lpString], offset $SG132341
.text$mn:00000BB3
.text$mn:00000BB3 loc_BB3:                                ; CODE XREF: WindowsDlg::run_dlgProc(uint,uint,long)+323j
.text$mn:00000BB3                 mov     edx, [ebp+var_10]
.text$mn:00000BB6                 mov     eax, [edx+24h]
.text$mn:00000BB9                 cmp     eax, [ebp+var_2C]
.text$mn:00000BBC                 jge     short loc_BC7
.text$mn:00000BBE                 mov     ecx, [ebp+var_10]
.text$mn:00000BC1                 mov     edx, [ecx+24h]
.text$mn:00000BC4                 mov     [ebp+var_2C], edx
.text$mn:00000BC7
.text$mn:00000BC7 loc_BC7:                                ; CODE XREF: WindowsDlg::run_dlgProc(uint,uint,long)+33Cj
.text$mn:00000BC7                 mov     eax, [ebp+var_2C]
.text$mn:00000BCA                 sub     eax, 1
.text$mn:00000BCD                 push    eax             ; Count
.text$mn:00000BCE                 mov     ecx, [ebp+lpString]
.text$mn:00000BD1                 push    ecx             ; Source
.text$mn:00000BD2                 mov     edx, [ebp+var_10]
.text$mn:00000BD5                 mov     eax, [edx+20h]
.text$mn:00000BD8                 push    eax             ; Dest
.text$mn:00000BD9                 call    _wcsncpy
.text$mn:00000BDE                 add     esp, 0Ch
.text$mn:00000BE1                 mov     ecx, [ebp+var_10]
.text$mn:00000BE4                 mov     edx, [ecx+20h]
.text$mn:00000BE7                 xor     eax, eax
.text$mn:00000BE9                 mov     ecx, [ebp+var_2C]
.text$mn:00000BEC                 mov     [edx+ecx*2-2], ax
.text$mn:00000BF1                 jmp     short loc_C46
.text$mn:00000BF3 ; ---------------------------------------------------------------------------
.text$mn:00000BF3
.text$mn:00000BF3 loc_BF3:                                ; CODE XREF: WindowsDlg::run_dlgProc(uint,uint,long)+2ECj
.text$mn:00000BF3                 mov     edx, [ebp+var_10]
.text$mn:00000BF6                 cmp     dword ptr [edx+14h], 2
.text$mn:00000BFA                 jnz     short loc_C46
.text$mn:00000BFC                 mov     eax, [ebp+var_10]
.text$mn:00000BFF                 mov     ecx, [eax+24h]
.text$mn:00000C02                 mov     [ebp+var_78], ecx
.text$mn:00000C05                 call    ?getInstance@NppParameters@@SAPAV1@XZ ; NppParameters::getInstance(void)
.text$mn:00000C0A                 mov     [ebp+var_70], eax
.text$mn:00000C0D                 mov     ecx, [ebp+var_28]
.text$mn:00000C10                 call    ?getLangType@Buffer@@QBE?AW4LangType@@XZ ; Buffer::getLangType(void)
.text$mn:00000C15                 push    eax
.text$mn:00000C16                 mov     ecx, [ebp+var_70]
.text$mn:00000C19                 call    ?getLangFromID@NppParameters@@QBEPAULang@@W4LangType@@@Z ; NppParameters::getLangFromID(LangType)
.text$mn:00000C1E                 mov     [ebp+var_58], eax
.text$mn:00000C21                 cmp     [ebp+var_58], 0
.text$mn:00000C25                 jz      short loc_C46
.text$mn:00000C27                 mov     edx, [ebp+var_78]
.text$mn:00000C2A                 sub     edx, 1
.text$mn:00000C2D                 push    edx             ; Count
.text$mn:00000C2E                 mov     ecx, [ebp+var_58] ; this
.text$mn:00000C31                 call    ?getLangName@Lang@@QBEPB_WXZ ; Lang::getLangName(void)
.text$mn:00000C36                 push    eax             ; Source
.text$mn:00000C37                 mov     eax, [ebp+var_10]
.text$mn:00000C3A                 mov     ecx, [eax+20h]
.text$mn:00000C3D                 push    ecx             ; Dest
.text$mn:00000C3E                 call    _wcsncpy
.text$mn:00000C43                 add     esp, 0Ch
.text$mn:00000C46
.text$mn:00000C46 loc_C46:                                ; CODE XREF: WindowsDlg::run_dlgProc(uint,uint,long)+17Bj
.text$mn:00000C46                                         ; WindowsDlg::run_dlgProc(uint,uint,long):loc_B60j ...
.text$mn:00000C46                 mov     eax, 1
.text$mn:00000C4B                 jmp     loc_FBE
.text$mn:00000C50 ; ---------------------------------------------------------------------------
.text$mn:00000C50                 jmp     loc_FA9
.text$mn:00000C55 ; ---------------------------------------------------------------------------
.text$mn:00000C55
.text$mn:00000C55 loc_C55:                                ; CODE XREF: WindowsDlg::run_dlgProc(uint,uint,long)+166j
.text$mn:00000C55                 mov     edx, [ebp+var_20]
.text$mn:00000C58                 cmp     dword ptr [edx+8], 0FFFFFF94h
.text$mn:00000C5C                 jnz     loc_E7E
.text$mn:00000C62                 mov     eax, [ebp+var_20]
.text$mn:00000C65                 mov     [ebp+var_54], eax
.text$mn:00000C68                 mov     ecx, [ebp+var_54]
.text$mn:00000C6B                 cmp     dword ptr [ecx+0Ch], 0FFFFFFFFh
.text$mn:00000C6F                 jnz     loc_E6F
.text$mn:00000C75                 mov     [ebp+var_19], 0
.text$mn:00000C79                 mov     edx, [ebp+var_54]
.text$mn:00000C7C                 mov     eax, [edx+10h]
.text$mn:00000C7F                 mov     [ebp+var_48], eax
.text$mn:00000C82                 mov     ecx, [ebp+this]
.text$mn:00000C85                 mov     edx, [ecx+50h]
.text$mn:00000C88                 cmp     edx, [ebp+var_48]
.text$mn:00000C8B                 jnz     short loc_C9D
.text$mn:00000C8D                 mov     [ebp+var_19], 1
.text$mn:00000C91                 mov     eax, [ebp+this]
.text$mn:00000C94                 mov     dword ptr [eax+50h], 0FFFFFFFFh
.text$mn:00000C9B                 jmp     short loc_CA6
.text$mn:00000C9D ; ---------------------------------------------------------------------------
.text$mn:00000C9D
.text$mn:00000C9D loc_C9D:                                ; CODE XREF: WindowsDlg::run_dlgProc(uint,uint,long)+40Bj
.text$mn:00000C9D                 mov     ecx, [ebp+this]
.text$mn:00000CA0                 mov     edx, [ebp+var_48]
.text$mn:00000CA3                 mov     [ecx+50h], edx
.text$mn:00000CA6
.text$mn:00000CA6 loc_CA6:                                ; CODE XREF: WindowsDlg::run_dlgProc(uint,uint,long)+41Bj
.text$mn:00000CA6                 mov     ecx, [ebp+this]
.text$mn:00000CA9                 add     ecx, 40h ; '@'
.text$mn:00000CAC                 call    ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int>>::size(void)
.text$mn:00000CB1                 mov     [ebp+var_50], eax
.text$mn:00000CB4                 lea     ecx, [ebp+var_90]
.text$mn:00000CBA                 call    ??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int>>::vector<int,std::allocator<int>>(void)
.text$mn:00000CBF                 mov     [ebp+var_4], 0
.text$mn:00000CC6                 mov     eax, [ebp+var_50]
.text$mn:00000CC9                 push    eax
.text$mn:00000CCA                 lea     ecx, [ebp+var_90]
.text$mn:00000CD0                 call    ?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z ; std::vector<int,std::allocator<int>>::resize(uint)
.text$mn:00000CD5                 mov     [ebp+wParam], 0
.text$mn:00000CDC                 jmp     short loc_CE7
.text$mn:00000CDE ; ---------------------------------------------------------------------------
.text$mn:00000CDE
.text$mn:00000CDE loc_CDE:                                ; CODE XREF: WindowsDlg::run_dlgProc(uint,uint,long)+4A8j
.text$mn:00000CDE                 mov     ecx, [ebp+wParam]
.text$mn:00000CE1                 add     ecx, 1
.text$mn:00000CE4                 mov     [ebp+wParam], ecx
.text$mn:00000CE7
.text$mn:00000CE7 loc_CE7:                                ; CODE XREF: WindowsDlg::run_dlgProc(uint,uint,long)+45Cj
.text$mn:00000CE7                 mov     edx, [ebp+wParam]
.text$mn:00000CEA                 cmp     edx, [ebp+var_50]
.text$mn:00000CED                 jge     short loc_D2A
.text$mn:00000CEF                 push    2               ; lParam
.text$mn:00000CF1                 mov     eax, [ebp+wParam]
.text$mn:00000CF4                 push    eax             ; wParam
.text$mn:00000CF5                 push    102Ch           ; Msg
.text$mn:00000CFA                 mov     ecx, [ebp+this]
.text$mn:00000CFD                 mov     edx, [ecx+28h]
.text$mn:00000D00                 push    edx             ; hWnd
.text$mn:00000D01                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000D07                 mov     esi, eax
.text$mn:00000D09                 mov     eax, [ebp+wParam]
.text$mn:00000D0C                 push    eax
.text$mn:00000D0D                 mov     ecx, [ebp+this]
.text$mn:00000D10                 add     ecx, 40h ; '@'
.text$mn:00000D13                 call    ??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z ; std::vector<int,std::allocator<int>>::operator[](uint)
.text$mn:00000D18                 mov     ecx, [eax]
.text$mn:00000D1A                 push    ecx
.text$mn:00000D1B                 lea     ecx, [ebp+var_90]
.text$mn:00000D21                 call    ??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z ; std::vector<int,std::allocator<int>>::operator[](uint)
.text$mn:00000D26                 mov     [eax], esi
.text$mn:00000D28                 jmp     short loc_CDE
.text$mn:00000D2A ; ---------------------------------------------------------------------------
.text$mn:00000D2A
.text$mn:00000D2A loc_D2A:                                ; CODE XREF: WindowsDlg::run_dlgProc(uint,uint,long)+46Dj
.text$mn:00000D2A                 movzx   edx, [ebp+var_19]
.text$mn:00000D2E                 push    edx             ; bool
.text$mn:00000D2F                 mov     eax, [ebp+var_48]
.text$mn:00000D32                 push    eax             ; int
.text$mn:00000D33                 mov     ecx, [ebp+this]
.text$mn:00000D36                 mov     edx, [ecx+3Ch]
.text$mn:00000D39                 push    edx             ; struct DocTabView *
.text$mn:00000D3A                 lea     ecx, [ebp+var_B0] ; this
.text$mn:00000D40                 call    ??0BufferEquivalent@@QAE@PAVDocTabView@@H_N@Z ; BufferEquivalent::BufferEquivalent(DocTabView *,int,bool)
.text$mn:00000D45                 sub     esp, 10h
.text$mn:00000D48                 mov     ecx, esp
.text$mn:00000D4A                 mov     edx, [eax]
.text$mn:00000D4C                 mov     [ecx], edx
.text$mn:00000D4E                 mov     edx, [eax+4]
.text$mn:00000D51                 mov     [ecx+4], edx
.text$mn:00000D54                 mov     edx, [eax+8]
.text$mn:00000D57                 mov     [ecx+8], edx
.text$mn:00000D5A                 mov     eax, [eax+0Ch]
.text$mn:00000D5D                 mov     [ecx+0Ch], eax
.text$mn:00000D60                 sub     esp, 0Ch
.text$mn:00000D63                 mov     ecx, esp
.text$mn:00000D65                 mov     [ebp+var_94], esp
.text$mn:00000D6B                 push    ecx
.text$mn:00000D6C                 mov     ecx, [ebp+this]
.text$mn:00000D6F                 add     ecx, 40h ; '@'
.text$mn:00000D72                 call    ?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ ; std::vector<int,std::allocator<int>>::end(void)
.text$mn:00000D77                 mov     [ebp+var_68], eax
.text$mn:00000D7A                 mov     edx, [ebp+var_68]
.text$mn:00000D7D                 mov     [ebp+var_98], edx
.text$mn:00000D83                 mov     byte ptr [ebp+var_4], 1
.text$mn:00000D87                 sub     esp, 0Ch
.text$mn:00000D8A                 mov     eax, esp
.text$mn:00000D8C                 mov     [ebp+var_A0], esp
.text$mn:00000D92                 push    eax
.text$mn:00000D93                 mov     ecx, [ebp+this]
.text$mn:00000D96                 add     ecx, 40h ; '@'
.text$mn:00000D99                 call    ?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ ; std::vector<int,std::allocator<int>>::begin(void)
.text$mn:00000D9E                 mov     [ebp+var_6C], eax
.text$mn:00000DA1                 mov     ecx, [ebp+var_6C]
.text$mn:00000DA4                 mov     [ebp+var_9C], ecx
.text$mn:00000DAA                 mov     byte ptr [ebp+var_4], 2
.text$mn:00000DAE                 mov     byte ptr [ebp+var_4], 0
.text$mn:00000DB2                 call    ??$stable_sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@UBufferEquivalent@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0UBufferEquivalent@@@Z ; std::stable_sort<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,BufferEquivalent>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,BufferEquivalent)
.text$mn:00000DB7                 add     esp, 28h
.text$mn:00000DBA                 mov     [ebp+wParam], 0
.text$mn:00000DC1                 jmp     short loc_DCC
.text$mn:00000DC3 ; ---------------------------------------------------------------------------
.text$mn:00000DC3
.text$mn:00000DC3 loc_DC3:                                ; CODE XREF: WindowsDlg::run_dlgProc(uint,uint,long)+5B6j
.text$mn:00000DC3                 mov     edx, [ebp+wParam]
.text$mn:00000DC6                 add     edx, 1
.text$mn:00000DC9                 mov     [ebp+wParam], edx
.text$mn:00000DCC
.text$mn:00000DCC loc_DCC:                                ; CODE XREF: WindowsDlg::run_dlgProc(uint,uint,long)+541j
.text$mn:00000DCC                 mov     eax, [ebp+wParam]
.text$mn:00000DCF                 cmp     eax, [ebp+var_50]
.text$mn:00000DD2                 jge     short loc_E38
.text$mn:00000DD4                 mov     [ebp+var_D4], 2
.text$mn:00000DDE                 mov     ecx, [ebp+wParam]
.text$mn:00000DE1                 push    ecx
.text$mn:00000DE2                 mov     ecx, [ebp+this]
.text$mn:00000DE5                 add     ecx, 40h ; '@'
.text$mn:00000DE8                 call    ??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z ; std::vector<int,std::allocator<int>>::operator[](uint)
.text$mn:00000DED                 mov     edx, [eax]
.text$mn:00000DEF                 push    edx
.text$mn:00000DF0                 lea     ecx, [ebp+var_90]
.text$mn:00000DF6                 call    ??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z ; std::vector<int,std::allocator<int>>::operator[](uint)
.text$mn:00000DFB                 cmp     dword ptr [eax], 0
.text$mn:00000DFE                 jz      short loc_E09
.text$mn:00000E00                 mov     [ebp+var_5C], 2
.text$mn:00000E07                 jmp     short loc_E10
.text$mn:00000E09 ; ---------------------------------------------------------------------------
.text$mn:00000E09
.text$mn:00000E09 loc_E09:                                ; CODE XREF: WindowsDlg::run_dlgProc(uint,uint,long)+57Ej
.text$mn:00000E09                 mov     [ebp+var_5C], 0
.text$mn:00000E10
.text$mn:00000E10 loc_E10:                                ; CODE XREF: WindowsDlg::run_dlgProc(uint,uint,long)+587j
.text$mn:00000E10                 mov     eax, [ebp+var_5C]
.text$mn:00000E13                 mov     [ebp+var_D8], eax
.text$mn:00000E19                 lea     ecx, [ebp+lParam]
.text$mn:00000E1F                 push    ecx             ; lParam
.text$mn:00000E20                 mov     edx, [ebp+wParam]
.text$mn:00000E23                 push    edx             ; wParam
.text$mn:00000E24                 push    102Bh           ; Msg
.text$mn:00000E29                 mov     eax, [ebp+this]
.text$mn:00000E2C                 mov     ecx, [eax+28h]
.text$mn:00000E2F                 push    ecx             ; hWnd
.text$mn:00000E30                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000E36                 jmp     short loc_DC3
.text$mn:00000E38 ; ---------------------------------------------------------------------------
.text$mn:00000E38
.text$mn:00000E38 loc_E38:                                ; CODE XREF: WindowsDlg::run_dlgProc(uint,uint,long)+552j
.text$mn:00000E38                 push    0               ; bErase
.text$mn:00000E3A                 mov     edx, [ebp+this]
.text$mn:00000E3D                 add     edx, 10h
.text$mn:00000E40                 push    edx             ; lpRect
.text$mn:00000E41                 mov     eax, [ebp+this]
.text$mn:00000E44                 mov     ecx, [eax+28h]
.text$mn:00000E47                 push    ecx             ; hWnd
.text$mn:00000E48                 call    dword ptr ds:__imp__InvalidateRect@12 ; InvalidateRect(x,x,x)
.text$mn:00000E4E                 mov     edx, [ebp+this]
.text$mn:00000E51                 mov     byte ptr [edx+54h], 1
.text$mn:00000E55                 mov     ecx, [ebp+this] ; this
.text$mn:00000E58                 call    ?updateButtonState@WindowsDlg@@IAEXXZ ; WindowsDlg::updateButtonState(void)
.text$mn:00000E5D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000E64                 lea     ecx, [ebp+var_90]
.text$mn:00000E6A                 call    ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int>>::~vector<int,std::allocator<int>>(void)
.text$mn:00000E6F
.text$mn:00000E6F loc_E6F:                                ; CODE XREF: WindowsDlg::run_dlgProc(uint,uint,long)+3EFj
.text$mn:00000E6F                 mov     eax, 1
.text$mn:00000E74                 jmp     loc_FBE
.text$mn:00000E79 ; ---------------------------------------------------------------------------
.text$mn:00000E79                 jmp     loc_FA9
.text$mn:00000E7E ; ---------------------------------------------------------------------------
.text$mn:00000E7E
.text$mn:00000E7E loc_E7E:                                ; CODE XREF: WindowsDlg::run_dlgProc(uint,uint,long)+3DCj
.text$mn:00000E7E                 mov     eax, [ebp+var_20]
.text$mn:00000E81                 cmp     dword ptr [eax+8], 0FFFFFF8Eh
.text$mn:00000E85                 jz      short loc_E99
.text$mn:00000E87                 mov     ecx, [ebp+var_20]
.text$mn:00000E8A                 cmp     dword ptr [ecx+8], 0FFFFFF9Bh
.text$mn:00000E8E                 jz      short loc_E99
.text$mn:00000E90                 mov     edx, [ebp+var_20]
.text$mn:00000E93                 cmp     dword ptr [edx+8], 0FFFFFF8Dh
.text$mn:00000E97                 jnz     short loc_EB0
.text$mn:00000E99
.text$mn:00000E99 loc_E99:                                ; CODE XREF: WindowsDlg::run_dlgProc(uint,uint,long)+605j
.text$mn:00000E99                                         ; WindowsDlg::run_dlgProc(uint,uint,long)+60Ej
.text$mn:00000E99                 mov     ecx, [ebp+this] ; this
.text$mn:00000E9C                 call    ?updateButtonState@WindowsDlg@@IAEXXZ ; WindowsDlg::updateButtonState(void)
.text$mn:00000EA1                 mov     eax, 1
.text$mn:00000EA6                 jmp     loc_FBE
.text$mn:00000EAB ; ---------------------------------------------------------------------------
.text$mn:00000EAB                 jmp     loc_FA9
.text$mn:00000EB0 ; ---------------------------------------------------------------------------
.text$mn:00000EB0
.text$mn:00000EB0 loc_EB0:                                ; CODE XREF: WindowsDlg::run_dlgProc(uint,uint,long)+617j
.text$mn:00000EB0                 mov     eax, [ebp+var_20]
.text$mn:00000EB3                 cmp     dword ptr [eax+8], 0FFFFFFFDh
.text$mn:00000EB7                 jnz     short loc_EDE
.text$mn:00000EB9                 push    0               ; lParam
.text$mn:00000EBB                 push    1               ; wParam
.text$mn:00000EBD                 push    111h            ; Msg
.text$mn:00000EC2                 mov     ecx, [ebp+this]
.text$mn:00000EC5                 mov     edx, [ecx+0Ch]
.text$mn:00000EC8                 push    edx             ; hWnd
.text$mn:00000EC9                 call    dword ptr ds:__imp__PostMessageW@16 ; PostMessageW(x,x,x,x)
.text$mn:00000ECF                 mov     eax, 1
.text$mn:00000ED4                 jmp     loc_FBE
.text$mn:00000ED9 ; ---------------------------------------------------------------------------
.text$mn:00000ED9                 jmp     loc_FA9
.text$mn:00000EDE ; ---------------------------------------------------------------------------
.text$mn:00000EDE
.text$mn:00000EDE loc_EDE:                                ; CODE XREF: WindowsDlg::run_dlgProc(uint,uint,long)+637j
.text$mn:00000EDE                 mov     eax, [ebp+var_20]
.text$mn:00000EE1                 cmp     dword ptr [eax+8], 0FFFFFF65h
.text$mn:00000EE8                 jnz     loc_FA9
.text$mn:00000EEE                 mov     ecx, [ebp+var_20]
.text$mn:00000EF1                 mov     [ebp+var_60], ecx
.text$mn:00000EF4                 push    11h             ; nVirtKey
.text$mn:00000EF6                 call    dword ptr ds:__imp__GetKeyState@4 ; GetKeyState(x)
.text$mn:00000EFC                 mov     [ebp+var_44], ax
.text$mn:00000F00                 push    12h             ; nVirtKey
.text$mn:00000F02                 call    dword ptr ds:__imp__GetKeyState@4 ; GetKeyState(x)
.text$mn:00000F08                 mov     [ebp+var_3C], ax
.text$mn:00000F0C                 push    10h             ; nVirtKey
.text$mn:00000F0E                 call    dword ptr ds:__imp__GetKeyState@4 ; GetKeyState(x)
.text$mn:00000F14                 mov     [ebp+var_4C], ax
.text$mn:00000F18                 mov     edx, [ebp+var_60]
.text$mn:00000F1B                 movzx   eax, word ptr [edx+0Ch]
.text$mn:00000F1F                 cmp     eax, 41h ; 'A'
.text$mn:00000F22                 jnz     short loc_FA2
.text$mn:00000F24                 movsx   ecx, [ebp+var_44]
.text$mn:00000F28                 test    ecx, ecx
.text$mn:00000F2A                 jge     short loc_FA2
.text$mn:00000F2C                 movsx   edx, [ebp+var_3C]
.text$mn:00000F30                 test    edx, edx
.text$mn:00000F32                 jl      short loc_FA2
.text$mn:00000F34                 movsx   eax, [ebp+var_4C]
.text$mn:00000F38                 test    eax, eax
.text$mn:00000F3A                 jl      short loc_FA2
.text$mn:00000F3C                 mov     [ebp+var_38], 0
.text$mn:00000F43                 push    0               ; lParam
.text$mn:00000F45                 push    0               ; wParam
.text$mn:00000F47                 push    1004h           ; Msg
.text$mn:00000F4C                 mov     ecx, [ebp+this]
.text$mn:00000F4F                 mov     edx, [ecx+28h]
.text$mn:00000F52                 push    edx             ; hWnd
.text$mn:00000F53                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000F59                 mov     [ebp+var_64], eax
.text$mn:00000F5C                 jmp     short loc_F67
.text$mn:00000F5E ; ---------------------------------------------------------------------------
.text$mn:00000F5E
.text$mn:00000F5E loc_F5E:                                ; CODE XREF: WindowsDlg::run_dlgProc(uint,uint,long)+720j
.text$mn:00000F5E                 mov     eax, [ebp+var_38]
.text$mn:00000F61                 add     eax, 1
.text$mn:00000F64                 mov     [ebp+var_38], eax
.text$mn:00000F67
.text$mn:00000F67 loc_F67:                                ; CODE XREF: WindowsDlg::run_dlgProc(uint,uint,long)+6DCj
.text$mn:00000F67                 mov     ecx, [ebp+var_38]
.text$mn:00000F6A                 cmp     ecx, [ebp+var_64]
.text$mn:00000F6D                 jge     short loc_FA2
.text$mn:00000F6F                 mov     [ebp+var_108], 2
.text$mn:00000F79                 mov     [ebp+var_10C], 2
.text$mn:00000F83                 lea     edx, [ebp+var_118]
.text$mn:00000F89                 push    edx             ; lParam
.text$mn:00000F8A                 mov     eax, [ebp+var_38]
.text$mn:00000F8D                 push    eax             ; wParam
.text$mn:00000F8E                 push    102Bh           ; Msg
.text$mn:00000F93                 mov     ecx, [ebp+this]
.text$mn:00000F96                 mov     edx, [ecx+28h]
.text$mn:00000F99                 push    edx             ; hWnd
.text$mn:00000F9A                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000FA0                 jmp     short loc_F5E
.text$mn:00000FA2 ; ---------------------------------------------------------------------------
.text$mn:00000FA2
.text$mn:00000FA2 loc_FA2:                                ; CODE XREF: WindowsDlg::run_dlgProc(uint,uint,long)+6A2j
.text$mn:00000FA2                                         ; WindowsDlg::run_dlgProc(uint,uint,long)+6AAj ...
.text$mn:00000FA2                 mov     eax, 1
.text$mn:00000FA7                 jmp     short loc_FBE
.text$mn:00000FA9 ; ---------------------------------------------------------------------------
.text$mn:00000FA9
.text$mn:00000FA9 loc_FA9:                                ; CODE XREF: WindowsDlg::run_dlgProc(uint,uint,long)+55j
.text$mn:00000FA9                                         ; WindowsDlg::run_dlgProc(uint,uint,long)+63j ...
.text$mn:00000FA9                 mov     eax, [ebp+arg_C]
.text$mn:00000FAC                 push    eax             ; __int32
.text$mn:00000FAD                 mov     ecx, [ebp+arg_8]
.text$mn:00000FB0                 push    ecx             ; unsigned int
.text$mn:00000FB1                 mov     edx, [ebp+arg_4]
.text$mn:00000FB4                 push    edx             ; unsigned int
.text$mn:00000FB5                 mov     eax, [ebp+this]
.text$mn:00000FB8                 push    eax             ; this
.text$mn:00000FB9                 call    ?run_dlgProc@SizeableDlg@@MAGHIIJ@Z ; SizeableDlg::run_dlgProc(uint,uint,long)
.text$mn:00000FBE
.text$mn:00000FBE loc_FBE:                                ; CODE XREF: WindowsDlg::run_dlgProc(uint,uint,long)+85j
.text$mn:00000FBE                                         ; WindowsDlg::run_dlgProc(uint,uint,long)+D4j ...
.text$mn:00000FBE                 mov     ecx, [ebp+var_C]
.text$mn:00000FC1                 mov     large fs:0, ecx
.text$mn:00000FC8                 pop     ecx
.text$mn:00000FC9                 pop     esi
.text$mn:00000FCA                 mov     esp, ebp
.text$mn:00000FCC                 pop     ebp
.text$mn:00000FCD                 retn    10h
.text$mn:00000FCD ?run_dlgProc@WindowsDlg@@MAGHIIJ@Z endp ; sp-analysis failed
.text$mn:00000FCD
.text$mn:00000FD0
.text$mn:00000FD0 ; =============== S U B R O U T I N E =======================================
.text$mn:00000FD0
.text$mn:00000FD0 ; Attributes: bp-based frame
.text$mn:00000FD0
.text$mn:00000FD0 ; int __thiscall WindowsDlg::onInitDialog(WindowsDlg *__hidden this)
.text$mn:00000FD0                 public ?onInitDialog@WindowsDlg@@MAEHXZ
.text$mn:00000FD0 ?onInitDialog@WindowsDlg@@MAEHXZ proc near ; DATA XREF: .rdata:0000DF4Co
.text$mn:00000FD0
.text$mn:00000FD0 Dst             = dword ptr -70h
.text$mn:00000FD0 var_6C          = dword ptr -6Ch
.text$mn:00000FD0 var_68          = dword ptr -68h
.text$mn:00000FD0 var_64          = dword ptr -64h
.text$mn:00000FD0 var_50          = dword ptr -50h
.text$mn:00000FD0 var_4C          = dword ptr -4Ch
.text$mn:00000FD0 var_48          = dword ptr -48h
.text$mn:00000FD0 var_44          = dword ptr -44h
.text$mn:00000FD0 var_40          = dword ptr -40h
.text$mn:00000FD0 lParam          = dword ptr -3Ch
.text$mn:00000FD0 var_38          = dword ptr -38h
.text$mn:00000FD0 var_34          = tagRECT ptr -34h
.text$mn:00000FD0 var_24          = tagRECT ptr -24h
.text$mn:00000FD0 Rect            = tagRECT ptr -14h
.text$mn:00000FD0 var_4           = dword ptr -4
.text$mn:00000FD0
.text$mn:00000FD0                 push    ebp
.text$mn:00000FD1                 mov     ebp, esp
.text$mn:00000FD3                 sub     esp, 70h
.text$mn:00000FD6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000FDB                 xor     eax, ebp
.text$mn:00000FDD                 mov     [ebp+var_4], eax
.text$mn:00000FE0                 mov     [ebp+var_38], ecx
.text$mn:00000FE3                 mov     eax, [ebp+var_38]
.text$mn:00000FE6                 mov     ecx, [eax+0Ch]
.text$mn:00000FE9                 push    ecx             ; HWND
.text$mn:00000FEA                 mov     ecx, [ebp+var_38]
.text$mn:00000FED                 add     ecx, 20h ; ' '  ; this
.text$mn:00000FF0                 call    ?InitToFitSizeFromCurrent@CWinMgr@@QAEXPAUHWND__@@@Z ; CWinMgr::InitToFitSizeFromCurrent(HWND__ *)
.text$mn:00000FF5                 push    1               ; unsigned int
.text$mn:00000FF7                 lea     edx, [ebp+var_34]
.text$mn:00000FFA                 push    edx             ; retstr
.text$mn:00000FFB                 mov     ecx, [ebp+var_38]
.text$mn:00000FFE                 add     ecx, 20h ; ' '  ; this
.text$mn:00001001                 call    ?GetRect@CWinMgr@@QAE?AUtagRECT@@I@Z ; CWinMgr::GetRect(uint)
.text$mn:00001006                 push    eax             ; struct tagRECT *
.text$mn:00001007                 call    ?RectToSize@@YA?AUtagSIZE@@ABUtagRECT@@@Z ; RectToSize(tagRECT const &)
.text$mn:0000100C                 add     esp, 4
.text$mn:0000100F                 mov     [ebp+var_4C], eax
.text$mn:00001012                 mov     [ebp+var_48], edx
.text$mn:00001015                 mov     eax, [ebp+var_38]
.text$mn:00001018                 mov     ecx, [ebp+var_4C]
.text$mn:0000101B                 mov     [eax+2Ch], ecx
.text$mn:0000101E                 mov     edx, [ebp+var_48]
.text$mn:00001021                 mov     [eax+30h], edx
.text$mn:00001024                 push    1B59h           ; unsigned int
.text$mn:00001029                 lea     eax, [ebp+var_24]
.text$mn:0000102C                 push    eax             ; retstr
.text$mn:0000102D                 mov     ecx, [ebp+var_38]
.text$mn:00001030                 add     ecx, 20h ; ' '  ; this
.text$mn:00001033                 call    ?GetRect@CWinMgr@@QAE?AUtagRECT@@I@Z ; CWinMgr::GetRect(uint)
.text$mn:00001038                 push    eax             ; struct tagRECT *
.text$mn:00001039                 call    ?RectToSize@@YA?AUtagSIZE@@ABUtagRECT@@@Z ; RectToSize(tagRECT const &)
.text$mn:0000103E                 add     esp, 4
.text$mn:00001041                 mov     [ebp+var_44], eax
.text$mn:00001044                 mov     [ebp+var_40], edx
.text$mn:00001047                 mov     ecx, [ebp+var_38]
.text$mn:0000104A                 mov     edx, [ebp+var_44]
.text$mn:0000104D                 mov     [ecx+34h], edx
.text$mn:00001050                 mov     eax, [ebp+var_40]
.text$mn:00001053                 mov     [ecx+38h], eax
.text$mn:00001056                 mov     ecx, [ebp+var_38]
.text$mn:00001059                 mov     dword ptr [ecx+50h], 0FFFFFFFFh
.text$mn:00001060                 mov     edx, [ebp+var_38]
.text$mn:00001063                 mov     eax, [edx+0Ch]
.text$mn:00001066                 push    eax             ; HWND
.text$mn:00001067                 mov     ecx, [ebp+var_38]
.text$mn:0000106A                 add     ecx, 20h ; ' '  ; this
.text$mn:0000106D                 call    ?CalcLayout@CWinMgr@@QAEXPAUHWND__@@@Z ; CWinMgr::CalcLayout(HWND__ *)
.text$mn:00001072                 mov     ecx, [ebp+var_38]
.text$mn:00001075                 mov     edx, [ecx+0Ch]
.text$mn:00001078                 push    edx
.text$mn:00001079                 mov     ecx, [ebp+var_38]
.text$mn:0000107C                 add     ecx, 20h ; ' '
.text$mn:0000107F                 mov     eax, [ebp+var_38]
.text$mn:00001082                 mov     edx, [eax+20h]
.text$mn:00001085                 mov     eax, [edx+8]
.text$mn:00001088                 call    eax
.text$mn:0000108A                 mov     ecx, [ebp+var_38]
.text$mn:0000108D                 add     ecx, 10h
.text$mn:00001090                 push    ecx
.text$mn:00001091                 mov     edx, [ebp+var_38]
.text$mn:00001094                 mov     eax, [edx]
.text$mn:00001096                 mov     ecx, [ebp+var_38]
.text$mn:00001099                 mov     edx, [eax+1Ch]
.text$mn:0000109C                 call    edx
.text$mn:0000109E                 push    1B59h           ; nIDDlgItem
.text$mn:000010A3                 mov     eax, [ebp+var_38]
.text$mn:000010A6                 mov     ecx, [eax+0Ch]
.text$mn:000010A9                 push    ecx             ; hDlg
.text$mn:000010AA                 call    dword ptr ds:__imp__GetDlgItem@8 ; GetDlgItem(x,x)
.text$mn:000010B0                 mov     edx, [ebp+var_38]
.text$mn:000010B3                 mov     [edx+28h], eax
.text$mn:000010B6                 push    0               ; lParam
.text$mn:000010B8                 push    0               ; wParam
.text$mn:000010BA                 push    1037h           ; Msg
.text$mn:000010BF                 mov     eax, [ebp+var_38]
.text$mn:000010C2                 mov     ecx, [eax+28h]
.text$mn:000010C5                 push    ecx             ; hWnd
.text$mn:000010C6                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:000010CC                 mov     [ebp+lParam], eax
.text$mn:000010CF                 mov     edx, [ebp+lParam]
.text$mn:000010D2                 or      edx, 10030h
.text$mn:000010D8                 mov     [ebp+lParam], edx
.text$mn:000010DB                 mov     eax, [ebp+lParam]
.text$mn:000010DE                 push    eax             ; lParam
.text$mn:000010DF                 push    0               ; wParam
.text$mn:000010E1                 push    1036h           ; Msg
.text$mn:000010E6                 mov     ecx, [ebp+var_38]
.text$mn:000010E9                 mov     edx, [ecx+28h]
.text$mn:000010EC                 push    edx             ; hWnd
.text$mn:000010ED                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:000010F3                 lea     eax, [ebp+Rect]
.text$mn:000010F6                 push    eax             ; lpRect
.text$mn:000010F7                 mov     ecx, [ebp+var_38]
.text$mn:000010FA                 mov     edx, [ecx+28h]
.text$mn:000010FD                 push    edx             ; hWnd
.text$mn:000010FE                 call    dword ptr ds:__imp__GetClientRect@8 ; GetClientRect(x,x)
.text$mn:00001104                 mov     eax, [ebp+Rect.right]
.text$mn:00001107                 sub     eax, [ebp+Rect.left]
.text$mn:0000110A                 mov     [ebp+var_50], eax
.text$mn:0000110D                 push    20h ; ' '       ; Size
.text$mn:0000110F                 push    0               ; Val
.text$mn:00001111                 lea     ecx, [ebp+Dst]
.text$mn:00001114                 push    ecx             ; Dst
.text$mn:00001115                 call    _memset
.text$mn:0000111A                 add     esp, 0Ch
.text$mn:0000111D                 mov     [ebp+Dst], 0Fh
.text$mn:00001124                 mov     [ebp+var_6C], 0
.text$mn:0000112B                 mov     [ebp+var_64], offset $SG132617 ; "Name"
.text$mn:00001132                 mov     eax, [ebp+var_50]
.text$mn:00001135                 cdq
.text$mn:00001136                 and     edx, 3
.text$mn:00001139                 add     eax, edx
.text$mn:0000113B                 sar     eax, 2
.text$mn:0000113E                 mov     [ebp+var_68], eax
.text$mn:00001141                 lea     edx, [ebp+Dst]
.text$mn:00001144                 push    edx             ; lParam
.text$mn:00001145                 push    0               ; wParam
.text$mn:00001147                 push    1061h           ; Msg
.text$mn:0000114C                 mov     eax, [ebp+var_38]
.text$mn:0000114F                 mov     ecx, [eax+28h]
.text$mn:00001152                 push    ecx             ; hWnd
.text$mn:00001153                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00001159                 mov     [ebp+var_64], offset $SG132618 ; "Path"
.text$mn:00001160                 mov     [ebp+var_68], 12Ch
.text$mn:00001167                 lea     edx, [ebp+Dst]
.text$mn:0000116A                 push    edx             ; lParam
.text$mn:0000116B                 push    1               ; wParam
.text$mn:0000116D                 push    1061h           ; Msg
.text$mn:00001172                 mov     eax, [ebp+var_38]
.text$mn:00001175                 mov     ecx, [eax+28h]
.text$mn:00001178                 push    ecx             ; hWnd
.text$mn:00001179                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:0000117F                 mov     [ebp+var_6C], 2
.text$mn:00001186                 mov     [ebp+var_64], offset $SG132619 ; "Type"
.text$mn:0000118D                 mov     [ebp+var_68], 28h ; '('
.text$mn:00001194                 lea     edx, [ebp+Dst]
.text$mn:00001197                 push    edx             ; lParam
.text$mn:00001198                 push    2               ; wParam
.text$mn:0000119A                 push    1061h           ; Msg
.text$mn:0000119F                 mov     eax, [ebp+var_38]
.text$mn:000011A2                 mov     ecx, [eax+28h]
.text$mn:000011A5                 push    ecx             ; hWnd
.text$mn:000011A6                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:000011AC                 mov     ecx, [ebp+var_38] ; this
.text$mn:000011AF                 call    ?fitColumnsToSize@WindowsDlg@@IAEXXZ ; WindowsDlg::fitColumnsToSize(void)
.text$mn:000011B4                 cmp     ds:?_lastKnownLocation@WindowsDlg@@1UtagRECT@@A.bottom, 0
.text$mn:000011BB                 jle     short loc_1200
.text$mn:000011BD                 cmp     ds:?_lastKnownLocation@WindowsDlg@@1UtagRECT@@A.right, 0
.text$mn:000011C4                 jle     short loc_1200
.text$mn:000011C6                 push    40h ; '@'       ; uFlags
.text$mn:000011C8                 mov     edx, ds:?_lastKnownLocation@WindowsDlg@@1UtagRECT@@A.bottom
.text$mn:000011CE                 sub     edx, ds:?_lastKnownLocation@WindowsDlg@@1UtagRECT@@A.top
.text$mn:000011D4                 push    edx             ; cy
.text$mn:000011D5                 mov     eax, ds:?_lastKnownLocation@WindowsDlg@@1UtagRECT@@A.right
.text$mn:000011DA                 sub     eax, ds:?_lastKnownLocation@WindowsDlg@@1UtagRECT@@A.left ; tagRECT WindowsDlg::_lastKnownLocation
.text$mn:000011E0                 push    eax             ; cx
.text$mn:000011E1                 mov     ecx, ds:?_lastKnownLocation@WindowsDlg@@1UtagRECT@@A.top
.text$mn:000011E7                 push    ecx             ; Y
.text$mn:000011E8                 mov     edx, ds:?_lastKnownLocation@WindowsDlg@@1UtagRECT@@A.left ; tagRECT WindowsDlg::_lastKnownLocation
.text$mn:000011EE                 push    edx             ; X
.text$mn:000011EF                 push    0               ; hWndInsertAfter
.text$mn:000011F1                 mov     eax, [ebp+var_38]
.text$mn:000011F4                 mov     ecx, [eax+0Ch]
.text$mn:000011F7                 push    ecx             ; hWnd
.text$mn:000011F8                 call    dword ptr ds:__imp__SetWindowPos@28 ; SetWindowPos(x,x,x,x,x,x,x)
.text$mn:000011FE                 jmp     short loc_1208
.text$mn:00001200 ; ---------------------------------------------------------------------------
.text$mn:00001200
.text$mn:00001200 loc_1200:                               ; CODE XREF: WindowsDlg::onInitDialog(void)+1EBj
.text$mn:00001200                                         ; WindowsDlg::onInitDialog(void)+1F4j
.text$mn:00001200                 mov     ecx, [ebp+var_38] ; this
.text$mn:00001203                 call    ?goToCenter@StaticDialog@@QAEXXZ ; StaticDialog::goToCenter(void)
.text$mn:00001208
.text$mn:00001208 loc_1208:                               ; CODE XREF: WindowsDlg::onInitDialog(void)+22Ej
.text$mn:00001208                 push    1               ; bool
.text$mn:0000120A                 mov     ecx, [ebp+var_38] ; this
.text$mn:0000120D                 call    ?doRefresh@WindowsDlg@@QAEX_N@Z ; WindowsDlg::doRefresh(bool)
.text$mn:00001212                 mov     eax, 1
.text$mn:00001217                 mov     ecx, [ebp+var_4]
.text$mn:0000121A                 xor     ecx, ebp
.text$mn:0000121C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00001221                 mov     esp, ebp
.text$mn:00001223                 pop     ebp
.text$mn:00001224                 retn
.text$mn:00001224 ?onInitDialog@WindowsDlg@@MAEHXZ endp
.text$mn:00001224
.text$mn:00001224 ; ---------------------------------------------------------------------------
.text$mn:00001225                 align 10h
.text$mn:00001230
.text$mn:00001230 ; =============== S U B R O U T I N E =======================================
.text$mn:00001230
.text$mn:00001230 ; Attributes: bp-based frame
.text$mn:00001230
.text$mn:00001230 ; void __thiscall WindowsDlg::onSize(WindowsDlg *this, unsigned int, int, int)
.text$mn:00001230                 public ?onSize@WindowsDlg@@MAEXIHH@Z
.text$mn:00001230 ?onSize@WindowsDlg@@MAEXIHH@Z proc near ; DATA XREF: .rdata:0000DF50o
.text$mn:00001230
.text$mn:00001230 var_4           = dword ptr -4
.text$mn:00001230 arg_0           = dword ptr  8
.text$mn:00001230 arg_4           = dword ptr  0Ch
.text$mn:00001230 arg_8           = dword ptr  10h
.text$mn:00001230
.text$mn:00001230                 push    ebp
.text$mn:00001231                 mov     ebp, esp
.text$mn:00001233                 push    ecx
.text$mn:00001234                 mov     [ebp+var_4], ecx
.text$mn:00001237                 mov     eax, [ebp+arg_8]
.text$mn:0000123A                 push    eax             ; int
.text$mn:0000123B                 mov     ecx, [ebp+arg_4]
.text$mn:0000123E                 push    ecx             ; int
.text$mn:0000123F                 mov     edx, [ebp+arg_0]
.text$mn:00001242                 push    edx             ; unsigned int
.text$mn:00001243                 mov     ecx, [ebp+var_4] ; this
.text$mn:00001246                 call    ?onSize@SizeableDlg@@MAEXIHH@Z ; SizeableDlg::onSize(uint,int,int)
.text$mn:0000124B                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000124E                 call    ?fitColumnsToSize@WindowsDlg@@IAEXXZ ; WindowsDlg::fitColumnsToSize(void)
.text$mn:00001253                 mov     esp, ebp
.text$mn:00001255                 pop     ebp
.text$mn:00001256                 retn    0Ch
.text$mn:00001256 ?onSize@WindowsDlg@@MAEXIHH@Z endp
.text$mn:00001256
.text$mn:00001256 ; ---------------------------------------------------------------------------
.text$mn:00001259                 align 10h
.text$mn:00001260
.text$mn:00001260 ; =============== S U B R O U T I N E =======================================
.text$mn:00001260
.text$mn:00001260 ; Attributes: bp-based frame
.text$mn:00001260
.text$mn:00001260 ; void __thiscall WindowsDlg::onGetMinMaxInfo(WindowsDlg *this, struct tagMINMAXINFO *)
.text$mn:00001260                 public ?onGetMinMaxInfo@WindowsDlg@@MAEXPAUtagMINMAXINFO@@@Z
.text$mn:00001260 ?onGetMinMaxInfo@WindowsDlg@@MAEXPAUtagMINMAXINFO@@@Z proc near
.text$mn:00001260                                         ; DATA XREF: .rdata:0000DF54o
.text$mn:00001260
.text$mn:00001260 var_4           = dword ptr -4
.text$mn:00001260 arg_0           = dword ptr  8
.text$mn:00001260
.text$mn:00001260                 push    ebp
.text$mn:00001261                 mov     ebp, esp
.text$mn:00001263                 push    ecx
.text$mn:00001264                 mov     [ebp+var_4], ecx
.text$mn:00001267                 mov     eax, [ebp+arg_0]
.text$mn:0000126A                 push    eax             ; struct tagMINMAXINFO *
.text$mn:0000126B                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000126E                 call    ?onGetMinMaxInfo@SizeableDlg@@MAEXPAUtagMINMAXINFO@@@Z ; SizeableDlg::onGetMinMaxInfo(tagMINMAXINFO *)
.text$mn:00001273                 mov     esp, ebp
.text$mn:00001275                 pop     ebp
.text$mn:00001276                 retn    4
.text$mn:00001276 ?onGetMinMaxInfo@WindowsDlg@@MAEXPAUtagMINMAXINFO@@@Z endp
.text$mn:00001276
.text$mn:00001276 ; ---------------------------------------------------------------------------
.text$mn:00001279                 align 10h
.text$mn:00001280
.text$mn:00001280 ; =============== S U B R O U T I N E =======================================
.text$mn:00001280
.text$mn:00001280 ; Attributes: bp-based frame
.text$mn:00001280
.text$mn:00001280 ; __int32 __thiscall WindowsDlg::onWinMgr(WindowsDlg *this, unsigned int, __int32)
.text$mn:00001280                 public ?onWinMgr@WindowsDlg@@MAEJIJ@Z
.text$mn:00001280 ?onWinMgr@WindowsDlg@@MAEJIJ@Z proc near ; DATA XREF: .rdata:0000DF58o
.text$mn:00001280
.text$mn:00001280 var_C           = dword ptr -0Ch
.text$mn:00001280 var_8           = dword ptr -8
.text$mn:00001280 var_4           = dword ptr -4
.text$mn:00001280 arg_0           = dword ptr  8
.text$mn:00001280 arg_4           = dword ptr  0Ch
.text$mn:00001280
.text$mn:00001280                 push    ebp
.text$mn:00001281                 mov     ebp, esp
.text$mn:00001283                 sub     esp, 0Ch
.text$mn:00001286                 mov     [ebp+var_C], ecx
.text$mn:00001289                 mov     eax, [ebp+arg_4]
.text$mn:0000128C                 mov     [ebp+var_8], eax
.text$mn:0000128F                 mov     ecx, [ebp+var_8]
.text$mn:00001292                 cmp     dword ptr [ecx+8], 1
.text$mn:00001296                 jnz     loc_131C
.text$mn:0000129C                 mov     edx, [ebp+arg_0]
.text$mn:0000129F                 mov     [ebp+var_4], edx
.text$mn:000012A2                 cmp     [ebp+var_4], 1B59h
.text$mn:000012A9                 ja      short loc_12C2
.text$mn:000012AB                 cmp     [ebp+var_4], 1B59h
.text$mn:000012B2                 jz      short loc_12F9
.text$mn:000012B4                 cmp     [ebp+var_4], 0
.text$mn:000012B8                 jbe     short loc_131C
.text$mn:000012BA                 cmp     [ebp+var_4], 2
.text$mn:000012BE                 jbe     short loc_12D6
.text$mn:000012C0                 jmp     short loc_131C
.text$mn:000012C2 ; ---------------------------------------------------------------------------
.text$mn:000012C2
.text$mn:000012C2 loc_12C2:                               ; CODE XREF: WindowsDlg::onWinMgr(uint,long)+29j
.text$mn:000012C2                 cmp     [ebp+var_4], 1B5Ah
.text$mn:000012C9                 jb      short loc_131C
.text$mn:000012CB                 cmp     [ebp+var_4], 1B5Ch
.text$mn:000012D2                 jbe     short loc_12D6
.text$mn:000012D4                 jmp     short loc_131C
.text$mn:000012D6 ; ---------------------------------------------------------------------------
.text$mn:000012D6
.text$mn:000012D6 loc_12D6:                               ; CODE XREF: WindowsDlg::onWinMgr(uint,long)+3Ej
.text$mn:000012D6                                         ; WindowsDlg::onWinMgr(uint,long)+52j
.text$mn:000012D6                 mov     eax, [ebp+var_C]
.text$mn:000012D9                 mov     ecx, [eax+2Ch]
.text$mn:000012DC                 mov     edx, [eax+30h]
.text$mn:000012DF                 mov     eax, [ebp+var_8]
.text$mn:000012E2                 mov     [eax+1Ch], ecx
.text$mn:000012E5                 mov     [eax+20h], edx
.text$mn:000012E8                 mov     ecx, [ebp+var_8]
.text$mn:000012EB                 mov     dword ptr [ecx+2Ch], 1
.text$mn:000012F2                 mov     eax, 1
.text$mn:000012F7                 jmp     short loc_132C
.text$mn:000012F9 ; ---------------------------------------------------------------------------
.text$mn:000012F9
.text$mn:000012F9 loc_12F9:                               ; CODE XREF: WindowsDlg::onWinMgr(uint,long)+32j
.text$mn:000012F9                 mov     edx, [ebp+var_C]
.text$mn:000012FC                 mov     eax, [edx+34h]
.text$mn:000012FF                 mov     ecx, [edx+38h]
.text$mn:00001302                 mov     edx, [ebp+var_8]
.text$mn:00001305                 mov     [edx+1Ch], eax
.text$mn:00001308                 mov     [edx+20h], ecx
.text$mn:0000130B                 mov     eax, [ebp+var_8]
.text$mn:0000130E                 mov     dword ptr [eax+2Ch], 1
.text$mn:00001315                 mov     eax, 1
.text$mn:0000131A                 jmp     short loc_132C
.text$mn:0000131C ; ---------------------------------------------------------------------------
.text$mn:0000131C
.text$mn:0000131C loc_131C:                               ; CODE XREF: WindowsDlg::onWinMgr(uint,long)+16j
.text$mn:0000131C                                         ; WindowsDlg::onWinMgr(uint,long)+38j ...
.text$mn:0000131C                 mov     ecx, [ebp+arg_4]
.text$mn:0000131F                 push    ecx             ; __int32
.text$mn:00001320                 mov     edx, [ebp+arg_0]
.text$mn:00001323                 push    edx             ; unsigned int
.text$mn:00001324                 mov     ecx, [ebp+var_C] ; this
.text$mn:00001327                 call    ?onWinMgr@SizeableDlg@@MAEJIJ@Z ; SizeableDlg::onWinMgr(uint,long)
.text$mn:0000132C
.text$mn:0000132C loc_132C:                               ; CODE XREF: WindowsDlg::onWinMgr(uint,long)+77j
.text$mn:0000132C                                         ; WindowsDlg::onWinMgr(uint,long)+9Aj
.text$mn:0000132C                 mov     esp, ebp
.text$mn:0000132E                 pop     ebp
.text$mn:0000132F                 retn    8
.text$mn:0000132F ?onWinMgr@WindowsDlg@@MAEJIJ@Z endp
.text$mn:0000132F
.text$mn:0000132F ; ---------------------------------------------------------------------------
.text$mn:00001332                 align 10h
.text$mn:00001340
.text$mn:00001340 ; =============== S U B R O U T I N E =======================================
.text$mn:00001340
.text$mn:00001340 ; Attributes: bp-based frame
.text$mn:00001340
.text$mn:00001340 ; void __thiscall WindowsDlg::destroy(WindowsDlg *__hidden this)
.text$mn:00001340                 public ?destroy@WindowsDlg@@MAEXXZ
.text$mn:00001340 ?destroy@WindowsDlg@@MAEXXZ proc near   ; DATA XREF: .rdata:0000DF18o
.text$mn:00001340
.text$mn:00001340 hWnd            = dword ptr -8
.text$mn:00001340 var_4           = dword ptr -4
.text$mn:00001340
.text$mn:00001340                 push    ebp
.text$mn:00001341                 mov     ebp, esp
.text$mn:00001343                 sub     esp, 8
.text$mn:00001346                 mov     [ebp+var_4], ecx
.text$mn:00001349                 push    offset ?_lastKnownLocation@WindowsDlg@@1UtagRECT@@A ; lpRect
.text$mn:0000134E                 mov     eax, [ebp+var_4]
.text$mn:00001351                 mov     ecx, [eax+0Ch]
.text$mn:00001354                 push    ecx             ; hWnd
.text$mn:00001355                 call    dword ptr ds:__imp__GetWindowRect@8 ; GetWindowRect(x,x)
.text$mn:0000135B                 mov     edx, [ebp+var_4]
.text$mn:0000135E                 mov     eax, [edx+0Ch]
.text$mn:00001361                 mov     [ebp+hWnd], eax
.text$mn:00001364                 mov     ecx, [ebp+var_4]
.text$mn:00001367                 mov     dword ptr [ecx+0Ch], 0
.text$mn:0000136E                 mov     edx, [ebp+hWnd]
.text$mn:00001371                 push    edx             ; hWnd
.text$mn:00001372                 call    dword ptr ds:__imp__DestroyWindow@4 ; DestroyWindow(x)
.text$mn:00001378                 mov     esp, ebp
.text$mn:0000137A                 pop     ebp
.text$mn:0000137B                 retn
.text$mn:0000137B ?destroy@WindowsDlg@@MAEXXZ endp
.text$mn:0000137B
.text$mn:0000137B ; ---------------------------------------------------------------------------
.text$mn:0000137C                 align 10h
.text$mn:00001380
.text$mn:00001380 ; =============== S U B R O U T I N E =======================================
.text$mn:00001380
.text$mn:00001380 ; Attributes: bp-based frame
.text$mn:00001380
.text$mn:00001380 ; void __thiscall WindowsDlg::fitColumnsToSize(WindowsDlg *__hidden this)
.text$mn:00001380                 public ?fitColumnsToSize@WindowsDlg@@IAEXXZ
.text$mn:00001380 ?fitColumnsToSize@WindowsDlg@@IAEXXZ proc near
.text$mn:00001380                                         ; CODE XREF: WindowsDlg::onInitDialog(void)+1DFp
.text$mn:00001380                                         ; WindowsDlg::onSize(uint,int,int)+1Ep
.text$mn:00001380
.text$mn:00001380 var_1C          = dword ptr -1Ch
.text$mn:00001380 lParam          = dword ptr -18h
.text$mn:00001380 Rect            = tagRECT ptr -14h
.text$mn:00001380 var_4           = dword ptr -4
.text$mn:00001380
.text$mn:00001380                 push    ebp
.text$mn:00001381                 mov     ebp, esp
.text$mn:00001383                 sub     esp, 1Ch
.text$mn:00001386                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000138B                 xor     eax, ebp
.text$mn:0000138D                 mov     [ebp+var_4], eax
.text$mn:00001390                 mov     [ebp+var_1C], ecx
.text$mn:00001393                 lea     eax, [ebp+Rect]
.text$mn:00001396                 push    eax             ; lpRect
.text$mn:00001397                 mov     ecx, [ebp+var_1C]
.text$mn:0000139A                 mov     edx, [ecx+28h]
.text$mn:0000139D                 push    edx             ; hWnd
.text$mn:0000139E                 call    dword ptr ds:__imp__GetClientRect@8 ; GetClientRect(x,x)
.text$mn:000013A4                 test    eax, eax
.text$mn:000013A6                 jz      short loc_141E
.text$mn:000013A8                 mov     eax, [ebp+Rect.right]
.text$mn:000013AB                 sub     eax, [ebp+Rect.left]
.text$mn:000013AE                 mov     [ebp+lParam], eax
.text$mn:000013B1                 push    0               ; lParam
.text$mn:000013B3                 push    0               ; wParam
.text$mn:000013B5                 push    101Dh           ; Msg
.text$mn:000013BA                 mov     ecx, [ebp+var_1C]
.text$mn:000013BD                 mov     edx, [ecx+28h]
.text$mn:000013C0                 push    edx             ; hWnd
.text$mn:000013C1                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:000013C7                 mov     ecx, [ebp+lParam]
.text$mn:000013CA                 sub     ecx, eax
.text$mn:000013CC                 mov     [ebp+lParam], ecx
.text$mn:000013CF                 push    0               ; lParam
.text$mn:000013D1                 push    2               ; wParam
.text$mn:000013D3                 push    101Dh           ; Msg
.text$mn:000013D8                 mov     edx, [ebp+var_1C]
.text$mn:000013DB                 mov     eax, [edx+28h]
.text$mn:000013DE                 push    eax             ; hWnd
.text$mn:000013DF                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:000013E5                 mov     ecx, [ebp+lParam]
.text$mn:000013E8                 sub     ecx, eax
.text$mn:000013EA                 mov     [ebp+lParam], ecx
.text$mn:000013ED                 push    2               ; nIndex
.text$mn:000013EF                 call    dword ptr ds:__imp__GetSystemMetrics@4 ; GetSystemMetrics(x)
.text$mn:000013F5                 mov     edx, [ebp+lParam]
.text$mn:000013F8                 sub     edx, eax
.text$mn:000013FA                 mov     [ebp+lParam], edx
.text$mn:000013FD                 mov     eax, [ebp+lParam]
.text$mn:00001400                 sub     eax, 1
.text$mn:00001403                 mov     [ebp+lParam], eax
.text$mn:00001406                 mov     ecx, [ebp+lParam]
.text$mn:00001409                 push    ecx             ; lParam
.text$mn:0000140A                 push    1               ; wParam
.text$mn:0000140C                 push    101Eh           ; Msg
.text$mn:00001411                 mov     edx, [ebp+var_1C]
.text$mn:00001414                 mov     eax, [edx+28h]
.text$mn:00001417                 push    eax             ; hWnd
.text$mn:00001418                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:0000141E
.text$mn:0000141E loc_141E:                               ; CODE XREF: WindowsDlg::fitColumnsToSize(void)+26j
.text$mn:0000141E                 mov     ecx, [ebp+var_4]
.text$mn:00001421                 xor     ecx, ebp
.text$mn:00001423                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00001428                 mov     esp, ebp
.text$mn:0000142A                 pop     ebp
.text$mn:0000142B                 retn
.text$mn:0000142B ?fitColumnsToSize@WindowsDlg@@IAEXXZ endp
.text$mn:0000142B
.text$mn:0000142B ; ---------------------------------------------------------------------------
.text$mn:0000142C                 align 10h
.text$mn:00001430
.text$mn:00001430 ; =============== S U B R O U T I N E =======================================
.text$mn:00001430
.text$mn:00001430 ; Attributes: bp-based frame
.text$mn:00001430
.text$mn:00001430 ; void __thiscall WindowsDlg::resetSelection(WindowsDlg *__hidden this)
.text$mn:00001430                 public ?resetSelection@WindowsDlg@@IAEXXZ
.text$mn:00001430 ?resetSelection@WindowsDlg@@IAEXXZ proc near
.text$mn:00001430                                         ; CODE XREF: WindowsDlg::doRefresh(bool)+130p
.text$mn:00001430
.text$mn:00001430 var_98          = dword ptr -98h
.text$mn:00001430 var_8C          = dword ptr -8Ch
.text$mn:00001430 var_88          = dword ptr -88h
.text$mn:00001430 lParam          = dword ptr -64h
.text$mn:00001430 var_58          = dword ptr -58h
.text$mn:00001430 var_54          = dword ptr -54h
.text$mn:00001430 var_30          = byte ptr -30h
.text$mn:00001430 var_24          = byte ptr -24h
.text$mn:00001430 var_18          = dword ptr -18h
.text$mn:00001430 wParam          = dword ptr -14h
.text$mn:00001430 var_10          = dword ptr -10h
.text$mn:00001430 var_C           = dword ptr -0Ch
.text$mn:00001430 var_4           = dword ptr -4
.text$mn:00001430
.text$mn:00001430                 push    ebp
.text$mn:00001431                 mov     ebp, esp
.text$mn:00001433                 push    0FFFFFFFFh
.text$mn:00001435                 push    offset __ehhandler$?resetSelection@WindowsDlg@@IAEXXZ
.text$mn:0000143A                 mov     eax, large fs:0
.text$mn:00001440                 push    eax
.text$mn:00001441                 sub     esp, 8Ch
.text$mn:00001447                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000144C                 xor     eax, ebp
.text$mn:0000144E                 push    eax
.text$mn:0000144F                 lea     eax, [ebp+var_C]
.text$mn:00001452                 mov     large fs:0, eax
.text$mn:00001458                 mov     [ebp+var_10], ecx
.text$mn:0000145B                 mov     eax, [ebp+var_10]
.text$mn:0000145E                 mov     ecx, [eax+3Ch]  ; this
.text$mn:00001461                 call    ?getCurrentTabIndex@TabBar@@QBEHXZ ; TabBar::getCurrentTabIndex(void)
.text$mn:00001466                 mov     [ebp+var_18], eax
.text$mn:00001469                 mov     [ebp+wParam], 0
.text$mn:00001470                 lea     ecx, [ebp+var_24]
.text$mn:00001473                 push    ecx
.text$mn:00001474                 mov     ecx, [ebp+var_10]
.text$mn:00001477                 add     ecx, 40h ; '@'
.text$mn:0000147A                 call    ?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ ; std::vector<int,std::allocator<int>>::begin(void)
.text$mn:0000147F                 mov     [ebp+var_4], 0
.text$mn:00001486                 lea     edx, [ebp+var_30]
.text$mn:00001489                 push    edx
.text$mn:0000148A                 mov     ecx, [ebp+var_10]
.text$mn:0000148D                 add     ecx, 40h ; '@'
.text$mn:00001490                 call    ?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ ; std::vector<int,std::allocator<int>>::end(void)
.text$mn:00001495                 mov     byte ptr [ebp+var_4], 1
.text$mn:00001499                 jmp     short loc_14AC
.text$mn:0000149B ; ---------------------------------------------------------------------------
.text$mn:0000149B
.text$mn:0000149B loc_149B:                               ; CODE XREF: WindowsDlg::resetSelection(void):loc_1529j
.text$mn:0000149B                 lea     ecx, [ebp+var_24]
.text$mn:0000149E                 call    ??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator++(void)
.text$mn:000014A3                 mov     eax, [ebp+wParam]
.text$mn:000014A6                 add     eax, 1
.text$mn:000014A9                 mov     [ebp+wParam], eax
.text$mn:000014AC
.text$mn:000014AC loc_14AC:                               ; CODE XREF: WindowsDlg::resetSelection(void)+69j
.text$mn:000014AC                 lea     ecx, [ebp+var_30]
.text$mn:000014AF                 push    ecx             ; std::_Iterator_base12 *
.text$mn:000014B0                 lea     ecx, [ebp+var_24]
.text$mn:000014B3                 call    ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator!=(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>> const &)
.text$mn:000014B8                 movzx   edx, al
.text$mn:000014BB                 test    edx, edx
.text$mn:000014BD                 jz      short loc_152E
.text$mn:000014BF                 lea     ecx, [ebp+var_24]
.text$mn:000014C2                 call    ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBEAAHXZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator*(void)
.text$mn:000014C7                 mov     eax, [eax]
.text$mn:000014C9                 cmp     eax, [ebp+var_18]
.text$mn:000014CC                 jnz     short loc_14F8
.text$mn:000014CE                 mov     [ebp+var_54], 3
.text$mn:000014D5                 mov     [ebp+var_58], 3
.text$mn:000014DC                 lea     ecx, [ebp+lParam]
.text$mn:000014DF                 push    ecx             ; lParam
.text$mn:000014E0                 mov     edx, [ebp+wParam]
.text$mn:000014E3                 push    edx             ; wParam
.text$mn:000014E4                 push    102Bh           ; Msg
.text$mn:000014E9                 mov     eax, [ebp+var_10]
.text$mn:000014EC                 mov     ecx, [eax+28h]
.text$mn:000014EF                 push    ecx             ; hWnd
.text$mn:000014F0                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:000014F6                 jmp     short loc_1529
.text$mn:000014F8 ; ---------------------------------------------------------------------------
.text$mn:000014F8
.text$mn:000014F8 loc_14F8:                               ; CODE XREF: WindowsDlg::resetSelection(void)+9Cj
.text$mn:000014F8                 mov     [ebp+var_88], 2
.text$mn:00001502                 mov     [ebp+var_8C], 0
.text$mn:0000150C                 lea     edx, [ebp+var_98]
.text$mn:00001512                 push    edx             ; lParam
.text$mn:00001513                 mov     eax, [ebp+wParam]
.text$mn:00001516                 push    eax             ; wParam
.text$mn:00001517                 push    102Bh           ; Msg
.text$mn:0000151C                 mov     ecx, [ebp+var_10]
.text$mn:0000151F                 mov     edx, [ecx+28h]
.text$mn:00001522                 push    edx             ; hWnd
.text$mn:00001523                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00001529
.text$mn:00001529 loc_1529:                               ; CODE XREF: WindowsDlg::resetSelection(void)+C6j
.text$mn:00001529                 jmp     loc_149B
.text$mn:0000152E ; ---------------------------------------------------------------------------
.text$mn:0000152E
.text$mn:0000152E loc_152E:                               ; CODE XREF: WindowsDlg::resetSelection(void)+8Dj
.text$mn:0000152E                 mov     byte ptr [ebp+var_4], 0
.text$mn:00001532                 lea     ecx, [ebp+var_30]
.text$mn:00001535                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$mn:0000153A                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001541                 lea     ecx, [ebp+var_24]
.text$mn:00001544                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$mn:00001549                 mov     ecx, [ebp+var_C]
.text$mn:0000154C                 mov     large fs:0, ecx
.text$mn:00001553                 pop     ecx
.text$mn:00001554                 mov     esp, ebp
.text$mn:00001556                 pop     ebp
.text$mn:00001557                 retn
.text$mn:00001557 ?resetSelection@WindowsDlg@@IAEXXZ endp
.text$mn:00001557
.text$mn:00001557 ; ---------------------------------------------------------------------------
.text$mn:00001558                 align 10h
.text$mn:00001560
.text$mn:00001560 ; =============== S U B R O U T I N E =======================================
.text$mn:00001560
.text$mn:00001560 ; Attributes: bp-based frame
.text$mn:00001560
.text$mn:00001560 ; void __thiscall WindowsDlg::doSave(WindowsDlg *__hidden this)
.text$mn:00001560                 public ?doSave@WindowsDlg@@IAEXXZ
.text$mn:00001560 ?doSave@WindowsDlg@@IAEXXZ proc near    ; CODE XREF: WindowsDlg::run_dlgProc(uint,uint,long)+107p
.text$mn:00001560
.text$mn:00001560 lParam          = dword ptr -34h
.text$mn:00001560 var_2C          = dword ptr -2Ch
.text$mn:00001560 var_24          = dword ptr -24h
.text$mn:00001560 var_20          = dword ptr -20h
.text$mn:00001560 var_1C          = dword ptr -1Ch
.text$mn:00001560 var_18          = dword ptr -18h
.text$mn:00001560 var_14          = dword ptr -14h
.text$mn:00001560 var_10          = dword ptr -10h
.text$mn:00001560 var_C           = dword ptr -0Ch
.text$mn:00001560 wParam          = dword ptr -8
.text$mn:00001560 var_4           = dword ptr -4
.text$mn:00001560
.text$mn:00001560                 push    ebp
.text$mn:00001561                 mov     ebp, esp
.text$mn:00001563                 sub     esp, 34h
.text$mn:00001566                 mov     [ebp+var_4], ecx
.text$mn:00001569                 lea     ecx, [ebp+lParam] ; this
.text$mn:0000156C                 call    ??0NMWINDLG@@QAE@XZ ; NMWINDLG::NMWINDLG(void)
.text$mn:00001571                 mov     [ebp+var_24], 2
.text$mn:00001578                 push    2               ; lParam
.text$mn:0000157A                 push    0FFFFFFFFh      ; wParam
.text$mn:0000157C                 push    100Ch           ; Msg
.text$mn:00001581                 mov     eax, [ebp+var_4]
.text$mn:00001584                 mov     ecx, [eax+28h]
.text$mn:00001587                 push    ecx             ; hWnd
.text$mn:00001588                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:0000158E                 mov     [ebp+var_20], eax
.text$mn:00001591                 mov     edx, [ebp+var_4]
.text$mn:00001594                 mov     eax, [edx+0Ch]
.text$mn:00001597                 mov     [ebp+lParam], eax
.text$mn:0000159A                 mov     ecx, ds:?WDN_NOTIFY@@3IB ; uint const WDN_NOTIFY
.text$mn:000015A0                 mov     [ebp+var_2C], ecx
.text$mn:000015A3                 push    0               ; lParam
.text$mn:000015A5                 push    0               ; wParam
.text$mn:000015A7                 push    1032h           ; Msg
.text$mn:000015AC                 mov     edx, [ebp+var_4]
.text$mn:000015AF                 mov     eax, [edx+28h]
.text$mn:000015B2                 push    eax             ; hWnd
.text$mn:000015B3                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:000015B9                 mov     [ebp+var_1C], eax
.text$mn:000015BC                 xor     ecx, ecx
.text$mn:000015BE                 mov     eax, [ebp+var_1C]
.text$mn:000015C1                 mov     edx, 4
.text$mn:000015C6                 mul     edx
.text$mn:000015C8                 seto    cl
.text$mn:000015CB                 neg     ecx
.text$mn:000015CD                 or      ecx, eax
.text$mn:000015CF                 push    ecx             ; unsigned int
.text$mn:000015D0                 call    ??_U@YAPAXI@Z   ; operator new[](uint)
.text$mn:000015D5                 add     esp, 4
.text$mn:000015D8                 mov     [ebp+var_10], eax
.text$mn:000015DB                 mov     eax, [ebp+var_10]
.text$mn:000015DE                 mov     [ebp+var_18], eax
.text$mn:000015E1                 mov     [ebp+wParam], 0FFFFFFFFh
.text$mn:000015E8                 mov     [ebp+var_C], 0
.text$mn:000015EF                 jmp     short loc_15FA
.text$mn:000015F1 ; ---------------------------------------------------------------------------
.text$mn:000015F1
.text$mn:000015F1 loc_15F1:                               ; CODE XREF: WindowsDlg::doSave(void)+D7j
.text$mn:000015F1                 mov     ecx, [ebp+var_C]
.text$mn:000015F4                 add     ecx, 1
.text$mn:000015F7                 mov     [ebp+var_C], ecx
.text$mn:000015FA
.text$mn:000015FA loc_15FA:                               ; CODE XREF: WindowsDlg::doSave(void)+8Fj
.text$mn:000015FA                 push    2               ; lParam
.text$mn:000015FC                 mov     edx, [ebp+wParam]
.text$mn:000015FF                 push    edx             ; wParam
.text$mn:00001600                 push    100Ch           ; Msg
.text$mn:00001605                 mov     eax, [ebp+var_4]
.text$mn:00001608                 mov     ecx, [eax+28h]
.text$mn:0000160B                 push    ecx             ; hWnd
.text$mn:0000160C                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00001612                 mov     [ebp+wParam], eax
.text$mn:00001615                 cmp     [ebp+wParam], 0FFFFFFFFh
.text$mn:00001619                 jnz     short loc_161D
.text$mn:0000161B                 jmp     short loc_1639
.text$mn:0000161D ; ---------------------------------------------------------------------------
.text$mn:0000161D
.text$mn:0000161D loc_161D:                               ; CODE XREF: WindowsDlg::doSave(void)+B9j
.text$mn:0000161D                 mov     edx, [ebp+wParam]
.text$mn:00001620                 push    edx
.text$mn:00001621                 mov     ecx, [ebp+var_4]
.text$mn:00001624                 add     ecx, 40h ; '@'
.text$mn:00001627                 call    ??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z ; std::vector<int,std::allocator<int>>::operator[](uint)
.text$mn:0000162C                 mov     ecx, [ebp+var_C]
.text$mn:0000162F                 mov     edx, [ebp+var_18]
.text$mn:00001632                 mov     eax, [eax]
.text$mn:00001634                 mov     [edx+ecx*4], eax
.text$mn:00001637                 jmp     short loc_15F1
.text$mn:00001639 ; ---------------------------------------------------------------------------
.text$mn:00001639
.text$mn:00001639 loc_1639:                               ; CODE XREF: WindowsDlg::doSave(void)+BBj
.text$mn:00001639                 lea     ecx, [ebp+lParam]
.text$mn:0000163C                 push    ecx             ; lParam
.text$mn:0000163D                 push    0               ; wParam
.text$mn:0000163F                 mov     edx, ds:?WDN_NOTIFY@@3IB ; uint const WDN_NOTIFY
.text$mn:00001645                 push    edx             ; Msg
.text$mn:00001646                 mov     eax, [ebp+var_4]
.text$mn:00001649                 mov     ecx, [eax+8]
.text$mn:0000164C                 push    ecx             ; hWnd
.text$mn:0000164D                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00001653                 mov     edx, [ebp+var_18]
.text$mn:00001656                 mov     [ebp+var_14], edx
.text$mn:00001659                 mov     eax, [ebp+var_14]
.text$mn:0000165C                 push    eax             ; void *
.text$mn:0000165D                 call    ??_V@YAXPAX@Z   ; operator delete[](void *)
.text$mn:00001662                 add     esp, 4
.text$mn:00001665                 push    0               ; bErase
.text$mn:00001667                 mov     ecx, [ebp+var_4]
.text$mn:0000166A                 add     ecx, 10h
.text$mn:0000166D                 push    ecx             ; lpRect
.text$mn:0000166E                 mov     edx, [ebp+var_4]
.text$mn:00001671                 mov     eax, [edx+28h]
.text$mn:00001674                 push    eax             ; hWnd
.text$mn:00001675                 call    dword ptr ds:__imp__InvalidateRect@12 ; InvalidateRect(x,x,x)
.text$mn:0000167B                 push    0               ; lParam
.text$mn:0000167D                 push    0               ; wParam
.text$mn:0000167F                 push    1032h           ; Msg
.text$mn:00001684                 mov     ecx, [ebp+var_4]
.text$mn:00001687                 mov     edx, [ecx+28h]
.text$mn:0000168A                 push    edx             ; hWnd
.text$mn:0000168B                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00001691                 push    eax             ; lParam
.text$mn:00001692                 push    0               ; wParam
.text$mn:00001694                 push    1015h           ; Msg
.text$mn:00001699                 mov     eax, [ebp+var_4]
.text$mn:0000169C                 mov     ecx, [eax+28h]
.text$mn:0000169F                 push    ecx             ; hWnd
.text$mn:000016A0                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:000016A6                 mov     esp, ebp
.text$mn:000016A8                 pop     ebp
.text$mn:000016A9                 retn
.text$mn:000016A9 ?doSave@WindowsDlg@@IAEXXZ endp
.text$mn:000016A9
.text$mn:000016A9 ; ---------------------------------------------------------------------------
.text$mn:000016AA                 align 10h
.text$mn:000016B0
.text$mn:000016B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000016B0
.text$mn:000016B0 ; Attributes: bp-based frame
.text$mn:000016B0
.text$mn:000016B0 ; void __thiscall WindowsDlg::doClose(WindowsDlg *__hidden this)
.text$mn:000016B0                 public ?doClose@WindowsDlg@@IAEXXZ
.text$mn:000016B0 ?doClose@WindowsDlg@@IAEXXZ proc near   ; CODE XREF: WindowsDlg::run_dlgProc(uint,uint,long)+119p
.text$mn:000016B0
.text$mn:000016B0 var_16C         = dword ptr -16Ch
.text$mn:000016B0 var_160         = dword ptr -160h
.text$mn:000016B0 var_15C         = dword ptr -15Ch
.text$mn:000016B0 lParam          = dword ptr -138h
.text$mn:000016B0 var_12C         = dword ptr -12Ch
.text$mn:000016B0 var_128         = dword ptr -128h
.text$mn:000016B0 var_104         = byte ptr -104h
.text$mn:000016B0 var_FC          = byte ptr -0FCh
.text$mn:000016B0 var_F0          = byte ptr -0F0h
.text$mn:000016B0 var_E4          = byte ptr -0E4h
.text$mn:000016B0 var_D8          = dword ptr -0D8h
.text$mn:000016B0 var_D4          = dword ptr -0D4h
.text$mn:000016B0 var_D0          = dword ptr -0D0h
.text$mn:000016B0 var_CC          = dword ptr -0CCh
.text$mn:000016B0 var_C8          = dword ptr -0C8h
.text$mn:000016B0 var_C4          = dword ptr -0C4h
.text$mn:000016B0 var_C0          = dword ptr -0C0h
.text$mn:000016B0 var_BC          = dword ptr -0BCh
.text$mn:000016B0 var_B8          = byte ptr -0B8h
.text$mn:000016B0 var_AC          = dword ptr -0ACh
.text$mn:000016B0 var_A8          = byte ptr -0A8h
.text$mn:000016B0 var_98          = byte ptr -98h
.text$mn:000016B0 var_8C          = dword ptr -8Ch
.text$mn:000016B0 var_84          = dword ptr -84h
.text$mn:000016B0 var_80          = dword ptr -80h
.text$mn:000016B0 var_7C          = dword ptr -7Ch
.text$mn:000016B0 var_78          = dword ptr -78h
.text$mn:000016B0 var_74          = dword ptr -74h
.text$mn:000016B0 var_70          = dword ptr -70h
.text$mn:000016B0 var_6C          = dword ptr -6Ch
.text$mn:000016B0 var_68          = dword ptr -68h
.text$mn:000016B0 var_64          = dword ptr -64h
.text$mn:000016B0 var_60          = byte ptr -60h
.text$mn:000016B0 var_54          = dword ptr -54h
.text$mn:000016B0 var_50          = dword ptr -50h
.text$mn:000016B0 var_4C          = dword ptr -4Ch
.text$mn:000016B0 var_48          = dword ptr -48h
.text$mn:000016B0 var_44          = dword ptr -44h
.text$mn:000016B0 var_40          = dword ptr -40h
.text$mn:000016B0 var_3C          = dword ptr -3Ch
.text$mn:000016B0 var_38          = dword ptr -38h
.text$mn:000016B0 var_34          = dword ptr -34h
.text$mn:000016B0 var_30          = dword ptr -30h
.text$mn:000016B0 var_2C          = dword ptr -2Ch
.text$mn:000016B0 var_28          = dword ptr -28h
.text$mn:000016B0 var_21          = byte ptr -21h
.text$mn:000016B0 var_20          = dword ptr -20h
.text$mn:000016B0 var_1C          = dword ptr -1Ch
.text$mn:000016B0 wParam          = dword ptr -18h
.text$mn:000016B0 var_14          = dword ptr -14h
.text$mn:000016B0 var_10          = dword ptr -10h
.text$mn:000016B0 var_C           = dword ptr -0Ch
.text$mn:000016B0 var_4           = dword ptr -4
.text$mn:000016B0
.text$mn:000016B0                 push    ebp
.text$mn:000016B1                 mov     ebp, esp
.text$mn:000016B3                 push    0FFFFFFFFh
.text$mn:000016B5                 push    offset __ehhandler$?doClose@WindowsDlg@@IAEXXZ
.text$mn:000016BA                 mov     eax, large fs:0
.text$mn:000016C0                 push    eax
.text$mn:000016C1                 sub     esp, 160h
.text$mn:000016C7                 push    esi
.text$mn:000016C8                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000016CD                 xor     eax, ebp
.text$mn:000016CF                 push    eax
.text$mn:000016D0                 lea     eax, [ebp+var_C]
.text$mn:000016D3                 mov     large fs:0, eax
.text$mn:000016D9                 mov     [ebp+var_10], ecx
.text$mn:000016DC                 lea     ecx, [ebp+var_8C] ; this
.text$mn:000016E2                 call    ??0NMWINDLG@@QAE@XZ ; NMWINDLG::NMWINDLG(void)
.text$mn:000016E7                 mov     [ebp+var_7C], 3
.text$mn:000016EE                 push    2               ; lParam
.text$mn:000016F0                 push    0FFFFFFFFh      ; wParam
.text$mn:000016F2                 push    100Ch           ; Msg
.text$mn:000016F7                 mov     eax, [ebp+var_10]
.text$mn:000016FA                 mov     ecx, [eax+28h]
.text$mn:000016FD                 push    ecx             ; hWnd
.text$mn:000016FE                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00001704                 mov     [ebp+var_14], eax
.text$mn:00001707                 cmp     [ebp+var_14], 0FFFFFFFFh
.text$mn:0000170B                 jnz     short loc_1712
.text$mn:0000170D                 jmp     loc_1BC2
.text$mn:00001712 ; ---------------------------------------------------------------------------
.text$mn:00001712
.text$mn:00001712 loc_1712:                               ; CODE XREF: WindowsDlg::doClose(void)+5Bj
.text$mn:00001712                 mov     edx, [ebp+var_14]
.text$mn:00001715                 push    edx
.text$mn:00001716                 mov     ecx, [ebp+var_10]
.text$mn:00001719                 add     ecx, 40h ; '@'
.text$mn:0000171C                 call    ??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z ; std::vector<int,std::allocator<int>>::operator[](uint)
.text$mn:00001721                 mov     eax, [eax]
.text$mn:00001723                 mov     [ebp+var_78], eax
.text$mn:00001726                 mov     ecx, [ebp+var_10]
.text$mn:00001729                 mov     edx, [ecx+0Ch]
.text$mn:0000172C                 mov     [ebp+var_8C], edx
.text$mn:00001732                 mov     eax, ds:?WDN_NOTIFY@@3IB ; uint const WDN_NOTIFY
.text$mn:00001737                 mov     [ebp+var_84], eax
.text$mn:0000173D                 push    0               ; lParam
.text$mn:0000173F                 push    0               ; wParam
.text$mn:00001741                 push    1032h           ; Msg
.text$mn:00001746                 mov     ecx, [ebp+var_10]
.text$mn:00001749                 mov     edx, [ecx+28h]
.text$mn:0000174C                 push    edx             ; hWnd
.text$mn:0000174D                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00001753                 mov     [ebp+var_74], eax
.text$mn:00001756                 mov     eax, [ebp+var_74]
.text$mn:00001759                 mov     [ebp+var_28], eax
.text$mn:0000175C                 xor     ecx, ecx
.text$mn:0000175E                 mov     eax, [ebp+var_74]
.text$mn:00001761                 mov     edx, 4
.text$mn:00001766                 mul     edx
.text$mn:00001768                 seto    cl
.text$mn:0000176B                 neg     ecx
.text$mn:0000176D                 or      ecx, eax
.text$mn:0000176F                 push    ecx             ; unsigned int
.text$mn:00001770                 call    ??_U@YAPAXI@Z   ; operator new[](uint)
.text$mn:00001775                 add     esp, 4
.text$mn:00001778                 mov     [ebp+var_50], eax
.text$mn:0000177B                 mov     eax, [ebp+var_50]
.text$mn:0000177E                 mov     [ebp+var_70], eax
.text$mn:00001781                 lea     ecx, [ebp+var_A8]
.text$mn:00001787                 call    ??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int>>::vector<int,std::allocator<int>>(void)
.text$mn:0000178C                 mov     [ebp+var_4], 0
.text$mn:00001793                 mov     [ebp+var_6C], 7FFFFFFFh
.text$mn:0000179A                 lea     ecx, [ebp+var_6C]
.text$mn:0000179D                 push    ecx
.text$mn:0000179E                 mov     edx, [ebp+var_28]
.text$mn:000017A1                 push    edx
.text$mn:000017A2                 lea     ecx, [ebp+var_A8]
.text$mn:000017A8                 call    ?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXIABH@Z ; std::vector<int,std::allocator<int>>::resize(uint,int const &)
.text$mn:000017AD                 mov     [ebp+wParam], 0FFFFFFFFh
.text$mn:000017B4                 mov     [ebp+var_20], 0
.text$mn:000017BB                 jmp     short loc_17C6
.text$mn:000017BD ; ---------------------------------------------------------------------------
.text$mn:000017BD
.text$mn:000017BD loc_17BD:                               ; CODE XREF: WindowsDlg::doClose(void)+198j
.text$mn:000017BD                 mov     eax, [ebp+var_20]
.text$mn:000017C0                 add     eax, 1
.text$mn:000017C3                 mov     [ebp+var_20], eax
.text$mn:000017C6
.text$mn:000017C6 loc_17C6:                               ; CODE XREF: WindowsDlg::doClose(void)+10Bj
.text$mn:000017C6                 push    2               ; lParam
.text$mn:000017C8                 mov     ecx, [ebp+wParam]
.text$mn:000017CB                 push    ecx             ; wParam
.text$mn:000017CC                 push    100Ch           ; Msg
.text$mn:000017D1                 mov     edx, [ebp+var_10]
.text$mn:000017D4                 mov     eax, [edx+28h]
.text$mn:000017D7                 push    eax             ; hWnd
.text$mn:000017D8                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:000017DE                 mov     [ebp+wParam], eax
.text$mn:000017E1                 cmp     [ebp+wParam], 0FFFFFFFFh
.text$mn:000017E5                 jnz     short loc_17E9
.text$mn:000017E7                 jmp     short loc_184D
.text$mn:000017E9 ; ---------------------------------------------------------------------------
.text$mn:000017E9
.text$mn:000017E9 loc_17E9:                               ; CODE XREF: WindowsDlg::doClose(void)+135j
.text$mn:000017E9                 mov     [ebp+var_128], 2
.text$mn:000017F3                 mov     [ebp+var_12C], 0
.text$mn:000017FD                 lea     ecx, [ebp+lParam]
.text$mn:00001803                 push    ecx             ; lParam
.text$mn:00001804                 mov     edx, [ebp+wParam]
.text$mn:00001807                 push    edx             ; wParam
.text$mn:00001808                 push    102Bh           ; Msg
.text$mn:0000180D                 mov     eax, [ebp+var_10]
.text$mn:00001810                 mov     ecx, [eax+28h]
.text$mn:00001813                 push    ecx             ; hWnd
.text$mn:00001814                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:0000181A                 mov     edx, [ebp+wParam]
.text$mn:0000181D                 push    edx
.text$mn:0000181E                 mov     ecx, [ebp+var_10]
.text$mn:00001821                 add     ecx, 40h ; '@'
.text$mn:00001824                 call    ??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z ; std::vector<int,std::allocator<int>>::operator[](uint)
.text$mn:00001829                 mov     ecx, [ebp+var_20]
.text$mn:0000182C                 mov     edx, [ebp+var_70]
.text$mn:0000182F                 mov     eax, [eax]
.text$mn:00001831                 mov     [edx+ecx*4], eax
.text$mn:00001834                 mov     ecx, [ebp+var_20]
.text$mn:00001837                 push    ecx
.text$mn:00001838                 lea     ecx, [ebp+var_A8]
.text$mn:0000183E                 call    ??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z ; std::vector<int,std::allocator<int>>::operator[](uint)
.text$mn:00001843                 mov     edx, [ebp+wParam]
.text$mn:00001846                 mov     [eax], edx
.text$mn:00001848                 jmp     loc_17BD
.text$mn:0000184D ; ---------------------------------------------------------------------------
.text$mn:0000184D
.text$mn:0000184D loc_184D:                               ; CODE XREF: WindowsDlg::doClose(void)+137j
.text$mn:0000184D                 lea     eax, [ebp+var_8C]
.text$mn:00001853                 push    eax             ; lParam
.text$mn:00001854                 push    0               ; wParam
.text$mn:00001856                 mov     ecx, ds:?WDN_NOTIFY@@3IB ; uint const WDN_NOTIFY
.text$mn:0000185C                 push    ecx             ; Msg
.text$mn:0000185D                 mov     edx, [ebp+var_10]
.text$mn:00001860                 mov     eax, [edx+8]
.text$mn:00001863                 push    eax             ; hWnd
.text$mn:00001864                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:0000186A                 cmp     [ebp+var_80], 0
.text$mn:0000186E                 jz      loc_1AE0
.text$mn:00001874                 lea     ecx, [ebp+var_98]
.text$mn:0000187A                 push    ecx
.text$mn:0000187B                 lea     ecx, [ebp+var_A8]
.text$mn:00001881                 call    ?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ ; std::vector<int,std::allocator<int>>::begin(void)
.text$mn:00001886                 mov     byte ptr [ebp+var_4], 1
.text$mn:0000188A                 mov     [ebp+var_1C], 0
.text$mn:00001891                 jmp     short loc_18A7
.text$mn:00001893 ; ---------------------------------------------------------------------------
.text$mn:00001893
.text$mn:00001893 loc_1893:                               ; CODE XREF: WindowsDlg::doClose(void):loc_198Dj
.text$mn:00001893                 mov     edx, [ebp+var_1C]
.text$mn:00001896                 add     edx, 1
.text$mn:00001899                 mov     [ebp+var_1C], edx
.text$mn:0000189C                 lea     ecx, [ebp+var_98]
.text$mn:000018A2                 call    ??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator++(void)
.text$mn:000018A7
.text$mn:000018A7 loc_18A7:                               ; CODE XREF: WindowsDlg::doClose(void)+1E1j
.text$mn:000018A7                 mov     eax, [ebp+var_1C]
.text$mn:000018AA                 cmp     eax, [ebp+var_28]
.text$mn:000018AD                 jnb     loc_1992
.text$mn:000018B3                 mov     ecx, [ebp+var_1C]
.text$mn:000018B6                 mov     edx, [ebp+var_70]
.text$mn:000018B9                 cmp     dword ptr [edx+ecx*4], 0FFFFFFFFh
.text$mn:000018BD                 jnz     loc_198D
.text$mn:000018C3                 lea     ecx, [ebp+var_98]
.text$mn:000018C9                 call    ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBEAAHXZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator*(void)
.text$mn:000018CE                 mov     eax, [eax]
.text$mn:000018D0                 push    eax
.text$mn:000018D1                 mov     ecx, [ebp+var_10]
.text$mn:000018D4                 add     ecx, 40h ; '@'
.text$mn:000018D7                 call    ??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z ; std::vector<int,std::allocator<int>>::operator[](uint)
.text$mn:000018DC                 mov     ecx, [eax]
.text$mn:000018DE                 mov     [ebp+var_3C], ecx
.text$mn:000018E1                 lea     ecx, [ebp+var_98]
.text$mn:000018E7                 call    ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBEAAHXZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator*(void)
.text$mn:000018EC                 mov     edx, [eax]
.text$mn:000018EE                 push    edx
.text$mn:000018EF                 mov     ecx, [ebp+var_10]
.text$mn:000018F2                 add     ecx, 40h ; '@'
.text$mn:000018F5                 call    ??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z ; std::vector<int,std::allocator<int>>::operator[](uint)
.text$mn:000018FA                 mov     dword ptr [eax], 0FFFFFFFFh
.text$mn:00001900                 lea     eax, [ebp+var_60]
.text$mn:00001903                 push    eax
.text$mn:00001904                 mov     ecx, [ebp+var_10]
.text$mn:00001907                 add     ecx, 40h ; '@'
.text$mn:0000190A                 call    ?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ ; std::vector<int,std::allocator<int>>::begin(void)
.text$mn:0000190F                 mov     byte ptr [ebp+var_4], 2
.text$mn:00001913                 lea     ecx, [ebp+var_B8]
.text$mn:00001919                 push    ecx
.text$mn:0000191A                 mov     ecx, [ebp+var_10]
.text$mn:0000191D                 add     ecx, 40h ; '@'
.text$mn:00001920                 call    ?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ ; std::vector<int,std::allocator<int>>::end(void)
.text$mn:00001925                 mov     byte ptr [ebp+var_4], 3
.text$mn:00001929                 jmp     short loc_1933
.text$mn:0000192B ; ---------------------------------------------------------------------------
.text$mn:0000192B
.text$mn:0000192B loc_192B:                               ; CODE XREF: WindowsDlg::doClose(void):loc_1970j
.text$mn:0000192B                 lea     ecx, [ebp+var_60]
.text$mn:0000192E                 call    ??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator++(void)
.text$mn:00001933
.text$mn:00001933 loc_1933:                               ; CODE XREF: WindowsDlg::doClose(void)+279j
.text$mn:00001933                 lea     edx, [ebp+var_B8]
.text$mn:00001939                 push    edx             ; std::_Iterator_base12 *
.text$mn:0000193A                 lea     ecx, [ebp+var_60]
.text$mn:0000193D                 call    ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator!=(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>> const &)
.text$mn:00001942                 movzx   eax, al
.text$mn:00001945                 test    eax, eax
.text$mn:00001947                 jz      short loc_1972
.text$mn:00001949                 lea     ecx, [ebp+var_60]
.text$mn:0000194C                 call    ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBEAAHXZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator*(void)
.text$mn:00001951                 mov     ecx, [eax]
.text$mn:00001953                 cmp     ecx, [ebp+var_3C]
.text$mn:00001956                 jle     short loc_1970
.text$mn:00001958                 lea     ecx, [ebp+var_60]
.text$mn:0000195B                 call    ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBEAAHXZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator*(void)
.text$mn:00001960                 mov     [ebp+var_2C], eax
.text$mn:00001963                 mov     edx, [ebp+var_2C]
.text$mn:00001966                 mov     eax, [edx]
.text$mn:00001968                 sub     eax, 1
.text$mn:0000196B                 mov     ecx, [ebp+var_2C]
.text$mn:0000196E                 mov     [ecx], eax
.text$mn:00001970
.text$mn:00001970 loc_1970:                               ; CODE XREF: WindowsDlg::doClose(void)+2A6j
.text$mn:00001970                 jmp     short loc_192B
.text$mn:00001972 ; ---------------------------------------------------------------------------
.text$mn:00001972
.text$mn:00001972 loc_1972:                               ; CODE XREF: WindowsDlg::doClose(void)+297j
.text$mn:00001972                 mov     byte ptr [ebp+var_4], 2
.text$mn:00001976                 lea     ecx, [ebp+var_B8]
.text$mn:0000197C                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$mn:00001981                 mov     byte ptr [ebp+var_4], 1
.text$mn:00001985                 lea     ecx, [ebp+var_60]
.text$mn:00001988                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$mn:0000198D
.text$mn:0000198D loc_198D:                               ; CODE XREF: WindowsDlg::doClose(void)+20Dj
.text$mn:0000198D                 jmp     loc_1893
.text$mn:00001992 ; ---------------------------------------------------------------------------
.text$mn:00001992
.text$mn:00001992 loc_1992:                               ; CODE XREF: WindowsDlg::doClose(void)+1FDj
.text$mn:00001992                 mov     [ebp+var_4C], 0FFFFFFFFh
.text$mn:00001999                 lea     edx, [ebp+var_FC]
.text$mn:0000199F                 push    edx
.text$mn:000019A0                 mov     ecx, [ebp+var_10]
.text$mn:000019A3                 add     ecx, 40h ; '@'
.text$mn:000019A6                 call    ?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ ; std::vector<int,std::allocator<int>>::end(void)
.text$mn:000019AB                 mov     [ebp+var_64], eax
.text$mn:000019AE                 mov     eax, [ebp+var_64]
.text$mn:000019B1                 mov     [ebp+var_44], eax
.text$mn:000019B4                 mov     byte ptr [ebp+var_4], 4
.text$mn:000019B8                 sub     esp, 0Ch
.text$mn:000019BB                 mov     ecx, esp
.text$mn:000019BD                 mov     [ebp+var_D8], esp
.text$mn:000019C3                 mov     edx, [ebp+var_44]
.text$mn:000019C6                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:000019C7                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>> const &)
.text$mn:000019CC                 mov     [ebp+var_68], eax
.text$mn:000019CF                 mov     eax, [ebp+var_68]
.text$mn:000019D2                 mov     [ebp+var_CC], eax
.text$mn:000019D8                 mov     byte ptr [ebp+var_4], 5
.text$mn:000019DC                 lea     ecx, [ebp+var_4C]
.text$mn:000019DF                 push    ecx
.text$mn:000019E0                 lea     edx, [ebp+var_21]
.text$mn:000019E3                 push    edx
.text$mn:000019E4                 lea     eax, [ebp+var_104]
.text$mn:000019EA                 push    eax
.text$mn:000019EB                 call    ??$bind2nd@U?$equal_to@H@std@@H@std@@YA?AV?$binder2nd@U?$equal_to@H@std@@@0@ABU?$equal_to@H@0@ABH@Z ; std::bind2nd<std::equal_to<int>,int>(std::equal_to<int> const &,int const &)
.text$mn:000019F0                 add     esp, 0Ch
.text$mn:000019F3                 mov     ecx, [eax+4]
.text$mn:000019F6                 push    ecx
.text$mn:000019F7                 mov     edx, [eax]
.text$mn:000019F9                 push    edx
.text$mn:000019FA                 sub     esp, 0Ch
.text$mn:000019FD                 mov     eax, esp
.text$mn:000019FF                 mov     [ebp+var_C0], esp
.text$mn:00001A05                 push    eax
.text$mn:00001A06                 mov     ecx, [ebp+var_10]
.text$mn:00001A09                 add     ecx, 40h ; '@'
.text$mn:00001A0C                 call    ?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ ; std::vector<int,std::allocator<int>>::end(void)
.text$mn:00001A11                 mov     [ebp+var_54], eax
.text$mn:00001A14                 mov     ecx, [ebp+var_54]
.text$mn:00001A17                 mov     [ebp+var_AC], ecx
.text$mn:00001A1D                 mov     byte ptr [ebp+var_4], 6
.text$mn:00001A21                 sub     esp, 0Ch
.text$mn:00001A24                 mov     edx, esp
.text$mn:00001A26                 mov     [ebp+var_C4], esp
.text$mn:00001A2C                 push    edx
.text$mn:00001A2D                 mov     ecx, [ebp+var_10]
.text$mn:00001A30                 add     ecx, 40h ; '@'
.text$mn:00001A33                 call    ?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ ; std::vector<int,std::allocator<int>>::begin(void)
.text$mn:00001A38                 mov     [ebp+var_34], eax
.text$mn:00001A3B                 mov     eax, [ebp+var_34]
.text$mn:00001A3E                 mov     [ebp+var_BC], eax
.text$mn:00001A44                 mov     byte ptr [ebp+var_4], 7
.text$mn:00001A48                 lea     ecx, [ebp+var_F0]
.text$mn:00001A4E                 push    ecx
.text$mn:00001A4F                 mov     byte ptr [ebp+var_4], 5
.text$mn:00001A53                 call    ??$remove_if@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@V?$binder2nd@U?$equal_to@H@std@@@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0V?$binder2nd@U?$equal_to@H@std@@@0@@Z ; std::remove_if<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::binder2nd<std::equal_to<int>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::binder2nd<std::equal_to<int>>)
.text$mn:00001A58                 add     esp, 24h
.text$mn:00001A5B                 mov     [ebp+var_38], eax
.text$mn:00001A5E                 mov     edx, [ebp+var_38]
.text$mn:00001A61                 mov     [ebp+var_40], edx
.text$mn:00001A64                 mov     byte ptr [ebp+var_4], 8
.text$mn:00001A68                 sub     esp, 0Ch
.text$mn:00001A6B                 mov     ecx, esp
.text$mn:00001A6D                 mov     [ebp+var_C8], esp
.text$mn:00001A73                 mov     eax, [ebp+var_40]
.text$mn:00001A76                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00001A77                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>> const &)
.text$mn:00001A7C                 mov     [ebp+var_48], eax
.text$mn:00001A7F                 mov     ecx, [ebp+var_48]
.text$mn:00001A82                 mov     [ebp+var_D0], ecx
.text$mn:00001A88                 mov     byte ptr [ebp+var_4], 9
.text$mn:00001A8C                 lea     edx, [ebp+var_E4]
.text$mn:00001A92                 push    edx
.text$mn:00001A93                 mov     ecx, [ebp+var_10]
.text$mn:00001A96                 add     ecx, 40h ; '@'
.text$mn:00001A99                 mov     byte ptr [ebp+var_4], 0Ah
.text$mn:00001A9D                 call    ?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@0@Z ; std::vector<int,std::allocator<int>>::erase(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>)
.text$mn:00001AA2                 mov     [ebp+var_D4], eax
.text$mn:00001AA8                 lea     ecx, [ebp+var_E4]
.text$mn:00001AAE                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$mn:00001AB3                 mov     byte ptr [ebp+var_4], 4
.text$mn:00001AB7                 lea     ecx, [ebp+var_F0]
.text$mn:00001ABD                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$mn:00001AC2                 mov     byte ptr [ebp+var_4], 1
.text$mn:00001AC6                 lea     ecx, [ebp+var_FC]
.text$mn:00001ACC                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$mn:00001AD1                 mov     byte ptr [ebp+var_4], 0
.text$mn:00001AD5                 lea     ecx, [ebp+var_98]
.text$mn:00001ADB                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$mn:00001AE0
.text$mn:00001AE0 loc_1AE0:                               ; CODE XREF: WindowsDlg::doClose(void)+1BEj
.text$mn:00001AE0                 mov     eax, [ebp+var_70]
.text$mn:00001AE3                 mov     [ebp+var_30], eax
.text$mn:00001AE6                 mov     ecx, [ebp+var_30]
.text$mn:00001AE9                 push    ecx             ; void *
.text$mn:00001AEA                 call    ??_V@YAXPAX@Z   ; operator delete[](void *)
.text$mn:00001AEF                 add     esp, 4
.text$mn:00001AF2                 mov     edx, [ebp+var_10]
.text$mn:00001AF5                 mov     ecx, [edx+3Ch]  ; this
.text$mn:00001AF8                 call    ?nbItem@TabBar@@QBEHXZ ; TabBar::nbItem(void)
.text$mn:00001AFD                 mov     esi, eax
.text$mn:00001AFF                 mov     ecx, [ebp+var_10]
.text$mn:00001B02                 add     ecx, 40h ; '@'
.text$mn:00001B05                 call    ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int>>::size(void)
.text$mn:00001B0A                 cmp     esi, eax
.text$mn:00001B0C                 jz      short loc_1B1D
.text$mn:00001B0E                 push    1               ; bool
.text$mn:00001B10                 mov     ecx, [ebp+var_10] ; this
.text$mn:00001B13                 call    ?doRefresh@WindowsDlg@@QAEX_N@Z ; WindowsDlg::doRefresh(bool)
.text$mn:00001B18                 jmp     loc_1BB0
.text$mn:00001B1D ; ---------------------------------------------------------------------------
.text$mn:00001B1D
.text$mn:00001B1D loc_1B1D:                               ; CODE XREF: WindowsDlg::doClose(void)+45Cj
.text$mn:00001B1D                 mov     ecx, [ebp+var_10]
.text$mn:00001B20                 add     ecx, 40h ; '@'
.text$mn:00001B23                 call    ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int>>::size(void)
.text$mn:00001B28                 cmp     [ebp+var_14], eax
.text$mn:00001B2B                 jnz     short loc_1B36
.text$mn:00001B2D                 mov     eax, [ebp+var_14]
.text$mn:00001B30                 sub     eax, 1
.text$mn:00001B33                 mov     [ebp+var_14], eax
.text$mn:00001B36
.text$mn:00001B36 loc_1B36:                               ; CODE XREF: WindowsDlg::doClose(void)+47Bj
.text$mn:00001B36                 cmp     [ebp+var_14], 0
.text$mn:00001B3A                 jl      short loc_1B90
.text$mn:00001B3C                 mov     [ebp+var_15C], 2
.text$mn:00001B46                 mov     [ebp+var_160], 2
.text$mn:00001B50                 lea     ecx, [ebp+var_16C]
.text$mn:00001B56                 push    ecx             ; lParam
.text$mn:00001B57
.text$mn:00001B57 loc_1B57:                               ; DATA XREF: WindowsDlg::doDialog(TiXmlNodeA *)+20o
.text$mn:00001B57                 mov     edx, [ebp+var_14]
.text$mn:00001B5A                 push    edx             ; wParam
.text$mn:00001B5B                 push    102Bh           ; Msg
.text$mn:00001B60                 mov     eax, [ebp+var_10]
.text$mn:00001B63                 mov     ecx, [eax+28h]
.text$mn:00001B66                 push    ecx             ; hWnd
.text$mn:00001B67                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00001B6D                 mov     ecx, [ebp+var_10]
.text$mn:00001B70                 add     ecx, 40h ; '@'
.text$mn:00001B73                 call    ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int>>::size(void)
.text$mn:00001B78                 sub     eax, 1
.text$mn:00001B7B                 push    eax             ; lParam
.text$mn:00001B7C                 push    0               ; wParam
.text$mn:00001B7E                 push    1015h           ; Msg
.text$mn:00001B83                 mov     edx, [ebp+var_10]
.text$mn:00001B86                 mov     eax, [edx+28h]
.text$mn:00001B89                 push    eax             ; hWnd
.text$mn:00001B8A                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00001B90
.text$mn:00001B90 loc_1B90:                               ; CODE XREF: WindowsDlg::doClose(void)+48Aj
.text$mn:00001B90                 push    0               ; lParam
.text$mn:00001B92                 mov     ecx, [ebp+var_10]
.text$mn:00001B95                 add     ecx, 40h ; '@'
.text$mn:00001B98                 call    ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int>>::size(void)
.text$mn:00001B9D                 push    eax             ; wParam
.text$mn:00001B9E                 push    102Fh           ; Msg
.text$mn:00001BA3                 mov     ecx, [ebp+var_10]
.text$mn:00001BA6                 mov     edx, [ecx+28h]
.text$mn:00001BA9                 push    edx             ; hWnd
.text$mn:00001BAA                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00001BB0
.text$mn:00001BB0 loc_1BB0:                               ; CODE XREF: WindowsDlg::doClose(void)+468j
.text$mn:00001BB0                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001BB7                 lea     ecx, [ebp+var_A8]
.text$mn:00001BBD                 call    ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int>>::~vector<int,std::allocator<int>>(void)
.text$mn:00001BC2
.text$mn:00001BC2 loc_1BC2:                               ; CODE XREF: WindowsDlg::doClose(void)+5Dj
.text$mn:00001BC2                 mov     ecx, [ebp+var_C]
.text$mn:00001BC5                 mov     large fs:0, ecx
.text$mn:00001BCC                 pop     ecx
.text$mn:00001BCD                 pop     esi
.text$mn:00001BCE                 mov     esp, ebp
.text$mn:00001BD0                 pop     ebp
.text$mn:00001BD1                 retn
.text$mn:00001BD1 ?doClose@WindowsDlg@@IAEXXZ endp
.text$mn:00001BD1
.text$mn:00001BD1 ; ---------------------------------------------------------------------------
.text$mn:00001BD2                 align 10h
.text$mn:00001BE0
.text$mn:00001BE0 ; =============== S U B R O U T I N E =======================================
.text$mn:00001BE0
.text$mn:00001BE0 ; Attributes: bp-based frame
.text$mn:00001BE0
.text$mn:00001BE0 ; void __thiscall WindowsDlg::doSortToTabs(WindowsDlg *__hidden this)
.text$mn:00001BE0                 public ?doSortToTabs@WindowsDlg@@IAEXXZ
.text$mn:00001BE0 ?doSortToTabs@WindowsDlg@@IAEXXZ proc near
.text$mn:00001BE0                                         ; CODE XREF: WindowsDlg::run_dlgProc(uint,uint,long)+12Bp
.text$mn:00001BE0
.text$mn:00001BE0 lParam          = dword ptr -5Ch
.text$mn:00001BE0 var_54          = dword ptr -54h
.text$mn:00001BE0 var_50          = dword ptr -50h
.text$mn:00001BE0 var_4C          = dword ptr -4Ch
.text$mn:00001BE0 var_48          = dword ptr -48h
.text$mn:00001BE0 var_44          = dword ptr -44h
.text$mn:00001BE0 var_40          = dword ptr -40h
.text$mn:00001BE0 var_3C          = byte ptr -3Ch
.text$mn:00001BE0 var_2C          = dword ptr -2Ch
.text$mn:00001BE0 var_28          = dword ptr -28h
.text$mn:00001BE0 var_24          = dword ptr -24h
.text$mn:00001BE0 var_20          = dword ptr -20h
.text$mn:00001BE0 var_1C          = dword ptr -1Ch
.text$mn:00001BE0 var_18          = dword ptr -18h
.text$mn:00001BE0 wParam          = dword ptr -14h
.text$mn:00001BE0 var_10          = dword ptr -10h
.text$mn:00001BE0 var_C           = dword ptr -0Ch
.text$mn:00001BE0 var_4           = dword ptr -4
.text$mn:00001BE0
.text$mn:00001BE0                 push    ebp
.text$mn:00001BE1                 mov     ebp, esp
.text$mn:00001BE3                 push    0FFFFFFFFh
.text$mn:00001BE5                 push    offset __ehhandler$?doSortToTabs@WindowsDlg@@IAEXXZ
.text$mn:00001BEA                 mov     eax, large fs:0
.text$mn:00001BF0                 push    eax
.text$mn:00001BF1                 sub     esp, 50h
.text$mn:00001BF4                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001BF9                 xor     eax, ebp
.text$mn:00001BFB                 push    eax
.text$mn:00001BFC                 lea     eax, [ebp+var_C]
.text$mn:00001BFF                 mov     large fs:0, eax
.text$mn:00001C05                 mov     [ebp+var_10], ecx
.text$mn:00001C08                 push    2               ; lParam
.text$mn:00001C0A                 push    0FFFFFFFFh      ; wParam
.text$mn:00001C0C                 push    100Ch           ; Msg
.text$mn:00001C11                 mov     eax, [ebp+var_10]
.text$mn:00001C14                 mov     ecx, [eax+28h]
.text$mn:00001C17                 push    ecx             ; hWnd
.text$mn:00001C18                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00001C1E                 mov     [ebp+var_1C], eax
.text$mn:00001C21                 cmp     [ebp+var_1C], 0FFFFFFFFh
.text$mn:00001C25                 jnz     short loc_1C2E
.text$mn:00001C27                 mov     [ebp+var_1C], 0
.text$mn:00001C2E
.text$mn:00001C2E loc_1C2E:                               ; CODE XREF: WindowsDlg::doSortToTabs(void)+45j
.text$mn:00001C2E                 lea     ecx, [ebp+lParam] ; this
.text$mn:00001C31                 call    ??0NMWINDLG@@QAE@XZ ; NMWINDLG::NMWINDLG(void)
.text$mn:00001C36                 mov     [ebp+var_4C], 4
.text$mn:00001C3D                 mov     edx, [ebp+var_10]
.text$mn:00001C40                 mov     eax, [edx+0Ch]
.text$mn:00001C43                 mov     [ebp+lParam], eax
.text$mn:00001C46                 mov     ecx, [ebp+var_1C]
.text$mn:00001C49                 push    ecx
.text$mn:00001C4A                 mov     ecx, [ebp+var_10]
.text$mn:00001C4D                 add     ecx, 40h ; '@'
.text$mn:00001C50                 call    ??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z ; std::vector<int,std::allocator<int>>::operator[](uint)
.text$mn:00001C55                 mov     edx, [eax]
.text$mn:00001C57                 mov     [ebp+var_48], edx
.text$mn:00001C5A                 mov     eax, ds:?WDN_NOTIFY@@3IB ; uint const WDN_NOTIFY
.text$mn:00001C5F                 mov     [ebp+var_54], eax
.text$mn:00001C62                 push    0               ; lParam
.text$mn:00001C64                 push    0               ; wParam
.text$mn:00001C66                 push    1004h           ; Msg
.text$mn:00001C6B                 mov     ecx, [ebp+var_10]
.text$mn:00001C6E                 mov     edx, [ecx+28h]
.text$mn:00001C71                 push    edx             ; hWnd
.text$mn:00001C72                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00001C78                 mov     [ebp+var_44], eax
.text$mn:00001C7B                 mov     eax, [ebp+var_44]
.text$mn:00001C7E                 mov     [ebp+var_28], eax
.text$mn:00001C81                 xor     ecx, ecx
.text$mn:00001C83                 mov     eax, [ebp+var_44]
.text$mn:00001C86                 mov     edx, 4
.text$mn:00001C8B                 mul     edx
.text$mn:00001C8D                 seto    cl
.text$mn:00001C90                 neg     ecx
.text$mn:00001C92                 or      ecx, eax
.text$mn:00001C94                 push    ecx             ; unsigned int
.text$mn:00001C95                 call    ??_U@YAPAXI@Z   ; operator new[](uint)
.text$mn:00001C9A                 add     esp, 4
.text$mn:00001C9D                 mov     [ebp+var_20], eax
.text$mn:00001CA0                 mov     eax, [ebp+var_20]
.text$mn:00001CA3                 mov     [ebp+var_40], eax
.text$mn:00001CA6                 lea     ecx, [ebp+var_3C]
.text$mn:00001CA9                 call    ??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int>>::vector<int,std::allocator<int>>(void)
.text$mn:00001CAE                 mov     [ebp+var_4], 0
.text$mn:00001CB5                 mov     [ebp+var_24], 7FFFFFFFh
.text$mn:00001CBC                 lea     ecx, [ebp+var_24]
.text$mn:00001CBF                 push    ecx
.text$mn:00001CC0                 mov     edx, [ebp+var_28]
.text$mn:00001CC3                 push    edx
.text$mn:00001CC4                 lea     ecx, [ebp+var_3C]
.text$mn:00001CC7                 call    ?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXIABH@Z ; std::vector<int,std::allocator<int>>::resize(uint,int const &)
.text$mn:00001CCC                 mov     [ebp+wParam], 0FFFFFFFFh
.text$mn:00001CD3                 mov     [ebp+var_18], 0
.text$mn:00001CDA                 jmp     short loc_1CE5
.text$mn:00001CDC ; ---------------------------------------------------------------------------
.text$mn:00001CDC
.text$mn:00001CDC loc_1CDC:                               ; CODE XREF: WindowsDlg::doSortToTabs(void)+161j
.text$mn:00001CDC                 mov     eax, [ebp+var_18]
.text$mn:00001CDF                 add     eax, 1
.text$mn:00001CE2                 mov     [ebp+var_18], eax
.text$mn:00001CE5
.text$mn:00001CE5 loc_1CE5:                               ; CODE XREF: WindowsDlg::doSortToTabs(void)+FAj
.text$mn:00001CE5                 push    0               ; lParam
.text$mn:00001CE7                 mov     ecx, [ebp+wParam]
.text$mn:00001CEA                 push    ecx             ; wParam
.text$mn:00001CEB                 push    100Ch           ; Msg
.text$mn:00001CF0                 mov     edx, [ebp+var_10]
.text$mn:00001CF3                 mov     eax, [edx+28h]
.text$mn:00001CF6                 push    eax             ; hWnd
.text$mn:00001CF7                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00001CFD                 mov     [ebp+wParam], eax
.text$mn:00001D00                 cmp     [ebp+wParam], 0FFFFFFFFh
.text$mn:00001D04                 jnz     short loc_1D08
.text$mn:00001D06                 jmp     short loc_1D43
.text$mn:00001D08 ; ---------------------------------------------------------------------------
.text$mn:00001D08
.text$mn:00001D08 loc_1D08:                               ; CODE XREF: WindowsDlg::doSortToTabs(void)+124j
.text$mn:00001D08                 mov     ecx, [ebp+wParam]
.text$mn:00001D0B                 push    ecx
.text$mn:00001D0C                 mov     ecx, [ebp+var_10]
.text$mn:00001D0F                 add     ecx, 40h ; '@'
.text$mn:00001D12                 call    ??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z ; std::vector<int,std::allocator<int>>::operator[](uint)
.text$mn:00001D17                 mov     edx, [ebp+var_18]
.text$mn:00001D1A                 mov     ecx, [ebp+var_40]
.text$mn:00001D1D                 mov     eax, [eax]
.text$mn:00001D1F                 mov     [ecx+edx*4], eax
.text$mn:00001D22                 mov     ecx, [ebp+wParam]
.text$mn:00001D25                 cmp     ecx, [ebp+var_1C]
.text$mn:00001D28                 jnz     short loc_1D30
.text$mn:00001D2A                 mov     edx, [ebp+var_18]
.text$mn:00001D2D                 mov     [ebp+var_48], edx
.text$mn:00001D30
.text$mn:00001D30 loc_1D30:                               ; CODE XREF: WindowsDlg::doSortToTabs(void)+148j
.text$mn:00001D30                 mov     eax, [ebp+var_18]
.text$mn:00001D33                 push    eax
.text$mn:00001D34                 lea     ecx, [ebp+var_3C]
.text$mn:00001D37                 call    ??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z ; std::vector<int,std::allocator<int>>::operator[](uint)
.text$mn:00001D3C                 mov     ecx, [ebp+wParam]
.text$mn:00001D3F                 mov     [eax], ecx
.text$mn:00001D41                 jmp     short loc_1CDC
.text$mn:00001D43 ; ---------------------------------------------------------------------------
.text$mn:00001D43
.text$mn:00001D43 loc_1D43:                               ; CODE XREF: WindowsDlg::doSortToTabs(void)+126j
.text$mn:00001D43                 lea     edx, [ebp+lParam]
.text$mn:00001D46                 push    edx             ; lParam
.text$mn:00001D47                 push    0               ; wParam
.text$mn:00001D49                 mov     eax, ds:?WDN_NOTIFY@@3IB ; uint const WDN_NOTIFY
.text$mn:00001D4E                 push    eax             ; Msg
.text$mn:00001D4F                 mov     ecx, [ebp+var_10]
.text$mn:00001D52                 mov     edx, [ecx+8]
.text$mn:00001D55                 push    edx             ; hWnd
.text$mn:00001D56                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00001D5C                 cmp     [ebp+var_50], 0
.text$mn:00001D60                 jz      short loc_1D77
.text$mn:00001D62                 mov     ecx, [ebp+var_10]
.text$mn:00001D65                 add     ecx, 40h ; '@'
.text$mn:00001D68                 call    ?clear@?$vector@HV?$allocator@H@std@@@std@@QAEXXZ ; std::vector<int,std::allocator<int>>::clear(void)
.text$mn:00001D6D                 push    1               ; bool
.text$mn:00001D6F                 mov     ecx, [ebp+var_10] ; this
.text$mn:00001D72                 call    ?doRefresh@WindowsDlg@@QAEX_N@Z ; WindowsDlg::doRefresh(bool)
.text$mn:00001D77
.text$mn:00001D77 loc_1D77:                               ; CODE XREF: WindowsDlg::doSortToTabs(void)+180j
.text$mn:00001D77                 mov     eax, [ebp+var_40]
.text$mn:00001D7A                 mov     [ebp+var_2C], eax
.text$mn:00001D7D                 mov     ecx, [ebp+var_2C]
.text$mn:00001D80                 push    ecx             ; void *
.text$mn:00001D81                 call    ??_V@YAXPAX@Z   ; operator delete[](void *)
.text$mn:00001D86                 add     esp, 4
.text$mn:00001D89                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001D90                 lea     ecx, [ebp+var_3C]
.text$mn:00001D93                 call    ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int>>::~vector<int,std::allocator<int>>(void)
.text$mn:00001D98                 mov     ecx, [ebp+var_C]
.text$mn:00001D9B                 mov     large fs:0, ecx
.text$mn:00001DA2                 pop     ecx
.text$mn:00001DA3                 mov     esp, ebp
.text$mn:00001DA5                 pop     ebp
.text$mn:00001DA6                 retn
.text$mn:00001DA6 ?doSortToTabs@WindowsDlg@@IAEXXZ endp
.text$mn:00001DA6
.text$mn:00001DA6 ; ---------------------------------------------------------------------------
.text$mn:00001DA7                 align 10h
.text$mn:00001DB0
.text$mn:00001DB0 ; =============== S U B R O U T I N E =======================================
.text$mn:00001DB0
.text$mn:00001DB0 ; Attributes: bp-based frame
.text$mn:00001DB0
.text$mn:00001DB0 ; void __thiscall WindowsDlg::updateButtonState(WindowsDlg *__hidden this)
.text$mn:00001DB0                 public ?updateButtonState@WindowsDlg@@IAEXXZ
.text$mn:00001DB0 ?updateButtonState@WindowsDlg@@IAEXXZ proc near
.text$mn:00001DB0                                         ; CODE XREF: WindowsDlg::doRefresh(bool)+138p
.text$mn:00001DB0                                         ; WindowsDlg::run_dlgProc(uint,uint,long)+13Ap ...
.text$mn:00001DB0
.text$mn:00001DB0 var_8           = dword ptr -8
.text$mn:00001DB0 var_4           = dword ptr -4
.text$mn:00001DB0
.text$mn:00001DB0                 push    ebp
.text$mn:00001DB1                 mov     ebp, esp
.text$mn:00001DB3                 sub     esp, 8
.text$mn:00001DB6                 mov     [ebp+var_4], ecx
.text$mn:00001DB9                 push    0               ; lParam
.text$mn:00001DBB                 push    0               ; wParam
.text$mn:00001DBD                 push    1032h           ; Msg
.text$mn:00001DC2                 mov     eax, [ebp+var_4]
.text$mn:00001DC5                 mov     ecx, [eax+28h]
.text$mn:00001DC8                 push    ecx             ; hWnd
.text$mn:00001DC9                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00001DCF                 mov     [ebp+var_8], eax
.text$mn:00001DD2                 cmp     [ebp+var_8], 0
.text$mn:00001DD6                 jnz     short loc_1E28
.text$mn:00001DD8                 push    0               ; bEnable
.text$mn:00001DDA                 push    1               ; nIDDlgItem
.text$mn:00001DDC                 mov     edx, [ebp+var_4]
.text$mn:00001DDF                 mov     eax, [edx+0Ch]
.text$mn:00001DE2                 push    eax             ; hDlg
.text$mn:00001DE3                 call    dword ptr ds:__imp__GetDlgItem@8 ; GetDlgItem(x,x)
.text$mn:00001DE9                 push    eax             ; hWnd
.text$mn:00001DEA                 call    dword ptr ds:__imp__EnableWindow@8 ; EnableWindow(x,x)
.text$mn:00001DF0                 push    0               ; bEnable
.text$mn:00001DF2                 push    1B5Ah           ; nIDDlgItem
.text$mn:00001DF7                 mov     ecx, [ebp+var_4]
.text$mn:00001DFA                 mov     edx, [ecx+0Ch]
.text$mn:00001DFD                 push    edx             ; hDlg
.text$mn:00001DFE                 call    dword ptr ds:__imp__GetDlgItem@8 ; GetDlgItem(x,x)
.text$mn:00001E04                 push    eax             ; hWnd
.text$mn:00001E05                 call    dword ptr ds:__imp__EnableWindow@8 ; EnableWindow(x,x)
.text$mn:00001E0B                 push    0               ; bEnable
.text$mn:00001E0D                 push    1B5Bh           ; nIDDlgItem
.text$mn:00001E12                 mov     eax, [ebp+var_4]
.text$mn:00001E15                 mov     ecx, [eax+0Ch]
.text$mn:00001E18                 push    ecx             ; hDlg
.text$mn:00001E19                 call    dword ptr ds:__imp__GetDlgItem@8 ; GetDlgItem(x,x)
.text$mn:00001E1F                 push    eax             ; hWnd
.text$mn:00001E20                 call    dword ptr ds:__imp__EnableWindow@8 ; EnableWindow(x,x)
.text$mn:00001E26                 jmp     short loc_1E96
.text$mn:00001E28 ; ---------------------------------------------------------------------------
.text$mn:00001E28
.text$mn:00001E28 loc_1E28:                               ; CODE XREF: WindowsDlg::updateButtonState(void)+26j
.text$mn:00001E28                 push    1               ; bEnable
.text$mn:00001E2A                 push    1B5Ah           ; nIDDlgItem
.text$mn:00001E2F                 mov     edx, [ebp+var_4]
.text$mn:00001E32                 mov     eax, [edx+0Ch]
.text$mn:00001E35                 push    eax             ; hDlg
.text$mn:00001E36                 call    dword ptr ds:__imp__GetDlgItem@8 ; GetDlgItem(x,x)
.text$mn:00001E3C                 push    eax             ; hWnd
.text$mn:00001E3D                 call    dword ptr ds:__imp__EnableWindow@8 ; EnableWindow(x,x)
.text$mn:00001E43                 push    1               ; bEnable
.text$mn:00001E45                 push    1B5Bh           ; nIDDlgItem
.text$mn:00001E4A                 mov     ecx, [ebp+var_4]
.text$mn:00001E4D                 mov     edx, [ecx+0Ch]
.text$mn:00001E50                 push    edx             ; hDlg
.text$mn:00001E51                 call    dword ptr ds:__imp__GetDlgItem@8 ; GetDlgItem(x,x)
.text$mn:00001E57                 push    eax             ; hWnd
.text$mn:00001E58                 call    dword ptr ds:__imp__EnableWindow@8 ; EnableWindow(x,x)
.text$mn:00001E5E                 cmp     [ebp+var_8], 1
.text$mn:00001E62                 jnz     short loc_1E7E
.text$mn:00001E64                 push    1               ; bEnable
.text$mn:00001E66                 push    1               ; nIDDlgItem
.text$mn:00001E68                 mov     eax, [ebp+var_4]
.text$mn:00001E6B                 mov     ecx, [eax+0Ch]
.text$mn:00001E6E                 push    ecx             ; hDlg
.text$mn:00001E6F                 call    dword ptr ds:__imp__GetDlgItem@8 ; GetDlgItem(x,x)
.text$mn:00001E75                 push    eax             ; hWnd
.text$mn:00001E76                 call    dword ptr ds:__imp__EnableWindow@8 ; EnableWindow(x,x)
.text$mn:00001E7C                 jmp     short loc_1E96
.text$mn:00001E7E ; ---------------------------------------------------------------------------
.text$mn:00001E7E
.text$mn:00001E7E loc_1E7E:                               ; CODE XREF: WindowsDlg::updateButtonState(void)+B2j
.text$mn:00001E7E                 push    0               ; bEnable
.text$mn:00001E80                 push    1               ; nIDDlgItem
.text$mn:00001E82                 mov     edx, [ebp+var_4]
.text$mn:00001E85                 mov     eax, [edx+0Ch]
.text$mn:00001E88                 push    eax             ; hDlg
.text$mn:00001E89                 call    dword ptr ds:__imp__GetDlgItem@8 ; GetDlgItem(x,x)
.text$mn:00001E8F                 push    eax             ; hWnd
.text$mn:00001E90                 call    dword ptr ds:__imp__EnableWindow@8 ; EnableWindow(x,x)
.text$mn:00001E96
.text$mn:00001E96 loc_1E96:                               ; CODE XREF: WindowsDlg::updateButtonState(void)+76j
.text$mn:00001E96                                         ; WindowsDlg::updateButtonState(void)+CCj
.text$mn:00001E96                 mov     ecx, [ebp+var_4]
.text$mn:00001E99                 movzx   edx, byte ptr [ecx+54h]
.text$mn:00001E9D                 push    edx             ; bEnable
.text$mn:00001E9E                 push    1B5Ch           ; nIDDlgItem
.text$mn:00001EA3                 mov     eax, [ebp+var_4]
.text$mn:00001EA6                 mov     ecx, [eax+0Ch]
.text$mn:00001EA9                 push    ecx             ; hDlg
.text$mn:00001EAA                 call    dword ptr ds:__imp__GetDlgItem@8 ; GetDlgItem(x,x)
.text$mn:00001EB0                 push    eax             ; hWnd
.text$mn:00001EB1                 call    dword ptr ds:__imp__EnableWindow@8 ; EnableWindow(x,x)
.text$mn:00001EB7                 mov     esp, ebp
.text$mn:00001EB9                 pop     ebp
.text$mn:00001EBA                 retn
.text$mn:00001EBA ?updateButtonState@WindowsDlg@@IAEXXZ endp
.text$mn:00001EBA
.text$mn:00001EBA ; ---------------------------------------------------------------------------
.text$mn:00001EBB                 align 10h
.text$mn:00001EC0
.text$mn:00001EC0 ; =============== S U B R O U T I N E =======================================
.text$mn:00001EC0
.text$mn:00001EC0 ; Attributes: bp-based frame
.text$mn:00001EC0
.text$mn:00001EC0 ; void __thiscall WindowsDlg::activateCurrent(WindowsDlg *__hidden this)
.text$mn:00001EC0                 public ?activateCurrent@WindowsDlg@@IAEXXZ
.text$mn:00001EC0 ?activateCurrent@WindowsDlg@@IAEXXZ proc near
.text$mn:00001EC0                                         ; CODE XREF: WindowsDlg::run_dlgProc(uint,uint,long)+CAp
.text$mn:00001EC0
.text$mn:00001EC0 lParam          = dword ptr -24h
.text$mn:00001EC0 var_1C          = dword ptr -1Ch
.text$mn:00001EC0 var_14          = dword ptr -14h
.text$mn:00001EC0 var_10          = dword ptr -10h
.text$mn:00001EC0 var_4           = dword ptr -4
.text$mn:00001EC0
.text$mn:00001EC0                 push    ebp
.text$mn:00001EC1                 mov     ebp, esp
.text$mn:00001EC3                 sub     esp, 24h
.text$mn:00001EC6                 mov     [ebp+var_4], ecx
.text$mn:00001EC9                 push    0               ; lParam
.text$mn:00001ECB                 push    0               ; wParam
.text$mn:00001ECD                 push    1032h           ; Msg
.text$mn:00001ED2                 mov     eax, [ebp+var_4]
.text$mn:00001ED5                 mov     ecx, [eax+28h]
.text$mn:00001ED8                 push    ecx             ; hWnd
.text$mn:00001ED9                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00001EDF                 cmp     eax, 1
.text$mn:00001EE2                 jnz     loc_1F6A
.text$mn:00001EE8                 lea     ecx, [ebp+lParam] ; this
.text$mn:00001EEB                 call    ??0NMWINDLG@@QAE@XZ ; NMWINDLG::NMWINDLG(void)
.text$mn:00001EF0                 mov     [ebp+var_14], 1
.text$mn:00001EF7                 push    2               ; lParam
.text$mn:00001EF9                 push    0FFFFFFFFh      ; wParam
.text$mn:00001EFB                 push    100Ch           ; Msg
.text$mn:00001F00                 mov     edx, [ebp+var_4]
.text$mn:00001F03                 mov     eax, [edx+28h]
.text$mn:00001F06                 push    eax             ; hWnd
.text$mn:00001F07                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00001F0D                 push    eax
.text$mn:00001F0E                 mov     ecx, [ebp+var_4]
.text$mn:00001F11                 add     ecx, 40h ; '@'
.text$mn:00001F14                 call    ??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z ; std::vector<int,std::allocator<int>>::operator[](uint)
.text$mn:00001F19                 mov     ecx, [eax]
.text$mn:00001F1B                 mov     [ebp+var_10], ecx
.text$mn:00001F1E                 mov     edx, [ebp+var_4]
.text$mn:00001F21                 mov     eax, [edx+0Ch]
.text$mn:00001F24                 mov     [ebp+lParam], eax
.text$mn:00001F27                 mov     ecx, ds:?WDN_NOTIFY@@3IB ; uint const WDN_NOTIFY
.text$mn:00001F2D                 mov     [ebp+var_1C], ecx
.text$mn:00001F30                 lea     edx, [ebp+lParam]
.text$mn:00001F33                 push    edx             ; lParam
.text$mn:00001F34                 push    0               ; wParam
.text$mn:00001F36                 mov     eax, ds:?WDN_NOTIFY@@3IB ; uint const WDN_NOTIFY
.text$mn:00001F3B                 push    eax             ; Msg
.text$mn:00001F3C                 mov     ecx, [ebp+var_4]
.text$mn:00001F3F                 mov     edx, [ecx+8]
.text$mn:00001F42                 push    edx             ; hWnd
.text$mn:00001F43                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00001F49                 push    offset ?_lastKnownLocation@WindowsDlg@@1UtagRECT@@A ; lpRect
.text$mn:00001F4E                 mov     eax, [ebp+var_4]
.text$mn:00001F51                 mov     ecx, [eax+0Ch]
.text$mn:00001F54                 push    ecx             ; hWnd
.text$mn:00001F55                 call    dword ptr ds:__imp__GetWindowRect@8 ; GetWindowRect(x,x)
.text$mn:00001F5B                 push    1               ; nResult
.text$mn:00001F5D                 mov     edx, [ebp+var_4]
.text$mn:00001F60                 mov     eax, [edx+0Ch]
.text$mn:00001F63                 push    eax             ; hDlg
.text$mn:00001F64                 call    dword ptr ds:__imp__EndDialog@8 ; EndDialog(x,x)
.text$mn:00001F6A
.text$mn:00001F6A loc_1F6A:                               ; CODE XREF: WindowsDlg::activateCurrent(void)+22j
.text$mn:00001F6A                 mov     esp, ebp
.text$mn:00001F6C                 pop     ebp
.text$mn:00001F6D                 retn
.text$mn:00001F6D ?activateCurrent@WindowsDlg@@IAEXXZ endp
.text$mn:00001F6D
.text$mn:00001F6D ; ---------------------------------------------------------------------------
.text$mn:00001F6E                 align 10h
.text$mn:00001F70
.text$mn:00001F70 ; =============== S U B R O U T I N E =======================================
.text$mn:00001F70
.text$mn:00001F70 ; Attributes: bp-based frame
.text$mn:00001F70
.text$mn:00001F70 ; void __thiscall WindowsDlg::init(WindowsDlg *this, HINSTANCE, HWND)
.text$mn:00001F70                 public ?init@WindowsDlg@@EAEXPAUHINSTANCE__@@PAUHWND__@@@Z
.text$mn:00001F70 ?init@WindowsDlg@@EAEXPAUHINSTANCE__@@PAUHWND__@@@Z proc near
.text$mn:00001F70                                         ; DATA XREF: .rdata:0000DF14o
.text$mn:00001F70
.text$mn:00001F70 var_4           = dword ptr -4
.text$mn:00001F70 arg_0           = dword ptr  8
.text$mn:00001F70 arg_4           = dword ptr  0Ch
.text$mn:00001F70
.text$mn:00001F70                 push    ebp
.text$mn:00001F71                 mov     ebp, esp
.text$mn:00001F73                 push    ecx
.text$mn:00001F74                 mov     [ebp+var_4], ecx
.text$mn:00001F77                 mov     eax, offset $SG132287 ; "Call other initialize method"
.text$mn:00001F7C                 test    eax, eax
.text$mn:00001F7E                 jz      short loc_1F97
.text$mn:00001F80                 push    0D8h ; '+'      ; Line
.text$mn:00001F85                 push    offset $SG132288 ; "..\\src\\WinControls\\WindowsDlg\\Windo"...
.text$mn:00001F8A                 push    offset $SG132289 ; "!\"Call other initialize method\""
.text$mn:00001F8F                 call    __wassert
.text$mn:00001F94 ; ---------------------------------------------------------------------------
.text$mn:00001F94                 add     esp, 0Ch
.text$mn:00001F97
.text$mn:00001F97 loc_1F97:                               ; CODE XREF: WindowsDlg::init(HINSTANCE__ *,HWND__ *)+Ej
.text$mn:00001F97                 mov     edx, [ebp+arg_4]
.text$mn:00001F9A                 push    edx             ; HWND
.text$mn:00001F9B                 mov     eax, [ebp+arg_0]
.text$mn:00001F9E                 push    eax             ; HINSTANCE
.text$mn:00001F9F                 mov     ecx, [ebp+var_4] ; this
.text$mn:00001FA2                 call    ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z ; Window::init(HINSTANCE__ *,HWND__ *)
.text$mn:00001FA7                 mov     ecx, [ebp+var_4]
.text$mn:00001FAA                 mov     dword ptr [ecx+3Ch], 0
.text$mn:00001FB1                 mov     esp, ebp
.text$mn:00001FB3                 pop     ebp
.text$mn:00001FB4                 retn    8
.text$mn:00001FB4 ?init@WindowsDlg@@EAEXPAUHINSTANCE__@@PAUHWND__@@@Z endp
.text$mn:00001FB4
.text$mn:00001FB4 ; ---------------------------------------------------------------------------
.text$mn:00001FB7                 align 10h
.text$mn:00001FC0
.text$mn:00001FC0 ; =============== S U B R O U T I N E =======================================
.text$mn:00001FC0
.text$mn:00001FC0 ; Attributes: bp-based frame
.text$mn:00001FC0
.text$mn:00001FC0 ; _DWORD __thiscall WindowsMenu::WindowsMenu(WindowsMenu *__hidden this)
.text$mn:00001FC0                 public ??0WindowsMenu@@QAE@XZ
.text$mn:00001FC0 ??0WindowsMenu@@QAE@XZ proc near
.text$mn:00001FC0
.text$mn:00001FC0 var_4           = dword ptr -4
.text$mn:00001FC0
.text$mn:00001FC0                 push    ebp
.text$mn:00001FC1                 mov     ebp, esp
.text$mn:00001FC3                 push    ecx
.text$mn:00001FC4                 mov     [ebp+var_4], ecx
.text$mn:00001FC7                 mov     eax, [ebp+var_4]
.text$mn:00001FCA                 mov     esp, ebp
.text$mn:00001FCC                 pop     ebp
.text$mn:00001FCD                 retn
.text$mn:00001FCD ??0WindowsMenu@@QAE@XZ endp
.text$mn:00001FCD
.text$mn:00001FCD ; ---------------------------------------------------------------------------
.text$mn:00001FCE                 align 10h
.text$mn:00001FD0
.text$mn:00001FD0 ; =============== S U B R O U T I N E =======================================
.text$mn:00001FD0
.text$mn:00001FD0 ; Attributes: bp-based frame
.text$mn:00001FD0
.text$mn:00001FD0 ; _DWORD __thiscall WindowsMenu::~WindowsMenu(WindowsMenu *__hidden this)
.text$mn:00001FD0                 public ??1WindowsMenu@@QAE@XZ
.text$mn:00001FD0 ??1WindowsMenu@@QAE@XZ proc near
.text$mn:00001FD0
.text$mn:00001FD0 var_4           = dword ptr -4
.text$mn:00001FD0
.text$mn:00001FD0                 push    ebp
.text$mn:00001FD1                 mov     ebp, esp
.text$mn:00001FD3                 push    ecx
.text$mn:00001FD4                 mov     [ebp+var_4], ecx
.text$mn:00001FD7                 mov     eax, [ebp+var_4]
.text$mn:00001FDA                 cmp     dword ptr [eax], 0
.text$mn:00001FDD                 jz      short loc_1FEB
.text$mn:00001FDF                 mov     ecx, [ebp+var_4]
.text$mn:00001FE2                 mov     edx, [ecx]
.text$mn:00001FE4                 push    edx             ; hMenu
.text$mn:00001FE5                 call    dword ptr ds:__imp__DestroyMenu@4 ; DestroyMenu(x)
.text$mn:00001FEB
.text$mn:00001FEB loc_1FEB:                               ; CODE XREF: WindowsMenu::~WindowsMenu(void)+Dj
.text$mn:00001FEB                 mov     esp, ebp
.text$mn:00001FED                 pop     ebp
.text$mn:00001FEE                 retn
.text$mn:00001FEE ??1WindowsMenu@@QAE@XZ endp
.text$mn:00001FEE
.text$mn:00001FEE ; ---------------------------------------------------------------------------
.text$mn:00001FEF                 align 10h
.text$mn:00001FF0
.text$mn:00001FF0 ; =============== S U B R O U T I N E =======================================
.text$mn:00001FF0
.text$mn:00001FF0 ; Attributes: bp-based frame
.text$mn:00001FF0
.text$mn:00001FF0 ; void __thiscall WindowsMenu::init(WindowsMenu *this, HINSTANCE hInstance, HMENU hMenu, const wchar_t *)
.text$mn:00001FF0                 public ?init@WindowsMenu@@QAEXPAUHINSTANCE__@@PAUHMENU__@@PB_W@Z
.text$mn:00001FF0 ?init@WindowsMenu@@QAEXPAUHINSTANCE__@@PAUHMENU__@@PB_W@Z proc near
.text$mn:00001FF0
.text$mn:00001FF0 Dst             = dword ptr -0A8h
.text$mn:00001FF0 var_A4          = dword ptr -0A4h
.text$mn:00001FF0 var_94          = dword ptr -94h
.text$mn:00001FF0 var_84          = dword ptr -84h
.text$mn:00001FF0 var_78          = dword ptr -78h
.text$mn:00001FF0 var_74          = dword ptr -74h
.text$mn:00001FF0 uId             = dword ptr -70h
.text$mn:00001FF0 var_6C          = byte ptr -6Ch
.text$mn:00001FF0 Buffer          = word ptr -50h
.text$mn:00001FF0 var_10          = dword ptr -10h
.text$mn:00001FF0 var_C           = dword ptr -0Ch
.text$mn:00001FF0 var_4           = dword ptr -4
.text$mn:00001FF0 hInstance       = dword ptr  8
.text$mn:00001FF0 hMenu           = dword ptr  0Ch
.text$mn:00001FF0 Str             = dword ptr  10h
.text$mn:00001FF0
.text$mn:00001FF0                 push    ebp
.text$mn:00001FF1                 mov     ebp, esp
.text$mn:00001FF3                 push    0FFFFFFFFh
.text$mn:00001FF5                 push    offset __ehhandler$?init@WindowsMenu@@QAEXPAUHINSTANCE__@@PAUHMENU__@@PB_W@Z
.text$mn:00001FFA                 mov     eax, large fs:0
.text$mn:00002000                 push    eax
.text$mn:00002001                 sub     esp, 9Ch
.text$mn:00002007                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000200C                 xor     eax, ebp
.text$mn:0000200E                 mov     [ebp+var_10], eax
.text$mn:00002011                 push    eax
.text$mn:00002012                 lea     eax, [ebp+var_C]
.text$mn:00002015                 mov     large fs:0, eax
.text$mn:0000201B                 mov     [ebp+var_74], ecx
.text$mn:0000201E                 push    offset MenuName ; lpMenuName
.text$mn:00002023                 mov     eax, [ebp+hInstance]
.text$mn:00002026                 push    eax             ; hInstance
.text$mn:00002027                 call    dword ptr ds:__imp__LoadMenuW@8 ; LoadMenuW(x,x)
.text$mn:0000202D                 mov     ecx, [ebp+var_74]
.text$mn:00002030                 mov     [ecx], eax
.text$mn:00002032                 cmp     [ebp+Str], 0
.text$mn:00002036                 jz      short loc_209B
.text$mn:00002038                 mov     edx, 2
.text$mn:0000203D                 imul    eax, edx, 0
.text$mn:00002040                 mov     ecx, [ebp+Str]
.text$mn:00002043                 movzx   edx, word ptr [ecx+eax]
.text$mn:00002047                 test    edx, edx
.text$mn:00002049                 jz      short loc_209B
.text$mn:0000204B                 mov     eax, [ebp+Str]
.text$mn:0000204E                 push    eax             ; Str
.text$mn:0000204F                 lea     ecx, [ebp+var_6C]
.text$mn:00002052                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:00002057                 mov     [ebp+var_4], 0
.text$mn:0000205E                 push    offset $SG133098 ; "..."
.text$mn:00002063                 lea     ecx, [ebp+var_6C]
.text$mn:00002066                 call    ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator+=(wchar_t const *)
.text$mn:0000206B                 lea     ecx, [ebp+var_6C]
.text$mn:0000206E                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:00002073                 push    eax             ; lpNewItem
.text$mn:00002074                 push    2AF9h           ; uIDNewItem
.text$mn:00002079                 push    0               ; uFlags
.text$mn:0000207B                 push    2AF9h           ; uPosition
.text$mn:00002080                 mov     ecx, [ebp+var_74]
.text$mn:00002083                 mov     edx, [ecx]
.text$mn:00002085                 push    edx             ; hMnu
.text$mn:00002086                 call    dword ptr ds:__imp__ModifyMenuW@20 ; ModifyMenuW(x,x,x,x,x)
.text$mn:0000208C                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002093                 lea     ecx, [ebp+var_6C]
.text$mn:00002096                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:0000209B
.text$mn:0000209B loc_209B:                               ; CODE XREF: WindowsMenu::init(HINSTANCE__ *,HMENU__ *,wchar_t const *)+46j
.text$mn:0000209B                                         ; WindowsMenu::init(HINSTANCE__ *,HMENU__ *,wchar_t const *)+59j
.text$mn:0000209B                 mov     [ebp+uId], 0
.text$mn:000020A2                 mov     eax, [ebp+hMenu]
.text$mn:000020A5                 push    eax             ; hMenu
.text$mn:000020A6                 call    dword ptr ds:__imp__GetMenuItemCount@4 ; GetMenuItemCount(x)
.text$mn:000020AC                 sub     eax, 1
.text$mn:000020AF                 mov     [ebp+uId], eax
.text$mn:000020B2                 jmp     short loc_20BD
.text$mn:000020B4 ; ---------------------------------------------------------------------------
.text$mn:000020B4
.text$mn:000020B4 loc_20B4:                               ; CODE XREF: WindowsMenu::init(HINSTANCE__ *,HMENU__ *,wchar_t const *)+EBj
.text$mn:000020B4                                         ; WindowsMenu::init(HINSTANCE__ *,HMENU__ *,wchar_t const *)+EFj
.text$mn:000020B4                 mov     ecx, [ebp+uId]
.text$mn:000020B7                 sub     ecx, 1
.text$mn:000020BA                 mov     [ebp+uId], ecx
.text$mn:000020BD
.text$mn:000020BD loc_20BD:                               ; CODE XREF: WindowsMenu::init(HINSTANCE__ *,HMENU__ *,wchar_t const *)+C2j
.text$mn:000020BD                 cmp     [ebp+uId], 0
.text$mn:000020C1                 jbe     short loc_20E1
.text$mn:000020C3                 push    400h            ; uFlags
.text$mn:000020C8                 mov     edx, [ebp+uId]
.text$mn:000020CB                 push    edx             ; uId
.text$mn:000020CC                 mov     eax, [ebp+hMenu]
.text$mn:000020CF                 push    eax             ; hMenu
.text$mn:000020D0                 call    dword ptr ds:__imp__GetMenuState@12 ; GetMenuState(x,x,x)
.text$mn:000020D6                 and     eax, 10h
.text$mn:000020D9                 jnz     short loc_20DD
.text$mn:000020DB                 jmp     short loc_20B4
.text$mn:000020DD ; ---------------------------------------------------------------------------
.text$mn:000020DD
.text$mn:000020DD loc_20DD:                               ; CODE XREF: WindowsMenu::init(HINSTANCE__ *,HMENU__ *,wchar_t const *)+E9j
.text$mn:000020DD                 jmp     short loc_20E1
.text$mn:000020DF ; ---------------------------------------------------------------------------
.text$mn:000020DF                 jmp     short loc_20B4
.text$mn:000020E1 ; ---------------------------------------------------------------------------
.text$mn:000020E1
.text$mn:000020E1 loc_20E1:                               ; CODE XREF: WindowsMenu::init(HINSTANCE__ *,HMENU__ *,wchar_t const *)+D1j
.text$mn:000020E1                                         ; WindowsMenu::init(HINSTANCE__ *,HMENU__ *,wchar_t const *):loc_20DDj
.text$mn:000020E1                 push    30h ; '0'       ; Size
.text$mn:000020E3                 push    0               ; Val
.text$mn:000020E5                 lea     ecx, [ebp+Dst]
.text$mn:000020EB                 push    ecx             ; Dst
.text$mn:000020EC                 call    _memset
.text$mn:000020F1                 add     esp, 0Ch
.text$mn:000020F4                 mov     [ebp+Dst], 30h ; '0'
.text$mn:000020FE                 mov     [ebp+var_A4], 44h ; 'D'
.text$mn:00002108                 push    20h ; ' '       ; cchBufferMax
.text$mn:0000210A                 lea     edx, [ebp+Buffer]
.text$mn:0000210D                 push    edx             ; lpBuffer
.text$mn:0000210E                 push    2AF8h           ; uID
.text$mn:00002113                 mov     eax, [ebp+hInstance]
.text$mn:00002116                 push    eax             ; hInstance
.text$mn:00002117                 call    dword ptr ds:__imp__LoadStringW@16 ; LoadStringW(x,x,x,x)
.text$mn:0000211D                 cmp     [ebp+Str], 0
.text$mn:00002121                 jz      short loc_213E
.text$mn:00002123                 mov     ecx, 2
.text$mn:00002128                 imul    edx, ecx, 0
.text$mn:0000212B                 mov     eax, [ebp+Str]
.text$mn:0000212E                 movzx   ecx, word ptr [eax+edx]
.text$mn:00002132                 test    ecx, ecx
.text$mn:00002134                 jz      short loc_213E
.text$mn:00002136                 mov     edx, [ebp+Str]
.text$mn:00002139                 mov     [ebp+var_78], edx
.text$mn:0000213C                 jmp     short loc_2144
.text$mn:0000213E ; ---------------------------------------------------------------------------
.text$mn:0000213E
.text$mn:0000213E loc_213E:                               ; CODE XREF: WindowsMenu::init(HINSTANCE__ *,HMENU__ *,wchar_t const *)+131j
.text$mn:0000213E                                         ; WindowsMenu::init(HINSTANCE__ *,HMENU__ *,wchar_t const *)+144j
.text$mn:0000213E                 lea     eax, [ebp+Buffer]
.text$mn:00002141                 mov     [ebp+var_78], eax
.text$mn:00002144
.text$mn:00002144 loc_2144:                               ; CODE XREF: WindowsMenu::init(HINSTANCE__ *,HMENU__ *,wchar_t const *)+14Cj
.text$mn:00002144                 mov     ecx, [ebp+var_78]
.text$mn:00002147                 mov     [ebp+var_84], ecx
.text$mn:0000214D                 mov     edx, [ebp+var_74]
.text$mn:00002150                 mov     eax, [edx]
.text$mn:00002152                 mov     [ebp+var_94], eax
.text$mn:00002158                 lea     ecx, [ebp+Dst]
.text$mn:0000215E                 push    ecx             ; lpmi
.text$mn:0000215F                 push    1               ; fByPosition
.text$mn:00002161                 mov     edx, [ebp+uId]
.text$mn:00002164                 push    edx             ; item
.text$mn:00002165                 mov     eax, [ebp+hMenu]
.text$mn:00002168                 push    eax             ; hmenu
.text$mn:00002169                 call    dword ptr ds:__imp__InsertMenuItemW@16 ; InsertMenuItemW(x,x,x,x)
.text$mn:0000216F                 mov     ecx, [ebp+var_C]
.text$mn:00002172                 mov     large fs:0, ecx
.text$mn:00002179                 pop     ecx
.text$mn:0000217A                 mov     ecx, [ebp+var_10]
.text$mn:0000217D                 xor     ecx, ebp
.text$mn:0000217F                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00002184                 mov     esp, ebp
.text$mn:00002186                 pop     ebp
.text$mn:00002187                 retn    0Ch
.text$mn:00002187 ?init@WindowsMenu@@QAEXPAUHINSTANCE__@@PAUHMENU__@@PB_W@Z endp
.text$mn:00002187
.text$mn:00002187 ; ---------------------------------------------------------------------------
.text$mn:0000218A                 align 10h
.text$mn:00002190
.text$mn:00002190 ; =============== S U B R O U T I N E =======================================
.text$mn:00002190
.text$mn:00002190 ; Attributes: bp-based frame
.text$mn:00002190
.text$mn:00002190 ; void __thiscall WindowsMenu::initPopupMenu(WindowsMenu *this, HMENU hMenu, struct DocTabView *)
.text$mn:00002190                 public ?initPopupMenu@WindowsMenu@@QAEXPAUHMENU__@@PAVDocTabView@@@Z
.text$mn:00002190 ?initPopupMenu@WindowsMenu@@QAEXPAUHMENU__@@PAVDocTabView@@@Z proc near
.text$mn:00002190
.text$mn:00002190 Dst             = dword ptr -0D0h
.text$mn:00002190 var_CC          = dword ptr -0CCh
.text$mn:00002190 var_C4          = dword ptr -0C4h
.text$mn:00002190 var_C0          = dword ptr -0C0h
.text$mn:00002190 var_AC          = dword ptr -0ACh
.text$mn:00002190 var_A0          = dword ptr -0A0h
.text$mn:00002190 var_9C          = dword ptr -9Ch
.text$mn:00002190 var_98          = dword ptr -98h
.text$mn:00002190 var_94          = dword ptr -94h
.text$mn:00002190 var_90          = byte ptr -90h
.text$mn:00002190 var_80          = dword ptr -80h
.text$mn:00002190 var_7C          = dword ptr -7Ch
.text$mn:00002190 var_78          = dword ptr -78h
.text$mn:00002190 var_74          = dword ptr -74h
.text$mn:00002190 var_70          = dword ptr -70h
.text$mn:00002190 var_6C          = dword ptr -6Ch
.text$mn:00002190 var_68          = dword ptr -68h
.text$mn:00002190 var_64          = dword ptr -64h
.text$mn:00002190 var_60          = dword ptr -60h
.text$mn:00002190 var_5C          = dword ptr -5Ch
.text$mn:00002190 var_56          = word ptr -56h
.text$mn:00002190 var_54          = dword ptr -54h
.text$mn:00002190 var_50          = dword ptr -50h
.text$mn:00002190 uId             = dword ptr -4Ch
.text$mn:00002190 var_48          = byte ptr -48h
.text$mn:00002190 var_2C          = byte ptr -2Ch
.text$mn:00002190 var_10          = dword ptr -10h
.text$mn:00002190 var_C           = dword ptr -0Ch
.text$mn:00002190 var_4           = dword ptr -4
.text$mn:00002190 hMenu           = dword ptr  8
.text$mn:00002190 arg_4           = dword ptr  0Ch
.text$mn:00002190
.text$mn:00002190                 push    ebp
.text$mn:00002191                 mov     ebp, esp
.text$mn:00002193                 push    0FFFFFFFFh
.text$mn:00002195                 push    offset __ehhandler$?initPopupMenu@WindowsMenu@@QAEXPAUHMENU__@@PAVDocTabView@@@Z
.text$mn:0000219A                 mov     eax, large fs:0
.text$mn:000021A0                 push    eax
.text$mn:000021A1                 sub     esp, 0C4h
.text$mn:000021A7                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000021AC                 xor     eax, ebp
.text$mn:000021AE                 mov     [ebp+var_10], eax
.text$mn:000021B1                 push    eax
.text$mn:000021B2                 lea     eax, [ebp+var_C]
.text$mn:000021B5                 mov     large fs:0, eax
.text$mn:000021BB                 mov     [ebp+var_70], ecx
.text$mn:000021BE                 mov     eax, [ebp+var_70]
.text$mn:000021C1                 mov     ecx, [ebp+hMenu]
.text$mn:000021C4                 cmp     ecx, [eax]
.text$mn:000021C6                 jnz     loc_2404
.text$mn:000021CC                 mov     ecx, [ebp+arg_4] ; this
.text$mn:000021CF                 call    ?getCurrentTabIndex@TabBar@@QBEHXZ ; TabBar::getCurrentTabIndex(void)
.text$mn:000021D4                 mov     [ebp+var_68], eax
.text$mn:000021D7                 mov     [ebp+var_60], 0Ah
.text$mn:000021DE                 mov     ecx, [ebp+arg_4] ; this
.text$mn:000021E1                 call    ?nbItem@TabBar@@QBEHXZ ; TabBar::nbItem(void)
.text$mn:000021E6                 mov     [ebp+var_54], eax
.text$mn:000021E9                 mov     edx, [ebp+var_54]
.text$mn:000021EC                 cmp     edx, [ebp+var_60]
.text$mn:000021EF                 jge     short loc_21F9
.text$mn:000021F1                 mov     eax, [ebp+var_54]
.text$mn:000021F4                 mov     [ebp+var_5C], eax
.text$mn:000021F7                 jmp     short loc_21FF
.text$mn:000021F9 ; ---------------------------------------------------------------------------
.text$mn:000021F9
.text$mn:000021F9 loc_21F9:                               ; CODE XREF: WindowsMenu::initPopupMenu(HMENU__ *,DocTabView *)+5Fj
.text$mn:000021F9                 mov     ecx, [ebp+var_60]
.text$mn:000021FC                 mov     [ebp+var_5C], ecx
.text$mn:000021FF
.text$mn:000021FF loc_21FF:                               ; CODE XREF: WindowsMenu::initPopupMenu(HMENU__ *,DocTabView *)+67j
.text$mn:000021FF                 mov     edx, [ebp+var_5C]
.text$mn:00002202                 mov     [ebp+var_54], edx
.text$mn:00002205                 mov     [ebp+uId], 2B0Ch
.text$mn:0000220C                 mov     [ebp+var_50], 0
.text$mn:00002213                 jmp     short loc_2227
.text$mn:00002215 ; ---------------------------------------------------------------------------
.text$mn:00002215
.text$mn:00002215 loc_2215:                               ; CODE XREF: WindowsMenu::initPopupMenu(HMENU__ *,DocTabView *)+249j
.text$mn:00002215                 mov     eax, [ebp+uId]
.text$mn:00002218                 add     eax, 1
.text$mn:0000221B                 mov     [ebp+uId], eax
.text$mn:0000221E                 mov     ecx, [ebp+var_50]
.text$mn:00002221                 add     ecx, 1
.text$mn:00002224                 mov     [ebp+var_50], ecx
.text$mn:00002227
.text$mn:00002227 loc_2227:                               ; CODE XREF: WindowsMenu::initPopupMenu(HMENU__ *,DocTabView *)+83j
.text$mn:00002227                 mov     edx, [ebp+var_54]
.text$mn:0000222A                 add     edx, 2B0Ch
.text$mn:00002230                 cmp     [ebp+uId], edx
.text$mn:00002233                 jge     loc_23DE
.text$mn:00002239                 mov     eax, [ebp+var_50]
.text$mn:0000223C                 push    eax             ; int
.text$mn:0000223D                 mov     ecx, [ebp+arg_4] ; this
.text$mn:00002240                 call    ?getBufferByIndex@DocTabView@@QAEPAVBuffer@@H@Z ; DocTabView::getBufferByIndex(int)
.text$mn:00002245                 mov     [ebp+var_7C], eax
.text$mn:00002248                 mov     ecx, [ebp+var_7C]
.text$mn:0000224B                 push    ecx             ; struct Buffer *
.text$mn:0000224C                 call    ?getInstance@FileManager@@SAPAV1@XZ ; FileManager::getInstance(void)
.text$mn:00002251                 mov     ecx, eax        ; this
.text$mn:00002253                 call    ?getBufferByID@FileManager@@QAEPAVBuffer@@PAV2@@Z ; FileManager::getBufferByID(Buffer *)
.text$mn:00002258                 mov     [ebp+var_78], eax
.text$mn:0000225B                 push    30h ; '0'       ; Size
.text$mn:0000225D                 push    0               ; Val
.text$mn:0000225F                 lea     edx, [ebp+Dst]
.text$mn:00002265                 push    edx             ; Dst
.text$mn:00002266                 call    _memset
.text$mn:0000226B                 add     esp, 0Ch
.text$mn:0000226E                 mov     [ebp+Dst], 30h ; '0'
.text$mn:00002278                 mov     [ebp+var_CC], 43h ; 'C'
.text$mn:00002282                 mov     ecx, [ebp+var_78] ; this
.text$mn:00002285                 call    ?getFileName@Buffer@@QBEPB_WXZ ; Buffer::getFileName(void)
.text$mn:0000228A                 push    eax             ; Str
.text$mn:0000228B                 lea     ecx, [ebp+var_48]
.text$mn:0000228E                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:00002293                 mov     [ebp+var_4], 0
.text$mn:0000229A                 lea     eax, [ebp+var_48]
.text$mn:0000229D                 push    eax
.text$mn:0000229E                 mov     ecx, [ebp+var_50]
.text$mn:000022A1                 push    ecx
.text$mn:000022A2                 push    3Ch ; '<'
.text$mn:000022A4                 lea     edx, [ebp+var_2C]
.text$mn:000022A7                 push    edx
.text$mn:000022A8                 call    ?BuildMenuFileName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HIABV12@@Z ; BuildMenuFileName(int,uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:000022AD                 add     esp, 10h
.text$mn:000022B0                 mov     byte ptr [ebp+var_4], 2
.text$mn:000022B4                 lea     ecx, [ebp+var_48]
.text$mn:000022B7                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:000022BC                 sub     esp, 0Ch
.text$mn:000022BF                 mov     eax, esp
.text$mn:000022C1                 mov     [ebp+var_9C], esp
.text$mn:000022C7                 push    eax
.text$mn:000022C8                 lea     ecx, [ebp+var_2C]
.text$mn:000022CB                 call    ?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::end(void)
.text$mn:000022D0                 mov     [ebp+var_74], eax
.text$mn:000022D3                 mov     ecx, [ebp+var_74]
.text$mn:000022D6                 mov     [ebp+var_94], ecx
.text$mn:000022DC                 mov     byte ptr [ebp+var_4], 3
.text$mn:000022E0                 sub     esp, 0Ch
.text$mn:000022E3                 mov     edx, esp
.text$mn:000022E5                 mov     [ebp+var_80], esp
.text$mn:000022E8                 push    edx
.text$mn:000022E9                 lea     ecx, [ebp+var_2C]
.text$mn:000022EC                 call    ?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::begin(void)
.text$mn:000022F1                 mov     [ebp+var_64], eax
.text$mn:000022F4                 mov     eax, [ebp+var_64]
.text$mn:000022F7                 mov     [ebp+var_A0], eax
.text$mn:000022FD                 mov     byte ptr [ebp+var_4], 4
.text$mn:00002301                 mov     byte ptr [ebp+var_4], 2
.text$mn:00002305                 lea     ecx, [ebp+var_90]
.text$mn:0000230B                 call    ??$?0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@X@?$vector@_WV?$allocator@_W@std@@@std@@QAE@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z ; std::vector<wchar_t,std::allocator<wchar_t>>::vector<wchar_t,std::allocator<wchar_t>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)
.text$mn:00002310                 mov     [ebp+var_98], eax
.text$mn:00002316                 mov     byte ptr [ebp+var_4], 5
.text$mn:0000231A                 xor     ecx, ecx
.text$mn:0000231C                 mov     [ebp+var_56], cx
.text$mn:00002320                 lea     edx, [ebp+var_56]
.text$mn:00002323                 push    edx
.text$mn:00002324                 lea     ecx, [ebp+var_90]
.text$mn:0000232A                 call    ?push_back@?$vector@_WV?$allocator@_W@std@@@std@@QAEX$$QA_W@Z ; std::vector<wchar_t,std::allocator<wchar_t>>::push_back(wchar_t &&)
.text$mn:0000232F                 push    0
.text$mn:00002331                 lea     ecx, [ebp+var_90]
.text$mn:00002337                 call    ??A?$vector@_WV?$allocator@_W@std@@@std@@QAEAA_WI@Z ; std::vector<wchar_t,std::allocator<wchar_t>>::operator[](uint)
.text$mn:0000233C                 mov     [ebp+var_AC], eax
.text$mn:00002342                 mov     eax, [ebp+var_C4]
.text$mn:00002348                 and     eax, 0FFFFFFF4h
.text$mn:0000234B                 mov     [ebp+var_C4], eax
.text$mn:00002351                 mov     ecx, [ebp+var_50]
.text$mn:00002354                 cmp     ecx, [ebp+var_68]
.text$mn:00002357                 jnz     short loc_2368
.text$mn:00002359                 mov     edx, [ebp+var_C4]
.text$mn:0000235F                 or      edx, 8
.text$mn:00002362                 mov     [ebp+var_C4], edx
.text$mn:00002368
.text$mn:00002368 loc_2368:                               ; CODE XREF: WindowsMenu::initPopupMenu(HMENU__ *,DocTabView *)+1C7j
.text$mn:00002368                 mov     eax, [ebp+uId]
.text$mn:0000236B                 mov     [ebp+var_C0], eax
.text$mn:00002371                 push    0               ; uFlags
.text$mn:00002373                 mov     ecx, [ebp+uId]
.text$mn:00002376                 push    ecx             ; uId
.text$mn:00002377                 mov     edx, [ebp+hMenu]
.text$mn:0000237A                 push    edx             ; hMenu
.text$mn:0000237B                 call    dword ptr ds:__imp__GetMenuState@12 ; GetMenuState(x,x,x)
.text$mn:00002381                 mov     [ebp+var_6C], eax
.text$mn:00002384                 cmp     [ebp+var_6C], 0FFFFFFFFh
.text$mn:00002388                 jnz     short loc_23A4
.text$mn:0000238A                 lea     eax, [ebp+Dst]
.text$mn:00002390                 push    eax             ; lpmi
.text$mn:00002391                 push    0               ; fByPosition
.text$mn:00002393                 push    2AF9h           ; item
.text$mn:00002398                 mov     ecx, [ebp+hMenu]
.text$mn:0000239B                 push    ecx             ; hmenu
.text$mn:0000239C                 call    dword ptr ds:__imp__InsertMenuItemW@16 ; InsertMenuItemW(x,x,x,x)
.text$mn:000023A2                 jmp     short loc_23BB
.text$mn:000023A4 ; ---------------------------------------------------------------------------
.text$mn:000023A4
.text$mn:000023A4 loc_23A4:                               ; CODE XREF: WindowsMenu::initPopupMenu(HMENU__ *,DocTabView *)+1F8j
.text$mn:000023A4                 lea     edx, [ebp+Dst]
.text$mn:000023AA                 push    edx             ; lpmii
.text$mn:000023AB                 push    0               ; fByPositon
.text$mn:000023AD                 mov     eax, [ebp+uId]
.text$mn:000023B0                 push    eax             ; item
.text$mn:000023B1                 mov     ecx, [ebp+hMenu]
.text$mn:000023B4                 push    ecx             ; hmenu
.text$mn:000023B5                 call    dword ptr ds:__imp__SetMenuItemInfoW@16 ; SetMenuItemInfoW(x,x,x,x)
.text$mn:000023BB
.text$mn:000023BB loc_23BB:                               ; CODE XREF: WindowsMenu::initPopupMenu(HMENU__ *,DocTabView *)+212j
.text$mn:000023BB                 mov     byte ptr [ebp+var_4], 2
.text$mn:000023BF                 lea     ecx, [ebp+var_90]
.text$mn:000023C5                 call    ??1?$vector@_WV?$allocator@_W@std@@@std@@QAE@XZ ; std::vector<wchar_t,std::allocator<wchar_t>>::~vector<wchar_t,std::allocator<wchar_t>>(void)
.text$mn:000023CA                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000023D1                 lea     ecx, [ebp+var_2C]
.text$mn:000023D4                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:000023D9                 jmp     loc_2215
.text$mn:000023DE ; ---------------------------------------------------------------------------
.text$mn:000023DE
.text$mn:000023DE loc_23DE:                               ; CODE XREF: WindowsMenu::initPopupMenu(HMENU__ *,DocTabView *)+A3j
.text$mn:000023DE                 jmp     short loc_23E9
.text$mn:000023E0 ; ---------------------------------------------------------------------------
.text$mn:000023E0
.text$mn:000023E0 loc_23E0:                               ; CODE XREF: WindowsMenu::initPopupMenu(HMENU__ *,DocTabView *)+272j
.text$mn:000023E0                 mov     edx, [ebp+uId]
.text$mn:000023E3                 add     edx, 1
.text$mn:000023E6                 mov     [ebp+uId], edx
.text$mn:000023E9
.text$mn:000023E9 loc_23E9:                               ; CODE XREF: WindowsMenu::initPopupMenu(HMENU__ *,DocTabView *):loc_23DEj
.text$mn:000023E9                 cmp     [ebp+uId], 2B15h
.text$mn:000023F0                 jg      short loc_2404
.text$mn:000023F2                 push    0               ; uFlags
.text$mn:000023F4                 mov     eax, [ebp+uId]
.text$mn:000023F7                 push    eax             ; uPosition
.text$mn:000023F8                 mov     ecx, [ebp+hMenu]
.text$mn:000023FB                 push    ecx             ; hMenu
.text$mn:000023FC                 call    dword ptr ds:__imp__DeleteMenu@12 ; DeleteMenu(x,x,x)
.text$mn:00002402                 jmp     short loc_23E0
.text$mn:00002404 ; ---------------------------------------------------------------------------
.text$mn:00002404
.text$mn:00002404 loc_2404:                               ; CODE XREF: WindowsMenu::initPopupMenu(HMENU__ *,DocTabView *)+36j
.text$mn:00002404                                         ; WindowsMenu::initPopupMenu(HMENU__ *,DocTabView *)+260j
.text$mn:00002404                 mov     ecx, [ebp+var_C]
.text$mn:00002407                 mov     large fs:0, ecx
.text$mn:0000240E                 pop     ecx
.text$mn:0000240F                 mov     ecx, [ebp+var_10]
.text$mn:00002412                 xor     ecx, ebp
.text$mn:00002414                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00002419                 mov     esp, ebp
.text$mn:0000241B                 pop     ebp
.text$mn:0000241C                 retn    8
.text$mn:0000241C ?initPopupMenu@WindowsMenu@@QAEXPAUHMENU__@@PAVDocTabView@@@Z endp
.text$mn:0000241C
.text$mn:0000241C ; ---------------------------------------------------------------------------
.text$mn:0000241F                 align 10h
.text$mn:0000241F _text$mn        ends
.text$mn:0000241F
.text$x:00002420 ; ===========================================================================
.text$x:00002420
.text$x:00002420 ; Segment type: Pure code
.text$x:00002420 ; Segment permissions: Read/Execute
.text$x:00002420 _text$x         segment para public 'CODE' use32
.text$x:00002420                 assume cs:_text$x
.text$x:00002420                 ;org 2420h
.text$x:00002420                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00002420
.text$x:00002420 ; =============== S U B R O U T I N E =======================================
.text$x:00002420
.text$x:00002420
.text$x:00002420 __unwindfunclet$??0WindowsDlg@@QAE@XZ$0 proc near
.text$x:00002420                                         ; DATA XREF: .xdata$x:0000CB7Co
.text$x:00002420                 mov     ecx, [ebp-10h]  ; this
.text$x:00002423                 jmp     ??1SizeableDlg@@UAE@XZ ; SizeableDlg::~SizeableDlg(void)
.text$x:00002423 __unwindfunclet$??0WindowsDlg@@QAE@XZ$0 endp
.text$x:00002423
.text$x:00002428
.text$x:00002428 ; =============== S U B R O U T I N E =======================================
.text$x:00002428
.text$x:00002428
.text$x:00002428 __unwindfunclet$??0WindowsDlg@@QAE@XZ$1 proc near
.text$x:00002428                                         ; DATA XREF: .xdata$x:0000CB84o
.text$x:00002428                 mov     ecx, [ebp-10h]
.text$x:0000242B                 add     ecx, 40h ; '@'
.text$x:0000242E                 jmp     ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int>>::~vector<int,std::allocator<int>>(void)
.text$x:0000242E __unwindfunclet$??0WindowsDlg@@QAE@XZ$1 endp
.text$x:0000242E
.text$x:00002433
.text$x:00002433 ; =============== S U B R O U T I N E =======================================
.text$x:00002433
.text$x:00002433
.text$x:00002433 __ehhandler$??0WindowsDlg@@QAE@XZ proc near
.text$x:00002433                                         ; DATA XREF: WindowsDlg::WindowsDlg(void)+5o
.text$x:00002433
.text$x:00002433 arg_4           = dword ptr  8
.text$x:00002433
.text$x:00002433                 mov     edx, [esp+arg_4]
.text$x:00002437                 lea     eax, [edx+0Ch]
.text$x:0000243A                 mov     ecx, [edx-8]
.text$x:0000243D                 xor     ecx, eax
.text$x:0000243F                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002444                 mov     eax, offset __ehfuncinfo$??0WindowsDlg@@QAE@XZ
.text$x:00002449                 jmp     ___CxxFrameHandler3
.text$x:00002449 __ehhandler$??0WindowsDlg@@QAE@XZ endp
.text$x:00002449
.text$x:0000244E
.text$x:0000244E ; =============== S U B R O U T I N E =======================================
.text$x:0000244E
.text$x:0000244E
.text$x:0000244E __unwindfunclet$?run_dlgProc@WindowsDlg@@MAGHIIJ@Z$0 proc near
.text$x:0000244E                                         ; DATA XREF: .xdata$x:0000CB8Co
.text$x:0000244E                 lea     ecx, [ebp-90h]
.text$x:00002454                 jmp     ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int>>::~vector<int,std::allocator<int>>(void)
.text$x:00002454 __unwindfunclet$?run_dlgProc@WindowsDlg@@MAGHIIJ@Z$0 endp
.text$x:00002454
.text$x:00002459
.text$x:00002459 ; =============== S U B R O U T I N E =======================================
.text$x:00002459
.text$x:00002459
.text$x:00002459 __unwindfunclet$?run_dlgProc@WindowsDlg@@MAGHIIJ@Z$1 proc near
.text$x:00002459                                         ; DATA XREF: .xdata$x:0000CB94o
.text$x:00002459                 mov     ecx, [ebp-94h]
.text$x:0000245F                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$x:0000245F __unwindfunclet$?run_dlgProc@WindowsDlg@@MAGHIIJ@Z$1 endp
.text$x:0000245F
.text$x:00002464
.text$x:00002464 ; =============== S U B R O U T I N E =======================================
.text$x:00002464
.text$x:00002464
.text$x:00002464 __unwindfunclet$?run_dlgProc@WindowsDlg@@MAGHIIJ@Z$2 proc near
.text$x:00002464                                         ; DATA XREF: .xdata$x:0000CB9Co
.text$x:00002464                 mov     ecx, [ebp-0A0h]
.text$x:0000246A                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$x:0000246A __unwindfunclet$?run_dlgProc@WindowsDlg@@MAGHIIJ@Z$2 endp
.text$x:0000246A
.text$x:0000246F
.text$x:0000246F ; =============== S U B R O U T I N E =======================================
.text$x:0000246F
.text$x:0000246F
.text$x:0000246F __ehhandler$?run_dlgProc@WindowsDlg@@MAGHIIJ@Z proc near
.text$x:0000246F                                         ; DATA XREF: WindowsDlg::run_dlgProc(uint,uint,long)+5o
.text$x:0000246F
.text$x:0000246F arg_4           = dword ptr  8
.text$x:0000246F
.text$x:0000246F                 mov     edx, [esp+arg_4]
.text$x:00002473                 lea     eax, [edx+0Ch]
.text$x:00002476                 mov     ecx, [edx-114h]
.text$x:0000247C                 xor     ecx, eax
.text$x:0000247E                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002483                 mov     eax, offset __ehfuncinfo$?run_dlgProc@WindowsDlg@@MAGHIIJ@Z
.text$x:00002488                 jmp     ___CxxFrameHandler3
.text$x:00002488 __ehhandler$?run_dlgProc@WindowsDlg@@MAGHIIJ@Z endp
.text$x:00002488
.text$x:0000248D
.text$x:0000248D ; =============== S U B R O U T I N E =======================================
.text$x:0000248D
.text$x:0000248D
.text$x:0000248D __unwindfunclet$?resetSelection@WindowsDlg@@IAEXXZ$0 proc near
.text$x:0000248D                                         ; DATA XREF: .xdata$x:0000CB6Co
.text$x:0000248D                 lea     ecx, [ebp-24h]
.text$x:00002490                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$x:00002490 __unwindfunclet$?resetSelection@WindowsDlg@@IAEXXZ$0 endp
.text$x:00002490
.text$x:00002495
.text$x:00002495 ; =============== S U B R O U T I N E =======================================
.text$x:00002495
.text$x:00002495
.text$x:00002495 __unwindfunclet$?resetSelection@WindowsDlg@@IAEXXZ$1 proc near
.text$x:00002495                                         ; DATA XREF: .xdata$x:0000CB74o
.text$x:00002495                 lea     ecx, [ebp-30h]
.text$x:00002498                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$x:00002498 __unwindfunclet$?resetSelection@WindowsDlg@@IAEXXZ$1 endp
.text$x:00002498
.text$x:0000249D
.text$x:0000249D ; =============== S U B R O U T I N E =======================================
.text$x:0000249D
.text$x:0000249D
.text$x:0000249D __ehhandler$?resetSelection@WindowsDlg@@IAEXXZ proc near
.text$x:0000249D                                         ; DATA XREF: WindowsDlg::resetSelection(void)+5o
.text$x:0000249D
.text$x:0000249D arg_4           = dword ptr  8
.text$x:0000249D
.text$x:0000249D                 mov     edx, [esp+arg_4]
.text$x:000024A1                 lea     eax, [edx+0Ch]
.text$x:000024A4                 mov     ecx, [edx-90h]
.text$x:000024AA                 xor     ecx, eax
.text$x:000024AC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000024B1                 mov     eax, offset __ehfuncinfo$?resetSelection@WindowsDlg@@IAEXXZ
.text$x:000024B6                 jmp     ___CxxFrameHandler3
.text$x:000024B6 __ehhandler$?resetSelection@WindowsDlg@@IAEXXZ endp
.text$x:000024B6
.text$x:000024BB
.text$x:000024BB ; =============== S U B R O U T I N E =======================================
.text$x:000024BB
.text$x:000024BB
.text$x:000024BB __unwindfunclet$?doClose@WindowsDlg@@IAEXXZ$0 proc near
.text$x:000024BB                                         ; DATA XREF: .xdata$x:0000CCD0o
.text$x:000024BB                 lea     ecx, [ebp-0A8h]
.text$x:000024C1                 jmp     ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int>>::~vector<int,std::allocator<int>>(void)
.text$x:000024C1 __unwindfunclet$?doClose@WindowsDlg@@IAEXXZ$0 endp
.text$x:000024C1
.text$x:000024C6
.text$x:000024C6 ; =============== S U B R O U T I N E =======================================
.text$x:000024C6
.text$x:000024C6
.text$x:000024C6 __unwindfunclet$?doClose@WindowsDlg@@IAEXXZ$1 proc near
.text$x:000024C6                                         ; DATA XREF: .xdata$x:0000CCD8o
.text$x:000024C6                 lea     ecx, [ebp-98h]
.text$x:000024CC                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$x:000024CC __unwindfunclet$?doClose@WindowsDlg@@IAEXXZ$1 endp
.text$x:000024CC
.text$x:000024D1
.text$x:000024D1 ; =============== S U B R O U T I N E =======================================
.text$x:000024D1
.text$x:000024D1
.text$x:000024D1 __unwindfunclet$?doClose@WindowsDlg@@IAEXXZ$2 proc near
.text$x:000024D1                                         ; DATA XREF: .xdata$x:0000CCE0o
.text$x:000024D1                 lea     ecx, [ebp-60h]
.text$x:000024D4                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$x:000024D4 __unwindfunclet$?doClose@WindowsDlg@@IAEXXZ$2 endp
.text$x:000024D4
.text$x:000024D9
.text$x:000024D9 ; =============== S U B R O U T I N E =======================================
.text$x:000024D9
.text$x:000024D9
.text$x:000024D9 __unwindfunclet$?doClose@WindowsDlg@@IAEXXZ$3 proc near
.text$x:000024D9                                         ; DATA XREF: .xdata$x:0000CCE8o
.text$x:000024D9                 lea     ecx, [ebp-0B8h]
.text$x:000024DF                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$x:000024DF __unwindfunclet$?doClose@WindowsDlg@@IAEXXZ$3 endp
.text$x:000024DF
.text$x:000024E4
.text$x:000024E4 ; =============== S U B R O U T I N E =======================================
.text$x:000024E4
.text$x:000024E4
.text$x:000024E4 __unwindfunclet$?doClose@WindowsDlg@@IAEXXZ$4 proc near
.text$x:000024E4                                         ; DATA XREF: .xdata$x:0000CCF0o
.text$x:000024E4                 lea     ecx, [ebp-0FCh]
.text$x:000024EA                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$x:000024EA __unwindfunclet$?doClose@WindowsDlg@@IAEXXZ$4 endp
.text$x:000024EA
.text$x:000024EF
.text$x:000024EF ; =============== S U B R O U T I N E =======================================
.text$x:000024EF
.text$x:000024EF
.text$x:000024EF __unwindfunclet$?doClose@WindowsDlg@@IAEXXZ$5 proc near
.text$x:000024EF                                         ; DATA XREF: .xdata$x:0000CCF8o
.text$x:000024EF                 mov     ecx, [ebp-0D8h]
.text$x:000024F5                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$x:000024F5 __unwindfunclet$?doClose@WindowsDlg@@IAEXXZ$5 endp
.text$x:000024F5
.text$x:000024FA
.text$x:000024FA ; =============== S U B R O U T I N E =======================================
.text$x:000024FA
.text$x:000024FA
.text$x:000024FA __unwindfunclet$?doClose@WindowsDlg@@IAEXXZ$6 proc near
.text$x:000024FA                                         ; DATA XREF: .xdata$x:0000CD00o
.text$x:000024FA                 mov     ecx, [ebp-0C0h]
.text$x:00002500                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$x:00002500 __unwindfunclet$?doClose@WindowsDlg@@IAEXXZ$6 endp
.text$x:00002500
.text$x:00002505
.text$x:00002505 ; =============== S U B R O U T I N E =======================================
.text$x:00002505
.text$x:00002505
.text$x:00002505 __unwindfunclet$?doClose@WindowsDlg@@IAEXXZ$7 proc near
.text$x:00002505                                         ; DATA XREF: .xdata$x:0000CD08o
.text$x:00002505                 mov     ecx, [ebp-0C4h]
.text$x:0000250B                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$x:0000250B __unwindfunclet$?doClose@WindowsDlg@@IAEXXZ$7 endp
.text$x:0000250B
.text$x:00002510
.text$x:00002510 ; =============== S U B R O U T I N E =======================================
.text$x:00002510
.text$x:00002510
.text$x:00002510 __unwindfunclet$?doClose@WindowsDlg@@IAEXXZ$8 proc near
.text$x:00002510                                         ; DATA XREF: .xdata$x:0000CD10o
.text$x:00002510                                         ; .xdata$x:0000CD20o
.text$x:00002510                 lea     ecx, [ebp-0F0h]
.text$x:00002516                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$x:00002516 __unwindfunclet$?doClose@WindowsDlg@@IAEXXZ$8 endp
.text$x:00002516
.text$x:0000251B
.text$x:0000251B ; =============== S U B R O U T I N E =======================================
.text$x:0000251B
.text$x:0000251B
.text$x:0000251B __unwindfunclet$?doClose@WindowsDlg@@IAEXXZ$9 proc near
.text$x:0000251B                                         ; DATA XREF: .xdata$x:0000CD18o
.text$x:0000251B                 mov     ecx, [ebp-0C8h]
.text$x:00002521                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$x:00002521 __unwindfunclet$?doClose@WindowsDlg@@IAEXXZ$9 endp
.text$x:00002521
.text$x:00002526
.text$x:00002526 ; =============== S U B R O U T I N E =======================================
.text$x:00002526
.text$x:00002526
.text$x:00002526 __ehhandler$?doClose@WindowsDlg@@IAEXXZ proc near
.text$x:00002526                                         ; DATA XREF: WindowsDlg::doClose(void)+5o
.text$x:00002526
.text$x:00002526 arg_4           = dword ptr  8
.text$x:00002526
.text$x:00002526                 mov     edx, [esp+arg_4]
.text$x:0000252A                 lea     eax, [edx+0Ch]
.text$x:0000252D                 mov     ecx, [edx-168h]
.text$x:00002533                 xor     ecx, eax
.text$x:00002535                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000253A                 mov     eax, offset __ehfuncinfo$?doClose@WindowsDlg@@IAEXXZ
.text$x:0000253F                 jmp     ___CxxFrameHandler3
.text$x:0000253F __ehhandler$?doClose@WindowsDlg@@IAEXXZ endp
.text$x:0000253F
.text$x:00002544
.text$x:00002544 ; =============== S U B R O U T I N E =======================================
.text$x:00002544
.text$x:00002544
.text$x:00002544 __unwindfunclet$?doSortToTabs@WindowsDlg@@IAEXXZ$0 proc near
.text$x:00002544                                         ; DATA XREF: .xdata$x:0000CB64o
.text$x:00002544                 lea     ecx, [ebp-3Ch]
.text$x:00002547                 jmp     ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int>>::~vector<int,std::allocator<int>>(void)
.text$x:00002547 __unwindfunclet$?doSortToTabs@WindowsDlg@@IAEXXZ$0 endp
.text$x:00002547
.text$x:0000254C
.text$x:0000254C ; =============== S U B R O U T I N E =======================================
.text$x:0000254C
.text$x:0000254C
.text$x:0000254C __ehhandler$?doSortToTabs@WindowsDlg@@IAEXXZ proc near
.text$x:0000254C                                         ; DATA XREF: WindowsDlg::doSortToTabs(void)+5o
.text$x:0000254C
.text$x:0000254C arg_4           = dword ptr  8
.text$x:0000254C
.text$x:0000254C                 mov     edx, [esp+arg_4]
.text$x:00002550                 lea     eax, [edx+0Ch]
.text$x:00002553                 mov     ecx, [edx-54h]
.text$x:00002556                 xor     ecx, eax
.text$x:00002558                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000255D                 mov     eax, offset __ehfuncinfo$?doSortToTabs@WindowsDlg@@IAEXXZ
.text$x:00002562                 jmp     ___CxxFrameHandler3
.text$x:00002562 __ehhandler$?doSortToTabs@WindowsDlg@@IAEXXZ endp
.text$x:00002562
.text$x:00002567
.text$x:00002567 ; =============== S U B R O U T I N E =======================================
.text$x:00002567
.text$x:00002567
.text$x:00002567 __unwindfunclet$?init@WindowsMenu@@QAEXPAUHINSTANCE__@@PAUHMENU__@@PB_W@Z$0 proc near
.text$x:00002567                                         ; DATA XREF: .xdata$x:0000CB5Co
.text$x:00002567                 lea     ecx, [ebp-6Ch]
.text$x:0000256A                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:0000256A __unwindfunclet$?init@WindowsMenu@@QAEXPAUHINSTANCE__@@PAUHMENU__@@PB_W@Z$0 endp
.text$x:0000256A
.text$x:0000256F
.text$x:0000256F ; =============== S U B R O U T I N E =======================================
.text$x:0000256F
.text$x:0000256F
.text$x:0000256F __ehhandler$?init@WindowsMenu@@QAEXPAUHINSTANCE__@@PAUHMENU__@@PB_W@Z proc near
.text$x:0000256F                                         ; DATA XREF: WindowsMenu::init(HINSTANCE__ *,HMENU__ *,wchar_t const *)+5o
.text$x:0000256F
.text$x:0000256F arg_4           = dword ptr  8
.text$x:0000256F
.text$x:0000256F                 mov     edx, [esp+arg_4]
.text$x:00002573                 lea     eax, [edx+0Ch]
.text$x:00002576                 mov     ecx, [edx-0A0h]
.text$x:0000257C                 xor     ecx, eax
.text$x:0000257E                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002583                 mov     ecx, [edx-4]
.text$x:00002586                 xor     ecx, eax
.text$x:00002588                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000258D                 mov     eax, offset __ehfuncinfo$?init@WindowsMenu@@QAEXPAUHINSTANCE__@@PAUHMENU__@@PB_W@Z
.text$x:00002592                 jmp     ___CxxFrameHandler3
.text$x:00002592 __ehhandler$?init@WindowsMenu@@QAEXPAUHINSTANCE__@@PAUHMENU__@@PB_W@Z endp
.text$x:00002592
.text$x:00002597
.text$x:00002597 ; =============== S U B R O U T I N E =======================================
.text$x:00002597
.text$x:00002597
.text$x:00002597 __unwindfunclet$?initPopupMenu@WindowsMenu@@QAEXPAUHMENU__@@PAVDocTabView@@@Z$0 proc near
.text$x:00002597                                         ; DATA XREF: .xdata$x:0000CCA0o
.text$x:00002597                 lea     ecx, [ebp-48h]
.text$x:0000259A                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:0000259A __unwindfunclet$?initPopupMenu@WindowsMenu@@QAEXPAUHMENU__@@PAVDocTabView@@@Z$0 endp
.text$x:0000259A
.text$x:0000259F
.text$x:0000259F ; =============== S U B R O U T I N E =======================================
.text$x:0000259F
.text$x:0000259F
.text$x:0000259F __unwindfunclet$?initPopupMenu@WindowsMenu@@QAEXPAUHMENU__@@PAVDocTabView@@@Z$1 proc near
.text$x:0000259F                                         ; DATA XREF: .xdata$x:0000CCA8o
.text$x:0000259F                                         ; .xdata$x:0000CCB0o
.text$x:0000259F                 lea     ecx, [ebp-2Ch]
.text$x:000025A2                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:000025A2 __unwindfunclet$?initPopupMenu@WindowsMenu@@QAEXPAUHMENU__@@PAVDocTabView@@@Z$1 endp
.text$x:000025A2
.text$x:000025A7
.text$x:000025A7 ; =============== S U B R O U T I N E =======================================
.text$x:000025A7
.text$x:000025A7
.text$x:000025A7 __unwindfunclet$?initPopupMenu@WindowsMenu@@QAEXPAUHMENU__@@PAVDocTabView@@@Z$2 proc near
.text$x:000025A7                                         ; DATA XREF: .xdata$x:0000CCB8o
.text$x:000025A7                 mov     ecx, [ebp-9Ch]
.text$x:000025AD                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:000025AD __unwindfunclet$?initPopupMenu@WindowsMenu@@QAEXPAUHMENU__@@PAVDocTabView@@@Z$2 endp
.text$x:000025AD
.text$x:000025B2
.text$x:000025B2 ; =============== S U B R O U T I N E =======================================
.text$x:000025B2
.text$x:000025B2
.text$x:000025B2 __unwindfunclet$?initPopupMenu@WindowsMenu@@QAEXPAUHMENU__@@PAVDocTabView@@@Z$3 proc near
.text$x:000025B2                                         ; DATA XREF: .xdata$x:0000CCC0o
.text$x:000025B2                 mov     ecx, [ebp-80h]
.text$x:000025B5                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:000025B5 __unwindfunclet$?initPopupMenu@WindowsMenu@@QAEXPAUHMENU__@@PAVDocTabView@@@Z$3 endp
.text$x:000025B5
.text$x:000025BA
.text$x:000025BA ; =============== S U B R O U T I N E =======================================
.text$x:000025BA
.text$x:000025BA
.text$x:000025BA __unwindfunclet$?initPopupMenu@WindowsMenu@@QAEXPAUHMENU__@@PAVDocTabView@@@Z$4 proc near
.text$x:000025BA                                         ; DATA XREF: .xdata$x:0000CCC8o
.text$x:000025BA                 lea     ecx, [ebp-90h]
.text$x:000025C0                 jmp     ??1?$vector@_WV?$allocator@_W@std@@@std@@QAE@XZ ; std::vector<wchar_t,std::allocator<wchar_t>>::~vector<wchar_t,std::allocator<wchar_t>>(void)
.text$x:000025C0 __unwindfunclet$?initPopupMenu@WindowsMenu@@QAEXPAUHMENU__@@PAVDocTabView@@@Z$4 endp
.text$x:000025C0
.text$x:000025C5
.text$x:000025C5 ; =============== S U B R O U T I N E =======================================
.text$x:000025C5
.text$x:000025C5
.text$x:000025C5 __ehhandler$?initPopupMenu@WindowsMenu@@QAEXPAUHMENU__@@PAVDocTabView@@@Z proc near
.text$x:000025C5                                         ; DATA XREF: WindowsMenu::initPopupMenu(HMENU__ *,DocTabView *)+5o
.text$x:000025C5
.text$x:000025C5 arg_4           = dword ptr  8
.text$x:000025C5
.text$x:000025C5                 mov     edx, [esp+arg_4]
.text$x:000025C9                 lea     eax, [edx+0Ch]
.text$x:000025CC                 mov     ecx, [edx-0C8h]
.text$x:000025D2                 xor     ecx, eax
.text$x:000025D4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000025D9                 mov     ecx, [edx-4]
.text$x:000025DC                 xor     ecx, eax
.text$x:000025DE                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000025E3                 mov     eax, offset __ehfuncinfo$?initPopupMenu@WindowsMenu@@QAEXPAUHMENU__@@PAVDocTabView@@@Z
.text$x:000025E8                 jmp     ___CxxFrameHandler3
.text$x:000025E8 __ehhandler$?initPopupMenu@WindowsMenu@@QAEXPAUHMENU__@@PAVDocTabView@@@Z endp
.text$x:000025E8
.text$x:000025E8 ; ---------------------------------------------------------------------------
.text$x:000025ED                 align 10h
.text$x:000025ED _text$x         ends
.text$x:000025ED
.text$mn:000025F0 ; ===========================================================================
.text$mn:000025F0
.text$mn:000025F0 ; Segment type: Pure code
.text$mn:000025F0 ; Segment permissions: Read/Execute
.text$mn:000025F0 _text$mn        segment para public 'CODE' use32
.text$mn:000025F0                 assume cs:_text$mn
.text$mn:000025F0                 ;org 25F0h
.text$mn:000025F0 ; COMDAT (pick any)
.text$mn:000025F0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000025F0
.text$mn:000025F0 ; =============== S U B R O U T I N E =======================================
.text$mn:000025F0
.text$mn:000025F0 ; Attributes: bp-based frame
.text$mn:000025F0
.text$mn:000025F0 ; public: __thiscall std::pair<int *, int>::pair<int *, int>(int * &, int &)
.text$mn:000025F0                 public ??$?0AAPAHAAHX@?$pair@PAHH@std@@QAE@AAPAHAAH@Z
.text$mn:000025F0 ??$?0AAPAHAAHX@?$pair@PAHH@std@@QAE@AAPAHAAH@Z proc near
.text$mn:000025F0                                         ; CODE XREF: std::get_temporary_buffer<int>(int)+67p
.text$mn:000025F0
.text$mn:000025F0 var_4           = dword ptr -4
.text$mn:000025F0 arg_0           = dword ptr  8
.text$mn:000025F0 arg_4           = dword ptr  0Ch
.text$mn:000025F0
.text$mn:000025F0                 push    ebp
.text$mn:000025F1                 mov     ebp, esp
.text$mn:000025F3                 push    ecx
.text$mn:000025F4                 mov     [ebp+var_4], ecx
.text$mn:000025F7                 mov     eax, [ebp+arg_0]
.text$mn:000025FA                 push    eax
.text$mn:000025FB                 call    ??$forward@AAPAH@std@@YAAAPAHAAPAH@Z ; std::forward<int * &>(int * &)
.text$mn:00002600                 add     esp, 4
.text$mn:00002603                 mov     ecx, [ebp+var_4]
.text$mn:00002606                 mov     edx, [eax]
.text$mn:00002608                 mov     [ecx], edx
.text$mn:0000260A                 mov     eax, [ebp+arg_4]
.text$mn:0000260D                 push    eax
.text$mn:0000260E                 call    ??$forward@AAH@std@@YAAAHAAH@Z ; std::forward<int &>(int &)
.text$mn:00002613                 add     esp, 4
.text$mn:00002616                 mov     ecx, [ebp+var_4]
.text$mn:00002619                 mov     edx, [eax]
.text$mn:0000261B                 mov     [ecx+4], edx
.text$mn:0000261E                 mov     eax, [ebp+var_4]
.text$mn:00002621                 mov     esp, ebp
.text$mn:00002623                 pop     ebp
.text$mn:00002624                 retn    8
.text$mn:00002624 ??$?0AAPAHAAHX@?$pair@PAHH@std@@QAE@AAPAHAAH@Z endp
.text$mn:00002624
.text$mn:00002624 ; ---------------------------------------------------------------------------
.text$mn:00002627                 align 4
.text$mn:00002627 _text$mn        ends
.text$mn:00002627
.text$mn:00002628 ; ===========================================================================
.text$mn:00002628
.text$mn:00002628 ; Segment type: Pure code
.text$mn:00002628 ; Segment permissions: Read/Execute
.text$mn:00002628 _text$mn        segment para public 'CODE' use32
.text$mn:00002628                 assume cs:_text$mn
.text$mn:00002628                 ;org 2628h
.text$mn:00002628 ; COMDAT (pick any)
.text$mn:00002628                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002628
.text$mn:00002628 ; =============== S U B R O U T I N E =======================================
.text$mn:00002628
.text$mn:00002628 ; Attributes: bp-based frame
.text$mn:00002628
.text$mn:00002628 ; public: __thiscall std::vector<wchar_t, class std::allocator<wchar_t>>::vector<wchar_t, class std::allocator<wchar_t>>(class std::_String_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>>, class std::_String_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>>)
.text$mn:00002628                 public ??$?0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@X@?$vector@_WV?$allocator@_W@std@@@std@@QAE@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z
.text$mn:00002628 ??$?0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@X@?$vector@_WV?$allocator@_W@std@@@std@@QAE@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z proc near
.text$mn:00002628                                         ; CODE XREF: WindowsMenu::initPopupMenu(HMENU__ *,DocTabView *)+17Bp
.text$mn:00002628
.text$mn:00002628 var_2C          = dword ptr -2Ch
.text$mn:00002628 var_28          = dword ptr -28h
.text$mn:00002628 var_24          = dword ptr -24h
.text$mn:00002628 var_20          = dword ptr -20h
.text$mn:00002628 var_1C          = dword ptr -1Ch
.text$mn:00002628 var_18          = dword ptr -18h
.text$mn:00002628 var_14          = dword ptr -14h
.text$mn:00002628 var_D           = byte ptr -0Dh
.text$mn:00002628 var_C           = dword ptr -0Ch
.text$mn:00002628 var_4           = dword ptr -4
.text$mn:00002628 arg_0           = byte ptr  8
.text$mn:00002628 arg_C           = byte ptr  14h
.text$mn:00002628
.text$mn:00002628                 push    ebp
.text$mn:00002629                 mov     ebp, esp
.text$mn:0000262B                 push    0FFFFFFFFh
.text$mn:0000262D                 push    offset __ehhandler$??$?0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@X@?$vector@_WV?$allocator@_W@std@@@std@@QAE@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z
.text$mn:00002632                 mov     eax, large fs:0
.text$mn:00002638                 push    eax
.text$mn:00002639                 sub     esp, 20h
.text$mn:0000263C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002641                 xor     eax, ebp
.text$mn:00002643                 push    eax
.text$mn:00002644                 lea     eax, [ebp+var_C]
.text$mn:00002647                 mov     large fs:0, eax
.text$mn:0000264D                 mov     [ebp+var_14], ecx
.text$mn:00002650                 mov     [ebp+var_4], 1
.text$mn:00002657                 lea     ecx, [ebp+var_D]
.text$mn:0000265A                 call    ??0?$allocator@_W@std@@QAE@XZ ; std::allocator<wchar_t>::allocator<wchar_t>(void)
.text$mn:0000265F                 push    eax
.text$mn:00002660                 mov     ecx, [ebp+var_14]
.text$mn:00002663                 call    ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<wchar_t,std::allocator<wchar_t>>>::_Vector_alloc<0,std::_Vec_base_types<wchar_t,std::allocator<wchar_t>>>(std::allocator<wchar_t> const &)
.text$mn:00002668                 mov     byte ptr [ebp+var_4], 2
.text$mn:0000266C                 sub     esp, 0Ch
.text$mn:0000266F                 mov     ecx, esp
.text$mn:00002671                 mov     [ebp+var_20], esp
.text$mn:00002674                 lea     eax, [ebp+arg_C]
.text$mn:00002677                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00002678                 call    ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:0000267D                 mov     [ebp+var_18], eax
.text$mn:00002680                 mov     ecx, [ebp+var_18]
.text$mn:00002683                 mov     [ebp+var_24], ecx
.text$mn:00002686                 mov     byte ptr [ebp+var_4], 3
.text$mn:0000268A                 sub     esp, 0Ch
.text$mn:0000268D                 mov     ecx, esp
.text$mn:0000268F                 mov     [ebp+var_28], esp
.text$mn:00002692                 lea     edx, [ebp+arg_0]
.text$mn:00002695                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:00002696                 call    ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:0000269B                 mov     [ebp+var_1C], eax
.text$mn:0000269E                 mov     eax, [ebp+var_1C]
.text$mn:000026A1                 mov     [ebp+var_2C], eax
.text$mn:000026A4                 mov     byte ptr [ebp+var_4], 4
.text$mn:000026A8                 mov     byte ptr [ebp+var_4], 2
.text$mn:000026AC                 mov     ecx, [ebp+var_14]
.text$mn:000026AF                 call    ??$_Construct@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$vector@_WV?$allocator@_W@std@@@std@@QAEXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z ; std::vector<wchar_t,std::allocator<wchar_t>>::_Construct<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)
.text$mn:000026B4                 mov     byte ptr [ebp+var_4], 0
.text$mn:000026B8                 lea     ecx, [ebp+arg_0]
.text$mn:000026BB                 call    ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$mn:000026C0                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000026C7                 lea     ecx, [ebp+arg_C]
.text$mn:000026CA                 call    ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$mn:000026CF                 mov     eax, [ebp+var_14]
.text$mn:000026D2                 mov     ecx, [ebp+var_C]
.text$mn:000026D5                 mov     large fs:0, ecx
.text$mn:000026DC                 pop     ecx
.text$mn:000026DD                 mov     esp, ebp
.text$mn:000026DF                 pop     ebp
.text$mn:000026E0                 retn    18h
.text$mn:000026E0 ??$?0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@X@?$vector@_WV?$allocator@_W@std@@@std@@QAE@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z endp
.text$mn:000026E0
.text$mn:000026E0 ; ---------------------------------------------------------------------------
.text$mn:000026E3                 align 4
.text$mn:000026E3 _text$mn        ends
.text$mn:000026E3
.text$x:000026E4 ; ===========================================================================
.text$x:000026E4
.text$x:000026E4 ; Segment type: Pure code
.text$x:000026E4 ; Segment permissions: Read/Execute
.text$x:000026E4 _text$x         segment para public 'CODE' use32
.text$x:000026E4                 assume cs:_text$x
.text$x:000026E4                 ;org 26E4h
.text$x:000026E4 ; COMDAT (pick associative to section at 2628)
.text$x:000026E4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000026E4
.text$x:000026E4 ; =============== S U B R O U T I N E =======================================
.text$x:000026E4
.text$x:000026E4
.text$x:000026E4 __unwindfunclet$??$?0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@X@?$vector@_WV?$allocator@_W@std@@@std@@QAE@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$0 proc near
.text$x:000026E4                                         ; DATA XREF: .xdata$x:0000D628o
.text$x:000026E4                 lea     ecx, [ebp+14h]
.text$x:000026E7                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:000026E7 __unwindfunclet$??$?0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@X@?$vector@_WV?$allocator@_W@std@@@std@@QAE@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$0 endp
.text$x:000026E7
.text$x:000026EC
.text$x:000026EC ; =============== S U B R O U T I N E =======================================
.text$x:000026EC
.text$x:000026EC
.text$x:000026EC __unwindfunclet$??$?0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@X@?$vector@_WV?$allocator@_W@std@@@std@@QAE@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$1 proc near
.text$x:000026EC                                         ; DATA XREF: .xdata$x:0000D630o
.text$x:000026EC                 lea     ecx, [ebp+8]
.text$x:000026EF                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:000026EF __unwindfunclet$??$?0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@X@?$vector@_WV?$allocator@_W@std@@@std@@QAE@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$1 endp
.text$x:000026EF
.text$x:000026F4
.text$x:000026F4 ; =============== S U B R O U T I N E =======================================
.text$x:000026F4
.text$x:000026F4
.text$x:000026F4 __unwindfunclet$??$?0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@X@?$vector@_WV?$allocator@_W@std@@@std@@QAE@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$2 proc near
.text$x:000026F4                                         ; DATA XREF: .xdata$x:0000D638o
.text$x:000026F4                 mov     ecx, [ebp-14h]
.text$x:000026F7                 jmp     ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<wchar_t,std::allocator<wchar_t>>>::~_Vector_alloc<0,std::_Vec_base_types<wchar_t,std::allocator<wchar_t>>>(void)
.text$x:000026F7 __unwindfunclet$??$?0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@X@?$vector@_WV?$allocator@_W@std@@@std@@QAE@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$2 endp
.text$x:000026F7
.text$x:000026FC
.text$x:000026FC ; =============== S U B R O U T I N E =======================================
.text$x:000026FC
.text$x:000026FC
.text$x:000026FC __unwindfunclet$??$?0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@X@?$vector@_WV?$allocator@_W@std@@@std@@QAE@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$3 proc near
.text$x:000026FC                                         ; DATA XREF: .xdata$x:0000D640o
.text$x:000026FC                 mov     ecx, [ebp-20h]
.text$x:000026FF                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:000026FF __unwindfunclet$??$?0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@X@?$vector@_WV?$allocator@_W@std@@@std@@QAE@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$3 endp
.text$x:000026FF
.text$x:00002704
.text$x:00002704 ; =============== S U B R O U T I N E =======================================
.text$x:00002704
.text$x:00002704
.text$x:00002704 __unwindfunclet$??$?0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@X@?$vector@_WV?$allocator@_W@std@@@std@@QAE@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$4 proc near
.text$x:00002704                                         ; DATA XREF: .xdata$x:0000D648o
.text$x:00002704                 mov     ecx, [ebp-28h]
.text$x:00002707                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00002707 __unwindfunclet$??$?0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@X@?$vector@_WV?$allocator@_W@std@@@std@@QAE@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$4 endp
.text$x:00002707
.text$x:0000270C
.text$x:0000270C ; =============== S U B R O U T I N E =======================================
.text$x:0000270C
.text$x:0000270C
.text$x:0000270C __ehhandler$??$?0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@X@?$vector@_WV?$allocator@_W@std@@@std@@QAE@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z proc near
.text$x:0000270C                                         ; DATA XREF: std::vector<wchar_t,std::allocator<wchar_t>>::vector<wchar_t,std::allocator<wchar_t>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)+5o
.text$x:0000270C
.text$x:0000270C arg_4           = dword ptr  8
.text$x:0000270C
.text$x:0000270C                 mov     edx, [esp+arg_4]
.text$x:00002710                 lea     eax, [edx+0Ch]
.text$x:00002713                 mov     ecx, [edx-24h]
.text$x:00002716                 xor     ecx, eax
.text$x:00002718                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000271D                 mov     eax, offset __ehfuncinfo$??$?0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@X@?$vector@_WV?$allocator@_W@std@@@std@@QAE@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z
.text$x:00002722                 jmp     ___CxxFrameHandler3
.text$x:00002722 __ehhandler$??$?0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@X@?$vector@_WV?$allocator@_W@std@@@std@@QAE@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z endp
.text$x:00002722
.text$x:00002722 ; ---------------------------------------------------------------------------
.text$x:00002727                 align 4
.text$x:00002727 _text$x         ends
.text$x:00002727
.text$mn:00002728 ; ===========================================================================
.text$mn:00002728
.text$mn:00002728 ; Segment type: Pure code
.text$mn:00002728 ; Segment permissions: Read/Execute
.text$mn:00002728 _text$mn        segment para public 'CODE' use32
.text$mn:00002728                 assume cs:_text$mn
.text$mn:00002728                 ;org 2728h
.text$mn:00002728 ; COMDAT (pick any)
.text$mn:00002728                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002728
.text$mn:00002728 ; =============== S U B R O U T I N E =======================================
.text$mn:00002728
.text$mn:00002728 ; Attributes: bp-based frame
.text$mn:00002728
.text$mn:00002728 ; void __cdecl std::_Advance<int *, int>(int * &, int, struct std::random_access_iterator_tag)
.text$mn:00002728                 public ??$_Advance@PAHH@std@@YAXAAPAHHUrandom_access_iterator_tag@0@@Z
.text$mn:00002728 ??$_Advance@PAHH@std@@YAXAAPAHHUrandom_access_iterator_tag@0@@Z proc near
.text$mn:00002728                                         ; CODE XREF: std::advance<int *,int>(int * &,int)+22p
.text$mn:00002728
.text$mn:00002728 arg_0           = dword ptr  8
.text$mn:00002728 arg_4           = dword ptr  0Ch
.text$mn:00002728
.text$mn:00002728                 push    ebp
.text$mn:00002729                 mov     ebp, esp
.text$mn:0000272B                 mov     eax, [ebp+arg_0]
.text$mn:0000272E                 mov     ecx, [eax]
.text$mn:00002730                 mov     edx, [ebp+arg_4]
.text$mn:00002733                 lea     eax, [ecx+edx*4]
.text$mn:00002736                 mov     ecx, [ebp+arg_0]
.text$mn:00002739                 mov     [ecx], eax
.text$mn:0000273B                 pop     ebp
.text$mn:0000273C                 retn
.text$mn:0000273C ??$_Advance@PAHH@std@@YAXAAPAHHUrandom_access_iterator_tag@0@@Z endp
.text$mn:0000273C
.text$mn:0000273C ; ---------------------------------------------------------------------------
.text$mn:0000273D                 align 10h
.text$mn:0000273D _text$mn        ends
.text$mn:0000273D
.text$mn:00002740 ; ===========================================================================
.text$mn:00002740
.text$mn:00002740 ; Segment type: Pure code
.text$mn:00002740 ; Segment permissions: Read/Execute
.text$mn:00002740 _text$mn        segment para public 'CODE' use32
.text$mn:00002740                 assume cs:_text$mn
.text$mn:00002740                 ;org 2740h
.text$mn:00002740 ; COMDAT (pick any)
.text$mn:00002740                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002740
.text$mn:00002740 ; =============== S U B R O U T I N E =======================================
.text$mn:00002740
.text$mn:00002740 ; Attributes: bp-based frame
.text$mn:00002740
.text$mn:00002740 ; char * __cdecl std::_Allocate<char>(unsigned int, char *)
.text$mn:00002740                 public ??$_Allocate@D@std@@YAPADIPAD@Z
.text$mn:00002740 ??$_Allocate@D@std@@YAPADIPAD@Z proc near
.text$mn:00002740                                         ; CODE XREF: std::allocator<char>::allocate(uint)+Dp
.text$mn:00002740
.text$mn:00002740 var_4           = dword ptr -4
.text$mn:00002740 arg_0           = dword ptr  8
.text$mn:00002740
.text$mn:00002740                 push    ebp
.text$mn:00002741                 mov     ebp, esp
.text$mn:00002743                 push    ecx
.text$mn:00002744                 mov     [ebp+var_4], 0
.text$mn:0000274B                 cmp     [ebp+arg_0], 0
.text$mn:0000274F                 jnz     short loc_2753
.text$mn:00002751                 jmp     short loc_2773
.text$mn:00002753 ; ---------------------------------------------------------------------------
.text$mn:00002753
.text$mn:00002753 loc_2753:                               ; CODE XREF: std::_Allocate<char>(uint,char *)+Fj
.text$mn:00002753                 cmp     [ebp+arg_0], 0FFFFFFFFh
.text$mn:00002757                 ja      short loc_276E
.text$mn:00002759                 mov     eax, [ebp+arg_0]
.text$mn:0000275C                 push    eax             ; unsigned int
.text$mn:0000275D                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00002762                 add     esp, 4
.text$mn:00002765                 mov     [ebp+var_4], eax
.text$mn:00002768                 cmp     [ebp+var_4], 0
.text$mn:0000276C                 jnz     short loc_2773
.text$mn:0000276E
.text$mn:0000276E loc_276E:                               ; CODE XREF: std::_Allocate<char>(uint,char *)+17j
.text$mn:0000276E                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:00002773
.text$mn:00002773 loc_2773:                               ; CODE XREF: std::_Allocate<char>(uint,char *)+11j
.text$mn:00002773                                         ; std::_Allocate<char>(uint,char *)+2Cj
.text$mn:00002773                 mov     eax, [ebp+var_4]
.text$mn:00002776                 mov     esp, ebp
.text$mn:00002778                 pop     ebp
.text$mn:00002779                 retn
.text$mn:00002779 ??$_Allocate@D@std@@YAPADIPAD@Z endp
.text$mn:00002779
.text$mn:00002779 ; ---------------------------------------------------------------------------
.text$mn:0000277A                 align 4
.text$mn:0000277A _text$mn        ends
.text$mn:0000277A
.text$mn:0000277C ; ===========================================================================
.text$mn:0000277C
.text$mn:0000277C ; Segment type: Pure code
.text$mn:0000277C ; Segment permissions: Read/Execute
.text$mn:0000277C _text$mn        segment para public 'CODE' use32
.text$mn:0000277C                 assume cs:_text$mn
.text$mn:0000277C                 ;org 277Ch
.text$mn:0000277C ; COMDAT (pick any)
.text$mn:0000277C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000277C
.text$mn:0000277C ; =============== S U B R O U T I N E =======================================
.text$mn:0000277C
.text$mn:0000277C ; Attributes: bp-based frame
.text$mn:0000277C
.text$mn:0000277C ; int * __cdecl std::_Allocate<int>(unsigned int, int *)
.text$mn:0000277C                 public ??$_Allocate@H@std@@YAPAHIPAH@Z
.text$mn:0000277C ??$_Allocate@H@std@@YAPAHIPAH@Z proc near
.text$mn:0000277C                                         ; CODE XREF: std::allocator<int>::allocate(uint)+Dp
.text$mn:0000277C
.text$mn:0000277C var_4           = dword ptr -4
.text$mn:0000277C arg_0           = dword ptr  8
.text$mn:0000277C
.text$mn:0000277C                 push    ebp
.text$mn:0000277D                 mov     ebp, esp
.text$mn:0000277F                 push    ecx
.text$mn:00002780                 mov     [ebp+var_4], 0
.text$mn:00002787                 cmp     [ebp+arg_0], 0
.text$mn:0000278B                 jnz     short loc_278F
.text$mn:0000278D                 jmp     short loc_27B5
.text$mn:0000278F ; ---------------------------------------------------------------------------
.text$mn:0000278F
.text$mn:0000278F loc_278F:                               ; CODE XREF: std::_Allocate<int>(uint,int *)+Fj
.text$mn:0000278F                 cmp     [ebp+arg_0], 3FFFFFFFh
.text$mn:00002796                 ja      short loc_27B0
.text$mn:00002798                 mov     eax, [ebp+arg_0]
.text$mn:0000279B                 shl     eax, 2
.text$mn:0000279E                 push    eax             ; unsigned int
.text$mn:0000279F                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:000027A4                 add     esp, 4
.text$mn:000027A7                 mov     [ebp+var_4], eax
.text$mn:000027AA                 cmp     [ebp+var_4], 0
.text$mn:000027AE                 jnz     short loc_27B5
.text$mn:000027B0
.text$mn:000027B0 loc_27B0:                               ; CODE XREF: std::_Allocate<int>(uint,int *)+1Aj
.text$mn:000027B0                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:000027B5
.text$mn:000027B5 loc_27B5:                               ; CODE XREF: std::_Allocate<int>(uint,int *)+11j
.text$mn:000027B5                                         ; std::_Allocate<int>(uint,int *)+32j
.text$mn:000027B5                 mov     eax, [ebp+var_4]
.text$mn:000027B8                 mov     esp, ebp
.text$mn:000027BA                 pop     ebp
.text$mn:000027BB                 retn
.text$mn:000027BB ??$_Allocate@H@std@@YAPAHIPAH@Z endp
.text$mn:000027BB
.text$mn:000027BB _text$mn        ends
.text$mn:000027BB
.text$mn:000027BC ; ===========================================================================
.text$mn:000027BC
.text$mn:000027BC ; Segment type: Pure code
.text$mn:000027BC ; Segment permissions: Read/Execute
.text$mn:000027BC _text$mn        segment para public 'CODE' use32
.text$mn:000027BC                 assume cs:_text$mn
.text$mn:000027BC                 ;org 27BCh
.text$mn:000027BC ; COMDAT (pick any)
.text$mn:000027BC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000027BC
.text$mn:000027BC ; =============== S U B R O U T I N E =======================================
.text$mn:000027BC
.text$mn:000027BC ; Attributes: bp-based frame
.text$mn:000027BC
.text$mn:000027BC ; struct std::_Container_proxy * __cdecl std::_Allocate<struct std::_Container_proxy>(unsigned int, struct std::_Container_proxy *)
.text$mn:000027BC                 public ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z
.text$mn:000027BC ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z proc near
.text$mn:000027BC                                         ; CODE XREF: std::allocator<std::_Container_proxy>::allocate(uint)+Dp
.text$mn:000027BC
.text$mn:000027BC var_4           = dword ptr -4
.text$mn:000027BC arg_0           = dword ptr  8
.text$mn:000027BC
.text$mn:000027BC                 push    ebp
.text$mn:000027BD                 mov     ebp, esp
.text$mn:000027BF                 push    ecx
.text$mn:000027C0                 mov     [ebp+var_4], 0
.text$mn:000027C7                 cmp     [ebp+arg_0], 0
.text$mn:000027CB                 jnz     short loc_27CF
.text$mn:000027CD                 jmp     short loc_27F5
.text$mn:000027CF ; ---------------------------------------------------------------------------
.text$mn:000027CF
.text$mn:000027CF loc_27CF:                               ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+Fj
.text$mn:000027CF                 cmp     [ebp+arg_0], 1FFFFFFFh
.text$mn:000027D6                 ja      short loc_27F0
.text$mn:000027D8                 mov     eax, [ebp+arg_0]
.text$mn:000027DB                 shl     eax, 3
.text$mn:000027DE                 push    eax             ; unsigned int
.text$mn:000027DF                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:000027E4                 add     esp, 4
.text$mn:000027E7                 mov     [ebp+var_4], eax
.text$mn:000027EA                 cmp     [ebp+var_4], 0
.text$mn:000027EE                 jnz     short loc_27F5
.text$mn:000027F0
.text$mn:000027F0 loc_27F0:                               ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+1Aj
.text$mn:000027F0                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:000027F5
.text$mn:000027F5 loc_27F5:                               ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+11j
.text$mn:000027F5                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+32j
.text$mn:000027F5                 mov     eax, [ebp+var_4]
.text$mn:000027F8                 mov     esp, ebp
.text$mn:000027FA                 pop     ebp
.text$mn:000027FB                 retn
.text$mn:000027FB ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z endp
.text$mn:000027FB
.text$mn:000027FB _text$mn        ends
.text$mn:000027FB
.text$mn:000027FC ; ===========================================================================
.text$mn:000027FC
.text$mn:000027FC ; Segment type: Pure code
.text$mn:000027FC ; Segment permissions: Read/Execute
.text$mn:000027FC _text$mn        segment para public 'CODE' use32
.text$mn:000027FC                 assume cs:_text$mn
.text$mn:000027FC                 ;org 27FCh
.text$mn:000027FC ; COMDAT (pick any)
.text$mn:000027FC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000027FC
.text$mn:000027FC ; =============== S U B R O U T I N E =======================================
.text$mn:000027FC
.text$mn:000027FC ; Attributes: bp-based frame
.text$mn:000027FC
.text$mn:000027FC ; wchar_t * __cdecl std::_Allocate<wchar_t>(unsigned int, wchar_t *)
.text$mn:000027FC                 public ??$_Allocate@_W@std@@YAPA_WIPA_W@Z
.text$mn:000027FC ??$_Allocate@_W@std@@YAPA_WIPA_W@Z proc near
.text$mn:000027FC                                         ; CODE XREF: std::allocator<wchar_t>::allocate(uint)+Dp
.text$mn:000027FC
.text$mn:000027FC var_4           = dword ptr -4
.text$mn:000027FC arg_0           = dword ptr  8
.text$mn:000027FC
.text$mn:000027FC                 push    ebp
.text$mn:000027FD                 mov     ebp, esp
.text$mn:000027FF                 push    ecx
.text$mn:00002800                 mov     [ebp+var_4], 0
.text$mn:00002807                 cmp     [ebp+arg_0], 0
.text$mn:0000280B                 jnz     short loc_280F
.text$mn:0000280D                 jmp     short loc_2834
.text$mn:0000280F ; ---------------------------------------------------------------------------
.text$mn:0000280F
.text$mn:0000280F loc_280F:                               ; CODE XREF: std::_Allocate<wchar_t>(uint,wchar_t *)+Fj
.text$mn:0000280F                 cmp     [ebp+arg_0], 7FFFFFFFh
.text$mn:00002816                 ja      short loc_282F
.text$mn:00002818                 mov     eax, [ebp+arg_0]
.text$mn:0000281B                 shl     eax, 1
.text$mn:0000281D                 push    eax             ; unsigned int
.text$mn:0000281E                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00002823                 add     esp, 4
.text$mn:00002826                 mov     [ebp+var_4], eax
.text$mn:00002829                 cmp     [ebp+var_4], 0
.text$mn:0000282D                 jnz     short loc_2834
.text$mn:0000282F
.text$mn:0000282F loc_282F:                               ; CODE XREF: std::_Allocate<wchar_t>(uint,wchar_t *)+1Aj
.text$mn:0000282F                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:00002834
.text$mn:00002834 loc_2834:                               ; CODE XREF: std::_Allocate<wchar_t>(uint,wchar_t *)+11j
.text$mn:00002834                                         ; std::_Allocate<wchar_t>(uint,wchar_t *)+31j
.text$mn:00002834                 mov     eax, [ebp+var_4]
.text$mn:00002837                 mov     esp, ebp
.text$mn:00002839                 pop     ebp
.text$mn:0000283A                 retn
.text$mn:0000283A ??$_Allocate@_W@std@@YAPA_WIPA_W@Z endp
.text$mn:0000283A
.text$mn:0000283A ; ---------------------------------------------------------------------------
.text$mn:0000283B                 align 4
.text$mn:0000283B _text$mn        ends
.text$mn:0000283B
.text$mn:0000283C ; ===========================================================================
.text$mn:0000283C
.text$mn:0000283C ; Segment type: Pure code
.text$mn:0000283C ; Segment permissions: Read/Execute
.text$mn:0000283C _text$mn        segment para public 'CODE' use32
.text$mn:0000283C                 assume cs:_text$mn
.text$mn:0000283C                 ;org 283Ch
.text$mn:0000283C ; COMDAT (pick any)
.text$mn:0000283C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000283C
.text$mn:0000283C ; =============== S U B R O U T I N E =======================================
.text$mn:0000283C
.text$mn:0000283C ; Attributes: bp-based frame
.text$mn:0000283C
.text$mn:0000283C ; int __cdecl std::_Buffered_merge<int *,int,int,BufferEquivalent>(void *Dst, void *Src, int, int, int, int, int, int, int, int)
.text$mn:0000283C                 public ??$_Buffered_merge@PAHHHUBufferEquivalent@@@std@@YAXPAH00HHAAV?$_Temp_iterator@H@0@UBufferEquivalent@@@Z
.text$mn:0000283C ??$_Buffered_merge@PAHHHUBufferEquivalent@@@std@@YAXPAH00HHAAV?$_Temp_iterator@H@0@UBufferEquivalent@@@Z proc near
.text$mn:0000283C                                         ; CODE XREF: std::_Buffered_merge<int *,int,int,BufferEquivalent>(int *,int *,int *,int,int,std::_Temp_iterator<int> &,BufferEquivalent)+323p
.text$mn:0000283C                                         ; std::_Buffered_merge<int *,int,int,BufferEquivalent>(int *,int *,int *,int,int,std::_Temp_iterator<int> &,BufferEquivalent)+362p ...
.text$mn:0000283C
.text$mn:0000283C var_68          = byte ptr -68h
.text$mn:0000283C var_54          = byte ptr -54h
.text$mn:0000283C var_40          = dword ptr -40h
.text$mn:0000283C var_3C          = dword ptr -3Ch
.text$mn:0000283C var_38          = dword ptr -38h
.text$mn:0000283C var_34          = dword ptr -34h
.text$mn:0000283C var_30          = dword ptr -30h
.text$mn:0000283C var_2C          = dword ptr -2Ch
.text$mn:0000283C var_28          = dword ptr -28h
.text$mn:0000283C var_24          = dword ptr -24h
.text$mn:0000283C var_20          = dword ptr -20h
.text$mn:0000283C var_1C          = dword ptr -1Ch
.text$mn:0000283C var_18          = dword ptr -18h
.text$mn:0000283C var_14          = dword ptr -14h
.text$mn:0000283C var_10          = dword ptr -10h
.text$mn:0000283C var_C           = dword ptr -0Ch
.text$mn:0000283C var_4           = dword ptr -4
.text$mn:0000283C Dst             = dword ptr  8
.text$mn:0000283C Src             = dword ptr  0Ch
.text$mn:0000283C arg_8           = dword ptr  10h
.text$mn:0000283C arg_C           = dword ptr  14h
.text$mn:0000283C arg_10          = dword ptr  18h
.text$mn:0000283C arg_14          = dword ptr  1Ch
.text$mn:0000283C arg_18          = dword ptr  20h
.text$mn:0000283C arg_1C          = dword ptr  24h
.text$mn:0000283C arg_20          = dword ptr  28h
.text$mn:0000283C arg_24          = dword ptr  2Ch
.text$mn:0000283C
.text$mn:0000283C                 push    ebp
.text$mn:0000283D                 mov     ebp, esp
.text$mn:0000283F                 push    0FFFFFFFFh
.text$mn:00002841                 push    offset __ehhandler$??$_Buffered_merge@PAHHHUBufferEquivalent@@@std@@YAXPAH00HHAAV?$_Temp_iterator@H@0@UBufferEquivalent@@@Z
.text$mn:00002846                 mov     eax, large fs:0
.text$mn:0000284C                 push    eax
.text$mn:0000284D                 sub     esp, 5Ch
.text$mn:00002850                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002855                 xor     eax, ebp
.text$mn:00002857                 push    eax
.text$mn:00002858                 lea     eax, [ebp+var_C]
.text$mn:0000285B                 mov     large fs:0, eax
.text$mn:00002861                 cmp     [ebp+arg_C], 0
.text$mn:00002865                 jz      short loc_286D
.text$mn:00002867                 cmp     [ebp+arg_10], 0
.text$mn:0000286B                 jnz     short loc_2872
.text$mn:0000286D
.text$mn:0000286D loc_286D:                               ; CODE XREF: std::_Buffered_merge<int *,int,int,BufferEquivalent>(int *,int *,int *,int,int,std::_Temp_iterator<int> &,BufferEquivalent)+29j
.text$mn:0000286D                 jmp     loc_2BA6
.text$mn:00002872 ; ---------------------------------------------------------------------------
.text$mn:00002872
.text$mn:00002872 loc_2872:                               ; CODE XREF: std::_Buffered_merge<int *,int,int,BufferEquivalent>(int *,int *,int *,int,int,std::_Temp_iterator<int> &,BufferEquivalent)+2Fj
.text$mn:00002872                 mov     eax, [ebp+arg_C]
.text$mn:00002875                 add     eax, [ebp+arg_10]
.text$mn:00002878                 cmp     eax, 2
.text$mn:0000287B                 jnz     short loc_28CF
.text$mn:0000287D                 push    0B63h           ; unsigned int
.text$mn:00002882                 push    offset ??_C@_1JC@HALMDPKM@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00002887                 mov     ecx, [ebp+Dst]
.text$mn:0000288A                 push    ecx             ; int
.text$mn:0000288B                 mov     edx, [ebp+Src]
.text$mn:0000288E                 push    edx             ; int
.text$mn:0000288F                 sub     esp, 10h
.text$mn:00002892                 mov     eax, esp
.text$mn:00002894                 mov     ecx, [ebp+arg_18]
.text$mn:00002897                 mov     [eax], ecx
.text$mn:00002899                 mov     edx, [ebp+arg_1C]
.text$mn:0000289C                 mov     [eax+4], edx
.text$mn:0000289F                 mov     ecx, [ebp+arg_20]
.text$mn:000028A2                 mov     [eax+8], ecx
.text$mn:000028A5                 mov     edx, [ebp+arg_24]
.text$mn:000028A8                 mov     [eax+0Ch], edx
.text$mn:000028AB                 call    ??$_Debug_lt_pred@UBufferEquivalent@@AAHAAH@std@@YA_NUBufferEquivalent@@AAH1PB_WI@Z ; std::_Debug_lt_pred<BufferEquivalent,int &,int &>(BufferEquivalent,int &,int &,wchar_t const *,uint)
.text$mn:000028B0                 add     esp, 20h
.text$mn:000028B3                 movzx   eax, al
.text$mn:000028B6                 test    eax, eax
.text$mn:000028B8                 jz      short loc_28CA
.text$mn:000028BA                 mov     ecx, [ebp+Src]
.text$mn:000028BD                 push    ecx
.text$mn:000028BE                 mov     edx, [ebp+Dst]
.text$mn:000028C1                 push    edx
.text$mn:000028C2                 call    ??$iter_swap@PAHPAH@std@@YAXPAH0@Z ; std::iter_swap<int *,int *>(int *,int *)
.text$mn:000028C7                 add     esp, 8
.text$mn:000028CA
.text$mn:000028CA loc_28CA:                               ; CODE XREF: std::_Buffered_merge<int *,int,int,BufferEquivalent>(int *,int *,int *,int,int,std::_Temp_iterator<int> &,BufferEquivalent)+7Cj
.text$mn:000028CA                 jmp     loc_2BA6
.text$mn:000028CF ; ---------------------------------------------------------------------------
.text$mn:000028CF
.text$mn:000028CF loc_28CF:                               ; CODE XREF: std::_Buffered_merge<int *,int,int,BufferEquivalent>(int *,int *,int *,int,int,std::_Temp_iterator<int> &,BufferEquivalent)+3Fj
.text$mn:000028CF                 mov     eax, [ebp+arg_C]
.text$mn:000028D2                 cmp     eax, [ebp+arg_10]
.text$mn:000028D5                 jg      loc_297F
.text$mn:000028DB                 mov     ecx, [ebp+arg_14]
.text$mn:000028DE                 call    ?_Maxlen@?$_Temp_iterator@H@std@@QAEHXZ ; std::_Temp_iterator<int>::_Maxlen(void)
.text$mn:000028E3                 cmp     [ebp+arg_C], eax
.text$mn:000028E6                 jg      loc_297F
.text$mn:000028EC                 mov     ecx, [ebp+arg_14]
.text$mn:000028EF                 call    ?_Init@?$_Temp_iterator@H@std@@QAEAAV12@XZ ; std::_Temp_iterator<int>::_Init(void)
.text$mn:000028F4                 sub     esp, 14h
.text$mn:000028F7                 mov     ecx, esp
.text$mn:000028F9                 mov     [ebp+var_2C], esp
.text$mn:000028FC                 push    eax
.text$mn:000028FD                 call    ??0?$_Temp_iterator@H@std@@QAE@ABV01@@Z ; std::_Temp_iterator<int>::_Temp_iterator<int>(std::_Temp_iterator<int> const &)
.text$mn:00002902                 mov     [ebp+var_24], eax
.text$mn:00002905                 mov     ecx, [ebp+var_24]
.text$mn:00002908                 mov     [ebp+var_30], ecx
.text$mn:0000290B                 mov     [ebp+var_4], 0
.text$mn:00002912                 mov     edx, [ebp+Src]
.text$mn:00002915                 push    edx
.text$mn:00002916                 mov     eax, [ebp+Dst]
.text$mn:00002919                 push    eax
.text$mn:0000291A                 lea     ecx, [ebp+var_54]
.text$mn:0000291D                 push    ecx
.text$mn:0000291E                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002925                 call    ??$_Move@PAHV?$_Temp_iterator@H@std@@@std@@YA?AV?$_Temp_iterator@H@0@PAH0V10@@Z ; std::_Move<int *,std::_Temp_iterator<int>>(int *,int *,std::_Temp_iterator<int>)
.text$mn:0000292A                 add     esp, 20h
.text$mn:0000292D                 mov     [ebp+var_34], eax
.text$mn:00002930                 lea     ecx, [ebp+var_54]
.text$mn:00002933                 call    ??1?$_Temp_iterator@H@std@@QAE@XZ ; std::_Temp_iterator<int>::~_Temp_iterator<int>(void)
.text$mn:00002938                 sub     esp, 10h
.text$mn:0000293B                 mov     edx, esp
.text$mn:0000293D                 mov     eax, [ebp+arg_18]
.text$mn:00002940                 mov     [edx], eax
.text$mn:00002942                 mov     ecx, [ebp+arg_1C]
.text$mn:00002945                 mov     [edx+4], ecx
.text$mn:00002948                 mov     eax, [ebp+arg_20]
.text$mn:0000294B                 mov     [edx+8], eax
.text$mn:0000294E                 mov     ecx, [ebp+arg_24]
.text$mn:00002951                 mov     [edx+0Ch], ecx
.text$mn:00002954                 mov     edx, [ebp+Dst]
.text$mn:00002957                 push    edx             ; Dst
.text$mn:00002958                 mov     eax, [ebp+arg_8]
.text$mn:0000295B                 push    eax             ; int
.text$mn:0000295C                 mov     ecx, [ebp+Src]
.text$mn:0000295F                 push    ecx             ; void *
.text$mn:00002960                 mov     ecx, [ebp+arg_14]
.text$mn:00002963                 call    ?_Last@?$_Temp_iterator@H@std@@QBEPAHXZ ; std::_Temp_iterator<int>::_Last(void)
.text$mn:00002968                 push    eax             ; int
.text$mn:00002969                 mov     ecx, [ebp+arg_14]
.text$mn:0000296C                 call    ?_First@?$_Temp_iterator@H@std@@QBEPAHXZ ; std::_Temp_iterator<int>::_First(void)
.text$mn:00002971                 push    eax             ; Src
.text$mn:00002972                 call    ??$_Merge@PAHPAHPAHUBufferEquivalent@@@std@@YAPAHPAH0000UBufferEquivalent@@@Z ; std::_Merge<int *,int *,int *,BufferEquivalent>(int *,int *,int *,int *,int *,BufferEquivalent)
.text$mn:00002977                 add     esp, 24h
.text$mn:0000297A                 jmp     loc_2BA6
.text$mn:0000297F ; ---------------------------------------------------------------------------
.text$mn:0000297F
.text$mn:0000297F loc_297F:                               ; CODE XREF: std::_Buffered_merge<int *,int,int,BufferEquivalent>(int *,int *,int *,int,int,std::_Temp_iterator<int> &,BufferEquivalent)+99j
.text$mn:0000297F                                         ; std::_Buffered_merge<int *,int,int,BufferEquivalent>(int *,int *,int *,int,int,std::_Temp_iterator<int> &,BufferEquivalent)+AAj
.text$mn:0000297F                 mov     ecx, [ebp+arg_14]
.text$mn:00002982                 call    ?_Maxlen@?$_Temp_iterator@H@std@@QAEHXZ ; std::_Temp_iterator<int>::_Maxlen(void)
.text$mn:00002987                 cmp     [ebp+arg_10], eax
.text$mn:0000298A                 jg      loc_2A23
.text$mn:00002990                 mov     ecx, [ebp+arg_14]
.text$mn:00002993                 call    ?_Init@?$_Temp_iterator@H@std@@QAEAAV12@XZ ; std::_Temp_iterator<int>::_Init(void)
.text$mn:00002998                 sub     esp, 14h
.text$mn:0000299B                 mov     ecx, esp
.text$mn:0000299D                 mov     [ebp+var_38], esp
.text$mn:000029A0                 push    eax
.text$mn:000029A1                 call    ??0?$_Temp_iterator@H@std@@QAE@ABV01@@Z ; std::_Temp_iterator<int>::_Temp_iterator<int>(std::_Temp_iterator<int> const &)
.text$mn:000029A6                 mov     [ebp+var_28], eax
.text$mn:000029A9                 mov     edx, [ebp+var_28]
.text$mn:000029AC                 mov     [ebp+var_3C], edx
.text$mn:000029AF                 mov     [ebp+var_4], 1
.text$mn:000029B6                 mov     eax, [ebp+arg_8]
.text$mn:000029B9                 push    eax
.text$mn:000029BA                 mov     ecx, [ebp+Src]
.text$mn:000029BD                 push    ecx
.text$mn:000029BE                 lea     edx, [ebp+var_68]
.text$mn:000029C1                 push    edx
.text$mn:000029C2                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000029C9                 call    ??$_Move@PAHV?$_Temp_iterator@H@std@@@std@@YA?AV?$_Temp_iterator@H@0@PAH0V10@@Z ; std::_Move<int *,std::_Temp_iterator<int>>(int *,int *,std::_Temp_iterator<int>)
.text$mn:000029CE                 add     esp, 20h
.text$mn:000029D1                 mov     [ebp+var_40], eax
.text$mn:000029D4                 lea     ecx, [ebp+var_68]
.text$mn:000029D7                 call    ??1?$_Temp_iterator@H@std@@QAE@XZ ; std::_Temp_iterator<int>::~_Temp_iterator<int>(void)
.text$mn:000029DC                 sub     esp, 10h
.text$mn:000029DF                 mov     eax, esp
.text$mn:000029E1                 mov     ecx, [ebp+arg_18]
.text$mn:000029E4                 mov     [eax], ecx
.text$mn:000029E6                 mov     edx, [ebp+arg_1C]
.text$mn:000029E9                 mov     [eax+4], edx
.text$mn:000029EC                 mov     ecx, [ebp+arg_20]
.text$mn:000029EF                 mov     [eax+8], ecx
.text$mn:000029F2                 mov     edx, [ebp+arg_24]
.text$mn:000029F5                 mov     [eax+0Ch], edx
.text$mn:000029F8                 mov     eax, [ebp+arg_8]
.text$mn:000029FB                 push    eax             ; int
.text$mn:000029FC                 mov     ecx, [ebp+arg_14]
.text$mn:000029FF                 call    ?_Last@?$_Temp_iterator@H@std@@QBEPAHXZ ; std::_Temp_iterator<int>::_Last(void)
.text$mn:00002A04                 push    eax             ; int
.text$mn:00002A05                 mov     ecx, [ebp+arg_14]
.text$mn:00002A08                 call    ?_First@?$_Temp_iterator@H@std@@QBEPAHXZ ; std::_Temp_iterator<int>::_First(void)
.text$mn:00002A0D                 push    eax             ; Src
.text$mn:00002A0E                 mov     ecx, [ebp+Src]
.text$mn:00002A11                 push    ecx             ; int
.text$mn:00002A12                 mov     edx, [ebp+Dst]
.text$mn:00002A15                 push    edx             ; void *
.text$mn:00002A16                 call    ??$_Merge_backward@PAHPAHPAHUBufferEquivalent@@@std@@YAPAHPAH0000UBufferEquivalent@@@Z ; std::_Merge_backward<int *,int *,int *,BufferEquivalent>(int *,int *,int *,int *,int *,BufferEquivalent)
.text$mn:00002A1B                 add     esp, 24h
.text$mn:00002A1E                 jmp     loc_2BA6
.text$mn:00002A23 ; ---------------------------------------------------------------------------
.text$mn:00002A23
.text$mn:00002A23 loc_2A23:                               ; CODE XREF: std::_Buffered_merge<int *,int,int,BufferEquivalent>(int *,int *,int *,int,int,std::_Temp_iterator<int> &,BufferEquivalent)+14Ej
.text$mn:00002A23                 mov     eax, [ebp+arg_10]
.text$mn:00002A26                 cmp     eax, [ebp+arg_C]
.text$mn:00002A29                 jge     short loc_2A99
.text$mn:00002A2B                 mov     eax, [ebp+arg_C]
.text$mn:00002A2E                 cdq
.text$mn:00002A2F                 sub     eax, edx
.text$mn:00002A31                 sar     eax, 1
.text$mn:00002A33                 mov     [ebp+var_18], eax
.text$mn:00002A36                 mov     [ebp+var_14], 0
.text$mn:00002A3D                 mov     ecx, [ebp+Dst]
.text$mn:00002A40                 mov     [ebp+var_10], ecx
.text$mn:00002A43                 mov     edx, [ebp+var_18]
.text$mn:00002A46                 push    edx
.text$mn:00002A47                 lea     eax, [ebp+var_10]
.text$mn:00002A4A                 push    eax
.text$mn:00002A4B                 call    ??$advance@PAHH@std@@YAXAAPAHH@Z ; std::advance<int *,int>(int * &,int)
.text$mn:00002A50                 add     esp, 0FFFFFFF8h
.text$mn:00002A53                 mov     ecx, esp
.text$mn:00002A55                 mov     edx, [ebp+arg_18]
.text$mn:00002A58                 mov     [ecx], edx
.text$mn:00002A5A                 mov     eax, [ebp+arg_1C]
.text$mn:00002A5D                 mov     [ecx+4], eax
.text$mn:00002A60                 mov     edx, [ebp+arg_20]
.text$mn:00002A63                 mov     [ecx+8], edx
.text$mn:00002A66                 mov     eax, [ebp+arg_24]
.text$mn:00002A69                 mov     [ecx+0Ch], eax
.text$mn:00002A6C                 mov     ecx, [ebp+var_10]
.text$mn:00002A6F                 push    ecx
.text$mn:00002A70                 mov     edx, [ebp+arg_8]
.text$mn:00002A73                 push    edx
.text$mn:00002A74                 mov     eax, [ebp+Src]
.text$mn:00002A77                 push    eax
.text$mn:00002A78                 call    ??$lower_bound@PAHHUBufferEquivalent@@@std@@YAPAHPAH0ABHUBufferEquivalent@@@Z ; std::lower_bound<int *,int,BufferEquivalent>(int *,int *,int const &,BufferEquivalent)
.text$mn:00002A7D                 add     esp, 1Ch
.text$mn:00002A80                 mov     [ebp+var_1C], eax
.text$mn:00002A83                 lea     ecx, [ebp+var_14]
.text$mn:00002A86                 push    ecx
.text$mn:00002A87                 mov     edx, [ebp+var_1C]
.text$mn:00002A8A                 push    edx
.text$mn:00002A8B                 mov     eax, [ebp+Src]
.text$mn:00002A8E                 push    eax
.text$mn:00002A8F                 call    ??$_Distance@PAHH@std@@YAXPAH0AAH@Z ; std::_Distance<int *,int>(int *,int *,int &)
.text$mn:00002A94                 add     esp, 0Ch
.text$mn:00002A97                 jmp     short loc_2B05
.text$mn:00002A99 ; ---------------------------------------------------------------------------
.text$mn:00002A99
.text$mn:00002A99 loc_2A99:                               ; CODE XREF: std::_Buffered_merge<int *,int,int,BufferEquivalent>(int *,int *,int *,int,int,std::_Temp_iterator<int> &,BufferEquivalent)+1EDj
.text$mn:00002A99                 mov     [ebp+var_18], 0
.text$mn:00002AA0                 mov     eax, [ebp+arg_10]
.text$mn:00002AA3                 cdq
.text$mn:00002AA4                 sub     eax, edx
.text$mn:00002AA6                 sar     eax, 1
.text$mn:00002AA8                 mov     [ebp+var_14], eax
.text$mn:00002AAB                 mov     ecx, [ebp+Src]
.text$mn:00002AAE                 mov     [ebp+var_1C], ecx
.text$mn:00002AB1                 mov     edx, [ebp+var_14]
.text$mn:00002AB4                 push    edx
.text$mn:00002AB5                 lea     eax, [ebp+var_1C]
.text$mn:00002AB8                 push    eax
.text$mn:00002AB9                 call    ??$advance@PAHH@std@@YAXAAPAHH@Z ; std::advance<int *,int>(int * &,int)
.text$mn:00002ABE                 add     esp, 0FFFFFFF8h
.text$mn:00002AC1                 mov     ecx, esp
.text$mn:00002AC3                 mov     edx, [ebp+arg_18]
.text$mn:00002AC6                 mov     [ecx], edx
.text$mn:00002AC8                 mov     eax, [ebp+arg_1C]
.text$mn:00002ACB                 mov     [ecx+4], eax
.text$mn:00002ACE                 mov     edx, [ebp+arg_20]
.text$mn:00002AD1                 mov     [ecx+8], edx
.text$mn:00002AD4                 mov     eax, [ebp+arg_24]
.text$mn:00002AD7                 mov     [ecx+0Ch], eax
.text$mn:00002ADA                 mov     ecx, [ebp+var_1C]
.text$mn:00002ADD                 push    ecx
.text$mn:00002ADE                 mov     edx, [ebp+Src]
.text$mn:00002AE1                 push    edx
.text$mn:00002AE2                 mov     eax, [ebp+Dst]
.text$mn:00002AE5                 push    eax
.text$mn:00002AE6                 call    ??$upper_bound@PAHHUBufferEquivalent@@@std@@YAPAHPAH0ABHUBufferEquivalent@@@Z ; std::upper_bound<int *,int,BufferEquivalent>(int *,int *,int const &,BufferEquivalent)
.text$mn:00002AEB                 add     esp, 1Ch
.text$mn:00002AEE                 mov     [ebp+var_10], eax
.text$mn:00002AF1                 lea     ecx, [ebp+var_18]
.text$mn:00002AF4                 push    ecx
.text$mn:00002AF5                 mov     edx, [ebp+var_10]
.text$mn:00002AF8
.text$mn:00002AF8 ; const WCHAR MenuName
.text$mn:00002AF8 MenuName:                               ; DATA XREF: WindowsMenu::init(HINSTANCE__ *,HMENU__ *,wchar_t const *)+2Eo
.text$mn:00002AF8                 push    edx
.text$mn:00002AF9                 mov     eax, [ebp+Dst]
.text$mn:00002AFC                 push    eax
.text$mn:00002AFD                 call    ??$_Distance@PAHH@std@@YAXPAH0AAH@Z ; std::_Distance<int *,int>(int *,int *,int &)
.text$mn:00002B02                 add     esp, 0Ch
.text$mn:00002B05
.text$mn:00002B05 loc_2B05:                               ; CODE XREF: std::_Buffered_merge<int *,int,int,BufferEquivalent>(int *,int *,int *,int,int,std::_Temp_iterator<int> &,BufferEquivalent)+25Bj
.text$mn:00002B05                 mov     ecx, [ebp+arg_14]
.text$mn:00002B08                 push    ecx             ; int
.text$mn:00002B09                 mov     edx, [ebp+var_14]
.text$mn:00002B0C                 push    edx             ; int
.text$mn:00002B0D                 mov     eax, [ebp+arg_C]
.text$mn:00002B10                 sub     eax, [ebp+var_18]
.text$mn:00002B13                 push    eax             ; int
.text$mn:00002B14                 mov     ecx, [ebp+var_1C]
.text$mn:00002B17                 push    ecx             ; int
.text$mn:00002B18                 mov     edx, [ebp+Src]
.text$mn:00002B1B                 push    edx             ; Src
.text$mn:00002B1C                 mov     eax, [ebp+var_10]
.text$mn:00002B1F                 push    eax             ; Dst
.text$mn:00002B20                 call    ??$_Buffered_rotate@PAHHH@std@@YAPAHPAH00HHAAV?$_Temp_iterator@H@0@@Z ; std::_Buffered_rotate<int *,int,int>(int *,int *,int *,int,int,std::_Temp_iterator<int> &)
.text$mn:00002B25                 add     esp, 18h
.text$mn:00002B28                 mov     [ebp+var_20], eax
.text$mn:00002B2B                 sub     esp, 10h
.text$mn:00002B2E                 mov     ecx, esp
.text$mn:00002B30                 mov     edx, [ebp+arg_18]
.text$mn:00002B33                 mov     [ecx], edx
.text$mn:00002B35                 mov     eax, [ebp+arg_1C]
.text$mn:00002B38                 mov     [ecx+4], eax
.text$mn:00002B3B                 mov     edx, [ebp+arg_20]
.text$mn:00002B3E                 mov     [ecx+8], edx
.text$mn:00002B41                 mov     eax, [ebp+arg_24]
.text$mn:00002B44                 mov     [ecx+0Ch], eax
.text$mn:00002B47                 mov     ecx, [ebp+arg_14]
.text$mn:00002B4A                 push    ecx             ; int
.text$mn:00002B4B                 mov     edx, [ebp+var_14]
.text$mn:00002B4E                 push    edx             ; int
.text$mn:00002B4F                 mov     eax, [ebp+var_18]
.text$mn:00002B52                 push    eax             ; int
.text$mn:00002B53                 mov     ecx, [ebp+var_20]
.text$mn:00002B56                 push    ecx             ; int
.text$mn:00002B57                 mov     edx, [ebp+var_10]
.text$mn:00002B5A                 push    edx             ; Src
.text$mn:00002B5B                 mov     eax, [ebp+Dst]
.text$mn:00002B5E                 push    eax             ; Dst
.text$mn:00002B5F                 call    ??$_Buffered_merge@PAHHHUBufferEquivalent@@@std@@YAXPAH00HHAAV?$_Temp_iterator@H@0@UBufferEquivalent@@@Z ; std::_Buffered_merge<int *,int,int,BufferEquivalent>(int *,int *,int *,int,int,std::_Temp_iterator<int> &,BufferEquivalent)
.text$mn:00002B64                 add     esp, 18h
.text$mn:00002B67                 mov     ecx, esp
.text$mn:00002B69                 mov     edx, [ebp+arg_18]
.text$mn:00002B6C                 mov     [ecx], edx
.text$mn:00002B6E                 mov     eax, [ebp+arg_1C]
.text$mn:00002B71                 mov     [ecx+4], eax
.text$mn:00002B74                 mov     edx, [ebp+arg_20]
.text$mn:00002B77                 mov     [ecx+8], edx
.text$mn:00002B7A                 mov     eax, [ebp+arg_24]
.text$mn:00002B7D                 mov     [ecx+0Ch], eax
.text$mn:00002B80                 mov     ecx, [ebp+arg_14]
.text$mn:00002B83                 push    ecx             ; int
.text$mn:00002B84                 mov     edx, [ebp+arg_10]
.text$mn:00002B87                 sub     edx, [ebp+var_14]
.text$mn:00002B8A                 push    edx             ; int
.text$mn:00002B8B                 mov     eax, [ebp+arg_C]
.text$mn:00002B8E                 sub     eax, [ebp+var_18]
.text$mn:00002B91                 push    eax             ; int
.text$mn:00002B92                 mov     ecx, [ebp+arg_8]
.text$mn:00002B95                 push    ecx             ; int
.text$mn:00002B96                 mov     edx, [ebp+var_1C]
.text$mn:00002B99                 push    edx             ; Src
.text$mn:00002B9A                 mov     eax, [ebp+var_20]
.text$mn:00002B9D                 push    eax             ; Dst
.text$mn:00002B9E                 call    ??$_Buffered_merge@PAHHHUBufferEquivalent@@@std@@YAXPAH00HHAAV?$_Temp_iterator@H@0@UBufferEquivalent@@@Z ; std::_Buffered_merge<int *,int,int,BufferEquivalent>(int *,int *,int *,int,int,std::_Temp_iterator<int> &,BufferEquivalent)
.text$mn:00002BA3                 add     esp, 28h
.text$mn:00002BA6
.text$mn:00002BA6 loc_2BA6:                               ; CODE XREF: std::_Buffered_merge<int *,int,int,BufferEquivalent>(int *,int *,int *,int,int,std::_Temp_iterator<int> &,BufferEquivalent):loc_286Dj
.text$mn:00002BA6                                         ; std::_Buffered_merge<int *,int,int,BufferEquivalent>(int *,int *,int *,int,int,std::_Temp_iterator<int> &,BufferEquivalent):loc_28CAj ...
.text$mn:00002BA6                 mov     ecx, [ebp+var_C]
.text$mn:00002BA9                 mov     large fs:0, ecx
.text$mn:00002BB0                 pop     ecx
.text$mn:00002BB1                 mov     esp, ebp
.text$mn:00002BB3                 pop     ebp
.text$mn:00002BB4                 retn
.text$mn:00002BB4 ??$_Buffered_merge@PAHHHUBufferEquivalent@@@std@@YAXPAH00HHAAV?$_Temp_iterator@H@0@UBufferEquivalent@@@Z endp
.text$mn:00002BB4
.text$mn:00002BB4 ; ---------------------------------------------------------------------------
.text$mn:00002BB5                 align 4
.text$mn:00002BB5 _text$mn        ends
.text$mn:00002BB5
.text$x:00002BB8 ; ===========================================================================
.text$x:00002BB8
.text$x:00002BB8 ; Segment type: Pure code
.text$x:00002BB8 ; Segment permissions: Read/Execute
.text$x:00002BB8 _text$x         segment para public 'CODE' use32
.text$x:00002BB8                 assume cs:_text$x
.text$x:00002BB8                 ;org 2BB8h
.text$x:00002BB8 ; COMDAT (pick associative to section at 283C)
.text$x:00002BB8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00002BB8
.text$x:00002BB8 ; =============== S U B R O U T I N E =======================================
.text$x:00002BB8
.text$x:00002BB8
.text$x:00002BB8 __unwindfunclet$??$_Buffered_merge@PAHHHUBufferEquivalent@@@std@@YAXPAH00HHAAV?$_Temp_iterator@H@0@UBufferEquivalent@@@Z$0 proc near
.text$x:00002BB8                                         ; DATA XREF: .xdata$x:0000D97Co
.text$x:00002BB8                 mov     ecx, [ebp-2Ch]
.text$x:00002BBB                 jmp     ??1?$_Temp_iterator@H@std@@QAE@XZ ; std::_Temp_iterator<int>::~_Temp_iterator<int>(void)
.text$x:00002BBB __unwindfunclet$??$_Buffered_merge@PAHHHUBufferEquivalent@@@std@@YAXPAH00HHAAV?$_Temp_iterator@H@0@UBufferEquivalent@@@Z$0 endp
.text$x:00002BBB
.text$x:00002BC0
.text$x:00002BC0 ; =============== S U B R O U T I N E =======================================
.text$x:00002BC0
.text$x:00002BC0
.text$x:00002BC0 __unwindfunclet$??$_Buffered_merge@PAHHHUBufferEquivalent@@@std@@YAXPAH00HHAAV?$_Temp_iterator@H@0@UBufferEquivalent@@@Z$2 proc near
.text$x:00002BC0                                         ; DATA XREF: .xdata$x:0000D984o
.text$x:00002BC0                 mov     ecx, [ebp-38h]
.text$x:00002BC3                 jmp     ??1?$_Temp_iterator@H@std@@QAE@XZ ; std::_Temp_iterator<int>::~_Temp_iterator<int>(void)
.text$x:00002BC3 __unwindfunclet$??$_Buffered_merge@PAHHHUBufferEquivalent@@@std@@YAXPAH00HHAAV?$_Temp_iterator@H@0@UBufferEquivalent@@@Z$2 endp
.text$x:00002BC3
.text$x:00002BC8
.text$x:00002BC8 ; =============== S U B R O U T I N E =======================================
.text$x:00002BC8
.text$x:00002BC8
.text$x:00002BC8 __ehhandler$??$_Buffered_merge@PAHHHUBufferEquivalent@@@std@@YAXPAH00HHAAV?$_Temp_iterator@H@0@UBufferEquivalent@@@Z proc near
.text$x:00002BC8                                         ; DATA XREF: std::_Buffered_merge<int *,int,int,BufferEquivalent>(int *,int *,int *,int,int,std::_Temp_iterator<int> &,BufferEquivalent)+5o
.text$x:00002BC8
.text$x:00002BC8 arg_4           = dword ptr  8
.text$x:00002BC8
.text$x:00002BC8                 mov     edx, [esp+arg_4]
.text$x:00002BCC                 lea     eax, [edx+0Ch]
.text$x:00002BCF                 mov     ecx, [edx-60h]
.text$x:00002BD2                 xor     ecx, eax
.text$x:00002BD4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002BD9                 mov     eax, offset __ehfuncinfo$??$_Buffered_merge@PAHHHUBufferEquivalent@@@std@@YAXPAH00HHAAV?$_Temp_iterator@H@0@UBufferEquivalent@@@Z
.text$x:00002BDE                 jmp     ___CxxFrameHandler3
.text$x:00002BDE __ehhandler$??$_Buffered_merge@PAHHHUBufferEquivalent@@@std@@YAXPAH00HHAAV?$_Temp_iterator@H@0@UBufferEquivalent@@@Z endp
.text$x:00002BDE
.text$x:00002BDE ; ---------------------------------------------------------------------------
.text$x:00002BE3                 align 4
.text$x:00002BE3 _text$x         ends
.text$x:00002BE3
.text$mn:00002BE4 ; ===========================================================================
.text$mn:00002BE4
.text$mn:00002BE4 ; Segment type: Pure code
.text$mn:00002BE4 ; Segment permissions: Read/Execute
.text$mn:00002BE4 _text$mn        segment para public 'CODE' use32
.text$mn:00002BE4                 assume cs:_text$mn
.text$mn:00002BE4                 ;org 2BE4h
.text$mn:00002BE4 ; COMDAT (pick any)
.text$mn:00002BE4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002BE4
.text$mn:00002BE4 ; =============== S U B R O U T I N E =======================================
.text$mn:00002BE4
.text$mn:00002BE4 ; Attributes: bp-based frame
.text$mn:00002BE4
.text$mn:00002BE4 ; int __cdecl std::_Buffered_merge_sort<int *,int,int,BufferEquivalent>(void *Dst, int, int, int, int, int, int, int)
.text$mn:00002BE4                 public ??$_Buffered_merge_sort@PAHHHUBufferEquivalent@@@std@@YAXPAH0HAAV?$_Temp_iterator@H@0@UBufferEquivalent@@@Z
.text$mn:00002BE4 ??$_Buffered_merge_sort@PAHHHUBufferEquivalent@@@std@@YAXPAH0HAAV?$_Temp_iterator@H@0@UBufferEquivalent@@@Z proc near
.text$mn:00002BE4                                         ; CODE XREF: std::_Stable_sort<int *,int,int,BufferEquivalent>(int *,int *,int,std::_Temp_iterator<int> &,BufferEquivalent)+9Ap
.text$mn:00002BE4                                         ; std::_Stable_sort<int *,int,int,BufferEquivalent>(int *,int *,int,std::_Temp_iterator<int> &,BufferEquivalent)+CEp
.text$mn:00002BE4
.text$mn:00002BE4 var_28          = dword ptr -28h
.text$mn:00002BE4 var_24          = dword ptr -24h
.text$mn:00002BE4 var_20          = dword ptr -20h
.text$mn:00002BE4 var_1C          = dword ptr -1Ch
.text$mn:00002BE4 var_18          = dword ptr -18h
.text$mn:00002BE4 Src             = dword ptr -14h
.text$mn:00002BE4 var_10          = dword ptr -10h
.text$mn:00002BE4 var_C           = dword ptr -0Ch
.text$mn:00002BE4 var_4           = dword ptr -4
.text$mn:00002BE4 Dst             = dword ptr  8
.text$mn:00002BE4 arg_4           = dword ptr  0Ch
.text$mn:00002BE4 arg_8           = dword ptr  10h
.text$mn:00002BE4 arg_C           = dword ptr  14h
.text$mn:00002BE4 arg_10          = dword ptr  18h
.text$mn:00002BE4 arg_14          = dword ptr  1Ch
.text$mn:00002BE4 arg_18          = dword ptr  20h
.text$mn:00002BE4 arg_1C          = dword ptr  24h
.text$mn:00002BE4
.text$mn:00002BE4                 push    ebp
.text$mn:00002BE5                 mov     ebp, esp
.text$mn:00002BE7                 push    0FFFFFFFFh
.text$mn:00002BE9                 push    offset __ehhandler$??$_Buffered_merge_sort@PAHHHUBufferEquivalent@@@std@@YAXPAH0HAAV?$_Temp_iterator@H@0@UBufferEquivalent@@@Z
.text$mn:00002BEE                 mov     eax, large fs:0
.text$mn:00002BF4                 push    eax
.text$mn:00002BF5                 sub     esp, 1Ch
.text$mn:00002BF8                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002BFD                 xor     eax, ebp
.text$mn:00002BFF                 push    eax
.text$mn:00002C00                 lea     eax, [ebp+var_C]
.text$mn:00002C03                 mov     large fs:0, eax
.text$mn:00002C09                 mov     eax, [ebp+Dst]
.text$mn:00002C0C                 mov     [ebp+Src], eax
.text$mn:00002C0F                 mov     ecx, [ebp+arg_8]
.text$mn:00002C12                 mov     [ebp+var_18], ecx
.text$mn:00002C15                 jmp     short loc_2C20
.text$mn:00002C17 ; ---------------------------------------------------------------------------
.text$mn:00002C17
.text$mn:00002C17 loc_2C17:                               ; CODE XREF: std::_Buffered_merge_sort<int *,int,int,BufferEquivalent>(int *,int *,int,std::_Temp_iterator<int> &,BufferEquivalent)+85j
.text$mn:00002C17                 mov     edx, [ebp+var_18]
.text$mn:00002C1A                 sub     edx, 20h ; ' '
.text$mn:00002C1D                 mov     [ebp+var_18], edx
.text$mn:00002C20
.text$mn:00002C20 loc_2C20:                               ; CODE XREF: std::_Buffered_merge_sort<int *,int,int,BufferEquivalent>(int *,int *,int,std::_Temp_iterator<int> &,BufferEquivalent)+31j
.text$mn:00002C20                 cmp     [ebp+var_18], 20h ; ' '
.text$mn:00002C24                 jl      short loc_2C6B
.text$mn:00002C26                 mov     eax, [ebp+Src]
.text$mn:00002C29                 mov     [ebp+var_1C], eax
.text$mn:00002C2C                 push    20h ; ' '       ; int
.text$mn:00002C2E                 lea     ecx, [ebp+var_1C]
.text$mn:00002C31                 push    ecx             ; int
.text$mn:00002C32                 call    ??$advance@PAHH@std@@YAXAAPAHH@Z ; std::advance<int *,int>(int * &,int)
.text$mn:00002C37                 add     esp, 0FFFFFFF8h
.text$mn:00002C3A                 mov     edx, esp
.text$mn:00002C3C                 mov     eax, [ebp+arg_10]
.text$mn:00002C3F                 mov     [edx], eax
.text$mn:00002C41                 mov     ecx, [ebp+arg_14]
.text$mn:00002C44                 mov     [edx+4], ecx
.text$mn:00002C47                 mov     eax, [ebp+arg_18]
.text$mn:00002C4A                 mov     [edx+8], eax
.text$mn:00002C4D                 mov     ecx, [ebp+arg_1C]
.text$mn:00002C50                 mov     [edx+0Ch], ecx
.text$mn:00002C53                 mov     edx, [ebp+var_1C]
.text$mn:00002C56                 push    edx             ; int
.text$mn:00002C57                 mov     eax, [ebp+Src]
.text$mn:00002C5A                 push    eax             ; Src
.text$mn:00002C5B                 call    ??$_Insertion_sort@PAHUBufferEquivalent@@@std@@YAXPAH0UBufferEquivalent@@@Z ; std::_Insertion_sort<int *,BufferEquivalent>(int *,int *,BufferEquivalent)
.text$mn:00002C60                 add     esp, 18h
.text$mn:00002C63                 mov     ecx, [ebp+var_1C]
.text$mn:00002C66                 mov     [ebp+Src], ecx
.text$mn:00002C69                 jmp     short loc_2C17
.text$mn:00002C6B ; ---------------------------------------------------------------------------
.text$mn:00002C6B
.text$mn:00002C6B loc_2C6B:                               ; CODE XREF: std::_Buffered_merge_sort<int *,int,int,BufferEquivalent>(int *,int *,int,std::_Temp_iterator<int> &,BufferEquivalent)+40j
.text$mn:00002C6B                 sub     esp, 10h
.text$mn:00002C6E                 mov     edx, esp
.text$mn:00002C70                 mov     eax, [ebp+arg_10]
.text$mn:00002C73                 mov     [edx], eax
.text$mn:00002C75                 mov     ecx, [ebp+arg_14]
.text$mn:00002C78                 mov     [edx+4], ecx
.text$mn:00002C7B                 mov     eax, [ebp+arg_18]
.text$mn:00002C7E                 mov     [edx+8], eax
.text$mn:00002C81                 mov     ecx, [ebp+arg_1C]
.text$mn:00002C84                 mov     [edx+0Ch], ecx
.text$mn:00002C87                 mov     edx, [ebp+arg_4]
.text$mn:00002C8A                 push    edx             ; int
.text$mn:00002C8B                 mov     eax, [ebp+Src]
.text$mn:00002C8E                 push    eax             ; Src
.text$mn:00002C8F                 call    ??$_Insertion_sort@PAHUBufferEquivalent@@@std@@YAXPAH0UBufferEquivalent@@@Z ; std::_Insertion_sort<int *,BufferEquivalent>(int *,int *,BufferEquivalent)
.text$mn:00002C94                 add     esp, 18h
.text$mn:00002C97                 mov     [ebp+var_10], 20h ; ' '
.text$mn:00002C9E                 jmp     short loc_2CA8
.text$mn:00002CA0 ; ---------------------------------------------------------------------------
.text$mn:00002CA0
.text$mn:00002CA0 loc_2CA0:                               ; CODE XREF: std::_Buffered_merge_sort<int *,int,int,BufferEquivalent>(int *,int *,int,std::_Temp_iterator<int> &,BufferEquivalent)+17Bj
.text$mn:00002CA0                 mov     ecx, [ebp+var_10]
.text$mn:00002CA3                 shl     ecx, 1
.text$mn:00002CA5                 mov     [ebp+var_10], ecx
.text$mn:00002CA8
.text$mn:00002CA8 loc_2CA8:                               ; CODE XREF: std::_Buffered_merge_sort<int *,int,int,BufferEquivalent>(int *,int *,int,std::_Temp_iterator<int> &,BufferEquivalent)+BAj
.text$mn:00002CA8                 mov     edx, [ebp+var_10]
.text$mn:00002CAB                 cmp     edx, [ebp+arg_8]
.text$mn:00002CAE                 jge     loc_2D64
.text$mn:00002CB4                 sub     esp, 10h
.text$mn:00002CB7                 mov     eax, esp
.text$mn:00002CB9                 mov     ecx, [ebp+arg_10]
.text$mn:00002CBC                 mov     [eax], ecx
.text$mn:00002CBE                 mov     edx, [ebp+arg_14]
.text$mn:00002CC1                 mov     [eax+4], edx
.text$mn:00002CC4                 mov     ecx, [ebp+arg_18]
.text$mn:00002CC7                 mov     [eax+8], ecx
.text$mn:00002CCA                 mov     edx, [ebp+arg_1C]
.text$mn:00002CCD                 mov     [eax+0Ch], edx
.text$mn:00002CD0                 mov     eax, [ebp+arg_8]
.text$mn:00002CD3                 push    eax
.text$mn:00002CD4                 mov     ecx, [ebp+var_10]
.text$mn:00002CD7                 push    ecx
.text$mn:00002CD8                 mov     ecx, [ebp+arg_C]
.text$mn:00002CDB                 call    ?_Init@?$_Temp_iterator@H@std@@QAEAAV12@XZ ; std::_Temp_iterator<int>::_Init(void)
.text$mn:00002CE0                 sub     esp, 14h
.text$mn:00002CE3                 mov     ecx, esp
.text$mn:00002CE5                 mov     [ebp+var_24], esp
.text$mn:00002CE8                 push    eax
.text$mn:00002CE9                 call    ??0?$_Temp_iterator@H@std@@QAE@ABV01@@Z ; std::_Temp_iterator<int>::_Temp_iterator<int>(std::_Temp_iterator<int> const &)
.text$mn:00002CEE                 mov     [ebp+var_20], eax
.text$mn:00002CF1                 mov     edx, [ebp+var_20]
.text$mn:00002CF4                 mov     [ebp+var_28], edx
.text$mn:00002CF7                 mov     [ebp+var_4], 0
.text$mn:00002CFE                 mov     eax, [ebp+arg_4]
.text$mn:00002D01                 push    eax
.text$mn:00002D02                 mov     ecx, [ebp+Dst]
.text$mn:00002D05                 push    ecx
.text$mn:00002D06                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002D0D                 call    ??$_Chunked_merge@PAHV?$_Temp_iterator@H@std@@HUBufferEquivalent@@@std@@YAXPAH0V?$_Temp_iterator@H@0@HHUBufferEquivalent@@@Z ; std::_Chunked_merge<int *,std::_Temp_iterator<int>,int,BufferEquivalent>(int *,int *,std::_Temp_iterator<int>,int,int,BufferEquivalent)
.text$mn:00002D12                 add     esp, 34h
.text$mn:00002D15                 mov     edx, [ebp+var_10]
.text$mn:00002D18                 shl     edx, 1
.text$mn:00002D1A                 mov     [ebp+var_10], edx
.text$mn:00002D1D                 sub     esp, 10h
.text$mn:00002D20                 mov     eax, esp
.text$mn:00002D22                 mov     ecx, [ebp+arg_10]
.text$mn:00002D25                 mov     [eax], ecx
.text$mn:00002D27                 mov     edx, [ebp+arg_14]
.text$mn:00002D2A                 mov     [eax+4], edx
.text$mn:00002D2D                 mov     ecx, [ebp+arg_18]
.text$mn:00002D30                 mov     [eax+8], ecx
.text$mn:00002D33                 mov     edx, [ebp+arg_1C]
.text$mn:00002D36                 mov     [eax+0Ch], edx
.text$mn:00002D39                 mov     eax, [ebp+arg_8]
.text$mn:00002D3C                 push    eax             ; int
.text$mn:00002D3D                 mov     ecx, [ebp+var_10]
.text$mn:00002D40                 push    ecx             ; int
.text$mn:00002D41                 mov     edx, [ebp+Dst]
.text$mn:00002D44                 push    edx             ; Dst
.text$mn:00002D45                 mov     ecx, [ebp+arg_C]
.text$mn:00002D48                 call    ?_Last@?$_Temp_iterator@H@std@@QBEPAHXZ ; std::_Temp_iterator<int>::_Last(void)
.text$mn:00002D4D                 push    eax             ; int
.text$mn:00002D4E                 mov     ecx, [ebp+arg_C]
.text$mn:00002D51                 call    ?_First@?$_Temp_iterator@H@std@@QBEPAHXZ ; std::_Temp_iterator<int>::_First(void)
.text$mn:00002D56                 push    eax             ; Src
.text$mn:00002D57                 call    ??$_Chunked_merge@PAHPAHHUBufferEquivalent@@@std@@YAXPAH00HHUBufferEquivalent@@@Z ; std::_Chunked_merge<int *,int *,int,BufferEquivalent>(int *,int *,int *,int,int,BufferEquivalent)
.text$mn:00002D5C                 add     esp, 24h
.text$mn:00002D5F                 jmp     loc_2CA0
.text$mn:00002D64 ; ---------------------------------------------------------------------------
.text$mn:00002D64
.text$mn:00002D64 loc_2D64:                               ; CODE XREF: std::_Buffered_merge_sort<int *,int,int,BufferEquivalent>(int *,int *,int,std::_Temp_iterator<int> &,BufferEquivalent)+CAj
.text$mn:00002D64                 mov     ecx, [ebp+var_C]
.text$mn:00002D67                 mov     large fs:0, ecx
.text$mn:00002D6E                 pop     ecx
.text$mn:00002D6F                 mov     esp, ebp
.text$mn:00002D71                 pop     ebp
.text$mn:00002D72                 retn
.text$mn:00002D72 ??$_Buffered_merge_sort@PAHHHUBufferEquivalent@@@std@@YAXPAH0HAAV?$_Temp_iterator@H@0@UBufferEquivalent@@@Z endp
.text$mn:00002D72
.text$mn:00002D72 ; ---------------------------------------------------------------------------
.text$mn:00002D73                 align 4
.text$mn:00002D73 _text$mn        ends
.text$mn:00002D73
.text$x:00002D74 ; ===========================================================================
.text$x:00002D74
.text$x:00002D74 ; Segment type: Pure code
.text$x:00002D74 ; Segment permissions: Read/Execute
.text$x:00002D74 _text$x         segment para public 'CODE' use32
.text$x:00002D74                 assume cs:_text$x
.text$x:00002D74                 ;org 2D74h
.text$x:00002D74 ; COMDAT (pick associative to section at 2BE4)
.text$x:00002D74                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00002D74
.text$x:00002D74 ; =============== S U B R O U T I N E =======================================
.text$x:00002D74
.text$x:00002D74
.text$x:00002D74 __unwindfunclet$??$_Buffered_merge_sort@PAHHHUBufferEquivalent@@@std@@YAXPAH0HAAV?$_Temp_iterator@H@0@UBufferEquivalent@@@Z$0 proc near
.text$x:00002D74                                         ; DATA XREF: .xdata$x:0000D950o
.text$x:00002D74                 mov     ecx, [ebp-24h]
.text$x:00002D77                 jmp     ??1?$_Temp_iterator@H@std@@QAE@XZ ; std::_Temp_iterator<int>::~_Temp_iterator<int>(void)
.text$x:00002D77 __unwindfunclet$??$_Buffered_merge_sort@PAHHHUBufferEquivalent@@@std@@YAXPAH0HAAV?$_Temp_iterator@H@0@UBufferEquivalent@@@Z$0 endp
.text$x:00002D77
.text$x:00002D7C
.text$x:00002D7C ; =============== S U B R O U T I N E =======================================
.text$x:00002D7C
.text$x:00002D7C
.text$x:00002D7C __ehhandler$??$_Buffered_merge_sort@PAHHHUBufferEquivalent@@@std@@YAXPAH0HAAV?$_Temp_iterator@H@0@UBufferEquivalent@@@Z proc near
.text$x:00002D7C                                         ; DATA XREF: std::_Buffered_merge_sort<int *,int,int,BufferEquivalent>(int *,int *,int,std::_Temp_iterator<int> &,BufferEquivalent)+5o
.text$x:00002D7C
.text$x:00002D7C arg_4           = dword ptr  8
.text$x:00002D7C
.text$x:00002D7C                 mov     edx, [esp+arg_4]
.text$x:00002D80                 lea     eax, [edx+0Ch]
.text$x:00002D83                 mov     ecx, [edx-20h]
.text$x:00002D86                 xor     ecx, eax
.text$x:00002D88                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002D8D                 mov     eax, offset __ehfuncinfo$??$_Buffered_merge_sort@PAHHHUBufferEquivalent@@@std@@YAXPAH0HAAV?$_Temp_iterator@H@0@UBufferEquivalent@@@Z
.text$x:00002D92                 jmp     ___CxxFrameHandler3
.text$x:00002D92 __ehhandler$??$_Buffered_merge_sort@PAHHHUBufferEquivalent@@@std@@YAXPAH0HAAV?$_Temp_iterator@H@0@UBufferEquivalent@@@Z endp
.text$x:00002D92
.text$x:00002D92 ; ---------------------------------------------------------------------------
.text$x:00002D97                 align 4
.text$x:00002D97 _text$x         ends
.text$x:00002D97
.text$mn:00002D98 ; ===========================================================================
.text$mn:00002D98
.text$mn:00002D98 ; Segment type: Pure code
.text$mn:00002D98 ; Segment permissions: Read/Execute
.text$mn:00002D98 _text$mn        segment para public 'CODE' use32
.text$mn:00002D98                 assume cs:_text$mn
.text$mn:00002D98                 ;org 2D98h
.text$mn:00002D98 ; COMDAT (pick any)
.text$mn:00002D98                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002D98
.text$mn:00002D98 ; =============== S U B R O U T I N E =======================================
.text$mn:00002D98
.text$mn:00002D98 ; Attributes: bp-based frame
.text$mn:00002D98
.text$mn:00002D98 ; int __cdecl std::_Buffered_rotate<int *,int,int>(void *Dst, void *Src, int, int, int, int)
.text$mn:00002D98                 public ??$_Buffered_rotate@PAHHH@std@@YAPAHPAH00HHAAV?$_Temp_iterator@H@0@@Z
.text$mn:00002D98 ??$_Buffered_rotate@PAHHH@std@@YAPAHPAH00HHAAV?$_Temp_iterator@H@0@@Z proc near
.text$mn:00002D98                                         ; CODE XREF: std::_Buffered_merge<int *,int,int,BufferEquivalent>(int *,int *,int *,int,int,std::_Temp_iterator<int> &,BufferEquivalent)+2E4p
.text$mn:00002D98
.text$mn:00002D98 var_54          = byte ptr -54h
.text$mn:00002D98 var_40          = byte ptr -40h
.text$mn:00002D98 var_2C          = dword ptr -2Ch
.text$mn:00002D98 var_28          = dword ptr -28h
.text$mn:00002D98 var_24          = dword ptr -24h
.text$mn:00002D98 var_20          = dword ptr -20h
.text$mn:00002D98 var_1C          = dword ptr -1Ch
.text$mn:00002D98 var_18          = dword ptr -18h
.text$mn:00002D98 var_14          = dword ptr -14h
.text$mn:00002D98 var_10          = dword ptr -10h
.text$mn:00002D98 var_C           = dword ptr -0Ch
.text$mn:00002D98 var_4           = dword ptr -4
.text$mn:00002D98 Dst             = dword ptr  8
.text$mn:00002D98 Src             = dword ptr  0Ch
.text$mn:00002D98 arg_8           = dword ptr  10h
.text$mn:00002D98 arg_C           = dword ptr  14h
.text$mn:00002D98 arg_10          = dword ptr  18h
.text$mn:00002D98 arg_14          = dword ptr  1Ch
.text$mn:00002D98
.text$mn:00002D98                 push    ebp
.text$mn:00002D99                 mov     ebp, esp
.text$mn:00002D9B                 push    0FFFFFFFFh
.text$mn:00002D9D                 push    offset __ehhandler$??$_Buffered_rotate@PAHHH@std@@YAPAHPAH00HHAAV?$_Temp_iterator@H@0@@Z
.text$mn:00002DA2                 mov     eax, large fs:0
.text$mn:00002DA8                 push    eax
.text$mn:00002DA9                 sub     esp, 48h
.text$mn:00002DAC                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002DB1                 xor     eax, ebp
.text$mn:00002DB3                 push    eax
.text$mn:00002DB4                 lea     eax, [ebp+var_C]
.text$mn:00002DB7                 mov     large fs:0, eax
.text$mn:00002DBD                 cmp     [ebp+arg_C], 0
.text$mn:00002DC1                 jz      short loc_2DC9
.text$mn:00002DC3                 cmp     [ebp+arg_10], 0
.text$mn:00002DC7                 jnz     short loc_2DE6
.text$mn:00002DC9
.text$mn:00002DC9 loc_2DC9:                               ; CODE XREF: std::_Buffered_rotate<int *,int,int>(int *,int *,int *,int,int,std::_Temp_iterator<int> &)+29j
.text$mn:00002DC9                 mov     eax, [ebp+arg_10]
.text$mn:00002DCC                 push    eax
.text$mn:00002DCD                 lea     ecx, [ebp+Dst]
.text$mn:00002DD0                 push    ecx
.text$mn:00002DD1                 call    ??$advance@PAHH@std@@YAXAAPAHH@Z ; std::advance<int *,int>(int * &,int)
.text$mn:00002DD6                 add     esp, 8
.text$mn:00002DD9                 mov     eax, [ebp+Dst]
.text$mn:00002DDC                 jmp     loc_2F32
.text$mn:00002DE1 ; ---------------------------------------------------------------------------
.text$mn:00002DE1                 jmp     loc_2F32
.text$mn:00002DE6 ; ---------------------------------------------------------------------------
.text$mn:00002DE6
.text$mn:00002DE6 loc_2DE6:                               ; CODE XREF: std::_Buffered_rotate<int *,int,int>(int *,int *,int *,int,int,std::_Temp_iterator<int> &)+2Fj
.text$mn:00002DE6                 mov     edx, [ebp+arg_C]
.text$mn:00002DE9                 cmp     edx, [ebp+arg_10]
.text$mn:00002DEC                 jg      loc_2E8B
.text$mn:00002DF2                 mov     ecx, [ebp+arg_14]
.text$mn:00002DF5                 call    ?_Maxlen@?$_Temp_iterator@H@std@@QAEHXZ ; std::_Temp_iterator<int>::_Maxlen(void)
.text$mn:00002DFA                 cmp     [ebp+arg_C], eax
.text$mn:00002DFD                 jg      loc_2E8B
.text$mn:00002E03                 mov     ecx, [ebp+arg_14]
.text$mn:00002E06                 call    ?_Init@?$_Temp_iterator@H@std@@QAEAAV12@XZ ; std::_Temp_iterator<int>::_Init(void)
.text$mn:00002E0B                 sub     esp, 14h
.text$mn:00002E0E                 mov     ecx, esp
.text$mn:00002E10                 mov     [ebp+var_18], esp
.text$mn:00002E13                 push    eax
.text$mn:00002E14                 call    ??0?$_Temp_iterator@H@std@@QAE@ABV01@@Z ; std::_Temp_iterator<int>::_Temp_iterator<int>(std::_Temp_iterator<int> const &)
.text$mn:00002E19                 mov     [ebp+var_10], eax
.text$mn:00002E1C                 mov     eax, [ebp+var_10]
.text$mn:00002E1F                 mov     [ebp+var_1C], eax
.text$mn:00002E22                 mov     [ebp+var_4], 0
.text$mn:00002E29                 mov     ecx, [ebp+Src]
.text$mn:00002E2C                 push    ecx
.text$mn:00002E2D                 mov     edx, [ebp+Dst]
.text$mn:00002E30                 push    edx
.text$mn:00002E31                 lea     eax, [ebp+var_40]
.text$mn:00002E34                 push    eax
.text$mn:00002E35                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002E3C                 call    ??$_Move@PAHV?$_Temp_iterator@H@std@@@std@@YA?AV?$_Temp_iterator@H@0@PAH0V10@@Z ; std::_Move<int *,std::_Temp_iterator<int>>(int *,int *,std::_Temp_iterator<int>)
.text$mn:00002E41                 add     esp, 20h
.text$mn:00002E44                 mov     [ebp+var_20], eax
.text$mn:00002E47                 lea     ecx, [ebp+var_40]
.text$mn:00002E4A                 call    ??1?$_Temp_iterator@H@std@@QAE@XZ ; std::_Temp_iterator<int>::~_Temp_iterator<int>(void)
.text$mn:00002E4F                 mov     ecx, [ebp+Dst]
.text$mn:00002E52                 push    ecx             ; Dst
.text$mn:00002E53                 mov     edx, [ebp+arg_8]
.text$mn:00002E56                 push    edx             ; int
.text$mn:00002E57                 mov     eax, [ebp+Src]
.text$mn:00002E5A                 push    eax             ; Src
.text$mn:00002E5B                 call    ??$_Move@PAHPAH@std@@YAPAHPAH00@Z ; std::_Move<int *,int *>(int *,int *,int *)
.text$mn:00002E60                 add     esp, 0Ch
.text$mn:00002E63                 mov     ecx, [ebp+arg_8]
.text$mn:00002E66                 push    ecx             ; int
.text$mn:00002E67                 mov     ecx, [ebp+arg_14]
.text$mn:00002E6A                 call    ?_Last@?$_Temp_iterator@H@std@@QBEPAHXZ ; std::_Temp_iterator<int>::_Last(void)
.text$mn:00002E6F                 push    eax             ; int
.text$mn:00002E70                 mov     ecx, [ebp+arg_14]
.text$mn:00002E73                 call    ?_First@?$_Temp_iterator@H@std@@QBEPAHXZ ; std::_Temp_iterator<int>::_First(void)
.text$mn:00002E78                 push    eax             ; Src
.text$mn:00002E79                 call    ??$_Move_backward@PAHPAH@std@@YAPAHPAH00@Z ; std::_Move_backward<int *,int *>(int *,int *,int *)
.text$mn:00002E7E                 add     esp, 0Ch
.text$mn:00002E81                 jmp     loc_2F32
.text$mn:00002E86 ; ---------------------------------------------------------------------------
.text$mn:00002E86                 jmp     loc_2F32
.text$mn:00002E8B ; ---------------------------------------------------------------------------
.text$mn:00002E8B
.text$mn:00002E8B loc_2E8B:                               ; CODE XREF: std::_Buffered_rotate<int *,int,int>(int *,int *,int *,int,int,std::_Temp_iterator<int> &)+54j
.text$mn:00002E8B                                         ; std::_Buffered_rotate<int *,int,int>(int *,int *,int *,int,int,std::_Temp_iterator<int> &)+65j
.text$mn:00002E8B                 mov     ecx, [ebp+arg_14]
.text$mn:00002E8E                 call    ?_Maxlen@?$_Temp_iterator@H@std@@QAEHXZ ; std::_Temp_iterator<int>::_Maxlen(void)
.text$mn:00002E93                 cmp     [ebp+arg_10], eax
.text$mn:00002E96                 jg      loc_2F1E
.text$mn:00002E9C                 mov     ecx, [ebp+arg_14]
.text$mn:00002E9F                 call    ?_Init@?$_Temp_iterator@H@std@@QAEAAV12@XZ ; std::_Temp_iterator<int>::_Init(void)
.text$mn:00002EA4                 sub     esp, 14h
.text$mn:00002EA7                 mov     ecx, esp
.text$mn:00002EA9                 mov     [ebp+var_24], esp
.text$mn:00002EAC                 push    eax
.text$mn:00002EAD                 call    ??0?$_Temp_iterator@H@std@@QAE@ABV01@@Z ; std::_Temp_iterator<int>::_Temp_iterator<int>(std::_Temp_iterator<int> const &)
.text$mn:00002EB2                 mov     [ebp+var_14], eax
.text$mn:00002EB5                 mov     edx, [ebp+var_14]
.text$mn:00002EB8                 mov     [ebp+var_28], edx
.text$mn:00002EBB                 mov     [ebp+var_4], 1
.text$mn:00002EC2                 mov     eax, [ebp+arg_8]
.text$mn:00002EC5                 push    eax
.text$mn:00002EC6                 mov     ecx, [ebp+Src]
.text$mn:00002EC9                 push    ecx
.text$mn:00002ECA                 lea     edx, [ebp+var_54]
.text$mn:00002ECD                 push    edx
.text$mn:00002ECE                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002ED5                 call    ??$_Move@PAHV?$_Temp_iterator@H@std@@@std@@YA?AV?$_Temp_iterator@H@0@PAH0V10@@Z ; std::_Move<int *,std::_Temp_iterator<int>>(int *,int *,std::_Temp_iterator<int>)
.text$mn:00002EDA                 add     esp, 20h
.text$mn:00002EDD                 mov     [ebp+var_2C], eax
.text$mn:00002EE0                 lea     ecx, [ebp+var_54]
.text$mn:00002EE3                 call    ??1?$_Temp_iterator@H@std@@QAE@XZ ; std::_Temp_iterator<int>::~_Temp_iterator<int>(void)
.text$mn:00002EE8                 mov     eax, [ebp+arg_8]
.text$mn:00002EEB                 push    eax             ; int
.text$mn:00002EEC                 mov     ecx, [ebp+Src]
.text$mn:00002EEF                 push    ecx             ; int
.text$mn:00002EF0                 mov     edx, [ebp+Dst]
.text$mn:00002EF3                 push    edx             ; Src
.text$mn:00002EF4                 call    ??$_Move_backward@PAHPAH@std@@YAPAHPAH00@Z ; std::_Move_backward<int *,int *>(int *,int *,int *)
.text$mn:00002EF9                 add     esp, 0Ch
.text$mn:00002EFC                 mov     eax, [ebp+Dst]
.text$mn:00002EFF                 push    eax             ; Dst
.text$mn:00002F00                 mov     ecx, [ebp+arg_14]
.text$mn:00002F03                 call    ?_Last@?$_Temp_iterator@H@std@@QBEPAHXZ ; std::_Temp_iterator<int>::_Last(void)
.text$mn:00002F08                 push    eax             ; int
.text$mn:00002F09                 mov     ecx, [ebp+arg_14]
.text$mn:00002F0C                 call    ?_First@?$_Temp_iterator@H@std@@QBEPAHXZ ; std::_Temp_iterator<int>::_First(void)
.text$mn:00002F11                 push    eax             ; Src
.text$mn:00002F12                 call    ??$_Move@PAHPAH@std@@YAPAHPAH00@Z ; std::_Move<int *,int *>(int *,int *,int *)
.text$mn:00002F17                 add     esp, 0Ch
.text$mn:00002F1A                 jmp     short loc_2F32
.text$mn:00002F1C ; ---------------------------------------------------------------------------
.text$mn:00002F1C                 jmp     short loc_2F32
.text$mn:00002F1E ; ---------------------------------------------------------------------------
.text$mn:00002F1E
.text$mn:00002F1E loc_2F1E:                               ; CODE XREF: std::_Buffered_rotate<int *,int,int>(int *,int *,int *,int,int,std::_Temp_iterator<int> &)+FEj
.text$mn:00002F1E                 mov     ecx, [ebp+arg_8]
.text$mn:00002F21                 push    ecx
.text$mn:00002F22                 mov     edx, [ebp+Src]
.text$mn:00002F25                 push    edx
.text$mn:00002F26                 mov     eax, [ebp+Dst]
.text$mn:00002F29                 push    eax
.text$mn:00002F2A                 call    ??$rotate@PAH@std@@YAPAHPAH00@Z ; std::rotate<int *>(int *,int *,int *)
.text$mn:00002F2F                 add     esp, 0Ch
.text$mn:00002F32
.text$mn:00002F32 loc_2F32:                               ; CODE XREF: std::_Buffered_rotate<int *,int,int>(int *,int *,int *,int,int,std::_Temp_iterator<int> &)+44j
.text$mn:00002F32                                         ; std::_Buffered_rotate<int *,int,int>(int *,int *,int *,int,int,std::_Temp_iterator<int> &)+49j ...
.text$mn:00002F32                 mov     ecx, [ebp+var_C]
.text$mn:00002F35                 mov     large fs:0, ecx
.text$mn:00002F3C                 pop     ecx
.text$mn:00002F3D                 mov     esp, ebp
.text$mn:00002F3F                 pop     ebp
.text$mn:00002F40                 retn
.text$mn:00002F40 ??$_Buffered_rotate@PAHHH@std@@YAPAHPAH00HHAAV?$_Temp_iterator@H@0@@Z endp
.text$mn:00002F40
.text$mn:00002F40 ; ---------------------------------------------------------------------------
.text$mn:00002F41                 align 4
.text$mn:00002F41 _text$mn        ends
.text$mn:00002F41
.text$x:00002F44 ; ===========================================================================
.text$x:00002F44
.text$x:00002F44 ; Segment type: Pure code
.text$x:00002F44 ; Segment permissions: Read/Execute
.text$x:00002F44 _text$x         segment para public 'CODE' use32
.text$x:00002F44                 assume cs:_text$x
.text$x:00002F44                 ;org 2F44h
.text$x:00002F44 ; COMDAT (pick associative to section at 2D98)
.text$x:00002F44                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00002F44
.text$x:00002F44 ; =============== S U B R O U T I N E =======================================
.text$x:00002F44
.text$x:00002F44
.text$x:00002F44 __unwindfunclet$??$_Buffered_rotate@PAHHH@std@@YAPAHPAH00HHAAV?$_Temp_iterator@H@0@@Z$0 proc near
.text$x:00002F44                                         ; DATA XREF: .xdata$x:0000DAC0o
.text$x:00002F44                 mov     ecx, [ebp-18h]
.text$x:00002F47                 jmp     ??1?$_Temp_iterator@H@std@@QAE@XZ ; std::_Temp_iterator<int>::~_Temp_iterator<int>(void)
.text$x:00002F47 __unwindfunclet$??$_Buffered_rotate@PAHHH@std@@YAPAHPAH00HHAAV?$_Temp_iterator@H@0@@Z$0 endp
.text$x:00002F47
.text$x:00002F4C
.text$x:00002F4C ; =============== S U B R O U T I N E =======================================
.text$x:00002F4C
.text$x:00002F4C
.text$x:00002F4C __unwindfunclet$??$_Buffered_rotate@PAHHH@std@@YAPAHPAH00HHAAV?$_Temp_iterator@H@0@@Z$2 proc near
.text$x:00002F4C                                         ; DATA XREF: .xdata$x:0000DAC8o
.text$x:00002F4C                 mov     ecx, [ebp-24h]
.text$x:00002F4F                 jmp     ??1?$_Temp_iterator@H@std@@QAE@XZ ; std::_Temp_iterator<int>::~_Temp_iterator<int>(void)
.text$x:00002F4F __unwindfunclet$??$_Buffered_rotate@PAHHH@std@@YAPAHPAH00HHAAV?$_Temp_iterator@H@0@@Z$2 endp
.text$x:00002F4F
.text$x:00002F54
.text$x:00002F54 ; =============== S U B R O U T I N E =======================================
.text$x:00002F54
.text$x:00002F54
.text$x:00002F54 __ehhandler$??$_Buffered_rotate@PAHHH@std@@YAPAHPAH00HHAAV?$_Temp_iterator@H@0@@Z proc near
.text$x:00002F54                                         ; DATA XREF: std::_Buffered_rotate<int *,int,int>(int *,int *,int *,int,int,std::_Temp_iterator<int> &)+5o
.text$x:00002F54
.text$x:00002F54 arg_4           = dword ptr  8
.text$x:00002F54
.text$x:00002F54                 mov     edx, [esp+arg_4]
.text$x:00002F58                 lea     eax, [edx+0Ch]
.text$x:00002F5B                 mov     ecx, [edx-4Ch]
.text$x:00002F5E                 xor     ecx, eax
.text$x:00002F60                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002F65                 mov     eax, offset __ehfuncinfo$??$_Buffered_rotate@PAHHH@std@@YAPAHPAH00HHAAV?$_Temp_iterator@H@0@@Z
.text$x:00002F6A                 jmp     ___CxxFrameHandler3
.text$x:00002F6A __ehhandler$??$_Buffered_rotate@PAHHH@std@@YAPAHPAH00HHAAV?$_Temp_iterator@H@0@@Z endp
.text$x:00002F6A
.text$x:00002F6A ; ---------------------------------------------------------------------------
.text$x:00002F6F                 align 10h
.text$x:00002F6F _text$x         ends
.text$x:00002F6F
.text$mn:00002F70 ; ===========================================================================
.text$mn:00002F70
.text$mn:00002F70 ; Segment type: Pure code
.text$mn:00002F70 ; Segment permissions: Read/Execute
.text$mn:00002F70 _text$mn        segment para public 'CODE' use32
.text$mn:00002F70                 assume cs:_text$mn
.text$mn:00002F70                 ;org 2F70h
.text$mn:00002F70 ; COMDAT (pick any)
.text$mn:00002F70                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002F70
.text$mn:00002F70 ; =============== S U B R O U T I N E =======================================
.text$mn:00002F70
.text$mn:00002F70 ; Attributes: bp-based frame
.text$mn:00002F70
.text$mn:00002F70 ; int __cdecl std::_Chunked_merge<int *,int *,int,BufferEquivalent>(void *Src, int, void *Dst, int, int, int, int, int, int)
.text$mn:00002F70                 public ??$_Chunked_merge@PAHPAHHUBufferEquivalent@@@std@@YAXPAH00HHUBufferEquivalent@@@Z
.text$mn:00002F70 ??$_Chunked_merge@PAHPAHHUBufferEquivalent@@@std@@YAXPAH00HHUBufferEquivalent@@@Z proc near
.text$mn:00002F70                                         ; CODE XREF: std::_Buffered_merge_sort<int *,int,int,BufferEquivalent>(int *,int *,int,std::_Temp_iterator<int> &,BufferEquivalent)+173p
.text$mn:00002F70
.text$mn:00002F70 var_10          = dword ptr -10h
.text$mn:00002F70 var_C           = dword ptr -0Ch
.text$mn:00002F70 var_8           = dword ptr -8
.text$mn:00002F70 var_4           = dword ptr -4
.text$mn:00002F70 Src             = dword ptr  8
.text$mn:00002F70 arg_4           = dword ptr  0Ch
.text$mn:00002F70 Dst             = dword ptr  10h
.text$mn:00002F70 arg_C           = dword ptr  14h
.text$mn:00002F70 arg_10          = dword ptr  18h
.text$mn:00002F70 arg_14          = dword ptr  1Ch
.text$mn:00002F70 arg_18          = dword ptr  20h
.text$mn:00002F70 arg_1C          = dword ptr  24h
.text$mn:00002F70 arg_20          = dword ptr  28h
.text$mn:00002F70
.text$mn:00002F70                 push    ebp
.text$mn:00002F71                 mov     ebp, esp
.text$mn:00002F73                 sub     esp, 10h
.text$mn:00002F76                 mov     eax, [ebp+arg_C]
.text$mn:00002F79                 shl     eax, 1
.text$mn:00002F7B                 mov     [ebp+var_10], eax
.text$mn:00002F7E                 jmp     short loc_2F89
.text$mn:00002F80 ; ---------------------------------------------------------------------------
.text$mn:00002F80
.text$mn:00002F80 loc_2F80:                               ; CODE XREF: std::_Chunked_merge<int *,int *,int,BufferEquivalent>(int *,int *,int *,int,int,BufferEquivalent)+8Bj
.text$mn:00002F80                 mov     ecx, [ebp+arg_10]
.text$mn:00002F83                 sub     ecx, [ebp+var_10]
.text$mn:00002F86                 mov     [ebp+arg_10], ecx
.text$mn:00002F89
.text$mn:00002F89 loc_2F89:                               ; CODE XREF: std::_Chunked_merge<int *,int *,int,BufferEquivalent>(int *,int *,int *,int,int,BufferEquivalent)+Ej
.text$mn:00002F89                 mov     edx, [ebp+var_10]
.text$mn:00002F8C                 cmp     edx, [ebp+arg_10]
.text$mn:00002F8F                 jg      short loc_2FFD
.text$mn:00002F91                 mov     eax, [ebp+Src]
.text$mn:00002F94                 mov     [ebp+var_4], eax
.text$mn:00002F97                 mov     ecx, [ebp+arg_C]
.text$mn:00002F9A                 push    ecx
.text$mn:00002F9B                 lea     edx, [ebp+var_4]
.text$mn:00002F9E                 push    edx
.text$mn:00002F9F                 call    ??$advance@PAHH@std@@YAXAAPAHH@Z ; std::advance<int *,int>(int * &,int)
.text$mn:00002FA4                 add     esp, 8
.text$mn:00002FA7                 mov     eax, [ebp+var_4]
.text$mn:00002FAA                 mov     [ebp+var_8], eax
.text$mn:00002FAD                 mov     ecx, [ebp+arg_C]
.text$mn:00002FB0                 push    ecx             ; int
.text$mn:00002FB1                 lea     edx, [ebp+var_8]
.text$mn:00002FB4                 push    edx             ; int
.text$mn:00002FB5                 call    ??$advance@PAHH@std@@YAXAAPAHH@Z ; std::advance<int *,int>(int * &,int)
.text$mn:00002FBA                 add     esp, 0FFFFFFF8h
.text$mn:00002FBD                 mov     eax, esp
.text$mn:00002FBF                 mov     ecx, [ebp+arg_14]
.text$mn:00002FC2                 mov     [eax], ecx
.text$mn:00002FC4                 mov     edx, [ebp+arg_18]
.text$mn:00002FC7                 mov     [eax+4], edx
.text$mn:00002FCA                 mov     ecx, [ebp+arg_1C]
.text$mn:00002FCD                 mov     [eax+8], ecx
.text$mn:00002FD0                 mov     edx, [ebp+arg_20]
.text$mn:00002FD3                 mov     [eax+0Ch], edx
.text$mn:00002FD6                 mov     eax, [ebp+Dst]
.text$mn:00002FD9                 push    eax             ; Dst
.text$mn:00002FDA                 mov     ecx, [ebp+var_8]
.text$mn:00002FDD                 push    ecx             ; int
.text$mn:00002FDE                 mov     edx, [ebp+var_4]
.text$mn:00002FE1                 push    edx             ; void *
.text$mn:00002FE2                 mov     eax, [ebp+var_4]
.text$mn:00002FE5                 push    eax             ; int
.text$mn:00002FE6                 mov     ecx, [ebp+Src]
.text$mn:00002FE9                 push    ecx             ; Src
.text$mn:00002FEA                 call    ??$_Merge@PAHPAHPAHUBufferEquivalent@@@std@@YAPAHPAH0000UBufferEquivalent@@@Z ; std::_Merge<int *,int *,int *,BufferEquivalent>(int *,int *,int *,int *,int *,BufferEquivalent)
.text$mn:00002FEF                 add     esp, 24h
.text$mn:00002FF2                 mov     [ebp+Dst], eax
.text$mn:00002FF5                 mov     edx, [ebp+var_8]
.text$mn:00002FF8                 mov     [ebp+Src], edx
.text$mn:00002FFB                 jmp     short loc_2F80
.text$mn:00002FFD ; ---------------------------------------------------------------------------
.text$mn:00002FFD
.text$mn:00002FFD loc_2FFD:                               ; CODE XREF: std::_Chunked_merge<int *,int *,int,BufferEquivalent>(int *,int *,int *,int,int,BufferEquivalent)+1Fj
.text$mn:00002FFD                 mov     eax, [ebp+arg_10]
.text$mn:00003000                 cmp     eax, [ebp+arg_C]
.text$mn:00003003                 jg      short loc_301B
.text$mn:00003005                 mov     ecx, [ebp+Dst]
.text$mn:00003008                 push    ecx             ; Dst
.text$mn:00003009                 mov     edx, [ebp+arg_4]
.text$mn:0000300C                 push    edx             ; int
.text$mn:0000300D                 mov     eax, [ebp+Src]
.text$mn:00003010                 push    eax             ; Src
.text$mn:00003011                 call    ??$_Move@PAHPAH@std@@YAPAHPAH00@Z ; std::_Move<int *,int *>(int *,int *,int *)
.text$mn:00003016                 add     esp, 0Ch
.text$mn:00003019                 jmp     short loc_3066
.text$mn:0000301B ; ---------------------------------------------------------------------------
.text$mn:0000301B
.text$mn:0000301B loc_301B:                               ; CODE XREF: std::_Chunked_merge<int *,int *,int,BufferEquivalent>(int *,int *,int *,int,int,BufferEquivalent)+93j
.text$mn:0000301B                 mov     ecx, [ebp+Src]
.text$mn:0000301E                 mov     [ebp+var_C], ecx
.text$mn:00003021                 mov     edx, [ebp+arg_C]
.text$mn:00003024                 push    edx             ; int
.text$mn:00003025                 lea     eax, [ebp+var_C]
.text$mn:00003028                 push    eax             ; int
.text$mn:00003029                 call    ??$advance@PAHH@std@@YAXAAPAHH@Z ; std::advance<int *,int>(int * &,int)
.text$mn:0000302E                 add     esp, 0FFFFFFF8h
.text$mn:00003031                 mov     ecx, esp
.text$mn:00003033                 mov     edx, [ebp+arg_14]
.text$mn:00003036                 mov     [ecx], edx
.text$mn:00003038                 mov     eax, [ebp+arg_18]
.text$mn:0000303B                 mov     [ecx+4], eax
.text$mn:0000303E                 mov     edx, [ebp+arg_1C]
.text$mn:00003041                 mov     [ecx+8], edx
.text$mn:00003044                 mov     eax, [ebp+arg_20]
.text$mn:00003047                 mov     [ecx+0Ch], eax
.text$mn:0000304A                 mov     ecx, [ebp+Dst]
.text$mn:0000304D                 push    ecx             ; Dst
.text$mn:0000304E                 mov     edx, [ebp+arg_4]
.text$mn:00003051                 push    edx             ; int
.text$mn:00003052                 mov     eax, [ebp+var_C]
.text$mn:00003055                 push    eax             ; void *
.text$mn:00003056                 mov     ecx, [ebp+var_C]
.text$mn:00003059                 push    ecx             ; int
.text$mn:0000305A                 mov     edx, [ebp+Src]
.text$mn:0000305D                 push    edx             ; Src
.text$mn:0000305E                 call    ??$_Merge@PAHPAHPAHUBufferEquivalent@@@std@@YAPAHPAH0000UBufferEquivalent@@@Z ; std::_Merge<int *,int *,int *,BufferEquivalent>(int *,int *,int *,int *,int *,BufferEquivalent)
.text$mn:00003063                 add     esp, 24h
.text$mn:00003066
.text$mn:00003066 loc_3066:                               ; CODE XREF: std::_Chunked_merge<int *,int *,int,BufferEquivalent>(int *,int *,int *,int,int,BufferEquivalent)+A9j
.text$mn:00003066                 mov     esp, ebp
.text$mn:00003068                 pop     ebp
.text$mn:00003069                 retn
.text$mn:00003069 ??$_Chunked_merge@PAHPAHHUBufferEquivalent@@@std@@YAXPAH00HHUBufferEquivalent@@@Z endp
.text$mn:00003069
.text$mn:00003069 ; ---------------------------------------------------------------------------
.text$mn:0000306A                 align 4
.text$mn:0000306A _text$mn        ends
.text$mn:0000306A
.text$mn:0000306C ; ===========================================================================
.text$mn:0000306C
.text$mn:0000306C ; Segment type: Pure code
.text$mn:0000306C ; Segment permissions: Read/Execute
.text$mn:0000306C _text$mn        segment para public 'CODE' use32
.text$mn:0000306C                 assume cs:_text$mn
.text$mn:0000306C                 ;org 306Ch
.text$mn:0000306C ; COMDAT (pick any)
.text$mn:0000306C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000306C
.text$mn:0000306C ; =============== S U B R O U T I N E =======================================
.text$mn:0000306C
.text$mn:0000306C ; Attributes: bp-based frame
.text$mn:0000306C
.text$mn:0000306C ; void __cdecl std::_Chunked_merge<int *, class std::_Temp_iterator<int>, int, struct BufferEquivalent>(int *, int *, class std::_Temp_iterator<int>, int, int, struct BufferEquivalent)
.text$mn:0000306C                 public ??$_Chunked_merge@PAHV?$_Temp_iterator@H@std@@HUBufferEquivalent@@@std@@YAXPAH0V?$_Temp_iterator@H@0@HHUBufferEquivalent@@@Z
.text$mn:0000306C ??$_Chunked_merge@PAHV?$_Temp_iterator@H@std@@HUBufferEquivalent@@@std@@YAXPAH0V?$_Temp_iterator@H@0@HHUBufferEquivalent@@@Z proc near
.text$mn:0000306C                                         ; CODE XREF: std::_Buffered_merge_sort<int *,int,int,BufferEquivalent>(int *,int *,int,std::_Temp_iterator<int> &,BufferEquivalent)+129p
.text$mn:0000306C
.text$mn:0000306C var_8C          = byte ptr -8Ch
.text$mn:0000306C var_78          = byte ptr -78h
.text$mn:0000306C var_64          = byte ptr -64h
.text$mn:0000306C var_50          = dword ptr -50h
.text$mn:0000306C var_4C          = dword ptr -4Ch
.text$mn:0000306C var_48          = dword ptr -48h
.text$mn:0000306C var_44          = dword ptr -44h
.text$mn:0000306C var_40          = dword ptr -40h
.text$mn:0000306C var_3C          = dword ptr -3Ch
.text$mn:0000306C var_38          = dword ptr -38h
.text$mn:0000306C var_34          = dword ptr -34h
.text$mn:0000306C var_30          = dword ptr -30h
.text$mn:0000306C var_2C          = dword ptr -2Ch
.text$mn:0000306C var_28          = dword ptr -28h
.text$mn:0000306C var_24          = dword ptr -24h
.text$mn:0000306C var_20          = dword ptr -20h
.text$mn:0000306C var_1C          = dword ptr -1Ch
.text$mn:0000306C var_18          = dword ptr -18h
.text$mn:0000306C var_14          = dword ptr -14h
.text$mn:0000306C var_10          = dword ptr -10h
.text$mn:0000306C var_C           = dword ptr -0Ch
.text$mn:0000306C var_4           = dword ptr -4
.text$mn:0000306C arg_0           = dword ptr  8
.text$mn:0000306C arg_4           = dword ptr  0Ch
.text$mn:0000306C arg_8           = byte ptr  10h
.text$mn:0000306C arg_1C          = dword ptr  24h
.text$mn:0000306C arg_20          = dword ptr  28h
.text$mn:0000306C arg_24          = dword ptr  2Ch
.text$mn:0000306C arg_28          = dword ptr  30h
.text$mn:0000306C arg_2C          = dword ptr  34h
.text$mn:0000306C arg_30          = dword ptr  38h
.text$mn:0000306C
.text$mn:0000306C                 push    ebp
.text$mn:0000306D                 mov     ebp, esp
.text$mn:0000306F                 push    0FFFFFFFFh
.text$mn:00003071                 push    offset __ehhandler$??$_Chunked_merge@PAHV?$_Temp_iterator@H@std@@HUBufferEquivalent@@@std@@YAXPAH0V?$_Temp_iterator@H@0@HHUBufferEquivalent@@@Z
.text$mn:00003076                 mov     eax, large fs:0
.text$mn:0000307C                 push    eax
.text$mn:0000307D                 sub     esp, 80h
.text$mn:00003083                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003088                 xor     eax, ebp
.text$mn:0000308A                 push    eax
.text$mn:0000308B                 lea     eax, [ebp+var_C]
.text$mn:0000308E                 mov     large fs:0, eax
.text$mn:00003094                 mov     [ebp+var_4], 0
.text$mn:0000309B                 mov     eax, [ebp+arg_1C]
.text$mn:0000309E                 shl     eax, 1
.text$mn:000030A0                 mov     [ebp+var_1C], eax
.text$mn:000030A3                 jmp     short loc_30AE
.text$mn:000030A5 ; ---------------------------------------------------------------------------
.text$mn:000030A5
.text$mn:000030A5 loc_30A5:                               ; CODE XREF: std::_Chunked_merge<int *,std::_Temp_iterator<int>,int,BufferEquivalent>(int *,int *,std::_Temp_iterator<int>,int,int,BufferEquivalent)+FFj
.text$mn:000030A5                 mov     ecx, [ebp+arg_20]
.text$mn:000030A8                 sub     ecx, [ebp+var_1C]
.text$mn:000030AB                 mov     [ebp+arg_20], ecx
.text$mn:000030AE
.text$mn:000030AE loc_30AE:                               ; CODE XREF: std::_Chunked_merge<int *,std::_Temp_iterator<int>,int,BufferEquivalent>(int *,int *,std::_Temp_iterator<int>,int,int,BufferEquivalent)+37j
.text$mn:000030AE                 mov     edx, [ebp+var_1C]
.text$mn:000030B1                 cmp     edx, [ebp+arg_20]
.text$mn:000030B4                 jg      loc_3170
.text$mn:000030BA                 mov     eax, [ebp+arg_0]
.text$mn:000030BD                 mov     [ebp+var_10], eax
.text$mn:000030C0                 mov     ecx, [ebp+arg_1C]
.text$mn:000030C3                 push    ecx
.text$mn:000030C4                 lea     edx, [ebp+var_10]
.text$mn:000030C7                 push    edx
.text$mn:000030C8                 call    ??$advance@PAHH@std@@YAXAAPAHH@Z ; std::advance<int *,int>(int * &,int)
.text$mn:000030CD                 add     esp, 8
.text$mn:000030D0                 mov     eax, [ebp+var_10]
.text$mn:000030D3                 mov     [ebp+var_14], eax
.text$mn:000030D6                 mov     ecx, [ebp+arg_1C]
.text$mn:000030D9                 push    ecx
.text$mn:000030DA                 lea     edx, [ebp+var_14]
.text$mn:000030DD                 push    edx
.text$mn:000030DE                 call    ??$advance@PAHH@std@@YAXAAPAHH@Z ; std::advance<int *,int>(int * &,int)
.text$mn:000030E3                 add     esp, 8
.text$mn:000030E6                 sub     esp, 10h
.text$mn:000030E9                 mov     eax, esp
.text$mn:000030EB                 mov     ecx, [ebp+arg_24]
.text$mn:000030EE                 mov     [eax], ecx
.text$mn:000030F0                 mov     edx, [ebp+arg_28]
.text$mn:000030F3                 mov     [eax+4], edx
.text$mn:000030F6                 mov     ecx, [ebp+arg_2C]
.text$mn:000030F9                 mov     [eax+8], ecx
.text$mn:000030FC                 mov     edx, [ebp+arg_30]
.text$mn:000030FF                 mov     [eax+0Ch], edx
.text$mn:00003102                 sub     esp, 14h
.text$mn:00003105                 mov     ecx, esp
.text$mn:00003107                 mov     [ebp+var_34], esp
.text$mn:0000310A                 lea     eax, [ebp+arg_8]
.text$mn:0000310D                 push    eax
.text$mn:0000310E                 call    ??0?$_Temp_iterator@H@std@@QAE@ABV01@@Z ; std::_Temp_iterator<int>::_Temp_iterator<int>(std::_Temp_iterator<int> const &)
.text$mn:00003113                 mov     [ebp+var_20], eax
.text$mn:00003116                 mov     ecx, [ebp+var_20]
.text$mn:00003119                 mov     [ebp+var_38], ecx
.text$mn:0000311C                 mov     byte ptr [ebp+var_4], 1
.text$mn:00003120                 mov     edx, [ebp+var_14]
.text$mn:00003123                 push    edx
.text$mn:00003124                 mov     eax, [ebp+var_10]
.text$mn:00003127                 push    eax
.text$mn:00003128                 mov     ecx, [ebp+var_10]
.text$mn:0000312B                 push    ecx
.text$mn:0000312C                 mov     edx, [ebp+arg_0]
.text$mn:0000312F                 push    edx
.text$mn:00003130                 lea     eax, [ebp+var_64]
.text$mn:00003133                 push    eax
.text$mn:00003134                 mov     byte ptr [ebp+var_4], 0
.text$mn:00003138                 call    ??$_Merge@PAHPAHV?$_Temp_iterator@H@std@@UBufferEquivalent@@@std@@YA?AV?$_Temp_iterator@H@0@PAH000V10@UBufferEquivalent@@@Z ; std::_Merge<int *,int *,std::_Temp_iterator<int>,BufferEquivalent>(int *,int *,int *,int *,std::_Temp_iterator<int>,BufferEquivalent)
.text$mn:0000313D                 add     esp, 38h
.text$mn:00003140                 mov     [ebp+var_24], eax
.text$mn:00003143                 mov     ecx, [ebp+var_24]
.text$mn:00003146                 mov     [ebp+var_28], ecx
.text$mn:00003149                 mov     byte ptr [ebp+var_4], 2
.text$mn:0000314D                 mov     edx, [ebp+var_28]
.text$mn:00003150                 push    edx
.text$mn:00003151                 lea     ecx, [ebp+arg_8]
.text$mn:00003154                 call    ??4?$_Temp_iterator@H@std@@QAEAAV01@ABV01@@Z ; std::_Temp_iterator<int>::operator=(std::_Temp_iterator<int> const &)
.text$mn:00003159                 mov     byte ptr [ebp+var_4], 0
.text$mn:0000315D                 lea     ecx, [ebp+var_64]
.text$mn:00003160                 call    ??1?$_Temp_iterator@H@std@@QAE@XZ ; std::_Temp_iterator<int>::~_Temp_iterator<int>(void)
.text$mn:00003165                 mov     eax, [ebp+var_14]
.text$mn:00003168                 mov     [ebp+arg_0], eax
.text$mn:0000316B                 jmp     loc_30A5
.text$mn:00003170 ; ---------------------------------------------------------------------------
.text$mn:00003170
.text$mn:00003170 loc_3170:                               ; CODE XREF: std::_Chunked_merge<int *,std::_Temp_iterator<int>,int,BufferEquivalent>(int *,int *,std::_Temp_iterator<int>,int,int,BufferEquivalent)+48j
.text$mn:00003170                 mov     ecx, [ebp+arg_20]
.text$mn:00003173                 cmp     ecx, [ebp+arg_1C]
.text$mn:00003176                 jg      short loc_31BE
.text$mn:00003178                 sub     esp, 14h
.text$mn:0000317B                 mov     ecx, esp
.text$mn:0000317D                 mov     [ebp+var_3C], esp
.text$mn:00003180                 lea     edx, [ebp+arg_8]
.text$mn:00003183                 push    edx
.text$mn:00003184                 call    ??0?$_Temp_iterator@H@std@@QAE@ABV01@@Z ; std::_Temp_iterator<int>::_Temp_iterator<int>(std::_Temp_iterator<int> const &)
.text$mn:00003189                 mov     [ebp+var_2C], eax
.text$mn:0000318C                 mov     eax, [ebp+var_2C]
.text$mn:0000318F                 mov     [ebp+var_40], eax
.text$mn:00003192                 mov     byte ptr [ebp+var_4], 3
.text$mn:00003196                 mov     ecx, [ebp+arg_4]
.text$mn:00003199                 push    ecx
.text$mn:0000319A                 mov     edx, [ebp+arg_0]
.text$mn:0000319D                 push    edx
.text$mn:0000319E                 lea     eax, [ebp+var_78]
.text$mn:000031A1                 push    eax
.text$mn:000031A2                 mov     byte ptr [ebp+var_4], 0
.text$mn:000031A6                 call    ??$_Move@PAHV?$_Temp_iterator@H@std@@@std@@YA?AV?$_Temp_iterator@H@0@PAH0V10@@Z ; std::_Move<int *,std::_Temp_iterator<int>>(int *,int *,std::_Temp_iterator<int>)
.text$mn:000031AB                 add     esp, 20h
.text$mn:000031AE                 mov     [ebp+var_44], eax
.text$mn:000031B1                 lea     ecx, [ebp+var_78]
.text$mn:000031B4                 call    ??1?$_Temp_iterator@H@std@@QAE@XZ ; std::_Temp_iterator<int>::~_Temp_iterator<int>(void)
.text$mn:000031B9                 jmp     loc_323F
.text$mn:000031BE ; ---------------------------------------------------------------------------
.text$mn:000031BE
.text$mn:000031BE loc_31BE:                               ; CODE XREF: std::_Chunked_merge<int *,std::_Temp_iterator<int>,int,BufferEquivalent>(int *,int *,std::_Temp_iterator<int>,int,int,BufferEquivalent)+10Aj
.text$mn:000031BE                 mov     ecx, [ebp+arg_0]
.text$mn:000031C1                 mov     [ebp+var_18], ecx
.text$mn:000031C4                 mov     edx, [ebp+arg_1C]
.text$mn:000031C7                 push    edx
.text$mn:000031C8                 lea     eax, [ebp+var_18]
.text$mn:000031CB                 push    eax
.text$mn:000031CC                 call    ??$advance@PAHH@std@@YAXAAPAHH@Z ; std::advance<int *,int>(int * &,int)
.text$mn:000031D1                 add     esp, 8
.text$mn:000031D4                 sub     esp, 10h
.text$mn:000031D7                 mov     ecx, esp
.text$mn:000031D9                 mov     edx, [ebp+arg_24]
.text$mn:000031DC                 mov     [ecx], edx
.text$mn:000031DE                 mov     eax, [ebp+arg_28]
.text$mn:000031E1                 mov     [ecx+4], eax
.text$mn:000031E4                 mov     edx, [ebp+arg_2C]
.text$mn:000031E7                 mov     [ecx+8], edx
.text$mn:000031EA                 mov     eax, [ebp+arg_30]
.text$mn:000031ED                 mov     [ecx+0Ch], eax
.text$mn:000031F0                 sub     esp, 14h
.text$mn:000031F3                 mov     ecx, esp
.text$mn:000031F5                 mov     [ebp+var_48], esp
.text$mn:000031F8                 lea     edx, [ebp+arg_8]
.text$mn:000031FB                 push    edx
.text$mn:000031FC                 call    ??0?$_Temp_iterator@H@std@@QAE@ABV01@@Z ; std::_Temp_iterator<int>::_Temp_iterator<int>(std::_Temp_iterator<int> const &)
.text$mn:00003201                 mov     [ebp+var_30], eax
.text$mn:00003204                 mov     eax, [ebp+var_30]
.text$mn:00003207                 mov     [ebp+var_4C], eax
.text$mn:0000320A                 mov     byte ptr [ebp+var_4], 4
.text$mn:0000320E                 mov     ecx, [ebp+arg_4]
.text$mn:00003211                 push    ecx
.text$mn:00003212                 mov     edx, [ebp+var_18]
.text$mn:00003215                 push    edx
.text$mn:00003216                 mov     eax, [ebp+var_18]
.text$mn:00003219                 push    eax
.text$mn:0000321A                 mov     ecx, [ebp+arg_0]
.text$mn:0000321D                 push    ecx
.text$mn:0000321E                 lea     edx, [ebp+var_8C]
.text$mn:00003224                 push    edx
.text$mn:00003225                 mov     byte ptr [ebp+var_4], 0
.text$mn:00003229                 call    ??$_Merge@PAHPAHV?$_Temp_iterator@H@std@@UBufferEquivalent@@@std@@YA?AV?$_Temp_iterator@H@0@PAH000V10@UBufferEquivalent@@@Z ; std::_Merge<int *,int *,std::_Temp_iterator<int>,BufferEquivalent>(int *,int *,int *,int *,std::_Temp_iterator<int>,BufferEquivalent)
.text$mn:0000322E                 add     esp, 38h
.text$mn:00003231                 mov     [ebp+var_50], eax
.text$mn:00003234                 lea     ecx, [ebp+var_8C]
.text$mn:0000323A                 call    ??1?$_Temp_iterator@H@std@@QAE@XZ ; std::_Temp_iterator<int>::~_Temp_iterator<int>(void)
.text$mn:0000323F
.text$mn:0000323F loc_323F:                               ; CODE XREF: std::_Chunked_merge<int *,std::_Temp_iterator<int>,int,BufferEquivalent>(int *,int *,std::_Temp_iterator<int>,int,int,BufferEquivalent)+14Dj
.text$mn:0000323F                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003246                 lea     ecx, [ebp+arg_8]
.text$mn:00003249                 call    ??1?$_Temp_iterator@H@std@@QAE@XZ ; std::_Temp_iterator<int>::~_Temp_iterator<int>(void)
.text$mn:0000324E                 mov     ecx, [ebp+var_C]
.text$mn:00003251                 mov     large fs:0, ecx
.text$mn:00003258                 pop     ecx
.text$mn:00003259                 mov     esp, ebp
.text$mn:0000325B                 pop     ebp
.text$mn:0000325C                 retn
.text$mn:0000325C ??$_Chunked_merge@PAHV?$_Temp_iterator@H@std@@HUBufferEquivalent@@@std@@YAXPAH0V?$_Temp_iterator@H@0@HHUBufferEquivalent@@@Z endp
.text$mn:0000325C
.text$mn:0000325C ; ---------------------------------------------------------------------------
.text$mn:0000325D                 align 10h
.text$mn:0000325D _text$mn        ends
.text$mn:0000325D
.text$x:00003260 ; ===========================================================================
.text$x:00003260
.text$x:00003260 ; Segment type: Pure code
.text$x:00003260 ; Segment permissions: Read/Execute
.text$x:00003260 _text$x         segment para public 'CODE' use32
.text$x:00003260                 assume cs:_text$x
.text$x:00003260                 ;org 3260h
.text$x:00003260 ; COMDAT (pick associative to section at 306C)
.text$x:00003260                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00003260
.text$x:00003260 ; =============== S U B R O U T I N E =======================================
.text$x:00003260
.text$x:00003260
.text$x:00003260 __unwindfunclet$??$_Chunked_merge@PAHV?$_Temp_iterator@H@std@@HUBufferEquivalent@@@std@@YAXPAH0V?$_Temp_iterator@H@0@HHUBufferEquivalent@@@Z$0 proc near
.text$x:00003260                                         ; DATA XREF: .xdata$x:0000DA5Co
.text$x:00003260                 lea     ecx, [ebp+10h]
.text$x:00003263                 jmp     ??1?$_Temp_iterator@H@std@@QAE@XZ ; std::_Temp_iterator<int>::~_Temp_iterator<int>(void)
.text$x:00003263 __unwindfunclet$??$_Chunked_merge@PAHV?$_Temp_iterator@H@std@@HUBufferEquivalent@@@std@@YAXPAH0V?$_Temp_iterator@H@0@HHUBufferEquivalent@@@Z$0 endp
.text$x:00003263
.text$x:00003268
.text$x:00003268 ; =============== S U B R O U T I N E =======================================
.text$x:00003268
.text$x:00003268
.text$x:00003268 __unwindfunclet$??$_Chunked_merge@PAHV?$_Temp_iterator@H@std@@HUBufferEquivalent@@@std@@YAXPAH0V?$_Temp_iterator@H@0@HHUBufferEquivalent@@@Z$1 proc near
.text$x:00003268                                         ; DATA XREF: .xdata$x:0000DA64o
.text$x:00003268                 mov     ecx, [ebp-34h]
.text$x:0000326B                 jmp     ??1?$_Temp_iterator@H@std@@QAE@XZ ; std::_Temp_iterator<int>::~_Temp_iterator<int>(void)
.text$x:0000326B __unwindfunclet$??$_Chunked_merge@PAHV?$_Temp_iterator@H@std@@HUBufferEquivalent@@@std@@YAXPAH0V?$_Temp_iterator@H@0@HHUBufferEquivalent@@@Z$1 endp
.text$x:0000326B
.text$x:00003270
.text$x:00003270 ; =============== S U B R O U T I N E =======================================
.text$x:00003270
.text$x:00003270
.text$x:00003270 __unwindfunclet$??$_Chunked_merge@PAHV?$_Temp_iterator@H@std@@HUBufferEquivalent@@@std@@YAXPAH0V?$_Temp_iterator@H@0@HHUBufferEquivalent@@@Z$2 proc near
.text$x:00003270                                         ; DATA XREF: .xdata$x:0000DA6Co
.text$x:00003270                 lea     ecx, [ebp-64h]
.text$x:00003273                 jmp     ??1?$_Temp_iterator@H@std@@QAE@XZ ; std::_Temp_iterator<int>::~_Temp_iterator<int>(void)
.text$x:00003273 __unwindfunclet$??$_Chunked_merge@PAHV?$_Temp_iterator@H@std@@HUBufferEquivalent@@@std@@YAXPAH0V?$_Temp_iterator@H@0@HHUBufferEquivalent@@@Z$2 endp
.text$x:00003273
.text$x:00003278
.text$x:00003278 ; =============== S U B R O U T I N E =======================================
.text$x:00003278
.text$x:00003278
.text$x:00003278 __unwindfunclet$??$_Chunked_merge@PAHV?$_Temp_iterator@H@std@@HUBufferEquivalent@@@std@@YAXPAH0V?$_Temp_iterator@H@0@HHUBufferEquivalent@@@Z$3 proc near
.text$x:00003278                                         ; DATA XREF: .xdata$x:0000DA74o
.text$x:00003278                 mov     ecx, [ebp-3Ch]
.text$x:0000327B                 jmp     ??1?$_Temp_iterator@H@std@@QAE@XZ ; std::_Temp_iterator<int>::~_Temp_iterator<int>(void)
.text$x:0000327B __unwindfunclet$??$_Chunked_merge@PAHV?$_Temp_iterator@H@std@@HUBufferEquivalent@@@std@@YAXPAH0V?$_Temp_iterator@H@0@HHUBufferEquivalent@@@Z$3 endp
.text$x:0000327B
.text$x:00003280
.text$x:00003280 ; =============== S U B R O U T I N E =======================================
.text$x:00003280
.text$x:00003280
.text$x:00003280 __unwindfunclet$??$_Chunked_merge@PAHV?$_Temp_iterator@H@std@@HUBufferEquivalent@@@std@@YAXPAH0V?$_Temp_iterator@H@0@HHUBufferEquivalent@@@Z$5 proc near
.text$x:00003280                                         ; DATA XREF: .xdata$x:0000DA7Co
.text$x:00003280                 mov     ecx, [ebp-48h]
.text$x:00003283                 jmp     ??1?$_Temp_iterator@H@std@@QAE@XZ ; std::_Temp_iterator<int>::~_Temp_iterator<int>(void)
.text$x:00003283 __unwindfunclet$??$_Chunked_merge@PAHV?$_Temp_iterator@H@std@@HUBufferEquivalent@@@std@@YAXPAH0V?$_Temp_iterator@H@0@HHUBufferEquivalent@@@Z$5 endp
.text$x:00003283
.text$x:00003288
.text$x:00003288 ; =============== S U B R O U T I N E =======================================
.text$x:00003288
.text$x:00003288
.text$x:00003288 __ehhandler$??$_Chunked_merge@PAHV?$_Temp_iterator@H@std@@HUBufferEquivalent@@@std@@YAXPAH0V?$_Temp_iterator@H@0@HHUBufferEquivalent@@@Z proc near
.text$x:00003288                                         ; DATA XREF: std::_Chunked_merge<int *,std::_Temp_iterator<int>,int,BufferEquivalent>(int *,int *,std::_Temp_iterator<int>,int,int,BufferEquivalent)+5o
.text$x:00003288
.text$x:00003288 arg_4           = dword ptr  8
.text$x:00003288
.text$x:00003288                 mov     edx, [esp+arg_4]
.text$x:0000328C                 lea     eax, [edx+0Ch]
.text$x:0000328F                 mov     ecx, [edx-84h]
.text$x:00003295                 xor     ecx, eax
.text$x:00003297                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000329C                 mov     eax, offset __ehfuncinfo$??$_Chunked_merge@PAHV?$_Temp_iterator@H@std@@HUBufferEquivalent@@@std@@YAXPAH0V?$_Temp_iterator@H@0@HHUBufferEquivalent@@@Z
.text$x:000032A1                 jmp     ___CxxFrameHandler3
.text$x:000032A1 __ehhandler$??$_Chunked_merge@PAHV?$_Temp_iterator@H@std@@HUBufferEquivalent@@@std@@YAXPAH0V?$_Temp_iterator@H@0@HHUBufferEquivalent@@@Z endp
.text$x:000032A1
.text$x:000032A1 ; ---------------------------------------------------------------------------
.text$x:000032A6                 align 4
.text$x:000032A6 _text$x         ends
.text$x:000032A6
.text$mn:000032A8 ; ===========================================================================
.text$mn:000032A8
.text$mn:000032A8 ; Segment type: Pure code
.text$mn:000032A8 ; Segment permissions: Read/Execute
.text$mn:000032A8 _text$mn        segment para public 'CODE' use32
.text$mn:000032A8                 assume cs:_text$mn
.text$mn:000032A8                 ;org 32A8h
.text$mn:000032A8 ; COMDAT (pick any)
.text$mn:000032A8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000032A8
.text$mn:000032A8 ; =============== S U B R O U T I N E =======================================
.text$mn:000032A8
.text$mn:000032A8 ; Attributes: bp-based frame
.text$mn:000032A8
.text$mn:000032A8 ; void __cdecl std::_Construct<int, int>(int *, int &&)
.text$mn:000032A8                 public ??$_Construct@HH@std@@YAXPAH$$QAH@Z
.text$mn:000032A8 ??$_Construct@HH@std@@YAXPAH$$QAH@Z proc near
.text$mn:000032A8                                         ; CODE XREF: std::_Temp_iterator<int>::operator=(int &&)+6Ap
.text$mn:000032A8
.text$mn:000032A8 var_1C          = dword ptr -1Ch
.text$mn:000032A8 var_18          = dword ptr -18h
.text$mn:000032A8 var_14          = dword ptr -14h
.text$mn:000032A8 var_10          = dword ptr -10h
.text$mn:000032A8 var_C           = dword ptr -0Ch
.text$mn:000032A8 var_4           = dword ptr -4
.text$mn:000032A8 arg_0           = dword ptr  8
.text$mn:000032A8 arg_4           = dword ptr  0Ch
.text$mn:000032A8
.text$mn:000032A8                 push    ebp
.text$mn:000032A9                 mov     ebp, esp
.text$mn:000032AB                 push    0FFFFFFFFh
.text$mn:000032AD                 push    offset __ehhandler$??$_Construct@HH@std@@YAXPAH$$QAH@Z
.text$mn:000032B2                 mov     eax, large fs:0
.text$mn:000032B8                 push    eax
.text$mn:000032B9                 sub     esp, 10h
.text$mn:000032BC                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000032C1                 xor     eax, ebp
.text$mn:000032C3                 push    eax
.text$mn:000032C4                 lea     eax, [ebp+var_C]
.text$mn:000032C7                 mov     large fs:0, eax
.text$mn:000032CD                 mov     eax, [ebp+arg_0]
.text$mn:000032D0                 mov     [ebp+var_18], eax
.text$mn:000032D3                 mov     ecx, [ebp+var_18]
.text$mn:000032D6                 push    ecx             ; void *
.text$mn:000032D7                 push    4               ; unsigned int
.text$mn:000032D9                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:000032DE                 add     esp, 8
.text$mn:000032E1                 mov     [ebp+var_10], eax
.text$mn:000032E4                 mov     [ebp+var_4], 0
.text$mn:000032EB                 cmp     [ebp+var_10], 0
.text$mn:000032EF                 jz      short loc_330C
.text$mn:000032F1                 mov     edx, [ebp+arg_4]
.text$mn:000032F4                 push    edx
.text$mn:000032F5                 call    ??$forward@H@std@@YA$$QAHAAH@Z ; std::forward<int>(int &)
.text$mn:000032FA                 add     esp, 4
.text$mn:000032FD                 mov     ecx, [ebp+var_10]
.text$mn:00003300                 mov     edx, [eax]
.text$mn:00003302                 mov     [ecx], edx
.text$mn:00003304                 mov     eax, [ebp+var_10]
.text$mn:00003307                 mov     [ebp+var_14], eax
.text$mn:0000330A                 jmp     short loc_3313
.text$mn:0000330C ; ---------------------------------------------------------------------------
.text$mn:0000330C
.text$mn:0000330C loc_330C:                               ; CODE XREF: std::_Construct<int,int>(int *,int &&)+47j
.text$mn:0000330C                 mov     [ebp+var_14], 0
.text$mn:00003313
.text$mn:00003313 loc_3313:                               ; CODE XREF: std::_Construct<int,int>(int *,int &&)+62j
.text$mn:00003313                 mov     ecx, [ebp+var_14]
.text$mn:00003316                 mov     [ebp+var_1C], ecx
.text$mn:00003319                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003320                 mov     ecx, [ebp+var_C]
.text$mn:00003323                 mov     large fs:0, ecx
.text$mn:0000332A                 pop     ecx
.text$mn:0000332B                 mov     esp, ebp
.text$mn:0000332D                 pop     ebp
.text$mn:0000332E                 retn
.text$mn:0000332E ??$_Construct@HH@std@@YAXPAH$$QAH@Z endp
.text$mn:0000332E
.text$mn:0000332E ; ---------------------------------------------------------------------------
.text$mn:0000332F                 align 10h
.text$mn:0000332F _text$mn        ends
.text$mn:0000332F
.text$x:00003330 ; ===========================================================================
.text$x:00003330
.text$x:00003330 ; Segment type: Pure code
.text$x:00003330 ; Segment permissions: Read/Execute
.text$x:00003330 _text$x         segment para public 'CODE' use32
.text$x:00003330                 assume cs:_text$x
.text$x:00003330                 ;org 3330h
.text$x:00003330 ; COMDAT (pick associative to section at 32A8)
.text$x:00003330                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00003330
.text$x:00003330 ; =============== S U B R O U T I N E =======================================
.text$x:00003330
.text$x:00003330
.text$x:00003330 __unwindfunclet$??$_Construct@HH@std@@YAXPAH$$QAH@Z$0 proc near
.text$x:00003330                                         ; DATA XREF: .xdata$x:0000DC18o
.text$x:00003330                 mov     eax, [ebp-18h]
.text$x:00003333                 push    eax
.text$x:00003334                 mov     eax, [ebp-10h]
.text$x:00003337                 push    eax             ; void *
.text$x:00003338                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:0000333D                 add     esp, 8
.text$x:00003340                 retn
.text$x:00003340 __unwindfunclet$??$_Construct@HH@std@@YAXPAH$$QAH@Z$0 endp
.text$x:00003340
.text$x:00003341
.text$x:00003341 ; =============== S U B R O U T I N E =======================================
.text$x:00003341
.text$x:00003341
.text$x:00003341 __ehhandler$??$_Construct@HH@std@@YAXPAH$$QAH@Z proc near
.text$x:00003341                                         ; DATA XREF: std::_Construct<int,int>(int *,int &&)+5o
.text$x:00003341
.text$x:00003341 arg_4           = dword ptr  8
.text$x:00003341
.text$x:00003341                 mov     edx, [esp+arg_4]
.text$x:00003345                 lea     eax, [edx+0Ch]
.text$x:00003348                 mov     ecx, [edx-14h]
.text$x:0000334B                 xor     ecx, eax
.text$x:0000334D                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003352                 mov     eax, offset __ehfuncinfo$??$_Construct@HH@std@@YAXPAH$$QAH@Z
.text$x:00003357                 jmp     ___CxxFrameHandler3
.text$x:00003357 __ehhandler$??$_Construct@HH@std@@YAXPAH$$QAH@Z endp
.text$x:00003357
.text$x:00003357 _text$x         ends
.text$x:00003357
.text$mn:0000335C ; ===========================================================================
.text$mn:0000335C
.text$mn:0000335C ; Segment type: Pure code
.text$mn:0000335C ; Segment permissions: Read/Execute
.text$mn:0000335C _text$mn        segment para public 'CODE' use32
.text$mn:0000335C                 assume cs:_text$mn
.text$mn:0000335C                 ;org 335Ch
.text$mn:0000335C ; COMDAT (pick any)
.text$mn:0000335C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000335C
.text$mn:0000335C ; =============== S U B R O U T I N E =======================================
.text$mn:0000335C
.text$mn:0000335C ; Attributes: bp-based frame
.text$mn:0000335C
.text$mn:0000335C ; public: void __thiscall std::vector<wchar_t, class std::allocator<wchar_t>>::_Construct<class std::_String_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>>>(class std::_String_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>>, class std::_String_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>>)
.text$mn:0000335C                 public ??$_Construct@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$vector@_WV?$allocator@_W@std@@@std@@QAEXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z
.text$mn:0000335C ??$_Construct@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$vector@_WV?$allocator@_W@std@@@std@@QAEXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z proc near
.text$mn:0000335C                                         ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::vector<wchar_t,std::allocator<wchar_t>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)+87p
.text$mn:0000335C
.text$mn:0000335C var_2C          = dword ptr -2Ch
.text$mn:0000335C var_28          = dword ptr -28h
.text$mn:0000335C var_24          = dword ptr -24h
.text$mn:0000335C var_20          = dword ptr -20h
.text$mn:0000335C var_1C          = dword ptr -1Ch
.text$mn:0000335C var_18          = dword ptr -18h
.text$mn:0000335C var_14          = dword ptr -14h
.text$mn:0000335C var_E           = byte ptr -0Eh
.text$mn:0000335C var_D           = byte ptr -0Dh
.text$mn:0000335C var_C           = dword ptr -0Ch
.text$mn:0000335C var_4           = dword ptr -4
.text$mn:0000335C arg_0           = byte ptr  8
.text$mn:0000335C arg_C           = byte ptr  14h
.text$mn:0000335C
.text$mn:0000335C                 push    ebp
.text$mn:0000335D                 mov     ebp, esp
.text$mn:0000335F                 push    0FFFFFFFFh
.text$mn:00003361                 push    offset __ehhandler$??$_Construct@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$vector@_WV?$allocator@_W@std@@@std@@QAEXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z
.text$mn:00003366                 mov     eax, large fs:0
.text$mn:0000336C                 push    eax
.text$mn:0000336D                 sub     esp, 20h
.text$mn:00003370                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003375                 xor     eax, ebp
.text$mn:00003377                 push    eax
.text$mn:00003378                 lea     eax, [ebp+var_C]
.text$mn:0000337B                 mov     large fs:0, eax
.text$mn:00003381                 mov     [ebp+var_1C], ecx
.text$mn:00003384                 mov     [ebp+var_4], 1
.text$mn:0000338B                 lea     eax, [ebp+arg_0]
.text$mn:0000338E                 push    eax
.text$mn:0000338F                 lea     ecx, [ebp+var_E]
.text$mn:00003392                 push    ecx
.text$mn:00003393                 call    ??$_Iter_cat@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@@Z ; std::_Iter_cat<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:00003398                 add     esp, 8
.text$mn:0000339B                 mov     dl, [eax]
.text$mn:0000339D                 mov     [ebp+var_D], dl
.text$mn:000033A0                 movzx   eax, [ebp+var_D]
.text$mn:000033A4                 push    eax
.text$mn:000033A5                 sub     esp, 0Ch
.text$mn:000033A8                 mov     ecx, esp
.text$mn:000033AA                 mov     [ebp+var_20], esp
.text$mn:000033AD                 lea     edx, [ebp+arg_C]
.text$mn:000033B0                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:000033B1                 call    ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:000033B6                 mov     [ebp+var_14], eax
.text$mn:000033B9                 mov     eax, [ebp+var_14]
.text$mn:000033BC                 mov     [ebp+var_24], eax
.text$mn:000033BF                 mov     byte ptr [ebp+var_4], 2
.text$mn:000033C3                 sub     esp, 0Ch
.text$mn:000033C6                 mov     ecx, esp
.text$mn:000033C8                 mov     [ebp+var_28], esp
.text$mn:000033CB                 lea     edx, [ebp+arg_0]
.text$mn:000033CE                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:000033CF                 call    ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:000033D4                 mov     [ebp+var_18], eax
.text$mn:000033D7                 mov     eax, [ebp+var_18]
.text$mn:000033DA                 mov     [ebp+var_2C], eax
.text$mn:000033DD                 mov     byte ptr [ebp+var_4], 3
.text$mn:000033E1                 mov     byte ptr [ebp+var_4], 1
.text$mn:000033E5                 mov     ecx, [ebp+var_1C]
.text$mn:000033E8                 call    ??$_Construct@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$vector@_WV?$allocator@_W@std@@@std@@QAEXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0Uforward_iterator_tag@1@@Z ; std::vector<wchar_t,std::allocator<wchar_t>>::_Construct<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::forward_iterator_tag)
.text$mn:000033ED                 mov     byte ptr [ebp+var_4], 0
.text$mn:000033F1                 lea     ecx, [ebp+arg_0]
.text$mn:000033F4                 call    ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$mn:000033F9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003400                 lea     ecx, [ebp+arg_C]
.text$mn:00003403                 call    ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$mn:00003408                 mov     ecx, [ebp+var_C]
.text$mn:0000340B                 mov     large fs:0, ecx
.text$mn:00003412                 pop     ecx
.text$mn:00003413                 mov     esp, ebp
.text$mn:00003415                 pop     ebp
.text$mn:00003416                 retn    18h
.text$mn:00003416 ??$_Construct@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$vector@_WV?$allocator@_W@std@@@std@@QAEXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z endp
.text$mn:00003416
.text$mn:00003416 ; ---------------------------------------------------------------------------
.text$mn:00003419                 align 4
.text$mn:00003419 _text$mn        ends
.text$mn:00003419
.text$x:0000341C ; ===========================================================================
.text$x:0000341C
.text$x:0000341C ; Segment type: Pure code
.text$x:0000341C ; Segment permissions: Read/Execute
.text$x:0000341C _text$x         segment para public 'CODE' use32
.text$x:0000341C                 assume cs:_text$x
.text$x:0000341C                 ;org 341Ch
.text$x:0000341C ; COMDAT (pick associative to section at 335C)
.text$x:0000341C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000341C
.text$x:0000341C ; =============== S U B R O U T I N E =======================================
.text$x:0000341C
.text$x:0000341C
.text$x:0000341C __unwindfunclet$??$_Construct@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$vector@_WV?$allocator@_W@std@@@std@@QAEXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$0 proc near
.text$x:0000341C                                         ; DATA XREF: .xdata$x:0000D7CCo
.text$x:0000341C                 lea     ecx, [ebp+14h]
.text$x:0000341F                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:0000341F __unwindfunclet$??$_Construct@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$vector@_WV?$allocator@_W@std@@@std@@QAEXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$0 endp
.text$x:0000341F
.text$x:00003424
.text$x:00003424 ; =============== S U B R O U T I N E =======================================
.text$x:00003424
.text$x:00003424
.text$x:00003424 __unwindfunclet$??$_Construct@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$vector@_WV?$allocator@_W@std@@@std@@QAEXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$1 proc near
.text$x:00003424                                         ; DATA XREF: .xdata$x:0000D7D4o
.text$x:00003424                 lea     ecx, [ebp+8]
.text$x:00003427                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00003427 __unwindfunclet$??$_Construct@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$vector@_WV?$allocator@_W@std@@@std@@QAEXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$1 endp
.text$x:00003427
.text$x:0000342C
.text$x:0000342C ; =============== S U B R O U T I N E =======================================
.text$x:0000342C
.text$x:0000342C
.text$x:0000342C __unwindfunclet$??$_Construct@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$vector@_WV?$allocator@_W@std@@@std@@QAEXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$2 proc near
.text$x:0000342C                                         ; DATA XREF: .xdata$x:0000D7DCo
.text$x:0000342C                 mov     ecx, [ebp-20h]
.text$x:0000342F                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:0000342F __unwindfunclet$??$_Construct@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$vector@_WV?$allocator@_W@std@@@std@@QAEXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$2 endp
.text$x:0000342F
.text$x:00003434
.text$x:00003434 ; =============== S U B R O U T I N E =======================================
.text$x:00003434
.text$x:00003434
.text$x:00003434 __unwindfunclet$??$_Construct@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$vector@_WV?$allocator@_W@std@@@std@@QAEXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$3 proc near
.text$x:00003434                                         ; DATA XREF: .xdata$x:0000D7E4o
.text$x:00003434                 mov     ecx, [ebp-28h]
.text$x:00003437                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00003437 __unwindfunclet$??$_Construct@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$vector@_WV?$allocator@_W@std@@@std@@QAEXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$3 endp
.text$x:00003437
.text$x:0000343C
.text$x:0000343C ; =============== S U B R O U T I N E =======================================
.text$x:0000343C
.text$x:0000343C
.text$x:0000343C __ehhandler$??$_Construct@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$vector@_WV?$allocator@_W@std@@@std@@QAEXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z proc near
.text$x:0000343C                                         ; DATA XREF: std::vector<wchar_t,std::allocator<wchar_t>>::_Construct<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)+5o
.text$x:0000343C
.text$x:0000343C arg_4           = dword ptr  8
.text$x:0000343C
.text$x:0000343C                 mov     edx, [esp+arg_4]
.text$x:00003440                 lea     eax, [edx+0Ch]
.text$x:00003443                 mov     ecx, [edx-24h]
.text$x:00003446                 xor     ecx, eax
.text$x:00003448                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000344D                 mov     eax, offset __ehfuncinfo$??$_Construct@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$vector@_WV?$allocator@_W@std@@@std@@QAEXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z
.text$x:00003452                 jmp     ___CxxFrameHandler3
.text$x:00003452 __ehhandler$??$_Construct@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$vector@_WV?$allocator@_W@std@@@std@@QAEXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z endp
.text$x:00003452
.text$x:00003452 ; ---------------------------------------------------------------------------
.text$x:00003457                 align 4
.text$x:00003457 _text$x         ends
.text$x:00003457
.text$mn:00003458 ; ===========================================================================
.text$mn:00003458
.text$mn:00003458 ; Segment type: Pure code
.text$mn:00003458 ; Segment permissions: Read/Execute
.text$mn:00003458 _text$mn        segment para public 'CODE' use32
.text$mn:00003458                 assume cs:_text$mn
.text$mn:00003458                 ;org 3458h
.text$mn:00003458 ; COMDAT (pick any)
.text$mn:00003458                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003458
.text$mn:00003458 ; =============== S U B R O U T I N E =======================================
.text$mn:00003458
.text$mn:00003458 ; Attributes: bp-based frame
.text$mn:00003458
.text$mn:00003458 ; public: void __thiscall std::vector<wchar_t, class std::allocator<wchar_t>>::_Construct<class std::_String_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>>>(class std::_String_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>>, class std::_String_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>>, struct std::forward_iterator_tag)
.text$mn:00003458                 public ??$_Construct@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$vector@_WV?$allocator@_W@std@@@std@@QAEXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0Uforward_iterator_tag@1@@Z
.text$mn:00003458 ??$_Construct@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$vector@_WV?$allocator@_W@std@@@std@@QAEXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0Uforward_iterator_tag@1@@Z proc near
.text$mn:00003458                                         ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::_Construct<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)+8Cp
.text$mn:00003458
.text$mn:00003458 var_4C          = dword ptr -4Ch
.text$mn:00003458 var_48          = dword ptr -48h
.text$mn:00003458 var_44          = dword ptr -44h
.text$mn:00003458 var_40          = dword ptr -40h
.text$mn:00003458 var_3C          = dword ptr -3Ch
.text$mn:00003458 var_38          = dword ptr -38h
.text$mn:00003458 var_34          = dword ptr -34h
.text$mn:00003458 var_30          = dword ptr -30h
.text$mn:00003458 var_2C          = dword ptr -2Ch
.text$mn:00003458 var_28          = dword ptr -28h
.text$mn:00003458 var_24          = dword ptr -24h
.text$mn:00003458 var_20          = dword ptr -20h
.text$mn:00003458 var_1C          = dword ptr -1Ch
.text$mn:00003458 var_18          = dword ptr -18h
.text$mn:00003458 var_14          = dword ptr -14h
.text$mn:00003458 var_10          = dword ptr -10h
.text$mn:00003458 var_C           = dword ptr -0Ch
.text$mn:00003458 var_4           = dword ptr -4
.text$mn:00003458 arg_0           = byte ptr  8
.text$mn:00003458 arg_C           = byte ptr  14h
.text$mn:00003458
.text$mn:00003458 ; FUNCTION CHUNK AT .text$mn:00003568 SIZE 00000009 BYTES
.text$mn:00003458 ; FUNCTION CHUNK AT .text$mn:00003578 SIZE 0000002F BYTES
.text$mn:00003458
.text$mn:00003458                 push    ebp
.text$mn:00003459                 mov     ebp, esp
.text$mn:0000345B                 push    0FFFFFFFFh
.text$mn:0000345D                 push    offset __ehhandler$??$_Construct@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$vector@_WV?$allocator@_W@std@@@std@@QAEXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0Uforward_iterator_tag@1@@Z
.text$mn:00003462                 mov     eax, large fs:0
.text$mn:00003468                 push    eax
.text$mn:00003469                 push    ecx
.text$mn:0000346A                 sub     esp, 3Ch
.text$mn:0000346D                 push    ebx
.text$mn:0000346E                 push    esi
.text$mn:0000346F                 push    edi
.text$mn:00003470                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003475                 xor     eax, ebp
.text$mn:00003477                 push    eax
.text$mn:00003478                 lea     eax, [ebp+var_C]
.text$mn:0000347B                 mov     large fs:0, eax
.text$mn:00003481                 mov     [ebp+var_10], esp
.text$mn:00003484                 mov     [ebp+var_14], ecx
.text$mn:00003487                 mov     [ebp+var_4], 1
.text$mn:0000348E                 sub     esp, 0Ch
.text$mn:00003491                 mov     ecx, esp
.text$mn:00003493                 mov     [ebp+var_30], esp
.text$mn:00003496                 lea     eax, [ebp+arg_C]
.text$mn:00003499                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:0000349A                 call    ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:0000349F                 mov     [ebp+var_18], eax
.text$mn:000034A2                 mov     ecx, [ebp+var_18]
.text$mn:000034A5                 mov     [ebp+var_34], ecx
.text$mn:000034A8                 mov     byte ptr [ebp+var_4], 2
.text$mn:000034AC                 sub     esp, 0Ch
.text$mn:000034AF                 mov     ecx, esp
.text$mn:000034B1                 mov     [ebp+var_38], esp
.text$mn:000034B4                 lea     edx, [ebp+arg_0]
.text$mn:000034B7                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:000034B8                 call    ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:000034BD                 mov     [ebp+var_1C], eax
.text$mn:000034C0                 mov     eax, [ebp+var_1C]
.text$mn:000034C3                 mov     [ebp+var_3C], eax
.text$mn:000034C6                 mov     byte ptr [ebp+var_4], 3
.text$mn:000034CA                 mov     byte ptr [ebp+var_4], 1
.text$mn:000034CE                 call    ??$distance@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YAHV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0@Z ; std::distance<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)
.text$mn:000034D3                 add     esp, 18h
.text$mn:000034D6                 mov     [ebp+var_20], eax
.text$mn:000034D9                 mov     ecx, [ebp+var_20]
.text$mn:000034DC                 push    ecx
.text$mn:000034DD                 mov     ecx, [ebp+var_14]
.text$mn:000034E0                 call    ?_Buy@?$vector@_WV?$allocator@_W@std@@@std@@IAE_NI@Z ; std::vector<wchar_t,std::allocator<wchar_t>>::_Buy(uint)
.text$mn:000034E5                 movzx   edx, al
.text$mn:000034E8                 test    edx, edx
.text$mn:000034EA                 jz      loc_3578
.text$mn:000034F0                 mov     byte ptr [ebp+var_4], 4
.text$mn:000034F4                 mov     eax, [ebp+var_14]
.text$mn:000034F7                 mov     ecx, [eax+4]
.text$mn:000034FA                 push    ecx
.text$mn:000034FB                 sub     esp, 0Ch
.text$mn:000034FE                 mov     ecx, esp
.text$mn:00003500                 mov     [ebp+var_40], esp
.text$mn:00003503                 lea     edx, [ebp+arg_C]
.text$mn:00003506                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:00003507                 call    ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:0000350C                 mov     [ebp+var_24], eax
.text$mn:0000350F                 mov     eax, [ebp+var_24]
.text$mn:00003512                 mov     [ebp+var_44], eax
.text$mn:00003515                 mov     byte ptr [ebp+var_4], 5
.text$mn:00003519                 sub     esp, 0Ch
.text$mn:0000351C                 mov     ecx, esp
.text$mn:0000351E                 mov     [ebp+var_48], esp
.text$mn:00003521                 lea     edx, [ebp+arg_0]
.text$mn:00003524                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:00003525                 call    ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:0000352A                 mov     [ebp+var_28], eax
.text$mn:0000352D                 mov     eax, [ebp+var_28]
.text$mn:00003530                 mov     [ebp+var_4C], eax
.text$mn:00003533                 mov     byte ptr [ebp+var_4], 6
.text$mn:00003537                 mov     byte ptr [ebp+var_4], 4
.text$mn:0000353B                 mov     ecx, [ebp+var_14]
.text$mn:0000353E                 call    ??$_Ucopy@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$vector@_WV?$allocator@_W@std@@@std@@IAEPA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0PA_W@Z ; std::vector<wchar_t,std::allocator<wchar_t>>::_Ucopy<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,wchar_t *)
.text$mn:00003543                 mov     [ebp+var_2C], eax
.text$mn:00003546                 mov     ecx, [ebp+var_14]
.text$mn:00003549                 mov     edx, [ebp+var_2C]
.text$mn:0000354C                 mov     [ecx+8], edx
.text$mn:0000354F                 jmp     short loc_3568
.text$mn:0000354F ??$_Construct@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$vector@_WV?$allocator@_W@std@@@std@@QAEXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0Uforward_iterator_tag@1@@Z endp
.text$mn:0000354F
.text$mn:00003551
.text$mn:00003551 ; =============== S U B R O U T I N E =======================================
.text$mn:00003551
.text$mn:00003551 ; Attributes: noreturn
.text$mn:00003551
.text$mn:00003551 __catch$??$_Construct@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$vector@_WV?$allocator@_W@std@@@std@@QAEXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0Uforward_iterator_tag@1@@Z$0 proc near
.text$mn:00003551                                         ; DATA XREF: .xdata$x:0000D84Co
.text$mn:00003551                 mov     ecx, [ebp-14h]
.text$mn:00003554                 call    ?_Tidy@?$vector@_WV?$allocator@_W@std@@@std@@IAEXXZ ; std::vector<wchar_t,std::allocator<wchar_t>>::_Tidy(void)
.text$mn:00003559                 push    0
.text$mn:0000355B                 push    0
.text$mn:0000355D                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:0000355D __catch$??$_Construct@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$vector@_WV?$allocator@_W@std@@@std@@QAEXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0Uforward_iterator_tag@1@@Z$0 endp
.text$mn:0000355D
.text$mn:00003562 ; ---------------------------------------------------------------------------
.text$mn:00003562                 mov     eax, offset $LN14_0
.text$mn:00003567                 retn
.text$mn:00003568 ; ---------------------------------------------------------------------------
.text$mn:00003568 ; START OF FUNCTION CHUNK FOR ??$_Construct@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$vector@_WV?$allocator@_W@std@@@std@@QAEXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0Uforward_iterator_tag@1@@Z
.text$mn:00003568
.text$mn:00003568 loc_3568:                               ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::_Construct<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::forward_iterator_tag)+F7j
.text$mn:00003568                 mov     [ebp+var_4], 1
.text$mn:0000356F                 jmp     short loc_3578
.text$mn:0000356F ; END OF FUNCTION CHUNK FOR ??$_Construct@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$vector@_WV?$allocator@_W@std@@@std@@QAEXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0Uforward_iterator_tag@1@@Z
.text$mn:00003571
.text$mn:00003571 ; =============== S U B R O U T I N E =======================================
.text$mn:00003571
.text$mn:00003571
.text$mn:00003571 $LN14_0         proc near               ; DATA XREF: .text$mn:00003562o
.text$mn:00003571                 mov     dword ptr [ebp-4], 1
.text$mn:00003571 $LN14_0         endp ; sp-analysis failed
.text$mn:00003571
.text$mn:00003578 ; START OF FUNCTION CHUNK FOR ??$_Construct@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$vector@_WV?$allocator@_W@std@@@std@@QAEXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0Uforward_iterator_tag@1@@Z
.text$mn:00003578
.text$mn:00003578 loc_3578:                               ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::_Construct<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::forward_iterator_tag)+92j
.text$mn:00003578                                         ; std::vector<wchar_t,std::allocator<wchar_t>>::_Construct<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::forward_iterator_tag)+117j
.text$mn:00003578                 mov     byte ptr [ebp+var_4], 0
.text$mn:0000357C                 lea     ecx, [ebp+arg_0]
.text$mn:0000357F                 call    ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$mn:00003584                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000358B                 lea     ecx, [ebp+arg_C]
.text$mn:0000358E                 call    ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$mn:00003593                 mov     ecx, [ebp+var_C]
.text$mn:00003596                 mov     large fs:0, ecx
.text$mn:0000359D                 pop     ecx
.text$mn:0000359E                 pop     edi
.text$mn:0000359F                 pop     esi
.text$mn:000035A0                 pop     ebx
.text$mn:000035A1                 mov     esp, ebp
.text$mn:000035A3                 pop     ebp
.text$mn:000035A4                 retn    1Ch
.text$mn:000035A4 ; END OF FUNCTION CHUNK FOR ??$_Construct@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$vector@_WV?$allocator@_W@std@@@std@@QAEXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0Uforward_iterator_tag@1@@Z
.text$mn:000035A4 ; ---------------------------------------------------------------------------
.text$mn:000035A7                 align 4
.text$mn:000035A7 _text$mn        ends
.text$mn:000035A7
.text$x:000035A8 ; ===========================================================================
.text$x:000035A8
.text$x:000035A8 ; Segment type: Pure code
.text$x:000035A8 ; Segment permissions: Read/Execute
.text$x:000035A8 _text$x         segment para public 'CODE' use32
.text$x:000035A8                 assume cs:_text$x
.text$x:000035A8                 ;org 35A8h
.text$x:000035A8 ; COMDAT (pick associative to section at 3458)
.text$x:000035A8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000035A8
.text$x:000035A8 ; =============== S U B R O U T I N E =======================================
.text$x:000035A8
.text$x:000035A8
.text$x:000035A8 __unwindfunclet$??$_Construct@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$vector@_WV?$allocator@_W@std@@@std@@QAEXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0Uforward_iterator_tag@1@@Z$2 proc near
.text$x:000035A8                                         ; DATA XREF: .xdata$x:0000D88Co
.text$x:000035A8                 lea     ecx, [ebp+14h]
.text$x:000035AB                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:000035AB __unwindfunclet$??$_Construct@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$vector@_WV?$allocator@_W@std@@@std@@QAEXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0Uforward_iterator_tag@1@@Z$2 endp
.text$x:000035AB
.text$x:000035B0
.text$x:000035B0 ; =============== S U B R O U T I N E =======================================
.text$x:000035B0
.text$x:000035B0
.text$x:000035B0 __unwindfunclet$??$_Construct@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$vector@_WV?$allocator@_W@std@@@std@@QAEXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0Uforward_iterator_tag@1@@Z$3 proc near
.text$x:000035B0                                         ; DATA XREF: .xdata$x:0000D894o
.text$x:000035B0                 lea     ecx, [ebp+8]
.text$x:000035B3                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:000035B3 __unwindfunclet$??$_Construct@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$vector@_WV?$allocator@_W@std@@@std@@QAEXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0Uforward_iterator_tag@1@@Z$3 endp
.text$x:000035B3
.text$x:000035B8
.text$x:000035B8 ; =============== S U B R O U T I N E =======================================
.text$x:000035B8
.text$x:000035B8
.text$x:000035B8 __unwindfunclet$??$_Construct@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$vector@_WV?$allocator@_W@std@@@std@@QAEXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0Uforward_iterator_tag@1@@Z$4 proc near
.text$x:000035B8                                         ; DATA XREF: .xdata$x:0000D89Co
.text$x:000035B8                 mov     ecx, [ebp-30h]
.text$x:000035BB                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:000035BB __unwindfunclet$??$_Construct@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$vector@_WV?$allocator@_W@std@@@std@@QAEXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0Uforward_iterator_tag@1@@Z$4 endp
.text$x:000035BB
.text$x:000035C0
.text$x:000035C0 ; =============== S U B R O U T I N E =======================================
.text$x:000035C0
.text$x:000035C0
.text$x:000035C0 __unwindfunclet$??$_Construct@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$vector@_WV?$allocator@_W@std@@@std@@QAEXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0Uforward_iterator_tag@1@@Z$5 proc near
.text$x:000035C0                                         ; DATA XREF: .xdata$x:0000D8A4o
.text$x:000035C0                 mov     ecx, [ebp-38h]
.text$x:000035C3                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:000035C3 __unwindfunclet$??$_Construct@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$vector@_WV?$allocator@_W@std@@@std@@QAEXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0Uforward_iterator_tag@1@@Z$5 endp
.text$x:000035C3
.text$x:000035C8
.text$x:000035C8 ; =============== S U B R O U T I N E =======================================
.text$x:000035C8
.text$x:000035C8
.text$x:000035C8 __unwindfunclet$??$_Construct@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$vector@_WV?$allocator@_W@std@@@std@@QAEXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0Uforward_iterator_tag@1@@Z$6 proc near
.text$x:000035C8                                         ; DATA XREF: .xdata$x:0000D8B4o
.text$x:000035C8                 mov     ecx, [ebp-40h]
.text$x:000035CB                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:000035CB __unwindfunclet$??$_Construct@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$vector@_WV?$allocator@_W@std@@@std@@QAEXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0Uforward_iterator_tag@1@@Z$6 endp
.text$x:000035CB
.text$x:000035D0
.text$x:000035D0 ; =============== S U B R O U T I N E =======================================
.text$x:000035D0
.text$x:000035D0
.text$x:000035D0 __unwindfunclet$??$_Construct@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$vector@_WV?$allocator@_W@std@@@std@@QAEXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0Uforward_iterator_tag@1@@Z$7 proc near
.text$x:000035D0                                         ; DATA XREF: .xdata$x:0000D8BCo
.text$x:000035D0                 mov     ecx, [ebp-48h]
.text$x:000035D3                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:000035D3 __unwindfunclet$??$_Construct@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$vector@_WV?$allocator@_W@std@@@std@@QAEXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0Uforward_iterator_tag@1@@Z$7 endp
.text$x:000035D3
.text$x:000035D8
.text$x:000035D8 ; =============== S U B R O U T I N E =======================================
.text$x:000035D8
.text$x:000035D8
.text$x:000035D8 __ehhandler$??$_Construct@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$vector@_WV?$allocator@_W@std@@@std@@QAEXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0Uforward_iterator_tag@1@@Z proc near
.text$x:000035D8                                         ; DATA XREF: std::vector<wchar_t,std::allocator<wchar_t>>::_Construct<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::forward_iterator_tag)+5o
.text$x:000035D8
.text$x:000035D8 arg_4           = dword ptr  8
.text$x:000035D8
.text$x:000035D8                 mov     edx, [esp+arg_4]
.text$x:000035DC                 lea     eax, [edx+0Ch]
.text$x:000035DF                 mov     ecx, [edx-50h]
.text$x:000035E2                 xor     ecx, eax
.text$x:000035E4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000035E9                 mov     eax, offset __ehfuncinfo$??$_Construct@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$vector@_WV?$allocator@_W@std@@@std@@QAEXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0Uforward_iterator_tag@1@@Z
.text$x:000035EE                 jmp     ___CxxFrameHandler3
.text$x:000035EE __ehhandler$??$_Construct@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$vector@_WV?$allocator@_W@std@@@std@@QAEXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0Uforward_iterator_tag@1@@Z endp
.text$x:000035EE
.text$x:000035EE ; ---------------------------------------------------------------------------
.text$x:000035F3                 align 4
.text$x:000035F3 _text$x         ends
.text$x:000035F3
.text$mn:000035F4 ; ===========================================================================
.text$mn:000035F4
.text$mn:000035F4 ; Segment type: Pure code
.text$mn:000035F4 ; Segment permissions: Read/Execute
.text$mn:000035F4 _text$mn        segment para public 'CODE' use32
.text$mn:000035F4                 assume cs:_text$mn
.text$mn:000035F4                 ;org 35F4h
.text$mn:000035F4 ; COMDAT (pick any)
.text$mn:000035F4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000035F4
.text$mn:000035F4 ; =============== S U B R O U T I N E =======================================
.text$mn:000035F4
.text$mn:000035F4 ; Attributes: bp-based frame
.text$mn:000035F4
.text$mn:000035F4 ; int __cdecl std::_Debug_lt_pred<BufferEquivalent,int &,int &>(char, int, int, int, int, int, wchar_t *, unsigned int)
.text$mn:000035F4                 public ??$_Debug_lt_pred@UBufferEquivalent@@AAHAAH@std@@YA_NUBufferEquivalent@@AAH1PB_WI@Z
.text$mn:000035F4 ??$_Debug_lt_pred@UBufferEquivalent@@AAHAAH@std@@YA_NUBufferEquivalent@@AAH1PB_WI@Z proc near
.text$mn:000035F4                                         ; CODE XREF: std::_Buffered_merge<int *,int,int,BufferEquivalent>(int *,int *,int *,int,int,std::_Temp_iterator<int> &,BufferEquivalent)+6Fp
.text$mn:000035F4                                         ; std::_Insertion_sort1<int *,BufferEquivalent,int>(int *,int *,BufferEquivalent,int *)+72p ...
.text$mn:000035F4
.text$mn:000035F4 arg_0           = byte ptr  8
.text$mn:000035F4 arg_10          = dword ptr  18h
.text$mn:000035F4 arg_14          = dword ptr  1Ch
.text$mn:000035F4 arg_18          = dword ptr  20h
.text$mn:000035F4 arg_1C          = dword ptr  24h
.text$mn:000035F4
.text$mn:000035F4                 push    ebp
.text$mn:000035F5                 mov     ebp, esp
.text$mn:000035F7                 mov     eax, [ebp+arg_14]
.text$mn:000035FA                 push    eax
.text$mn:000035FB                 call    ??$forward@AAH@std@@YAAAHAAH@Z ; std::forward<int &>(int &)
.text$mn:00003600                 add     esp, 4
.text$mn:00003603                 mov     ecx, [eax]
.text$mn:00003605                 push    ecx
.text$mn:00003606                 mov     edx, [ebp+arg_10]
.text$mn:00003609                 push    edx
.text$mn:0000360A                 call    ??$forward@AAH@std@@YAAAHAAH@Z ; std::forward<int &>(int &)
.text$mn:0000360F                 add     esp, 4
.text$mn:00003612                 mov     eax, [eax]
.text$mn:00003614                 push    eax
.text$mn:00003615                 lea     ecx, [ebp+arg_0]
.text$mn:00003618                 call    ??RBufferEquivalent@@QBE_NHH@Z ; BufferEquivalent::operator()(int,int)
.text$mn:0000361D                 movzx   ecx, al
.text$mn:00003620                 test    ecx, ecx
.text$mn:00003622                 jnz     short loc_362A
.text$mn:00003624                 xor     al, al
.text$mn:00003626                 jmp     short loc_366E
.text$mn:00003628 ; ---------------------------------------------------------------------------
.text$mn:00003628                 jmp     short loc_366C
.text$mn:0000362A ; ---------------------------------------------------------------------------
.text$mn:0000362A
.text$mn:0000362A loc_362A:                               ; CODE XREF: std::_Debug_lt_pred<BufferEquivalent,int &,int &>(BufferEquivalent,int &,int &,wchar_t const *,uint)+2Ej
.text$mn:0000362A                 mov     edx, [ebp+arg_10]
.text$mn:0000362D                 push    edx
.text$mn:0000362E                 call    ??$forward@AAH@std@@YAAAHAAH@Z ; std::forward<int &>(int &)
.text$mn:00003633                 add     esp, 4
.text$mn:00003636                 mov     eax, [eax]
.text$mn:00003638                 push    eax
.text$mn:00003639                 mov     ecx, [ebp+arg_14]
.text$mn:0000363C                 push    ecx
.text$mn:0000363D                 call    ??$forward@AAH@std@@YAAAHAAH@Z ; std::forward<int &>(int &)
.text$mn:00003642                 add     esp, 4
.text$mn:00003645                 mov     edx, [eax]
.text$mn:00003647                 push    edx
.text$mn:00003648                 lea     ecx, [ebp+arg_0]
.text$mn:0000364B                 call    ??RBufferEquivalent@@QBE_NHH@Z ; BufferEquivalent::operator()(int,int)
.text$mn:00003650                 movzx   eax, al
.text$mn:00003653                 test    eax, eax
.text$mn:00003655                 jz      short loc_366C
.text$mn:00003657                 mov     ecx, [ebp+arg_1C]
.text$mn:0000365A                 push    ecx             ; unsigned int
.text$mn:0000365B                 mov     edx, [ebp+arg_18]
.text$mn:0000365E                 push    edx             ; wchar_t *
.text$mn:0000365F                 push    offset ??_C@_1CE@IGJMOCCK@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAo?$AAp?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AA?$AA@ ; "invalid operator<"
.text$mn:00003664                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00003669                 add     esp, 0Ch
.text$mn:0000366C
.text$mn:0000366C loc_366C:                               ; CODE XREF: std::_Debug_lt_pred<BufferEquivalent,int &,int &>(BufferEquivalent,int &,int &,wchar_t const *,uint)+34j
.text$mn:0000366C                                         ; std::_Debug_lt_pred<BufferEquivalent,int &,int &>(BufferEquivalent,int &,int &,wchar_t const *,uint)+61j
.text$mn:0000366C                 mov     al, 1
.text$mn:0000366E
.text$mn:0000366E loc_366E:                               ; CODE XREF: std::_Debug_lt_pred<BufferEquivalent,int &,int &>(BufferEquivalent,int &,int &,wchar_t const *,uint)+32j
.text$mn:0000366E                 pop     ebp
.text$mn:0000366F                 retn
.text$mn:0000366F ??$_Debug_lt_pred@UBufferEquivalent@@AAHAAH@std@@YA_NUBufferEquivalent@@AAH1PB_WI@Z endp
.text$mn:0000366F
.text$mn:0000366F _text$mn        ends
.text$mn:0000366F
.text$mn:00003670 ; ===========================================================================
.text$mn:00003670
.text$mn:00003670 ; Segment type: Pure code
.text$mn:00003670 ; Segment permissions: Read/Execute
.text$mn:00003670 _text$mn        segment para public 'CODE' use32
.text$mn:00003670                 assume cs:_text$mn
.text$mn:00003670                 ;org 3670h
.text$mn:00003670 ; COMDAT (pick any)
.text$mn:00003670                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003670
.text$mn:00003670 ; =============== S U B R O U T I N E =======================================
.text$mn:00003670
.text$mn:00003670 ; Attributes: bp-based frame
.text$mn:00003670
.text$mn:00003670 ; int __cdecl std::_Debug_pointer<char>(int, wchar_t *, unsigned int)
.text$mn:00003670                 public ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z
.text$mn:00003670 ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z proc near
.text$mn:00003670                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+15p
.text$mn:00003670                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+1Bp
.text$mn:00003670
.text$mn:00003670 arg_0           = dword ptr  8
.text$mn:00003670 arg_4           = dword ptr  0Ch
.text$mn:00003670 arg_8           = dword ptr  10h
.text$mn:00003670
.text$mn:00003670                 push    ebp
.text$mn:00003671                 mov     ebp, esp
.text$mn:00003673                 cmp     [ebp+arg_0], 0
.text$mn:00003677                 jnz     short loc_368E
.text$mn:00003679                 mov     eax, [ebp+arg_8]
.text$mn:0000367C                 push    eax             ; unsigned int
.text$mn:0000367D                 mov     ecx, [ebp+arg_4]
.text$mn:00003680                 push    ecx             ; wchar_t *
.text$mn:00003681                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:00003686                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:0000368B                 add     esp, 0Ch
.text$mn:0000368E
.text$mn:0000368E loc_368E:                               ; CODE XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+7j
.text$mn:0000368E                 pop     ebp
.text$mn:0000368F                 retn
.text$mn:0000368F ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z endp
.text$mn:0000368F
.text$mn:0000368F _text$mn        ends
.text$mn:0000368F
.text$mn:00003690 ; ===========================================================================
.text$mn:00003690
.text$mn:00003690 ; Segment type: Pure code
.text$mn:00003690 ; Segment permissions: Read/Execute
.text$mn:00003690 _text$mn        segment para public 'CODE' use32
.text$mn:00003690                 assume cs:_text$mn
.text$mn:00003690                 ;org 3690h
.text$mn:00003690 ; COMDAT (pick any)
.text$mn:00003690                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003690
.text$mn:00003690 ; =============== S U B R O U T I N E =======================================
.text$mn:00003690
.text$mn:00003690 ; Attributes: bp-based frame
.text$mn:00003690
.text$mn:00003690 ; int __cdecl std::_Debug_pointer<int>(int, wchar_t *, unsigned int)
.text$mn:00003690                 public ??$_Debug_pointer@H@std@@YAXPAHPB_WI@Z
.text$mn:00003690 ??$_Debug_pointer@H@std@@YAXPAHPB_WI@Z proc near
.text$mn:00003690                                         ; CODE XREF: std::_Debug_range2<int *>(int *,int *,wchar_t const *,uint,std::random_access_iterator_tag)+17p
.text$mn:00003690                                         ; std::_Debug_range2<int *>(int *,int *,wchar_t const *,uint,std::random_access_iterator_tag)+2Bp ...
.text$mn:00003690
.text$mn:00003690 arg_0           = dword ptr  8
.text$mn:00003690 arg_4           = dword ptr  0Ch
.text$mn:00003690 arg_8           = dword ptr  10h
.text$mn:00003690
.text$mn:00003690                 push    ebp
.text$mn:00003691                 mov     ebp, esp
.text$mn:00003693                 cmp     [ebp+arg_0], 0
.text$mn:00003697                 jnz     short loc_36AE
.text$mn:00003699                 mov     eax, [ebp+arg_8]
.text$mn:0000369C                 push    eax             ; unsigned int
.text$mn:0000369D                 mov     ecx, [ebp+arg_4]
.text$mn:000036A0                 push    ecx             ; wchar_t *
.text$mn:000036A1                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:000036A6                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:000036AB                 add     esp, 0Ch
.text$mn:000036AE
.text$mn:000036AE loc_36AE:                               ; CODE XREF: std::_Debug_pointer<int>(int *,wchar_t const *,uint)+7j
.text$mn:000036AE                 pop     ebp
.text$mn:000036AF                 retn
.text$mn:000036AF ??$_Debug_pointer@H@std@@YAXPAHPB_WI@Z endp
.text$mn:000036AF
.text$mn:000036AF _text$mn        ends
.text$mn:000036AF
.text$mn:000036B0 ; ===========================================================================
.text$mn:000036B0
.text$mn:000036B0 ; Segment type: Pure code
.text$mn:000036B0 ; Segment permissions: Read/Execute
.text$mn:000036B0 _text$mn        segment para public 'CODE' use32
.text$mn:000036B0                 assume cs:_text$mn
.text$mn:000036B0                 ;org 36B0h
.text$mn:000036B0 ; COMDAT (pick any)
.text$mn:000036B0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000036B0
.text$mn:000036B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000036B0
.text$mn:000036B0 ; Attributes: bp-based frame
.text$mn:000036B0
.text$mn:000036B0 ; void __cdecl std::_Debug_pointer<struct BufferEquivalent>(struct BufferEquivalent &, wchar_t const *, unsigned int)
.text$mn:000036B0                 public ??$_Debug_pointer@UBufferEquivalent@@@std@@YAXAAUBufferEquivalent@@PB_WI@Z
.text$mn:000036B0 ??$_Debug_pointer@UBufferEquivalent@@@std@@YAXAAUBufferEquivalent@@PB_WI@Z proc near
.text$mn:000036B0                                         ; CODE XREF: std::stable_sort<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,BufferEquivalent>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,BufferEquivalent)+8Cp
.text$mn:000036B0                 push    ebp
.text$mn:000036B1                 mov     ebp, esp
.text$mn:000036B3                 pop     ebp
.text$mn:000036B4                 retn
.text$mn:000036B4 ??$_Debug_pointer@UBufferEquivalent@@@std@@YAXAAUBufferEquivalent@@PB_WI@Z endp
.text$mn:000036B4
.text$mn:000036B4 ; ---------------------------------------------------------------------------
.text$mn:000036B5                 align 4
.text$mn:000036B5 _text$mn        ends
.text$mn:000036B5
.text$mn:000036B8 ; ===========================================================================
.text$mn:000036B8
.text$mn:000036B8 ; Segment type: Pure code
.text$mn:000036B8 ; Segment permissions: Read/Execute
.text$mn:000036B8 _text$mn        segment para public 'CODE' use32
.text$mn:000036B8                 assume cs:_text$mn
.text$mn:000036B8                 ;org 36B8h
.text$mn:000036B8 ; COMDAT (pick any)
.text$mn:000036B8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000036B8
.text$mn:000036B8 ; =============== S U B R O U T I N E =======================================
.text$mn:000036B8
.text$mn:000036B8 ; Attributes: bp-based frame
.text$mn:000036B8
.text$mn:000036B8 ; void __cdecl std::_Debug_pointer<class std::_String_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>>>(class std::_String_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>> &, wchar_t const *, unsigned int)
.text$mn:000036B8                 public ??$_Debug_pointer@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YAXAAV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@PB_WI@Z
.text$mn:000036B8 ??$_Debug_pointer@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YAXAAV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@PB_WI@Z proc near
.text$mn:000036B8                                         ; CODE XREF: std::_Distance2<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,int>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,int &,std::random_access_iterator_tag)+4Ap
.text$mn:000036B8                                         ; std::_Distance2<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,int>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,int &,std::random_access_iterator_tag)+60p
.text$mn:000036B8                 push    ebp
.text$mn:000036B9                 mov     ebp, esp
.text$mn:000036BB                 pop     ebp
.text$mn:000036BC                 retn
.text$mn:000036BC ??$_Debug_pointer@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YAXAAV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@PB_WI@Z endp
.text$mn:000036BC
.text$mn:000036BC ; ---------------------------------------------------------------------------
.text$mn:000036BD                 align 10h
.text$mn:000036BD _text$mn        ends
.text$mn:000036BD
.text$mn:000036C0 ; ===========================================================================
.text$mn:000036C0
.text$mn:000036C0 ; Segment type: Pure code
.text$mn:000036C0 ; Segment permissions: Read/Execute
.text$mn:000036C0 _text$mn        segment para public 'CODE' use32
.text$mn:000036C0                 assume cs:_text$mn
.text$mn:000036C0                 ;org 36C0h
.text$mn:000036C0 ; COMDAT (pick any)
.text$mn:000036C0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000036C0
.text$mn:000036C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000036C0
.text$mn:000036C0 ; Attributes: bp-based frame
.text$mn:000036C0
.text$mn:000036C0 ; void __cdecl std::_Debug_pointer<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<int>>>>(class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<int>>> &, wchar_t const *, unsigned int)
.text$mn:000036C0                 public ??$_Debug_pointer@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAXAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@PB_WI@Z
.text$mn:000036C0 ??$_Debug_pointer@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAXAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@PB_WI@Z proc near
.text$mn:000036C0                                         ; CODE XREF: std::_Debug_range2<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,wchar_t const *,uint,std::random_access_iterator_tag)+48p
.text$mn:000036C0                                         ; std::_Debug_range2<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,wchar_t const *,uint,std::random_access_iterator_tag)+5Cp
.text$mn:000036C0                 push    ebp
.text$mn:000036C1                 mov     ebp, esp
.text$mn:000036C3                 pop     ebp
.text$mn:000036C4                 retn
.text$mn:000036C4 ??$_Debug_pointer@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAXAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@PB_WI@Z endp
.text$mn:000036C4
.text$mn:000036C4 ; ---------------------------------------------------------------------------
.text$mn:000036C5                 align 4
.text$mn:000036C5 _text$mn        ends
.text$mn:000036C5
.text$mn:000036C8 ; ===========================================================================
.text$mn:000036C8
.text$mn:000036C8 ; Segment type: Pure code
.text$mn:000036C8 ; Segment permissions: Read/Execute
.text$mn:000036C8 _text$mn        segment para public 'CODE' use32
.text$mn:000036C8                 assume cs:_text$mn
.text$mn:000036C8                 ;org 36C8h
.text$mn:000036C8 ; COMDAT (pick any)
.text$mn:000036C8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000036C8
.text$mn:000036C8 ; =============== S U B R O U T I N E =======================================
.text$mn:000036C8
.text$mn:000036C8 ; Attributes: bp-based frame
.text$mn:000036C8
.text$mn:000036C8 ; void __cdecl std::_Debug_pointer<class std::binder2nd<struct std::equal_to<int>>>(class std::binder2nd<struct std::equal_to<int>> &, wchar_t const *, unsigned int)
.text$mn:000036C8                 public ??$_Debug_pointer@V?$binder2nd@U?$equal_to@H@std@@@std@@@std@@YAXAAV?$binder2nd@U?$equal_to@H@std@@@0@PB_WI@Z
.text$mn:000036C8 ??$_Debug_pointer@V?$binder2nd@U?$equal_to@H@std@@@std@@@std@@YAXAAV?$binder2nd@U?$equal_to@H@std@@@0@PB_WI@Z proc near
.text$mn:000036C8                                         ; CODE XREF: std::find_if<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::binder2nd<std::equal_to<int>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::binder2nd<std::equal_to<int>>)+8Dp
.text$mn:000036C8                 push    ebp
.text$mn:000036C9                 mov     ebp, esp
.text$mn:000036CB                 pop     ebp
.text$mn:000036CC                 retn
.text$mn:000036CC ??$_Debug_pointer@V?$binder2nd@U?$equal_to@H@std@@@std@@@std@@YAXAAV?$binder2nd@U?$equal_to@H@std@@@0@PB_WI@Z endp
.text$mn:000036CC
.text$mn:000036CC ; ---------------------------------------------------------------------------
.text$mn:000036CD                 align 10h
.text$mn:000036CD _text$mn        ends
.text$mn:000036CD
.text$mn:000036D0 ; ===========================================================================
.text$mn:000036D0
.text$mn:000036D0 ; Segment type: Pure code
.text$mn:000036D0 ; Segment permissions: Read/Execute
.text$mn:000036D0 _text$mn        segment para public 'CODE' use32
.text$mn:000036D0                 assume cs:_text$mn
.text$mn:000036D0                 ;org 36D0h
.text$mn:000036D0 ; COMDAT (pick any)
.text$mn:000036D0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000036D0
.text$mn:000036D0 ; =============== S U B R O U T I N E =======================================
.text$mn:000036D0
.text$mn:000036D0 ; Attributes: bp-based frame
.text$mn:000036D0
.text$mn:000036D0 ; int __cdecl std::_Debug_pointer<wchar_t>(int, wchar_t *, unsigned int)
.text$mn:000036D0                 public ??$_Debug_pointer@_W@std@@YAXPA_WPB_WI@Z
.text$mn:000036D0 ??$_Debug_pointer@_W@std@@YAXPA_WPB_WI@Z proc near
.text$mn:000036D0                                         ; CODE XREF: std::_Debug_range2<wchar_t *>(wchar_t *,wchar_t *,wchar_t const *,uint,std::random_access_iterator_tag)+17p
.text$mn:000036D0                                         ; std::_Debug_range2<wchar_t *>(wchar_t *,wchar_t *,wchar_t const *,uint,std::random_access_iterator_tag)+2Bp ...
.text$mn:000036D0
.text$mn:000036D0 arg_0           = dword ptr  8
.text$mn:000036D0 arg_4           = dword ptr  0Ch
.text$mn:000036D0 arg_8           = dword ptr  10h
.text$mn:000036D0
.text$mn:000036D0                 push    ebp
.text$mn:000036D1                 mov     ebp, esp
.text$mn:000036D3                 cmp     [ebp+arg_0], 0
.text$mn:000036D7                 jnz     short loc_36EE
.text$mn:000036D9                 mov     eax, [ebp+arg_8]
.text$mn:000036DC                 push    eax             ; unsigned int
.text$mn:000036DD                 mov     ecx, [ebp+arg_4]
.text$mn:000036E0                 push    ecx             ; wchar_t *
.text$mn:000036E1                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:000036E6                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:000036EB                 add     esp, 0Ch
.text$mn:000036EE
.text$mn:000036EE loc_36EE:                               ; CODE XREF: std::_Debug_pointer<wchar_t>(wchar_t *,wchar_t const *,uint)+7j
.text$mn:000036EE                 pop     ebp
.text$mn:000036EF                 retn
.text$mn:000036EF ??$_Debug_pointer@_W@std@@YAXPA_WPB_WI@Z endp
.text$mn:000036EF
.text$mn:000036EF _text$mn        ends
.text$mn:000036EF
.text$mn:000036F0 ; ===========================================================================
.text$mn:000036F0
.text$mn:000036F0 ; Segment type: Pure code
.text$mn:000036F0 ; Segment permissions: Read/Execute
.text$mn:000036F0 _text$mn        segment para public 'CODE' use32
.text$mn:000036F0                 assume cs:_text$mn
.text$mn:000036F0                 ;org 36F0h
.text$mn:000036F0 ; COMDAT (pick any)
.text$mn:000036F0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000036F0
.text$mn:000036F0 ; =============== S U B R O U T I N E =======================================
.text$mn:000036F0
.text$mn:000036F0 ; Attributes: bp-based frame
.text$mn:000036F0
.text$mn:000036F0 ; int __cdecl std::_Debug_pointer<wchar_t>(int, wchar_t *, unsigned int)
.text$mn:000036F0                 public ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z
.text$mn:000036F0 ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z proc near
.text$mn:000036F0                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *)+15p
.text$mn:000036F0                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)+1Dp ...
.text$mn:000036F0
.text$mn:000036F0 arg_0           = dword ptr  8
.text$mn:000036F0 arg_4           = dword ptr  0Ch
.text$mn:000036F0 arg_8           = dword ptr  10h
.text$mn:000036F0
.text$mn:000036F0                 push    ebp
.text$mn:000036F1                 mov     ebp, esp
.text$mn:000036F3                 cmp     [ebp+arg_0], 0
.text$mn:000036F7                 jnz     short loc_370E
.text$mn:000036F9                 mov     eax, [ebp+arg_8]
.text$mn:000036FC                 push    eax             ; unsigned int
.text$mn:000036FD                 mov     ecx, [ebp+arg_4]
.text$mn:00003700                 push    ecx             ; wchar_t *
.text$mn:00003701                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:00003706                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:0000370B                 add     esp, 0Ch
.text$mn:0000370E
.text$mn:0000370E loc_370E:                               ; CODE XREF: std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)+7j
.text$mn:0000370E                 pop     ebp
.text$mn:0000370F                 retn
.text$mn:0000370F ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z endp
.text$mn:0000370F
.text$mn:0000370F _text$mn        ends
.text$mn:0000370F
.text$mn:00003710 ; ===========================================================================
.text$mn:00003710
.text$mn:00003710 ; Segment type: Pure code
.text$mn:00003710 ; Segment permissions: Read/Execute
.text$mn:00003710 _text$mn        segment para public 'CODE' use32
.text$mn:00003710                 assume cs:_text$mn
.text$mn:00003710                 ;org 3710h
.text$mn:00003710 ; COMDAT (pick any)
.text$mn:00003710                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003710
.text$mn:00003710 ; =============== S U B R O U T I N E =======================================
.text$mn:00003710
.text$mn:00003710 ; Attributes: bp-based frame
.text$mn:00003710
.text$mn:00003710 ; int __cdecl std::_Debug_range2<int *>(int, int, wchar_t *, unsigned int)
.text$mn:00003710                 public ??$_Debug_range2@PAH@std@@YAXPAH0PB_WIUrandom_access_iterator_tag@0@@Z
.text$mn:00003710 ??$_Debug_range2@PAH@std@@YAXPAH0PB_WIUrandom_access_iterator_tag@0@@Z proc near
.text$mn:00003710                                         ; CODE XREF: std::_Debug_range<int *>(int *,int *,wchar_t const *,uint)+2Ap
.text$mn:00003710
.text$mn:00003710 arg_0           = dword ptr  8
.text$mn:00003710 arg_4           = dword ptr  0Ch
.text$mn:00003710 arg_8           = dword ptr  10h
.text$mn:00003710 arg_C           = dword ptr  14h
.text$mn:00003710
.text$mn:00003710                 push    ebp
.text$mn:00003711                 mov     ebp, esp
.text$mn:00003713                 mov     eax, [ebp+arg_0]
.text$mn:00003716                 cmp     eax, [ebp+arg_4]
.text$mn:00003719                 jz      short loc_3760
.text$mn:0000371B                 mov     ecx, [ebp+arg_C]
.text$mn:0000371E                 push    ecx             ; unsigned int
.text$mn:0000371F                 mov     edx, [ebp+arg_8]
.text$mn:00003722                 push    edx             ; wchar_t *
.text$mn:00003723                 mov     eax, [ebp+arg_0]
.text$mn:00003726                 push    eax             ; int
.text$mn:00003727                 call    ??$_Debug_pointer@H@std@@YAXPAHPB_WI@Z ; std::_Debug_pointer<int>(int *,wchar_t const *,uint)
.text$mn:0000372C                 add     esp, 0Ch
.text$mn:0000372F                 mov     ecx, [ebp+arg_C]
.text$mn:00003732                 push    ecx             ; unsigned int
.text$mn:00003733                 mov     edx, [ebp+arg_8]
.text$mn:00003736                 push    edx             ; wchar_t *
.text$mn:00003737                 mov     eax, [ebp+arg_4]
.text$mn:0000373A                 push    eax             ; int
.text$mn:0000373B                 call    ??$_Debug_pointer@H@std@@YAXPAHPB_WI@Z ; std::_Debug_pointer<int>(int *,wchar_t const *,uint)
.text$mn:00003740                 add     esp, 0Ch
.text$mn:00003743                 mov     ecx, [ebp+arg_4]
.text$mn:00003746                 cmp     ecx, [ebp+arg_0]
.text$mn:00003749                 jnb     short loc_3760
.text$mn:0000374B                 mov     edx, [ebp+arg_C]
.text$mn:0000374E                 push    edx             ; unsigned int
.text$mn:0000374F                 mov     eax, [ebp+arg_8]
.text$mn:00003752                 push    eax             ; wchar_t *
.text$mn:00003753                 push    offset ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "invalid iterator range"
.text$mn:00003758                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:0000375D                 add     esp, 0Ch
.text$mn:00003760
.text$mn:00003760 loc_3760:                               ; CODE XREF: std::_Debug_range2<int *>(int *,int *,wchar_t const *,uint,std::random_access_iterator_tag)+9j
.text$mn:00003760                                         ; std::_Debug_range2<int *>(int *,int *,wchar_t const *,uint,std::random_access_iterator_tag)+39j
.text$mn:00003760                 pop     ebp
.text$mn:00003761                 retn
.text$mn:00003761 ??$_Debug_range2@PAH@std@@YAXPAH0PB_WIUrandom_access_iterator_tag@0@@Z endp
.text$mn:00003761
.text$mn:00003761 ; ---------------------------------------------------------------------------
.text$mn:00003762                 align 4
.text$mn:00003762 _text$mn        ends
.text$mn:00003762
.text$mn:00003764 ; ===========================================================================
.text$mn:00003764
.text$mn:00003764 ; Segment type: Pure code
.text$mn:00003764 ; Segment permissions: Read/Execute
.text$mn:00003764 _text$mn        segment para public 'CODE' use32
.text$mn:00003764                 assume cs:_text$mn
.text$mn:00003764                 ;org 3764h
.text$mn:00003764 ; COMDAT (pick any)
.text$mn:00003764                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003764
.text$mn:00003764 ; =============== S U B R O U T I N E =======================================
.text$mn:00003764
.text$mn:00003764 ; Attributes: bp-based frame
.text$mn:00003764
.text$mn:00003764 ; int __cdecl std::_Debug_range2<wchar_t *>(int, int, wchar_t *, unsigned int)
.text$mn:00003764                 public ??$_Debug_range2@PA_W@std@@YAXPA_W0PB_WIUrandom_access_iterator_tag@0@@Z
.text$mn:00003764 ??$_Debug_range2@PA_W@std@@YAXPA_W0PB_WIUrandom_access_iterator_tag@0@@Z proc near
.text$mn:00003764                                         ; CODE XREF: std::_Debug_range<wchar_t *>(wchar_t *,wchar_t *,wchar_t const *,uint)+2Ap
.text$mn:00003764
.text$mn:00003764 arg_0           = dword ptr  8
.text$mn:00003764 arg_4           = dword ptr  0Ch
.text$mn:00003764 arg_8           = dword ptr  10h
.text$mn:00003764 arg_C           = dword ptr  14h
.text$mn:00003764
.text$mn:00003764                 push    ebp
.text$mn:00003765                 mov     ebp, esp
.text$mn:00003767                 mov     eax, [ebp+arg_0]
.text$mn:0000376A                 cmp     eax, [ebp+arg_4]
.text$mn:0000376D                 jz      short loc_37B4
.text$mn:0000376F                 mov     ecx, [ebp+arg_C]
.text$mn:00003772                 push    ecx             ; unsigned int
.text$mn:00003773                 mov     edx, [ebp+arg_8]
.text$mn:00003776                 push    edx             ; wchar_t *
.text$mn:00003777                 mov     eax, [ebp+arg_0]
.text$mn:0000377A                 push    eax             ; int
.text$mn:0000377B                 call    ??$_Debug_pointer@_W@std@@YAXPA_WPB_WI@Z ; std::_Debug_pointer<wchar_t>(wchar_t *,wchar_t const *,uint)
.text$mn:00003780                 add     esp, 0Ch
.text$mn:00003783                 mov     ecx, [ebp+arg_C]
.text$mn:00003786                 push    ecx             ; unsigned int
.text$mn:00003787                 mov     edx, [ebp+arg_8]
.text$mn:0000378A                 push    edx             ; wchar_t *
.text$mn:0000378B                 mov     eax, [ebp+arg_4]
.text$mn:0000378E                 push    eax             ; int
.text$mn:0000378F                 call    ??$_Debug_pointer@_W@std@@YAXPA_WPB_WI@Z ; std::_Debug_pointer<wchar_t>(wchar_t *,wchar_t const *,uint)
.text$mn:00003794                 add     esp, 0Ch
.text$mn:00003797                 mov     ecx, [ebp+arg_4]
.text$mn:0000379A                 cmp     ecx, [ebp+arg_0]
.text$mn:0000379D                 jnb     short loc_37B4
.text$mn:0000379F                 mov     edx, [ebp+arg_C]
.text$mn:000037A2                 push    edx             ; unsigned int
.text$mn:000037A3                 mov     eax, [ebp+arg_8]
.text$mn:000037A6                 push    eax             ; wchar_t *
.text$mn:000037A7                 push    offset ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "invalid iterator range"
.text$mn:000037AC                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:000037B1                 add     esp, 0Ch
.text$mn:000037B4
.text$mn:000037B4 loc_37B4:                               ; CODE XREF: std::_Debug_range2<wchar_t *>(wchar_t *,wchar_t *,wchar_t const *,uint,std::random_access_iterator_tag)+9j
.text$mn:000037B4                                         ; std::_Debug_range2<wchar_t *>(wchar_t *,wchar_t *,wchar_t const *,uint,std::random_access_iterator_tag)+39j
.text$mn:000037B4                 pop     ebp
.text$mn:000037B5                 retn
.text$mn:000037B5 ??$_Debug_range2@PA_W@std@@YAXPA_W0PB_WIUrandom_access_iterator_tag@0@@Z endp
.text$mn:000037B5
.text$mn:000037B5 ; ---------------------------------------------------------------------------
.text$mn:000037B6                 align 4
.text$mn:000037B6 _text$mn        ends
.text$mn:000037B6
.text$mn:000037B8 ; ===========================================================================
.text$mn:000037B8
.text$mn:000037B8 ; Segment type: Pure code
.text$mn:000037B8 ; Segment permissions: Read/Execute
.text$mn:000037B8 _text$mn        segment para public 'CODE' use32
.text$mn:000037B8                 assume cs:_text$mn
.text$mn:000037B8                 ;org 37B8h
.text$mn:000037B8 ; COMDAT (pick any)
.text$mn:000037B8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000037B8
.text$mn:000037B8 ; =============== S U B R O U T I N E =======================================
.text$mn:000037B8
.text$mn:000037B8 ; Attributes: bp-based frame
.text$mn:000037B8
.text$mn:000037B8 ; int __cdecl std::_Debug_range2<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>>(char, int, int, char, int, int, wchar_t *, unsigned int)
.text$mn:000037B8                 public ??$_Debug_range2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z
.text$mn:000037B8 ??$_Debug_range2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z proc near
.text$mn:000037B8                                         ; CODE XREF: std::_Debug_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,wchar_t const *,uint)+8Ap
.text$mn:000037B8
.text$mn:000037B8 var_C           = dword ptr -0Ch
.text$mn:000037B8 var_4           = dword ptr -4
.text$mn:000037B8 arg_0           = byte ptr  8
.text$mn:000037B8 arg_C           = byte ptr  14h
.text$mn:000037B8 arg_18          = dword ptr  20h
.text$mn:000037B8 arg_1C          = dword ptr  24h
.text$mn:000037B8
.text$mn:000037B8                 push    ebp
.text$mn:000037B9                 mov     ebp, esp
.text$mn:000037BB                 push    0FFFFFFFFh
.text$mn:000037BD                 push    offset __ehhandler$??$_Debug_range2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z
.text$mn:000037C2                 mov     eax, large fs:0
.text$mn:000037C8                 push    eax
.text$mn:000037C9                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000037CE                 xor     eax, ebp
.text$mn:000037D0                 push    eax
.text$mn:000037D1                 lea     eax, [ebp+var_C]
.text$mn:000037D4                 mov     large fs:0, eax
.text$mn:000037DA                 mov     [ebp+var_4], 1
.text$mn:000037E1                 lea     eax, [ebp+arg_C]
.text$mn:000037E4                 push    eax             ; std::_Iterator_base12 *
.text$mn:000037E5                 lea     ecx, [ebp+arg_0]
.text$mn:000037E8                 call    ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator!=(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>> const &)
.text$mn:000037ED                 movzx   ecx, al
.text$mn:000037F0                 test    ecx, ecx
.text$mn:000037F2                 jz      short loc_3844
.text$mn:000037F4                 mov     edx, [ebp+arg_1C]
.text$mn:000037F7                 push    edx
.text$mn:000037F8                 mov     eax, [ebp+arg_18]
.text$mn:000037FB                 push    eax
.text$mn:000037FC                 lea     ecx, [ebp+arg_0]
.text$mn:000037FF                 push    ecx
.text$mn:00003800                 call    ??$_Debug_pointer@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAXAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@PB_WI@Z ; std::_Debug_pointer<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>> &,wchar_t const *,uint)
.text$mn:00003805                 add     esp, 0Ch
.text$mn:00003808                 mov     edx, [ebp+arg_1C]
.text$mn:0000380B                 push    edx
.text$mn:0000380C                 mov     eax, [ebp+arg_18]
.text$mn:0000380F                 push    eax
.text$mn:00003810                 lea     ecx, [ebp+arg_C]
.text$mn:00003813                 push    ecx
.text$mn:00003814                 call    ??$_Debug_pointer@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAXAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@PB_WI@Z ; std::_Debug_pointer<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>> &,wchar_t const *,uint)
.text$mn:00003819                 add     esp, 0Ch
.text$mn:0000381C                 lea     edx, [ebp+arg_0]
.text$mn:0000381F                 push    edx             ; std::_Iterator_base12 *
.text$mn:00003820                 lea     ecx, [ebp+arg_C]
.text$mn:00003823                 call    ??M?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator<(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>> const &)
.text$mn:00003828                 movzx   eax, al
.text$mn:0000382B                 test    eax, eax
.text$mn:0000382D                 jz      short loc_3844
.text$mn:0000382F                 mov     ecx, [ebp+arg_1C]
.text$mn:00003832                 push    ecx             ; unsigned int
.text$mn:00003833                 mov     edx, [ebp+arg_18]
.text$mn:00003836                 push    edx             ; wchar_t *
.text$mn:00003837                 push    offset ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "invalid iterator range"
.text$mn:0000383C                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00003841                 add     esp, 0Ch
.text$mn:00003844
.text$mn:00003844 loc_3844:                               ; CODE XREF: std::_Debug_range2<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,wchar_t const *,uint,std::random_access_iterator_tag)+3Aj
.text$mn:00003844                                         ; std::_Debug_range2<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,wchar_t const *,uint,std::random_access_iterator_tag)+75j
.text$mn:00003844                 mov     byte ptr [ebp+var_4], 0
.text$mn:00003848                 lea     ecx, [ebp+arg_0]
.text$mn:0000384B                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$mn:00003850                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003857                 lea     ecx, [ebp+arg_C]
.text$mn:0000385A                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$mn:0000385F                 mov     ecx, [ebp+var_C]
.text$mn:00003862                 mov     large fs:0, ecx
.text$mn:00003869                 pop     ecx
.text$mn:0000386A                 mov     esp, ebp
.text$mn:0000386C                 pop     ebp
.text$mn:0000386D                 retn
.text$mn:0000386D ??$_Debug_range2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z endp
.text$mn:0000386D
.text$mn:0000386D ; ---------------------------------------------------------------------------
.text$mn:0000386E                 align 10h
.text$mn:0000386E _text$mn        ends
.text$mn:0000386E
.text$x:00003870 ; ===========================================================================
.text$x:00003870
.text$x:00003870 ; Segment type: Pure code
.text$x:00003870 ; Segment permissions: Read/Execute
.text$x:00003870 _text$x         segment para public 'CODE' use32
.text$x:00003870                 assume cs:_text$x
.text$x:00003870                 ;org 3870h
.text$x:00003870 ; COMDAT (pick associative to section at 37B8)
.text$x:00003870                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00003870
.text$x:00003870 ; =============== S U B R O U T I N E =======================================
.text$x:00003870
.text$x:00003870
.text$x:00003870 __unwindfunclet$??$_Debug_range2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z$0 proc near
.text$x:00003870                                         ; DATA XREF: .xdata$x:0000D810o
.text$x:00003870                 lea     ecx, [ebp+14h]
.text$x:00003873                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$x:00003873 __unwindfunclet$??$_Debug_range2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z$0 endp
.text$x:00003873
.text$x:00003878
.text$x:00003878 ; =============== S U B R O U T I N E =======================================
.text$x:00003878
.text$x:00003878
.text$x:00003878 __unwindfunclet$??$_Debug_range2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z$1 proc near
.text$x:00003878                                         ; DATA XREF: .xdata$x:0000D818o
.text$x:00003878                 lea     ecx, [ebp+8]
.text$x:0000387B                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$x:0000387B __unwindfunclet$??$_Debug_range2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z$1 endp
.text$x:0000387B
.text$x:00003880
.text$x:00003880 ; =============== S U B R O U T I N E =======================================
.text$x:00003880
.text$x:00003880
.text$x:00003880 __ehhandler$??$_Debug_range2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z proc near
.text$x:00003880                                         ; DATA XREF: std::_Debug_range2<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,wchar_t const *,uint,std::random_access_iterator_tag)+5o
.text$x:00003880
.text$x:00003880 arg_4           = dword ptr  8
.text$x:00003880
.text$x:00003880                 mov     edx, [esp+arg_4]
.text$x:00003884                 lea     eax, [edx+0Ch]
.text$x:00003887                 mov     ecx, [edx-4]
.text$x:0000388A                 xor     ecx, eax
.text$x:0000388C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003891                 mov     eax, offset __ehfuncinfo$??$_Debug_range2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z
.text$x:00003896                 jmp     ___CxxFrameHandler3
.text$x:00003896 __ehhandler$??$_Debug_range2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z endp
.text$x:00003896
.text$x:00003896 ; ---------------------------------------------------------------------------
.text$x:0000389B                 align 4
.text$x:0000389B _text$x         ends
.text$x:0000389B
.text$mn:0000389C ; ===========================================================================
.text$mn:0000389C
.text$mn:0000389C ; Segment type: Pure code
.text$mn:0000389C ; Segment permissions: Read/Execute
.text$mn:0000389C _text$mn        segment para public 'CODE' use32
.text$mn:0000389C                 assume cs:_text$mn
.text$mn:0000389C                 ;org 389Ch
.text$mn:0000389C ; COMDAT (pick any)
.text$mn:0000389C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000389C
.text$mn:0000389C ; =============== S U B R O U T I N E =======================================
.text$mn:0000389C
.text$mn:0000389C ; Attributes: bp-based frame
.text$mn:0000389C
.text$mn:0000389C ; int __cdecl std::_Debug_range<int *>(int, int, wchar_t *, unsigned int)
.text$mn:0000389C                 public ??$_Debug_range@PAH@std@@YAXPAH0PB_WI@Z
.text$mn:0000389C ??$_Debug_range@PAH@std@@YAXPAH0PB_WI@Z proc near
.text$mn:0000389C                                         ; CODE XREF: std::_Uninit_move<int,int,int>(int *,int *,int *,std::_Wrap_alloc<std::allocator<int>> &,int *,std::_Scalar_ptr_iterator_tag)+16p
.text$mn:0000389C                                         ; std::rotate<int *>(int *,int *,int *)+16p ...
.text$mn:0000389C
.text$mn:0000389C var_1           = byte ptr -1
.text$mn:0000389C arg_0           = dword ptr  8
.text$mn:0000389C arg_4           = dword ptr  0Ch
.text$mn:0000389C arg_8           = dword ptr  10h
.text$mn:0000389C arg_C           = dword ptr  14h
.text$mn:0000389C
.text$mn:0000389C                 push    ebp
.text$mn:0000389D                 mov     ebp, esp
.text$mn:0000389F                 push    ecx
.text$mn:000038A0                 lea     eax, [ebp+arg_0]
.text$mn:000038A3                 push    eax
.text$mn:000038A4                 lea     ecx, [ebp+var_1]
.text$mn:000038A7                 push    ecx
.text$mn:000038A8                 call    ??$_Iter_cat@PAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH@Z ; std::_Iter_cat<int *>(int * const &)
.text$mn:000038AD                 add     esp, 8
.text$mn:000038B0                 mov     dl, [eax]
.text$mn:000038B2                 movzx   eax, dl
.text$mn:000038B5                 push    eax
.text$mn:000038B6                 mov     ecx, [ebp+arg_C]
.text$mn:000038B9                 push    ecx             ; unsigned int
.text$mn:000038BA                 mov     edx, [ebp+arg_8]
.text$mn:000038BD                 push    edx             ; wchar_t *
.text$mn:000038BE                 mov     eax, [ebp+arg_4]
.text$mn:000038C1                 push    eax             ; int
.text$mn:000038C2                 mov     ecx, [ebp+arg_0]
.text$mn:000038C5                 push    ecx             ; int
.text$mn:000038C6                 call    ??$_Debug_range2@PAH@std@@YAXPAH0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<int *>(int *,int *,wchar_t const *,uint,std::random_access_iterator_tag)
.text$mn:000038CB                 add     esp, 14h
.text$mn:000038CE                 mov     esp, ebp
.text$mn:000038D0                 pop     ebp
.text$mn:000038D1                 retn
.text$mn:000038D1 ??$_Debug_range@PAH@std@@YAXPAH0PB_WI@Z endp
.text$mn:000038D1
.text$mn:000038D1 ; ---------------------------------------------------------------------------
.text$mn:000038D2                 align 4
.text$mn:000038D2 _text$mn        ends
.text$mn:000038D2
.text$mn:000038D4 ; ===========================================================================
.text$mn:000038D4
.text$mn:000038D4 ; Segment type: Pure code
.text$mn:000038D4 ; Segment permissions: Read/Execute
.text$mn:000038D4 _text$mn        segment para public 'CODE' use32
.text$mn:000038D4                 assume cs:_text$mn
.text$mn:000038D4                 ;org 38D4h
.text$mn:000038D4 ; COMDAT (pick any)
.text$mn:000038D4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000038D4
.text$mn:000038D4 ; =============== S U B R O U T I N E =======================================
.text$mn:000038D4
.text$mn:000038D4 ; Attributes: bp-based frame
.text$mn:000038D4
.text$mn:000038D4 ; int __cdecl std::_Debug_range<wchar_t *>(int, int, wchar_t *, unsigned int)
.text$mn:000038D4                 public ??$_Debug_range@PA_W@std@@YAXPA_W0PB_WI@Z
.text$mn:000038D4 ??$_Debug_range@PA_W@std@@YAXPA_W0PB_WI@Z proc near
.text$mn:000038D4                                         ; CODE XREF: std::_Uninit_copy<wchar_t,wchar_t>(wchar_t *,wchar_t *,wchar_t *,std::_Wrap_alloc<std::allocator<wchar_t>> &,std::_Scalar_ptr_iterator_tag)+16p
.text$mn:000038D4                                         ; std::_Uninit_move<wchar_t,wchar_t,wchar_t>(wchar_t *,wchar_t *,wchar_t *,std::_Wrap_alloc<std::allocator<wchar_t>> &,wchar_t *,std::_Scalar_ptr_iterator_tag)+16p
.text$mn:000038D4
.text$mn:000038D4 var_1           = byte ptr -1
.text$mn:000038D4 arg_0           = dword ptr  8
.text$mn:000038D4 arg_4           = dword ptr  0Ch
.text$mn:000038D4 arg_8           = dword ptr  10h
.text$mn:000038D4 arg_C           = dword ptr  14h
.text$mn:000038D4
.text$mn:000038D4                 push    ebp
.text$mn:000038D5                 mov     ebp, esp
.text$mn:000038D7                 push    ecx
.text$mn:000038D8                 lea     eax, [ebp+arg_0]
.text$mn:000038DB                 push    eax
.text$mn:000038DC                 lea     ecx, [ebp+var_1]
.text$mn:000038DF                 push    ecx
.text$mn:000038E0                 call    ??$_Iter_cat@PA_W@std@@YA?AUrandom_access_iterator_tag@0@ABQA_W@Z ; std::_Iter_cat<wchar_t *>(wchar_t * const &)
.text$mn:000038E5                 add     esp, 8
.text$mn:000038E8                 mov     dl, [eax]
.text$mn:000038EA                 movzx   eax, dl
.text$mn:000038ED                 push    eax
.text$mn:000038EE                 mov     ecx, [ebp+arg_C]
.text$mn:000038F1                 push    ecx             ; unsigned int
.text$mn:000038F2                 mov     edx, [ebp+arg_8]
.text$mn:000038F5                 push    edx             ; wchar_t *
.text$mn:000038F6                 mov     eax, [ebp+arg_4]
.text$mn:000038F9                 push    eax             ; int
.text$mn:000038FA                 mov     ecx, [ebp+arg_0]
.text$mn:000038FD                 push    ecx             ; int
.text$mn:000038FE                 call    ??$_Debug_range2@PA_W@std@@YAXPA_W0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<wchar_t *>(wchar_t *,wchar_t *,wchar_t const *,uint,std::random_access_iterator_tag)
.text$mn:00003903                 add     esp, 14h
.text$mn:00003906                 mov     esp, ebp
.text$mn:00003908                 pop     ebp
.text$mn:00003909                 retn
.text$mn:00003909 ??$_Debug_range@PA_W@std@@YAXPA_W0PB_WI@Z endp
.text$mn:00003909
.text$mn:00003909 ; ---------------------------------------------------------------------------
.text$mn:0000390A                 align 4
.text$mn:0000390A _text$mn        ends
.text$mn:0000390A
.text$mn:0000390C ; ===========================================================================
.text$mn:0000390C
.text$mn:0000390C ; Segment type: Pure code
.text$mn:0000390C ; Segment permissions: Read/Execute
.text$mn:0000390C _text$mn        segment para public 'CODE' use32
.text$mn:0000390C                 assume cs:_text$mn
.text$mn:0000390C                 ;org 390Ch
.text$mn:0000390C ; COMDAT (pick any)
.text$mn:0000390C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000390C
.text$mn:0000390C ; =============== S U B R O U T I N E =======================================
.text$mn:0000390C
.text$mn:0000390C ; Attributes: bp-based frame
.text$mn:0000390C
.text$mn:0000390C ; int __cdecl std::_Debug_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>>(char, int, int, int, int, int, wchar_t *, unsigned int)
.text$mn:0000390C                 public ??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0PB_WI@Z
.text$mn:0000390C ??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0PB_WI@Z proc near
.text$mn:0000390C                                         ; CODE XREF: std::find_if<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::binder2nd<std::equal_to<int>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::binder2nd<std::equal_to<int>>)+7Ap
.text$mn:0000390C                                         ; std::stable_sort<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,BufferEquivalent>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,BufferEquivalent)+76p
.text$mn:0000390C
.text$mn:0000390C var_28          = dword ptr -28h
.text$mn:0000390C var_24          = dword ptr -24h
.text$mn:0000390C var_20          = dword ptr -20h
.text$mn:0000390C var_1C          = dword ptr -1Ch
.text$mn:0000390C var_18          = dword ptr -18h
.text$mn:0000390C var_14          = dword ptr -14h
.text$mn:0000390C var_D           = byte ptr -0Dh
.text$mn:0000390C var_C           = dword ptr -0Ch
.text$mn:0000390C var_4           = dword ptr -4
.text$mn:0000390C arg_0           = byte ptr  8
.text$mn:0000390C arg_C           = dword ptr  14h
.text$mn:0000390C arg_18          = dword ptr  20h
.text$mn:0000390C arg_1C          = dword ptr  24h
.text$mn:0000390C
.text$mn:0000390C                 push    ebp
.text$mn:0000390D                 mov     ebp, esp
.text$mn:0000390F                 push    0FFFFFFFFh
.text$mn:00003911                 push    offset __ehhandler$??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0PB_WI@Z
.text$mn:00003916                 mov     eax, large fs:0
.text$mn:0000391C                 push    eax
.text$mn:0000391D                 sub     esp, 1Ch
.text$mn:00003920                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003925                 xor     eax, ebp
.text$mn:00003927                 push    eax
.text$mn:00003928                 lea     eax, [ebp+var_C]
.text$mn:0000392B                 mov     large fs:0, eax
.text$mn:00003931                 mov     [ebp+var_4], 1
.text$mn:00003938                 lea     eax, [ebp+arg_0]
.text$mn:0000393B                 push    eax
.text$mn:0000393C                 lea     ecx, [ebp+var_D]
.text$mn:0000393F                 push    ecx
.text$mn:00003940                 call    ??$_Iter_cat@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@@Z ; std::_Iter_cat<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>> const &)
.text$mn:00003945                 add     esp, 8
.text$mn:00003948                 mov     dl, [eax]
.text$mn:0000394A                 movzx   eax, dl
.text$mn:0000394D                 push    eax
.text$mn:0000394E                 mov     ecx, [ebp+arg_1C]
.text$mn:00003951                 push    ecx             ; unsigned int
.text$mn:00003952                 mov     edx, [ebp+arg_18]
.text$mn:00003955                 push    edx             ; wchar_t *
.text$mn:00003956                 sub     esp, 0Ch
.text$mn:00003959                 mov     ecx, esp
.text$mn:0000395B                 mov     [ebp+var_1C], esp
.text$mn:0000395E                 lea     eax, [ebp+arg_C]
.text$mn:00003961                 push    eax             ; int
.text$mn:00003962                 call    ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>> const &)
.text$mn:00003967                 mov     [ebp+var_14], eax
.text$mn:0000396A                 mov     ecx, [ebp+var_14]
.text$mn:0000396D                 mov     [ebp+var_20], ecx
.text$mn:00003970                 mov     byte ptr [ebp+var_4], 2
.text$mn:00003974                 sub     esp, 0Ch
.text$mn:00003977                 mov     ecx, esp
.text$mn:00003979                 mov     [ebp+var_24], esp
.text$mn:0000397C                 lea     edx, [ebp+arg_0]
.text$mn:0000397F                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:00003980                 call    ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>> const &)
.text$mn:00003985                 mov     [ebp+var_18], eax
.text$mn:00003988                 mov     eax, [ebp+var_18]
.text$mn:0000398B                 mov     [ebp+var_28], eax
.text$mn:0000398E                 mov     byte ptr [ebp+var_4], 3
.text$mn:00003992                 mov     byte ptr [ebp+var_4], 1
.text$mn:00003996                 call    ??$_Debug_range2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,wchar_t const *,uint,std::random_access_iterator_tag)
.text$mn:0000399B                 add     esp, 24h
.text$mn:0000399E                 mov     byte ptr [ebp+var_4], 0
.text$mn:000039A2                 lea     ecx, [ebp+arg_0]
.text$mn:000039A5                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$mn:000039AA                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000039B1                 lea     ecx, [ebp+arg_C]
.text$mn:000039B4                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$mn:000039B9                 mov     ecx, [ebp+var_C]
.text$mn:000039BC                 mov     large fs:0, ecx
.text$mn:000039C3                 pop     ecx
.text$mn:000039C4                 mov     esp, ebp
.text$mn:000039C6                 pop     ebp
.text$mn:000039C7                 retn
.text$mn:000039C7 ??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0PB_WI@Z endp
.text$mn:000039C7
.text$mn:000039C7 _text$mn        ends
.text$mn:000039C7
.text$x:000039C8 ; ===========================================================================
.text$x:000039C8
.text$x:000039C8 ; Segment type: Pure code
.text$x:000039C8 ; Segment permissions: Read/Execute
.text$x:000039C8 _text$x         segment para public 'CODE' use32
.text$x:000039C8                 assume cs:_text$x
.text$x:000039C8                 ;org 39C8h
.text$x:000039C8 ; COMDAT (pick associative to section at 390C)
.text$x:000039C8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000039C8
.text$x:000039C8 ; =============== S U B R O U T I N E =======================================
.text$x:000039C8
.text$x:000039C8
.text$x:000039C8 __unwindfunclet$??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0PB_WI@Z$0 proc near
.text$x:000039C8                                         ; DATA XREF: .xdata$x:0000D67Co
.text$x:000039C8                 lea     ecx, [ebp+14h]
.text$x:000039CB                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$x:000039CB __unwindfunclet$??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0PB_WI@Z$0 endp
.text$x:000039CB
.text$x:000039D0
.text$x:000039D0 ; =============== S U B R O U T I N E =======================================
.text$x:000039D0
.text$x:000039D0
.text$x:000039D0 __unwindfunclet$??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0PB_WI@Z$1 proc near
.text$x:000039D0                                         ; DATA XREF: .xdata$x:0000D684o
.text$x:000039D0                 lea     ecx, [ebp+8]
.text$x:000039D3                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$x:000039D3 __unwindfunclet$??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0PB_WI@Z$1 endp
.text$x:000039D3
.text$x:000039D8
.text$x:000039D8 ; =============== S U B R O U T I N E =======================================
.text$x:000039D8
.text$x:000039D8
.text$x:000039D8 __unwindfunclet$??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0PB_WI@Z$2 proc near
.text$x:000039D8                                         ; DATA XREF: .xdata$x:0000D68Co
.text$x:000039D8                 mov     ecx, [ebp-1Ch]
.text$x:000039DB                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$x:000039DB __unwindfunclet$??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0PB_WI@Z$2 endp
.text$x:000039DB
.text$x:000039E0
.text$x:000039E0 ; =============== S U B R O U T I N E =======================================
.text$x:000039E0
.text$x:000039E0
.text$x:000039E0 __unwindfunclet$??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0PB_WI@Z$3 proc near
.text$x:000039E0                                         ; DATA XREF: .xdata$x:0000D694o
.text$x:000039E0                 mov     ecx, [ebp-24h]
.text$x:000039E3                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$x:000039E3 __unwindfunclet$??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0PB_WI@Z$3 endp
.text$x:000039E3
.text$x:000039E8
.text$x:000039E8 ; =============== S U B R O U T I N E =======================================
.text$x:000039E8
.text$x:000039E8
.text$x:000039E8 __ehhandler$??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0PB_WI@Z proc near
.text$x:000039E8                                         ; DATA XREF: std::_Debug_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,wchar_t const *,uint)+5o
.text$x:000039E8
.text$x:000039E8 arg_4           = dword ptr  8
.text$x:000039E8
.text$x:000039E8                 mov     edx, [esp+arg_4]
.text$x:000039EC                 lea     eax, [edx+0Ch]
.text$x:000039EF                 mov     ecx, [edx-20h]
.text$x:000039F2                 xor     ecx, eax
.text$x:000039F4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000039F9                 mov     eax, offset __ehfuncinfo$??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0PB_WI@Z
.text$x:000039FE                 jmp     ___CxxFrameHandler3
.text$x:000039FE __ehhandler$??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0PB_WI@Z endp
.text$x:000039FE
.text$x:000039FE ; ---------------------------------------------------------------------------
.text$x:00003A03                 align 4
.text$x:00003A03 _text$x         ends
.text$x:00003A03
.text$mn:00003A04 ; ===========================================================================
.text$mn:00003A04
.text$mn:00003A04 ; Segment type: Pure code
.text$mn:00003A04 ; Segment permissions: Read/Execute
.text$mn:00003A04 _text$mn        segment para public 'CODE' use32
.text$mn:00003A04                 assume cs:_text$mn
.text$mn:00003A04                 ;org 3A04h
.text$mn:00003A04 ; COMDAT (pick any)
.text$mn:00003A04                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003A04
.text$mn:00003A04 ; =============== S U B R O U T I N E =======================================
.text$mn:00003A04
.text$mn:00003A04 ; Attributes: bp-based frame
.text$mn:00003A04
.text$mn:00003A04 ; void __cdecl std::_Destroy<int>(int *)
.text$mn:00003A04                 public ??$_Destroy@H@std@@YAXPAH@Z
.text$mn:00003A04 ??$_Destroy@H@std@@YAXPAH@Z proc near   ; CODE XREF: std::_Temp_iterator<int>::~_Temp_iterator<int>(void)+33p
.text$mn:00003A04                 push    ebp
.text$mn:00003A05                 mov     ebp, esp
.text$mn:00003A07                 pop     ebp
.text$mn:00003A08                 retn
.text$mn:00003A08 ??$_Destroy@H@std@@YAXPAH@Z endp
.text$mn:00003A08
.text$mn:00003A08 ; ---------------------------------------------------------------------------
.text$mn:00003A09                 align 4
.text$mn:00003A09 _text$mn        ends
.text$mn:00003A09
.text$mn:00003A0C ; ===========================================================================
.text$mn:00003A0C
.text$mn:00003A0C ; Segment type: Pure code
.text$mn:00003A0C ; Segment permissions: Read/Execute
.text$mn:00003A0C _text$mn        segment para public 'CODE' use32
.text$mn:00003A0C                 assume cs:_text$mn
.text$mn:00003A0C                 ;org 3A0Ch
.text$mn:00003A0C ; COMDAT (pick any)
.text$mn:00003A0C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003A0C
.text$mn:00003A0C ; =============== S U B R O U T I N E =======================================
.text$mn:00003A0C
.text$mn:00003A0C ; Attributes: bp-based frame
.text$mn:00003A0C
.text$mn:00003A0C ; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<int>>>(int *, int *, struct std::_Wrap_alloc<class std::allocator<int>> &)
.text$mn:00003A0C                 public ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@@std@@YAXPAH0AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@@Z
.text$mn:00003A0C ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@@std@@YAXPAH0AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@@Z proc near
.text$mn:00003A0C                                         ; CODE XREF: std::vector<int,std::allocator<int>>::_Destroy(int *,int *)+21p
.text$mn:00003A0C
.text$mn:00003A0C var_1           = byte ptr -1
.text$mn:00003A0C arg_0           = dword ptr  8
.text$mn:00003A0C arg_4           = dword ptr  0Ch
.text$mn:00003A0C arg_8           = dword ptr  10h
.text$mn:00003A0C
.text$mn:00003A0C                 push    ebp
.text$mn:00003A0D                 mov     ebp, esp
.text$mn:00003A0F                 push    ecx
.text$mn:00003A10                 mov     eax, [ebp+arg_4]
.text$mn:00003A13                 push    eax
.text$mn:00003A14                 mov     ecx, [ebp+arg_0]
.text$mn:00003A17                 push    ecx
.text$mn:00003A18                 call    ??$_Ptr_cat@HH@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAH0@Z ; std::_Ptr_cat<int,int>(int *,int *)
.text$mn:00003A1D                 add     esp, 8
.text$mn:00003A20                 mov     [ebp+var_1], al
.text$mn:00003A23                 movzx   edx, [ebp+var_1]
.text$mn:00003A27                 push    edx
.text$mn:00003A28                 mov     eax, [ebp+arg_8]
.text$mn:00003A2B                 push    eax
.text$mn:00003A2C                 mov     ecx, [ebp+arg_4]
.text$mn:00003A2F                 push    ecx
.text$mn:00003A30                 mov     edx, [ebp+arg_0]
.text$mn:00003A33                 push    edx
.text$mn:00003A34                 call    ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@@std@@YAXPAH0AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<int>>>(int *,int *,std::_Wrap_alloc<std::allocator<int>> &,std::_Scalar_ptr_iterator_tag)
.text$mn:00003A39                 add     esp, 10h
.text$mn:00003A3C                 mov     esp, ebp
.text$mn:00003A3E                 pop     ebp
.text$mn:00003A3F                 retn
.text$mn:00003A3F ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@@std@@YAXPAH0AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@@Z endp
.text$mn:00003A3F
.text$mn:00003A3F _text$mn        ends
.text$mn:00003A3F
.text$mn:00003A40 ; ===========================================================================
.text$mn:00003A40
.text$mn:00003A40 ; Segment type: Pure code
.text$mn:00003A40 ; Segment permissions: Read/Execute
.text$mn:00003A40 _text$mn        segment para public 'CODE' use32
.text$mn:00003A40                 assume cs:_text$mn
.text$mn:00003A40                 ;org 3A40h
.text$mn:00003A40 ; COMDAT (pick any)
.text$mn:00003A40                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003A40
.text$mn:00003A40 ; =============== S U B R O U T I N E =======================================
.text$mn:00003A40
.text$mn:00003A40 ; Attributes: bp-based frame
.text$mn:00003A40
.text$mn:00003A40 ; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<int>>>(int *, int *, struct std::_Wrap_alloc<class std::allocator<int>> &, struct std::_Scalar_ptr_iterator_tag)
.text$mn:00003A40                 public ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@@std@@YAXPAH0AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
.text$mn:00003A40 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@@std@@YAXPAH0AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z proc near
.text$mn:00003A40                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<int>>>(int *,int *,std::_Wrap_alloc<std::allocator<int>> &)+28p
.text$mn:00003A40                 push    ebp
.text$mn:00003A41                 mov     ebp, esp
.text$mn:00003A43                 pop     ebp
.text$mn:00003A44                 retn
.text$mn:00003A44 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@@std@@YAXPAH0AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z endp
.text$mn:00003A44
.text$mn:00003A44 ; ---------------------------------------------------------------------------
.text$mn:00003A45                 align 4
.text$mn:00003A45 _text$mn        ends
.text$mn:00003A45
.text$mn:00003A48 ; ===========================================================================
.text$mn:00003A48
.text$mn:00003A48 ; Segment type: Pure code
.text$mn:00003A48 ; Segment permissions: Read/Execute
.text$mn:00003A48 _text$mn        segment para public 'CODE' use32
.text$mn:00003A48                 assume cs:_text$mn
.text$mn:00003A48                 ;org 3A48h
.text$mn:00003A48 ; COMDAT (pick any)
.text$mn:00003A48                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003A48
.text$mn:00003A48 ; =============== S U B R O U T I N E =======================================
.text$mn:00003A48
.text$mn:00003A48 ; Attributes: bp-based frame
.text$mn:00003A48
.text$mn:00003A48 ; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<wchar_t>>>(wchar_t *, wchar_t *, struct std::_Wrap_alloc<class std::allocator<wchar_t>> &)
.text$mn:00003A48                 public ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YAXPA_W0AAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@@Z
.text$mn:00003A48 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YAXPA_W0AAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@@Z proc near
.text$mn:00003A48                                         ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::_Destroy(wchar_t *,wchar_t *)+21p
.text$mn:00003A48
.text$mn:00003A48 var_1           = byte ptr -1
.text$mn:00003A48 arg_0           = dword ptr  8
.text$mn:00003A48 arg_4           = dword ptr  0Ch
.text$mn:00003A48 arg_8           = dword ptr  10h
.text$mn:00003A48
.text$mn:00003A48                 push    ebp
.text$mn:00003A49                 mov     ebp, esp
.text$mn:00003A4B                 push    ecx
.text$mn:00003A4C                 mov     eax, [ebp+arg_4]
.text$mn:00003A4F                 push    eax
.text$mn:00003A50                 mov     ecx, [ebp+arg_0]
.text$mn:00003A53                 push    ecx
.text$mn:00003A54                 call    ??$_Ptr_cat@_W_W@std@@YA?AU_Scalar_ptr_iterator_tag@0@PA_W0@Z ; std::_Ptr_cat<wchar_t,wchar_t>(wchar_t *,wchar_t *)
.text$mn:00003A59                 add     esp, 8
.text$mn:00003A5C                 mov     [ebp+var_1], al
.text$mn:00003A5F                 movzx   edx, [ebp+var_1]
.text$mn:00003A63                 push    edx
.text$mn:00003A64                 mov     eax, [ebp+arg_8]
.text$mn:00003A67                 push    eax
.text$mn:00003A68                 mov     ecx, [ebp+arg_4]
.text$mn:00003A6B                 push    ecx
.text$mn:00003A6C                 mov     edx, [ebp+arg_0]
.text$mn:00003A6F                 push    edx
.text$mn:00003A70                 call    ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YAXPA_W0AAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<wchar_t>>>(wchar_t *,wchar_t *,std::_Wrap_alloc<std::allocator<wchar_t>> &,std::_Scalar_ptr_iterator_tag)
.text$mn:00003A75                 add     esp, 10h
.text$mn:00003A78                 mov     esp, ebp
.text$mn:00003A7A                 pop     ebp
.text$mn:00003A7B                 retn
.text$mn:00003A7B ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YAXPA_W0AAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@@Z endp
.text$mn:00003A7B
.text$mn:00003A7B _text$mn        ends
.text$mn:00003A7B
.text$mn:00003A7C ; ===========================================================================
.text$mn:00003A7C
.text$mn:00003A7C ; Segment type: Pure code
.text$mn:00003A7C ; Segment permissions: Read/Execute
.text$mn:00003A7C _text$mn        segment para public 'CODE' use32
.text$mn:00003A7C                 assume cs:_text$mn
.text$mn:00003A7C                 ;org 3A7Ch
.text$mn:00003A7C ; COMDAT (pick any)
.text$mn:00003A7C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003A7C
.text$mn:00003A7C ; =============== S U B R O U T I N E =======================================
.text$mn:00003A7C
.text$mn:00003A7C ; Attributes: bp-based frame
.text$mn:00003A7C
.text$mn:00003A7C ; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<wchar_t>>>(wchar_t *, wchar_t *, struct std::_Wrap_alloc<class std::allocator<wchar_t>> &, struct std::_Scalar_ptr_iterator_tag)
.text$mn:00003A7C                 public ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YAXPA_W0AAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
.text$mn:00003A7C ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YAXPA_W0AAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z proc near
.text$mn:00003A7C                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<wchar_t>>>(wchar_t *,wchar_t *,std::_Wrap_alloc<std::allocator<wchar_t>> &)+28p
.text$mn:00003A7C                 push    ebp
.text$mn:00003A7D                 mov     ebp, esp
.text$mn:00003A7F                 pop     ebp
.text$mn:00003A80                 retn
.text$mn:00003A80 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YAXPA_W0AAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z endp
.text$mn:00003A80
.text$mn:00003A80 ; ---------------------------------------------------------------------------
.text$mn:00003A81                 align 4
.text$mn:00003A81 _text$mn        ends
.text$mn:00003A81
.text$mn:00003A84 ; ===========================================================================
.text$mn:00003A84
.text$mn:00003A84 ; Segment type: Pure code
.text$mn:00003A84 ; Segment permissions: Read/Execute
.text$mn:00003A84 _text$mn        segment para public 'CODE' use32
.text$mn:00003A84                 assume cs:_text$mn
.text$mn:00003A84                 ;org 3A84h
.text$mn:00003A84 ; COMDAT (pick any)
.text$mn:00003A84                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003A84
.text$mn:00003A84 ; =============== S U B R O U T I N E =======================================
.text$mn:00003A84
.text$mn:00003A84 ; Attributes: bp-based frame
.text$mn:00003A84
.text$mn:00003A84 ; int * __cdecl std::_Dist_type<int *>(int *)
.text$mn:00003A84                 public ??$_Dist_type@PAH@std@@YAPAHPAH@Z
.text$mn:00003A84 ??$_Dist_type@PAH@std@@YAPAHPAH@Z proc near
.text$mn:00003A84                                         ; CODE XREF: std::_Rotate<int *>(int *,int *,int *,std::random_access_iterator_tag)+14p
.text$mn:00003A84                                         ; std::lower_bound<int *,int,BufferEquivalent>(int *,int *,int const &,BufferEquivalent)+7p ...
.text$mn:00003A84                 push    ebp
.text$mn:00003A85                 mov     ebp, esp
.text$mn:00003A87                 xor     eax, eax
.text$mn:00003A89                 pop     ebp
.text$mn:00003A8A                 retn
.text$mn:00003A8A ??$_Dist_type@PAH@std@@YAPAHPAH@Z endp
.text$mn:00003A8A
.text$mn:00003A8A ; ---------------------------------------------------------------------------
.text$mn:00003A8B                 align 4
.text$mn:00003A8B _text$mn        ends
.text$mn:00003A8B
.text$mn:00003A8C ; ===========================================================================
.text$mn:00003A8C
.text$mn:00003A8C ; Segment type: Pure code
.text$mn:00003A8C ; Segment permissions: Read/Execute
.text$mn:00003A8C _text$mn        segment para public 'CODE' use32
.text$mn:00003A8C                 assume cs:_text$mn
.text$mn:00003A8C                 ;org 3A8Ch
.text$mn:00003A8C ; COMDAT (pick any)
.text$mn:00003A8C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003A8C
.text$mn:00003A8C ; =============== S U B R O U T I N E =======================================
.text$mn:00003A8C
.text$mn:00003A8C ; Attributes: bp-based frame
.text$mn:00003A8C
.text$mn:00003A8C ; int * __cdecl std::_Dist_type<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<int>>>>(class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<int>>>)
.text$mn:00003A8C                 public ??$_Dist_type@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAPAHV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@@Z
.text$mn:00003A8C ??$_Dist_type@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAPAHV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@@Z proc near
.text$mn:00003A8C                                         ; CODE XREF: std::stable_sort<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,BufferEquivalent>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,BufferEquivalent)+11Ap
.text$mn:00003A8C
.text$mn:00003A8C var_10          = dword ptr -10h
.text$mn:00003A8C var_C           = dword ptr -0Ch
.text$mn:00003A8C var_4           = dword ptr -4
.text$mn:00003A8C arg_0           = byte ptr  8
.text$mn:00003A8C
.text$mn:00003A8C                 push    ebp
.text$mn:00003A8D                 mov     ebp, esp
.text$mn:00003A8F                 push    0FFFFFFFFh
.text$mn:00003A91                 push    offset __ehhandler$??$_Dist_type@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAPAHV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@@Z
.text$mn:00003A96                 mov     eax, large fs:0
.text$mn:00003A9C                 push    eax
.text$mn:00003A9D                 push    ecx
.text$mn:00003A9E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003AA3                 xor     eax, ebp
.text$mn:00003AA5                 push    eax
.text$mn:00003AA6                 lea     eax, [ebp+var_C]
.text$mn:00003AA9                 mov     large fs:0, eax
.text$mn:00003AAF                 mov     [ebp+var_4], 0
.text$mn:00003AB6                 mov     [ebp+var_10], 0
.text$mn:00003ABD                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003AC4                 lea     ecx, [ebp+arg_0]
.text$mn:00003AC7                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$mn:00003ACC                 mov     eax, [ebp+var_10]
.text$mn:00003ACF                 mov     ecx, [ebp+var_C]
.text$mn:00003AD2                 mov     large fs:0, ecx
.text$mn:00003AD9                 pop     ecx
.text$mn:00003ADA                 mov     esp, ebp
.text$mn:00003ADC                 pop     ebp
.text$mn:00003ADD                 retn
.text$mn:00003ADD ??$_Dist_type@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAPAHV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@@Z endp
.text$mn:00003ADD
.text$mn:00003ADD ; ---------------------------------------------------------------------------
.text$mn:00003ADE                 align 10h
.text$mn:00003ADE _text$mn        ends
.text$mn:00003ADE
.text$x:00003AE0 ; ===========================================================================
.text$x:00003AE0
.text$x:00003AE0 ; Segment type: Pure code
.text$x:00003AE0 ; Segment permissions: Read/Execute
.text$x:00003AE0 _text$x         segment para public 'CODE' use32
.text$x:00003AE0                 assume cs:_text$x
.text$x:00003AE0                 ;org 3AE0h
.text$x:00003AE0 ; COMDAT (pick associative to section at 3A8C)
.text$x:00003AE0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00003AE0
.text$x:00003AE0 ; =============== S U B R O U T I N E =======================================
.text$x:00003AE0
.text$x:00003AE0
.text$x:00003AE0 __unwindfunclet$??$_Dist_type@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAPAHV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@@Z$0 proc near
.text$x:00003AE0                                         ; DATA XREF: .xdata$x:0000D6ECo
.text$x:00003AE0                 lea     ecx, [ebp+8]
.text$x:00003AE3                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$x:00003AE3 __unwindfunclet$??$_Dist_type@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAPAHV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@@Z$0 endp
.text$x:00003AE3
.text$x:00003AE8
.text$x:00003AE8 ; =============== S U B R O U T I N E =======================================
.text$x:00003AE8
.text$x:00003AE8
.text$x:00003AE8 __ehhandler$??$_Dist_type@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAPAHV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@@Z proc near
.text$x:00003AE8                                         ; DATA XREF: std::_Dist_type<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>)+5o
.text$x:00003AE8
.text$x:00003AE8 arg_4           = dword ptr  8
.text$x:00003AE8
.text$x:00003AE8                 mov     edx, [esp+arg_4]
.text$x:00003AEC                 lea     eax, [edx+0Ch]
.text$x:00003AEF                 mov     ecx, [edx-8]
.text$x:00003AF2                 xor     ecx, eax
.text$x:00003AF4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003AF9                 mov     eax, offset __ehfuncinfo$??$_Dist_type@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAPAHV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@@Z
.text$x:00003AFE                 jmp     ___CxxFrameHandler3
.text$x:00003AFE __ehhandler$??$_Dist_type@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAPAHV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@@Z endp
.text$x:00003AFE
.text$x:00003AFE ; ---------------------------------------------------------------------------
.text$x:00003B03                 align 4
.text$x:00003B03 _text$x         ends
.text$x:00003B03
.text$mn:00003B04 ; ===========================================================================
.text$mn:00003B04
.text$mn:00003B04 ; Segment type: Pure code
.text$mn:00003B04 ; Segment permissions: Read/Execute
.text$mn:00003B04 _text$mn        segment para public 'CODE' use32
.text$mn:00003B04                 assume cs:_text$mn
.text$mn:00003B04                 ;org 3B04h
.text$mn:00003B04 ; COMDAT (pick any)
.text$mn:00003B04                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003B04
.text$mn:00003B04 ; =============== S U B R O U T I N E =======================================
.text$mn:00003B04
.text$mn:00003B04 ; Attributes: bp-based frame
.text$mn:00003B04
.text$mn:00003B04 ; void __cdecl std::_Distance2<int *, int>(int *, int *, int &, struct std::random_access_iterator_tag)
.text$mn:00003B04                 public ??$_Distance2@PAHH@std@@YAXPAH0AAHUrandom_access_iterator_tag@0@@Z
.text$mn:00003B04 ??$_Distance2@PAHH@std@@YAXPAH0AAHUrandom_access_iterator_tag@0@@Z proc near
.text$mn:00003B04                                         ; CODE XREF: std::_Distance<int *,int>(int *,int *,int &)+26p
.text$mn:00003B04                                         ; std::distance<int *>(int *,int *)+2Fp
.text$mn:00003B04
.text$mn:00003B04 arg_0           = dword ptr  8
.text$mn:00003B04 arg_4           = dword ptr  0Ch
.text$mn:00003B04 arg_8           = dword ptr  10h
.text$mn:00003B04
.text$mn:00003B04                 push    ebp
.text$mn:00003B05                 mov     ebp, esp
.text$mn:00003B07                 mov     eax, [ebp+arg_0]
.text$mn:00003B0A                 cmp     eax, [ebp+arg_4]
.text$mn:00003B0D                 jz      short loc_3B3B
.text$mn:00003B0F                 push    2E9h            ; unsigned int
.text$mn:00003B14                 push    offset ??_C@_1JA@EADLBAJ@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00003B19                 mov     ecx, [ebp+arg_0]
.text$mn:00003B1C                 push    ecx             ; int
.text$mn:00003B1D                 call    ??$_Debug_pointer@H@std@@YAXPAHPB_WI@Z ; std::_Debug_pointer<int>(int *,wchar_t const *,uint)
.text$mn:00003B22                 add     esp, 0Ch
.text$mn:00003B25                 push    2EAh            ; unsigned int
.text$mn:00003B2A                 push    offset ??_C@_1JA@EADLBAJ@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00003B2F                 mov     edx, [ebp+arg_4]
.text$mn:00003B32                 push    edx             ; int
.text$mn:00003B33                 call    ??$_Debug_pointer@H@std@@YAXPAHPB_WI@Z ; std::_Debug_pointer<int>(int *,wchar_t const *,uint)
.text$mn:00003B38                 add     esp, 0Ch
.text$mn:00003B3B
.text$mn:00003B3B loc_3B3B:                               ; CODE XREF: std::_Distance2<int *,int>(int *,int *,int &,std::random_access_iterator_tag)+9j
.text$mn:00003B3B                 mov     eax, [ebp+arg_4]
.text$mn:00003B3E                 sub     eax, [ebp+arg_0]
.text$mn:00003B41                 sar     eax, 2
.text$mn:00003B44                 mov     ecx, [ebp+arg_8]
.text$mn:00003B47                 add     eax, [ecx]
.text$mn:00003B49                 mov     edx, [ebp+arg_8]
.text$mn:00003B4C                 mov     [edx], eax
.text$mn:00003B4E                 pop     ebp
.text$mn:00003B4F                 retn
.text$mn:00003B4F ??$_Distance2@PAHH@std@@YAXPAH0AAHUrandom_access_iterator_tag@0@@Z endp
.text$mn:00003B4F
.text$mn:00003B4F _text$mn        ends
.text$mn:00003B4F
.text$mn:00003B50 ; ===========================================================================
.text$mn:00003B50
.text$mn:00003B50 ; Segment type: Pure code
.text$mn:00003B50 ; Segment permissions: Read/Execute
.text$mn:00003B50 _text$mn        segment para public 'CODE' use32
.text$mn:00003B50                 assume cs:_text$mn
.text$mn:00003B50                 ;org 3B50h
.text$mn:00003B50 ; COMDAT (pick any)
.text$mn:00003B50                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003B50
.text$mn:00003B50 ; =============== S U B R O U T I N E =======================================
.text$mn:00003B50
.text$mn:00003B50 ; Attributes: bp-based frame
.text$mn:00003B50
.text$mn:00003B50 ; void __cdecl std::_Distance2<class std::_String_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>>, int>(class std::_String_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>>, class std::_String_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>>, int &, struct std::random_access_iterator_tag)
.text$mn:00003B50                 public ??$_Distance2@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@H@std@@YAXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0AAHUrandom_access_iterator_tag@0@@Z
.text$mn:00003B50 ??$_Distance2@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@H@std@@YAXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0AAHUrandom_access_iterator_tag@0@@Z proc near
.text$mn:00003B50                                         ; CODE XREF: std::distance<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)+8Dp
.text$mn:00003B50
.text$mn:00003B50 var_C           = dword ptr -0Ch
.text$mn:00003B50 var_4           = dword ptr -4
.text$mn:00003B50 arg_0           = byte ptr  8
.text$mn:00003B50 arg_C           = byte ptr  14h
.text$mn:00003B50 arg_18          = dword ptr  20h
.text$mn:00003B50
.text$mn:00003B50                 push    ebp
.text$mn:00003B51                 mov     ebp, esp
.text$mn:00003B53                 push    0FFFFFFFFh
.text$mn:00003B55                 push    offset __ehhandler$??$_Distance2@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@H@std@@YAXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0AAHUrandom_access_iterator_tag@0@@Z
.text$mn:00003B5A                 mov     eax, large fs:0
.text$mn:00003B60                 push    eax
.text$mn:00003B61                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003B66                 xor     eax, ebp
.text$mn:00003B68                 push    eax
.text$mn:00003B69                 lea     eax, [ebp+var_C]
.text$mn:00003B6C                 mov     large fs:0, eax
.text$mn:00003B72                 mov     [ebp+var_4], 1
.text$mn:00003B79                 lea     eax, [ebp+arg_C]
.text$mn:00003B7C                 push    eax             ; std::_Iterator_base12 *
.text$mn:00003B7D                 lea     ecx, [ebp+arg_0]
.text$mn:00003B80                 call    ??9?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE_NABV01@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator!=(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:00003B85                 movzx   ecx, al
.text$mn:00003B88                 test    ecx, ecx
.text$mn:00003B8A                 jz      short loc_3BB8
.text$mn:00003B8C                 push    2E9h
.text$mn:00003B91                 push    offset ??_C@_1JA@EADLBAJ@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00003B96                 lea     edx, [ebp+arg_0]
.text$mn:00003B99                 push    edx
.text$mn:00003B9A                 call    ??$_Debug_pointer@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YAXAAV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@PB_WI@Z ; std::_Debug_pointer<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>> &,wchar_t const *,uint)
.text$mn:00003B9F                 add     esp, 0Ch
.text$mn:00003BA2                 push    2EAh
.text$mn:00003BA7                 push    offset ??_C@_1JA@EADLBAJ@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00003BAC                 lea     eax, [ebp+arg_C]
.text$mn:00003BAF                 push    eax
.text$mn:00003BB0                 call    ??$_Debug_pointer@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YAXAAV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@PB_WI@Z ; std::_Debug_pointer<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>> &,wchar_t const *,uint)
.text$mn:00003BB5                 add     esp, 0Ch
.text$mn:00003BB8
.text$mn:00003BB8 loc_3BB8:                               ; CODE XREF: std::_Distance2<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,int>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,int &,std::random_access_iterator_tag)+3Aj
.text$mn:00003BB8                 lea     ecx, [ebp+arg_0]
.text$mn:00003BBB                 push    ecx             ; std::_Iterator_base12 *
.text$mn:00003BBC                 lea     ecx, [ebp+arg_C]
.text$mn:00003BBF                 call    ??G?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEHABV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@@Z ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator-(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:00003BC4                 mov     edx, [ebp+arg_18]
.text$mn:00003BC7                 add     eax, [edx]
.text$mn:00003BC9                 mov     ecx, [ebp+arg_18]
.text$mn:00003BCC                 mov     [ecx], eax
.text$mn:00003BCE                 mov     byte ptr [ebp+var_4], 0
.text$mn:00003BD2                 lea     ecx, [ebp+arg_0]
.text$mn:00003BD5                 call    ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$mn:00003BDA                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003BE1                 lea     ecx, [ebp+arg_C]
.text$mn:00003BE4                 call    ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$mn:00003BE9                 mov     ecx, [ebp+var_C]
.text$mn:00003BEC                 mov     large fs:0, ecx
.text$mn:00003BF3                 pop     ecx
.text$mn:00003BF4                 mov     esp, ebp
.text$mn:00003BF6                 pop     ebp
.text$mn:00003BF7                 retn
.text$mn:00003BF7 ??$_Distance2@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@H@std@@YAXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0AAHUrandom_access_iterator_tag@0@@Z endp
.text$mn:00003BF7
.text$mn:00003BF7 _text$mn        ends
.text$mn:00003BF7
.text$x:00003BF8 ; ===========================================================================
.text$x:00003BF8
.text$x:00003BF8 ; Segment type: Pure code
.text$x:00003BF8 ; Segment permissions: Read/Execute
.text$x:00003BF8 _text$x         segment para public 'CODE' use32
.text$x:00003BF8                 assume cs:_text$x
.text$x:00003BF8                 ;org 3BF8h
.text$x:00003BF8 ; COMDAT (pick associative to section at 3B50)
.text$x:00003BF8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00003BF8
.text$x:00003BF8 ; =============== S U B R O U T I N E =======================================
.text$x:00003BF8
.text$x:00003BF8
.text$x:00003BF8 __unwindfunclet$??$_Distance2@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@H@std@@YAXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0AAHUrandom_access_iterator_tag@0@@Z$0 proc near
.text$x:00003BF8                                         ; DATA XREF: .xdata$x:0000DAF4o
.text$x:00003BF8                 lea     ecx, [ebp+14h]
.text$x:00003BFB                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00003BFB __unwindfunclet$??$_Distance2@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@H@std@@YAXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0AAHUrandom_access_iterator_tag@0@@Z$0 endp
.text$x:00003BFB
.text$x:00003C00
.text$x:00003C00 ; =============== S U B R O U T I N E =======================================
.text$x:00003C00
.text$x:00003C00
.text$x:00003C00 __unwindfunclet$??$_Distance2@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@H@std@@YAXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0AAHUrandom_access_iterator_tag@0@@Z$1 proc near
.text$x:00003C00                                         ; DATA XREF: .xdata$x:0000DAFCo
.text$x:00003C00                 lea     ecx, [ebp+8]
.text$x:00003C03                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00003C03 __unwindfunclet$??$_Distance2@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@H@std@@YAXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0AAHUrandom_access_iterator_tag@0@@Z$1 endp
.text$x:00003C03
.text$x:00003C08
.text$x:00003C08 ; =============== S U B R O U T I N E =======================================
.text$x:00003C08
.text$x:00003C08
.text$x:00003C08 __ehhandler$??$_Distance2@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@H@std@@YAXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0AAHUrandom_access_iterator_tag@0@@Z proc near
.text$x:00003C08                                         ; DATA XREF: std::_Distance2<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,int>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,int &,std::random_access_iterator_tag)+5o
.text$x:00003C08
.text$x:00003C08 arg_4           = dword ptr  8
.text$x:00003C08
.text$x:00003C08                 mov     edx, [esp+arg_4]
.text$x:00003C0C                 lea     eax, [edx+0Ch]
.text$x:00003C0F                 mov     ecx, [edx-4]
.text$x:00003C12                 xor     ecx, eax
.text$x:00003C14                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003C19                 mov     eax, offset __ehfuncinfo$??$_Distance2@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@H@std@@YAXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0AAHUrandom_access_iterator_tag@0@@Z
.text$x:00003C1E                 jmp     ___CxxFrameHandler3
.text$x:00003C1E __ehhandler$??$_Distance2@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@H@std@@YAXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0AAHUrandom_access_iterator_tag@0@@Z endp
.text$x:00003C1E
.text$x:00003C1E ; ---------------------------------------------------------------------------
.text$x:00003C23                 align 4
.text$x:00003C23 _text$x         ends
.text$x:00003C23
.text$mn:00003C24 ; ===========================================================================
.text$mn:00003C24
.text$mn:00003C24 ; Segment type: Pure code
.text$mn:00003C24 ; Segment permissions: Read/Execute
.text$mn:00003C24 _text$mn        segment para public 'CODE' use32
.text$mn:00003C24                 assume cs:_text$mn
.text$mn:00003C24                 ;org 3C24h
.text$mn:00003C24 ; COMDAT (pick any)
.text$mn:00003C24                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003C24
.text$mn:00003C24 ; =============== S U B R O U T I N E =======================================
.text$mn:00003C24
.text$mn:00003C24 ; Attributes: bp-based frame
.text$mn:00003C24
.text$mn:00003C24 ; void __cdecl std::_Distance<int *, int>(int *, int *, int &)
.text$mn:00003C24                 public ??$_Distance@PAHH@std@@YAXPAH0AAH@Z
.text$mn:00003C24 ??$_Distance@PAHH@std@@YAXPAH0AAH@Z proc near
.text$mn:00003C24                                         ; CODE XREF: std::_Buffered_merge<int *,int,int,BufferEquivalent>(int *,int *,int *,int,int,std::_Temp_iterator<int> &,BufferEquivalent)+253p
.text$mn:00003C24                                         ; std::_Buffered_merge<int *,int,int,BufferEquivalent>(int *,int *,int *,int,int,std::_Temp_iterator<int> &,BufferEquivalent)+2C1p ...
.text$mn:00003C24
.text$mn:00003C24 var_1           = byte ptr -1
.text$mn:00003C24 arg_0           = dword ptr  8
.text$mn:00003C24 arg_4           = dword ptr  0Ch
.text$mn:00003C24 arg_8           = dword ptr  10h
.text$mn:00003C24
.text$mn:00003C24                 push    ebp
.text$mn:00003C25                 mov     ebp, esp
.text$mn:00003C27                 push    ecx
.text$mn:00003C28                 lea     eax, [ebp+arg_0]
.text$mn:00003C2B                 push    eax
.text$mn:00003C2C                 lea     ecx, [ebp+var_1]
.text$mn:00003C2F                 push    ecx
.text$mn:00003C30                 call    ??$_Iter_cat@PAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH@Z ; std::_Iter_cat<int *>(int * const &)
.text$mn:00003C35                 add     esp, 8
.text$mn:00003C38                 mov     dl, [eax]
.text$mn:00003C3A                 movzx   eax, dl
.text$mn:00003C3D                 push    eax
.text$mn:00003C3E                 mov     ecx, [ebp+arg_8]
.text$mn:00003C41                 push    ecx
.text$mn:00003C42                 mov     edx, [ebp+arg_4]
.text$mn:00003C45                 push    edx
.text$mn:00003C46                 mov     eax, [ebp+arg_0]
.text$mn:00003C49                 push    eax
.text$mn:00003C4A                 call    ??$_Distance2@PAHH@std@@YAXPAH0AAHUrandom_access_iterator_tag@0@@Z ; std::_Distance2<int *,int>(int *,int *,int &,std::random_access_iterator_tag)
.text$mn:00003C4F                 add     esp, 10h
.text$mn:00003C52                 mov     esp, ebp
.text$mn:00003C54                 pop     ebp
.text$mn:00003C55                 retn
.text$mn:00003C55 ??$_Distance@PAHH@std@@YAXPAH0AAH@Z endp
.text$mn:00003C55
.text$mn:00003C55 ; ---------------------------------------------------------------------------
.text$mn:00003C56                 align 4
.text$mn:00003C56 _text$mn        ends
.text$mn:00003C56
.text$mn:00003C58 ; ===========================================================================
.text$mn:00003C58
.text$mn:00003C58 ; Segment type: Pure code
.text$mn:00003C58 ; Segment permissions: Read/Execute
.text$mn:00003C58 _text$mn        segment para public 'CODE' use32
.text$mn:00003C58                 assume cs:_text$mn
.text$mn:00003C58                 ;org 3C58h
.text$mn:00003C58 ; COMDAT (pick any)
.text$mn:00003C58                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003C58
.text$mn:00003C58 ; =============== S U B R O U T I N E =======================================
.text$mn:00003C58
.text$mn:00003C58 ; Attributes: bp-based frame
.text$mn:00003C58
.text$mn:00003C58 ; int * __cdecl std::_Fill_n<int *, unsigned int, int>(int *, unsigned int, int const &)
.text$mn:00003C58                 public ??$_Fill_n@PAHIH@std@@YAPAHPAHIABH@Z
.text$mn:00003C58 ??$_Fill_n@PAHIH@std@@YAPAHPAHIABH@Z proc near
.text$mn:00003C58                                         ; CODE XREF: std::_Uninit_def_fill_n<int,uint,int>(int *,uint,std::_Wrap_alloc<std::allocator<int>> &,int *,std::_Scalar_ptr_iterator_tag)+17p
.text$mn:00003C58                                         ; std::_Uninit_fill_n<int,uint,int,int>(int *,uint,int const *,std::_Wrap_alloc<std::allocator<int>> &,int *,std::_Scalar_ptr_iterator_tag)+Fp
.text$mn:00003C58
.text$mn:00003C58 arg_0           = dword ptr  8
.text$mn:00003C58 arg_4           = dword ptr  0Ch
.text$mn:00003C58 arg_8           = dword ptr  10h
.text$mn:00003C58
.text$mn:00003C58                 push    ebp
.text$mn:00003C59                 mov     ebp, esp
.text$mn:00003C5B                 jmp     short loc_3C6F
.text$mn:00003C5D ; ---------------------------------------------------------------------------
.text$mn:00003C5D
.text$mn:00003C5D loc_3C5D:                               ; CODE XREF: std::_Fill_n<int *,uint,int>(int *,uint,int const &)+27j
.text$mn:00003C5D                 mov     eax, [ebp+arg_4]
.text$mn:00003C60                 sub     eax, 1
.text$mn:00003C63                 mov     [ebp+arg_4], eax
.text$mn:00003C66                 mov     ecx, [ebp+arg_0]
.text$mn:00003C69                 add     ecx, 4
.text$mn:00003C6C                 mov     [ebp+arg_0], ecx
.text$mn:00003C6F
.text$mn:00003C6F loc_3C6F:                               ; CODE XREF: std::_Fill_n<int *,uint,int>(int *,uint,int const &)+3j
.text$mn:00003C6F                 cmp     [ebp+arg_4], 0
.text$mn:00003C73                 jbe     short loc_3C81
.text$mn:00003C75                 mov     edx, [ebp+arg_0]
.text$mn:00003C78                 mov     eax, [ebp+arg_8]
.text$mn:00003C7B                 mov     ecx, [eax]
.text$mn:00003C7D                 mov     [edx], ecx
.text$mn:00003C7F                 jmp     short loc_3C5D
.text$mn:00003C81 ; ---------------------------------------------------------------------------
.text$mn:00003C81
.text$mn:00003C81 loc_3C81:                               ; CODE XREF: std::_Fill_n<int *,uint,int>(int *,uint,int const &)+1Bj
.text$mn:00003C81                 mov     eax, [ebp+arg_0]
.text$mn:00003C84                 pop     ebp
.text$mn:00003C85                 retn
.text$mn:00003C85 ??$_Fill_n@PAHIH@std@@YAPAHPAHIABH@Z endp
.text$mn:00003C85
.text$mn:00003C85 ; ---------------------------------------------------------------------------
.text$mn:00003C86                 align 4
.text$mn:00003C86 _text$mn        ends
.text$mn:00003C86
.text$mn:00003C88 ; ===========================================================================
.text$mn:00003C88
.text$mn:00003C88 ; Segment type: Pure code
.text$mn:00003C88 ; Segment permissions: Read/Execute
.text$mn:00003C88 _text$mn        segment para public 'CODE' use32
.text$mn:00003C88                 assume cs:_text$mn
.text$mn:00003C88                 ;org 3C88h
.text$mn:00003C88 ; COMDAT (pick any)
.text$mn:00003C88                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003C88
.text$mn:00003C88 ; =============== S U B R O U T I N E =======================================
.text$mn:00003C88
.text$mn:00003C88 ; Attributes: bp-based frame
.text$mn:00003C88
.text$mn:00003C88 ; int * __cdecl std::_Find_if<int *, class std::binder2nd<struct std::equal_to<int>>>(int *, int *, class std::binder2nd<struct std::equal_to<int>>)
.text$mn:00003C88                 public ??$_Find_if@PAHV?$binder2nd@U?$equal_to@H@std@@@std@@@std@@YAPAHPAH0V?$binder2nd@U?$equal_to@H@std@@@0@@Z
.text$mn:00003C88 ??$_Find_if@PAHV?$binder2nd@U?$equal_to@H@std@@@std@@@std@@YAPAHPAH0V?$binder2nd@U?$equal_to@H@std@@@0@@Z proc near
.text$mn:00003C88                                         ; CODE XREF: std::find_if<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::binder2nd<std::equal_to<int>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::binder2nd<std::equal_to<int>>)+FFp
.text$mn:00003C88
.text$mn:00003C88 arg_0           = dword ptr  8
.text$mn:00003C88 arg_4           = dword ptr  0Ch
.text$mn:00003C88 arg_8           = byte ptr  10h
.text$mn:00003C88
.text$mn:00003C88                 push    ebp
.text$mn:00003C89                 mov     ebp, esp
.text$mn:00003C8B                 jmp     short loc_3C96
.text$mn:00003C8D ; ---------------------------------------------------------------------------
.text$mn:00003C8D
.text$mn:00003C8D loc_3C8D:                               ; CODE XREF: std::_Find_if<int *,std::binder2nd<std::equal_to<int>>>(int *,int *,std::binder2nd<std::equal_to<int>>):loc_3CB3j
.text$mn:00003C8D                 mov     eax, [ebp+arg_0]
.text$mn:00003C90                 add     eax, 4
.text$mn:00003C93                 mov     [ebp+arg_0], eax
.text$mn:00003C96
.text$mn:00003C96 loc_3C96:                               ; CODE XREF: std::_Find_if<int *,std::binder2nd<std::equal_to<int>>>(int *,int *,std::binder2nd<std::equal_to<int>>)+3j
.text$mn:00003C96                 mov     ecx, [ebp+arg_0]
.text$mn:00003C99                 cmp     ecx, [ebp+arg_4]
.text$mn:00003C9C                 jz      short loc_3CB5
.text$mn:00003C9E                 mov     edx, [ebp+arg_0]
.text$mn:00003CA1                 push    edx
.text$mn:00003CA2                 lea     ecx, [ebp+arg_8]
.text$mn:00003CA5                 call    ??R?$binder2nd@U?$equal_to@H@std@@@std@@QBE_NAAH@Z ; std::binder2nd<std::equal_to<int>>::operator()(int &)
.text$mn:00003CAA                 movzx   eax, al
.text$mn:00003CAD                 test    eax, eax
.text$mn:00003CAF                 jz      short loc_3CB3
.text$mn:00003CB1                 jmp     short loc_3CB5
.text$mn:00003CB3 ; ---------------------------------------------------------------------------
.text$mn:00003CB3
.text$mn:00003CB3 loc_3CB3:                               ; CODE XREF: std::_Find_if<int *,std::binder2nd<std::equal_to<int>>>(int *,int *,std::binder2nd<std::equal_to<int>>)+27j
.text$mn:00003CB3                 jmp     short loc_3C8D
.text$mn:00003CB5 ; ---------------------------------------------------------------------------
.text$mn:00003CB5
.text$mn:00003CB5 loc_3CB5:                               ; CODE XREF: std::_Find_if<int *,std::binder2nd<std::equal_to<int>>>(int *,int *,std::binder2nd<std::equal_to<int>>)+14j
.text$mn:00003CB5                                         ; std::_Find_if<int *,std::binder2nd<std::equal_to<int>>>(int *,int *,std::binder2nd<std::equal_to<int>>)+29j
.text$mn:00003CB5                 mov     eax, [ebp+arg_0]
.text$mn:00003CB8                 pop     ebp
.text$mn:00003CB9                 retn
.text$mn:00003CB9 ??$_Find_if@PAHV?$binder2nd@U?$equal_to@H@std@@@std@@@std@@YAPAHPAH0V?$binder2nd@U?$equal_to@H@std@@@0@@Z endp
.text$mn:00003CB9
.text$mn:00003CB9 ; ---------------------------------------------------------------------------
.text$mn:00003CBA                 align 4
.text$mn:00003CBA _text$mn        ends
.text$mn:00003CBA
.text$mn:00003CBC ; ===========================================================================
.text$mn:00003CBC
.text$mn:00003CBC ; Segment type: Pure code
.text$mn:00003CBC ; Segment permissions: Read/Execute
.text$mn:00003CBC _text$mn        segment para public 'CODE' use32
.text$mn:00003CBC                 assume cs:_text$mn
.text$mn:00003CBC                 ;org 3CBCh
.text$mn:00003CBC ; COMDAT (pick any)
.text$mn:00003CBC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003CBC
.text$mn:00003CBC ; =============== S U B R O U T I N E =======================================
.text$mn:00003CBC
.text$mn:00003CBC ; Attributes: bp-based frame
.text$mn:00003CBC
.text$mn:00003CBC ; int __cdecl std::_Insertion_sort1<int *,BufferEquivalent,int>(void *Src, int, int, int, int, int)
.text$mn:00003CBC                 public ??$_Insertion_sort1@PAHUBufferEquivalent@@H@std@@YAXPAH0UBufferEquivalent@@0@Z
.text$mn:00003CBC ??$_Insertion_sort1@PAHUBufferEquivalent@@H@std@@YAXPAH0UBufferEquivalent@@0@Z proc near
.text$mn:00003CBC                                         ; CODE XREF: std::_Insertion_sort<int *,BufferEquivalent>(int *,int *,BufferEquivalent)+34p
.text$mn:00003CBC
.text$mn:00003CBC var_10          = dword ptr -10h
.text$mn:00003CBC var_C           = dword ptr -0Ch
.text$mn:00003CBC var_8           = dword ptr -8
.text$mn:00003CBC var_4           = dword ptr -4
.text$mn:00003CBC Src             = dword ptr  8
.text$mn:00003CBC arg_4           = dword ptr  0Ch
.text$mn:00003CBC arg_8           = dword ptr  10h
.text$mn:00003CBC arg_C           = dword ptr  14h
.text$mn:00003CBC arg_10          = dword ptr  18h
.text$mn:00003CBC arg_14          = dword ptr  1Ch
.text$mn:00003CBC
.text$mn:00003CBC                 push    ebp
.text$mn:00003CBD                 mov     ebp, esp
.text$mn:00003CBF                 sub     esp, 10h
.text$mn:00003CC2                 mov     eax, [ebp+Src]
.text$mn:00003CC5                 cmp     eax, [ebp+arg_4]
.text$mn:00003CC8                 jz      loc_3DF0
.text$mn:00003CCE                 mov     ecx, [ebp+Src]
.text$mn:00003CD1                 mov     [ebp+var_8], ecx
.text$mn:00003CD4
.text$mn:00003CD4 loc_3CD4:                               ; CODE XREF: std::_Insertion_sort1<int *,BufferEquivalent,int>(int *,int *,BufferEquivalent,int *):loc_3DEBj
.text$mn:00003CD4                 mov     edx, [ebp+var_8]
.text$mn:00003CD7                 add     edx, 4
.text$mn:00003CDA                 mov     [ebp+var_8], edx
.text$mn:00003CDD                 mov     eax, [ebp+var_8]
.text$mn:00003CE0                 cmp     eax, [ebp+arg_4]
.text$mn:00003CE3                 jz      loc_3DF0
.text$mn:00003CE9                 mov     ecx, [ebp+var_8]
.text$mn:00003CEC                 mov     [ebp+var_4], ecx
.text$mn:00003CEF                 mov     edx, [ebp+var_8]
.text$mn:00003CF2                 push    edx
.text$mn:00003CF3                 call    ??$_Move@AAH@std@@YA$$QAHAAH@Z ; std::_Move<int &>(int &)
.text$mn:00003CF8                 add     esp, 4
.text$mn:00003CFB                 mov     eax, [eax]
.text$mn:00003CFD                 mov     [ebp+var_10], eax
.text$mn:00003D00                 push    0BBEh           ; unsigned int
.text$mn:00003D05                 push    offset ??_C@_1JC@HALMDPKM@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00003D0A                 mov     ecx, [ebp+Src]
.text$mn:00003D0D                 push    ecx             ; int
.text$mn:00003D0E                 lea     edx, [ebp+var_10]
.text$mn:00003D11                 push    edx             ; int
.text$mn:00003D12                 sub     esp, 10h
.text$mn:00003D15                 mov     eax, esp
.text$mn:00003D17                 mov     ecx, [ebp+arg_8]
.text$mn:00003D1A                 mov     [eax], ecx
.text$mn:00003D1C                 mov     edx, [ebp+arg_C]
.text$mn:00003D1F                 mov     [eax+4], edx
.text$mn:00003D22                 mov     ecx, [ebp+arg_10]
.text$mn:00003D25                 mov     [eax+8], ecx
.text$mn:00003D28                 mov     edx, [ebp+arg_14]
.text$mn:00003D2B                 mov     [eax+0Ch], edx
.text$mn:00003D2E                 call    ??$_Debug_lt_pred@UBufferEquivalent@@AAHAAH@std@@YA_NUBufferEquivalent@@AAH1PB_WI@Z ; std::_Debug_lt_pred<BufferEquivalent,int &,int &>(BufferEquivalent,int &,int &,wchar_t const *,uint)
.text$mn:00003D33                 add     esp, 20h
.text$mn:00003D36                 movzx   eax, al
.text$mn:00003D39                 test    eax, eax
.text$mn:00003D3B                 jz      short loc_3D6F
.text$mn:00003D3D                 mov     ecx, [ebp+var_4]
.text$mn:00003D40                 add     ecx, 4
.text$mn:00003D43                 mov     [ebp+var_4], ecx
.text$mn:00003D46                 mov     edx, [ebp+var_4]
.text$mn:00003D49                 push    edx             ; int
.text$mn:00003D4A                 mov     eax, [ebp+var_8]
.text$mn:00003D4D                 push    eax             ; int
.text$mn:00003D4E                 mov     ecx, [ebp+Src]
.text$mn:00003D51                 push    ecx             ; Src
.text$mn:00003D52                 call    ??$_Move_backward@PAHPAH@std@@YAPAHPAH00@Z ; std::_Move_backward<int *,int *>(int *,int *,int *)
.text$mn:00003D57                 add     esp, 0Ch
.text$mn:00003D5A                 lea     edx, [ebp+var_10]
.text$mn:00003D5D                 push    edx
.text$mn:00003D5E                 call    ??$_Move@AAH@std@@YA$$QAHAAH@Z ; std::_Move<int &>(int &)
.text$mn:00003D63                 add     esp, 4
.text$mn:00003D66                 mov     ecx, [ebp+Src]
.text$mn:00003D69                 mov     edx, [eax]
.text$mn:00003D6B                 mov     [ecx], edx
.text$mn:00003D6D                 jmp     short loc_3DEB
.text$mn:00003D6F ; ---------------------------------------------------------------------------
.text$mn:00003D6F
.text$mn:00003D6F loc_3D6F:                               ; CODE XREF: std::_Insertion_sort1<int *,BufferEquivalent,int>(int *,int *,BufferEquivalent,int *)+7Fj
.text$mn:00003D6F                 mov     eax, [ebp+var_4]
.text$mn:00003D72                 mov     [ebp+var_C], eax
.text$mn:00003D75                 jmp     short loc_3D7D
.text$mn:00003D77 ; ---------------------------------------------------------------------------
.text$mn:00003D77
.text$mn:00003D77 loc_3D77:                               ; CODE XREF: std::_Insertion_sort1<int *,BufferEquivalent,int>(int *,int *,BufferEquivalent,int *)+11Aj
.text$mn:00003D77                 mov     ecx, [ebp+var_C]
.text$mn:00003D7A                 mov     [ebp+var_4], ecx
.text$mn:00003D7D
.text$mn:00003D7D loc_3D7D:                               ; CODE XREF: std::_Insertion_sort1<int *,BufferEquivalent,int>(int *,int *,BufferEquivalent,int *)+B9j
.text$mn:00003D7D                 mov     edx, [ebp+var_C]
.text$mn:00003D80                 sub     edx, 4
.text$mn:00003D83                 mov     [ebp+var_C], edx
.text$mn:00003D86                 push    0BC6h           ; unsigned int
.text$mn:00003D8B                 push    offset ??_C@_1JC@HALMDPKM@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00003D90                 mov     eax, [ebp+var_C]
.text$mn:00003D93                 push    eax             ; int
.text$mn:00003D94                 lea     ecx, [ebp+var_10]
.text$mn:00003D97                 push    ecx             ; int
.text$mn:00003D98                 sub     esp, 10h
.text$mn:00003D9B                 mov     edx, esp
.text$mn:00003D9D                 mov     eax, [ebp+arg_8]
.text$mn:00003DA0                 mov     [edx], eax
.text$mn:00003DA2                 mov     ecx, [ebp+arg_C]
.text$mn:00003DA5                 mov     [edx+4], ecx
.text$mn:00003DA8                 mov     eax, [ebp+arg_10]
.text$mn:00003DAB                 mov     [edx+8], eax
.text$mn:00003DAE                 mov     ecx, [ebp+arg_14]
.text$mn:00003DB1                 mov     [edx+0Ch], ecx
.text$mn:00003DB4                 call    ??$_Debug_lt_pred@UBufferEquivalent@@AAHAAH@std@@YA_NUBufferEquivalent@@AAH1PB_WI@Z ; std::_Debug_lt_pred<BufferEquivalent,int &,int &>(BufferEquivalent,int &,int &,wchar_t const *,uint)
.text$mn:00003DB9                 add     esp, 20h
.text$mn:00003DBC                 movzx   edx, al
.text$mn:00003DBF                 test    edx, edx
.text$mn:00003DC1                 jz      short loc_3DD8
.text$mn:00003DC3                 mov     eax, [ebp+var_C]
.text$mn:00003DC6                 push    eax
.text$mn:00003DC7                 call    ??$_Move@AAH@std@@YA$$QAHAAH@Z ; std::_Move<int &>(int &)
.text$mn:00003DCC                 add     esp, 4
.text$mn:00003DCF                 mov     ecx, [ebp+var_4]
.text$mn:00003DD2                 mov     edx, [eax]
.text$mn:00003DD4                 mov     [ecx], edx
.text$mn:00003DD6                 jmp     short loc_3D77
.text$mn:00003DD8 ; ---------------------------------------------------------------------------
.text$mn:00003DD8
.text$mn:00003DD8 loc_3DD8:                               ; CODE XREF: std::_Insertion_sort1<int *,BufferEquivalent,int>(int *,int *,BufferEquivalent,int *)+105j
.text$mn:00003DD8                 lea     eax, [ebp+var_10]
.text$mn:00003DDB                 push    eax
.text$mn:00003DDC                 call    ??$_Move@AAH@std@@YA$$QAHAAH@Z ; std::_Move<int &>(int &)
.text$mn:00003DE1                 add     esp, 4
.text$mn:00003DE4                 mov     ecx, [ebp+var_4]
.text$mn:00003DE7                 mov     edx, [eax]
.text$mn:00003DE9                 mov     [ecx], edx
.text$mn:00003DEB
.text$mn:00003DEB loc_3DEB:                               ; CODE XREF: std::_Insertion_sort1<int *,BufferEquivalent,int>(int *,int *,BufferEquivalent,int *)+B1j
.text$mn:00003DEB                 jmp     loc_3CD4
.text$mn:00003DF0 ; ---------------------------------------------------------------------------
.text$mn:00003DF0
.text$mn:00003DF0 loc_3DF0:                               ; CODE XREF: std::_Insertion_sort1<int *,BufferEquivalent,int>(int *,int *,BufferEquivalent,int *)+Cj
.text$mn:00003DF0                                         ; std::_Insertion_sort1<int *,BufferEquivalent,int>(int *,int *,BufferEquivalent,int *)+27j
.text$mn:00003DF0                 mov     esp, ebp
.text$mn:00003DF2                 pop     ebp
.text$mn:00003DF3                 retn
.text$mn:00003DF3 ??$_Insertion_sort1@PAHUBufferEquivalent@@H@std@@YAXPAH0UBufferEquivalent@@0@Z endp
.text$mn:00003DF3
.text$mn:00003DF3 _text$mn        ends
.text$mn:00003DF3
.text$mn:00003DF4 ; ===========================================================================
.text$mn:00003DF4
.text$mn:00003DF4 ; Segment type: Pure code
.text$mn:00003DF4 ; Segment permissions: Read/Execute
.text$mn:00003DF4 _text$mn        segment para public 'CODE' use32
.text$mn:00003DF4                 assume cs:_text$mn
.text$mn:00003DF4                 ;org 3DF4h
.text$mn:00003DF4 ; COMDAT (pick any)
.text$mn:00003DF4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003DF4
.text$mn:00003DF4 ; =============== S U B R O U T I N E =======================================
.text$mn:00003DF4
.text$mn:00003DF4 ; Attributes: bp-based frame
.text$mn:00003DF4
.text$mn:00003DF4 ; int __cdecl std::_Insertion_sort<int *,BufferEquivalent>(void *Src, int, int, int, int, int)
.text$mn:00003DF4                 public ??$_Insertion_sort@PAHUBufferEquivalent@@@std@@YAXPAH0UBufferEquivalent@@@Z
.text$mn:00003DF4 ??$_Insertion_sort@PAHUBufferEquivalent@@@std@@YAXPAH0UBufferEquivalent@@@Z proc near
.text$mn:00003DF4                                         ; CODE XREF: std::_Buffered_merge_sort<int *,int,int,BufferEquivalent>(int *,int *,int,std::_Temp_iterator<int> &,BufferEquivalent)+77p
.text$mn:00003DF4                                         ; std::_Buffered_merge_sort<int *,int,int,BufferEquivalent>(int *,int *,int,std::_Temp_iterator<int> &,BufferEquivalent)+ABp ...
.text$mn:00003DF4
.text$mn:00003DF4 Src             = dword ptr  8
.text$mn:00003DF4 arg_4           = dword ptr  0Ch
.text$mn:00003DF4 arg_8           = dword ptr  10h
.text$mn:00003DF4 arg_C           = dword ptr  14h
.text$mn:00003DF4 arg_10          = dword ptr  18h
.text$mn:00003DF4 arg_14          = dword ptr  1Ch
.text$mn:00003DF4
.text$mn:00003DF4                 push    ebp
.text$mn:00003DF5                 mov     ebp, esp
.text$mn:00003DF7                 mov     eax, [ebp+Src]
.text$mn:00003DFA                 push    eax
.text$mn:00003DFB                 call    ??$_Val_type@PAH@std@@YAPAHPAH@Z ; std::_Val_type<int *>(int *)
.text$mn:00003E00                 add     esp, 4
.text$mn:00003E03                 push    eax
.text$mn:00003E04                 sub     esp, 10h
.text$mn:00003E07                 mov     ecx, esp
.text$mn:00003E09                 mov     edx, [ebp+arg_8]
.text$mn:00003E0C                 mov     [ecx], edx
.text$mn:00003E0E                 mov     eax, [ebp+arg_C]
.text$mn:00003E11                 mov     [ecx+4], eax
.text$mn:00003E14                 mov     edx, [ebp+arg_10]
.text$mn:00003E17                 mov     [ecx+8], edx
.text$mn:00003E1A                 mov     eax, [ebp+arg_14]
.text$mn:00003E1D                 mov     [ecx+0Ch], eax
.text$mn:00003E20                 mov     ecx, [ebp+arg_4]
.text$mn:00003E23                 push    ecx             ; int
.text$mn:00003E24                 mov     edx, [ebp+Src]
.text$mn:00003E27                 push    edx             ; Src
.text$mn:00003E28                 call    ??$_Insertion_sort1@PAHUBufferEquivalent@@H@std@@YAXPAH0UBufferEquivalent@@0@Z ; std::_Insertion_sort1<int *,BufferEquivalent,int>(int *,int *,BufferEquivalent,int *)
.text$mn:00003E2D                 add     esp, 1Ch
.text$mn:00003E30                 pop     ebp
.text$mn:00003E31                 retn
.text$mn:00003E31 ??$_Insertion_sort@PAHUBufferEquivalent@@@std@@YAXPAH0UBufferEquivalent@@@Z endp
.text$mn:00003E31
.text$mn:00003E31 ; ---------------------------------------------------------------------------
.text$mn:00003E32                 align 4
.text$mn:00003E32 _text$mn        ends
.text$mn:00003E32
.text$mn:00003E34 ; ===========================================================================
.text$mn:00003E34
.text$mn:00003E34 ; Segment type: Pure code
.text$mn:00003E34 ; Segment permissions: Read/Execute
.text$mn:00003E34 _text$mn        segment para public 'CODE' use32
.text$mn:00003E34                 assume cs:_text$mn
.text$mn:00003E34                 ;org 3E34h
.text$mn:00003E34 ; COMDAT (pick any)
.text$mn:00003E34                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003E34
.text$mn:00003E34 ; =============== S U B R O U T I N E =======================================
.text$mn:00003E34
.text$mn:00003E34 ; Attributes: bp-based frame
.text$mn:00003E34
.text$mn:00003E34 ; struct std::random_access_iterator_tag __cdecl std::_Iter_cat<int *>(int * const &)
.text$mn:00003E34                 public ??$_Iter_cat@PAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH@Z
.text$mn:00003E34 ??$_Iter_cat@PAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH@Z proc near
.text$mn:00003E34                                         ; CODE XREF: std::_Debug_range<int *>(int *,int *,wchar_t const *,uint)+Cp
.text$mn:00003E34                                         ; std::_Distance<int *,int>(int *,int *,int &)+Cp ...
.text$mn:00003E34
.text$mn:00003E34 var_1           = byte ptr -1
.text$mn:00003E34 arg_0           = dword ptr  8
.text$mn:00003E34
.text$mn:00003E34                 push    ebp
.text$mn:00003E35                 mov     ebp, esp
.text$mn:00003E37                 push    ecx
.text$mn:00003E38                 mov     eax, [ebp+arg_0]
.text$mn:00003E3B                 mov     cl, [ebp+var_1]
.text$mn:00003E3E                 mov     [eax], cl
.text$mn:00003E40                 mov     eax, [ebp+arg_0]
.text$mn:00003E43                 mov     esp, ebp
.text$mn:00003E45                 pop     ebp
.text$mn:00003E46                 retn
.text$mn:00003E46 ??$_Iter_cat@PAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH@Z endp
.text$mn:00003E46
.text$mn:00003E46 ; ---------------------------------------------------------------------------
.text$mn:00003E47                 align 4
.text$mn:00003E47 _text$mn        ends
.text$mn:00003E47
.text$mn:00003E48 ; ===========================================================================
.text$mn:00003E48
.text$mn:00003E48 ; Segment type: Pure code
.text$mn:00003E48 ; Segment permissions: Read/Execute
.text$mn:00003E48 _text$mn        segment para public 'CODE' use32
.text$mn:00003E48                 assume cs:_text$mn
.text$mn:00003E48                 ;org 3E48h
.text$mn:00003E48 ; COMDAT (pick any)
.text$mn:00003E48                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003E48
.text$mn:00003E48 ; =============== S U B R O U T I N E =======================================
.text$mn:00003E48
.text$mn:00003E48 ; Attributes: bp-based frame
.text$mn:00003E48
.text$mn:00003E48 ; struct std::random_access_iterator_tag __cdecl std::_Iter_cat<wchar_t *>(wchar_t * const &)
.text$mn:00003E48                 public ??$_Iter_cat@PA_W@std@@YA?AUrandom_access_iterator_tag@0@ABQA_W@Z
.text$mn:00003E48 ??$_Iter_cat@PA_W@std@@YA?AUrandom_access_iterator_tag@0@ABQA_W@Z proc near
.text$mn:00003E48                                         ; CODE XREF: std::_Debug_range<wchar_t *>(wchar_t *,wchar_t *,wchar_t const *,uint)+Cp
.text$mn:00003E48
.text$mn:00003E48 var_1           = byte ptr -1
.text$mn:00003E48 arg_0           = dword ptr  8
.text$mn:00003E48
.text$mn:00003E48                 push    ebp
.text$mn:00003E49                 mov     ebp, esp
.text$mn:00003E4B                 push    ecx
.text$mn:00003E4C                 mov     eax, [ebp+arg_0]
.text$mn:00003E4F                 mov     cl, [ebp+var_1]
.text$mn:00003E52                 mov     [eax], cl
.text$mn:00003E54                 mov     eax, [ebp+arg_0]
.text$mn:00003E57                 mov     esp, ebp
.text$mn:00003E59                 pop     ebp
.text$mn:00003E5A                 retn
.text$mn:00003E5A ??$_Iter_cat@PA_W@std@@YA?AUrandom_access_iterator_tag@0@ABQA_W@Z endp
.text$mn:00003E5A
.text$mn:00003E5A ; ---------------------------------------------------------------------------
.text$mn:00003E5B                 align 4
.text$mn:00003E5B _text$mn        ends
.text$mn:00003E5B
.text$mn:00003E5C ; ===========================================================================
.text$mn:00003E5C
.text$mn:00003E5C ; Segment type: Pure code
.text$mn:00003E5C ; Segment permissions: Read/Execute
.text$mn:00003E5C _text$mn        segment para public 'CODE' use32
.text$mn:00003E5C                 assume cs:_text$mn
.text$mn:00003E5C                 ;org 3E5Ch
.text$mn:00003E5C ; COMDAT (pick any)
.text$mn:00003E5C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003E5C
.text$mn:00003E5C ; =============== S U B R O U T I N E =======================================
.text$mn:00003E5C
.text$mn:00003E5C ; Attributes: bp-based frame
.text$mn:00003E5C
.text$mn:00003E5C ; struct std::random_access_iterator_tag __cdecl std::_Iter_cat<class std::_String_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>>>(class std::_String_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>> const &)
.text$mn:00003E5C                 public ??$_Iter_cat@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@@Z
.text$mn:00003E5C ??$_Iter_cat@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@@Z proc near
.text$mn:00003E5C                                         ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::_Construct<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)+37p
.text$mn:00003E5C                                         ; std::distance<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)+3Bp
.text$mn:00003E5C
.text$mn:00003E5C var_1           = byte ptr -1
.text$mn:00003E5C arg_0           = dword ptr  8
.text$mn:00003E5C
.text$mn:00003E5C                 push    ebp
.text$mn:00003E5D                 mov     ebp, esp
.text$mn:00003E5F                 push    ecx
.text$mn:00003E60                 mov     eax, [ebp+arg_0]
.text$mn:00003E63                 mov     cl, [ebp+var_1]
.text$mn:00003E66                 mov     [eax], cl
.text$mn:00003E68                 mov     eax, [ebp+arg_0]
.text$mn:00003E6B                 mov     esp, ebp
.text$mn:00003E6D                 pop     ebp
.text$mn:00003E6E                 retn
.text$mn:00003E6E ??$_Iter_cat@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@@Z endp
.text$mn:00003E6E
.text$mn:00003E6E ; ---------------------------------------------------------------------------
.text$mn:00003E6F                 align 10h
.text$mn:00003E6F _text$mn        ends
.text$mn:00003E6F
.text$mn:00003E70 ; ===========================================================================
.text$mn:00003E70
.text$mn:00003E70 ; Segment type: Pure code
.text$mn:00003E70 ; Segment permissions: Read/Execute
.text$mn:00003E70 _text$mn        segment para public 'CODE' use32
.text$mn:00003E70                 assume cs:_text$mn
.text$mn:00003E70                 ;org 3E70h
.text$mn:00003E70 ; COMDAT (pick any)
.text$mn:00003E70                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003E70
.text$mn:00003E70 ; =============== S U B R O U T I N E =======================================
.text$mn:00003E70
.text$mn:00003E70 ; Attributes: bp-based frame
.text$mn:00003E70
.text$mn:00003E70 ; struct std::random_access_iterator_tag __cdecl std::_Iter_cat<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<int>>>>(class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<int>>> const &)
.text$mn:00003E70                 public ??$_Iter_cat@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@@Z
.text$mn:00003E70 ??$_Iter_cat@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@@Z proc near
.text$mn:00003E70                                         ; CODE XREF: std::_Debug_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,wchar_t const *,uint)+34p
.text$mn:00003E70
.text$mn:00003E70 var_1           = byte ptr -1
.text$mn:00003E70 arg_0           = dword ptr  8
.text$mn:00003E70
.text$mn:00003E70                 push    ebp
.text$mn:00003E71                 mov     ebp, esp
.text$mn:00003E73                 push    ecx
.text$mn:00003E74                 mov     eax, [ebp+arg_0]
.text$mn:00003E77                 mov     cl, [ebp+var_1]
.text$mn:00003E7A                 mov     [eax], cl
.text$mn:00003E7C                 mov     eax, [ebp+arg_0]
.text$mn:00003E7F                 mov     esp, ebp
.text$mn:00003E81                 pop     ebp
.text$mn:00003E82                 retn
.text$mn:00003E82 ??$_Iter_cat@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@@Z endp
.text$mn:00003E82
.text$mn:00003E82 ; ---------------------------------------------------------------------------
.text$mn:00003E83                 align 4
.text$mn:00003E83 _text$mn        ends
.text$mn:00003E83
.text$mn:00003E84 ; ===========================================================================
.text$mn:00003E84
.text$mn:00003E84 ; Segment type: Pure code
.text$mn:00003E84 ; Segment permissions: Read/Execute
.text$mn:00003E84 _text$mn        segment para public 'CODE' use32
.text$mn:00003E84                 assume cs:_text$mn
.text$mn:00003E84                 ;org 3E84h
.text$mn:00003E84 ; COMDAT (pick any)
.text$mn:00003E84                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003E84
.text$mn:00003E84 ; =============== S U B R O U T I N E =======================================
.text$mn:00003E84
.text$mn:00003E84 ; Attributes: bp-based frame
.text$mn:00003E84
.text$mn:00003E84 ; int * __cdecl std::_Lower_bound<int *, int, int, struct BufferEquivalent>(int *, int *, int const &, struct BufferEquivalent, int *)
.text$mn:00003E84                 public ??$_Lower_bound@PAHHHUBufferEquivalent@@@std@@YAPAHPAH0ABHUBufferEquivalent@@0@Z
.text$mn:00003E84 ??$_Lower_bound@PAHHHUBufferEquivalent@@@std@@YAPAHPAH0ABHUBufferEquivalent@@0@Z proc near
.text$mn:00003E84                                         ; CODE XREF: std::lower_bound<int *,int,BufferEquivalent>(int *,int *,int const &,BufferEquivalent)+4Ap
.text$mn:00003E84
.text$mn:00003E84 var_C           = dword ptr -0Ch
.text$mn:00003E84 var_8           = dword ptr -8
.text$mn:00003E84 var_4           = dword ptr -4
.text$mn:00003E84 arg_0           = dword ptr  8
.text$mn:00003E84 arg_4           = dword ptr  0Ch
.text$mn:00003E84 arg_8           = dword ptr  10h
.text$mn:00003E84 arg_C           = byte ptr  14h
.text$mn:00003E84
.text$mn:00003E84                 push    ebp
.text$mn:00003E85                 mov     ebp, esp
.text$mn:00003E87                 sub     esp, 0Ch
.text$mn:00003E8A                 mov     [ebp+var_4], 0
.text$mn:00003E91                 lea     eax, [ebp+var_4]
.text$mn:00003E94                 push    eax
.text$mn:00003E95                 mov     ecx, [ebp+arg_4]
.text$mn:00003E98                 push    ecx
.text$mn:00003E99                 mov     edx, [ebp+arg_0]
.text$mn:00003E9C                 push    edx
.text$mn:00003E9D                 call    ??$_Distance@PAHH@std@@YAXPAH0AAH@Z ; std::_Distance<int *,int>(int *,int *,int &)
.text$mn:00003EA2                 add     esp, 0Ch
.text$mn:00003EA5
.text$mn:00003EA5 loc_3EA5:                               ; CODE XREF: std::_Lower_bound<int *,int,int,BufferEquivalent>(int *,int *,int const &,BufferEquivalent,int *):loc_3F0Cj
.text$mn:00003EA5                 cmp     [ebp+var_4], 0
.text$mn:00003EA9                 jle     short loc_3F0E
.text$mn:00003EAB                 mov     eax, [ebp+var_4]
.text$mn:00003EAE                 cdq
.text$mn:00003EAF                 sub     eax, edx
.text$mn:00003EB1                 sar     eax, 1
.text$mn:00003EB3                 mov     [ebp+var_C], eax
.text$mn:00003EB6                 mov     eax, [ebp+arg_0]
.text$mn:00003EB9                 mov     [ebp+var_8], eax
.text$mn:00003EBC                 mov     ecx, [ebp+var_C]
.text$mn:00003EBF                 push    ecx
.text$mn:00003EC0                 lea     edx, [ebp+var_8]
.text$mn:00003EC3                 push    edx
.text$mn:00003EC4                 call    ??$advance@PAHH@std@@YAXAAPAHH@Z ; std::advance<int *,int>(int * &,int)
.text$mn:00003EC9                 add     esp, 8
.text$mn:00003ECC                 mov     eax, [ebp+arg_8]
.text$mn:00003ECF                 mov     ecx, [eax]
.text$mn:00003ED1                 push    ecx
.text$mn:00003ED2                 mov     edx, [ebp+var_8]
.text$mn:00003ED5                 mov     eax, [edx]
.text$mn:00003ED7                 push    eax
.text$mn:00003ED8                 lea     ecx, [ebp+arg_C]
.text$mn:00003EDB                 call    ??RBufferEquivalent@@QBE_NHH@Z ; BufferEquivalent::operator()(int,int)
.text$mn:00003EE0                 movzx   ecx, al
.text$mn:00003EE3                 test    ecx, ecx
.text$mn:00003EE5                 jz      short loc_3F06
.text$mn:00003EE7                 mov     edx, [ebp+var_8]
.text$mn:00003EEA                 add     edx, 4
.text$mn:00003EED                 mov     [ebp+var_8], edx
.text$mn:00003EF0                 mov     eax, [ebp+var_8]
.text$mn:00003EF3                 mov     [ebp+arg_0], eax
.text$mn:00003EF6                 mov     ecx, [ebp+var_C]
.text$mn:00003EF9                 add     ecx, 1
.text$mn:00003EFC                 mov     edx, [ebp+var_4]
.text$mn:00003EFF                 sub     edx, ecx
.text$mn:00003F01                 mov     [ebp+var_4], edx
.text$mn:00003F04                 jmp     short loc_3F0C
.text$mn:00003F06 ; ---------------------------------------------------------------------------
.text$mn:00003F06
.text$mn:00003F06 loc_3F06:                               ; CODE XREF: std::_Lower_bound<int *,int,int,BufferEquivalent>(int *,int *,int const &,BufferEquivalent,int *)+61j
.text$mn:00003F06                 mov     eax, [ebp+var_C]
.text$mn:00003F09                 mov     [ebp+var_4], eax
.text$mn:00003F0C
.text$mn:00003F0C loc_3F0C:                               ; CODE XREF: std::_Lower_bound<int *,int,int,BufferEquivalent>(int *,int *,int const &,BufferEquivalent,int *)+80j
.text$mn:00003F0C                 jmp     short loc_3EA5
.text$mn:00003F0E ; ---------------------------------------------------------------------------
.text$mn:00003F0E
.text$mn:00003F0E loc_3F0E:                               ; CODE XREF: std::_Lower_bound<int *,int,int,BufferEquivalent>(int *,int *,int const &,BufferEquivalent,int *)+25j
.text$mn:00003F0E                 mov     eax, [ebp+arg_0]
.text$mn:00003F11                 mov     esp, ebp
.text$mn:00003F13                 pop     ebp
.text$mn:00003F14                 retn
.text$mn:00003F14 ??$_Lower_bound@PAHHHUBufferEquivalent@@@std@@YAPAHPAH0ABHUBufferEquivalent@@0@Z endp
.text$mn:00003F14
.text$mn:00003F14 ; ---------------------------------------------------------------------------
.text$mn:00003F15                 align 4
.text$mn:00003F15 _text$mn        ends
.text$mn:00003F15
.text$mn:00003F18 ; ===========================================================================
.text$mn:00003F18
.text$mn:00003F18 ; Segment type: Pure code
.text$mn:00003F18 ; Segment permissions: Read/Execute
.text$mn:00003F18 _text$mn        segment para public 'CODE' use32
.text$mn:00003F18                 assume cs:_text$mn
.text$mn:00003F18                 ;org 3F18h
.text$mn:00003F18 ; COMDAT (pick any)
.text$mn:00003F18                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003F18
.text$mn:00003F18 ; =============== S U B R O U T I N E =======================================
.text$mn:00003F18
.text$mn:00003F18 ; Attributes: bp-based frame
.text$mn:00003F18
.text$mn:00003F18 ; int __cdecl std::_Merge<int *,int *,int *,BufferEquivalent>(void *Src, int, void *, int, void *Dst, int, int, int, int)
.text$mn:00003F18                 public ??$_Merge@PAHPAHPAHUBufferEquivalent@@@std@@YAPAHPAH0000UBufferEquivalent@@@Z
.text$mn:00003F18 ??$_Merge@PAHPAHPAHUBufferEquivalent@@@std@@YAPAHPAH0000UBufferEquivalent@@@Z proc near
.text$mn:00003F18                                         ; CODE XREF: std::_Buffered_merge<int *,int,int,BufferEquivalent>(int *,int *,int *,int,int,std::_Temp_iterator<int> &,BufferEquivalent)+136p
.text$mn:00003F18                                         ; std::_Chunked_merge<int *,int *,int,BufferEquivalent>(int *,int *,int *,int,int,BufferEquivalent)+7Ap ...
.text$mn:00003F18
.text$mn:00003F18 var_8           = dword ptr -8
.text$mn:00003F18 var_4           = dword ptr -4
.text$mn:00003F18 Src             = dword ptr  8
.text$mn:00003F18 arg_4           = dword ptr  0Ch
.text$mn:00003F18 arg_8           = dword ptr  10h
.text$mn:00003F18 arg_C           = dword ptr  14h
.text$mn:00003F18 Dst             = dword ptr  18h
.text$mn:00003F18 arg_14          = dword ptr  1Ch
.text$mn:00003F18 arg_18          = dword ptr  20h
.text$mn:00003F18 arg_1C          = dword ptr  24h
.text$mn:00003F18 arg_20          = dword ptr  28h
.text$mn:00003F18
.text$mn:00003F18                 push    ebp
.text$mn:00003F19                 mov     ebp, esp
.text$mn:00003F1B                 sub     esp, 8
.text$mn:00003F1E                 mov     eax, [ebp+Src]
.text$mn:00003F21                 cmp     eax, [ebp+arg_4]
.text$mn:00003F24                 jz      loc_3FE4
.text$mn:00003F2A                 mov     ecx, [ebp+arg_8]
.text$mn:00003F2D                 cmp     ecx, [ebp+arg_C]
.text$mn:00003F30                 jz      loc_3FE4
.text$mn:00003F36
.text$mn:00003F36 loc_3F36:                               ; CODE XREF: std::_Merge<int *,int *,int *,BufferEquivalent>(int *,int *,int *,int *,int *,BufferEquivalent):loc_3FDFj
.text$mn:00003F36                 push    0B45h           ; unsigned int
.text$mn:00003F3B                 push    offset ??_C@_1JC@HALMDPKM@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00003F40                 mov     edx, [ebp+Src]
.text$mn:00003F43                 push    edx             ; int
.text$mn:00003F44                 mov     eax, [ebp+arg_8]
.text$mn:00003F47                 push    eax             ; int
.text$mn:00003F48                 sub     esp, 10h
.text$mn:00003F4B                 mov     ecx, esp
.text$mn:00003F4D                 mov     edx, [ebp+arg_14]
.text$mn:00003F50                 mov     [ecx], edx
.text$mn:00003F52                 mov     eax, [ebp+arg_18]
.text$mn:00003F55                 mov     [ecx+4], eax
.text$mn:00003F58                 mov     edx, [ebp+arg_1C]
.text$mn:00003F5B                 mov     [ecx+8], edx
.text$mn:00003F5E                 mov     eax, [ebp+arg_20]
.text$mn:00003F61                 mov     [ecx+0Ch], eax
.text$mn:00003F64                 call    ??$_Debug_lt_pred@UBufferEquivalent@@AAHAAH@std@@YA_NUBufferEquivalent@@AAH1PB_WI@Z ; std::_Debug_lt_pred<BufferEquivalent,int &,int &>(BufferEquivalent,int &,int &,wchar_t const *,uint)
.text$mn:00003F69                 add     esp, 20h
.text$mn:00003F6C                 movzx   ecx, al
.text$mn:00003F6F                 test    ecx, ecx
.text$mn:00003F71                 jz      short loc_3FAA
.text$mn:00003F73                 mov     edx, [ebp+arg_8]
.text$mn:00003F76                 mov     [ebp+var_4], edx
.text$mn:00003F79                 mov     eax, [ebp+var_4]
.text$mn:00003F7C                 push    eax
.text$mn:00003F7D                 call    ??$_Move@AAH@std@@YA$$QAHAAH@Z ; std::_Move<int &>(int &)
.text$mn:00003F82                 add     esp, 4
.text$mn:00003F85                 mov     ecx, [ebp+Dst]
.text$mn:00003F88                 mov     edx, [eax]
.text$mn:00003F8A                 mov     [ecx], edx
.text$mn:00003F8C                 mov     eax, [ebp+Dst]
.text$mn:00003F8F                 add     eax, 4
.text$mn:00003F92                 mov     [ebp+Dst], eax
.text$mn:00003F95                 mov     ecx, [ebp+arg_8]
.text$mn:00003F98                 add     ecx, 4
.text$mn:00003F9B                 mov     [ebp+arg_8], ecx
.text$mn:00003F9E                 mov     edx, [ebp+arg_8]
.text$mn:00003FA1                 cmp     edx, [ebp+arg_C]
.text$mn:00003FA4                 jnz     short loc_3FA8
.text$mn:00003FA6                 jmp     short loc_3FE4
.text$mn:00003FA8 ; ---------------------------------------------------------------------------
.text$mn:00003FA8
.text$mn:00003FA8 loc_3FA8:                               ; CODE XREF: std::_Merge<int *,int *,int *,BufferEquivalent>(int *,int *,int *,int *,int *,BufferEquivalent)+8Cj
.text$mn:00003FA8                 jmp     short loc_3FDF
.text$mn:00003FAA ; ---------------------------------------------------------------------------
.text$mn:00003FAA
.text$mn:00003FAA loc_3FAA:                               ; CODE XREF: std::_Merge<int *,int *,int *,BufferEquivalent>(int *,int *,int *,int *,int *,BufferEquivalent)+59j
.text$mn:00003FAA                 mov     eax, [ebp+Src]
.text$mn:00003FAD                 mov     [ebp+var_8], eax
.text$mn:00003FB0                 mov     ecx, [ebp+var_8]
.text$mn:00003FB3                 push    ecx
.text$mn:00003FB4                 call    ??$_Move@AAH@std@@YA$$QAHAAH@Z ; std::_Move<int &>(int &)
.text$mn:00003FB9                 add     esp, 4
.text$mn:00003FBC                 mov     edx, [ebp+Dst]
.text$mn:00003FBF                 mov     eax, [eax]
.text$mn:00003FC1                 mov     [edx], eax
.text$mn:00003FC3                 mov     ecx, [ebp+Dst]
.text$mn:00003FC6                 add     ecx, 4
.text$mn:00003FC9                 mov     [ebp+Dst], ecx
.text$mn:00003FCC                 mov     edx, [ebp+Src]
.text$mn:00003FCF                 add     edx, 4
.text$mn:00003FD2                 mov     [ebp+Src], edx
.text$mn:00003FD5                 mov     eax, [ebp+Src]
.text$mn:00003FD8                 cmp     eax, [ebp+arg_4]
.text$mn:00003FDB                 jnz     short loc_3FDF
.text$mn:00003FDD                 jmp     short loc_3FE4
.text$mn:00003FDF ; ---------------------------------------------------------------------------
.text$mn:00003FDF
.text$mn:00003FDF loc_3FDF:                               ; CODE XREF: std::_Merge<int *,int *,int *,BufferEquivalent>(int *,int *,int *,int *,int *,BufferEquivalent):loc_3FA8j
.text$mn:00003FDF                                         ; std::_Merge<int *,int *,int *,BufferEquivalent>(int *,int *,int *,int *,int *,BufferEquivalent)+C3j
.text$mn:00003FDF                 jmp     loc_3F36
.text$mn:00003FE4 ; ---------------------------------------------------------------------------
.text$mn:00003FE4
.text$mn:00003FE4 loc_3FE4:                               ; CODE XREF: std::_Merge<int *,int *,int *,BufferEquivalent>(int *,int *,int *,int *,int *,BufferEquivalent)+Cj
.text$mn:00003FE4                                         ; std::_Merge<int *,int *,int *,BufferEquivalent>(int *,int *,int *,int *,int *,BufferEquivalent)+18j ...
.text$mn:00003FE4                 mov     ecx, [ebp+Dst]
.text$mn:00003FE7                 push    ecx             ; Dst
.text$mn:00003FE8                 mov     edx, [ebp+arg_4]
.text$mn:00003FEB                 push    edx             ; int
.text$mn:00003FEC                 mov     eax, [ebp+Src]
.text$mn:00003FEF                 push    eax             ; Src
.text$mn:00003FF0                 call    ??$_Move@PAHPAH@std@@YAPAHPAH00@Z ; std::_Move<int *,int *>(int *,int *,int *)
.text$mn:00003FF5                 add     esp, 0Ch
.text$mn:00003FF8                 mov     [ebp+Dst], eax
.text$mn:00003FFB                 mov     ecx, [ebp+Dst]
.text$mn:00003FFE                 push    ecx             ; Dst
.text$mn:00003FFF                 mov     edx, [ebp+arg_C]
.text$mn:00004002                 push    edx             ; int
.text$mn:00004003                 mov     eax, [ebp+arg_8]
.text$mn:00004006                 push    eax             ; Src
.text$mn:00004007                 call    ??$_Move@PAHPAH@std@@YAPAHPAH00@Z ; std::_Move<int *,int *>(int *,int *,int *)
.text$mn:0000400C                 add     esp, 0Ch
.text$mn:0000400F                 mov     esp, ebp
.text$mn:00004011                 pop     ebp
.text$mn:00004012                 retn
.text$mn:00004012 ??$_Merge@PAHPAHPAHUBufferEquivalent@@@std@@YAPAHPAH0000UBufferEquivalent@@@Z endp
.text$mn:00004012
.text$mn:00004012 ; ---------------------------------------------------------------------------
.text$mn:00004013                 align 4
.text$mn:00004013 _text$mn        ends
.text$mn:00004013
.text$mn:00004014 ; ===========================================================================
.text$mn:00004014
.text$mn:00004014 ; Segment type: Pure code
.text$mn:00004014 ; Segment permissions: Read/Execute
.text$mn:00004014 _text$mn        segment para public 'CODE' use32
.text$mn:00004014                 assume cs:_text$mn
.text$mn:00004014                 ;org 4014h
.text$mn:00004014 ; COMDAT (pick any)
.text$mn:00004014                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004014
.text$mn:00004014 ; =============== S U B R O U T I N E =======================================
.text$mn:00004014
.text$mn:00004014 ; Attributes: bp-based frame
.text$mn:00004014
.text$mn:00004014 ; class std::_Temp_iterator<int> __cdecl std::_Merge<int *, int *, class std::_Temp_iterator<int>, struct BufferEquivalent>(int *, int *, int *, int *, class std::_Temp_iterator<int>, struct BufferEquivalent)
.text$mn:00004014                 public ??$_Merge@PAHPAHV?$_Temp_iterator@H@std@@UBufferEquivalent@@@std@@YA?AV?$_Temp_iterator@H@0@PAH000V10@UBufferEquivalent@@@Z
.text$mn:00004014 ??$_Merge@PAHPAHV?$_Temp_iterator@H@std@@UBufferEquivalent@@@std@@YA?AV?$_Temp_iterator@H@0@PAH000V10@UBufferEquivalent@@@Z proc near
.text$mn:00004014                                         ; CODE XREF: std::_Chunked_merge<int *,std::_Temp_iterator<int>,int,BufferEquivalent>(int *,int *,std::_Temp_iterator<int>,int,int,BufferEquivalent)+CCp
.text$mn:00004014                                         ; std::_Chunked_merge<int *,std::_Temp_iterator<int>,int,BufferEquivalent>(int *,int *,std::_Temp_iterator<int>,int,int,BufferEquivalent)+1BDp
.text$mn:00004014
.text$mn:00004014 var_58          = byte ptr -58h
.text$mn:00004014 var_44          = dword ptr -44h
.text$mn:00004014 var_40          = dword ptr -40h
.text$mn:00004014 var_3C          = dword ptr -3Ch
.text$mn:00004014 var_38          = dword ptr -38h
.text$mn:00004014 var_34          = dword ptr -34h
.text$mn:00004014 var_30          = dword ptr -30h
.text$mn:00004014 var_2C          = dword ptr -2Ch
.text$mn:00004014 var_28          = dword ptr -28h
.text$mn:00004014 var_24          = dword ptr -24h
.text$mn:00004014 var_20          = dword ptr -20h
.text$mn:00004014 var_1C          = dword ptr -1Ch
.text$mn:00004014 var_18          = dword ptr -18h
.text$mn:00004014 var_14          = dword ptr -14h
.text$mn:00004014 var_10          = dword ptr -10h
.text$mn:00004014 var_C           = dword ptr -0Ch
.text$mn:00004014 var_4           = dword ptr -4
.text$mn:00004014 arg_0           = dword ptr  8
.text$mn:00004014 arg_4           = dword ptr  0Ch
.text$mn:00004014 arg_8           = dword ptr  10h
.text$mn:00004014 arg_C           = dword ptr  14h
.text$mn:00004014 arg_10          = dword ptr  18h
.text$mn:00004014 arg_14          = byte ptr  1Ch
.text$mn:00004014 arg_28          = dword ptr  30h
.text$mn:00004014 arg_2C          = dword ptr  34h
.text$mn:00004014 arg_30          = dword ptr  38h
.text$mn:00004014 arg_34          = dword ptr  3Ch
.text$mn:00004014
.text$mn:00004014                 push    ebp
.text$mn:00004015                 mov     ebp, esp
.text$mn:00004017                 push    0FFFFFFFFh
.text$mn:00004019                 push    offset __ehhandler$??$_Merge@PAHPAHV?$_Temp_iterator@H@std@@UBufferEquivalent@@@std@@YA?AV?$_Temp_iterator@H@0@PAH000V10@UBufferEquivalent@@@Z
.text$mn:0000401E                 mov     eax, large fs:0
.text$mn:00004024                 push    eax
.text$mn:00004025                 sub     esp, 4Ch
.text$mn:00004028                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000402D                 xor     eax, ebp
.text$mn:0000402F                 push    eax
.text$mn:00004030                 lea     eax, [ebp+var_C]
.text$mn:00004033                 mov     large fs:0, eax
.text$mn:00004039                 mov     [ebp+var_10], 0
.text$mn:00004040                 mov     [ebp+var_4], 1
.text$mn:00004047                 mov     eax, [ebp+arg_4]
.text$mn:0000404A                 cmp     eax, [ebp+arg_8]
.text$mn:0000404D                 jz      loc_412B
.text$mn:00004053                 mov     ecx, [ebp+arg_C]
.text$mn:00004056                 cmp     ecx, [ebp+arg_10]
.text$mn:00004059                 jz      loc_412B
.text$mn:0000405F
.text$mn:0000405F loc_405F:                               ; CODE XREF: std::_Merge<int *,int *,std::_Temp_iterator<int>,BufferEquivalent>(int *,int *,int *,int *,std::_Temp_iterator<int>,BufferEquivalent):loc_4126j
.text$mn:0000405F                 push    0B45h           ; unsigned int
.text$mn:00004064                 push    offset ??_C@_1JC@HALMDPKM@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00004069                 mov     edx, [ebp+arg_4]
.text$mn:0000406C                 push    edx             ; int
.text$mn:0000406D                 mov     eax, [ebp+arg_C]
.text$mn:00004070                 push    eax             ; int
.text$mn:00004071                 sub     esp, 10h
.text$mn:00004074                 mov     ecx, esp
.text$mn:00004076                 mov     edx, [ebp+arg_28]
.text$mn:00004079                 mov     [ecx], edx
.text$mn:0000407B                 mov     eax, [ebp+arg_2C]
.text$mn:0000407E                 mov     [ecx+4], eax
.text$mn:00004081                 mov     edx, [ebp+arg_30]
.text$mn:00004084                 mov     [ecx+8], edx
.text$mn:00004087                 mov     eax, [ebp+arg_34]
.text$mn:0000408A                 mov     [ecx+0Ch], eax
.text$mn:0000408D                 call    ??$_Debug_lt_pred@UBufferEquivalent@@AAHAAH@std@@YA_NUBufferEquivalent@@AAH1PB_WI@Z ; std::_Debug_lt_pred<BufferEquivalent,int &,int &>(BufferEquivalent,int &,int &,wchar_t const *,uint)
.text$mn:00004092                 add     esp, 20h
.text$mn:00004095                 movzx   ecx, al
.text$mn:00004098                 test    ecx, ecx
.text$mn:0000409A                 jz      short loc_40E2
.text$mn:0000409C                 mov     edx, [ebp+arg_C]
.text$mn:0000409F                 mov     [ebp+var_14], edx
.text$mn:000040A2                 mov     eax, [ebp+var_14]
.text$mn:000040A5                 push    eax
.text$mn:000040A6                 call    ??$_Move@AAH@std@@YA$$QAHAAH@Z ; std::_Move<int &>(int &)
.text$mn:000040AB                 add     esp, 4
.text$mn:000040AE                 mov     [ebp+var_18], eax
.text$mn:000040B1                 mov     ecx, [ebp+var_18]
.text$mn:000040B4                 push    ecx
.text$mn:000040B5                 push    0
.text$mn:000040B7                 lea     ecx, [ebp+arg_14]
.text$mn:000040BA                 call    ??E?$_Temp_iterator@H@std@@QAEAAV01@H@Z ; std::_Temp_iterator<int>::operator++(int)
.text$mn:000040BF                 mov     ecx, eax
.text$mn:000040C1                 call    ??D?$_Temp_iterator@H@std@@QAEAAV01@XZ ; std::_Temp_iterator<int>::operator*(void)
.text$mn:000040C6                 mov     ecx, eax
.text$mn:000040C8                 call    ??4?$_Temp_iterator@H@std@@QAEAAV01@$$QAH@Z ; std::_Temp_iterator<int>::operator=(int &&)
.text$mn:000040CD                 mov     edx, [ebp+arg_C]
.text$mn:000040D0                 add     edx, 4
.text$mn:000040D3                 mov     [ebp+arg_C], edx
.text$mn:000040D6                 mov     eax, [ebp+arg_C]
.text$mn:000040D9                 cmp     eax, [ebp+arg_10]
.text$mn:000040DC                 jnz     short loc_40E0
.text$mn:000040DE                 jmp     short loc_412B
.text$mn:000040E0 ; ---------------------------------------------------------------------------
.text$mn:000040E0
.text$mn:000040E0 loc_40E0:                               ; CODE XREF: std::_Merge<int *,int *,std::_Temp_iterator<int>,BufferEquivalent>(int *,int *,int *,int *,std::_Temp_iterator<int>,BufferEquivalent)+C8j
.text$mn:000040E0                 jmp     short loc_4126
.text$mn:000040E2 ; ---------------------------------------------------------------------------
.text$mn:000040E2
.text$mn:000040E2 loc_40E2:                               ; CODE XREF: std::_Merge<int *,int *,std::_Temp_iterator<int>,BufferEquivalent>(int *,int *,int *,int *,std::_Temp_iterator<int>,BufferEquivalent)+86j
.text$mn:000040E2                 mov     ecx, [ebp+arg_4]
.text$mn:000040E5                 mov     [ebp+var_1C], ecx
.text$mn:000040E8                 mov     edx, [ebp+var_1C]
.text$mn:000040EB                 push    edx
.text$mn:000040EC                 call    ??$_Move@AAH@std@@YA$$QAHAAH@Z ; std::_Move<int &>(int &)
.text$mn:000040F1                 add     esp, 4
.text$mn:000040F4                 mov     [ebp+var_20], eax
.text$mn:000040F7                 mov     eax, [ebp+var_20]
.text$mn:000040FA                 push    eax
.text$mn:000040FB                 push    0
.text$mn:000040FD                 lea     ecx, [ebp+arg_14]
.text$mn:00004100                 call    ??E?$_Temp_iterator@H@std@@QAEAAV01@H@Z ; std::_Temp_iterator<int>::operator++(int)
.text$mn:00004105                 mov     ecx, eax
.text$mn:00004107                 call    ??D?$_Temp_iterator@H@std@@QAEAAV01@XZ ; std::_Temp_iterator<int>::operator*(void)
.text$mn:0000410C                 mov     ecx, eax
.text$mn:0000410E                 call    ??4?$_Temp_iterator@H@std@@QAEAAV01@$$QAH@Z ; std::_Temp_iterator<int>::operator=(int &&)
.text$mn:00004113                 mov     ecx, [ebp+arg_4]
.text$mn:00004116                 add     ecx, 4
.text$mn:00004119                 mov     [ebp+arg_4], ecx
.text$mn:0000411C                 mov     edx, [ebp+arg_4]
.text$mn:0000411F                 cmp     edx, [ebp+arg_8]
.text$mn:00004122                 jnz     short loc_4126
.text$mn:00004124                 jmp     short loc_412B
.text$mn:00004126 ; ---------------------------------------------------------------------------
.text$mn:00004126
.text$mn:00004126 loc_4126:                               ; CODE XREF: std::_Merge<int *,int *,std::_Temp_iterator<int>,BufferEquivalent>(int *,int *,int *,int *,std::_Temp_iterator<int>,BufferEquivalent):loc_40E0j
.text$mn:00004126                                         ; std::_Merge<int *,int *,std::_Temp_iterator<int>,BufferEquivalent>(int *,int *,int *,int *,std::_Temp_iterator<int>,BufferEquivalent)+10Ej
.text$mn:00004126                 jmp     loc_405F
.text$mn:0000412B ; ---------------------------------------------------------------------------
.text$mn:0000412B
.text$mn:0000412B loc_412B:                               ; CODE XREF: std::_Merge<int *,int *,std::_Temp_iterator<int>,BufferEquivalent>(int *,int *,int *,int *,std::_Temp_iterator<int>,BufferEquivalent)+39j
.text$mn:0000412B                                         ; std::_Merge<int *,int *,std::_Temp_iterator<int>,BufferEquivalent>(int *,int *,int *,int *,std::_Temp_iterator<int>,BufferEquivalent)+45j ...
.text$mn:0000412B                 sub     esp, 14h
.text$mn:0000412E                 mov     ecx, esp
.text$mn:00004130                 mov     [ebp+var_34], esp
.text$mn:00004133                 lea     eax, [ebp+arg_14]
.text$mn:00004136                 push    eax
.text$mn:00004137                 call    ??0?$_Temp_iterator@H@std@@QAE@ABV01@@Z ; std::_Temp_iterator<int>::_Temp_iterator<int>(std::_Temp_iterator<int> const &)
.text$mn:0000413C                 mov     [ebp+var_24], eax
.text$mn:0000413F                 mov     ecx, [ebp+var_24]
.text$mn:00004142                 mov     [ebp+var_38], ecx
.text$mn:00004145                 mov     byte ptr [ebp+var_4], 2
.text$mn:00004149                 mov     edx, [ebp+arg_8]
.text$mn:0000414C                 push    edx
.text$mn:0000414D                 mov     eax, [ebp+arg_4]
.text$mn:00004150                 push    eax
.text$mn:00004151                 lea     ecx, [ebp+var_58]
.text$mn:00004154                 push    ecx
.text$mn:00004155                 mov     byte ptr [ebp+var_4], 1
.text$mn:00004159                 call    ??$_Move@PAHV?$_Temp_iterator@H@std@@@std@@YA?AV?$_Temp_iterator@H@0@PAH0V10@@Z ; std::_Move<int *,std::_Temp_iterator<int>>(int *,int *,std::_Temp_iterator<int>)
.text$mn:0000415E                 add     esp, 20h
.text$mn:00004161                 mov     [ebp+var_28], eax
.text$mn:00004164                 mov     edx, [ebp+var_28]
.text$mn:00004167                 mov     [ebp+var_2C], edx
.text$mn:0000416A                 mov     byte ptr [ebp+var_4], 3
.text$mn:0000416E                 mov     eax, [ebp+var_2C]
.text$mn:00004171                 push    eax
.text$mn:00004172                 lea     ecx, [ebp+arg_14]
.text$mn:00004175                 call    ??4?$_Temp_iterator@H@std@@QAEAAV01@ABV01@@Z ; std::_Temp_iterator<int>::operator=(std::_Temp_iterator<int> const &)
.text$mn:0000417A                 mov     byte ptr [ebp+var_4], 1
.text$mn:0000417E                 lea     ecx, [ebp+var_58]
.text$mn:00004181                 call    ??1?$_Temp_iterator@H@std@@QAE@XZ ; std::_Temp_iterator<int>::~_Temp_iterator<int>(void)
.text$mn:00004186                 sub     esp, 14h
.text$mn:00004189                 mov     ecx, esp
.text$mn:0000418B                 mov     [ebp+var_3C], esp
.text$mn:0000418E                 lea     edx, [ebp+arg_14]
.text$mn:00004191                 push    edx
.text$mn:00004192                 call    ??0?$_Temp_iterator@H@std@@QAE@ABV01@@Z ; std::_Temp_iterator<int>::_Temp_iterator<int>(std::_Temp_iterator<int> const &)
.text$mn:00004197                 mov     [ebp+var_30], eax
.text$mn:0000419A                 mov     eax, [ebp+var_30]
.text$mn:0000419D                 mov     [ebp+var_40], eax
.text$mn:000041A0                 mov     byte ptr [ebp+var_4], 4
.text$mn:000041A4                 mov     ecx, [ebp+arg_10]
.text$mn:000041A7                 push    ecx
.text$mn:000041A8                 mov     edx, [ebp+arg_C]
.text$mn:000041AB                 push    edx
.text$mn:000041AC                 mov     eax, [ebp+arg_0]
.text$mn:000041AF                 push    eax
.text$mn:000041B0                 mov     byte ptr [ebp+var_4], 1
.text$mn:000041B4                 call    ??$_Move@PAHV?$_Temp_iterator@H@std@@@std@@YA?AV?$_Temp_iterator@H@0@PAH0V10@@Z ; std::_Move<int *,std::_Temp_iterator<int>>(int *,int *,std::_Temp_iterator<int>)
.text$mn:000041B9                 add     esp, 20h
.text$mn:000041BC                 mov     [ebp+var_44], eax
.text$mn:000041BF                 mov     ecx, [ebp+var_10]
.text$mn:000041C2                 or      ecx, 1
.text$mn:000041C5                 mov     [ebp+var_10], ecx
.text$mn:000041C8                 mov     byte ptr [ebp+var_4], 0
.text$mn:000041CC                 lea     ecx, [ebp+arg_14]
.text$mn:000041CF                 call    ??1?$_Temp_iterator@H@std@@QAE@XZ ; std::_Temp_iterator<int>::~_Temp_iterator<int>(void)
.text$mn:000041D4                 mov     eax, [ebp+arg_0]
.text$mn:000041D7                 mov     ecx, [ebp+var_C]
.text$mn:000041DA                 mov     large fs:0, ecx
.text$mn:000041E1                 pop     ecx
.text$mn:000041E2                 mov     esp, ebp
.text$mn:000041E4                 pop     ebp
.text$mn:000041E5                 retn
.text$mn:000041E5 ??$_Merge@PAHPAHV?$_Temp_iterator@H@std@@UBufferEquivalent@@@std@@YA?AV?$_Temp_iterator@H@0@PAH000V10@UBufferEquivalent@@@Z endp
.text$mn:000041E5
.text$mn:000041E5 ; ---------------------------------------------------------------------------
.text$mn:000041E6                 align 4
.text$mn:000041E6 _text$mn        ends
.text$mn:000041E6
.text$x:000041E8 ; ===========================================================================
.text$x:000041E8
.text$x:000041E8 ; Segment type: Pure code
.text$x:000041E8 ; Segment permissions: Read/Execute
.text$x:000041E8 _text$x         segment para public 'CODE' use32
.text$x:000041E8                 assume cs:_text$x
.text$x:000041E8                 ;org 41E8h
.text$x:000041E8 ; COMDAT (pick associative to section at 4014)
.text$x:000041E8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000041E8
.text$x:000041E8 ; =============== S U B R O U T I N E =======================================
.text$x:000041E8
.text$x:000041E8
.text$x:000041E8 __unwindfunclet$??$_Merge@PAHPAHV?$_Temp_iterator@H@std@@UBufferEquivalent@@@std@@YA?AV?$_Temp_iterator@H@0@PAH000V10@UBufferEquivalent@@@Z$0 proc near
.text$x:000041E8                                         ; DATA XREF: .xdata$x:0000DB98o
.text$x:000041E8                 lea     ecx, [ebp+1Ch]
.text$x:000041EB                 jmp     ??1?$_Temp_iterator@H@std@@QAE@XZ ; std::_Temp_iterator<int>::~_Temp_iterator<int>(void)
.text$x:000041EB __unwindfunclet$??$_Merge@PAHPAHV?$_Temp_iterator@H@std@@UBufferEquivalent@@@std@@YA?AV?$_Temp_iterator@H@0@PAH000V10@UBufferEquivalent@@@Z$0 endp
.text$x:000041EB
.text$x:000041F0
.text$x:000041F0 ; =============== S U B R O U T I N E =======================================
.text$x:000041F0
.text$x:000041F0
.text$x:000041F0 __unwindfunclet$??$_Merge@PAHPAHV?$_Temp_iterator@H@std@@UBufferEquivalent@@@std@@YA?AV?$_Temp_iterator@H@0@PAH000V10@UBufferEquivalent@@@Z$1 proc near
.text$x:000041F0                                         ; DATA XREF: .xdata$x:0000DBA0o
.text$x:000041F0                 mov     ecx, [ebp-34h]
.text$x:000041F3                 jmp     ??1?$_Temp_iterator@H@std@@QAE@XZ ; std::_Temp_iterator<int>::~_Temp_iterator<int>(void)
.text$x:000041F3 __unwindfunclet$??$_Merge@PAHPAHV?$_Temp_iterator@H@std@@UBufferEquivalent@@@std@@YA?AV?$_Temp_iterator@H@0@PAH000V10@UBufferEquivalent@@@Z$1 endp
.text$x:000041F3
.text$x:000041F8
.text$x:000041F8 ; =============== S U B R O U T I N E =======================================
.text$x:000041F8
.text$x:000041F8
.text$x:000041F8 __unwindfunclet$??$_Merge@PAHPAHV?$_Temp_iterator@H@std@@UBufferEquivalent@@@std@@YA?AV?$_Temp_iterator@H@0@PAH000V10@UBufferEquivalent@@@Z$2 proc near
.text$x:000041F8                                         ; DATA XREF: .xdata$x:0000DBA8o
.text$x:000041F8                 lea     ecx, [ebp-58h]
.text$x:000041FB                 jmp     ??1?$_Temp_iterator@H@std@@QAE@XZ ; std::_Temp_iterator<int>::~_Temp_iterator<int>(void)
.text$x:000041FB __unwindfunclet$??$_Merge@PAHPAHV?$_Temp_iterator@H@std@@UBufferEquivalent@@@std@@YA?AV?$_Temp_iterator@H@0@PAH000V10@UBufferEquivalent@@@Z$2 endp
.text$x:000041FB
.text$x:00004200
.text$x:00004200 ; =============== S U B R O U T I N E =======================================
.text$x:00004200
.text$x:00004200
.text$x:00004200 __unwindfunclet$??$_Merge@PAHPAHV?$_Temp_iterator@H@std@@UBufferEquivalent@@@std@@YA?AV?$_Temp_iterator@H@0@PAH000V10@UBufferEquivalent@@@Z$3 proc near
.text$x:00004200                                         ; DATA XREF: .xdata$x:0000DBB0o
.text$x:00004200                 mov     ecx, [ebp-3Ch]
.text$x:00004203                 jmp     ??1?$_Temp_iterator@H@std@@QAE@XZ ; std::_Temp_iterator<int>::~_Temp_iterator<int>(void)
.text$x:00004203 __unwindfunclet$??$_Merge@PAHPAHV?$_Temp_iterator@H@std@@UBufferEquivalent@@@std@@YA?AV?$_Temp_iterator@H@0@PAH000V10@UBufferEquivalent@@@Z$3 endp
.text$x:00004203
.text$x:00004208
.text$x:00004208 ; =============== S U B R O U T I N E =======================================
.text$x:00004208
.text$x:00004208
.text$x:00004208 __unwindfunclet$??$_Merge@PAHPAHV?$_Temp_iterator@H@std@@UBufferEquivalent@@@std@@YA?AV?$_Temp_iterator@H@0@PAH000V10@UBufferEquivalent@@@Z$4 proc near
.text$x:00004208                                         ; DATA XREF: .xdata$x:0000DB90o
.text$x:00004208                 mov     eax, [ebp-10h]
.text$x:0000420B                 and     eax, 1
.text$x:0000420E                 jz      $LN15
.text$x:00004214                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:00004218                 mov     ecx, [ebp+8]
.text$x:0000421B                 jmp     ??1?$_Temp_iterator@H@std@@QAE@XZ ; std::_Temp_iterator<int>::~_Temp_iterator<int>(void)
.text$x:00004220 ; ---------------------------------------------------------------------------
.text$x:00004220
.text$x:00004220 $LN15:                                  ; CODE XREF: __unwindfunclet$??$_Merge@PAHPAHV?$_Temp_iterator@H@std@@UBufferEquivalent@@@std@@YA?AV?$_Temp_iterator@H@0@PAH000V10@UBufferEquivalent@@@Z$4+6j
.text$x:00004220                 retn
.text$x:00004220 __unwindfunclet$??$_Merge@PAHPAHV?$_Temp_iterator@H@std@@UBufferEquivalent@@@std@@YA?AV?$_Temp_iterator@H@0@PAH000V10@UBufferEquivalent@@@Z$4 endp
.text$x:00004220
.text$x:00004221
.text$x:00004221 ; =============== S U B R O U T I N E =======================================
.text$x:00004221
.text$x:00004221
.text$x:00004221 __ehhandler$??$_Merge@PAHPAHV?$_Temp_iterator@H@std@@UBufferEquivalent@@@std@@YA?AV?$_Temp_iterator@H@0@PAH000V10@UBufferEquivalent@@@Z proc near
.text$x:00004221                                         ; DATA XREF: std::_Merge<int *,int *,std::_Temp_iterator<int>,BufferEquivalent>(int *,int *,int *,int *,std::_Temp_iterator<int>,BufferEquivalent)+5o
.text$x:00004221
.text$x:00004221 arg_4           = dword ptr  8
.text$x:00004221
.text$x:00004221                 mov     edx, [esp+arg_4]
.text$x:00004225                 lea     eax, [edx+0Ch]
.text$x:00004228                 mov     ecx, [edx-50h]
.text$x:0000422B                 xor     ecx, eax
.text$x:0000422D                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004232                 mov     eax, offset __ehfuncinfo$??$_Merge@PAHPAHV?$_Temp_iterator@H@std@@UBufferEquivalent@@@std@@YA?AV?$_Temp_iterator@H@0@PAH000V10@UBufferEquivalent@@@Z
.text$x:00004237                 jmp     ___CxxFrameHandler3
.text$x:00004237 __ehhandler$??$_Merge@PAHPAHV?$_Temp_iterator@H@std@@UBufferEquivalent@@@std@@YA?AV?$_Temp_iterator@H@0@PAH000V10@UBufferEquivalent@@@Z endp
.text$x:00004237
.text$x:00004237 _text$x         ends
.text$x:00004237
.text$mn:0000423C ; ===========================================================================
.text$mn:0000423C
.text$mn:0000423C ; Segment type: Pure code
.text$mn:0000423C ; Segment permissions: Read/Execute
.text$mn:0000423C _text$mn        segment para public 'CODE' use32
.text$mn:0000423C                 assume cs:_text$mn
.text$mn:0000423C                 ;org 423Ch
.text$mn:0000423C ; COMDAT (pick any)
.text$mn:0000423C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000423C
.text$mn:0000423C ; =============== S U B R O U T I N E =======================================
.text$mn:0000423C
.text$mn:0000423C ; Attributes: bp-based frame
.text$mn:0000423C
.text$mn:0000423C ; int __cdecl std::_Merge_backward<int *,int *,int *,BufferEquivalent>(void *, int, void *Src, int, int, int, int, int, int)
.text$mn:0000423C                 public ??$_Merge_backward@PAHPAHPAHUBufferEquivalent@@@std@@YAPAHPAH0000UBufferEquivalent@@@Z
.text$mn:0000423C ??$_Merge_backward@PAHPAHPAHUBufferEquivalent@@@std@@YAPAHPAH0000UBufferEquivalent@@@Z proc near
.text$mn:0000423C                                         ; CODE XREF: std::_Buffered_merge<int *,int,int,BufferEquivalent>(int *,int *,int *,int,int,std::_Temp_iterator<int> &,BufferEquivalent)+1DAp
.text$mn:0000423C
.text$mn:0000423C arg_0           = dword ptr  8
.text$mn:0000423C arg_4           = dword ptr  0Ch
.text$mn:0000423C Src             = dword ptr  10h
.text$mn:0000423C arg_C           = dword ptr  14h
.text$mn:0000423C arg_10          = dword ptr  18h
.text$mn:0000423C arg_14          = dword ptr  1Ch
.text$mn:0000423C arg_18          = dword ptr  20h
.text$mn:0000423C arg_1C          = dword ptr  24h
.text$mn:0000423C arg_20          = dword ptr  28h
.text$mn:0000423C
.text$mn:0000423C                 push    ebp
.text$mn:0000423D                 mov     ebp, esp
.text$mn:0000423F                 mov     eax, [ebp+arg_0]
.text$mn:00004242                 cmp     eax, [ebp+arg_4]
.text$mn:00004245                 jz      loc_430B
.text$mn:0000424B                 mov     ecx, [ebp+Src]
.text$mn:0000424E                 cmp     ecx, [ebp+arg_C]
.text$mn:00004251                 jz      loc_430B
.text$mn:00004257
.text$mn:00004257 loc_4257:                               ; CODE XREF: std::_Merge_backward<int *,int *,int *,BufferEquivalent>(int *,int *,int *,int *,int *,BufferEquivalent):loc_4306j
.text$mn:00004257                 mov     edx, [ebp+arg_4]
.text$mn:0000425A                 sub     edx, 4
.text$mn:0000425D                 mov     [ebp+arg_4], edx
.text$mn:00004260                 mov     eax, [ebp+arg_C]
.text$mn:00004263                 sub     eax, 4
.text$mn:00004266                 mov     [ebp+arg_C], eax
.text$mn:00004269                 push    0B26h           ; unsigned int
.text$mn:0000426E                 push    offset ??_C@_1JC@HALMDPKM@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00004273                 mov     ecx, [ebp+arg_4]
.text$mn:00004276                 push    ecx             ; int
.text$mn:00004277                 mov     edx, [ebp+arg_C]
.text$mn:0000427A                 push    edx             ; int
.text$mn:0000427B                 sub     esp, 10h
.text$mn:0000427E                 mov     eax, esp
.text$mn:00004280                 mov     ecx, [ebp+arg_14]
.text$mn:00004283                 mov     [eax], ecx
.text$mn:00004285                 mov     edx, [ebp+arg_18]
.text$mn:00004288                 mov     [eax+4], edx
.text$mn:0000428B                 mov     ecx, [ebp+arg_1C]
.text$mn:0000428E                 mov     [eax+8], ecx
.text$mn:00004291                 mov     edx, [ebp+arg_20]
.text$mn:00004294                 mov     [eax+0Ch], edx
.text$mn:00004297                 call    ??$_Debug_lt_pred@UBufferEquivalent@@AAHAAH@std@@YA_NUBufferEquivalent@@AAH1PB_WI@Z ; std::_Debug_lt_pred<BufferEquivalent,int &,int &>(BufferEquivalent,int &,int &,wchar_t const *,uint)
.text$mn:0000429C                 add     esp, 20h
.text$mn:0000429F                 movzx   eax, al
.text$mn:000042A2                 test    eax, eax
.text$mn:000042A4                 jz      short loc_42D7
.text$mn:000042A6                 mov     ecx, [ebp+arg_10]
.text$mn:000042A9                 sub     ecx, 4
.text$mn:000042AC                 mov     [ebp+arg_10], ecx
.text$mn:000042AF                 mov     edx, [ebp+arg_4]
.text$mn:000042B2                 push    edx
.text$mn:000042B3                 call    ??$_Move@AAH@std@@YA$$QAHAAH@Z ; std::_Move<int &>(int &)
.text$mn:000042B8                 add     esp, 4
.text$mn:000042BB                 mov     ecx, [ebp+arg_10]
.text$mn:000042BE                 mov     edx, [eax]
.text$mn:000042C0                 mov     [ecx], edx
.text$mn:000042C2                 mov     eax, [ebp+arg_C]
.text$mn:000042C5                 add     eax, 4
.text$mn:000042C8                 mov     [ebp+arg_C], eax
.text$mn:000042CB                 mov     ecx, [ebp+arg_0]
.text$mn:000042CE                 cmp     ecx, [ebp+arg_4]
.text$mn:000042D1                 jnz     short loc_42D5
.text$mn:000042D3                 jmp     short loc_430B
.text$mn:000042D5 ; ---------------------------------------------------------------------------
.text$mn:000042D5
.text$mn:000042D5 loc_42D5:                               ; CODE XREF: std::_Merge_backward<int *,int *,int *,BufferEquivalent>(int *,int *,int *,int *,int *,BufferEquivalent)+95j
.text$mn:000042D5                 jmp     short loc_4306
.text$mn:000042D7 ; ---------------------------------------------------------------------------
.text$mn:000042D7
.text$mn:000042D7 loc_42D7:                               ; CODE XREF: std::_Merge_backward<int *,int *,int *,BufferEquivalent>(int *,int *,int *,int *,int *,BufferEquivalent)+68j
.text$mn:000042D7                 mov     edx, [ebp+arg_10]
.text$mn:000042DA                 sub     edx, 4
.text$mn:000042DD                 mov     [ebp+arg_10], edx
.text$mn:000042E0                 mov     eax, [ebp+arg_C]
.text$mn:000042E3                 push    eax
.text$mn:000042E4                 call    ??$_Move@AAH@std@@YA$$QAHAAH@Z ; std::_Move<int &>(int &)
.text$mn:000042E9                 add     esp, 4
.text$mn:000042EC                 mov     ecx, [ebp+arg_10]
.text$mn:000042EF                 mov     edx, [eax]
.text$mn:000042F1                 mov     [ecx], edx
.text$mn:000042F3                 mov     eax, [ebp+arg_4]
.text$mn:000042F6                 add     eax, 4
.text$mn:000042F9                 mov     [ebp+arg_4], eax
.text$mn:000042FC                 mov     ecx, [ebp+Src]
.text$mn:000042FF                 cmp     ecx, [ebp+arg_C]
.text$mn:00004302                 jnz     short loc_4306
.text$mn:00004304                 jmp     short loc_430B
.text$mn:00004306 ; ---------------------------------------------------------------------------
.text$mn:00004306
.text$mn:00004306 loc_4306:                               ; CODE XREF: std::_Merge_backward<int *,int *,int *,BufferEquivalent>(int *,int *,int *,int *,int *,BufferEquivalent):loc_42D5j
.text$mn:00004306                                         ; std::_Merge_backward<int *,int *,int *,BufferEquivalent>(int *,int *,int *,int *,int *,BufferEquivalent)+C6j
.text$mn:00004306                 jmp     loc_4257
.text$mn:0000430B ; ---------------------------------------------------------------------------
.text$mn:0000430B
.text$mn:0000430B loc_430B:                               ; CODE XREF: std::_Merge_backward<int *,int *,int *,BufferEquivalent>(int *,int *,int *,int *,int *,BufferEquivalent)+9j
.text$mn:0000430B                                         ; std::_Merge_backward<int *,int *,int *,BufferEquivalent>(int *,int *,int *,int *,int *,BufferEquivalent)+15j ...
.text$mn:0000430B                 mov     edx, [ebp+arg_10]
.text$mn:0000430E                 push    edx             ; int
.text$mn:0000430F                 mov     eax, [ebp+arg_C]
.text$mn:00004312                 push    eax             ; int
.text$mn:00004313                 mov     ecx, [ebp+Src]
.text$mn:00004316                 push    ecx             ; Src
.text$mn:00004317                 call    ??$_Move_backward@PAHPAH@std@@YAPAHPAH00@Z ; std::_Move_backward<int *,int *>(int *,int *,int *)
.text$mn:0000431C                 add     esp, 0Ch
.text$mn:0000431F                 mov     [ebp+arg_10], eax
.text$mn:00004322                 mov     edx, [ebp+arg_10]
.text$mn:00004325                 push    edx             ; int
.text$mn:00004326                 mov     eax, [ebp+arg_4]
.text$mn:00004329                 push    eax             ; int
.text$mn:0000432A                 mov     ecx, [ebp+arg_0]
.text$mn:0000432D                 push    ecx             ; Src
.text$mn:0000432E                 call    ??$_Move_backward@PAHPAH@std@@YAPAHPAH00@Z ; std::_Move_backward<int *,int *>(int *,int *,int *)
.text$mn:00004333                 add     esp, 0Ch
.text$mn:00004336                 pop     ebp
.text$mn:00004337                 retn
.text$mn:00004337 ??$_Merge_backward@PAHPAHPAHUBufferEquivalent@@@std@@YAPAHPAH0000UBufferEquivalent@@@Z endp
.text$mn:00004337
.text$mn:00004337 _text$mn        ends
.text$mn:00004337
.text$mn:00004338 ; ===========================================================================
.text$mn:00004338
.text$mn:00004338 ; Segment type: Pure code
.text$mn:00004338 ; Segment permissions: Read/Execute
.text$mn:00004338 _text$mn        segment para public 'CODE' use32
.text$mn:00004338                 assume cs:_text$mn
.text$mn:00004338                 ;org 4338h
.text$mn:00004338 ; COMDAT (pick any)
.text$mn:00004338                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004338
.text$mn:00004338 ; =============== S U B R O U T I N E =======================================
.text$mn:00004338
.text$mn:00004338 ; Attributes: bp-based frame
.text$mn:00004338
.text$mn:00004338 ; int && __cdecl std::_Move<int &>(int &)
.text$mn:00004338                 public ??$_Move@AAH@std@@YA$$QAHAAH@Z
.text$mn:00004338 ??$_Move@AAH@std@@YA$$QAHAAH@Z proc near
.text$mn:00004338                                         ; CODE XREF: std::_Insertion_sort1<int *,BufferEquivalent,int>(int *,int *,BufferEquivalent,int *)+37p
.text$mn:00004338                                         ; std::_Insertion_sort1<int *,BufferEquivalent,int>(int *,int *,BufferEquivalent,int *)+A2p ...
.text$mn:00004338
.text$mn:00004338 arg_0           = dword ptr  8
.text$mn:00004338
.text$mn:00004338                 push    ebp
.text$mn:00004339                 mov     ebp, esp
.text$mn:0000433B                 mov     eax, [ebp+arg_0]
.text$mn:0000433E                 pop     ebp
.text$mn:0000433F                 retn
.text$mn:0000433F ??$_Move@AAH@std@@YA$$QAHAAH@Z endp
.text$mn:0000433F
.text$mn:0000433F _text$mn        ends
.text$mn:0000433F
.text$mn:00004340 ; ===========================================================================
.text$mn:00004340
.text$mn:00004340 ; Segment type: Pure code
.text$mn:00004340 ; Segment permissions: Read/Execute
.text$mn:00004340 _text$mn        segment para public 'CODE' use32
.text$mn:00004340                 assume cs:_text$mn
.text$mn:00004340                 ;org 4340h
.text$mn:00004340 ; COMDAT (pick any)
.text$mn:00004340                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004340
.text$mn:00004340 ; =============== S U B R O U T I N E =======================================
.text$mn:00004340
.text$mn:00004340 ; Attributes: bp-based frame
.text$mn:00004340
.text$mn:00004340 ; int __cdecl std::_Move<int *,int *>(void *Src, int, void *Dst)
.text$mn:00004340                 public ??$_Move@PAHPAH@std@@YAPAHPAH00@Z
.text$mn:00004340 ??$_Move@PAHPAH@std@@YAPAHPAH00@Z proc near
.text$mn:00004340                                         ; CODE XREF: std::_Buffered_rotate<int *,int,int>(int *,int *,int *,int,int,std::_Temp_iterator<int> &)+C3p
.text$mn:00004340                                         ; std::_Buffered_rotate<int *,int,int>(int *,int *,int *,int,int,std::_Temp_iterator<int> &)+17Ap ...
.text$mn:00004340
.text$mn:00004340 var_1           = byte ptr -1
.text$mn:00004340 Src             = dword ptr  8
.text$mn:00004340 arg_4           = dword ptr  0Ch
.text$mn:00004340 Dst             = dword ptr  10h
.text$mn:00004340
.text$mn:00004340                 push    ebp
.text$mn:00004341                 mov     ebp, esp
.text$mn:00004343                 push    ecx
.text$mn:00004344                 mov     eax, [ebp+Dst]
.text$mn:00004347                 push    eax
.text$mn:00004348                 mov     ecx, [ebp+Src]
.text$mn:0000434B                 push    ecx
.text$mn:0000434C                 call    ??$_Ptr_cat@HH@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAH0@Z ; std::_Ptr_cat<int,int>(int *,int *)
.text$mn:00004351                 add     esp, 8
.text$mn:00004354                 mov     [ebp+var_1], al
.text$mn:00004357                 movzx   edx, [ebp+var_1]
.text$mn:0000435B                 push    edx
.text$mn:0000435C                 mov     eax, [ebp+Dst]
.text$mn:0000435F                 push    eax             ; Dst
.text$mn:00004360                 mov     ecx, [ebp+arg_4]
.text$mn:00004363                 push    ecx             ; int
.text$mn:00004364                 mov     edx, [ebp+Src]
.text$mn:00004367                 push    edx             ; Src
.text$mn:00004368                 call    ??$_Move@PAHPAH@std@@YAPAHPAH00U_Scalar_ptr_iterator_tag@0@@Z ; std::_Move<int *,int *>(int *,int *,int *,std::_Scalar_ptr_iterator_tag)
.text$mn:0000436D                 add     esp, 10h
.text$mn:00004370                 mov     esp, ebp
.text$mn:00004372                 pop     ebp
.text$mn:00004373                 retn
.text$mn:00004373 ??$_Move@PAHPAH@std@@YAPAHPAH00@Z endp
.text$mn:00004373
.text$mn:00004373 _text$mn        ends
.text$mn:00004373
.text$mn:00004374 ; ===========================================================================
.text$mn:00004374
.text$mn:00004374 ; Segment type: Pure code
.text$mn:00004374 ; Segment permissions: Read/Execute
.text$mn:00004374 _text$mn        segment para public 'CODE' use32
.text$mn:00004374                 assume cs:_text$mn
.text$mn:00004374                 ;org 4374h
.text$mn:00004374 ; COMDAT (pick any)
.text$mn:00004374                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004374
.text$mn:00004374 ; =============== S U B R O U T I N E =======================================
.text$mn:00004374
.text$mn:00004374 ; Attributes: bp-based frame
.text$mn:00004374
.text$mn:00004374 ; int __cdecl std::_Move<int *,int *>(void *Src, int, void *Dst)
.text$mn:00004374                 public ??$_Move@PAHPAH@std@@YAPAHPAH00U_Scalar_ptr_iterator_tag@0@@Z
.text$mn:00004374 ??$_Move@PAHPAH@std@@YAPAHPAH00U_Scalar_ptr_iterator_tag@0@@Z proc near
.text$mn:00004374                                         ; CODE XREF: std::_Move<int *,int *>(int *,int *,int *)+28p
.text$mn:00004374
.text$mn:00004374 var_4           = dword ptr -4
.text$mn:00004374 Src             = dword ptr  8
.text$mn:00004374 arg_4           = dword ptr  0Ch
.text$mn:00004374 Dst             = dword ptr  10h
.text$mn:00004374
.text$mn:00004374                 push    ebp
.text$mn:00004375                 mov     ebp, esp
.text$mn:00004377                 push    ecx
.text$mn:00004378                 mov     eax, [ebp+arg_4]
.text$mn:0000437B                 sub     eax, [ebp+Src]
.text$mn:0000437E                 sar     eax, 2
.text$mn:00004381                 mov     [ebp+var_4], eax
.text$mn:00004384                 mov     ecx, [ebp+var_4]
.text$mn:00004387                 shl     ecx, 2
.text$mn:0000438A                 push    ecx             ; Size
.text$mn:0000438B                 mov     edx, [ebp+Src]
.text$mn:0000438E                 push    edx             ; Src
.text$mn:0000438F                 mov     eax, [ebp+Dst]
.text$mn:00004392                 push    eax             ; Dst
.text$mn:00004393                 call    _memmove
.text$mn:00004398                 add     esp, 0Ch
.text$mn:0000439B                 mov     ecx, [ebp+var_4]
.text$mn:0000439E                 mov     edx, [ebp+Dst]
.text$mn:000043A1                 lea     eax, [edx+ecx*4]
.text$mn:000043A4                 mov     esp, ebp
.text$mn:000043A6                 pop     ebp
.text$mn:000043A7                 retn
.text$mn:000043A7 ??$_Move@PAHPAH@std@@YAPAHPAH00U_Scalar_ptr_iterator_tag@0@@Z endp
.text$mn:000043A7
.text$mn:000043A7 _text$mn        ends
.text$mn:000043A7
.text$mn:000043A8 ; ===========================================================================
.text$mn:000043A8
.text$mn:000043A8 ; Segment type: Pure code
.text$mn:000043A8 ; Segment permissions: Read/Execute
.text$mn:000043A8 _text$mn        segment para public 'CODE' use32
.text$mn:000043A8                 assume cs:_text$mn
.text$mn:000043A8                 ;org 43A8h
.text$mn:000043A8 ; COMDAT (pick any)
.text$mn:000043A8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000043A8
.text$mn:000043A8 ; =============== S U B R O U T I N E =======================================
.text$mn:000043A8
.text$mn:000043A8 ; Attributes: bp-based frame
.text$mn:000043A8
.text$mn:000043A8 ; class std::_Temp_iterator<int> __cdecl std::_Move<int *, class std::_Temp_iterator<int>>(int *, int *, class std::_Temp_iterator<int>)
.text$mn:000043A8                 public ??$_Move@PAHV?$_Temp_iterator@H@std@@@std@@YA?AV?$_Temp_iterator@H@0@PAH0V10@@Z
.text$mn:000043A8 ??$_Move@PAHV?$_Temp_iterator@H@std@@@std@@YA?AV?$_Temp_iterator@H@0@PAH0V10@@Z proc near
.text$mn:000043A8                                         ; CODE XREF: std::_Buffered_merge<int *,int,int,BufferEquivalent>(int *,int *,int *,int,int,std::_Temp_iterator<int> &,BufferEquivalent)+E9p
.text$mn:000043A8                                         ; std::_Buffered_merge<int *,int,int,BufferEquivalent>(int *,int *,int *,int,int,std::_Temp_iterator<int> &,BufferEquivalent)+18Dp ...
.text$mn:000043A8
.text$mn:000043A8 var_24          = dword ptr -24h
.text$mn:000043A8 var_20          = dword ptr -20h
.text$mn:000043A8 var_1C          = dword ptr -1Ch
.text$mn:000043A8 var_18          = dword ptr -18h
.text$mn:000043A8 var_14          = dword ptr -14h
.text$mn:000043A8 var_D           = byte ptr -0Dh
.text$mn:000043A8 var_C           = dword ptr -0Ch
.text$mn:000043A8 var_4           = dword ptr -4
.text$mn:000043A8 arg_0           = dword ptr  8
.text$mn:000043A8 arg_4           = dword ptr  0Ch
.text$mn:000043A8 arg_8           = dword ptr  10h
.text$mn:000043A8 arg_C           = byte ptr  14h
.text$mn:000043A8
.text$mn:000043A8                 push    ebp
.text$mn:000043A9                 mov     ebp, esp
.text$mn:000043AB                 push    0FFFFFFFFh
.text$mn:000043AD                 push    offset __ehhandler$??$_Move@PAHV?$_Temp_iterator@H@std@@@std@@YA?AV?$_Temp_iterator@H@0@PAH0V10@@Z
.text$mn:000043B2                 mov     eax, large fs:0
.text$mn:000043B8                 push    eax
.text$mn:000043B9                 sub     esp, 18h
.text$mn:000043BC                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000043C1                 xor     eax, ebp
.text$mn:000043C3                 push    eax
.text$mn:000043C4                 lea     eax, [ebp+var_C]
.text$mn:000043C7                 mov     large fs:0, eax
.text$mn:000043CD                 mov     [ebp+var_14], 0
.text$mn:000043D4                 mov     [ebp+var_4], 1
.text$mn:000043DB                 lea     eax, [ebp+arg_C]
.text$mn:000043DE                 push    eax
.text$mn:000043DF                 lea     ecx, [ebp+arg_4]
.text$mn:000043E2                 push    ecx
.text$mn:000043E3                 call    ??$_Ptr_cat@PAHV?$_Temp_iterator@H@std@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAHAAV?$_Temp_iterator@H@0@@Z ; std::_Ptr_cat<int *,std::_Temp_iterator<int>>(int * &,std::_Temp_iterator<int> &)
.text$mn:000043E8                 add     esp, 8
.text$mn:000043EB                 mov     [ebp+var_D], al
.text$mn:000043EE                 movzx   edx, [ebp+var_D]
.text$mn:000043F2                 push    edx
.text$mn:000043F3                 sub     esp, 14h
.text$mn:000043F6                 mov     ecx, esp
.text$mn:000043F8                 mov     [ebp+var_1C], esp
.text$mn:000043FB                 lea     eax, [ebp+arg_C]
.text$mn:000043FE                 push    eax
.text$mn:000043FF                 call    ??0?$_Temp_iterator@H@std@@QAE@ABV01@@Z ; std::_Temp_iterator<int>::_Temp_iterator<int>(std::_Temp_iterator<int> const &)
.text$mn:00004404                 mov     [ebp+var_18], eax
.text$mn:00004407                 mov     ecx, [ebp+var_18]
.text$mn:0000440A                 mov     [ebp+var_20], ecx
.text$mn:0000440D                 mov     byte ptr [ebp+var_4], 2
.text$mn:00004411                 mov     edx, [ebp+arg_8]
.text$mn:00004414                 push    edx
.text$mn:00004415                 mov     eax, [ebp+arg_4]
.text$mn:00004418                 push    eax
.text$mn:00004419                 mov     ecx, [ebp+arg_0]
.text$mn:0000441C                 push    ecx
.text$mn:0000441D                 mov     byte ptr [ebp+var_4], 1
.text$mn:00004421                 call    ??$_Move@PAHV?$_Temp_iterator@H@std@@@std@@YA?AV?$_Temp_iterator@H@0@PAH0V10@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move<int *,std::_Temp_iterator<int>>(int *,int *,std::_Temp_iterator<int>,std::_Nonscalar_ptr_iterator_tag)
.text$mn:00004426                 add     esp, 24h
.text$mn:00004429                 mov     [ebp+var_24], eax
.text$mn:0000442C                 mov     edx, [ebp+var_14]
.text$mn:0000442F                 or      edx, 1
.text$mn:00004432                 mov     [ebp+var_14], edx
.text$mn:00004435                 mov     byte ptr [ebp+var_4], 0
.text$mn:00004439                 lea     ecx, [ebp+arg_C]
.text$mn:0000443C                 call    ??1?$_Temp_iterator@H@std@@QAE@XZ ; std::_Temp_iterator<int>::~_Temp_iterator<int>(void)
.text$mn:00004441                 mov     eax, [ebp+arg_0]
.text$mn:00004444                 mov     ecx, [ebp+var_C]
.text$mn:00004447                 mov     large fs:0, ecx
.text$mn:0000444E                 pop     ecx
.text$mn:0000444F                 mov     esp, ebp
.text$mn:00004451                 pop     ebp
.text$mn:00004452                 retn
.text$mn:00004452 ??$_Move@PAHV?$_Temp_iterator@H@std@@@std@@YA?AV?$_Temp_iterator@H@0@PAH0V10@@Z endp
.text$mn:00004452
.text$mn:00004452 ; ---------------------------------------------------------------------------
.text$mn:00004453                 align 4
.text$mn:00004453 _text$mn        ends
.text$mn:00004453
.text$x:00004454 ; ===========================================================================
.text$x:00004454
.text$x:00004454 ; Segment type: Pure code
.text$x:00004454 ; Segment permissions: Read/Execute
.text$x:00004454 _text$x         segment para public 'CODE' use32
.text$x:00004454                 assume cs:_text$x
.text$x:00004454                 ;org 4454h
.text$x:00004454 ; COMDAT (pick associative to section at 43A8)
.text$x:00004454                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00004454
.text$x:00004454 ; =============== S U B R O U T I N E =======================================
.text$x:00004454
.text$x:00004454
.text$x:00004454 __unwindfunclet$??$_Move@PAHV?$_Temp_iterator@H@std@@@std@@YA?AV?$_Temp_iterator@H@0@PAH0V10@@Z$0 proc near
.text$x:00004454                                         ; DATA XREF: .xdata$x:0000DA8Co
.text$x:00004454                 lea     ecx, [ebp+14h]
.text$x:00004457                 jmp     ??1?$_Temp_iterator@H@std@@QAE@XZ ; std::_Temp_iterator<int>::~_Temp_iterator<int>(void)
.text$x:00004457 __unwindfunclet$??$_Move@PAHV?$_Temp_iterator@H@std@@@std@@YA?AV?$_Temp_iterator@H@0@PAH0V10@@Z$0 endp
.text$x:00004457
.text$x:0000445C
.text$x:0000445C ; =============== S U B R O U T I N E =======================================
.text$x:0000445C
.text$x:0000445C
.text$x:0000445C __unwindfunclet$??$_Move@PAHV?$_Temp_iterator@H@std@@@std@@YA?AV?$_Temp_iterator@H@0@PAH0V10@@Z$1 proc near
.text$x:0000445C                                         ; DATA XREF: .xdata$x:0000DA94o
.text$x:0000445C                 mov     ecx, [ebp-1Ch]
.text$x:0000445F                 jmp     ??1?$_Temp_iterator@H@std@@QAE@XZ ; std::_Temp_iterator<int>::~_Temp_iterator<int>(void)
.text$x:0000445F __unwindfunclet$??$_Move@PAHV?$_Temp_iterator@H@std@@@std@@YA?AV?$_Temp_iterator@H@0@PAH0V10@@Z$1 endp
.text$x:0000445F
.text$x:00004464
.text$x:00004464 ; =============== S U B R O U T I N E =======================================
.text$x:00004464
.text$x:00004464
.text$x:00004464 __unwindfunclet$??$_Move@PAHV?$_Temp_iterator@H@std@@@std@@YA?AV?$_Temp_iterator@H@0@PAH0V10@@Z$2 proc near
.text$x:00004464                                         ; DATA XREF: .xdata$x:0000DA84o
.text$x:00004464                 mov     eax, [ebp-14h]
.text$x:00004467                 and     eax, 1
.text$x:0000446A                 jz      $LN6_2
.text$x:00004470                 and     dword ptr [ebp-14h], 0FFFFFFFEh
.text$x:00004474                 mov     ecx, [ebp+8]
.text$x:00004477                 jmp     ??1?$_Temp_iterator@H@std@@QAE@XZ ; std::_Temp_iterator<int>::~_Temp_iterator<int>(void)
.text$x:0000447C ; ---------------------------------------------------------------------------
.text$x:0000447C
.text$x:0000447C $LN6_2:                                 ; CODE XREF: __unwindfunclet$??$_Move@PAHV?$_Temp_iterator@H@std@@@std@@YA?AV?$_Temp_iterator@H@0@PAH0V10@@Z$2+6j
.text$x:0000447C                 retn
.text$x:0000447C __unwindfunclet$??$_Move@PAHV?$_Temp_iterator@H@std@@@std@@YA?AV?$_Temp_iterator@H@0@PAH0V10@@Z$2 endp
.text$x:0000447C
.text$x:0000447D
.text$x:0000447D ; =============== S U B R O U T I N E =======================================
.text$x:0000447D
.text$x:0000447D
.text$x:0000447D __ehhandler$??$_Move@PAHV?$_Temp_iterator@H@std@@@std@@YA?AV?$_Temp_iterator@H@0@PAH0V10@@Z proc near
.text$x:0000447D                                         ; DATA XREF: std::_Move<int *,std::_Temp_iterator<int>>(int *,int *,std::_Temp_iterator<int>)+5o
.text$x:0000447D
.text$x:0000447D arg_4           = dword ptr  8
.text$x:0000447D
.text$x:0000447D                 mov     edx, [esp+arg_4]
.text$x:00004481                 lea     eax, [edx+0Ch]
.text$x:00004484                 mov     ecx, [edx-1Ch]
.text$x:00004487                 xor     ecx, eax
.text$x:00004489                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000448E                 mov     eax, offset __ehfuncinfo$??$_Move@PAHV?$_Temp_iterator@H@std@@@std@@YA?AV?$_Temp_iterator@H@0@PAH0V10@@Z
.text$x:00004493                 jmp     ___CxxFrameHandler3
.text$x:00004493 __ehhandler$??$_Move@PAHV?$_Temp_iterator@H@std@@@std@@YA?AV?$_Temp_iterator@H@0@PAH0V10@@Z endp
.text$x:00004493
.text$x:00004493 _text$x         ends
.text$x:00004493
.text$mn:00004498 ; ===========================================================================
.text$mn:00004498
.text$mn:00004498 ; Segment type: Pure code
.text$mn:00004498 ; Segment permissions: Read/Execute
.text$mn:00004498 _text$mn        segment para public 'CODE' use32
.text$mn:00004498                 assume cs:_text$mn
.text$mn:00004498                 ;org 4498h
.text$mn:00004498 ; COMDAT (pick any)
.text$mn:00004498                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004498
.text$mn:00004498 ; =============== S U B R O U T I N E =======================================
.text$mn:00004498
.text$mn:00004498 ; Attributes: bp-based frame
.text$mn:00004498
.text$mn:00004498 ; class std::_Temp_iterator<int> __cdecl std::_Move<int *, class std::_Temp_iterator<int>>(int *, int *, class std::_Temp_iterator<int>, struct std::_Nonscalar_ptr_iterator_tag)
.text$mn:00004498                 public ??$_Move@PAHV?$_Temp_iterator@H@std@@@std@@YA?AV?$_Temp_iterator@H@0@PAH0V10@U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00004498 ??$_Move@PAHV?$_Temp_iterator@H@std@@@std@@YA?AV?$_Temp_iterator@H@0@PAH0V10@U_Nonscalar_ptr_iterator_tag@0@@Z proc near
.text$mn:00004498                                         ; CODE XREF: std::_Move<int *,std::_Temp_iterator<int>>(int *,int *,std::_Temp_iterator<int>)+79p
.text$mn:00004498
.text$mn:00004498 var_10          = dword ptr -10h
.text$mn:00004498 var_C           = dword ptr -0Ch
.text$mn:00004498 var_4           = dword ptr -4
.text$mn:00004498 arg_0           = dword ptr  8
.text$mn:00004498 arg_4           = dword ptr  0Ch
.text$mn:00004498 arg_8           = dword ptr  10h
.text$mn:00004498 arg_C           = byte ptr  14h
.text$mn:00004498
.text$mn:00004498                 push    ebp
.text$mn:00004499                 mov     ebp, esp
.text$mn:0000449B                 push    0FFFFFFFFh
.text$mn:0000449D                 push    offset __ehhandler$??$_Move@PAHV?$_Temp_iterator@H@std@@@std@@YA?AV?$_Temp_iterator@H@0@PAH0V10@U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:000044A2                 mov     eax, large fs:0
.text$mn:000044A8                 push    eax
.text$mn:000044A9                 push    ecx
.text$mn:000044AA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000044AF                 xor     eax, ebp
.text$mn:000044B1                 push    eax
.text$mn:000044B2                 lea     eax, [ebp+var_C]
.text$mn:000044B5                 mov     large fs:0, eax
.text$mn:000044BB                 mov     [ebp+var_10], 0
.text$mn:000044C2                 mov     [ebp+var_4], 1
.text$mn:000044C9                 jmp     short loc_44DC
.text$mn:000044CB ; ---------------------------------------------------------------------------
.text$mn:000044CB
.text$mn:000044CB loc_44CB:                               ; CODE XREF: std::_Move<int *,std::_Temp_iterator<int>>(int *,int *,std::_Temp_iterator<int>,std::_Nonscalar_ptr_iterator_tag)+68j
.text$mn:000044CB                 lea     ecx, [ebp+arg_C]
.text$mn:000044CE                 call    ??E?$_Temp_iterator@H@std@@QAEAAV01@XZ ; std::_Temp_iterator<int>::operator++(void)
.text$mn:000044D3                 mov     eax, [ebp+arg_4]
.text$mn:000044D6                 add     eax, 4
.text$mn:000044D9                 mov     [ebp+arg_4], eax
.text$mn:000044DC
.text$mn:000044DC loc_44DC:                               ; CODE XREF: std::_Move<int *,std::_Temp_iterator<int>>(int *,int *,std::_Temp_iterator<int>,std::_Nonscalar_ptr_iterator_tag)+31j
.text$mn:000044DC                 mov     ecx, [ebp+arg_4]
.text$mn:000044DF                 cmp     ecx, [ebp+arg_8]
.text$mn:000044E2                 jz      short loc_4502
.text$mn:000044E4                 mov     edx, [ebp+arg_4]
.text$mn:000044E7                 push    edx
.text$mn:000044E8                 call    ??$move@AAH@std@@YA$$QAHAAH@Z ; std::move<int &>(int &)
.text$mn:000044ED                 add     esp, 4
.text$mn:000044F0                 push    eax
.text$mn:000044F1                 lea     ecx, [ebp+arg_C]
.text$mn:000044F4                 call    ??D?$_Temp_iterator@H@std@@QAEAAV01@XZ ; std::_Temp_iterator<int>::operator*(void)
.text$mn:000044F9                 mov     ecx, eax
.text$mn:000044FB                 call    ??4?$_Temp_iterator@H@std@@QAEAAV01@$$QAH@Z ; std::_Temp_iterator<int>::operator=(int &&)
.text$mn:00004500                 jmp     short loc_44CB
.text$mn:00004502 ; ---------------------------------------------------------------------------
.text$mn:00004502
.text$mn:00004502 loc_4502:                               ; CODE XREF: std::_Move<int *,std::_Temp_iterator<int>>(int *,int *,std::_Temp_iterator<int>,std::_Nonscalar_ptr_iterator_tag)+4Aj
.text$mn:00004502                 lea     eax, [ebp+arg_C]
.text$mn:00004505                 push    eax
.text$mn:00004506                 mov     ecx, [ebp+arg_0]
.text$mn:00004509                 call    ??0?$_Temp_iterator@H@std@@QAE@ABV01@@Z ; std::_Temp_iterator<int>::_Temp_iterator<int>(std::_Temp_iterator<int> const &)
.text$mn:0000450E                 mov     ecx, [ebp+var_10]
.text$mn:00004511                 or      ecx, 1
.text$mn:00004514                 mov     [ebp+var_10], ecx
.text$mn:00004517                 mov     byte ptr [ebp+var_4], 0
.text$mn:0000451B                 lea     ecx, [ebp+arg_C]
.text$mn:0000451E                 call    ??1?$_Temp_iterator@H@std@@QAE@XZ ; std::_Temp_iterator<int>::~_Temp_iterator<int>(void)
.text$mn:00004523                 mov     eax, [ebp+arg_0]
.text$mn:00004526                 mov     ecx, [ebp+var_C]
.text$mn:00004529                 mov     large fs:0, ecx
.text$mn:00004530                 pop     ecx
.text$mn:00004531                 mov     esp, ebp
.text$mn:00004533                 pop     ebp
.text$mn:00004534                 retn
.text$mn:00004534 ??$_Move@PAHV?$_Temp_iterator@H@std@@@std@@YA?AV?$_Temp_iterator@H@0@PAH0V10@U_Nonscalar_ptr_iterator_tag@0@@Z endp
.text$mn:00004534
.text$mn:00004534 ; ---------------------------------------------------------------------------
.text$mn:00004535                 align 4
.text$mn:00004535 _text$mn        ends
.text$mn:00004535
.text$x:00004538 ; ===========================================================================
.text$x:00004538
.text$x:00004538 ; Segment type: Pure code
.text$x:00004538 ; Segment permissions: Read/Execute
.text$x:00004538 _text$x         segment para public 'CODE' use32
.text$x:00004538                 assume cs:_text$x
.text$x:00004538                 ;org 4538h
.text$x:00004538 ; COMDAT (pick associative to section at 4498)
.text$x:00004538                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00004538
.text$x:00004538 ; =============== S U B R O U T I N E =======================================
.text$x:00004538
.text$x:00004538
.text$x:00004538 __unwindfunclet$??$_Move@PAHV?$_Temp_iterator@H@std@@@std@@YA?AV?$_Temp_iterator@H@0@PAH0V10@U_Nonscalar_ptr_iterator_tag@0@@Z$0 proc near
.text$x:00004538                                         ; DATA XREF: .xdata$x:0000DBC0o
.text$x:00004538                 lea     ecx, [ebp+14h]
.text$x:0000453B                 jmp     ??1?$_Temp_iterator@H@std@@QAE@XZ ; std::_Temp_iterator<int>::~_Temp_iterator<int>(void)
.text$x:0000453B __unwindfunclet$??$_Move@PAHV?$_Temp_iterator@H@std@@@std@@YA?AV?$_Temp_iterator@H@0@PAH0V10@U_Nonscalar_ptr_iterator_tag@0@@Z$0 endp
.text$x:0000453B
.text$x:00004540
.text$x:00004540 ; =============== S U B R O U T I N E =======================================
.text$x:00004540
.text$x:00004540
.text$x:00004540 __unwindfunclet$??$_Move@PAHV?$_Temp_iterator@H@std@@@std@@YA?AV?$_Temp_iterator@H@0@PAH0V10@U_Nonscalar_ptr_iterator_tag@0@@Z$1 proc near
.text$x:00004540                                         ; DATA XREF: .xdata$x:0000DBB8o
.text$x:00004540                 mov     eax, [ebp-10h]
.text$x:00004543                 and     eax, 1
.text$x:00004546                 jz      $LN8_1
.text$x:0000454C                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:00004550                 mov     ecx, [ebp+8]
.text$x:00004553                 jmp     ??1?$_Temp_iterator@H@std@@QAE@XZ ; std::_Temp_iterator<int>::~_Temp_iterator<int>(void)
.text$x:00004558 ; ---------------------------------------------------------------------------
.text$x:00004558
.text$x:00004558 $LN8_1:                                 ; CODE XREF: __unwindfunclet$??$_Move@PAHV?$_Temp_iterator@H@std@@@std@@YA?AV?$_Temp_iterator@H@0@PAH0V10@U_Nonscalar_ptr_iterator_tag@0@@Z$1+6j
.text$x:00004558                 retn
.text$x:00004558 __unwindfunclet$??$_Move@PAHV?$_Temp_iterator@H@std@@@std@@YA?AV?$_Temp_iterator@H@0@PAH0V10@U_Nonscalar_ptr_iterator_tag@0@@Z$1 endp
.text$x:00004558
.text$x:00004559
.text$x:00004559 ; =============== S U B R O U T I N E =======================================
.text$x:00004559
.text$x:00004559
.text$x:00004559 __ehhandler$??$_Move@PAHV?$_Temp_iterator@H@std@@@std@@YA?AV?$_Temp_iterator@H@0@PAH0V10@U_Nonscalar_ptr_iterator_tag@0@@Z proc near
.text$x:00004559                                         ; DATA XREF: std::_Move<int *,std::_Temp_iterator<int>>(int *,int *,std::_Temp_iterator<int>,std::_Nonscalar_ptr_iterator_tag)+5o
.text$x:00004559
.text$x:00004559 arg_4           = dword ptr  8
.text$x:00004559
.text$x:00004559                 mov     edx, [esp+arg_4]
.text$x:0000455D                 lea     eax, [edx+0Ch]
.text$x:00004560                 mov     ecx, [edx-8]
.text$x:00004563                 xor     ecx, eax
.text$x:00004565                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000456A                 mov     eax, offset __ehfuncinfo$??$_Move@PAHV?$_Temp_iterator@H@std@@@std@@YA?AV?$_Temp_iterator@H@0@PAH0V10@U_Nonscalar_ptr_iterator_tag@0@@Z
.text$x:0000456F                 jmp     ___CxxFrameHandler3
.text$x:0000456F __ehhandler$??$_Move@PAHV?$_Temp_iterator@H@std@@@std@@YA?AV?$_Temp_iterator@H@0@PAH0V10@U_Nonscalar_ptr_iterator_tag@0@@Z endp
.text$x:0000456F
.text$x:0000456F _text$x         ends
.text$x:0000456F
.text$mn:00004574 ; ===========================================================================
.text$mn:00004574
.text$mn:00004574 ; Segment type: Pure code
.text$mn:00004574 ; Segment permissions: Read/Execute
.text$mn:00004574 _text$mn        segment para public 'CODE' use32
.text$mn:00004574                 assume cs:_text$mn
.text$mn:00004574                 ;org 4574h
.text$mn:00004574 ; COMDAT (pick any)
.text$mn:00004574                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004574
.text$mn:00004574 ; =============== S U B R O U T I N E =======================================
.text$mn:00004574
.text$mn:00004574 ; Attributes: bp-based frame
.text$mn:00004574
.text$mn:00004574 ; int __cdecl std::_Move_backward<int *,int *>(void *Src, int, int)
.text$mn:00004574                 public ??$_Move_backward@PAHPAH@std@@YAPAHPAH00@Z
.text$mn:00004574 ??$_Move_backward@PAHPAH@std@@YAPAHPAH00@Z proc near
.text$mn:00004574                                         ; CODE XREF: std::_Buffered_rotate<int *,int,int>(int *,int *,int *,int,int,std::_Temp_iterator<int> &)+E1p
.text$mn:00004574                                         ; std::_Buffered_rotate<int *,int,int>(int *,int *,int *,int,int,std::_Temp_iterator<int> &)+15Cp ...
.text$mn:00004574
.text$mn:00004574 var_1           = byte ptr -1
.text$mn:00004574 Src             = dword ptr  8
.text$mn:00004574 arg_4           = dword ptr  0Ch
.text$mn:00004574 arg_8           = dword ptr  10h
.text$mn:00004574
.text$mn:00004574                 push    ebp
.text$mn:00004575                 mov     ebp, esp
.text$mn:00004577                 push    ecx
.text$mn:00004578                 mov     eax, [ebp+arg_8]
.text$mn:0000457B                 push    eax
.text$mn:0000457C                 mov     ecx, [ebp+Src]
.text$mn:0000457F                 push    ecx
.text$mn:00004580                 call    ??$_Ptr_cat@HH@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAH0@Z ; std::_Ptr_cat<int,int>(int *,int *)
.text$mn:00004585                 add     esp, 8
.text$mn:00004588                 mov     [ebp+var_1], al
.text$mn:0000458B                 movzx   edx, [ebp+var_1]
.text$mn:0000458F                 push    edx
.text$mn:00004590                 mov     eax, [ebp+arg_8]
.text$mn:00004593                 push    eax             ; int
.text$mn:00004594                 mov     ecx, [ebp+arg_4]
.text$mn:00004597                 push    ecx             ; int
.text$mn:00004598                 mov     edx, [ebp+Src]
.text$mn:0000459B                 push    edx             ; Src
.text$mn:0000459C                 call    ??$_Move_backward@PAHPAH@std@@YAPAHPAH00U_Scalar_ptr_iterator_tag@0@@Z ; std::_Move_backward<int *,int *>(int *,int *,int *,std::_Scalar_ptr_iterator_tag)
.text$mn:000045A1                 add     esp, 10h
.text$mn:000045A4                 mov     esp, ebp
.text$mn:000045A6                 pop     ebp
.text$mn:000045A7                 retn
.text$mn:000045A7 ??$_Move_backward@PAHPAH@std@@YAPAHPAH00@Z endp
.text$mn:000045A7
.text$mn:000045A7 _text$mn        ends
.text$mn:000045A7
.text$mn:000045A8 ; ===========================================================================
.text$mn:000045A8
.text$mn:000045A8 ; Segment type: Pure code
.text$mn:000045A8 ; Segment permissions: Read/Execute
.text$mn:000045A8 _text$mn        segment para public 'CODE' use32
.text$mn:000045A8                 assume cs:_text$mn
.text$mn:000045A8                 ;org 45A8h
.text$mn:000045A8 ; COMDAT (pick any)
.text$mn:000045A8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000045A8
.text$mn:000045A8 ; =============== S U B R O U T I N E =======================================
.text$mn:000045A8
.text$mn:000045A8 ; Attributes: bp-based frame
.text$mn:000045A8
.text$mn:000045A8 ; int __cdecl std::_Move_backward<int *,int *>(void *Src, int, int)
.text$mn:000045A8                 public ??$_Move_backward@PAHPAH@std@@YAPAHPAH00U_Scalar_ptr_iterator_tag@0@@Z
.text$mn:000045A8 ??$_Move_backward@PAHPAH@std@@YAPAHPAH00U_Scalar_ptr_iterator_tag@0@@Z proc near
.text$mn:000045A8                                         ; CODE XREF: std::_Move_backward<int *,int *>(int *,int *,int *)+28p
.text$mn:000045A8
.text$mn:000045A8 var_4           = dword ptr -4
.text$mn:000045A8 Src             = dword ptr  8
.text$mn:000045A8 arg_4           = dword ptr  0Ch
.text$mn:000045A8 arg_8           = dword ptr  10h
.text$mn:000045A8
.text$mn:000045A8                 push    ebp
.text$mn:000045A9                 mov     ebp, esp
.text$mn:000045AB                 push    ecx
.text$mn:000045AC                 mov     eax, [ebp+arg_4]
.text$mn:000045AF                 sub     eax, [ebp+Src]
.text$mn:000045B2                 sar     eax, 2
.text$mn:000045B5                 mov     [ebp+var_4], eax
.text$mn:000045B8                 mov     ecx, [ebp+var_4]
.text$mn:000045BB                 shl     ecx, 2
.text$mn:000045BE                 push    ecx             ; Size
.text$mn:000045BF                 mov     edx, [ebp+Src]
.text$mn:000045C2                 push    edx             ; Src
.text$mn:000045C3                 mov     eax, [ebp+var_4]
.text$mn:000045C6                 shl     eax, 2
.text$mn:000045C9                 mov     ecx, [ebp+arg_8]
.text$mn:000045CC                 sub     ecx, eax
.text$mn:000045CE                 push    ecx             ; Dst
.text$mn:000045CF                 call    _memmove
.text$mn:000045D4                 add     esp, 0Ch
.text$mn:000045D7                 mov     edx, [ebp+var_4]
.text$mn:000045DA                 shl     edx, 2
.text$mn:000045DD                 mov     eax, [ebp+arg_8]
.text$mn:000045E0                 sub     eax, edx
.text$mn:000045E2                 mov     esp, ebp
.text$mn:000045E4                 pop     ebp
.text$mn:000045E5                 retn
.text$mn:000045E5 ??$_Move_backward@PAHPAH@std@@YAPAHPAH00U_Scalar_ptr_iterator_tag@0@@Z endp
.text$mn:000045E5
.text$mn:000045E5 ; ---------------------------------------------------------------------------
.text$mn:000045E6                 align 4
.text$mn:000045E6 _text$mn        ends
.text$mn:000045E6
.text$mn:000045E8 ; ===========================================================================
.text$mn:000045E8
.text$mn:000045E8 ; Segment type: Pure code
.text$mn:000045E8 ; Segment permissions: Read/Execute
.text$mn:000045E8 _text$mn        segment para public 'CODE' use32
.text$mn:000045E8                 assume cs:_text$mn
.text$mn:000045E8                 ;org 45E8h
.text$mn:000045E8 ; COMDAT (pick any)
.text$mn:000045E8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000045E8
.text$mn:000045E8 ; =============== S U B R O U T I N E =======================================
.text$mn:000045E8
.text$mn:000045E8 ; Attributes: bp-based frame
.text$mn:000045E8
.text$mn:000045E8 ; struct std::_Scalar_ptr_iterator_tag __cdecl std::_Ptr_cat<int, int>(int *, int *)
.text$mn:000045E8                 public ??$_Ptr_cat@HH@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAH0@Z
.text$mn:000045E8 ??$_Ptr_cat@HH@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAH0@Z proc near
.text$mn:000045E8                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<int>>>(int *,int *,std::_Wrap_alloc<std::allocator<int>> &)+Cp
.text$mn:000045E8                                         ; std::_Move<int *,int *>(int *,int *,int *)+Cp ...
.text$mn:000045E8
.text$mn:000045E8 var_1           = byte ptr -1
.text$mn:000045E8
.text$mn:000045E8                 push    ebp
.text$mn:000045E9                 mov     ebp, esp
.text$mn:000045EB                 push    ecx
.text$mn:000045EC                 mov     al, [ebp+var_1]
.text$mn:000045EF                 mov     esp, ebp
.text$mn:000045F1                 pop     ebp
.text$mn:000045F2                 retn
.text$mn:000045F2 ??$_Ptr_cat@HH@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAH0@Z endp
.text$mn:000045F2
.text$mn:000045F2 ; ---------------------------------------------------------------------------
.text$mn:000045F3                 align 4
.text$mn:000045F3 _text$mn        ends
.text$mn:000045F3
.text$mn:000045F4 ; ===========================================================================
.text$mn:000045F4
.text$mn:000045F4 ; Segment type: Pure code
.text$mn:000045F4 ; Segment permissions: Read/Execute
.text$mn:000045F4 _text$mn        segment para public 'CODE' use32
.text$mn:000045F4                 assume cs:_text$mn
.text$mn:000045F4                 ;org 45F4h
.text$mn:000045F4 ; COMDAT (pick any)
.text$mn:000045F4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000045F4
.text$mn:000045F4 ; =============== S U B R O U T I N E =======================================
.text$mn:000045F4
.text$mn:000045F4 ; Attributes: bp-based frame
.text$mn:000045F4
.text$mn:000045F4 ; struct std::_Nonscalar_ptr_iterator_tag __cdecl std::_Ptr_cat<int *, class std::_Temp_iterator<int>>(int * &, class std::_Temp_iterator<int> &)
.text$mn:000045F4                 public ??$_Ptr_cat@PAHV?$_Temp_iterator@H@std@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAHAAV?$_Temp_iterator@H@0@@Z
.text$mn:000045F4 ??$_Ptr_cat@PAHV?$_Temp_iterator@H@std@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAHAAV?$_Temp_iterator@H@0@@Z proc near
.text$mn:000045F4                                         ; CODE XREF: std::_Move<int *,std::_Temp_iterator<int>>(int *,int *,std::_Temp_iterator<int>)+3Bp
.text$mn:000045F4
.text$mn:000045F4 var_1           = byte ptr -1
.text$mn:000045F4
.text$mn:000045F4                 push    ebp
.text$mn:000045F5                 mov     ebp, esp
.text$mn:000045F7                 push    ecx
.text$mn:000045F8                 mov     al, [ebp+var_1]
.text$mn:000045FB                 mov     esp, ebp
.text$mn:000045FD                 pop     ebp
.text$mn:000045FE                 retn
.text$mn:000045FE ??$_Ptr_cat@PAHV?$_Temp_iterator@H@std@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAHAAV?$_Temp_iterator@H@0@@Z endp
.text$mn:000045FE
.text$mn:000045FE ; ---------------------------------------------------------------------------
.text$mn:000045FF                 align 10h
.text$mn:000045FF _text$mn        ends
.text$mn:000045FF
.text$mn:00004600 ; ===========================================================================
.text$mn:00004600
.text$mn:00004600 ; Segment type: Pure code
.text$mn:00004600 ; Segment permissions: Read/Execute
.text$mn:00004600 _text$mn        segment para public 'CODE' use32
.text$mn:00004600                 assume cs:_text$mn
.text$mn:00004600                 ;org 4600h
.text$mn:00004600 ; COMDAT (pick any)
.text$mn:00004600                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004600
.text$mn:00004600 ; =============== S U B R O U T I N E =======================================
.text$mn:00004600
.text$mn:00004600 ; Attributes: bp-based frame
.text$mn:00004600
.text$mn:00004600 ; struct std::_Scalar_ptr_iterator_tag __cdecl std::_Ptr_cat<wchar_t, wchar_t>(wchar_t *, wchar_t *)
.text$mn:00004600                 public ??$_Ptr_cat@_W_W@std@@YA?AU_Scalar_ptr_iterator_tag@0@PA_W0@Z
.text$mn:00004600 ??$_Ptr_cat@_W_W@std@@YA?AU_Scalar_ptr_iterator_tag@0@PA_W0@Z proc near
.text$mn:00004600                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<wchar_t>>>(wchar_t *,wchar_t *,std::_Wrap_alloc<std::allocator<wchar_t>> &)+Cp
.text$mn:00004600                                         ; std::_Uninit_copy<wchar_t *,wchar_t *,std::_Wrap_alloc<std::allocator<wchar_t>>>(wchar_t *,wchar_t *,wchar_t *,std::_Wrap_alloc<std::allocator<wchar_t>> &)+Cp ...
.text$mn:00004600
.text$mn:00004600 var_1           = byte ptr -1
.text$mn:00004600
.text$mn:00004600                 push    ebp
.text$mn:00004601                 mov     ebp, esp
.text$mn:00004603                 push    ecx
.text$mn:00004604                 mov     al, [ebp+var_1]
.text$mn:00004607                 mov     esp, ebp
.text$mn:00004609                 pop     ebp
.text$mn:0000460A                 retn
.text$mn:0000460A ??$_Ptr_cat@_W_W@std@@YA?AU_Scalar_ptr_iterator_tag@0@PA_W0@Z endp
.text$mn:0000460A
.text$mn:0000460A ; ---------------------------------------------------------------------------
.text$mn:0000460B                 align 4
.text$mn:0000460B _text$mn        ends
.text$mn:0000460B
.text$mn:0000460C ; ===========================================================================
.text$mn:0000460C
.text$mn:0000460C ; Segment type: Pure code
.text$mn:0000460C ; Segment permissions: Read/Execute
.text$mn:0000460C _text$mn        segment para public 'CODE' use32
.text$mn:0000460C                 assume cs:_text$mn
.text$mn:0000460C                 ;org 460Ch
.text$mn:0000460C ; COMDAT (pick any)
.text$mn:0000460C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000460C
.text$mn:0000460C ; =============== S U B R O U T I N E =======================================
.text$mn:0000460C
.text$mn:0000460C ; Attributes: bp-based frame
.text$mn:0000460C
.text$mn:0000460C ; int * & __cdecl std::_Rechecked<int *, int *>(int * &, int *)
.text$mn:0000460C                 public ??$_Rechecked@PAHPAH@std@@YAAAPAHAAPAHPAH@Z
.text$mn:0000460C ??$_Rechecked@PAHPAH@std@@YAAAPAHAAPAHPAH@Z proc near
.text$mn:0000460C                                         ; CODE XREF: std::_Uninitialized_move<int *,int *,std::_Wrap_alloc<std::allocator<int>>>(int *,int *,int *,std::_Wrap_alloc<std::allocator<int>> &)+3Bp
.text$mn:0000460C                                         ; std::lower_bound<int *,int,BufferEquivalent>(int *,int *,int const &,BufferEquivalent)+57p ...
.text$mn:0000460C
.text$mn:0000460C arg_0           = dword ptr  8
.text$mn:0000460C arg_4           = dword ptr  0Ch
.text$mn:0000460C
.text$mn:0000460C                 push    ebp
.text$mn:0000460D                 mov     ebp, esp
.text$mn:0000460F                 mov     eax, [ebp+arg_0]
.text$mn:00004612                 mov     ecx, [ebp+arg_4]
.text$mn:00004615                 mov     [eax], ecx
.text$mn:00004617                 mov     eax, [ebp+arg_0]
.text$mn:0000461A                 pop     ebp
.text$mn:0000461B                 retn
.text$mn:0000461B ??$_Rechecked@PAHPAH@std@@YAAAPAHAAPAHPAH@Z endp
.text$mn:0000461B
.text$mn:0000461B _text$mn        ends
.text$mn:0000461B
.text$mn:0000461C ; ===========================================================================
.text$mn:0000461C
.text$mn:0000461C ; Segment type: Pure code
.text$mn:0000461C ; Segment permissions: Read/Execute
.text$mn:0000461C _text$mn        segment para public 'CODE' use32
.text$mn:0000461C                 assume cs:_text$mn
.text$mn:0000461C                 ;org 461Ch
.text$mn:0000461C ; COMDAT (pick any)
.text$mn:0000461C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000461C
.text$mn:0000461C ; =============== S U B R O U T I N E =======================================
.text$mn:0000461C
.text$mn:0000461C ; Attributes: bp-based frame
.text$mn:0000461C
.text$mn:0000461C ; wchar_t * & __cdecl std::_Rechecked<wchar_t *, wchar_t *>(wchar_t * &, wchar_t *)
.text$mn:0000461C                 public ??$_Rechecked@PA_WPA_W@std@@YAAAPA_WAAPA_WPA_W@Z
.text$mn:0000461C ??$_Rechecked@PA_WPA_W@std@@YAAAPA_WAAPA_WPA_W@Z proc near
.text$mn:0000461C                                         ; CODE XREF: std::_Uninitialized_copy<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,wchar_t *,std::_Wrap_alloc<std::allocator<wchar_t>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,wchar_t *,std::_Wrap_alloc<std::allocator<wchar_t>> &)+B2p
.text$mn:0000461C                                         ; std::_Uninitialized_move<wchar_t *,wchar_t *,std::_Wrap_alloc<std::allocator<wchar_t>>>(wchar_t *,wchar_t *,wchar_t *,std::_Wrap_alloc<std::allocator<wchar_t>> &)+3Bp
.text$mn:0000461C
.text$mn:0000461C arg_0           = dword ptr  8
.text$mn:0000461C arg_4           = dword ptr  0Ch
.text$mn:0000461C
.text$mn:0000461C                 push    ebp
.text$mn:0000461D                 mov     ebp, esp
.text$mn:0000461F                 mov     eax, [ebp+arg_0]
.text$mn:00004622                 mov     ecx, [ebp+arg_4]
.text$mn:00004625                 mov     [eax], ecx
.text$mn:00004627                 mov     eax, [ebp+arg_0]
.text$mn:0000462A                 pop     ebp
.text$mn:0000462B                 retn
.text$mn:0000462B ??$_Rechecked@PA_WPA_W@std@@YAAAPA_WAAPA_WPA_W@Z endp
.text$mn:0000462B
.text$mn:0000462B _text$mn        ends
.text$mn:0000462B
.text$mn:0000462C ; ===========================================================================
.text$mn:0000462C
.text$mn:0000462C ; Segment type: Pure code
.text$mn:0000462C ; Segment permissions: Read/Execute
.text$mn:0000462C _text$mn        segment para public 'CODE' use32
.text$mn:0000462C                 assume cs:_text$mn
.text$mn:0000462C                 ;org 462Ch
.text$mn:0000462C ; COMDAT (pick any)
.text$mn:0000462C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000462C
.text$mn:0000462C ; =============== S U B R O U T I N E =======================================
.text$mn:0000462C
.text$mn:0000462C ; Attributes: bp-based frame
.text$mn:0000462C
.text$mn:0000462C ; class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<int>>> & __cdecl std::_Rechecked<class std::_Vector_val<struct std::_Simple_types<int>>>(class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<int>>> &, int *)
.text$mn:0000462C                 public ??$_Rechecked@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@YAAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@AAV10@PAH@Z
.text$mn:0000462C ??$_Rechecked@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@YAAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@AAV10@PAH@Z proc near
.text$mn:0000462C                                         ; CODE XREF: std::find_if<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::binder2nd<std::equal_to<int>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::binder2nd<std::equal_to<int>>)+112p
.text$mn:0000462C                                         ; std::remove_if<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::binder2nd<std::equal_to<int>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::binder2nd<std::equal_to<int>>)+176p
.text$mn:0000462C
.text$mn:0000462C arg_0           = dword ptr  8
.text$mn:0000462C arg_4           = dword ptr  0Ch
.text$mn:0000462C
.text$mn:0000462C                 push    ebp
.text$mn:0000462D                 mov     ebp, esp
.text$mn:0000462F                 mov     eax, [ebp+arg_4]
.text$mn:00004632                 push    eax
.text$mn:00004633                 mov     ecx, [ebp+arg_0]
.text$mn:00004636                 call    ?_Rechecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAEAAV12@PAH@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Rechecked(int *)
.text$mn:0000463B                 pop     ebp
.text$mn:0000463C                 retn
.text$mn:0000463C ??$_Rechecked@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@YAAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@AAV10@PAH@Z endp
.text$mn:0000463C
.text$mn:0000463C ; ---------------------------------------------------------------------------
.text$mn:0000463D                 align 10h
.text$mn:0000463D _text$mn        ends
.text$mn:0000463D
.text$mn:00004640 ; ===========================================================================
.text$mn:00004640
.text$mn:00004640 ; Segment type: Pure code
.text$mn:00004640 ; Segment permissions: Read/Execute
.text$mn:00004640 _text$mn        segment para public 'CODE' use32
.text$mn:00004640                 assume cs:_text$mn
.text$mn:00004640                 ;org 4640h
.text$mn:00004640 ; COMDAT (pick any)
.text$mn:00004640                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004640
.text$mn:00004640 ; =============== S U B R O U T I N E =======================================
.text$mn:00004640
.text$mn:00004640 ; Attributes: bp-based frame
.text$mn:00004640
.text$mn:00004640 ; int * __cdecl std::_Remove_if<int *, class std::binder2nd<struct std::equal_to<int>>>(int *, int *, class std::binder2nd<struct std::equal_to<int>>)
.text$mn:00004640                 public ??$_Remove_if@PAHV?$binder2nd@U?$equal_to@H@std@@@std@@@std@@YAPAHPAH0V?$binder2nd@U?$equal_to@H@std@@@0@@Z
.text$mn:00004640 ??$_Remove_if@PAHV?$binder2nd@U?$equal_to@H@std@@@std@@@std@@YAPAHPAH0V?$binder2nd@U?$equal_to@H@std@@@0@@Z proc near
.text$mn:00004640                                         ; CODE XREF: std::remove_if<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::binder2nd<std::equal_to<int>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::binder2nd<std::equal_to<int>>)+163p
.text$mn:00004640
.text$mn:00004640 var_4           = dword ptr -4
.text$mn:00004640 arg_0           = dword ptr  8
.text$mn:00004640 arg_4           = dword ptr  0Ch
.text$mn:00004640 arg_8           = byte ptr  10h
.text$mn:00004640
.text$mn:00004640                 push    ebp
.text$mn:00004641                 mov     ebp, esp
.text$mn:00004643                 push    ecx
.text$mn:00004644                 mov     eax, [ebp+arg_0]
.text$mn:00004647                 mov     [ebp+var_4], eax
.text$mn:0000464A                 mov     ecx, [ebp+arg_0]
.text$mn:0000464D                 add     ecx, 4
.text$mn:00004650                 mov     [ebp+arg_0], ecx
.text$mn:00004653                 jmp     short loc_465E
.text$mn:00004655 ; ---------------------------------------------------------------------------
.text$mn:00004655
.text$mn:00004655 loc_4655:                               ; CODE XREF: std::_Remove_if<int *,std::binder2nd<std::equal_to<int>>>(int *,int *,std::binder2nd<std::equal_to<int>>):loc_4695j
.text$mn:00004655                 mov     edx, [ebp+arg_0]
.text$mn:00004658                 add     edx, 4
.text$mn:0000465B                 mov     [ebp+arg_0], edx
.text$mn:0000465E
.text$mn:0000465E loc_465E:                               ; CODE XREF: std::_Remove_if<int *,std::binder2nd<std::equal_to<int>>>(int *,int *,std::binder2nd<std::equal_to<int>>)+13j
.text$mn:0000465E                 mov     eax, [ebp+arg_0]
.text$mn:00004661                 cmp     eax, [ebp+arg_4]
.text$mn:00004664                 jz      short loc_4697
.text$mn:00004666                 mov     ecx, [ebp+arg_0]
.text$mn:00004669                 push    ecx
.text$mn:0000466A                 lea     ecx, [ebp+arg_8]
.text$mn:0000466D                 call    ??R?$binder2nd@U?$equal_to@H@std@@@std@@QBE_NAAH@Z ; std::binder2nd<std::equal_to<int>>::operator()(int &)
.text$mn:00004672                 movzx   edx, al
.text$mn:00004675                 test    edx, edx
.text$mn:00004677                 jnz     short loc_4695
.text$mn:00004679                 mov     eax, [ebp+arg_0]
.text$mn:0000467C                 push    eax
.text$mn:0000467D                 call    ??$_Move@AAH@std@@YA$$QAHAAH@Z ; std::_Move<int &>(int &)
.text$mn:00004682                 add     esp, 4
.text$mn:00004685                 mov     ecx, [ebp+var_4]
.text$mn:00004688                 mov     edx, [eax]
.text$mn:0000468A                 mov     [ecx], edx
.text$mn:0000468C                 mov     eax, [ebp+var_4]
.text$mn:0000468F                 add     eax, 4
.text$mn:00004692                 mov     [ebp+var_4], eax
.text$mn:00004695
.text$mn:00004695 loc_4695:                               ; CODE XREF: std::_Remove_if<int *,std::binder2nd<std::equal_to<int>>>(int *,int *,std::binder2nd<std::equal_to<int>>)+37j
.text$mn:00004695                 jmp     short loc_4655
.text$mn:00004697 ; ---------------------------------------------------------------------------
.text$mn:00004697
.text$mn:00004697 loc_4697:                               ; CODE XREF: std::_Remove_if<int *,std::binder2nd<std::equal_to<int>>>(int *,int *,std::binder2nd<std::equal_to<int>>)+24j
.text$mn:00004697                 mov     eax, [ebp+var_4]
.text$mn:0000469A                 mov     esp, ebp
.text$mn:0000469C                 pop     ebp
.text$mn:0000469D                 retn
.text$mn:0000469D ??$_Remove_if@PAHV?$binder2nd@U?$equal_to@H@std@@@std@@@std@@YAPAHPAH0V?$binder2nd@U?$equal_to@H@std@@@0@@Z endp
.text$mn:0000469D
.text$mn:0000469D ; ---------------------------------------------------------------------------
.text$mn:0000469E                 align 10h
.text$mn:0000469E _text$mn        ends
.text$mn:0000469E
.text$mn:000046A0 ; ===========================================================================
.text$mn:000046A0
.text$mn:000046A0 ; Segment type: Pure code
.text$mn:000046A0 ; Segment permissions: Read/Execute
.text$mn:000046A0 _text$mn        segment para public 'CODE' use32
.text$mn:000046A0                 assume cs:_text$mn
.text$mn:000046A0                 ;org 46A0h
.text$mn:000046A0 ; COMDAT (pick any)
.text$mn:000046A0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000046A0
.text$mn:000046A0 ; =============== S U B R O U T I N E =======================================
.text$mn:000046A0
.text$mn:000046A0 ; Attributes: bp-based frame
.text$mn:000046A0
.text$mn:000046A0 ; void __cdecl std::_Rotate<int *>(int *, int *, int *, struct std::random_access_iterator_tag)
.text$mn:000046A0                 public ??$_Rotate@PAH@std@@YAXPAH00Urandom_access_iterator_tag@0@@Z
.text$mn:000046A0 ??$_Rotate@PAH@std@@YAXPAH00Urandom_access_iterator_tag@0@@Z proc near
.text$mn:000046A0                                         ; CODE XREF: std::rotate<int *>(int *,int *,int *)+85p
.text$mn:000046A0
.text$mn:000046A0 arg_0           = dword ptr  8
.text$mn:000046A0 arg_4           = dword ptr  0Ch
.text$mn:000046A0 arg_8           = dword ptr  10h
.text$mn:000046A0
.text$mn:000046A0                 push    ebp
.text$mn:000046A1                 mov     ebp, esp
.text$mn:000046A3                 mov     eax, [ebp+arg_0]
.text$mn:000046A6                 push    eax
.text$mn:000046A7                 call    ??$_Val_type@PAH@std@@YAPAHPAH@Z ; std::_Val_type<int *>(int *)
.text$mn:000046AC                 add     esp, 4
.text$mn:000046AF                 push    eax
.text$mn:000046B0                 mov     ecx, [ebp+arg_0]
.text$mn:000046B3                 push    ecx
.text$mn:000046B4                 call    ??$_Dist_type@PAH@std@@YAPAHPAH@Z ; std::_Dist_type<int *>(int *)
.text$mn:000046B9                 add     esp, 4
.text$mn:000046BC                 push    eax
.text$mn:000046BD                 mov     edx, [ebp+arg_8]
.text$mn:000046C0                 push    edx
.text$mn:000046C1                 mov     eax, [ebp+arg_4]
.text$mn:000046C4                 push    eax
.text$mn:000046C5                 mov     ecx, [ebp+arg_0]
.text$mn:000046C8                 push    ecx
.text$mn:000046C9                 call    ??$_Rotate@PAHHH@std@@YAXPAH0000@Z ; std::_Rotate<int *,int,int>(int *,int *,int *,int *,int *)
.text$mn:000046CE                 add     esp, 14h
.text$mn:000046D1                 pop     ebp
.text$mn:000046D2                 retn
.text$mn:000046D2 ??$_Rotate@PAH@std@@YAXPAH00Urandom_access_iterator_tag@0@@Z endp
.text$mn:000046D2
.text$mn:000046D2 ; ---------------------------------------------------------------------------
.text$mn:000046D3                 align 4
.text$mn:000046D3 _text$mn        ends
.text$mn:000046D3
.text$mn:000046D4 ; ===========================================================================
.text$mn:000046D4
.text$mn:000046D4 ; Segment type: Pure code
.text$mn:000046D4 ; Segment permissions: Read/Execute
.text$mn:000046D4 _text$mn        segment para public 'CODE' use32
.text$mn:000046D4                 assume cs:_text$mn
.text$mn:000046D4                 ;org 46D4h
.text$mn:000046D4 ; COMDAT (pick any)
.text$mn:000046D4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000046D4
.text$mn:000046D4 ; =============== S U B R O U T I N E =======================================
.text$mn:000046D4
.text$mn:000046D4 ; Attributes: bp-based frame
.text$mn:000046D4
.text$mn:000046D4 ; void __cdecl std::_Rotate<int *, int, int>(int *, int *, int *, int *, int *)
.text$mn:000046D4                 public ??$_Rotate@PAHHH@std@@YAXPAH0000@Z
.text$mn:000046D4 ??$_Rotate@PAHHH@std@@YAXPAH0000@Z proc near
.text$mn:000046D4                                         ; CODE XREF: std::_Rotate<int *>(int *,int *,int *,std::random_access_iterator_tag)+29p
.text$mn:000046D4
.text$mn:000046D4 var_24          = dword ptr -24h
.text$mn:000046D4 var_20          = dword ptr -20h
.text$mn:000046D4 var_1C          = dword ptr -1Ch
.text$mn:000046D4 var_18          = dword ptr -18h
.text$mn:000046D4 var_14          = dword ptr -14h
.text$mn:000046D4 var_10          = dword ptr -10h
.text$mn:000046D4 var_C           = dword ptr -0Ch
.text$mn:000046D4 var_8           = dword ptr -8
.text$mn:000046D4 var_4           = dword ptr -4
.text$mn:000046D4 arg_0           = dword ptr  8
.text$mn:000046D4 arg_4           = dword ptr  0Ch
.text$mn:000046D4 arg_8           = dword ptr  10h
.text$mn:000046D4
.text$mn:000046D4                 push    ebp
.text$mn:000046D5                 mov     ebp, esp
.text$mn:000046D7                 sub     esp, 24h
.text$mn:000046DA                 mov     eax, [ebp+arg_4]
.text$mn:000046DD                 sub     eax, [ebp+arg_0]
.text$mn:000046E0                 sar     eax, 2
.text$mn:000046E3                 mov     [ebp+var_C], eax
.text$mn:000046E6                 mov     ecx, [ebp+arg_8]
.text$mn:000046E9                 sub     ecx, [ebp+arg_0]
.text$mn:000046EC                 sar     ecx, 2
.text$mn:000046EF                 mov     [ebp+var_4], ecx
.text$mn:000046F2                 mov     edx, [ebp+var_C]
.text$mn:000046F5                 mov     [ebp+var_10], edx
.text$mn:000046F8
.text$mn:000046F8 loc_46F8:                               ; CODE XREF: std::_Rotate<int *,int,int>(int *,int *,int *,int *,int *)+40j
.text$mn:000046F8                 cmp     [ebp+var_10], 0
.text$mn:000046FC                 jz      short loc_4716
.text$mn:000046FE                 mov     eax, [ebp+var_4]
.text$mn:00004701                 cdq
.text$mn:00004702                 idiv    [ebp+var_10]
.text$mn:00004705                 mov     [ebp+var_24], edx
.text$mn:00004708                 mov     eax, [ebp+var_10]
.text$mn:0000470B                 mov     [ebp+var_4], eax
.text$mn:0000470E                 mov     ecx, [ebp+var_24]
.text$mn:00004711                 mov     [ebp+var_10], ecx
.text$mn:00004714                 jmp     short loc_46F8
.text$mn:00004716 ; ---------------------------------------------------------------------------
.text$mn:00004716
.text$mn:00004716 loc_4716:                               ; CODE XREF: std::_Rotate<int *,int,int>(int *,int *,int *,int *,int *)+28j
.text$mn:00004716                 mov     edx, [ebp+arg_8]
.text$mn:00004719                 sub     edx, [ebp+arg_0]
.text$mn:0000471C                 sar     edx, 2
.text$mn:0000471F                 cmp     [ebp+var_4], edx
.text$mn:00004722                 jge     loc_47D7
.text$mn:00004728                 jmp     short loc_4733
.text$mn:0000472A ; ---------------------------------------------------------------------------
.text$mn:0000472A
.text$mn:0000472A loc_472A:                               ; CODE XREF: std::_Rotate<int *,int,int>(int *,int *,int *,int *,int *):loc_47D2j
.text$mn:0000472A                 mov     eax, [ebp+var_4]
.text$mn:0000472D                 sub     eax, 1
.text$mn:00004730                 mov     [ebp+var_4], eax
.text$mn:00004733
.text$mn:00004733 loc_4733:                               ; CODE XREF: std::_Rotate<int *,int,int>(int *,int *,int *,int *,int *)+54j
.text$mn:00004733                 cmp     [ebp+var_4], 0
.text$mn:00004737                 jle     loc_47D7
.text$mn:0000473D                 mov     ecx, [ebp+var_4]
.text$mn:00004740                 mov     edx, [ebp+arg_0]
.text$mn:00004743                 lea     eax, [edx+ecx*4]
.text$mn:00004746                 mov     [ebp+var_20], eax
.text$mn:00004749                 mov     ecx, [ebp+var_20]
.text$mn:0000474C                 mov     [ebp+var_14], ecx
.text$mn:0000474F                 mov     edx, [ebp+var_C]
.text$mn:00004752                 mov     eax, [ebp+var_14]
.text$mn:00004755                 lea     ecx, [eax+edx*4]
.text$mn:00004758                 cmp     ecx, [ebp+arg_8]
.text$mn:0000475B                 jnz     short loc_4765
.text$mn:0000475D                 mov     edx, [ebp+arg_0]
.text$mn:00004760                 mov     [ebp+var_18], edx
.text$mn:00004763                 jmp     short loc_4771
.text$mn:00004765 ; ---------------------------------------------------------------------------
.text$mn:00004765
.text$mn:00004765 loc_4765:                               ; CODE XREF: std::_Rotate<int *,int,int>(int *,int *,int *,int *,int *)+87j
.text$mn:00004765                 mov     eax, [ebp+var_C]
.text$mn:00004768                 mov     ecx, [ebp+var_14]
.text$mn:0000476B                 lea     edx, [ecx+eax*4]
.text$mn:0000476E                 mov     [ebp+var_18], edx
.text$mn:00004771
.text$mn:00004771 loc_4771:                               ; CODE XREF: std::_Rotate<int *,int,int>(int *,int *,int *,int *,int *)+8Fj
.text$mn:00004771                 mov     eax, [ebp+var_18]
.text$mn:00004774                 mov     [ebp+var_8], eax
.text$mn:00004777
.text$mn:00004777 loc_4777:                               ; CODE XREF: std::_Rotate<int *,int,int>(int *,int *,int *,int *,int *):loc_47D0j
.text$mn:00004777                 mov     ecx, [ebp+var_8]
.text$mn:0000477A                 push    ecx
.text$mn:0000477B                 mov     edx, [ebp+var_14]
.text$mn:0000477E                 push    edx
.text$mn:0000477F                 call    ??$iter_swap@PAHPAH@std@@YAXPAH0@Z ; std::iter_swap<int *,int *>(int *,int *)
.text$mn:00004784                 add     esp, 8
.text$mn:00004787                 mov     eax, [ebp+var_8]
.text$mn:0000478A                 mov     [ebp+var_14], eax
.text$mn:0000478D                 mov     ecx, [ebp+arg_8]
.text$mn:00004790                 sub     ecx, [ebp+var_8]
.text$mn:00004793                 sar     ecx, 2
.text$mn:00004796                 cmp     [ebp+var_C], ecx
.text$mn:00004799                 jge     short loc_47A9
.text$mn:0000479B                 mov     edx, [ebp+var_C]
.text$mn:0000479E                 mov     eax, [ebp+var_8]
.text$mn:000047A1                 lea     ecx, [eax+edx*4]
.text$mn:000047A4                 mov     [ebp+var_1C], ecx
.text$mn:000047A7                 jmp     short loc_47C0
.text$mn:000047A9 ; ---------------------------------------------------------------------------
.text$mn:000047A9
.text$mn:000047A9 loc_47A9:                               ; CODE XREF: std::_Rotate<int *,int,int>(int *,int *,int *,int *,int *)+C5j
.text$mn:000047A9                 mov     edx, [ebp+arg_8]
.text$mn:000047AC                 sub     edx, [ebp+var_8]
.text$mn:000047AF                 sar     edx, 2
.text$mn:000047B2                 mov     eax, [ebp+var_C]
.text$mn:000047B5                 sub     eax, edx
.text$mn:000047B7                 mov     ecx, [ebp+arg_0]
.text$mn:000047BA                 lea     edx, [ecx+eax*4]
.text$mn:000047BD                 mov     [ebp+var_1C], edx
.text$mn:000047C0
.text$mn:000047C0 loc_47C0:                               ; CODE XREF: std::_Rotate<int *,int,int>(int *,int *,int *,int *,int *)+D3j
.text$mn:000047C0                 mov     eax, [ebp+var_1C]
.text$mn:000047C3                 mov     [ebp+var_8], eax
.text$mn:000047C6                 mov     ecx, [ebp+var_8]
.text$mn:000047C9                 cmp     ecx, [ebp+var_20]
.text$mn:000047CC                 jnz     short loc_47D0
.text$mn:000047CE                 jmp     short loc_47D2
.text$mn:000047D0 ; ---------------------------------------------------------------------------
.text$mn:000047D0
.text$mn:000047D0 loc_47D0:                               ; CODE XREF: std::_Rotate<int *,int,int>(int *,int *,int *,int *,int *)+F8j
.text$mn:000047D0                 jmp     short loc_4777
.text$mn:000047D2 ; ---------------------------------------------------------------------------
.text$mn:000047D2
.text$mn:000047D2 loc_47D2:                               ; CODE XREF: std::_Rotate<int *,int,int>(int *,int *,int *,int *,int *)+FAj
.text$mn:000047D2                 jmp     loc_472A
.text$mn:000047D7 ; ---------------------------------------------------------------------------
.text$mn:000047D7
.text$mn:000047D7 loc_47D7:                               ; CODE XREF: std::_Rotate<int *,int,int>(int *,int *,int *,int *,int *)+4Ej
.text$mn:000047D7                                         ; std::_Rotate<int *,int,int>(int *,int *,int *,int *,int *)+63j
.text$mn:000047D7                 mov     esp, ebp
.text$mn:000047D9                 pop     ebp
.text$mn:000047DA                 retn
.text$mn:000047DA ??$_Rotate@PAHHH@std@@YAXPAH0000@Z endp
.text$mn:000047DA
.text$mn:000047DA ; ---------------------------------------------------------------------------
.text$mn:000047DB                 align 4
.text$mn:000047DB _text$mn        ends
.text$mn:000047DB
.text$mn:000047DC ; ===========================================================================
.text$mn:000047DC
.text$mn:000047DC ; Segment type: Pure code
.text$mn:000047DC ; Segment permissions: Read/Execute
.text$mn:000047DC _text$mn        segment para public 'CODE' use32
.text$mn:000047DC                 assume cs:_text$mn
.text$mn:000047DC                 ;org 47DCh
.text$mn:000047DC ; COMDAT (pick any)
.text$mn:000047DC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000047DC
.text$mn:000047DC ; =============== S U B R O U T I N E =======================================
.text$mn:000047DC
.text$mn:000047DC ; Attributes: bp-based frame
.text$mn:000047DC
.text$mn:000047DC ; int __cdecl std::_Stable_sort<int *,int,int,BufferEquivalent>(void *Src, int, int, int, int, int, int, int)
.text$mn:000047DC                 public ??$_Stable_sort@PAHHHUBufferEquivalent@@@std@@YAXPAH000UBufferEquivalent@@@Z
.text$mn:000047DC ??$_Stable_sort@PAHHHUBufferEquivalent@@@std@@YAXPAH000UBufferEquivalent@@@Z proc near
.text$mn:000047DC                                         ; CODE XREF: std::stable_sort<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,BufferEquivalent>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,BufferEquivalent)+18Bp
.text$mn:000047DC
.text$mn:000047DC var_24          = dword ptr -24h
.text$mn:000047DC var_10          = dword ptr -10h
.text$mn:000047DC var_C           = dword ptr -0Ch
.text$mn:000047DC var_4           = dword ptr -4
.text$mn:000047DC Src             = dword ptr  8
.text$mn:000047DC arg_4           = dword ptr  0Ch
.text$mn:000047DC arg_10          = dword ptr  18h
.text$mn:000047DC arg_14          = dword ptr  1Ch
.text$mn:000047DC arg_18          = dword ptr  20h
.text$mn:000047DC arg_1C          = dword ptr  24h
.text$mn:000047DC
.text$mn:000047DC                 push    ebp
.text$mn:000047DD                 mov     ebp, esp
.text$mn:000047DF                 push    0FFFFFFFFh
.text$mn:000047E1                 push    offset __ehhandler$??$_Stable_sort@PAHHHUBufferEquivalent@@@std@@YAXPAH000UBufferEquivalent@@@Z
.text$mn:000047E6                 mov     eax, large fs:0
.text$mn:000047EC                 push    eax
.text$mn:000047ED                 sub     esp, 18h
.text$mn:000047F0                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000047F5                 xor     eax, ebp
.text$mn:000047F7                 push    eax
.text$mn:000047F8                 lea     eax, [ebp+var_C]
.text$mn:000047FB                 mov     large fs:0, eax
.text$mn:00004801                 mov     [ebp+var_10], 0
.text$mn:00004808                 lea     eax, [ebp+var_10]
.text$mn:0000480B                 push    eax
.text$mn:0000480C                 mov     ecx, [ebp+arg_4]
.text$mn:0000480F                 push    ecx             ; int
.text$mn:00004810                 mov     edx, [ebp+Src]
.text$mn:00004813                 push    edx             ; int
.text$mn:00004814                 call    ??$_Distance@PAHH@std@@YAXPAH0AAH@Z ; std::_Distance<int *,int>(int *,int *,int &)
.text$mn:00004819                 add     esp, 0Ch
.text$mn:0000481C                 mov     eax, [ebp+var_10]
.text$mn:0000481F                 add     eax, 1
.text$mn:00004822                 cdq
.text$mn:00004823                 sub     eax, edx
.text$mn:00004825                 sar     eax, 1
.text$mn:00004827                 push    eax             ; int
.text$mn:00004828                 lea     ecx, [ebp+var_24]
.text$mn:0000482B                 call    ??0?$_Temp_iterator@H@std@@QAE@H@Z ; std::_Temp_iterator<int>::_Temp_iterator<int>(int)
.text$mn:00004830                 mov     [ebp+var_4], 0
.text$mn:00004837                 sub     esp, 10h
.text$mn:0000483A                 mov     eax, esp
.text$mn:0000483C                 mov     ecx, [ebp+arg_10]
.text$mn:0000483F                 mov     [eax], ecx
.text$mn:00004841                 mov     edx, [ebp+arg_14]
.text$mn:00004844                 mov     [eax+4], edx
.text$mn:00004847                 mov     ecx, [ebp+arg_18]
.text$mn:0000484A                 mov     [eax+8], ecx
.text$mn:0000484D                 mov     edx, [ebp+arg_1C]
.text$mn:00004850                 mov     [eax+0Ch], edx
.text$mn:00004853                 lea     eax, [ebp+var_24]
.text$mn:00004856                 push    eax             ; int
.text$mn:00004857                 mov     ecx, [ebp+var_10]
.text$mn:0000485A                 push    ecx             ; int
.text$mn:0000485B                 mov     edx, [ebp+arg_4]
.text$mn:0000485E                 push    edx             ; int
.text$mn:0000485F                 mov     eax, [ebp+Src]
.text$mn:00004862                 push    eax             ; Src
.text$mn:00004863                 call    ??$_Stable_sort@PAHHHUBufferEquivalent@@@std@@YAXPAH0HAAV?$_Temp_iterator@H@0@UBufferEquivalent@@@Z ; std::_Stable_sort<int *,int,int,BufferEquivalent>(int *,int *,int,std::_Temp_iterator<int> &,BufferEquivalent)
.text$mn:00004868                 add     esp, 20h
.text$mn:0000486B                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004872                 lea     ecx, [ebp+var_24]
.text$mn:00004875                 call    ??1?$_Temp_iterator@H@std@@QAE@XZ ; std::_Temp_iterator<int>::~_Temp_iterator<int>(void)
.text$mn:0000487A                 mov     ecx, [ebp+var_C]
.text$mn:0000487D                 mov     large fs:0, ecx
.text$mn:00004884                 pop     ecx
.text$mn:00004885                 mov     esp, ebp
.text$mn:00004887                 pop     ebp
.text$mn:00004888                 retn
.text$mn:00004888 ??$_Stable_sort@PAHHHUBufferEquivalent@@@std@@YAXPAH000UBufferEquivalent@@@Z endp
.text$mn:00004888
.text$mn:00004888 ; ---------------------------------------------------------------------------
.text$mn:00004889                 align 4
.text$mn:00004889 _text$mn        ends
.text$mn:00004889
.text$x:0000488C ; ===========================================================================
.text$x:0000488C
.text$x:0000488C ; Segment type: Pure code
.text$x:0000488C ; Segment permissions: Read/Execute
.text$x:0000488C _text$x         segment para public 'CODE' use32
.text$x:0000488C                 assume cs:_text$x
.text$x:0000488C                 ;org 488Ch
.text$x:0000488C ; COMDAT (pick associative to section at 47DC)
.text$x:0000488C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000488C
.text$x:0000488C ; =============== S U B R O U T I N E =======================================
.text$x:0000488C
.text$x:0000488C
.text$x:0000488C __unwindfunclet$??$_Stable_sort@PAHHHUBufferEquivalent@@@std@@YAXPAH000UBufferEquivalent@@@Z$0 proc near
.text$x:0000488C                                         ; DATA XREF: .xdata$x:0000D744o
.text$x:0000488C                 lea     ecx, [ebp-24h]
.text$x:0000488F                 jmp     ??1?$_Temp_iterator@H@std@@QAE@XZ ; std::_Temp_iterator<int>::~_Temp_iterator<int>(void)
.text$x:0000488F __unwindfunclet$??$_Stable_sort@PAHHHUBufferEquivalent@@@std@@YAXPAH000UBufferEquivalent@@@Z$0 endp
.text$x:0000488F
.text$x:00004894
.text$x:00004894 ; =============== S U B R O U T I N E =======================================
.text$x:00004894
.text$x:00004894
.text$x:00004894 __ehhandler$??$_Stable_sort@PAHHHUBufferEquivalent@@@std@@YAXPAH000UBufferEquivalent@@@Z proc near
.text$x:00004894                                         ; DATA XREF: std::_Stable_sort<int *,int,int,BufferEquivalent>(int *,int *,int *,int *,BufferEquivalent)+5o
.text$x:00004894
.text$x:00004894 arg_4           = dword ptr  8
.text$x:00004894
.text$x:00004894                 mov     edx, [esp+arg_4]
.text$x:00004898                 lea     eax, [edx+0Ch]
.text$x:0000489B                 mov     ecx, [edx-1Ch]
.text$x:0000489E                 xor     ecx, eax
.text$x:000048A0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000048A5                 mov     eax, offset __ehfuncinfo$??$_Stable_sort@PAHHHUBufferEquivalent@@@std@@YAXPAH000UBufferEquivalent@@@Z
.text$x:000048AA                 jmp     ___CxxFrameHandler3
.text$x:000048AA __ehhandler$??$_Stable_sort@PAHHHUBufferEquivalent@@@std@@YAXPAH000UBufferEquivalent@@@Z endp
.text$x:000048AA
.text$x:000048AA ; ---------------------------------------------------------------------------
.text$x:000048AF                 align 10h
.text$x:000048AF _text$x         ends
.text$x:000048AF
.text$mn:000048B0 ; ===========================================================================
.text$mn:000048B0
.text$mn:000048B0 ; Segment type: Pure code
.text$mn:000048B0 ; Segment permissions: Read/Execute
.text$mn:000048B0 _text$mn        segment para public 'CODE' use32
.text$mn:000048B0                 assume cs:_text$mn
.text$mn:000048B0                 ;org 48B0h
.text$mn:000048B0 ; COMDAT (pick any)
.text$mn:000048B0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000048B0
.text$mn:000048B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000048B0
.text$mn:000048B0 ; Attributes: bp-based frame
.text$mn:000048B0
.text$mn:000048B0 ; int __cdecl std::_Stable_sort<int *,int,int,BufferEquivalent>(void *Src, int, int, int, int, int, int, int)
.text$mn:000048B0                 public ??$_Stable_sort@PAHHHUBufferEquivalent@@@std@@YAXPAH0HAAV?$_Temp_iterator@H@0@UBufferEquivalent@@@Z
.text$mn:000048B0 ??$_Stable_sort@PAHHHUBufferEquivalent@@@std@@YAXPAH0HAAV?$_Temp_iterator@H@0@UBufferEquivalent@@@Z proc near
.text$mn:000048B0                                         ; CODE XREF: std::_Stable_sort<int *,int,int,BufferEquivalent>(int *,int *,int *,int *,BufferEquivalent)+87p
.text$mn:000048B0                                         ; std::_Stable_sort<int *,int,int,BufferEquivalent>(int *,int *,int,std::_Temp_iterator<int> &,BufferEquivalent)+104p ...
.text$mn:000048B0
.text$mn:000048B0 Dst             = dword ptr -8
.text$mn:000048B0 var_4           = dword ptr -4
.text$mn:000048B0 Src             = dword ptr  8
.text$mn:000048B0 arg_4           = dword ptr  0Ch
.text$mn:000048B0 arg_8           = dword ptr  10h
.text$mn:000048B0 arg_C           = dword ptr  14h
.text$mn:000048B0 arg_10          = dword ptr  18h
.text$mn:000048B0 arg_14          = dword ptr  1Ch
.text$mn:000048B0 arg_18          = dword ptr  20h
.text$mn:000048B0 arg_1C          = dword ptr  24h
.text$mn:000048B0
.text$mn:000048B0                 push    ebp
.text$mn:000048B1                 mov     ebp, esp
.text$mn:000048B3                 sub     esp, 8
.text$mn:000048B6                 cmp     [ebp+arg_8], 20h ; ' '
.text$mn:000048BA                 jg      short loc_48ED
.text$mn:000048BC                 sub     esp, 10h
.text$mn:000048BF                 mov     eax, esp
.text$mn:000048C1                 mov     ecx, [ebp+arg_10]
.text$mn:000048C4                 mov     [eax], ecx
.text$mn:000048C6                 mov     edx, [ebp+arg_14]
.text$mn:000048C9                 mov     [eax+4], edx
.text$mn:000048CC                 mov     ecx, [ebp+arg_18]
.text$mn:000048CF                 mov     [eax+8], ecx
.text$mn:000048D2                 mov     edx, [ebp+arg_1C]
.text$mn:000048D5                 mov     [eax+0Ch], edx
.text$mn:000048D8                 mov     eax, [ebp+arg_4]
.text$mn:000048DB                 push    eax             ; int
.text$mn:000048DC                 mov     ecx, [ebp+Src]
.text$mn:000048DF                 push    ecx             ; Src
.text$mn:000048E0                 call    ??$_Insertion_sort@PAHUBufferEquivalent@@@std@@YAXPAH0UBufferEquivalent@@@Z ; std::_Insertion_sort<int *,BufferEquivalent>(int *,int *,BufferEquivalent)
.text$mn:000048E5                 add     esp, 18h
.text$mn:000048E8                 jmp     loc_4A2F
.text$mn:000048ED ; ---------------------------------------------------------------------------
.text$mn:000048ED
.text$mn:000048ED loc_48ED:                               ; CODE XREF: std::_Stable_sort<int *,int,int,BufferEquivalent>(int *,int *,int,std::_Temp_iterator<int> &,BufferEquivalent)+Aj
.text$mn:000048ED                 mov     eax, [ebp+arg_8]
.text$mn:000048F0                 add     eax, 1
.text$mn:000048F3                 cdq
.text$mn:000048F4                 sub     eax, edx
.text$mn:000048F6                 sar     eax, 1
.text$mn:000048F8                 mov     [ebp+var_4], eax
.text$mn:000048FB                 mov     edx, [ebp+Src]
.text$mn:000048FE                 mov     [ebp+Dst], edx
.text$mn:00004901                 mov     eax, [ebp+var_4]
.text$mn:00004904                 push    eax             ; int
.text$mn:00004905                 lea     ecx, [ebp+Dst]
.text$mn:00004908                 push    ecx             ; int
.text$mn:00004909                 call    ??$advance@PAHH@std@@YAXAAPAHH@Z ; std::advance<int *,int>(int * &,int)
.text$mn:0000490E                 add     esp, 8
.text$mn:00004911                 mov     ecx, [ebp+arg_C]
.text$mn:00004914                 call    ?_Maxlen@?$_Temp_iterator@H@std@@QAEHXZ ; std::_Temp_iterator<int>::_Maxlen(void)
.text$mn:00004919                 cmp     [ebp+var_4], eax
.text$mn:0000491C                 jg      short loc_4988
.text$mn:0000491E                 sub     esp, 10h
.text$mn:00004921                 mov     edx, esp
.text$mn:00004923                 mov     eax, [ebp+arg_10]
.text$mn:00004926                 mov     [edx], eax
.text$mn:00004928                 mov     ecx, [ebp+arg_14]
.text$mn:0000492B                 mov     [edx+4], ecx
.text$mn:0000492E                 mov     eax, [ebp+arg_18]
.text$mn:00004931                 mov     [edx+8], eax
.text$mn:00004934                 mov     ecx, [ebp+arg_1C]
.text$mn:00004937                 mov     [edx+0Ch], ecx
.text$mn:0000493A                 mov     edx, [ebp+arg_C]
.text$mn:0000493D                 push    edx             ; int
.text$mn:0000493E                 mov     eax, [ebp+var_4]
.text$mn:00004941                 push    eax             ; int
.text$mn:00004942                 mov     ecx, [ebp+Dst]
.text$mn:00004945                 push    ecx             ; int
.text$mn:00004946                 mov     edx, [ebp+Src]
.text$mn:00004949                 push    edx             ; Dst
.text$mn:0000494A                 call    ??$_Buffered_merge_sort@PAHHHUBufferEquivalent@@@std@@YAXPAH0HAAV?$_Temp_iterator@H@0@UBufferEquivalent@@@Z ; std::_Buffered_merge_sort<int *,int,int,BufferEquivalent>(int *,int *,int,std::_Temp_iterator<int> &,BufferEquivalent)
.text$mn:0000494F                 add     esp, 10h
.text$mn:00004952                 mov     eax, esp
.text$mn:00004954                 mov     ecx, [ebp+arg_10]
.text$mn:00004957                 mov     [eax], ecx
.text$mn:00004959                 mov     edx, [ebp+arg_14]
.text$mn:0000495C                 mov     [eax+4], edx
.text$mn:0000495F                 mov     ecx, [ebp+arg_18]
.text$mn:00004962                 mov     [eax+8], ecx
.text$mn:00004965                 mov     edx, [ebp+arg_1C]
.text$mn:00004968                 mov     [eax+0Ch], edx
.text$mn:0000496B                 mov     eax, [ebp+arg_C]
.text$mn:0000496E                 push    eax             ; int
.text$mn:0000496F                 mov     ecx, [ebp+arg_8]
.text$mn:00004972                 sub     ecx, [ebp+var_4]
.text$mn:00004975                 push    ecx             ; int
.text$mn:00004976                 mov     edx, [ebp+arg_4]
.text$mn:00004979                 push    edx             ; int
.text$mn:0000497A                 mov     eax, [ebp+Dst]
.text$mn:0000497D                 push    eax             ; Dst
.text$mn:0000497E                 call    ??$_Buffered_merge_sort@PAHHHUBufferEquivalent@@@std@@YAXPAH0HAAV?$_Temp_iterator@H@0@UBufferEquivalent@@@Z ; std::_Buffered_merge_sort<int *,int,int,BufferEquivalent>(int *,int *,int,std::_Temp_iterator<int> &,BufferEquivalent)
.text$mn:00004983                 add     esp, 20h
.text$mn:00004986                 jmp     short loc_49F0
.text$mn:00004988 ; ---------------------------------------------------------------------------
.text$mn:00004988
.text$mn:00004988 loc_4988:                               ; CODE XREF: std::_Stable_sort<int *,int,int,BufferEquivalent>(int *,int *,int,std::_Temp_iterator<int> &,BufferEquivalent)+6Cj
.text$mn:00004988                 sub     esp, 10h
.text$mn:0000498B                 mov     ecx, esp
.text$mn:0000498D                 mov     edx, [ebp+arg_10]
.text$mn:00004990                 mov     [ecx], edx
.text$mn:00004992                 mov     eax, [ebp+arg_14]
.text$mn:00004995                 mov     [ecx+4], eax
.text$mn:00004998                 mov     edx, [ebp+arg_18]
.text$mn:0000499B                 mov     [ecx+8], edx
.text$mn:0000499E                 mov     eax, [ebp+arg_1C]
.text$mn:000049A1                 mov     [ecx+0Ch], eax
.text$mn:000049A4                 mov     ecx, [ebp+arg_C]
.text$mn:000049A7                 push    ecx             ; int
.text$mn:000049A8                 mov     edx, [ebp+var_4]
.text$mn:000049AB                 push    edx             ; int
.text$mn:000049AC                 mov     eax, [ebp+Dst]
.text$mn:000049AF                 push    eax             ; int
.text$mn:000049B0                 mov     ecx, [ebp+Src]
.text$mn:000049B3                 push    ecx             ; Src
.text$mn:000049B4                 call    ??$_Stable_sort@PAHHHUBufferEquivalent@@@std@@YAXPAH0HAAV?$_Temp_iterator@H@0@UBufferEquivalent@@@Z ; std::_Stable_sort<int *,int,int,BufferEquivalent>(int *,int *,int,std::_Temp_iterator<int> &,BufferEquivalent)
.text$mn:000049B9                 add     esp, 10h
.text$mn:000049BC                 mov     edx, esp
.text$mn:000049BE                 mov     eax, [ebp+arg_10]
.text$mn:000049C1                 mov     [edx], eax
.text$mn:000049C3                 mov     ecx, [ebp+arg_14]
.text$mn:000049C6                 mov     [edx+4], ecx
.text$mn:000049C9                 mov     eax, [ebp+arg_18]
.text$mn:000049CC                 mov     [edx+8], eax
.text$mn:000049CF                 mov     ecx, [ebp+arg_1C]
.text$mn:000049D2                 mov     [edx+0Ch], ecx
.text$mn:000049D5                 mov     edx, [ebp+arg_C]
.text$mn:000049D8                 push    edx             ; int
.text$mn:000049D9                 mov     eax, [ebp+arg_8]
.text$mn:000049DC                 sub     eax, [ebp+var_4]
.text$mn:000049DF                 push    eax             ; int
.text$mn:000049E0                 mov     ecx, [ebp+arg_4]
.text$mn:000049E3                 push    ecx             ; int
.text$mn:000049E4                 mov     edx, [ebp+Dst]
.text$mn:000049E7                 push    edx             ; Src
.text$mn:000049E8                 call    ??$_Stable_sort@PAHHHUBufferEquivalent@@@std@@YAXPAH0HAAV?$_Temp_iterator@H@0@UBufferEquivalent@@@Z ; std::_Stable_sort<int *,int,int,BufferEquivalent>(int *,int *,int,std::_Temp_iterator<int> &,BufferEquivalent)
.text$mn:000049ED                 add     esp, 20h
.text$mn:000049F0
.text$mn:000049F0 loc_49F0:                               ; CODE XREF: std::_Stable_sort<int *,int,int,BufferEquivalent>(int *,int *,int,std::_Temp_iterator<int> &,BufferEquivalent)+D6j
.text$mn:000049F0                 sub     esp, 10h
.text$mn:000049F3                 mov     eax, esp
.text$mn:000049F5                 mov     ecx, [ebp+arg_10]
.text$mn:000049F8                 mov     [eax], ecx
.text$mn:000049FA                 mov     edx, [ebp+arg_14]
.text$mn:000049FD                 mov     [eax+4], edx
.text$mn:00004A00                 mov     ecx, [ebp+arg_18]
.text$mn:00004A03                 mov     [eax+8], ecx
.text$mn:00004A06                 mov     edx, [ebp+arg_1C]
.text$mn:00004A09                 mov     [eax+0Ch], edx
.text$mn:00004A0C                 mov     eax, [ebp+arg_C]
.text$mn:00004A0F                 push    eax             ; int
.text$mn:00004A10                 mov     ecx, [ebp+arg_8]
.text$mn:00004A13                 sub     ecx, [ebp+var_4]
.text$mn:00004A16                 push    ecx             ; int
.text$mn:00004A17                 mov     edx, [ebp+var_4]
.text$mn:00004A1A                 push    edx             ; int
.text$mn:00004A1B                 mov     eax, [ebp+arg_4]
.text$mn:00004A1E                 push    eax             ; int
.text$mn:00004A1F                 mov     ecx, [ebp+Dst]
.text$mn:00004A22                 push    ecx             ; Src
.text$mn:00004A23                 mov     edx, [ebp+Src]
.text$mn:00004A26                 push    edx             ; Dst
.text$mn:00004A27                 call    ??$_Buffered_merge@PAHHHUBufferEquivalent@@@std@@YAXPAH00HHAAV?$_Temp_iterator@H@0@UBufferEquivalent@@@Z ; std::_Buffered_merge<int *,int,int,BufferEquivalent>(int *,int *,int *,int,int,std::_Temp_iterator<int> &,BufferEquivalent)
.text$mn:00004A2C                 add     esp, 28h
.text$mn:00004A2F
.text$mn:00004A2F loc_4A2F:                               ; CODE XREF: std::_Stable_sort<int *,int,int,BufferEquivalent>(int *,int *,int,std::_Temp_iterator<int> &,BufferEquivalent)+38j
.text$mn:00004A2F                 mov     esp, ebp
.text$mn:00004A31                 pop     ebp
.text$mn:00004A32                 retn
.text$mn:00004A32 ??$_Stable_sort@PAHHHUBufferEquivalent@@@std@@YAXPAH0HAAV?$_Temp_iterator@H@0@UBufferEquivalent@@@Z endp
.text$mn:00004A32
.text$mn:00004A32 ; ---------------------------------------------------------------------------
.text$mn:00004A33                 align 4
.text$mn:00004A33 _text$mn        ends
.text$mn:00004A33
.text$mn:00004A34 ; ===========================================================================
.text$mn:00004A34
.text$mn:00004A34 ; Segment type: Pure code
.text$mn:00004A34 ; Segment permissions: Read/Execute
.text$mn:00004A34 _text$mn        segment para public 'CODE' use32
.text$mn:00004A34                 assume cs:_text$mn
.text$mn:00004A34                 ;org 4A34h
.text$mn:00004A34 ; COMDAT (pick any)
.text$mn:00004A34                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004A34
.text$mn:00004A34 ; =============== S U B R O U T I N E =======================================
.text$mn:00004A34
.text$mn:00004A34 ; Attributes: bp-based frame
.text$mn:00004A34
.text$mn:00004A34 ; protected: wchar_t * __thiscall std::vector<wchar_t, class std::allocator<wchar_t>>::_Ucopy<class std::_String_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>>>(class std::_String_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>>, class std::_String_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>>, wchar_t *)
.text$mn:00004A34                 public ??$_Ucopy@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$vector@_WV?$allocator@_W@std@@@std@@IAEPA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0PA_W@Z
.text$mn:00004A34 ??$_Ucopy@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$vector@_WV?$allocator@_W@std@@@std@@IAEPA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0PA_W@Z proc near
.text$mn:00004A34                                         ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::_Construct<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::forward_iterator_tag)+E6p
.text$mn:00004A34
.text$mn:00004A34 var_34          = dword ptr -34h
.text$mn:00004A34 var_30          = dword ptr -30h
.text$mn:00004A34 var_2C          = dword ptr -2Ch
.text$mn:00004A34 var_28          = dword ptr -28h
.text$mn:00004A34 var_24          = dword ptr -24h
.text$mn:00004A34 var_20          = dword ptr -20h
.text$mn:00004A34 var_1C          = dword ptr -1Ch
.text$mn:00004A34 var_18          = dword ptr -18h
.text$mn:00004A34 var_14          = dword ptr -14h
.text$mn:00004A34 var_D           = byte ptr -0Dh
.text$mn:00004A34 var_C           = dword ptr -0Ch
.text$mn:00004A34 var_4           = dword ptr -4
.text$mn:00004A34 arg_0           = byte ptr  8
.text$mn:00004A34 arg_C           = byte ptr  14h
.text$mn:00004A34 arg_18          = dword ptr  20h
.text$mn:00004A34
.text$mn:00004A34                 push    ebp
.text$mn:00004A35                 mov     ebp, esp
.text$mn:00004A37                 push    0FFFFFFFFh
.text$mn:00004A39                 push    offset __ehhandler$??$_Ucopy@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$vector@_WV?$allocator@_W@std@@@std@@IAEPA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0PA_W@Z
.text$mn:00004A3E                 mov     eax, large fs:0
.text$mn:00004A44                 push    eax
.text$mn:00004A45                 sub     esp, 28h
.text$mn:00004A48                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004A4D                 xor     eax, ebp
.text$mn:00004A4F                 push    eax
.text$mn:00004A50                 lea     eax, [ebp+var_C]
.text$mn:00004A53                 mov     large fs:0, eax
.text$mn:00004A59                 mov     [ebp+var_14], ecx
.text$mn:00004A5C                 mov     [ebp+var_4], 1
.text$mn:00004A63                 lea     eax, [ebp+var_D]
.text$mn:00004A66                 push    eax
.text$mn:00004A67                 mov     ecx, [ebp+var_14]
.text$mn:00004A6A                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:00004A6F                 lea     ecx, [ebp+var_D]
.text$mn:00004A72                 push    ecx
.text$mn:00004A73                 mov     edx, [ebp+arg_18]
.text$mn:00004A76                 push    edx
.text$mn:00004A77                 sub     esp, 0Ch
.text$mn:00004A7A                 mov     ecx, esp
.text$mn:00004A7C                 mov     [ebp+var_28], esp
.text$mn:00004A7F                 lea     eax, [ebp+arg_C]
.text$mn:00004A82                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00004A83                 call    ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:00004A88                 mov     [ebp+var_18], eax
.text$mn:00004A8B                 mov     ecx, [ebp+var_18]
.text$mn:00004A8E                 mov     [ebp+var_2C], ecx
.text$mn:00004A91                 mov     byte ptr [ebp+var_4], 2
.text$mn:00004A95                 sub     esp, 0Ch
.text$mn:00004A98                 mov     ecx, esp
.text$mn:00004A9A                 mov     [ebp+var_30], esp
.text$mn:00004A9D                 lea     edx, [ebp+arg_0]
.text$mn:00004AA0                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:00004AA1                 call    ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:00004AA6                 mov     [ebp+var_1C], eax
.text$mn:00004AA9                 mov     eax, [ebp+var_1C]
.text$mn:00004AAC                 mov     [ebp+var_34], eax
.text$mn:00004AAF                 mov     byte ptr [ebp+var_4], 3
.text$mn:00004AB3                 mov     byte ptr [ebp+var_4], 1
.text$mn:00004AB7                 call    ??$_Uninitialized_copy@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@PA_WU?$_Wrap_alloc@V?$allocator@_W@std@@@2@@std@@YAPA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0PA_WAAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@@Z ; std::_Uninitialized_copy<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,wchar_t *,std::_Wrap_alloc<std::allocator<wchar_t>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,wchar_t *,std::_Wrap_alloc<std::allocator<wchar_t>> &)
.text$mn:00004ABC                 add     esp, 20h
.text$mn:00004ABF                 mov     [ebp+var_20], eax
.text$mn:00004AC2                 mov     ecx, [ebp+var_20]
.text$mn:00004AC5                 mov     [ebp+var_24], ecx
.text$mn:00004AC8                 mov     byte ptr [ebp+var_4], 0
.text$mn:00004ACC                 lea     ecx, [ebp+arg_0]
.text$mn:00004ACF                 call    ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$mn:00004AD4                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004ADB                 lea     ecx, [ebp+arg_C]
.text$mn:00004ADE                 call    ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$mn:00004AE3                 mov     eax, [ebp+var_24]
.text$mn:00004AE6                 mov     ecx, [ebp+var_C]
.text$mn:00004AE9                 mov     large fs:0, ecx
.text$mn:00004AF0                 pop     ecx
.text$mn:00004AF1                 mov     esp, ebp
.text$mn:00004AF3                 pop     ebp
.text$mn:00004AF4                 retn    1Ch
.text$mn:00004AF4 ??$_Ucopy@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$vector@_WV?$allocator@_W@std@@@std@@IAEPA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0PA_W@Z endp
.text$mn:00004AF4
.text$mn:00004AF4 ; ---------------------------------------------------------------------------
.text$mn:00004AF7                 align 4
.text$mn:00004AF7 _text$mn        ends
.text$mn:00004AF7
.text$x:00004AF8 ; ===========================================================================
.text$x:00004AF8
.text$x:00004AF8 ; Segment type: Pure code
.text$x:00004AF8 ; Segment permissions: Read/Execute
.text$x:00004AF8 _text$x         segment para public 'CODE' use32
.text$x:00004AF8                 assume cs:_text$x
.text$x:00004AF8                 ;org 4AF8h
.text$x:00004AF8 ; COMDAT (pick associative to section at 4A34)
.text$x:00004AF8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00004AF8
.text$x:00004AF8 ; =============== S U B R O U T I N E =======================================
.text$x:00004AF8
.text$x:00004AF8
.text$x:00004AF8 __unwindfunclet$??$_Ucopy@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$vector@_WV?$allocator@_W@std@@@std@@IAEPA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0PA_W@Z$0 proc near
.text$x:00004AF8                                         ; DATA XREF: .xdata$x:0000D9F4o
.text$x:00004AF8                 lea     ecx, [ebp+14h]
.text$x:00004AFB                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00004AFB __unwindfunclet$??$_Ucopy@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$vector@_WV?$allocator@_W@std@@@std@@IAEPA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0PA_W@Z$0 endp
.text$x:00004AFB
.text$x:00004B00
.text$x:00004B00 ; =============== S U B R O U T I N E =======================================
.text$x:00004B00
.text$x:00004B00
.text$x:00004B00 __unwindfunclet$??$_Ucopy@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$vector@_WV?$allocator@_W@std@@@std@@IAEPA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0PA_W@Z$1 proc near
.text$x:00004B00                                         ; DATA XREF: .xdata$x:0000D9FCo
.text$x:00004B00                 lea     ecx, [ebp+8]
.text$x:00004B03                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00004B03 __unwindfunclet$??$_Ucopy@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$vector@_WV?$allocator@_W@std@@@std@@IAEPA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0PA_W@Z$1 endp
.text$x:00004B03
.text$x:00004B08
.text$x:00004B08 ; =============== S U B R O U T I N E =======================================
.text$x:00004B08
.text$x:00004B08
.text$x:00004B08 __unwindfunclet$??$_Ucopy@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$vector@_WV?$allocator@_W@std@@@std@@IAEPA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0PA_W@Z$2 proc near
.text$x:00004B08                                         ; DATA XREF: .xdata$x:0000DA04o
.text$x:00004B08                 mov     ecx, [ebp-28h]
.text$x:00004B0B                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00004B0B __unwindfunclet$??$_Ucopy@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$vector@_WV?$allocator@_W@std@@@std@@IAEPA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0PA_W@Z$2 endp
.text$x:00004B0B
.text$x:00004B10
.text$x:00004B10 ; =============== S U B R O U T I N E =======================================
.text$x:00004B10
.text$x:00004B10
.text$x:00004B10 __unwindfunclet$??$_Ucopy@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$vector@_WV?$allocator@_W@std@@@std@@IAEPA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0PA_W@Z$3 proc near
.text$x:00004B10                                         ; DATA XREF: .xdata$x:0000DA0Co
.text$x:00004B10                 mov     ecx, [ebp-30h]
.text$x:00004B13                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00004B13 __unwindfunclet$??$_Ucopy@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$vector@_WV?$allocator@_W@std@@@std@@IAEPA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0PA_W@Z$3 endp
.text$x:00004B13
.text$x:00004B18
.text$x:00004B18 ; =============== S U B R O U T I N E =======================================
.text$x:00004B18
.text$x:00004B18
.text$x:00004B18 __ehhandler$??$_Ucopy@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$vector@_WV?$allocator@_W@std@@@std@@IAEPA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0PA_W@Z proc near
.text$x:00004B18                                         ; DATA XREF: std::vector<wchar_t,std::allocator<wchar_t>>::_Ucopy<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,wchar_t *)+5o
.text$x:00004B18
.text$x:00004B18 arg_4           = dword ptr  8
.text$x:00004B18
.text$x:00004B18                 mov     edx, [esp+arg_4]
.text$x:00004B1C                 lea     eax, [edx+0Ch]
.text$x:00004B1F                 mov     ecx, [edx-2Ch]
.text$x:00004B22                 xor     ecx, eax
.text$x:00004B24                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004B29                 mov     eax, offset __ehfuncinfo$??$_Ucopy@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$vector@_WV?$allocator@_W@std@@@std@@IAEPA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0PA_W@Z
.text$x:00004B2E                 jmp     ___CxxFrameHandler3
.text$x:00004B2E __ehhandler$??$_Ucopy@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$vector@_WV?$allocator@_W@std@@@std@@IAEPA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0PA_W@Z endp
.text$x:00004B2E
.text$x:00004B2E ; ---------------------------------------------------------------------------
.text$x:00004B33                 align 4
.text$x:00004B33 _text$x         ends
.text$x:00004B33
.text$mn:00004B34 ; ===========================================================================
.text$mn:00004B34
.text$mn:00004B34 ; Segment type: Pure code
.text$mn:00004B34 ; Segment permissions: Read/Execute
.text$mn:00004B34 _text$mn        segment para public 'CODE' use32
.text$mn:00004B34                 assume cs:_text$mn
.text$mn:00004B34                 ;org 4B34h
.text$mn:00004B34 ; COMDAT (pick any)
.text$mn:00004B34                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004B34
.text$mn:00004B34 ; =============== S U B R O U T I N E =======================================
.text$mn:00004B34
.text$mn:00004B34 ; Attributes: bp-based frame
.text$mn:00004B34
.text$mn:00004B34 ; protected: int * __thiscall std::vector<int, class std::allocator<int>>::_Umove<int *>(int *, int *, int *)
.text$mn:00004B34                 public ??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z
.text$mn:00004B34 ??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z proc near
.text$mn:00004B34                                         ; CODE XREF: std::vector<int,std::allocator<int>>::_Reallocate(uint)+65p
.text$mn:00004B34
.text$mn:00004B34 var_8           = dword ptr -8
.text$mn:00004B34 var_1           = byte ptr -1
.text$mn:00004B34 arg_0           = dword ptr  8
.text$mn:00004B34 arg_4           = dword ptr  0Ch
.text$mn:00004B34 arg_8           = dword ptr  10h
.text$mn:00004B34
.text$mn:00004B34                 push    ebp
.text$mn:00004B35                 mov     ebp, esp
.text$mn:00004B37                 sub     esp, 8
.text$mn:00004B3A                 mov     [ebp+var_8], ecx
.text$mn:00004B3D                 lea     eax, [ebp+var_1]
.text$mn:00004B40                 push    eax
.text$mn:00004B41                 mov     ecx, [ebp+var_8]
.text$mn:00004B44                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@H@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>::_Getal(void)
.text$mn:00004B49                 lea     ecx, [ebp+var_1]
.text$mn:00004B4C                 push    ecx
.text$mn:00004B4D                 mov     edx, [ebp+arg_8]
.text$mn:00004B50                 push    edx
.text$mn:00004B51                 mov     eax, [ebp+arg_4]
.text$mn:00004B54                 push    eax
.text$mn:00004B55                 mov     ecx, [ebp+arg_0]
.text$mn:00004B58                 push    ecx
.text$mn:00004B59                 call    ??$_Uninitialized_move@PAHPAHU?$_Wrap_alloc@V?$allocator@H@std@@@std@@@std@@YAPAHPAH00AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@@Z ; std::_Uninitialized_move<int *,int *,std::_Wrap_alloc<std::allocator<int>>>(int *,int *,int *,std::_Wrap_alloc<std::allocator<int>> &)
.text$mn:00004B5E                 add     esp, 10h
.text$mn:00004B61                 mov     esp, ebp
.text$mn:00004B63                 pop     ebp
.text$mn:00004B64                 retn    0Ch
.text$mn:00004B64 ??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z endp
.text$mn:00004B64
.text$mn:00004B64 ; ---------------------------------------------------------------------------
.text$mn:00004B67                 align 4
.text$mn:00004B67 _text$mn        ends
.text$mn:00004B67
.text$mn:00004B68 ; ===========================================================================
.text$mn:00004B68
.text$mn:00004B68 ; Segment type: Pure code
.text$mn:00004B68 ; Segment permissions: Read/Execute
.text$mn:00004B68 _text$mn        segment para public 'CODE' use32
.text$mn:00004B68                 assume cs:_text$mn
.text$mn:00004B68                 ;org 4B68h
.text$mn:00004B68 ; COMDAT (pick any)
.text$mn:00004B68                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004B68
.text$mn:00004B68 ; =============== S U B R O U T I N E =======================================
.text$mn:00004B68
.text$mn:00004B68 ; Attributes: bp-based frame
.text$mn:00004B68
.text$mn:00004B68 ; protected: wchar_t * __thiscall std::vector<wchar_t, class std::allocator<wchar_t>>::_Umove<wchar_t *>(wchar_t *, wchar_t *, wchar_t *)
.text$mn:00004B68                 public ??$_Umove@PA_W@?$vector@_WV?$allocator@_W@std@@@std@@IAEPA_WPA_W00@Z
.text$mn:00004B68 ??$_Umove@PA_W@?$vector@_WV?$allocator@_W@std@@@std@@IAEPA_WPA_W00@Z proc near
.text$mn:00004B68                                         ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::_Reallocate(uint)+65p
.text$mn:00004B68
.text$mn:00004B68 var_8           = dword ptr -8
.text$mn:00004B68 var_1           = byte ptr -1
.text$mn:00004B68 arg_0           = dword ptr  8
.text$mn:00004B68 arg_4           = dword ptr  0Ch
.text$mn:00004B68 arg_8           = dword ptr  10h
.text$mn:00004B68
.text$mn:00004B68                 push    ebp
.text$mn:00004B69                 mov     ebp, esp
.text$mn:00004B6B                 sub     esp, 8
.text$mn:00004B6E                 mov     [ebp+var_8], ecx
.text$mn:00004B71                 lea     eax, [ebp+var_1]
.text$mn:00004B74                 push    eax
.text$mn:00004B75                 mov     ecx, [ebp+var_8]
.text$mn:00004B78                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:00004B7D                 lea     ecx, [ebp+var_1]
.text$mn:00004B80                 push    ecx
.text$mn:00004B81                 mov     edx, [ebp+arg_8]
.text$mn:00004B84                 push    edx
.text$mn:00004B85                 mov     eax, [ebp+arg_4]
.text$mn:00004B88                 push    eax
.text$mn:00004B89                 mov     ecx, [ebp+arg_0]
.text$mn:00004B8C                 push    ecx
.text$mn:00004B8D                 call    ??$_Uninitialized_move@PA_WPA_WU?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YAPA_WPA_W00AAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@@Z ; std::_Uninitialized_move<wchar_t *,wchar_t *,std::_Wrap_alloc<std::allocator<wchar_t>>>(wchar_t *,wchar_t *,wchar_t *,std::_Wrap_alloc<std::allocator<wchar_t>> &)
.text$mn:00004B92                 add     esp, 10h
.text$mn:00004B95                 mov     esp, ebp
.text$mn:00004B97                 pop     ebp
.text$mn:00004B98                 retn    0Ch
.text$mn:00004B98 ??$_Umove@PA_W@?$vector@_WV?$allocator@_W@std@@@std@@IAEPA_WPA_W00@Z endp
.text$mn:00004B98
.text$mn:00004B98 ; ---------------------------------------------------------------------------
.text$mn:00004B9B                 align 4
.text$mn:00004B9B _text$mn        ends
.text$mn:00004B9B
.text$mn:00004B9C ; ===========================================================================
.text$mn:00004B9C
.text$mn:00004B9C ; Segment type: Pure code
.text$mn:00004B9C ; Segment permissions: Read/Execute
.text$mn:00004B9C _text$mn        segment para public 'CODE' use32
.text$mn:00004B9C                 assume cs:_text$mn
.text$mn:00004B9C                 ;org 4B9Ch
.text$mn:00004B9C ; COMDAT (pick any)
.text$mn:00004B9C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004B9C
.text$mn:00004B9C ; =============== S U B R O U T I N E =======================================
.text$mn:00004B9C
.text$mn:00004B9C ; Attributes: bp-based frame
.text$mn:00004B9C
.text$mn:00004B9C ; int * __cdecl std::_Unchecked<int *>(int *)
.text$mn:00004B9C                 public ??$_Unchecked@PAH@std@@YAPAHPAH@Z
.text$mn:00004B9C ??$_Unchecked@PAH@std@@YAPAHPAH@Z proc near
.text$mn:00004B9C                                         ; CODE XREF: std::_Uninitialized_move<int *,int *,std::_Wrap_alloc<std::allocator<int>>>(int *,int *,int *,std::_Wrap_alloc<std::allocator<int>> &)+Bp
.text$mn:00004B9C                                         ; std::_Uninitialized_move<int *,int *,std::_Wrap_alloc<std::allocator<int>>>(int *,int *,int *,std::_Wrap_alloc<std::allocator<int>> &)+18p ...
.text$mn:00004B9C
.text$mn:00004B9C arg_0           = dword ptr  8
.text$mn:00004B9C
.text$mn:00004B9C                 push    ebp
.text$mn:00004B9D                 mov     ebp, esp
.text$mn:00004B9F                 mov     eax, [ebp+arg_0]
.text$mn:00004BA2                 pop     ebp
.text$mn:00004BA3                 retn
.text$mn:00004BA3 ??$_Unchecked@PAH@std@@YAPAHPAH@Z endp
.text$mn:00004BA3
.text$mn:00004BA3 _text$mn        ends
.text$mn:00004BA3
.text$mn:00004BA4 ; ===========================================================================
.text$mn:00004BA4
.text$mn:00004BA4 ; Segment type: Pure code
.text$mn:00004BA4 ; Segment permissions: Read/Execute
.text$mn:00004BA4 _text$mn        segment para public 'CODE' use32
.text$mn:00004BA4                 assume cs:_text$mn
.text$mn:00004BA4                 ;org 4BA4h
.text$mn:00004BA4 ; COMDAT (pick any)
.text$mn:00004BA4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004BA4
.text$mn:00004BA4 ; =============== S U B R O U T I N E =======================================
.text$mn:00004BA4
.text$mn:00004BA4 ; Attributes: bp-based frame
.text$mn:00004BA4
.text$mn:00004BA4 ; wchar_t * __cdecl std::_Unchecked<wchar_t *>(wchar_t *)
.text$mn:00004BA4                 public ??$_Unchecked@PA_W@std@@YAPA_WPA_W@Z
.text$mn:00004BA4 ??$_Unchecked@PA_W@std@@YAPA_WPA_W@Z proc near
.text$mn:00004BA4                                         ; CODE XREF: std::_Uninitialized_copy<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,wchar_t *,std::_Wrap_alloc<std::allocator<wchar_t>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,wchar_t *,std::_Wrap_alloc<std::allocator<wchar_t>> &)+34p
.text$mn:00004BA4                                         ; std::_Uninitialized_move<wchar_t *,wchar_t *,std::_Wrap_alloc<std::allocator<wchar_t>>>(wchar_t *,wchar_t *,wchar_t *,std::_Wrap_alloc<std::allocator<wchar_t>> &)+Bp ...
.text$mn:00004BA4
.text$mn:00004BA4 arg_0           = dword ptr  8
.text$mn:00004BA4
.text$mn:00004BA4                 push    ebp
.text$mn:00004BA5                 mov     ebp, esp
.text$mn:00004BA7                 mov     eax, [ebp+arg_0]
.text$mn:00004BAA                 pop     ebp
.text$mn:00004BAB                 retn
.text$mn:00004BAB ??$_Unchecked@PA_W@std@@YAPA_WPA_W@Z endp
.text$mn:00004BAB
.text$mn:00004BAB _text$mn        ends
.text$mn:00004BAB
.text$mn:00004BAC ; ===========================================================================
.text$mn:00004BAC
.text$mn:00004BAC ; Segment type: Pure code
.text$mn:00004BAC ; Segment permissions: Read/Execute
.text$mn:00004BAC _text$mn        segment para public 'CODE' use32
.text$mn:00004BAC                 assume cs:_text$mn
.text$mn:00004BAC                 ;org 4BACh
.text$mn:00004BAC ; COMDAT (pick any)
.text$mn:00004BAC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004BAC
.text$mn:00004BAC ; =============== S U B R O U T I N E =======================================
.text$mn:00004BAC
.text$mn:00004BAC ; Attributes: bp-based frame
.text$mn:00004BAC
.text$mn:00004BAC ; wchar_t * __cdecl std::_Unchecked<class std::_String_val<struct std::_Simple_types<wchar_t>>>(class std::_String_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>>)
.text$mn:00004BAC                 public ??$_Unchecked@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@@Z
.text$mn:00004BAC ??$_Unchecked@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@@Z proc near
.text$mn:00004BAC                                         ; CODE XREF: std::_Uninitialized_copy<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,wchar_t *,std::_Wrap_alloc<std::allocator<wchar_t>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,wchar_t *,std::_Wrap_alloc<std::allocator<wchar_t>> &)+5Fp
.text$mn:00004BAC                                         ; std::_Uninitialized_copy<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,wchar_t *,std::_Wrap_alloc<std::allocator<wchar_t>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,wchar_t *,std::_Wrap_alloc<std::allocator<wchar_t>> &)+90p
.text$mn:00004BAC
.text$mn:00004BAC var_10          = dword ptr -10h
.text$mn:00004BAC var_C           = dword ptr -0Ch
.text$mn:00004BAC var_4           = dword ptr -4
.text$mn:00004BAC arg_0           = byte ptr  8
.text$mn:00004BAC
.text$mn:00004BAC                 push    ebp
.text$mn:00004BAD                 mov     ebp, esp
.text$mn:00004BAF                 push    0FFFFFFFFh
.text$mn:00004BB1                 push    offset __ehhandler$??$_Unchecked@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@@Z
.text$mn:00004BB6                 mov     eax, large fs:0
.text$mn:00004BBC                 push    eax
.text$mn:00004BBD                 push    ecx
.text$mn:00004BBE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004BC3                 xor     eax, ebp
.text$mn:00004BC5                 push    eax
.text$mn:00004BC6                 lea     eax, [ebp+var_C]
.text$mn:00004BC9                 mov     large fs:0, eax
.text$mn:00004BCF                 mov     [ebp+var_4], 0
.text$mn:00004BD6                 lea     ecx, [ebp+arg_0]
.text$mn:00004BD9                 call    ?_Unchecked@?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEPA_WXZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_Unchecked(void)
.text$mn:00004BDE                 mov     [ebp+var_10], eax
.text$mn:00004BE1                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004BE8                 lea     ecx, [ebp+arg_0]
.text$mn:00004BEB                 call    ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$mn:00004BF0                 mov     eax, [ebp+var_10]
.text$mn:00004BF3                 mov     ecx, [ebp+var_C]
.text$mn:00004BF6                 mov     large fs:0, ecx
.text$mn:00004BFD                 pop     ecx
.text$mn:00004BFE                 mov     esp, ebp
.text$mn:00004C00                 pop     ebp
.text$mn:00004C01                 retn
.text$mn:00004C01 ??$_Unchecked@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@@Z endp
.text$mn:00004C01
.text$mn:00004C01 ; ---------------------------------------------------------------------------
.text$mn:00004C02                 align 4
.text$mn:00004C02 _text$mn        ends
.text$mn:00004C02
.text$x:00004C04 ; ===========================================================================
.text$x:00004C04
.text$x:00004C04 ; Segment type: Pure code
.text$x:00004C04 ; Segment permissions: Read/Execute
.text$x:00004C04 _text$x         segment para public 'CODE' use32
.text$x:00004C04                 assume cs:_text$x
.text$x:00004C04                 ;org 4C04h
.text$x:00004C04 ; COMDAT (pick associative to section at 4BAC)
.text$x:00004C04                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00004C04
.text$x:00004C04 ; =============== S U B R O U T I N E =======================================
.text$x:00004C04
.text$x:00004C04
.text$x:00004C04 __unwindfunclet$??$_Unchecked@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@@Z$0 proc near
.text$x:00004C04                                         ; DATA XREF: .xdata$x:0000DBECo
.text$x:00004C04                 lea     ecx, [ebp+8]
.text$x:00004C07                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00004C07 __unwindfunclet$??$_Unchecked@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@@Z$0 endp
.text$x:00004C07
.text$x:00004C0C
.text$x:00004C0C ; =============== S U B R O U T I N E =======================================
.text$x:00004C0C
.text$x:00004C0C
.text$x:00004C0C __ehhandler$??$_Unchecked@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@@Z proc near
.text$x:00004C0C                                         ; DATA XREF: std::_Unchecked<std::_String_val<std::_Simple_types<wchar_t>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)+5o
.text$x:00004C0C
.text$x:00004C0C arg_4           = dword ptr  8
.text$x:00004C0C
.text$x:00004C0C                 mov     edx, [esp+arg_4]
.text$x:00004C10                 lea     eax, [edx+0Ch]
.text$x:00004C13                 mov     ecx, [edx-8]
.text$x:00004C16                 xor     ecx, eax
.text$x:00004C18                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004C1D                 mov     eax, offset __ehfuncinfo$??$_Unchecked@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@@Z
.text$x:00004C22                 jmp     ___CxxFrameHandler3
.text$x:00004C22 __ehhandler$??$_Unchecked@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@@Z endp
.text$x:00004C22
.text$x:00004C22 ; ---------------------------------------------------------------------------
.text$x:00004C27                 align 4
.text$x:00004C27 _text$x         ends
.text$x:00004C27
.text$mn:00004C28 ; ===========================================================================
.text$mn:00004C28
.text$mn:00004C28 ; Segment type: Pure code
.text$mn:00004C28 ; Segment permissions: Read/Execute
.text$mn:00004C28 _text$mn        segment para public 'CODE' use32
.text$mn:00004C28                 assume cs:_text$mn
.text$mn:00004C28                 ;org 4C28h
.text$mn:00004C28 ; COMDAT (pick any)
.text$mn:00004C28                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004C28
.text$mn:00004C28 ; =============== S U B R O U T I N E =======================================
.text$mn:00004C28
.text$mn:00004C28 ; Attributes: bp-based frame
.text$mn:00004C28
.text$mn:00004C28 ; int * __cdecl std::_Unchecked<class std::_Vector_val<struct std::_Simple_types<int>>>(class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<int>>>)
.text$mn:00004C28                 public ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@YAPAHV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@@Z
.text$mn:00004C28 ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@YAPAHV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@@Z proc near
.text$mn:00004C28                                         ; CODE XREF: std::find_if<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::binder2nd<std::equal_to<int>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::binder2nd<std::equal_to<int>>)+BFp
.text$mn:00004C28                                         ; std::find_if<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::binder2nd<std::equal_to<int>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::binder2nd<std::equal_to<int>>)+F0p ...
.text$mn:00004C28
.text$mn:00004C28 var_10          = dword ptr -10h
.text$mn:00004C28 var_C           = dword ptr -0Ch
.text$mn:00004C28 var_4           = dword ptr -4
.text$mn:00004C28 arg_0           = byte ptr  8
.text$mn:00004C28
.text$mn:00004C28                 push    ebp
.text$mn:00004C29                 mov     ebp, esp
.text$mn:00004C2B                 push    0FFFFFFFFh
.text$mn:00004C2D                 push    offset __ehhandler$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@YAPAHV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@@Z
.text$mn:00004C32                 mov     eax, large fs:0
.text$mn:00004C38                 push    eax
.text$mn:00004C39                 push    ecx
.text$mn:00004C3A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004C3F                 xor     eax, ebp
.text$mn:00004C41                 push    eax
.text$mn:00004C42                 lea     eax, [ebp+var_C]
.text$mn:00004C45                 mov     large fs:0, eax
.text$mn:00004C4B                 mov     [ebp+var_4], 0
.text$mn:00004C52                 lea     ecx, [ebp+arg_0]
.text$mn:00004C55                 call    ?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBEPAHXZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Unchecked(void)
.text$mn:00004C5A                 mov     [ebp+var_10], eax
.text$mn:00004C5D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004C64                 lea     ecx, [ebp+arg_0]
.text$mn:00004C67                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$mn:00004C6C                 mov     eax, [ebp+var_10]
.text$mn:00004C6F                 mov     ecx, [ebp+var_C]
.text$mn:00004C72                 mov     large fs:0, ecx
.text$mn:00004C79                 pop     ecx
.text$mn:00004C7A                 mov     esp, ebp
.text$mn:00004C7C                 pop     ebp
.text$mn:00004C7D                 retn
.text$mn:00004C7D ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@YAPAHV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@@Z endp
.text$mn:00004C7D
.text$mn:00004C7D ; ---------------------------------------------------------------------------
.text$mn:00004C7E                 align 10h
.text$mn:00004C7E _text$mn        ends
.text$mn:00004C7E
.text$x:00004C80 ; ===========================================================================
.text$x:00004C80
.text$x:00004C80 ; Segment type: Pure code
.text$x:00004C80 ; Segment permissions: Read/Execute
.text$x:00004C80 _text$x         segment para public 'CODE' use32
.text$x:00004C80                 assume cs:_text$x
.text$x:00004C80                 ;org 4C80h
.text$x:00004C80 ; COMDAT (pick associative to section at 4C28)
.text$x:00004C80                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00004C80
.text$x:00004C80 ; =============== S U B R O U T I N E =======================================
.text$x:00004C80
.text$x:00004C80
.text$x:00004C80 __unwindfunclet$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@YAPAHV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@@Z$0 proc near
.text$x:00004C80                                         ; DATA XREF: .xdata$x:0000D6C0o
.text$x:00004C80                 lea     ecx, [ebp+8]
.text$x:00004C83                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$x:00004C83 __unwindfunclet$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@YAPAHV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@@Z$0 endp
.text$x:00004C83
.text$x:00004C88
.text$x:00004C88 ; =============== S U B R O U T I N E =======================================
.text$x:00004C88
.text$x:00004C88
.text$x:00004C88 __ehhandler$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@YAPAHV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@@Z proc near
.text$x:00004C88                                         ; DATA XREF: std::_Unchecked<std::_Vector_val<std::_Simple_types<int>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>)+5o
.text$x:00004C88
.text$x:00004C88 arg_4           = dword ptr  8
.text$x:00004C88
.text$x:00004C88                 mov     edx, [esp+arg_4]
.text$x:00004C8C                 lea     eax, [edx+0Ch]
.text$x:00004C8F                 mov     ecx, [edx-8]
.text$x:00004C92                 xor     ecx, eax
.text$x:00004C94                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004C99                 mov     eax, offset __ehfuncinfo$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@YAPAHV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@@Z
.text$x:00004C9E                 jmp     ___CxxFrameHandler3
.text$x:00004C9E __ehhandler$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@YAPAHV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@@Z endp
.text$x:00004C9E
.text$x:00004C9E ; ---------------------------------------------------------------------------
.text$x:00004CA3                 align 4
.text$x:00004CA3 _text$x         ends
.text$x:00004CA3
.text$mn:00004CA4 ; ===========================================================================
.text$mn:00004CA4
.text$mn:00004CA4 ; Segment type: Pure code
.text$mn:00004CA4 ; Segment permissions: Read/Execute
.text$mn:00004CA4 _text$mn        segment para public 'CODE' use32
.text$mn:00004CA4                 assume cs:_text$mn
.text$mn:00004CA4                 ;org 4CA4h
.text$mn:00004CA4 ; COMDAT (pick any)
.text$mn:00004CA4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004CA4
.text$mn:00004CA4 ; =============== S U B R O U T I N E =======================================
.text$mn:00004CA4
.text$mn:00004CA4 ; Attributes: bp-based frame
.text$mn:00004CA4
.text$mn:00004CA4 ; int __cdecl std::_Uninit_copy<wchar_t *,wchar_t *,std::_Wrap_alloc<std::allocator<wchar_t>>>(void *Src, int, void *Dst, int)
.text$mn:00004CA4                 public ??$_Uninit_copy@PA_WPA_WU?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YAPA_WPA_W00AAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@@Z
.text$mn:00004CA4 ??$_Uninit_copy@PA_WPA_WU?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YAPA_WPA_W00AAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@@Z proc near
.text$mn:00004CA4                                         ; CODE XREF: std::_Uninitialized_copy<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,wchar_t *,std::_Wrap_alloc<std::allocator<wchar_t>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,wchar_t *,std::_Wrap_alloc<std::allocator<wchar_t>> &)+9Fp
.text$mn:00004CA4
.text$mn:00004CA4 var_1           = byte ptr -1
.text$mn:00004CA4 Src             = dword ptr  8
.text$mn:00004CA4 arg_4           = dword ptr  0Ch
.text$mn:00004CA4 Dst             = dword ptr  10h
.text$mn:00004CA4 arg_C           = dword ptr  14h
.text$mn:00004CA4
.text$mn:00004CA4                 push    ebp
.text$mn:00004CA5                 mov     ebp, esp
.text$mn:00004CA7                 push    ecx
.text$mn:00004CA8                 mov     eax, [ebp+Dst]
.text$mn:00004CAB                 push    eax
.text$mn:00004CAC                 mov     ecx, [ebp+Src]
.text$mn:00004CAF                 push    ecx
.text$mn:00004CB0                 call    ??$_Ptr_cat@_W_W@std@@YA?AU_Scalar_ptr_iterator_tag@0@PA_W0@Z ; std::_Ptr_cat<wchar_t,wchar_t>(wchar_t *,wchar_t *)
.text$mn:00004CB5                 add     esp, 8
.text$mn:00004CB8                 mov     [ebp+var_1], al
.text$mn:00004CBB                 movzx   edx, [ebp+var_1]
.text$mn:00004CBF                 push    edx
.text$mn:00004CC0                 mov     eax, [ebp+arg_C]
.text$mn:00004CC3                 push    eax
.text$mn:00004CC4                 mov     ecx, [ebp+Dst]
.text$mn:00004CC7                 push    ecx             ; Dst
.text$mn:00004CC8                 mov     edx, [ebp+arg_4]
.text$mn:00004CCB                 push    edx             ; int
.text$mn:00004CCC                 mov     eax, [ebp+Src]
.text$mn:00004CCF                 push    eax             ; Src
.text$mn:00004CD0                 call    ??$_Uninit_copy@_W_W@std@@YAPA_WPA_W00AAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<wchar_t,wchar_t>(wchar_t *,wchar_t *,wchar_t *,std::_Wrap_alloc<std::allocator<wchar_t>> &,std::_Scalar_ptr_iterator_tag)
.text$mn:00004CD5                 add     esp, 14h
.text$mn:00004CD8                 mov     esp, ebp
.text$mn:00004CDA                 pop     ebp
.text$mn:00004CDB                 retn
.text$mn:00004CDB ??$_Uninit_copy@PA_WPA_WU?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YAPA_WPA_W00AAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@@Z endp
.text$mn:00004CDB
.text$mn:00004CDB _text$mn        ends
.text$mn:00004CDB
.text$mn:00004CDC ; ===========================================================================
.text$mn:00004CDC
.text$mn:00004CDC ; Segment type: Pure code
.text$mn:00004CDC ; Segment permissions: Read/Execute
.text$mn:00004CDC _text$mn        segment para public 'CODE' use32
.text$mn:00004CDC                 assume cs:_text$mn
.text$mn:00004CDC                 ;org 4CDCh
.text$mn:00004CDC ; COMDAT (pick any)
.text$mn:00004CDC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004CDC
.text$mn:00004CDC ; =============== S U B R O U T I N E =======================================
.text$mn:00004CDC
.text$mn:00004CDC ; Attributes: bp-based frame
.text$mn:00004CDC
.text$mn:00004CDC ; int __cdecl std::_Uninit_copy<wchar_t,wchar_t>(void *Src, int, void *Dst)
.text$mn:00004CDC                 public ??$_Uninit_copy@_W_W@std@@YAPA_WPA_W00AAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
.text$mn:00004CDC ??$_Uninit_copy@_W_W@std@@YAPA_WPA_W00AAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z proc near
.text$mn:00004CDC                                         ; CODE XREF: std::_Uninit_copy<wchar_t *,wchar_t *,std::_Wrap_alloc<std::allocator<wchar_t>>>(wchar_t *,wchar_t *,wchar_t *,std::_Wrap_alloc<std::allocator<wchar_t>> &)+2Cp
.text$mn:00004CDC
.text$mn:00004CDC var_4           = dword ptr -4
.text$mn:00004CDC Src             = dword ptr  8
.text$mn:00004CDC arg_4           = dword ptr  0Ch
.text$mn:00004CDC Dst             = dword ptr  10h
.text$mn:00004CDC
.text$mn:00004CDC                 push    ebp
.text$mn:00004CDD                 mov     ebp, esp
.text$mn:00004CDF                 push    ecx
.text$mn:00004CE0                 push    192h            ; unsigned int
.text$mn:00004CE5                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00004CEA                 mov     eax, [ebp+arg_4]
.text$mn:00004CED                 push    eax             ; int
.text$mn:00004CEE                 mov     ecx, [ebp+Src]
.text$mn:00004CF1                 push    ecx             ; int
.text$mn:00004CF2                 call    ??$_Debug_range@PA_W@std@@YAXPA_W0PB_WI@Z ; std::_Debug_range<wchar_t *>(wchar_t *,wchar_t *,wchar_t const *,uint)
.text$mn:00004CF7                 add     esp, 10h
.text$mn:00004CFA                 push    193h            ; unsigned int
.text$mn:00004CFF                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00004D04                 mov     edx, [ebp+Dst]
.text$mn:00004D07                 push    edx             ; int
.text$mn:00004D08                 call    ??$_Debug_pointer@_W@std@@YAXPA_WPB_WI@Z ; std::_Debug_pointer<wchar_t>(wchar_t *,wchar_t const *,uint)
.text$mn:00004D0D                 add     esp, 0Ch
.text$mn:00004D10                 mov     eax, [ebp+arg_4]
.text$mn:00004D13                 sub     eax, [ebp+Src]
.text$mn:00004D16                 sar     eax, 1
.text$mn:00004D18                 mov     [ebp+var_4], eax
.text$mn:00004D1B                 mov     ecx, [ebp+var_4]
.text$mn:00004D1E                 shl     ecx, 1
.text$mn:00004D20                 push    ecx             ; Size
.text$mn:00004D21                 mov     edx, [ebp+Src]
.text$mn:00004D24                 push    edx             ; Src
.text$mn:00004D25                 mov     eax, [ebp+Dst]
.text$mn:00004D28                 push    eax             ; Dst
.text$mn:00004D29                 call    _memmove
.text$mn:00004D2E                 add     esp, 0Ch
.text$mn:00004D31                 mov     ecx, [ebp+var_4]
.text$mn:00004D34                 lea     eax, [eax+ecx*2]
.text$mn:00004D37                 mov     esp, ebp
.text$mn:00004D39                 pop     ebp
.text$mn:00004D3A                 retn
.text$mn:00004D3A ??$_Uninit_copy@_W_W@std@@YAPA_WPA_W00AAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z endp
.text$mn:00004D3A
.text$mn:00004D3A ; ---------------------------------------------------------------------------
.text$mn:00004D3B                 align 4
.text$mn:00004D3B _text$mn        ends
.text$mn:00004D3B
.text$mn:00004D3C ; ===========================================================================
.text$mn:00004D3C
.text$mn:00004D3C ; Segment type: Pure code
.text$mn:00004D3C ; Segment permissions: Read/Execute
.text$mn:00004D3C _text$mn        segment para public 'CODE' use32
.text$mn:00004D3C                 assume cs:_text$mn
.text$mn:00004D3C                 ;org 4D3Ch
.text$mn:00004D3C ; COMDAT (pick any)
.text$mn:00004D3C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004D3C
.text$mn:00004D3C ; =============== S U B R O U T I N E =======================================
.text$mn:00004D3C
.text$mn:00004D3C ; Attributes: bp-based frame
.text$mn:00004D3C
.text$mn:00004D3C ; void __cdecl std::_Uninit_def_fill_n<int, unsigned int, int>(int *, unsigned int, struct std::_Wrap_alloc<class std::allocator<int>> &, int *, struct std::_Scalar_ptr_iterator_tag)
.text$mn:00004D3C                 public ??$_Uninit_def_fill_n@HIH@std@@YAXPAHIAAU?$_Wrap_alloc@V?$allocator@H@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
.text$mn:00004D3C ??$_Uninit_def_fill_n@HIH@std@@YAXPAHIAAU?$_Wrap_alloc@V?$allocator@H@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z proc near
.text$mn:00004D3C                                         ; CODE XREF: std::_Uninitialized_default_fill_n<int *,uint,std::_Wrap_alloc<std::allocator<int>>>(int *,uint,std::_Wrap_alloc<std::allocator<int>> &)+35p
.text$mn:00004D3C
.text$mn:00004D3C var_4           = dword ptr -4
.text$mn:00004D3C arg_0           = dword ptr  8
.text$mn:00004D3C arg_4           = dword ptr  0Ch
.text$mn:00004D3C
.text$mn:00004D3C                 push    ebp
.text$mn:00004D3D                 mov     ebp, esp
.text$mn:00004D3F                 push    ecx
.text$mn:00004D40                 mov     [ebp+var_4], 0
.text$mn:00004D47                 lea     eax, [ebp+var_4]
.text$mn:00004D4A                 push    eax
.text$mn:00004D4B                 mov     ecx, [ebp+arg_4]
.text$mn:00004D4E                 push    ecx
.text$mn:00004D4F                 mov     edx, [ebp+arg_0]
.text$mn:00004D52                 push    edx
.text$mn:00004D53                 call    ??$_Fill_n@PAHIH@std@@YAPAHPAHIABH@Z ; std::_Fill_n<int *,uint,int>(int *,uint,int const &)
.text$mn:00004D58                 add     esp, 0Ch
.text$mn:00004D5B                 mov     esp, ebp
.text$mn:00004D5D                 pop     ebp
.text$mn:00004D5E                 retn
.text$mn:00004D5E ??$_Uninit_def_fill_n@HIH@std@@YAXPAHIAAU?$_Wrap_alloc@V?$allocator@H@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z endp
.text$mn:00004D5E
.text$mn:00004D5E ; ---------------------------------------------------------------------------
.text$mn:00004D5F                 align 10h
.text$mn:00004D5F _text$mn        ends
.text$mn:00004D5F
.text$mn:00004D60 ; ===========================================================================
.text$mn:00004D60
.text$mn:00004D60 ; Segment type: Pure code
.text$mn:00004D60 ; Segment permissions: Read/Execute
.text$mn:00004D60 _text$mn        segment para public 'CODE' use32
.text$mn:00004D60                 assume cs:_text$mn
.text$mn:00004D60                 ;org 4D60h
.text$mn:00004D60 ; COMDAT (pick any)
.text$mn:00004D60                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004D60
.text$mn:00004D60 ; =============== S U B R O U T I N E =======================================
.text$mn:00004D60
.text$mn:00004D60 ; Attributes: bp-based frame
.text$mn:00004D60
.text$mn:00004D60 ; void __cdecl std::_Uninit_fill_n<int, unsigned int, int, int>(int *, unsigned int, int const *, struct std::_Wrap_alloc<class std::allocator<int>> &, int *, struct std::_Scalar_ptr_iterator_tag)
.text$mn:00004D60                 public ??$_Uninit_fill_n@HIHH@std@@YAXPAHIPBHAAU?$_Wrap_alloc@V?$allocator@H@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
.text$mn:00004D60 ??$_Uninit_fill_n@HIHH@std@@YAXPAHIPBHAAU?$_Wrap_alloc@V?$allocator@H@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z proc near
.text$mn:00004D60                                         ; CODE XREF: std::_Uninitialized_fill_n<int *,uint,int,std::_Wrap_alloc<std::allocator<int>>>(int *,uint,int const *,std::_Wrap_alloc<std::allocator<int>> &)+39p
.text$mn:00004D60
.text$mn:00004D60 arg_0           = dword ptr  8
.text$mn:00004D60 arg_4           = dword ptr  0Ch
.text$mn:00004D60 arg_8           = dword ptr  10h
.text$mn:00004D60
.text$mn:00004D60                 push    ebp
.text$mn:00004D61                 mov     ebp, esp
.text$mn:00004D63                 mov     eax, [ebp+arg_8]
.text$mn:00004D66                 push    eax
.text$mn:00004D67                 mov     ecx, [ebp+arg_4]
.text$mn:00004D6A                 push    ecx
.text$mn:00004D6B                 mov     edx, [ebp+arg_0]
.text$mn:00004D6E                 push    edx
.text$mn:00004D6F                 call    ??$_Fill_n@PAHIH@std@@YAPAHPAHIABH@Z ; std::_Fill_n<int *,uint,int>(int *,uint,int const &)
.text$mn:00004D74                 add     esp, 0Ch
.text$mn:00004D77                 pop     ebp
.text$mn:00004D78                 retn
.text$mn:00004D78 ??$_Uninit_fill_n@HIHH@std@@YAXPAHIPBHAAU?$_Wrap_alloc@V?$allocator@H@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z endp
.text$mn:00004D78
.text$mn:00004D78 ; ---------------------------------------------------------------------------
.text$mn:00004D79                 align 4
.text$mn:00004D79 _text$mn        ends
.text$mn:00004D79
.text$mn:00004D7C ; ===========================================================================
.text$mn:00004D7C
.text$mn:00004D7C ; Segment type: Pure code
.text$mn:00004D7C ; Segment permissions: Read/Execute
.text$mn:00004D7C _text$mn        segment para public 'CODE' use32
.text$mn:00004D7C                 assume cs:_text$mn
.text$mn:00004D7C                 ;org 4D7Ch
.text$mn:00004D7C ; COMDAT (pick any)
.text$mn:00004D7C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004D7C
.text$mn:00004D7C ; =============== S U B R O U T I N E =======================================
.text$mn:00004D7C
.text$mn:00004D7C ; Attributes: bp-based frame
.text$mn:00004D7C
.text$mn:00004D7C ; int __cdecl std::_Uninit_move<int,int,int>(void *Src, int, void *Dst)
.text$mn:00004D7C                 public ??$_Uninit_move@HHH@std@@YAPAHPAH00AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
.text$mn:00004D7C ??$_Uninit_move@HHH@std@@YAPAHPAH00AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z proc near
.text$mn:00004D7C                                         ; CODE XREF: std::_Uninit_move<int *,int *,std::_Wrap_alloc<std::allocator<int>>>(int *,int *,int *,std::_Wrap_alloc<std::allocator<int>> &)+39p
.text$mn:00004D7C
.text$mn:00004D7C var_4           = dword ptr -4
.text$mn:00004D7C Src             = dword ptr  8
.text$mn:00004D7C arg_4           = dword ptr  0Ch
.text$mn:00004D7C Dst             = dword ptr  10h
.text$mn:00004D7C
.text$mn:00004D7C                 push    ebp
.text$mn:00004D7D                 mov     ebp, esp
.text$mn:00004D7F                 push    ecx
.text$mn:00004D80                 push    1D6h            ; unsigned int
.text$mn:00004D85                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00004D8A                 mov     eax, [ebp+arg_4]
.text$mn:00004D8D                 push    eax             ; int
.text$mn:00004D8E                 mov     ecx, [ebp+Src]
.text$mn:00004D91                 push    ecx             ; int
.text$mn:00004D92                 call    ??$_Debug_range@PAH@std@@YAXPAH0PB_WI@Z ; std::_Debug_range<int *>(int *,int *,wchar_t const *,uint)
.text$mn:00004D97                 add     esp, 10h
.text$mn:00004D9A                 push    1D7h            ; unsigned int
.text$mn:00004D9F                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00004DA4                 mov     edx, [ebp+Dst]
.text$mn:00004DA7                 push    edx             ; int
.text$mn:00004DA8                 call    ??$_Debug_pointer@H@std@@YAXPAHPB_WI@Z ; std::_Debug_pointer<int>(int *,wchar_t const *,uint)
.text$mn:00004DAD                 add     esp, 0Ch
.text$mn:00004DB0                 mov     eax, [ebp+arg_4]
.text$mn:00004DB3                 sub     eax, [ebp+Src]
.text$mn:00004DB6                 sar     eax, 2
.text$mn:00004DB9                 mov     [ebp+var_4], eax
.text$mn:00004DBC                 mov     ecx, [ebp+var_4]
.text$mn:00004DBF                 shl     ecx, 2
.text$mn:00004DC2                 push    ecx             ; Size
.text$mn:00004DC3                 mov     edx, [ebp+Src]
.text$mn:00004DC6                 push    edx             ; Src
.text$mn:00004DC7                 mov     eax, [ebp+Dst]
.text$mn:00004DCA                 push    eax             ; Dst
.text$mn:00004DCB                 call    _memmove
.text$mn:00004DD0                 add     esp, 0Ch
.text$mn:00004DD3                 mov     ecx, [ebp+var_4]
.text$mn:00004DD6                 lea     eax, [eax+ecx*4]
.text$mn:00004DD9                 mov     esp, ebp
.text$mn:00004DDB                 pop     ebp
.text$mn:00004DDC                 retn
.text$mn:00004DDC ??$_Uninit_move@HHH@std@@YAPAHPAH00AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z endp
.text$mn:00004DDC
.text$mn:00004DDC ; ---------------------------------------------------------------------------
.text$mn:00004DDD                 align 10h
.text$mn:00004DDD _text$mn        ends
.text$mn:00004DDD
.text$mn:00004DE0 ; ===========================================================================
.text$mn:00004DE0
.text$mn:00004DE0 ; Segment type: Pure code
.text$mn:00004DE0 ; Segment permissions: Read/Execute
.text$mn:00004DE0 _text$mn        segment para public 'CODE' use32
.text$mn:00004DE0                 assume cs:_text$mn
.text$mn:00004DE0                 ;org 4DE0h
.text$mn:00004DE0 ; COMDAT (pick any)
.text$mn:00004DE0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004DE0
.text$mn:00004DE0 ; =============== S U B R O U T I N E =======================================
.text$mn:00004DE0
.text$mn:00004DE0 ; Attributes: bp-based frame
.text$mn:00004DE0
.text$mn:00004DE0 ; int __cdecl std::_Uninit_move<int *,int *,std::_Wrap_alloc<std::allocator<int>>>(void *Src, int, void *Dst, int)
.text$mn:00004DE0                 public ??$_Uninit_move@PAHPAHU?$_Wrap_alloc@V?$allocator@H@std@@@std@@@std@@YAPAHPAH00AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@@Z
.text$mn:00004DE0 ??$_Uninit_move@PAHPAHU?$_Wrap_alloc@V?$allocator@H@std@@@std@@@std@@YAPAHPAH00AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@@Z proc near
.text$mn:00004DE0                                         ; CODE XREF: std::_Uninitialized_move<int *,int *,std::_Wrap_alloc<std::allocator<int>>>(int *,int *,int *,std::_Wrap_alloc<std::allocator<int>> &)+2Ep
.text$mn:00004DE0
.text$mn:00004DE0 var_1           = byte ptr -1
.text$mn:00004DE0 Src             = dword ptr  8
.text$mn:00004DE0 arg_4           = dword ptr  0Ch
.text$mn:00004DE0 Dst             = dword ptr  10h
.text$mn:00004DE0 arg_C           = dword ptr  14h
.text$mn:00004DE0
.text$mn:00004DE0                 push    ebp
.text$mn:00004DE1                 mov     ebp, esp
.text$mn:00004DE3                 push    ecx
.text$mn:00004DE4                 mov     eax, [ebp+Dst]
.text$mn:00004DE7                 push    eax
.text$mn:00004DE8                 mov     ecx, [ebp+Src]
.text$mn:00004DEB                 push    ecx
.text$mn:00004DEC                 call    ??$_Ptr_cat@HH@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAH0@Z ; std::_Ptr_cat<int,int>(int *,int *)
.text$mn:00004DF1                 add     esp, 8
.text$mn:00004DF4                 mov     [ebp+var_1], al
.text$mn:00004DF7                 movzx   edx, [ebp+var_1]
.text$mn:00004DFB                 push    edx
.text$mn:00004DFC                 mov     eax, [ebp+Src]
.text$mn:00004DFF                 push    eax
.text$mn:00004E00                 call    ??$_Val_type@PAH@std@@YAPAHPAH@Z ; std::_Val_type<int *>(int *)
.text$mn:00004E05                 add     esp, 4
.text$mn:00004E08                 push    eax
.text$mn:00004E09                 mov     ecx, [ebp+arg_C]
.text$mn:00004E0C                 push    ecx
.text$mn:00004E0D                 mov     edx, [ebp+Dst]
.text$mn:00004E10                 push    edx             ; Dst
.text$mn:00004E11                 mov     eax, [ebp+arg_4]
.text$mn:00004E14                 push    eax             ; int
.text$mn:00004E15                 mov     ecx, [ebp+Src]
.text$mn:00004E18                 push    ecx             ; Src
.text$mn:00004E19                 call    ??$_Uninit_move@HHH@std@@YAPAHPAH00AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<int,int,int>(int *,int *,int *,std::_Wrap_alloc<std::allocator<int>> &,int *,std::_Scalar_ptr_iterator_tag)
.text$mn:00004E1E                 add     esp, 18h
.text$mn:00004E21                 mov     esp, ebp
.text$mn:00004E23                 pop     ebp
.text$mn:00004E24                 retn
.text$mn:00004E24 ??$_Uninit_move@PAHPAHU?$_Wrap_alloc@V?$allocator@H@std@@@std@@@std@@YAPAHPAH00AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@@Z endp
.text$mn:00004E24
.text$mn:00004E24 ; ---------------------------------------------------------------------------
.text$mn:00004E25                 align 4
.text$mn:00004E25 _text$mn        ends
.text$mn:00004E25
.text$mn:00004E28 ; ===========================================================================
.text$mn:00004E28
.text$mn:00004E28 ; Segment type: Pure code
.text$mn:00004E28 ; Segment permissions: Read/Execute
.text$mn:00004E28 _text$mn        segment para public 'CODE' use32
.text$mn:00004E28                 assume cs:_text$mn
.text$mn:00004E28                 ;org 4E28h
.text$mn:00004E28 ; COMDAT (pick any)
.text$mn:00004E28                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004E28
.text$mn:00004E28 ; =============== S U B R O U T I N E =======================================
.text$mn:00004E28
.text$mn:00004E28 ; Attributes: bp-based frame
.text$mn:00004E28
.text$mn:00004E28 ; int __cdecl std::_Uninit_move<wchar_t *,wchar_t *,std::_Wrap_alloc<std::allocator<wchar_t>>>(void *Src, int, void *Dst, int)
.text$mn:00004E28                 public ??$_Uninit_move@PA_WPA_WU?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YAPA_WPA_W00AAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@@Z
.text$mn:00004E28 ??$_Uninit_move@PA_WPA_WU?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YAPA_WPA_W00AAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@@Z proc near
.text$mn:00004E28                                         ; CODE XREF: std::_Uninitialized_move<wchar_t *,wchar_t *,std::_Wrap_alloc<std::allocator<wchar_t>>>(wchar_t *,wchar_t *,wchar_t *,std::_Wrap_alloc<std::allocator<wchar_t>> &)+2Ep
.text$mn:00004E28
.text$mn:00004E28 var_1           = byte ptr -1
.text$mn:00004E28 Src             = dword ptr  8
.text$mn:00004E28 arg_4           = dword ptr  0Ch
.text$mn:00004E28 Dst             = dword ptr  10h
.text$mn:00004E28 arg_C           = dword ptr  14h
.text$mn:00004E28
.text$mn:00004E28                 push    ebp
.text$mn:00004E29                 mov     ebp, esp
.text$mn:00004E2B                 push    ecx
.text$mn:00004E2C                 mov     eax, [ebp+Dst]
.text$mn:00004E2F                 push    eax
.text$mn:00004E30                 mov     ecx, [ebp+Src]
.text$mn:00004E33                 push    ecx
.text$mn:00004E34                 call    ??$_Ptr_cat@_W_W@std@@YA?AU_Scalar_ptr_iterator_tag@0@PA_W0@Z ; std::_Ptr_cat<wchar_t,wchar_t>(wchar_t *,wchar_t *)
.text$mn:00004E39                 add     esp, 8
.text$mn:00004E3C                 mov     [ebp+var_1], al
.text$mn:00004E3F                 movzx   edx, [ebp+var_1]
.text$mn:00004E43                 push    edx
.text$mn:00004E44                 mov     eax, [ebp+Src]
.text$mn:00004E47                 push    eax
.text$mn:00004E48                 call    ??$_Val_type@PA_W@std@@YAPA_WPA_W@Z ; std::_Val_type<wchar_t *>(wchar_t *)
.text$mn:00004E4D                 add     esp, 4
.text$mn:00004E50                 push    eax
.text$mn:00004E51                 mov     ecx, [ebp+arg_C]
.text$mn:00004E54                 push    ecx
.text$mn:00004E55                 mov     edx, [ebp+Dst]
.text$mn:00004E58                 push    edx             ; Dst
.text$mn:00004E59                 mov     eax, [ebp+arg_4]
.text$mn:00004E5C                 push    eax             ; int
.text$mn:00004E5D                 mov     ecx, [ebp+Src]
.text$mn:00004E60                 push    ecx             ; Src
.text$mn:00004E61                 call    ??$_Uninit_move@_W_W_W@std@@YAPA_WPA_W00AAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<wchar_t,wchar_t,wchar_t>(wchar_t *,wchar_t *,wchar_t *,std::_Wrap_alloc<std::allocator<wchar_t>> &,wchar_t *,std::_Scalar_ptr_iterator_tag)
.text$mn:00004E66                 add     esp, 18h
.text$mn:00004E69                 mov     esp, ebp
.text$mn:00004E6B                 pop     ebp
.text$mn:00004E6C                 retn
.text$mn:00004E6C ??$_Uninit_move@PA_WPA_WU?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YAPA_WPA_W00AAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@@Z endp
.text$mn:00004E6C
.text$mn:00004E6C ; ---------------------------------------------------------------------------
.text$mn:00004E6D                 align 10h
.text$mn:00004E6D _text$mn        ends
.text$mn:00004E6D
.text$mn:00004E70 ; ===========================================================================
.text$mn:00004E70
.text$mn:00004E70 ; Segment type: Pure code
.text$mn:00004E70 ; Segment permissions: Read/Execute
.text$mn:00004E70 _text$mn        segment para public 'CODE' use32
.text$mn:00004E70                 assume cs:_text$mn
.text$mn:00004E70                 ;org 4E70h
.text$mn:00004E70 ; COMDAT (pick any)
.text$mn:00004E70                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004E70
.text$mn:00004E70 ; =============== S U B R O U T I N E =======================================
.text$mn:00004E70
.text$mn:00004E70 ; Attributes: bp-based frame
.text$mn:00004E70
.text$mn:00004E70 ; int __cdecl std::_Uninit_move<wchar_t,wchar_t,wchar_t>(void *Src, int, void *Dst)
.text$mn:00004E70                 public ??$_Uninit_move@_W_W_W@std@@YAPA_WPA_W00AAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
.text$mn:00004E70 ??$_Uninit_move@_W_W_W@std@@YAPA_WPA_W00AAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z proc near
.text$mn:00004E70                                         ; CODE XREF: std::_Uninit_move<wchar_t *,wchar_t *,std::_Wrap_alloc<std::allocator<wchar_t>>>(wchar_t *,wchar_t *,wchar_t *,std::_Wrap_alloc<std::allocator<wchar_t>> &)+39p
.text$mn:00004E70
.text$mn:00004E70 var_4           = dword ptr -4
.text$mn:00004E70 Src             = dword ptr  8
.text$mn:00004E70 arg_4           = dword ptr  0Ch
.text$mn:00004E70 Dst             = dword ptr  10h
.text$mn:00004E70
.text$mn:00004E70                 push    ebp
.text$mn:00004E71                 mov     ebp, esp
.text$mn:00004E73                 push    ecx
.text$mn:00004E74                 push    1D6h            ; unsigned int
.text$mn:00004E79                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00004E7E                 mov     eax, [ebp+arg_4]
.text$mn:00004E81                 push    eax             ; int
.text$mn:00004E82                 mov     ecx, [ebp+Src]
.text$mn:00004E85                 push    ecx             ; int
.text$mn:00004E86                 call    ??$_Debug_range@PA_W@std@@YAXPA_W0PB_WI@Z ; std::_Debug_range<wchar_t *>(wchar_t *,wchar_t *,wchar_t const *,uint)
.text$mn:00004E8B                 add     esp, 10h
.text$mn:00004E8E                 push    1D7h            ; unsigned int
.text$mn:00004E93                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00004E98                 mov     edx, [ebp+Dst]
.text$mn:00004E9B                 push    edx             ; int
.text$mn:00004E9C                 call    ??$_Debug_pointer@_W@std@@YAXPA_WPB_WI@Z ; std::_Debug_pointer<wchar_t>(wchar_t *,wchar_t const *,uint)
.text$mn:00004EA1                 add     esp, 0Ch
.text$mn:00004EA4                 mov     eax, [ebp+arg_4]
.text$mn:00004EA7                 sub     eax, [ebp+Src]
.text$mn:00004EAA                 sar     eax, 1
.text$mn:00004EAC                 mov     [ebp+var_4], eax
.text$mn:00004EAF                 mov     ecx, [ebp+var_4]
.text$mn:00004EB2                 shl     ecx, 1
.text$mn:00004EB4                 push    ecx             ; Size
.text$mn:00004EB5                 mov     edx, [ebp+Src]
.text$mn:00004EB8                 push    edx             ; Src
.text$mn:00004EB9                 mov     eax, [ebp+Dst]
.text$mn:00004EBC                 push    eax             ; Dst
.text$mn:00004EBD                 call    _memmove
.text$mn:00004EC2                 add     esp, 0Ch
.text$mn:00004EC5                 mov     ecx, [ebp+var_4]
.text$mn:00004EC8                 lea     eax, [eax+ecx*2]
.text$mn:00004ECB                 mov     esp, ebp
.text$mn:00004ECD                 pop     ebp
.text$mn:00004ECE                 retn
.text$mn:00004ECE ??$_Uninit_move@_W_W_W@std@@YAPA_WPA_W00AAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z endp
.text$mn:00004ECE
.text$mn:00004ECE ; ---------------------------------------------------------------------------
.text$mn:00004ECF                 align 10h
.text$mn:00004ECF _text$mn        ends
.text$mn:00004ECF
.text$mn:00004ED0 ; ===========================================================================
.text$mn:00004ED0
.text$mn:00004ED0 ; Segment type: Pure code
.text$mn:00004ED0 ; Segment permissions: Read/Execute
.text$mn:00004ED0 _text$mn        segment para public 'CODE' use32
.text$mn:00004ED0                 assume cs:_text$mn
.text$mn:00004ED0                 ;org 4ED0h
.text$mn:00004ED0 ; COMDAT (pick any)
.text$mn:00004ED0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004ED0
.text$mn:00004ED0 ; =============== S U B R O U T I N E =======================================
.text$mn:00004ED0
.text$mn:00004ED0 ; Attributes: bp-based frame
.text$mn:00004ED0
.text$mn:00004ED0 ; wchar_t * __cdecl std::_Uninitialized_copy<class std::_String_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>>, wchar_t *, struct std::_Wrap_alloc<class std::allocator<wchar_t>>>(class std::_String_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>>, class std::_String_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>>, wchar_t *, struct std::_Wrap_alloc<class std::allocator<wchar_t>> &)
.text$mn:00004ED0                 public ??$_Uninitialized_copy@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@PA_WU?$_Wrap_alloc@V?$allocator@_W@std@@@2@@std@@YAPA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0PA_WAAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@@Z
.text$mn:00004ED0 ??$_Uninitialized_copy@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@PA_WU?$_Wrap_alloc@V?$allocator@_W@std@@@2@@std@@YAPA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0PA_WAAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@@Z proc near
.text$mn:00004ED0                                         ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::_Ucopy<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,wchar_t *)+83p
.text$mn:00004ED0
.text$mn:00004ED0 var_34          = dword ptr -34h
.text$mn:00004ED0 var_30          = dword ptr -30h
.text$mn:00004ED0 var_2C          = dword ptr -2Ch
.text$mn:00004ED0 var_28          = dword ptr -28h
.text$mn:00004ED0 var_24          = dword ptr -24h
.text$mn:00004ED0 var_20          = dword ptr -20h
.text$mn:00004ED0 Src             = dword ptr -1Ch
.text$mn:00004ED0 var_18          = dword ptr -18h
.text$mn:00004ED0 var_14          = dword ptr -14h
.text$mn:00004ED0 var_10          = dword ptr -10h
.text$mn:00004ED0 var_C           = dword ptr -0Ch
.text$mn:00004ED0 var_4           = dword ptr -4
.text$mn:00004ED0 arg_0           = byte ptr  8
.text$mn:00004ED0 arg_C           = byte ptr  14h
.text$mn:00004ED0 arg_18          = dword ptr  20h
.text$mn:00004ED0 arg_1C          = dword ptr  24h
.text$mn:00004ED0
.text$mn:00004ED0                 push    ebp
.text$mn:00004ED1                 mov     ebp, esp
.text$mn:00004ED3                 push    0FFFFFFFFh
.text$mn:00004ED5                 push    offset __ehhandler$??$_Uninitialized_copy@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@PA_WU?$_Wrap_alloc@V?$allocator@_W@std@@@2@@std@@YAPA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0PA_WAAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@@Z
.text$mn:00004EDA                 mov     eax, large fs:0
.text$mn:00004EE0                 push    eax
.text$mn:00004EE1                 sub     esp, 28h
.text$mn:00004EE4                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004EE9                 xor     eax, ebp
.text$mn:00004EEB                 push    eax
.text$mn:00004EEC                 lea     eax, [ebp+var_C]
.text$mn:00004EEF                 mov     large fs:0, eax
.text$mn:00004EF5                 mov     [ebp+var_4], 1
.text$mn:00004EFC                 mov     eax, [ebp+arg_1C]
.text$mn:00004EFF                 push    eax             ; int
.text$mn:00004F00                 mov     ecx, [ebp+arg_18]
.text$mn:00004F03                 push    ecx
.text$mn:00004F04                 call    ??$_Unchecked@PA_W@std@@YAPA_WPA_W@Z ; std::_Unchecked<wchar_t *>(wchar_t *)
.text$mn:00004F09                 add     esp, 4
.text$mn:00004F0C                 push    eax             ; Dst
.text$mn:00004F0D                 sub     esp, 0Ch
.text$mn:00004F10                 mov     ecx, esp
.text$mn:00004F12                 mov     [ebp+var_28], esp
.text$mn:00004F15                 lea     edx, [ebp+arg_C]
.text$mn:00004F18                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:00004F19                 call    ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:00004F1E                 mov     [ebp+var_10], eax
.text$mn:00004F21                 mov     eax, [ebp+var_10]
.text$mn:00004F24                 mov     [ebp+var_2C], eax
.text$mn:00004F27                 mov     byte ptr [ebp+var_4], 2
.text$mn:00004F2B                 mov     byte ptr [ebp+var_4], 1
.text$mn:00004F2F                 call    ??$_Unchecked@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@@Z ; std::_Unchecked<std::_String_val<std::_Simple_types<wchar_t>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)
.text$mn:00004F34                 add     esp, 0Ch
.text$mn:00004F37                 mov     [ebp+var_14], eax
.text$mn:00004F3A                 mov     ecx, [ebp+var_14]
.text$mn:00004F3D                 push    ecx             ; int
.text$mn:00004F3E                 sub     esp, 0Ch
.text$mn:00004F41                 mov     ecx, esp
.text$mn:00004F43                 mov     [ebp+var_30], esp
.text$mn:00004F46                 lea     edx, [ebp+arg_0]
.text$mn:00004F49                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:00004F4A                 call    ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:00004F4F                 mov     [ebp+var_18], eax
.text$mn:00004F52                 mov     eax, [ebp+var_18]
.text$mn:00004F55                 mov     [ebp+var_34], eax
.text$mn:00004F58                 mov     byte ptr [ebp+var_4], 3
.text$mn:00004F5C                 mov     byte ptr [ebp+var_4], 1
.text$mn:00004F60                 call    ??$_Unchecked@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@@Z ; std::_Unchecked<std::_String_val<std::_Simple_types<wchar_t>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)
.text$mn:00004F65                 add     esp, 0Ch
.text$mn:00004F68                 mov     [ebp+Src], eax
.text$mn:00004F6B                 mov     ecx, [ebp+Src]
.text$mn:00004F6E                 push    ecx             ; Src
.text$mn:00004F6F                 call    ??$_Uninit_copy@PA_WPA_WU?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YAPA_WPA_W00AAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@@Z ; std::_Uninit_copy<wchar_t *,wchar_t *,std::_Wrap_alloc<std::allocator<wchar_t>>>(wchar_t *,wchar_t *,wchar_t *,std::_Wrap_alloc<std::allocator<wchar_t>> &)
.text$mn:00004F74                 add     esp, 10h
.text$mn:00004F77                 mov     [ebp+var_20], eax
.text$mn:00004F7A                 mov     edx, [ebp+var_20]
.text$mn:00004F7D                 push    edx
.text$mn:00004F7E                 lea     eax, [ebp+arg_18]
.text$mn:00004F81                 push    eax
.text$mn:00004F82                 call    ??$_Rechecked@PA_WPA_W@std@@YAAAPA_WAAPA_WPA_W@Z ; std::_Rechecked<wchar_t *,wchar_t *>(wchar_t * &,wchar_t *)
.text$mn:00004F87                 add     esp, 8
.text$mn:00004F8A                 mov     ecx, [eax]
.text$mn:00004F8C                 mov     [ebp+var_24], ecx
.text$mn:00004F8F                 mov     byte ptr [ebp+var_4], 0
.text$mn:00004F93                 lea     ecx, [ebp+arg_0]
.text$mn:00004F96                 call    ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$mn:00004F9B                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004FA2                 lea     ecx, [ebp+arg_C]
.text$mn:00004FA5                 call    ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$mn:00004FAA                 mov     eax, [ebp+var_24]
.text$mn:00004FAD                 mov     ecx, [ebp+var_C]
.text$mn:00004FB0                 mov     large fs:0, ecx
.text$mn:00004FB7                 pop     ecx
.text$mn:00004FB8                 mov     esp, ebp
.text$mn:00004FBA                 pop     ebp
.text$mn:00004FBB                 retn
.text$mn:00004FBB ??$_Uninitialized_copy@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@PA_WU?$_Wrap_alloc@V?$allocator@_W@std@@@2@@std@@YAPA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0PA_WAAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@@Z endp
.text$mn:00004FBB
.text$mn:00004FBB _text$mn        ends
.text$mn:00004FBB
.text$x:00004FBC ; ===========================================================================
.text$x:00004FBC
.text$x:00004FBC ; Segment type: Pure code
.text$x:00004FBC ; Segment permissions: Read/Execute
.text$x:00004FBC _text$x         segment para public 'CODE' use32
.text$x:00004FBC                 assume cs:_text$x
.text$x:00004FBC                 ;org 4FBCh
.text$x:00004FBC ; COMDAT (pick associative to section at 4ED0)
.text$x:00004FBC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00004FBC
.text$x:00004FBC ; =============== S U B R O U T I N E =======================================
.text$x:00004FBC
.text$x:00004FBC
.text$x:00004FBC __unwindfunclet$??$_Uninitialized_copy@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@PA_WU?$_Wrap_alloc@V?$allocator@_W@std@@@2@@std@@YAPA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0PA_WAAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@@Z$0 proc near
.text$x:00004FBC                                         ; DATA XREF: .xdata$x:0000DB28o
.text$x:00004FBC                 lea     ecx, [ebp+14h]
.text$x:00004FBF                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00004FBF __unwindfunclet$??$_Uninitialized_copy@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@PA_WU?$_Wrap_alloc@V?$allocator@_W@std@@@2@@std@@YAPA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0PA_WAAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@@Z$0 endp
.text$x:00004FBF
.text$x:00004FC4
.text$x:00004FC4 ; =============== S U B R O U T I N E =======================================
.text$x:00004FC4
.text$x:00004FC4
.text$x:00004FC4 __unwindfunclet$??$_Uninitialized_copy@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@PA_WU?$_Wrap_alloc@V?$allocator@_W@std@@@2@@std@@YAPA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0PA_WAAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@@Z$1 proc near
.text$x:00004FC4                                         ; DATA XREF: .xdata$x:0000DB30o
.text$x:00004FC4                 lea     ecx, [ebp+8]
.text$x:00004FC7                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00004FC7 __unwindfunclet$??$_Uninitialized_copy@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@PA_WU?$_Wrap_alloc@V?$allocator@_W@std@@@2@@std@@YAPA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0PA_WAAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@@Z$1 endp
.text$x:00004FC7
.text$x:00004FCC
.text$x:00004FCC ; =============== S U B R O U T I N E =======================================
.text$x:00004FCC
.text$x:00004FCC
.text$x:00004FCC __unwindfunclet$??$_Uninitialized_copy@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@PA_WU?$_Wrap_alloc@V?$allocator@_W@std@@@2@@std@@YAPA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0PA_WAAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@@Z$2 proc near
.text$x:00004FCC                                         ; DATA XREF: .xdata$x:0000DB38o
.text$x:00004FCC                 mov     ecx, [ebp-28h]
.text$x:00004FCF                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00004FCF __unwindfunclet$??$_Uninitialized_copy@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@PA_WU?$_Wrap_alloc@V?$allocator@_W@std@@@2@@std@@YAPA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0PA_WAAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@@Z$2 endp
.text$x:00004FCF
.text$x:00004FD4
.text$x:00004FD4 ; =============== S U B R O U T I N E =======================================
.text$x:00004FD4
.text$x:00004FD4
.text$x:00004FD4 __unwindfunclet$??$_Uninitialized_copy@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@PA_WU?$_Wrap_alloc@V?$allocator@_W@std@@@2@@std@@YAPA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0PA_WAAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@@Z$3 proc near
.text$x:00004FD4                                         ; DATA XREF: .xdata$x:0000DB40o
.text$x:00004FD4                 mov     ecx, [ebp-30h]
.text$x:00004FD7                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00004FD7 __unwindfunclet$??$_Uninitialized_copy@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@PA_WU?$_Wrap_alloc@V?$allocator@_W@std@@@2@@std@@YAPA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0PA_WAAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@@Z$3 endp
.text$x:00004FD7
.text$x:00004FDC
.text$x:00004FDC ; =============== S U B R O U T I N E =======================================
.text$x:00004FDC
.text$x:00004FDC
.text$x:00004FDC __ehhandler$??$_Uninitialized_copy@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@PA_WU?$_Wrap_alloc@V?$allocator@_W@std@@@2@@std@@YAPA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0PA_WAAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@@Z proc near
.text$x:00004FDC                                         ; DATA XREF: std::_Uninitialized_copy<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,wchar_t *,std::_Wrap_alloc<std::allocator<wchar_t>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,wchar_t *,std::_Wrap_alloc<std::allocator<wchar_t>> &)+5o
.text$x:00004FDC
.text$x:00004FDC arg_4           = dword ptr  8
.text$x:00004FDC
.text$x:00004FDC                 mov     edx, [esp+arg_4]
.text$x:00004FE0                 lea     eax, [edx+0Ch]
.text$x:00004FE3                 mov     ecx, [edx-2Ch]
.text$x:00004FE6                 xor     ecx, eax
.text$x:00004FE8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004FED                 mov     eax, offset __ehfuncinfo$??$_Uninitialized_copy@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@PA_WU?$_Wrap_alloc@V?$allocator@_W@std@@@2@@std@@YAPA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0PA_WAAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@@Z
.text$x:00004FF2                 jmp     ___CxxFrameHandler3
.text$x:00004FF2 __ehhandler$??$_Uninitialized_copy@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@PA_WU?$_Wrap_alloc@V?$allocator@_W@std@@@2@@std@@YAPA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0PA_WAAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@@Z endp
.text$x:00004FF2
.text$x:00004FF2 ; ---------------------------------------------------------------------------
.text$x:00004FF7                 align 4
.text$x:00004FF7 _text$x         ends
.text$x:00004FF7
.text$mn:00004FF8 ; ===========================================================================
.text$mn:00004FF8
.text$mn:00004FF8 ; Segment type: Pure code
.text$mn:00004FF8 ; Segment permissions: Read/Execute
.text$mn:00004FF8 _text$mn        segment para public 'CODE' use32
.text$mn:00004FF8                 assume cs:_text$mn
.text$mn:00004FF8                 ;org 4FF8h
.text$mn:00004FF8 ; COMDAT (pick any)
.text$mn:00004FF8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004FF8
.text$mn:00004FF8 ; =============== S U B R O U T I N E =======================================
.text$mn:00004FF8
.text$mn:00004FF8 ; Attributes: bp-based frame
.text$mn:00004FF8
.text$mn:00004FF8 ; void __cdecl std::_Uninitialized_default_fill_n<int *, unsigned int, struct std::_Wrap_alloc<class std::allocator<int>>>(int *, unsigned int, struct std::_Wrap_alloc<class std::allocator<int>> &)
.text$mn:00004FF8                 public ??$_Uninitialized_default_fill_n@PAHIU?$_Wrap_alloc@V?$allocator@H@std@@@std@@@std@@YAXPAHIAAU?$_Wrap_alloc@V?$allocator@H@std@@@0@@Z
.text$mn:00004FF8 ??$_Uninitialized_default_fill_n@PAHIU?$_Wrap_alloc@V?$allocator@H@std@@@std@@@std@@YAXPAHIAAU?$_Wrap_alloc@V?$allocator@H@std@@@0@@Z proc near
.text$mn:00004FF8                                         ; CODE XREF: std::vector<int,std::allocator<int>>::resize(uint)+A8p
.text$mn:00004FF8
.text$mn:00004FF8 var_1           = byte ptr -1
.text$mn:00004FF8 arg_0           = dword ptr  8
.text$mn:00004FF8 arg_4           = dword ptr  0Ch
.text$mn:00004FF8 arg_8           = dword ptr  10h
.text$mn:00004FF8
.text$mn:00004FF8                 push    ebp
.text$mn:00004FF9                 mov     ebp, esp
.text$mn:00004FFB                 push    ecx
.text$mn:00004FFC                 mov     eax, [ebp+arg_0]
.text$mn:00004FFF                 push    eax
.text$mn:00005000                 mov     ecx, [ebp+arg_0]
.text$mn:00005003                 push    ecx
.text$mn:00005004                 call    ??$_Ptr_cat@HH@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAH0@Z ; std::_Ptr_cat<int,int>(int *,int *)
.text$mn:00005009                 add     esp, 8
.text$mn:0000500C                 mov     [ebp+var_1], al
.text$mn:0000500F                 movzx   edx, [ebp+var_1]
.text$mn:00005013                 push    edx
.text$mn:00005014                 mov     eax, [ebp+arg_0]
.text$mn:00005017                 push    eax
.text$mn:00005018                 call    ??$_Val_type@PAH@std@@YAPAHPAH@Z ; std::_Val_type<int *>(int *)
.text$mn:0000501D                 add     esp, 4
.text$mn:00005020                 push    eax
.text$mn:00005021                 mov     ecx, [ebp+arg_8]
.text$mn:00005024                 push    ecx
.text$mn:00005025                 mov     edx, [ebp+arg_4]
.text$mn:00005028                 push    edx
.text$mn:00005029                 mov     eax, [ebp+arg_0]
.text$mn:0000502C                 push    eax
.text$mn:0000502D                 call    ??$_Uninit_def_fill_n@HIH@std@@YAXPAHIAAU?$_Wrap_alloc@V?$allocator@H@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_def_fill_n<int,uint,int>(int *,uint,std::_Wrap_alloc<std::allocator<int>> &,int *,std::_Scalar_ptr_iterator_tag)
.text$mn:00005032                 add     esp, 14h
.text$mn:00005035                 mov     esp, ebp
.text$mn:00005037                 pop     ebp
.text$mn:00005038                 retn
.text$mn:00005038 ??$_Uninitialized_default_fill_n@PAHIU?$_Wrap_alloc@V?$allocator@H@std@@@std@@@std@@YAXPAHIAAU?$_Wrap_alloc@V?$allocator@H@std@@@0@@Z endp
.text$mn:00005038
.text$mn:00005038 ; ---------------------------------------------------------------------------
.text$mn:00005039                 align 4
.text$mn:00005039 _text$mn        ends
.text$mn:00005039
.text$mn:0000503C ; ===========================================================================
.text$mn:0000503C
.text$mn:0000503C ; Segment type: Pure code
.text$mn:0000503C ; Segment permissions: Read/Execute
.text$mn:0000503C _text$mn        segment para public 'CODE' use32
.text$mn:0000503C                 assume cs:_text$mn
.text$mn:0000503C                 ;org 503Ch
.text$mn:0000503C ; COMDAT (pick any)
.text$mn:0000503C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000503C
.text$mn:0000503C ; =============== S U B R O U T I N E =======================================
.text$mn:0000503C
.text$mn:0000503C ; Attributes: bp-based frame
.text$mn:0000503C
.text$mn:0000503C ; void __cdecl std::_Uninitialized_fill_n<int *, unsigned int, int, struct std::_Wrap_alloc<class std::allocator<int>>>(int *, unsigned int, int const *, struct std::_Wrap_alloc<class std::allocator<int>> &)
.text$mn:0000503C                 public ??$_Uninitialized_fill_n@PAHIHU?$_Wrap_alloc@V?$allocator@H@std@@@std@@@std@@YAXPAHIPBHAAU?$_Wrap_alloc@V?$allocator@H@std@@@0@@Z
.text$mn:0000503C ??$_Uninitialized_fill_n@PAHIHU?$_Wrap_alloc@V?$allocator@H@std@@@std@@@std@@YAXPAHIPBHAAU?$_Wrap_alloc@V?$allocator@H@std@@@0@@Z proc near
.text$mn:0000503C                                         ; CODE XREF: std::vector<int,std::allocator<int>>::_Ufill(int *,uint,int const *)+25p
.text$mn:0000503C
.text$mn:0000503C var_1           = byte ptr -1
.text$mn:0000503C arg_0           = dword ptr  8
.text$mn:0000503C arg_4           = dword ptr  0Ch
.text$mn:0000503C arg_8           = dword ptr  10h
.text$mn:0000503C arg_C           = dword ptr  14h
.text$mn:0000503C
.text$mn:0000503C                 push    ebp
.text$mn:0000503D                 mov     ebp, esp
.text$mn:0000503F                 push    ecx
.text$mn:00005040                 mov     eax, [ebp+arg_0]
.text$mn:00005043                 push    eax
.text$mn:00005044                 mov     ecx, [ebp+arg_0]
.text$mn:00005047                 push    ecx
.text$mn:00005048                 call    ??$_Ptr_cat@HH@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAH0@Z ; std::_Ptr_cat<int,int>(int *,int *)
.text$mn:0000504D                 add     esp, 8
.text$mn:00005050                 mov     [ebp+var_1], al
.text$mn:00005053                 movzx   edx, [ebp+var_1]
.text$mn:00005057                 push    edx
.text$mn:00005058                 mov     eax, [ebp+arg_0]
.text$mn:0000505B                 push    eax
.text$mn:0000505C                 call    ??$_Val_type@PAH@std@@YAPAHPAH@Z ; std::_Val_type<int *>(int *)
.text$mn:00005061                 add     esp, 4
.text$mn:00005064                 push    eax
.text$mn:00005065                 mov     ecx, [ebp+arg_C]
.text$mn:00005068                 push    ecx
.text$mn:00005069                 mov     edx, [ebp+arg_8]
.text$mn:0000506C                 push    edx
.text$mn:0000506D                 mov     eax, [ebp+arg_4]
.text$mn:00005070                 push    eax
.text$mn:00005071                 mov     ecx, [ebp+arg_0]
.text$mn:00005074                 push    ecx
.text$mn:00005075                 call    ??$_Uninit_fill_n@HIHH@std@@YAXPAHIPBHAAU?$_Wrap_alloc@V?$allocator@H@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<int,uint,int,int>(int *,uint,int const *,std::_Wrap_alloc<std::allocator<int>> &,int *,std::_Scalar_ptr_iterator_tag)
.text$mn:0000507A                 add     esp, 18h
.text$mn:0000507D                 mov     esp, ebp
.text$mn:0000507F                 pop     ebp
.text$mn:00005080                 retn
.text$mn:00005080 ??$_Uninitialized_fill_n@PAHIHU?$_Wrap_alloc@V?$allocator@H@std@@@std@@@std@@YAXPAHIPBHAAU?$_Wrap_alloc@V?$allocator@H@std@@@0@@Z endp
.text$mn:00005080
.text$mn:00005080 ; ---------------------------------------------------------------------------
.text$mn:00005081                 align 4
.text$mn:00005081 _text$mn        ends
.text$mn:00005081
.text$mn:00005084 ; ===========================================================================
.text$mn:00005084
.text$mn:00005084 ; Segment type: Pure code
.text$mn:00005084 ; Segment permissions: Read/Execute
.text$mn:00005084 _text$mn        segment para public 'CODE' use32
.text$mn:00005084                 assume cs:_text$mn
.text$mn:00005084                 ;org 5084h
.text$mn:00005084 ; COMDAT (pick any)
.text$mn:00005084                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005084
.text$mn:00005084 ; =============== S U B R O U T I N E =======================================
.text$mn:00005084
.text$mn:00005084 ; Attributes: bp-based frame
.text$mn:00005084
.text$mn:00005084 ; int * __cdecl std::_Uninitialized_move<int *, int *, struct std::_Wrap_alloc<class std::allocator<int>>>(int *, int *, int *, struct std::_Wrap_alloc<class std::allocator<int>> &)
.text$mn:00005084                 public ??$_Uninitialized_move@PAHPAHU?$_Wrap_alloc@V?$allocator@H@std@@@std@@@std@@YAPAHPAH00AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@@Z
.text$mn:00005084 ??$_Uninitialized_move@PAHPAHU?$_Wrap_alloc@V?$allocator@H@std@@@std@@@std@@YAPAHPAH00AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@@Z proc near
.text$mn:00005084                                         ; CODE XREF: std::vector<int,std::allocator<int>>::_Umove<int *>(int *,int *,int *)+25p
.text$mn:00005084
.text$mn:00005084 arg_0           = dword ptr  8
.text$mn:00005084 arg_4           = dword ptr  0Ch
.text$mn:00005084 arg_8           = dword ptr  10h
.text$mn:00005084 arg_C           = dword ptr  14h
.text$mn:00005084
.text$mn:00005084                 push    ebp
.text$mn:00005085                 mov     ebp, esp
.text$mn:00005087                 mov     eax, [ebp+arg_C]
.text$mn:0000508A                 push    eax             ; int
.text$mn:0000508B                 mov     ecx, [ebp+arg_8]
.text$mn:0000508E                 push    ecx
.text$mn:0000508F                 call    ??$_Unchecked@PAH@std@@YAPAHPAH@Z ; std::_Unchecked<int *>(int *)
.text$mn:00005094                 add     esp, 4
.text$mn:00005097                 push    eax             ; Dst
.text$mn:00005098                 mov     edx, [ebp+arg_4]
.text$mn:0000509B                 push    edx
.text$mn:0000509C                 call    ??$_Unchecked@PAH@std@@YAPAHPAH@Z ; std::_Unchecked<int *>(int *)
.text$mn:000050A1                 add     esp, 4
.text$mn:000050A4                 push    eax             ; int
.text$mn:000050A5                 mov     eax, [ebp+arg_0]
.text$mn:000050A8                 push    eax
.text$mn:000050A9                 call    ??$_Unchecked@PAH@std@@YAPAHPAH@Z ; std::_Unchecked<int *>(int *)
.text$mn:000050AE                 add     esp, 4
.text$mn:000050B1                 push    eax             ; Src
.text$mn:000050B2                 call    ??$_Uninit_move@PAHPAHU?$_Wrap_alloc@V?$allocator@H@std@@@std@@@std@@YAPAHPAH00AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@@Z ; std::_Uninit_move<int *,int *,std::_Wrap_alloc<std::allocator<int>>>(int *,int *,int *,std::_Wrap_alloc<std::allocator<int>> &)
.text$mn:000050B7                 add     esp, 10h
.text$mn:000050BA                 push    eax
.text$mn:000050BB                 lea     ecx, [ebp+arg_8]
.text$mn:000050BE                 push    ecx
.text$mn:000050BF                 call    ??$_Rechecked@PAHPAH@std@@YAAAPAHAAPAHPAH@Z ; std::_Rechecked<int *,int *>(int * &,int *)
.text$mn:000050C4                 add     esp, 8
.text$mn:000050C7                 mov     eax, [eax]
.text$mn:000050C9                 pop     ebp
.text$mn:000050CA                 retn
.text$mn:000050CA ??$_Uninitialized_move@PAHPAHU?$_Wrap_alloc@V?$allocator@H@std@@@std@@@std@@YAPAHPAH00AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@@Z endp
.text$mn:000050CA
.text$mn:000050CA ; ---------------------------------------------------------------------------
.text$mn:000050CB                 align 4
.text$mn:000050CB _text$mn        ends
.text$mn:000050CB
.text$mn:000050CC ; ===========================================================================
.text$mn:000050CC
.text$mn:000050CC ; Segment type: Pure code
.text$mn:000050CC ; Segment permissions: Read/Execute
.text$mn:000050CC _text$mn        segment para public 'CODE' use32
.text$mn:000050CC                 assume cs:_text$mn
.text$mn:000050CC                 ;org 50CCh
.text$mn:000050CC ; COMDAT (pick any)
.text$mn:000050CC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000050CC
.text$mn:000050CC ; =============== S U B R O U T I N E =======================================
.text$mn:000050CC
.text$mn:000050CC ; Attributes: bp-based frame
.text$mn:000050CC
.text$mn:000050CC ; wchar_t * __cdecl std::_Uninitialized_move<wchar_t *, wchar_t *, struct std::_Wrap_alloc<class std::allocator<wchar_t>>>(wchar_t *, wchar_t *, wchar_t *, struct std::_Wrap_alloc<class std::allocator<wchar_t>> &)
.text$mn:000050CC                 public ??$_Uninitialized_move@PA_WPA_WU?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YAPA_WPA_W00AAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@@Z
.text$mn:000050CC ??$_Uninitialized_move@PA_WPA_WU?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YAPA_WPA_W00AAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@@Z proc near
.text$mn:000050CC                                         ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::_Umove<wchar_t *>(wchar_t *,wchar_t *,wchar_t *)+25p
.text$mn:000050CC
.text$mn:000050CC arg_0           = dword ptr  8
.text$mn:000050CC arg_4           = dword ptr  0Ch
.text$mn:000050CC arg_8           = dword ptr  10h
.text$mn:000050CC arg_C           = dword ptr  14h
.text$mn:000050CC
.text$mn:000050CC                 push    ebp
.text$mn:000050CD                 mov     ebp, esp
.text$mn:000050CF                 mov     eax, [ebp+arg_C]
.text$mn:000050D2                 push    eax             ; int
.text$mn:000050D3                 mov     ecx, [ebp+arg_8]
.text$mn:000050D6                 push    ecx
.text$mn:000050D7                 call    ??$_Unchecked@PA_W@std@@YAPA_WPA_W@Z ; std::_Unchecked<wchar_t *>(wchar_t *)
.text$mn:000050DC                 add     esp, 4
.text$mn:000050DF                 push    eax             ; Dst
.text$mn:000050E0                 mov     edx, [ebp+arg_4]
.text$mn:000050E3                 push    edx
.text$mn:000050E4                 call    ??$_Unchecked@PA_W@std@@YAPA_WPA_W@Z ; std::_Unchecked<wchar_t *>(wchar_t *)
.text$mn:000050E9                 add     esp, 4
.text$mn:000050EC                 push    eax             ; int
.text$mn:000050ED                 mov     eax, [ebp+arg_0]
.text$mn:000050F0                 push    eax
.text$mn:000050F1                 call    ??$_Unchecked@PA_W@std@@YAPA_WPA_W@Z ; std::_Unchecked<wchar_t *>(wchar_t *)
.text$mn:000050F6                 add     esp, 4
.text$mn:000050F9                 push    eax             ; Src
.text$mn:000050FA                 call    ??$_Uninit_move@PA_WPA_WU?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YAPA_WPA_W00AAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@@Z ; std::_Uninit_move<wchar_t *,wchar_t *,std::_Wrap_alloc<std::allocator<wchar_t>>>(wchar_t *,wchar_t *,wchar_t *,std::_Wrap_alloc<std::allocator<wchar_t>> &)
.text$mn:000050FF                 add     esp, 10h
.text$mn:00005102                 push    eax
.text$mn:00005103                 lea     ecx, [ebp+arg_8]
.text$mn:00005106                 push    ecx
.text$mn:00005107                 call    ??$_Rechecked@PA_WPA_W@std@@YAAAPA_WAAPA_WPA_W@Z ; std::_Rechecked<wchar_t *,wchar_t *>(wchar_t * &,wchar_t *)
.text$mn:0000510C                 add     esp, 8
.text$mn:0000510F                 mov     eax, [eax]
.text$mn:00005111                 pop     ebp
.text$mn:00005112                 retn
.text$mn:00005112 ??$_Uninitialized_move@PA_WPA_WU?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YAPA_WPA_W00AAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@@Z endp
.text$mn:00005112
.text$mn:00005112 ; ---------------------------------------------------------------------------
.text$mn:00005113                 align 4
.text$mn:00005113 _text$mn        ends
.text$mn:00005113
.text$mn:00005114 ; ===========================================================================
.text$mn:00005114
.text$mn:00005114 ; Segment type: Pure code
.text$mn:00005114 ; Segment permissions: Read/Execute
.text$mn:00005114 _text$mn        segment para public 'CODE' use32
.text$mn:00005114                 assume cs:_text$mn
.text$mn:00005114                 ;org 5114h
.text$mn:00005114 ; COMDAT (pick any)
.text$mn:00005114                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005114
.text$mn:00005114 ; =============== S U B R O U T I N E =======================================
.text$mn:00005114
.text$mn:00005114 ; Attributes: bp-based frame
.text$mn:00005114
.text$mn:00005114 ; int * __cdecl std::_Upper_bound<int *, int, int, struct BufferEquivalent>(int *, int *, int const &, struct BufferEquivalent, int *)
.text$mn:00005114                 public ??$_Upper_bound@PAHHHUBufferEquivalent@@@std@@YAPAHPAH0ABHUBufferEquivalent@@0@Z
.text$mn:00005114 ??$_Upper_bound@PAHHHUBufferEquivalent@@@std@@YAPAHPAH0ABHUBufferEquivalent@@0@Z proc near
.text$mn:00005114                                         ; CODE XREF: std::upper_bound<int *,int,BufferEquivalent>(int *,int *,int const &,BufferEquivalent)+4Ap
.text$mn:00005114
.text$mn:00005114 var_C           = dword ptr -0Ch
.text$mn:00005114 var_8           = dword ptr -8
.text$mn:00005114 var_4           = dword ptr -4
.text$mn:00005114 arg_0           = dword ptr  8
.text$mn:00005114 arg_4           = dword ptr  0Ch
.text$mn:00005114 arg_8           = dword ptr  10h
.text$mn:00005114 arg_C           = byte ptr  14h
.text$mn:00005114
.text$mn:00005114                 push    ebp
.text$mn:00005115                 mov     ebp, esp
.text$mn:00005117                 sub     esp, 0Ch
.text$mn:0000511A                 mov     [ebp+var_4], 0
.text$mn:00005121                 lea     eax, [ebp+var_4]
.text$mn:00005124                 push    eax
.text$mn:00005125                 mov     ecx, [ebp+arg_4]
.text$mn:00005128                 push    ecx
.text$mn:00005129                 mov     edx, [ebp+arg_0]
.text$mn:0000512C                 push    edx
.text$mn:0000512D                 call    ??$_Distance@PAHH@std@@YAXPAH0AAH@Z ; std::_Distance<int *,int>(int *,int *,int &)
.text$mn:00005132                 add     esp, 0Ch
.text$mn:00005135
.text$mn:00005135 loc_5135:                               ; CODE XREF: std::_Upper_bound<int *,int,int,BufferEquivalent>(int *,int *,int const &,BufferEquivalent,int *):loc_519Cj
.text$mn:00005135                 cmp     [ebp+var_4], 0
.text$mn:00005139                 jle     short loc_519E
.text$mn:0000513B                 mov     eax, [ebp+var_4]
.text$mn:0000513E                 cdq
.text$mn:0000513F                 sub     eax, edx
.text$mn:00005141                 sar     eax, 1
.text$mn:00005143                 mov     [ebp+var_C], eax
.text$mn:00005146                 mov     eax, [ebp+arg_0]
.text$mn:00005149                 mov     [ebp+var_8], eax
.text$mn:0000514C                 mov     ecx, [ebp+var_C]
.text$mn:0000514F                 push    ecx
.text$mn:00005150                 lea     edx, [ebp+var_8]
.text$mn:00005153                 push    edx
.text$mn:00005154                 call    ??$advance@PAHH@std@@YAXAAPAHH@Z ; std::advance<int *,int>(int * &,int)
.text$mn:00005159                 add     esp, 8
.text$mn:0000515C                 mov     eax, [ebp+var_8]
.text$mn:0000515F                 mov     ecx, [eax]
.text$mn:00005161                 push    ecx
.text$mn:00005162                 mov     edx, [ebp+arg_8]
.text$mn:00005165                 mov     eax, [edx]
.text$mn:00005167                 push    eax
.text$mn:00005168                 lea     ecx, [ebp+arg_C]
.text$mn:0000516B                 call    ??RBufferEquivalent@@QBE_NHH@Z ; BufferEquivalent::operator()(int,int)
.text$mn:00005170                 movzx   ecx, al
.text$mn:00005173                 test    ecx, ecx
.text$mn:00005175                 jnz     short loc_5196
.text$mn:00005177                 mov     edx, [ebp+var_8]
.text$mn:0000517A                 add     edx, 4
.text$mn:0000517D                 mov     [ebp+var_8], edx
.text$mn:00005180                 mov     eax, [ebp+var_8]
.text$mn:00005183                 mov     [ebp+arg_0], eax
.text$mn:00005186                 mov     ecx, [ebp+var_C]
.text$mn:00005189                 add     ecx, 1
.text$mn:0000518C                 mov     edx, [ebp+var_4]
.text$mn:0000518F                 sub     edx, ecx
.text$mn:00005191                 mov     [ebp+var_4], edx
.text$mn:00005194                 jmp     short loc_519C
.text$mn:00005196 ; ---------------------------------------------------------------------------
.text$mn:00005196
.text$mn:00005196 loc_5196:                               ; CODE XREF: std::_Upper_bound<int *,int,int,BufferEquivalent>(int *,int *,int const &,BufferEquivalent,int *)+61j
.text$mn:00005196                 mov     eax, [ebp+var_C]
.text$mn:00005199                 mov     [ebp+var_4], eax
.text$mn:0000519C
.text$mn:0000519C loc_519C:                               ; CODE XREF: std::_Upper_bound<int *,int,int,BufferEquivalent>(int *,int *,int const &,BufferEquivalent,int *)+80j
.text$mn:0000519C                 jmp     short loc_5135
.text$mn:0000519E ; ---------------------------------------------------------------------------
.text$mn:0000519E
.text$mn:0000519E loc_519E:                               ; CODE XREF: std::_Upper_bound<int *,int,int,BufferEquivalent>(int *,int *,int const &,BufferEquivalent,int *)+25j
.text$mn:0000519E                 mov     eax, [ebp+arg_0]
.text$mn:000051A1                 mov     esp, ebp
.text$mn:000051A3                 pop     ebp
.text$mn:000051A4                 retn
.text$mn:000051A4 ??$_Upper_bound@PAHHHUBufferEquivalent@@@std@@YAPAHPAH0ABHUBufferEquivalent@@0@Z endp
.text$mn:000051A4
.text$mn:000051A4 ; ---------------------------------------------------------------------------
.text$mn:000051A5                 align 4
.text$mn:000051A5 _text$mn        ends
.text$mn:000051A5
.text$mn:000051A8 ; ===========================================================================
.text$mn:000051A8
.text$mn:000051A8 ; Segment type: Pure code
.text$mn:000051A8 ; Segment permissions: Read/Execute
.text$mn:000051A8 _text$mn        segment para public 'CODE' use32
.text$mn:000051A8                 assume cs:_text$mn
.text$mn:000051A8                 ;org 51A8h
.text$mn:000051A8 ; COMDAT (pick any)
.text$mn:000051A8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000051A8
.text$mn:000051A8 ; =============== S U B R O U T I N E =======================================
.text$mn:000051A8
.text$mn:000051A8 ; Attributes: bp-based frame
.text$mn:000051A8
.text$mn:000051A8 ; int * __cdecl std::_Val_type<int *>(int *)
.text$mn:000051A8                 public ??$_Val_type@PAH@std@@YAPAHPAH@Z
.text$mn:000051A8 ??$_Val_type@PAH@std@@YAPAHPAH@Z proc near
.text$mn:000051A8                                         ; CODE XREF: std::_Insertion_sort<int *,BufferEquivalent>(int *,int *,BufferEquivalent)+7p
.text$mn:000051A8                                         ; std::_Rotate<int *>(int *,int *,int *,std::random_access_iterator_tag)+7p ...
.text$mn:000051A8                 push    ebp
.text$mn:000051A9                 mov     ebp, esp
.text$mn:000051AB                 xor     eax, eax
.text$mn:000051AD                 pop     ebp
.text$mn:000051AE                 retn
.text$mn:000051AE ??$_Val_type@PAH@std@@YAPAHPAH@Z endp
.text$mn:000051AE
.text$mn:000051AE ; ---------------------------------------------------------------------------
.text$mn:000051AF                 align 10h
.text$mn:000051AF _text$mn        ends
.text$mn:000051AF
.text$mn:000051B0 ; ===========================================================================
.text$mn:000051B0
.text$mn:000051B0 ; Segment type: Pure code
.text$mn:000051B0 ; Segment permissions: Read/Execute
.text$mn:000051B0 _text$mn        segment para public 'CODE' use32
.text$mn:000051B0                 assume cs:_text$mn
.text$mn:000051B0                 ;org 51B0h
.text$mn:000051B0 ; COMDAT (pick any)
.text$mn:000051B0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000051B0
.text$mn:000051B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000051B0
.text$mn:000051B0 ; Attributes: bp-based frame
.text$mn:000051B0
.text$mn:000051B0 ; wchar_t * __cdecl std::_Val_type<wchar_t *>(wchar_t *)
.text$mn:000051B0                 public ??$_Val_type@PA_W@std@@YAPA_WPA_W@Z
.text$mn:000051B0 ??$_Val_type@PA_W@std@@YAPA_WPA_W@Z proc near
.text$mn:000051B0                                         ; CODE XREF: std::_Uninit_move<wchar_t *,wchar_t *,std::_Wrap_alloc<std::allocator<wchar_t>>>(wchar_t *,wchar_t *,wchar_t *,std::_Wrap_alloc<std::allocator<wchar_t>> &)+20p
.text$mn:000051B0                 push    ebp
.text$mn:000051B1                 mov     ebp, esp
.text$mn:000051B3                 xor     eax, eax
.text$mn:000051B5                 pop     ebp
.text$mn:000051B6                 retn
.text$mn:000051B6 ??$_Val_type@PA_W@std@@YAPA_WPA_W@Z endp
.text$mn:000051B6
.text$mn:000051B6 ; ---------------------------------------------------------------------------
.text$mn:000051B7                 align 4
.text$mn:000051B7 _text$mn        ends
.text$mn:000051B7
.text$mn:000051B8 ; ===========================================================================
.text$mn:000051B8
.text$mn:000051B8 ; Segment type: Pure code
.text$mn:000051B8 ; Segment permissions: Read/Execute
.text$mn:000051B8 _text$mn        segment para public 'CODE' use32
.text$mn:000051B8                 assume cs:_text$mn
.text$mn:000051B8                 ;org 51B8h
.text$mn:000051B8 ; COMDAT (pick any)
.text$mn:000051B8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000051B8
.text$mn:000051B8 ; =============== S U B R O U T I N E =======================================
.text$mn:000051B8
.text$mn:000051B8 ; Attributes: bp-based frame
.text$mn:000051B8
.text$mn:000051B8 ; int * __cdecl std::_Val_type<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<int>>>>(class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<int>>>)
.text$mn:000051B8                 public ??$_Val_type@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAPAHV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@@Z
.text$mn:000051B8 ??$_Val_type@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAPAHV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@@Z proc near
.text$mn:000051B8                                         ; CODE XREF: std::stable_sort<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,BufferEquivalent>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,BufferEquivalent)+E9p
.text$mn:000051B8
.text$mn:000051B8 var_10          = dword ptr -10h
.text$mn:000051B8 var_C           = dword ptr -0Ch
.text$mn:000051B8 var_4           = dword ptr -4
.text$mn:000051B8 arg_0           = byte ptr  8
.text$mn:000051B8
.text$mn:000051B8                 push    ebp
.text$mn:000051B9                 mov     ebp, esp
.text$mn:000051BB                 push    0FFFFFFFFh
.text$mn:000051BD                 push    offset __ehhandler$??$_Val_type@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAPAHV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@@Z
.text$mn:000051C2                 mov     eax, large fs:0
.text$mn:000051C8                 push    eax
.text$mn:000051C9                 push    ecx
.text$mn:000051CA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000051CF                 xor     eax, ebp
.text$mn:000051D1                 push    eax
.text$mn:000051D2                 lea     eax, [ebp+var_C]
.text$mn:000051D5                 mov     large fs:0, eax
.text$mn:000051DB                 mov     [ebp+var_4], 0
.text$mn:000051E2                 mov     [ebp+var_10], 0
.text$mn:000051E9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000051F0                 lea     ecx, [ebp+arg_0]
.text$mn:000051F3                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$mn:000051F8                 mov     eax, [ebp+var_10]
.text$mn:000051FB                 mov     ecx, [ebp+var_C]
.text$mn:000051FE                 mov     large fs:0, ecx
.text$mn:00005205                 pop     ecx
.text$mn:00005206                 mov     esp, ebp
.text$mn:00005208                 pop     ebp
.text$mn:00005209                 retn
.text$mn:00005209 ??$_Val_type@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAPAHV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@@Z endp
.text$mn:00005209
.text$mn:00005209 ; ---------------------------------------------------------------------------
.text$mn:0000520A                 align 4
.text$mn:0000520A _text$mn        ends
.text$mn:0000520A
.text$x:0000520C ; ===========================================================================
.text$x:0000520C
.text$x:0000520C ; Segment type: Pure code
.text$x:0000520C ; Segment permissions: Read/Execute
.text$x:0000520C _text$x         segment para public 'CODE' use32
.text$x:0000520C                 assume cs:_text$x
.text$x:0000520C                 ;org 520Ch
.text$x:0000520C ; COMDAT (pick associative to section at 51B8)
.text$x:0000520C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000520C
.text$x:0000520C ; =============== S U B R O U T I N E =======================================
.text$x:0000520C
.text$x:0000520C
.text$x:0000520C __unwindfunclet$??$_Val_type@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAPAHV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@@Z$0 proc near
.text$x:0000520C                                         ; DATA XREF: .xdata$x:0000D718o
.text$x:0000520C                 lea     ecx, [ebp+8]
.text$x:0000520F                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$x:0000520F __unwindfunclet$??$_Val_type@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAPAHV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@@Z$0 endp
.text$x:0000520F
.text$x:00005214
.text$x:00005214 ; =============== S U B R O U T I N E =======================================
.text$x:00005214
.text$x:00005214
.text$x:00005214 __ehhandler$??$_Val_type@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAPAHV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@@Z proc near
.text$x:00005214                                         ; DATA XREF: std::_Val_type<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>)+5o
.text$x:00005214
.text$x:00005214 arg_4           = dword ptr  8
.text$x:00005214
.text$x:00005214                 mov     edx, [esp+arg_4]
.text$x:00005218                 lea     eax, [edx+0Ch]
.text$x:0000521B                 mov     ecx, [edx-8]
.text$x:0000521E                 xor     ecx, eax
.text$x:00005220                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005225                 mov     eax, offset __ehfuncinfo$??$_Val_type@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAPAHV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@@Z
.text$x:0000522A                 jmp     ___CxxFrameHandler3
.text$x:0000522A __ehhandler$??$_Val_type@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAPAHV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@@Z endp
.text$x:0000522A
.text$x:0000522A ; ---------------------------------------------------------------------------
.text$x:0000522F                 align 10h
.text$x:0000522F _text$x         ends
.text$x:0000522F
.text$mn:00005230 ; ===========================================================================
.text$mn:00005230
.text$mn:00005230 ; Segment type: Pure code
.text$mn:00005230 ; Segment permissions: Read/Execute
.text$mn:00005230 _text$mn        segment para public 'CODE' use32
.text$mn:00005230                 assume cs:_text$mn
.text$mn:00005230                 ;org 5230h
.text$mn:00005230 ; COMDAT (pick any)
.text$mn:00005230                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005230
.text$mn:00005230 ; =============== S U B R O U T I N E =======================================
.text$mn:00005230
.text$mn:00005230 ; Attributes: bp-based frame
.text$mn:00005230
.text$mn:00005230 ; int const * __cdecl std::addressof<int const>(int const &)
.text$mn:00005230                 public ??$addressof@$$CBH@std@@YAPBHABH@Z
.text$mn:00005230 ??$addressof@$$CBH@std@@YAPBHABH@Z proc near
.text$mn:00005230                                         ; CODE XREF: std::vector<int,std::allocator<int>>::resize(uint,int const &)+6Ap
.text$mn:00005230
.text$mn:00005230 arg_0           = dword ptr  8
.text$mn:00005230
.text$mn:00005230                 push    ebp
.text$mn:00005231                 mov     ebp, esp
.text$mn:00005233                 mov     eax, [ebp+arg_0]
.text$mn:00005236                 pop     ebp
.text$mn:00005237                 retn
.text$mn:00005237 ??$addressof@$$CBH@std@@YAPBHABH@Z endp
.text$mn:00005237
.text$mn:00005237 _text$mn        ends
.text$mn:00005237
.text$mn:00005238 ; ===========================================================================
.text$mn:00005238
.text$mn:00005238 ; Segment type: Pure code
.text$mn:00005238 ; Segment permissions: Read/Execute
.text$mn:00005238 _text$mn        segment para public 'CODE' use32
.text$mn:00005238                 assume cs:_text$mn
.text$mn:00005238                 ;org 5238h
.text$mn:00005238 ; COMDAT (pick any)
.text$mn:00005238                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005238
.text$mn:00005238 ; =============== S U B R O U T I N E =======================================
.text$mn:00005238
.text$mn:00005238 ; Attributes: bp-based frame
.text$mn:00005238
.text$mn:00005238 ; char * __cdecl std::addressof<char>(char &)
.text$mn:00005238                 public ??$addressof@D@std@@YAPADAAD@Z
.text$mn:00005238 ??$addressof@D@std@@YAPADAAD@Z proc near
.text$mn:00005238                                         ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+19p
.text$mn:00005238                                         ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)+19p ...
.text$mn:00005238
.text$mn:00005238 arg_0           = dword ptr  8
.text$mn:00005238
.text$mn:00005238                 push    ebp
.text$mn:00005239                 mov     ebp, esp
.text$mn:0000523B                 mov     eax, [ebp+arg_0]
.text$mn:0000523E                 pop     ebp
.text$mn:0000523F                 retn
.text$mn:0000523F ??$addressof@D@std@@YAPADAAD@Z endp
.text$mn:0000523F
.text$mn:0000523F _text$mn        ends
.text$mn:0000523F
.text$mn:00005240 ; ===========================================================================
.text$mn:00005240
.text$mn:00005240 ; Segment type: Pure code
.text$mn:00005240 ; Segment permissions: Read/Execute
.text$mn:00005240 _text$mn        segment para public 'CODE' use32
.text$mn:00005240                 assume cs:_text$mn
.text$mn:00005240                 ;org 5240h
.text$mn:00005240 ; COMDAT (pick any)
.text$mn:00005240                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005240
.text$mn:00005240 ; =============== S U B R O U T I N E =======================================
.text$mn:00005240
.text$mn:00005240 ; Attributes: bp-based frame
.text$mn:00005240
.text$mn:00005240 ; int * __cdecl std::addressof<int>(int &)
.text$mn:00005240                 public ??$addressof@H@std@@YAPAHAAH@Z
.text$mn:00005240 ??$addressof@H@std@@YAPAHAAH@Z proc near
.text$mn:00005240                                         ; CODE XREF: std::vector<int,std::allocator<int>>::resize(uint,int const &)+8Fp
.text$mn:00005240                                         ; std::vector<int,std::allocator<int>>::resize(uint,int const &)+BFp
.text$mn:00005240
.text$mn:00005240 arg_0           = dword ptr  8
.text$mn:00005240
.text$mn:00005240                 push    ebp
.text$mn:00005241                 mov     ebp, esp
.text$mn:00005243                 mov     eax, [ebp+arg_0]
.text$mn:00005246                 pop     ebp
.text$mn:00005247                 retn
.text$mn:00005247 ??$addressof@H@std@@YAPAHAAH@Z endp
.text$mn:00005247
.text$mn:00005247 _text$mn        ends
.text$mn:00005247
.text$mn:00005248 ; ===========================================================================
.text$mn:00005248
.text$mn:00005248 ; Segment type: Pure code
.text$mn:00005248 ; Segment permissions: Read/Execute
.text$mn:00005248 _text$mn        segment para public 'CODE' use32
.text$mn:00005248                 assume cs:_text$mn
.text$mn:00005248                 ;org 5248h
.text$mn:00005248 ; COMDAT (pick any)
.text$mn:00005248                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005248
.text$mn:00005248 ; =============== S U B R O U T I N E =======================================
.text$mn:00005248
.text$mn:00005248 ; Attributes: bp-based frame
.text$mn:00005248
.text$mn:00005248 ; wchar_t * __cdecl std::addressof<wchar_t>(wchar_t &)
.text$mn:00005248                 public ??$addressof@_W@std@@YAPA_WAA_W@Z
.text$mn:00005248 ??$addressof@_W@std@@YAPA_WAA_W@Z proc near
.text$mn:00005248                                         ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+19p
.text$mn:00005248                                         ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+19p ...
.text$mn:00005248
.text$mn:00005248 arg_0           = dword ptr  8
.text$mn:00005248
.text$mn:00005248                 push    ebp
.text$mn:00005249                 mov     ebp, esp
.text$mn:0000524B                 mov     eax, [ebp+arg_0]
.text$mn:0000524E                 pop     ebp
.text$mn:0000524F                 retn
.text$mn:0000524F ??$addressof@_W@std@@YAPA_WAA_W@Z endp
.text$mn:0000524F
.text$mn:0000524F _text$mn        ends
.text$mn:0000524F
.text$mn:00005250 ; ===========================================================================
.text$mn:00005250
.text$mn:00005250 ; Segment type: Pure code
.text$mn:00005250 ; Segment permissions: Read/Execute
.text$mn:00005250 _text$mn        segment para public 'CODE' use32
.text$mn:00005250                 assume cs:_text$mn
.text$mn:00005250                 ;org 5250h
.text$mn:00005250 ; COMDAT (pick any)
.text$mn:00005250                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005250
.text$mn:00005250 ; =============== S U B R O U T I N E =======================================
.text$mn:00005250
.text$mn:00005250 ; Attributes: bp-based frame
.text$mn:00005250
.text$mn:00005250 ; void __cdecl std::advance<int *, int>(int * &, int)
.text$mn:00005250                 public ??$advance@PAHH@std@@YAXAAPAHH@Z
.text$mn:00005250 ??$advance@PAHH@std@@YAXAAPAHH@Z proc near
.text$mn:00005250                                         ; CODE XREF: std::_Buffered_merge<int *,int,int,BufferEquivalent>(int *,int *,int *,int,int,std::_Temp_iterator<int> &,BufferEquivalent)+20Fp
.text$mn:00005250                                         ; std::_Buffered_merge<int *,int,int,BufferEquivalent>(int *,int *,int *,int,int,std::_Temp_iterator<int> &,BufferEquivalent)+27Dp ...
.text$mn:00005250
.text$mn:00005250 var_1           = byte ptr -1
.text$mn:00005250 arg_0           = dword ptr  8
.text$mn:00005250 arg_4           = dword ptr  0Ch
.text$mn:00005250
.text$mn:00005250                 push    ebp
.text$mn:00005251                 mov     ebp, esp
.text$mn:00005253                 push    ecx
.text$mn:00005254                 mov     eax, [ebp+arg_0]
.text$mn:00005257                 push    eax
.text$mn:00005258                 lea     ecx, [ebp+var_1]
.text$mn:0000525B                 push    ecx
.text$mn:0000525C                 call    ??$_Iter_cat@PAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH@Z ; std::_Iter_cat<int *>(int * const &)
.text$mn:00005261                 add     esp, 8
.text$mn:00005264                 mov     dl, [eax]
.text$mn:00005266                 movzx   eax, dl
.text$mn:00005269                 push    eax
.text$mn:0000526A                 mov     ecx, [ebp+arg_4]
.text$mn:0000526D                 push    ecx
.text$mn:0000526E                 mov     edx, [ebp+arg_0]
.text$mn:00005271                 push    edx
.text$mn:00005272                 call    ??$_Advance@PAHH@std@@YAXAAPAHHUrandom_access_iterator_tag@0@@Z ; std::_Advance<int *,int>(int * &,int,std::random_access_iterator_tag)
.text$mn:00005277                 add     esp, 0Ch
.text$mn:0000527A                 mov     esp, ebp
.text$mn:0000527C                 pop     ebp
.text$mn:0000527D                 retn
.text$mn:0000527D ??$advance@PAHH@std@@YAXAAPAHH@Z endp
.text$mn:0000527D
.text$mn:0000527D ; ---------------------------------------------------------------------------
.text$mn:0000527E                 align 10h
.text$mn:0000527E _text$mn        ends
.text$mn:0000527E
.text$mn:00005280 ; ===========================================================================
.text$mn:00005280
.text$mn:00005280 ; Segment type: Pure code
.text$mn:00005280 ; Segment permissions: Read/Execute
.text$mn:00005280 _text$mn        segment para public 'CODE' use32
.text$mn:00005280                 assume cs:_text$mn
.text$mn:00005280                 ;org 5280h
.text$mn:00005280 ; COMDAT (pick any)
.text$mn:00005280                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005280
.text$mn:00005280 ; =============== S U B R O U T I N E =======================================
.text$mn:00005280
.text$mn:00005280 ; Attributes: bp-based frame
.text$mn:00005280
.text$mn:00005280 ; class std::binder2nd<struct std::equal_to<int>> __cdecl std::bind2nd<struct std::equal_to<int>, int>(struct std::equal_to<int> const &, int const &)
.text$mn:00005280                 public ??$bind2nd@U?$equal_to@H@std@@H@std@@YA?AV?$binder2nd@U?$equal_to@H@std@@@0@ABU?$equal_to@H@0@ABH@Z
.text$mn:00005280 ??$bind2nd@U?$equal_to@H@std@@H@std@@YA?AV?$binder2nd@U?$equal_to@H@std@@@0@ABU?$equal_to@H@0@ABH@Z proc near
.text$mn:00005280                                         ; CODE XREF: WindowsDlg::doClose(void)+33Bp
.text$mn:00005280
.text$mn:00005280 var_4           = dword ptr -4
.text$mn:00005280 arg_0           = dword ptr  8
.text$mn:00005280 arg_4           = dword ptr  0Ch
.text$mn:00005280 arg_8           = dword ptr  10h
.text$mn:00005280
.text$mn:00005280                 push    ebp
.text$mn:00005281                 mov     ebp, esp
.text$mn:00005283                 push    ecx
.text$mn:00005284                 mov     eax, [ebp+arg_8]
.text$mn:00005287                 mov     ecx, [eax]
.text$mn:00005289                 mov     [ebp+var_4], ecx
.text$mn:0000528C                 lea     edx, [ebp+var_4]
.text$mn:0000528F                 push    edx
.text$mn:00005290                 mov     eax, [ebp+arg_4]
.text$mn:00005293                 push    eax
.text$mn:00005294                 mov     ecx, [ebp+arg_0]
.text$mn:00005297                 call    ??0?$binder2nd@U?$equal_to@H@std@@@std@@QAE@ABU?$equal_to@H@1@ABH@Z ; std::binder2nd<std::equal_to<int>>::binder2nd<std::equal_to<int>>(std::equal_to<int> const &,int const &)
.text$mn:0000529C                 mov     eax, [ebp+arg_0]
.text$mn:0000529F                 mov     esp, ebp
.text$mn:000052A1                 pop     ebp
.text$mn:000052A2                 retn
.text$mn:000052A2 ??$bind2nd@U?$equal_to@H@std@@H@std@@YA?AV?$binder2nd@U?$equal_to@H@std@@@0@ABU?$equal_to@H@0@ABH@Z endp
.text$mn:000052A2
.text$mn:000052A2 ; ---------------------------------------------------------------------------
.text$mn:000052A3                 align 4
.text$mn:000052A3 _text$mn        ends
.text$mn:000052A3
.text$mn:000052A4 ; ===========================================================================
.text$mn:000052A4
.text$mn:000052A4 ; Segment type: Pure code
.text$mn:000052A4 ; Segment permissions: Read/Execute
.text$mn:000052A4 _text$mn        segment para public 'CODE' use32
.text$mn:000052A4                 assume cs:_text$mn
.text$mn:000052A4                 ;org 52A4h
.text$mn:000052A4 ; COMDAT (pick any)
.text$mn:000052A4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000052A4
.text$mn:000052A4 ; =============== S U B R O U T I N E =======================================
.text$mn:000052A4
.text$mn:000052A4 ; Attributes: bp-based frame
.text$mn:000052A4
.text$mn:000052A4 ; int __stdcall std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(void *, int)
.text$mn:000052A4                 public ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
.text$mn:000052A4 ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z proc near
.text$mn:000052A4                                         ; CODE XREF: $LN19+4Bp
.text$mn:000052A4
.text$mn:000052A4 var_4           = dword ptr -4
.text$mn:000052A4 arg_0           = dword ptr  8
.text$mn:000052A4 arg_4           = dword ptr  0Ch
.text$mn:000052A4
.text$mn:000052A4                 push    ebp
.text$mn:000052A5                 mov     ebp, esp
.text$mn:000052A7                 push    ecx
.text$mn:000052A8                 mov     [ebp+var_4], ecx
.text$mn:000052AB                 mov     eax, [ebp+arg_4]
.text$mn:000052AE                 push    eax
.text$mn:000052AF                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:000052B4                 add     esp, 4
.text$mn:000052B7                 push    eax             ; int
.text$mn:000052B8                 mov     ecx, [ebp+arg_0]
.text$mn:000052BB                 push    ecx             ; void *
.text$mn:000052BC                 mov     edx, [ebp+var_4]
.text$mn:000052BF                 push    edx             ; int
.text$mn:000052C0                 call    ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(std::allocator<char> &,char * *,char * &)
.text$mn:000052C5                 add     esp, 0Ch
.text$mn:000052C8                 mov     esp, ebp
.text$mn:000052CA                 pop     ebp
.text$mn:000052CB                 retn    8
.text$mn:000052CB ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z endp
.text$mn:000052CB
.text$mn:000052CB ; ---------------------------------------------------------------------------
.text$mn:000052CE                 align 10h
.text$mn:000052CE _text$mn        ends
.text$mn:000052CE
.text$mn:000052D0 ; ===========================================================================
.text$mn:000052D0
.text$mn:000052D0 ; Segment type: Pure code
.text$mn:000052D0 ; Segment permissions: Read/Execute
.text$mn:000052D0 _text$mn        segment para public 'CODE' use32
.text$mn:000052D0                 assume cs:_text$mn
.text$mn:000052D0                 ;org 52D0h
.text$mn:000052D0 ; COMDAT (pick any)
.text$mn:000052D0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000052D0
.text$mn:000052D0 ; =============== S U B R O U T I N E =======================================
.text$mn:000052D0
.text$mn:000052D0 ; Attributes: bp-based frame
.text$mn:000052D0
.text$mn:000052D0 ; int __stdcall std::allocator<char>::construct<char *,char * &>(void *, int)
.text$mn:000052D0                 public ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$mn:000052D0 ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
.text$mn:000052D0                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(std::allocator<char> &,char * *,char * &)+17p
.text$mn:000052D0
.text$mn:000052D0 var_1C          = dword ptr -1Ch
.text$mn:000052D0 var_18          = dword ptr -18h
.text$mn:000052D0 var_14          = dword ptr -14h
.text$mn:000052D0 var_10          = dword ptr -10h
.text$mn:000052D0 var_C           = dword ptr -0Ch
.text$mn:000052D0 var_4           = dword ptr -4
.text$mn:000052D0 arg_0           = dword ptr  8
.text$mn:000052D0 arg_4           = dword ptr  0Ch
.text$mn:000052D0
.text$mn:000052D0                 push    ebp
.text$mn:000052D1                 mov     ebp, esp
.text$mn:000052D3                 push    0FFFFFFFFh
.text$mn:000052D5                 push    offset __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$mn:000052DA                 mov     eax, large fs:0
.text$mn:000052E0                 push    eax
.text$mn:000052E1                 sub     esp, 10h
.text$mn:000052E4                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000052E9                 xor     eax, ebp
.text$mn:000052EB                 push    eax
.text$mn:000052EC                 lea     eax, [ebp+var_C]
.text$mn:000052EF                 mov     large fs:0, eax
.text$mn:000052F5                 mov     [ebp+var_18], ecx
.text$mn:000052F8                 mov     eax, [ebp+arg_0]
.text$mn:000052FB                 push    eax             ; void *
.text$mn:000052FC                 push    4               ; unsigned int
.text$mn:000052FE                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00005303                 add     esp, 8
.text$mn:00005306                 mov     [ebp+var_10], eax
.text$mn:00005309                 mov     [ebp+var_4], 0
.text$mn:00005310                 cmp     [ebp+var_10], 0
.text$mn:00005314                 jz      short loc_5331
.text$mn:00005316                 mov     ecx, [ebp+arg_4]
.text$mn:00005319                 push    ecx
.text$mn:0000531A                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:0000531F                 add     esp, 4
.text$mn:00005322                 mov     edx, [ebp+var_10]
.text$mn:00005325                 mov     eax, [eax]
.text$mn:00005327                 mov     [edx], eax
.text$mn:00005329                 mov     ecx, [ebp+var_10]
.text$mn:0000532C                 mov     [ebp+var_14], ecx
.text$mn:0000532F                 jmp     short loc_5338
.text$mn:00005331 ; ---------------------------------------------------------------------------
.text$mn:00005331
.text$mn:00005331 loc_5331:                               ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+44j
.text$mn:00005331                 mov     [ebp+var_14], 0
.text$mn:00005338
.text$mn:00005338 loc_5338:                               ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+5Fj
.text$mn:00005338                 mov     edx, [ebp+var_14]
.text$mn:0000533B                 mov     [ebp+var_1C], edx
.text$mn:0000533E                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005345                 mov     ecx, [ebp+var_C]
.text$mn:00005348                 mov     large fs:0, ecx
.text$mn:0000534F                 pop     ecx
.text$mn:00005350                 mov     esp, ebp
.text$mn:00005352                 pop     ebp
.text$mn:00005353                 retn    8
.text$mn:00005353 ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp
.text$mn:00005353
.text$mn:00005353 ; ---------------------------------------------------------------------------
.text$mn:00005356                 align 4
.text$mn:00005356 _text$mn        ends
.text$mn:00005356
.text$x:00005358 ; ===========================================================================
.text$x:00005358
.text$x:00005358 ; Segment type: Pure code
.text$x:00005358 ; Segment permissions: Read/Execute
.text$x:00005358 _text$x         segment para public 'CODE' use32
.text$x:00005358                 assume cs:_text$x
.text$x:00005358                 ;org 5358h
.text$x:00005358 ; COMDAT (pick associative to section at 52D0)
.text$x:00005358                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00005358
.text$x:00005358 ; =============== S U B R O U T I N E =======================================
.text$x:00005358
.text$x:00005358
.text$x:00005358 __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 proc near
.text$x:00005358                                         ; DATA XREF: .xdata$x:0000D8F8o
.text$x:00005358                 mov     eax, [ebp+8]
.text$x:0000535B                 push    eax
.text$x:0000535C                 mov     eax, [ebp-10h]
.text$x:0000535F                 push    eax             ; void *
.text$x:00005360                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00005365                 add     esp, 8
.text$x:00005368                 retn
.text$x:00005368 __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 endp
.text$x:00005368
.text$x:00005369
.text$x:00005369 ; =============== S U B R O U T I N E =======================================
.text$x:00005369
.text$x:00005369
.text$x:00005369 __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
.text$x:00005369                                         ; DATA XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+5o
.text$x:00005369
.text$x:00005369 arg_4           = dword ptr  8
.text$x:00005369
.text$x:00005369                 mov     edx, [esp+arg_4]
.text$x:0000536D                 lea     eax, [edx+0Ch]
.text$x:00005370                 mov     ecx, [edx-14h]
.text$x:00005373                 xor     ecx, eax
.text$x:00005375                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000537A                 mov     eax, offset __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$x:0000537F                 jmp     ___CxxFrameHandler3
.text$x:0000537F __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp
.text$x:0000537F
.text$x:0000537F _text$x         ends
.text$x:0000537F
.text$mn:00005384 ; ===========================================================================
.text$mn:00005384
.text$mn:00005384 ; Segment type: Pure code
.text$mn:00005384 ; Segment permissions: Read/Execute
.text$mn:00005384 _text$mn        segment para public 'CODE' use32
.text$mn:00005384                 assume cs:_text$mn
.text$mn:00005384                 ;org 5384h
.text$mn:00005384 ; COMDAT (pick any)
.text$mn:00005384                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005384
.text$mn:00005384 ; =============== S U B R O U T I N E =======================================
.text$mn:00005384
.text$mn:00005384 ; Attributes: bp-based frame
.text$mn:00005384
.text$mn:00005384 ; int __cdecl std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(int, void *, int)
.text$mn:00005384                 public ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
.text$mn:00005384 ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z proc near
.text$mn:00005384                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)+1Cp
.text$mn:00005384
.text$mn:00005384 arg_0           = dword ptr  8
.text$mn:00005384 arg_4           = dword ptr  0Ch
.text$mn:00005384 arg_8           = dword ptr  10h
.text$mn:00005384
.text$mn:00005384                 push    ebp
.text$mn:00005385                 mov     ebp, esp
.text$mn:00005387                 mov     eax, [ebp+arg_8]
.text$mn:0000538A                 push    eax
.text$mn:0000538B                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:00005390                 add     esp, 4
.text$mn:00005393                 push    eax             ; int
.text$mn:00005394                 mov     ecx, [ebp+arg_4]
.text$mn:00005397                 push    ecx             ; void *
.text$mn:00005398                 mov     ecx, [ebp+arg_0]
.text$mn:0000539B                 call    ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)
.text$mn:000053A0                 pop     ebp
.text$mn:000053A1                 retn
.text$mn:000053A1 ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z endp
.text$mn:000053A1
.text$mn:000053A1 ; ---------------------------------------------------------------------------
.text$mn:000053A2                 align 4
.text$mn:000053A2 _text$mn        ends
.text$mn:000053A2
.text$mn:000053A4 ; ===========================================================================
.text$mn:000053A4
.text$mn:000053A4 ; Segment type: Pure code
.text$mn:000053A4 ; Segment permissions: Read/Execute
.text$mn:000053A4 _text$mn        segment para public 'CODE' use32
.text$mn:000053A4                 assume cs:_text$mn
.text$mn:000053A4                 ;org 53A4h
.text$mn:000053A4 ; COMDAT (pick any)
.text$mn:000053A4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000053A4
.text$mn:000053A4 ; =============== S U B R O U T I N E =======================================
.text$mn:000053A4
.text$mn:000053A4 ; Attributes: bp-based frame
.text$mn:000053A4
.text$mn:000053A4 ; int __stdcall std::_Wrap_alloc<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(void *, int)
.text$mn:000053A4                 public ??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z
.text$mn:000053A4 ??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z proc near
.text$mn:000053A4                                         ; CODE XREF: $LN19_0+4Bp
.text$mn:000053A4
.text$mn:000053A4 var_4           = dword ptr -4
.text$mn:000053A4 arg_0           = dword ptr  8
.text$mn:000053A4 arg_4           = dword ptr  0Ch
.text$mn:000053A4
.text$mn:000053A4                 push    ebp
.text$mn:000053A5                 mov     ebp, esp
.text$mn:000053A7                 push    ecx
.text$mn:000053A8                 mov     [ebp+var_4], ecx
.text$mn:000053AB                 mov     eax, [ebp+arg_4]
.text$mn:000053AE                 push    eax
.text$mn:000053AF                 call    ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z ; std::forward<wchar_t * &>(wchar_t * &)
.text$mn:000053B4                 add     esp, 4
.text$mn:000053B7                 push    eax             ; int
.text$mn:000053B8                 mov     ecx, [ebp+arg_0]
.text$mn:000053BB                 push    ecx             ; void *
.text$mn:000053BC                 mov     edx, [ebp+var_4]
.text$mn:000053BF                 push    edx             ; int
.text$mn:000053C0                 call    ??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z ; std::allocator_traits<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(std::allocator<wchar_t> &,wchar_t * *,wchar_t * &)
.text$mn:000053C5                 add     esp, 0Ch
.text$mn:000053C8                 mov     esp, ebp
.text$mn:000053CA                 pop     ebp
.text$mn:000053CB                 retn    8
.text$mn:000053CB ??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z endp
.text$mn:000053CB
.text$mn:000053CB ; ---------------------------------------------------------------------------
.text$mn:000053CE                 align 10h
.text$mn:000053CE _text$mn        ends
.text$mn:000053CE
.text$mn:000053D0 ; ===========================================================================
.text$mn:000053D0
.text$mn:000053D0 ; Segment type: Pure code
.text$mn:000053D0 ; Segment permissions: Read/Execute
.text$mn:000053D0 _text$mn        segment para public 'CODE' use32
.text$mn:000053D0                 assume cs:_text$mn
.text$mn:000053D0                 ;org 53D0h
.text$mn:000053D0 ; COMDAT (pick any)
.text$mn:000053D0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000053D0
.text$mn:000053D0 ; =============== S U B R O U T I N E =======================================
.text$mn:000053D0
.text$mn:000053D0 ; Attributes: bp-based frame
.text$mn:000053D0
.text$mn:000053D0 ; int __stdcall std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(void *, int)
.text$mn:000053D0                 public ??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z
.text$mn:000053D0 ??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z proc near
.text$mn:000053D0                                         ; CODE XREF: std::allocator_traits<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(std::allocator<wchar_t> &,wchar_t * *,wchar_t * &)+17p
.text$mn:000053D0
.text$mn:000053D0 var_1C          = dword ptr -1Ch
.text$mn:000053D0 var_18          = dword ptr -18h
.text$mn:000053D0 var_14          = dword ptr -14h
.text$mn:000053D0 var_10          = dword ptr -10h
.text$mn:000053D0 var_C           = dword ptr -0Ch
.text$mn:000053D0 var_4           = dword ptr -4
.text$mn:000053D0 arg_0           = dword ptr  8
.text$mn:000053D0 arg_4           = dword ptr  0Ch
.text$mn:000053D0
.text$mn:000053D0                 push    ebp
.text$mn:000053D1                 mov     ebp, esp
.text$mn:000053D3                 push    0FFFFFFFFh
.text$mn:000053D5                 push    offset __ehhandler$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z
.text$mn:000053DA                 mov     eax, large fs:0
.text$mn:000053E0                 push    eax
.text$mn:000053E1                 sub     esp, 10h
.text$mn:000053E4                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000053E9                 xor     eax, ebp
.text$mn:000053EB                 push    eax
.text$mn:000053EC                 lea     eax, [ebp+var_C]
.text$mn:000053EF                 mov     large fs:0, eax
.text$mn:000053F5                 mov     [ebp+var_18], ecx
.text$mn:000053F8                 mov     eax, [ebp+arg_0]
.text$mn:000053FB                 push    eax             ; void *
.text$mn:000053FC                 push    4               ; unsigned int
.text$mn:000053FE                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00005403                 add     esp, 8
.text$mn:00005406                 mov     [ebp+var_10], eax
.text$mn:00005409                 mov     [ebp+var_4], 0
.text$mn:00005410                 cmp     [ebp+var_10], 0
.text$mn:00005414                 jz      short loc_5431
.text$mn:00005416                 mov     ecx, [ebp+arg_4]
.text$mn:00005419                 push    ecx
.text$mn:0000541A                 call    ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z ; std::forward<wchar_t * &>(wchar_t * &)
.text$mn:0000541F                 add     esp, 4
.text$mn:00005422                 mov     edx, [ebp+var_10]
.text$mn:00005425                 mov     eax, [eax]
.text$mn:00005427                 mov     [edx], eax
.text$mn:00005429                 mov     ecx, [ebp+var_10]
.text$mn:0000542C                 mov     [ebp+var_14], ecx
.text$mn:0000542F                 jmp     short loc_5438
.text$mn:00005431 ; ---------------------------------------------------------------------------
.text$mn:00005431
.text$mn:00005431 loc_5431:                               ; CODE XREF: std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+44j
.text$mn:00005431                 mov     [ebp+var_14], 0
.text$mn:00005438
.text$mn:00005438 loc_5438:                               ; CODE XREF: std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+5Fj
.text$mn:00005438                 mov     edx, [ebp+var_14]
.text$mn:0000543B                 mov     [ebp+var_1C], edx
.text$mn:0000543E                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005445                 mov     ecx, [ebp+var_C]
.text$mn:00005448                 mov     large fs:0, ecx
.text$mn:0000544F                 pop     ecx
.text$mn:00005450                 mov     esp, ebp
.text$mn:00005452                 pop     ebp
.text$mn:00005453                 retn    8
.text$mn:00005453 ??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z endp
.text$mn:00005453
.text$mn:00005453 ; ---------------------------------------------------------------------------
.text$mn:00005456                 align 4
.text$mn:00005456 _text$mn        ends
.text$mn:00005456
.text$x:00005458 ; ===========================================================================
.text$x:00005458
.text$x:00005458 ; Segment type: Pure code
.text$x:00005458 ; Segment permissions: Read/Execute
.text$x:00005458 _text$x         segment para public 'CODE' use32
.text$x:00005458                 assume cs:_text$x
.text$x:00005458                 ;org 5458h
.text$x:00005458 ; COMDAT (pick associative to section at 53D0)
.text$x:00005458                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00005458
.text$x:00005458 ; =============== S U B R O U T I N E =======================================
.text$x:00005458
.text$x:00005458
.text$x:00005458 __unwindfunclet$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z$0 proc near
.text$x:00005458                                         ; DATA XREF: .xdata$x:0000D924o
.text$x:00005458                 mov     eax, [ebp+8]
.text$x:0000545B                 push    eax
.text$x:0000545C                 mov     eax, [ebp-10h]
.text$x:0000545F                 push    eax             ; void *
.text$x:00005460                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00005465                 add     esp, 8
.text$x:00005468                 retn
.text$x:00005468 __unwindfunclet$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z$0 endp
.text$x:00005468
.text$x:00005469
.text$x:00005469 ; =============== S U B R O U T I N E =======================================
.text$x:00005469
.text$x:00005469
.text$x:00005469 __ehhandler$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z proc near
.text$x:00005469                                         ; DATA XREF: std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+5o
.text$x:00005469
.text$x:00005469 arg_4           = dword ptr  8
.text$x:00005469
.text$x:00005469                 mov     edx, [esp+arg_4]
.text$x:0000546D                 lea     eax, [edx+0Ch]
.text$x:00005470                 mov     ecx, [edx-14h]
.text$x:00005473                 xor     ecx, eax
.text$x:00005475                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000547A                 mov     eax, offset __ehfuncinfo$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z
.text$x:0000547F                 jmp     ___CxxFrameHandler3
.text$x:0000547F __ehhandler$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z endp
.text$x:0000547F
.text$x:0000547F _text$x         ends
.text$x:0000547F
.text$mn:00005484 ; ===========================================================================
.text$mn:00005484
.text$mn:00005484 ; Segment type: Pure code
.text$mn:00005484 ; Segment permissions: Read/Execute
.text$mn:00005484 _text$mn        segment para public 'CODE' use32
.text$mn:00005484                 assume cs:_text$mn
.text$mn:00005484                 ;org 5484h
.text$mn:00005484 ; COMDAT (pick any)
.text$mn:00005484                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005484
.text$mn:00005484 ; =============== S U B R O U T I N E =======================================
.text$mn:00005484
.text$mn:00005484 ; Attributes: bp-based frame
.text$mn:00005484
.text$mn:00005484 ; int __cdecl std::allocator_traits<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(int, void *, int)
.text$mn:00005484                 public ??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z
.text$mn:00005484 ??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z proc near
.text$mn:00005484                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+1Cp
.text$mn:00005484
.text$mn:00005484 arg_0           = dword ptr  8
.text$mn:00005484 arg_4           = dword ptr  0Ch
.text$mn:00005484 arg_8           = dword ptr  10h
.text$mn:00005484
.text$mn:00005484                 push    ebp
.text$mn:00005485                 mov     ebp, esp
.text$mn:00005487                 mov     eax, [ebp+arg_8]
.text$mn:0000548A                 push    eax
.text$mn:0000548B                 call    ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z ; std::forward<wchar_t * &>(wchar_t * &)
.text$mn:00005490                 add     esp, 4
.text$mn:00005493                 push    eax             ; int
.text$mn:00005494                 mov     ecx, [ebp+arg_4]
.text$mn:00005497                 push    ecx             ; void *
.text$mn:00005498                 mov     ecx, [ebp+arg_0]
.text$mn:0000549B                 call    ??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z ; std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)
.text$mn:000054A0                 pop     ebp
.text$mn:000054A1                 retn
.text$mn:000054A1 ??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z endp
.text$mn:000054A1
.text$mn:000054A1 ; ---------------------------------------------------------------------------
.text$mn:000054A2                 align 4
.text$mn:000054A2 _text$mn        ends
.text$mn:000054A2
.text$mn:000054A4 ; ===========================================================================
.text$mn:000054A4
.text$mn:000054A4 ; Segment type: Pure code
.text$mn:000054A4 ; Segment permissions: Read/Execute
.text$mn:000054A4 _text$mn        segment para public 'CODE' use32
.text$mn:000054A4                 assume cs:_text$mn
.text$mn:000054A4                 ;org 54A4h
.text$mn:000054A4 ; COMDAT (pick any)
.text$mn:000054A4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000054A4
.text$mn:000054A4 ; =============== S U B R O U T I N E =======================================
.text$mn:000054A4
.text$mn:000054A4 ; Attributes: bp-based frame
.text$mn:000054A4
.text$mn:000054A4 ; int __stdcall std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(void *, int)
.text$mn:000054A4                 public ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:000054A4 ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$mn:000054A4                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>::_Alloc_proxy(void)+32p
.text$mn:000054A4                                         ; std::_Vector_alloc<0,std::_Vec_base_types<wchar_t,std::allocator<wchar_t>>>::_Alloc_proxy(void)+32p
.text$mn:000054A4
.text$mn:000054A4 var_4           = dword ptr -4
.text$mn:000054A4 arg_0           = dword ptr  8
.text$mn:000054A4 arg_4           = dword ptr  0Ch
.text$mn:000054A4
.text$mn:000054A4                 push    ebp
.text$mn:000054A5                 mov     ebp, esp
.text$mn:000054A7                 push    ecx
.text$mn:000054A8                 mov     [ebp+var_4], ecx
.text$mn:000054AB                 mov     eax, [ebp+arg_4]
.text$mn:000054AE                 push    eax
.text$mn:000054AF                 call    ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>(std::_Container_proxy &)
.text$mn:000054B4                 add     esp, 4
.text$mn:000054B7                 push    eax             ; int
.text$mn:000054B8                 mov     ecx, [ebp+arg_0]
.text$mn:000054BB                 push    ecx             ; void *
.text$mn:000054BC                 mov     edx, [ebp+var_4]
.text$mn:000054BF                 push    edx             ; int
.text$mn:000054C0                 call    ??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z ; std::allocator_traits<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(std::allocator<std::_Container_proxy> &,std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:000054C5                 add     esp, 0Ch
.text$mn:000054C8                 mov     esp, ebp
.text$mn:000054CA                 pop     ebp
.text$mn:000054CB                 retn    8
.text$mn:000054CB ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$mn:000054CB
.text$mn:000054CB ; ---------------------------------------------------------------------------
.text$mn:000054CE                 align 10h
.text$mn:000054CE _text$mn        ends
.text$mn:000054CE
.text$mn:000054D0 ; ===========================================================================
.text$mn:000054D0
.text$mn:000054D0 ; Segment type: Pure code
.text$mn:000054D0 ; Segment permissions: Read/Execute
.text$mn:000054D0 _text$mn        segment para public 'CODE' use32
.text$mn:000054D0                 assume cs:_text$mn
.text$mn:000054D0                 ;org 54D0h
.text$mn:000054D0 ; COMDAT (pick any)
.text$mn:000054D0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000054D0
.text$mn:000054D0 ; =============== S U B R O U T I N E =======================================
.text$mn:000054D0
.text$mn:000054D0 ; Attributes: bp-based frame
.text$mn:000054D0
.text$mn:000054D0 ; int __stdcall std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(void *, int)
.text$mn:000054D0                 public ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:000054D0 ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$mn:000054D0                                         ; CODE XREF: std::allocator_traits<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(std::allocator<std::_Container_proxy> &,std::_Container_proxy *,std::_Container_proxy &&)+17p
.text$mn:000054D0                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+32p ...
.text$mn:000054D0
.text$mn:000054D0 var_1C          = dword ptr -1Ch
.text$mn:000054D0 var_18          = dword ptr -18h
.text$mn:000054D0 var_14          = dword ptr -14h
.text$mn:000054D0 var_10          = dword ptr -10h
.text$mn:000054D0 var_C           = dword ptr -0Ch
.text$mn:000054D0 var_4           = dword ptr -4
.text$mn:000054D0 arg_0           = dword ptr  8
.text$mn:000054D0 arg_4           = dword ptr  0Ch
.text$mn:000054D0
.text$mn:000054D0                 push    ebp
.text$mn:000054D1                 mov     ebp, esp
.text$mn:000054D3                 push    0FFFFFFFFh
.text$mn:000054D5                 push    offset __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:000054DA                 mov     eax, large fs:0
.text$mn:000054E0                 push    eax
.text$mn:000054E1                 sub     esp, 10h
.text$mn:000054E4                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000054E9                 xor     eax, ebp
.text$mn:000054EB                 push    eax
.text$mn:000054EC                 lea     eax, [ebp+var_C]
.text$mn:000054EF                 mov     large fs:0, eax
.text$mn:000054F5                 mov     [ebp+var_18], ecx
.text$mn:000054F8                 mov     eax, [ebp+arg_0]
.text$mn:000054FB                 push    eax             ; void *
.text$mn:000054FC                 push    8               ; unsigned int
.text$mn:000054FE                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00005503                 add     esp, 8
.text$mn:00005506                 mov     [ebp+var_10], eax
.text$mn:00005509                 mov     [ebp+var_4], 0
.text$mn:00005510                 cmp     [ebp+var_10], 0
.text$mn:00005514                 jz      short loc_5537
.text$mn:00005516                 mov     ecx, [ebp+arg_4]
.text$mn:00005519                 push    ecx
.text$mn:0000551A                 call    ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>(std::_Container_proxy &)
.text$mn:0000551F                 add     esp, 4
.text$mn:00005522                 mov     edx, [eax]
.text$mn:00005524                 mov     eax, [eax+4]
.text$mn:00005527                 mov     ecx, [ebp+var_10]
.text$mn:0000552A                 mov     [ecx], edx
.text$mn:0000552C                 mov     [ecx+4], eax
.text$mn:0000552F                 mov     edx, [ebp+var_10]
.text$mn:00005532                 mov     [ebp+var_14], edx
.text$mn:00005535                 jmp     short loc_553E
.text$mn:00005537 ; ---------------------------------------------------------------------------
.text$mn:00005537
.text$mn:00005537 loc_5537:                               ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+44j
.text$mn:00005537                 mov     [ebp+var_14], 0
.text$mn:0000553E
.text$mn:0000553E loc_553E:                               ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+65j
.text$mn:0000553E                 mov     eax, [ebp+var_14]
.text$mn:00005541                 mov     [ebp+var_1C], eax
.text$mn:00005544                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000554B                 mov     ecx, [ebp+var_C]
.text$mn:0000554E                 mov     large fs:0, ecx
.text$mn:00005555                 pop     ecx
.text$mn:00005556                 mov     esp, ebp
.text$mn:00005558                 pop     ebp
.text$mn:00005559                 retn    8
.text$mn:00005559 ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$mn:00005559
.text$mn:00005559 _text$mn        ends
.text$mn:00005559
.text$x:0000555C ; ===========================================================================
.text$x:0000555C
.text$x:0000555C ; Segment type: Pure code
.text$x:0000555C ; Segment permissions: Read/Execute
.text$x:0000555C _text$x         segment para public 'CODE' use32
.text$x:0000555C                 assume cs:_text$x
.text$x:0000555C                 ;org 555Ch
.text$x:0000555C ; COMDAT (pick associative to section at 54D0)
.text$x:0000555C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000555C
.text$x:0000555C ; =============== S U B R O U T I N E =======================================
.text$x:0000555C
.text$x:0000555C
.text$x:0000555C __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 proc near
.text$x:0000555C                                         ; DATA XREF: .xdata$x:0000D650o
.text$x:0000555C                 mov     eax, [ebp+8]
.text$x:0000555F                 push    eax
.text$x:00005560                 mov     eax, [ebp-10h]
.text$x:00005563                 push    eax             ; void *
.text$x:00005564                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00005569                 add     esp, 8
.text$x:0000556C                 retn
.text$x:0000556C __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 endp
.text$x:0000556C
.text$x:0000556D
.text$x:0000556D ; =============== S U B R O U T I N E =======================================
.text$x:0000556D
.text$x:0000556D
.text$x:0000556D __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$x:0000556D                                         ; DATA XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+5o
.text$x:0000556D
.text$x:0000556D arg_4           = dword ptr  8
.text$x:0000556D
.text$x:0000556D                 mov     edx, [esp+arg_4]
.text$x:00005571                 lea     eax, [edx+0Ch]
.text$x:00005574                 mov     ecx, [edx-14h]
.text$x:00005577                 xor     ecx, eax
.text$x:00005579                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000557E                 mov     eax, offset __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$x:00005583                 jmp     ___CxxFrameHandler3
.text$x:00005583 __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$x:00005583
.text$x:00005583 _text$x         ends
.text$x:00005583
.text$mn:00005588 ; ===========================================================================
.text$mn:00005588
.text$mn:00005588 ; Segment type: Pure code
.text$mn:00005588 ; Segment permissions: Read/Execute
.text$mn:00005588 _text$mn        segment para public 'CODE' use32
.text$mn:00005588                 assume cs:_text$mn
.text$mn:00005588                 ;org 5588h
.text$mn:00005588 ; COMDAT (pick any)
.text$mn:00005588                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005588
.text$mn:00005588 ; =============== S U B R O U T I N E =======================================
.text$mn:00005588
.text$mn:00005588 ; Attributes: bp-based frame
.text$mn:00005588
.text$mn:00005588 ; int __cdecl std::allocator_traits<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(int, void *, int)
.text$mn:00005588                 public ??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z
.text$mn:00005588 ??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z proc near
.text$mn:00005588                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+1Cp
.text$mn:00005588
.text$mn:00005588 arg_0           = dword ptr  8
.text$mn:00005588 arg_4           = dword ptr  0Ch
.text$mn:00005588 arg_8           = dword ptr  10h
.text$mn:00005588
.text$mn:00005588                 push    ebp
.text$mn:00005589                 mov     ebp, esp
.text$mn:0000558B                 mov     eax, [ebp+arg_8]
.text$mn:0000558E                 push    eax
.text$mn:0000558F                 call    ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>(std::_Container_proxy &)
.text$mn:00005594                 add     esp, 4
.text$mn:00005597                 push    eax             ; int
.text$mn:00005598                 mov     ecx, [ebp+arg_4]
.text$mn:0000559B                 push    ecx             ; void *
.text$mn:0000559C                 mov     ecx, [ebp+arg_0]
.text$mn:0000559F                 call    ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:000055A4                 pop     ebp
.text$mn:000055A5                 retn
.text$mn:000055A5 ??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z endp
.text$mn:000055A5
.text$mn:000055A5 ; ---------------------------------------------------------------------------
.text$mn:000055A6                 align 4
.text$mn:000055A6 _text$mn        ends
.text$mn:000055A6
.text$mn:000055A8 ; ===========================================================================
.text$mn:000055A8
.text$mn:000055A8 ; Segment type: Pure code
.text$mn:000055A8 ; Segment permissions: Read/Execute
.text$mn:000055A8 _text$mn        segment para public 'CODE' use32
.text$mn:000055A8                 assume cs:_text$mn
.text$mn:000055A8                 ;org 55A8h
.text$mn:000055A8 ; COMDAT (pick any)
.text$mn:000055A8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000055A8
.text$mn:000055A8 ; =============== S U B R O U T I N E =======================================
.text$mn:000055A8
.text$mn:000055A8 ; Attributes: bp-based frame
.text$mn:000055A8
.text$mn:000055A8 ; int __stdcall std::_Wrap_alloc<std::allocator<wchar_t>>::construct<wchar_t,wchar_t>(void *, int)
.text$mn:000055A8                 public ??$construct@_W_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_W$$QA_W@Z
.text$mn:000055A8 ??$construct@_W_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_W$$QA_W@Z proc near
.text$mn:000055A8                                         ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::push_back(wchar_t &&)+99p
.text$mn:000055A8                                         ; std::vector<wchar_t,std::allocator<wchar_t>>::push_back(wchar_t &&)+FFp
.text$mn:000055A8
.text$mn:000055A8 var_4           = dword ptr -4
.text$mn:000055A8 arg_0           = dword ptr  8
.text$mn:000055A8 arg_4           = dword ptr  0Ch
.text$mn:000055A8
.text$mn:000055A8                 push    ebp
.text$mn:000055A9                 mov     ebp, esp
.text$mn:000055AB                 push    ecx
.text$mn:000055AC                 mov     [ebp+var_4], ecx
.text$mn:000055AF                 mov     eax, [ebp+arg_4]
.text$mn:000055B2                 push    eax
.text$mn:000055B3                 call    ??$forward@_W@std@@YA$$QA_WAA_W@Z ; std::forward<wchar_t>(wchar_t &)
.text$mn:000055B8                 add     esp, 4
.text$mn:000055BB                 push    eax             ; int
.text$mn:000055BC                 mov     ecx, [ebp+arg_0]
.text$mn:000055BF                 push    ecx             ; void *
.text$mn:000055C0                 mov     edx, [ebp+var_4]
.text$mn:000055C3                 push    edx             ; int
.text$mn:000055C4                 call    ??$construct@_W_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PA_W$$QA_W@Z ; std::allocator_traits<std::allocator<wchar_t>>::construct<wchar_t,wchar_t>(std::allocator<wchar_t> &,wchar_t *,wchar_t &&)
.text$mn:000055C9                 add     esp, 0Ch
.text$mn:000055CC                 mov     esp, ebp
.text$mn:000055CE                 pop     ebp
.text$mn:000055CF                 retn    8
.text$mn:000055CF ??$construct@_W_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_W$$QA_W@Z endp
.text$mn:000055CF
.text$mn:000055CF ; ---------------------------------------------------------------------------
.text$mn:000055D2                 align 4
.text$mn:000055D2 _text$mn        ends
.text$mn:000055D2
.text$mn:000055D4 ; ===========================================================================
.text$mn:000055D4
.text$mn:000055D4 ; Segment type: Pure code
.text$mn:000055D4 ; Segment permissions: Read/Execute
.text$mn:000055D4 _text$mn        segment para public 'CODE' use32
.text$mn:000055D4                 assume cs:_text$mn
.text$mn:000055D4                 ;org 55D4h
.text$mn:000055D4 ; COMDAT (pick any)
.text$mn:000055D4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000055D4
.text$mn:000055D4 ; =============== S U B R O U T I N E =======================================
.text$mn:000055D4
.text$mn:000055D4 ; Attributes: bp-based frame
.text$mn:000055D4
.text$mn:000055D4 ; int __stdcall std::allocator<wchar_t>::construct<wchar_t,wchar_t>(void *, int)
.text$mn:000055D4                 public ??$construct@_W_W@?$allocator@_W@std@@QAEXPA_W$$QA_W@Z
.text$mn:000055D4 ??$construct@_W_W@?$allocator@_W@std@@QAEXPA_W$$QA_W@Z proc near
.text$mn:000055D4                                         ; CODE XREF: std::allocator_traits<std::allocator<wchar_t>>::construct<wchar_t,wchar_t>(std::allocator<wchar_t> &,wchar_t *,wchar_t &&)+17p
.text$mn:000055D4
.text$mn:000055D4 var_1C          = dword ptr -1Ch
.text$mn:000055D4 var_18          = dword ptr -18h
.text$mn:000055D4 var_14          = dword ptr -14h
.text$mn:000055D4 var_10          = dword ptr -10h
.text$mn:000055D4 var_C           = dword ptr -0Ch
.text$mn:000055D4 var_4           = dword ptr -4
.text$mn:000055D4 arg_0           = dword ptr  8
.text$mn:000055D4 arg_4           = dword ptr  0Ch
.text$mn:000055D4
.text$mn:000055D4                 push    ebp
.text$mn:000055D5                 mov     ebp, esp
.text$mn:000055D7                 push    0FFFFFFFFh
.text$mn:000055D9                 push    offset __ehhandler$??$construct@_W_W@?$allocator@_W@std@@QAEXPA_W$$QA_W@Z
.text$mn:000055DE                 mov     eax, large fs:0
.text$mn:000055E4                 push    eax
.text$mn:000055E5                 sub     esp, 10h
.text$mn:000055E8                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000055ED                 xor     eax, ebp
.text$mn:000055EF                 push    eax
.text$mn:000055F0                 lea     eax, [ebp+var_C]
.text$mn:000055F3                 mov     large fs:0, eax
.text$mn:000055F9                 mov     [ebp+var_18], ecx
.text$mn:000055FC                 mov     eax, [ebp+arg_0]
.text$mn:000055FF                 push    eax             ; void *
.text$mn:00005600                 push    2               ; unsigned int
.text$mn:00005602                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00005607                 add     esp, 8
.text$mn:0000560A                 mov     [ebp+var_10], eax
.text$mn:0000560D                 mov     [ebp+var_4], 0
.text$mn:00005614                 cmp     [ebp+var_10], 0
.text$mn:00005618                 jz      short loc_5637
.text$mn:0000561A                 mov     ecx, [ebp+arg_4]
.text$mn:0000561D                 push    ecx
.text$mn:0000561E                 call    ??$forward@_W@std@@YA$$QA_WAA_W@Z ; std::forward<wchar_t>(wchar_t &)
.text$mn:00005623                 add     esp, 4
.text$mn:00005626                 mov     edx, [ebp+var_10]
.text$mn:00005629                 mov     ax, [eax]
.text$mn:0000562C                 mov     [edx], ax
.text$mn:0000562F                 mov     ecx, [ebp+var_10]
.text$mn:00005632                 mov     [ebp+var_14], ecx
.text$mn:00005635                 jmp     short loc_563E
.text$mn:00005637 ; ---------------------------------------------------------------------------
.text$mn:00005637
.text$mn:00005637 loc_5637:                               ; CODE XREF: std::allocator<wchar_t>::construct<wchar_t,wchar_t>(wchar_t *,wchar_t &&)+44j
.text$mn:00005637                 mov     [ebp+var_14], 0
.text$mn:0000563E
.text$mn:0000563E loc_563E:                               ; CODE XREF: std::allocator<wchar_t>::construct<wchar_t,wchar_t>(wchar_t *,wchar_t &&)+61j
.text$mn:0000563E                 mov     edx, [ebp+var_14]
.text$mn:00005641                 mov     [ebp+var_1C], edx
.text$mn:00005644                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000564B                 mov     ecx, [ebp+var_C]
.text$mn:0000564E                 mov     large fs:0, ecx
.text$mn:00005655                 pop     ecx
.text$mn:00005656                 mov     esp, ebp
.text$mn:00005658                 pop     ebp
.text$mn:00005659                 retn    8
.text$mn:00005659 ??$construct@_W_W@?$allocator@_W@std@@QAEXPA_W$$QA_W@Z endp
.text$mn:00005659
.text$mn:00005659 _text$mn        ends
.text$mn:00005659
.text$x:0000565C ; ===========================================================================
.text$x:0000565C
.text$x:0000565C ; Segment type: Pure code
.text$x:0000565C ; Segment permissions: Read/Execute
.text$x:0000565C _text$x         segment para public 'CODE' use32
.text$x:0000565C                 assume cs:_text$x
.text$x:0000565C                 ;org 565Ch
.text$x:0000565C ; COMDAT (pick associative to section at 55D4)
.text$x:0000565C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000565C
.text$x:0000565C ; =============== S U B R O U T I N E =======================================
.text$x:0000565C
.text$x:0000565C
.text$x:0000565C __unwindfunclet$??$construct@_W_W@?$allocator@_W@std@@QAEXPA_W$$QA_W@Z$0 proc near
.text$x:0000565C                                         ; DATA XREF: .xdata$x:0000D8CCo
.text$x:0000565C                 mov     eax, [ebp+8]
.text$x:0000565F                 push    eax
.text$x:00005660                 mov     eax, [ebp-10h]
.text$x:00005663                 push    eax             ; void *
.text$x:00005664                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00005669                 add     esp, 8
.text$x:0000566C                 retn
.text$x:0000566C __unwindfunclet$??$construct@_W_W@?$allocator@_W@std@@QAEXPA_W$$QA_W@Z$0 endp
.text$x:0000566C
.text$x:0000566D
.text$x:0000566D ; =============== S U B R O U T I N E =======================================
.text$x:0000566D
.text$x:0000566D
.text$x:0000566D __ehhandler$??$construct@_W_W@?$allocator@_W@std@@QAEXPA_W$$QA_W@Z proc near
.text$x:0000566D                                         ; DATA XREF: std::allocator<wchar_t>::construct<wchar_t,wchar_t>(wchar_t *,wchar_t &&)+5o
.text$x:0000566D
.text$x:0000566D arg_4           = dword ptr  8
.text$x:0000566D
.text$x:0000566D                 mov     edx, [esp+arg_4]
.text$x:00005671                 lea     eax, [edx+0Ch]
.text$x:00005674                 mov     ecx, [edx-14h]
.text$x:00005677                 xor     ecx, eax
.text$x:00005679                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000567E                 mov     eax, offset __ehfuncinfo$??$construct@_W_W@?$allocator@_W@std@@QAEXPA_W$$QA_W@Z
.text$x:00005683                 jmp     ___CxxFrameHandler3
.text$x:00005683 __ehhandler$??$construct@_W_W@?$allocator@_W@std@@QAEXPA_W$$QA_W@Z endp
.text$x:00005683
.text$x:00005683 _text$x         ends
.text$x:00005683
.text$mn:00005688 ; ===========================================================================
.text$mn:00005688
.text$mn:00005688 ; Segment type: Pure code
.text$mn:00005688 ; Segment permissions: Read/Execute
.text$mn:00005688 _text$mn        segment para public 'CODE' use32
.text$mn:00005688                 assume cs:_text$mn
.text$mn:00005688                 ;org 5688h
.text$mn:00005688 ; COMDAT (pick any)
.text$mn:00005688                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005688
.text$mn:00005688 ; =============== S U B R O U T I N E =======================================
.text$mn:00005688
.text$mn:00005688 ; Attributes: bp-based frame
.text$mn:00005688
.text$mn:00005688 ; int __cdecl std::allocator_traits<std::allocator<wchar_t>>::construct<wchar_t,wchar_t>(int, void *, int)
.text$mn:00005688                 public ??$construct@_W_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PA_W$$QA_W@Z
.text$mn:00005688 ??$construct@_W_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PA_W$$QA_W@Z proc near
.text$mn:00005688                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::construct<wchar_t,wchar_t>(wchar_t *,wchar_t &&)+1Cp
.text$mn:00005688
.text$mn:00005688 arg_0           = dword ptr  8
.text$mn:00005688 arg_4           = dword ptr  0Ch
.text$mn:00005688 arg_8           = dword ptr  10h
.text$mn:00005688
.text$mn:00005688                 push    ebp
.text$mn:00005689                 mov     ebp, esp
.text$mn:0000568B                 mov     eax, [ebp+arg_8]
.text$mn:0000568E                 push    eax
.text$mn:0000568F                 call    ??$forward@_W@std@@YA$$QA_WAA_W@Z ; std::forward<wchar_t>(wchar_t &)
.text$mn:00005694                 add     esp, 4
.text$mn:00005697                 push    eax             ; int
.text$mn:00005698                 mov     ecx, [ebp+arg_4]
.text$mn:0000569B                 push    ecx             ; void *
.text$mn:0000569C                 mov     ecx, [ebp+arg_0]
.text$mn:0000569F                 call    ??$construct@_W_W@?$allocator@_W@std@@QAEXPA_W$$QA_W@Z ; std::allocator<wchar_t>::construct<wchar_t,wchar_t>(wchar_t *,wchar_t &&)
.text$mn:000056A4                 pop     ebp
.text$mn:000056A5                 retn
.text$mn:000056A5 ??$construct@_W_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PA_W$$QA_W@Z endp
.text$mn:000056A5
.text$mn:000056A5 ; ---------------------------------------------------------------------------
.text$mn:000056A6                 align 4
.text$mn:000056A6 _text$mn        ends
.text$mn:000056A6
.text$mn:000056A8 ; ===========================================================================
.text$mn:000056A8
.text$mn:000056A8 ; Segment type: Pure code
.text$mn:000056A8 ; Segment permissions: Read/Execute
.text$mn:000056A8 _text$mn        segment para public 'CODE' use32
.text$mn:000056A8                 assume cs:_text$mn
.text$mn:000056A8                 ;org 56A8h
.text$mn:000056A8 ; COMDAT (pick any)
.text$mn:000056A8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000056A8
.text$mn:000056A8 ; =============== S U B R O U T I N E =======================================
.text$mn:000056A8
.text$mn:000056A8 ; Attributes: bp-based frame
.text$mn:000056A8
.text$mn:000056A8 ; public: void __thiscall std::_Wrap_alloc<class std::allocator<char>>::destroy<char *>(char * *)
.text$mn:000056A8                 public ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
.text$mn:000056A8 ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z proc near
.text$mn:000056A8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+3Ap
.text$mn:000056A8
.text$mn:000056A8 var_4           = dword ptr -4
.text$mn:000056A8 arg_0           = dword ptr  8
.text$mn:000056A8
.text$mn:000056A8                 push    ebp
.text$mn:000056A9                 mov     ebp, esp
.text$mn:000056AB                 push    ecx
.text$mn:000056AC                 mov     [ebp+var_4], ecx
.text$mn:000056AF                 mov     eax, [ebp+arg_0]
.text$mn:000056B2                 push    eax
.text$mn:000056B3                 mov     ecx, [ebp+var_4]
.text$mn:000056B6                 push    ecx
.text$mn:000056B7                 call    ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char * *)
.text$mn:000056BC                 add     esp, 8
.text$mn:000056BF                 mov     esp, ebp
.text$mn:000056C1                 pop     ebp
.text$mn:000056C2                 retn    4
.text$mn:000056C2 ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z endp
.text$mn:000056C2
.text$mn:000056C2 ; ---------------------------------------------------------------------------
.text$mn:000056C5                 align 4
.text$mn:000056C5 _text$mn        ends
.text$mn:000056C5
.text$mn:000056C8 ; ===========================================================================
.text$mn:000056C8
.text$mn:000056C8 ; Segment type: Pure code
.text$mn:000056C8 ; Segment permissions: Read/Execute
.text$mn:000056C8 _text$mn        segment para public 'CODE' use32
.text$mn:000056C8                 assume cs:_text$mn
.text$mn:000056C8                 ;org 56C8h
.text$mn:000056C8 ; COMDAT (pick any)
.text$mn:000056C8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000056C8
.text$mn:000056C8 ; =============== S U B R O U T I N E =======================================
.text$mn:000056C8
.text$mn:000056C8 ; Attributes: bp-based frame
.text$mn:000056C8
.text$mn:000056C8 ; public: void __thiscall std::allocator<char>::destroy<char *>(char * *)
.text$mn:000056C8                 public ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
.text$mn:000056C8 ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z proc near
.text$mn:000056C8                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char * *)+Ap
.text$mn:000056C8
.text$mn:000056C8 var_4           = dword ptr -4
.text$mn:000056C8
.text$mn:000056C8                 push    ebp
.text$mn:000056C9                 mov     ebp, esp
.text$mn:000056CB                 push    ecx
.text$mn:000056CC                 mov     [ebp+var_4], ecx
.text$mn:000056CF                 mov     esp, ebp
.text$mn:000056D1                 pop     ebp
.text$mn:000056D2                 retn    4
.text$mn:000056D2 ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z endp
.text$mn:000056D2
.text$mn:000056D2 ; ---------------------------------------------------------------------------
.text$mn:000056D5                 align 4
.text$mn:000056D5 _text$mn        ends
.text$mn:000056D5
.text$mn:000056D8 ; ===========================================================================
.text$mn:000056D8
.text$mn:000056D8 ; Segment type: Pure code
.text$mn:000056D8 ; Segment permissions: Read/Execute
.text$mn:000056D8 _text$mn        segment para public 'CODE' use32
.text$mn:000056D8                 assume cs:_text$mn
.text$mn:000056D8                 ;org 56D8h
.text$mn:000056D8 ; COMDAT (pick any)
.text$mn:000056D8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000056D8
.text$mn:000056D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000056D8
.text$mn:000056D8 ; Attributes: bp-based frame
.text$mn:000056D8
.text$mn:000056D8 ; public: static void __cdecl std::allocator_traits<class std::allocator<char>>::destroy<char *>(class std::allocator<char> &, char * *)
.text$mn:000056D8                 public ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
.text$mn:000056D8 ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z proc near
.text$mn:000056D8                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)+Fp
.text$mn:000056D8
.text$mn:000056D8 arg_0           = dword ptr  8
.text$mn:000056D8 arg_4           = dword ptr  0Ch
.text$mn:000056D8
.text$mn:000056D8                 push    ebp
.text$mn:000056D9                 mov     ebp, esp
.text$mn:000056DB                 mov     eax, [ebp+arg_4]
.text$mn:000056DE                 push    eax
.text$mn:000056DF                 mov     ecx, [ebp+arg_0]
.text$mn:000056E2                 call    ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ; std::allocator<char>::destroy<char *>(char * *)
.text$mn:000056E7                 pop     ebp
.text$mn:000056E8                 retn
.text$mn:000056E8 ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z endp
.text$mn:000056E8
.text$mn:000056E8 ; ---------------------------------------------------------------------------
.text$mn:000056E9                 align 4
.text$mn:000056E9 _text$mn        ends
.text$mn:000056E9
.text$mn:000056EC ; ===========================================================================
.text$mn:000056EC
.text$mn:000056EC ; Segment type: Pure code
.text$mn:000056EC ; Segment permissions: Read/Execute
.text$mn:000056EC _text$mn        segment para public 'CODE' use32
.text$mn:000056EC                 assume cs:_text$mn
.text$mn:000056EC                 ;org 56ECh
.text$mn:000056EC ; COMDAT (pick any)
.text$mn:000056EC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000056EC
.text$mn:000056EC ; =============== S U B R O U T I N E =======================================
.text$mn:000056EC
.text$mn:000056EC ; Attributes: bp-based frame
.text$mn:000056EC
.text$mn:000056EC ; public: void __thiscall std::_Wrap_alloc<class std::allocator<wchar_t>>::destroy<wchar_t *>(wchar_t * *)
.text$mn:000056EC                 public ??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z
.text$mn:000056EC ??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z proc near
.text$mn:000056EC                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+3Ap
.text$mn:000056EC
.text$mn:000056EC var_4           = dword ptr -4
.text$mn:000056EC arg_0           = dword ptr  8
.text$mn:000056EC
.text$mn:000056EC                 push    ebp
.text$mn:000056ED                 mov     ebp, esp
.text$mn:000056EF                 push    ecx
.text$mn:000056F0                 mov     [ebp+var_4], ecx
.text$mn:000056F3                 mov     eax, [ebp+arg_0]
.text$mn:000056F6                 push    eax
.text$mn:000056F7                 mov     ecx, [ebp+var_4]
.text$mn:000056FA                 push    ecx
.text$mn:000056FB                 call    ??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z ; std::allocator_traits<std::allocator<wchar_t>>::destroy<wchar_t *>(std::allocator<wchar_t> &,wchar_t * *)
.text$mn:00005700                 add     esp, 8
.text$mn:00005703                 mov     esp, ebp
.text$mn:00005705                 pop     ebp
.text$mn:00005706                 retn    4
.text$mn:00005706 ??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z endp
.text$mn:00005706
.text$mn:00005706 ; ---------------------------------------------------------------------------
.text$mn:00005709                 align 4
.text$mn:00005709 _text$mn        ends
.text$mn:00005709
.text$mn:0000570C ; ===========================================================================
.text$mn:0000570C
.text$mn:0000570C ; Segment type: Pure code
.text$mn:0000570C ; Segment permissions: Read/Execute
.text$mn:0000570C _text$mn        segment para public 'CODE' use32
.text$mn:0000570C                 assume cs:_text$mn
.text$mn:0000570C                 ;org 570Ch
.text$mn:0000570C ; COMDAT (pick any)
.text$mn:0000570C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000570C
.text$mn:0000570C ; =============== S U B R O U T I N E =======================================
.text$mn:0000570C
.text$mn:0000570C ; Attributes: bp-based frame
.text$mn:0000570C
.text$mn:0000570C ; public: void __thiscall std::allocator<wchar_t>::destroy<wchar_t *>(wchar_t * *)
.text$mn:0000570C                 public ??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z
.text$mn:0000570C ??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z proc near
.text$mn:0000570C                                         ; CODE XREF: std::allocator_traits<std::allocator<wchar_t>>::destroy<wchar_t *>(std::allocator<wchar_t> &,wchar_t * *)+Ap
.text$mn:0000570C
.text$mn:0000570C var_4           = dword ptr -4
.text$mn:0000570C
.text$mn:0000570C                 push    ebp
.text$mn:0000570D                 mov     ebp, esp
.text$mn:0000570F                 push    ecx
.text$mn:00005710                 mov     [ebp+var_4], ecx
.text$mn:00005713                 mov     esp, ebp
.text$mn:00005715                 pop     ebp
.text$mn:00005716                 retn    4
.text$mn:00005716 ??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z endp
.text$mn:00005716
.text$mn:00005716 ; ---------------------------------------------------------------------------
.text$mn:00005719                 align 4
.text$mn:00005719 _text$mn        ends
.text$mn:00005719
.text$mn:0000571C ; ===========================================================================
.text$mn:0000571C
.text$mn:0000571C ; Segment type: Pure code
.text$mn:0000571C ; Segment permissions: Read/Execute
.text$mn:0000571C _text$mn        segment para public 'CODE' use32
.text$mn:0000571C                 assume cs:_text$mn
.text$mn:0000571C                 ;org 571Ch
.text$mn:0000571C ; COMDAT (pick any)
.text$mn:0000571C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000571C
.text$mn:0000571C ; =============== S U B R O U T I N E =======================================
.text$mn:0000571C
.text$mn:0000571C ; Attributes: bp-based frame
.text$mn:0000571C
.text$mn:0000571C ; public: static void __cdecl std::allocator_traits<class std::allocator<wchar_t>>::destroy<wchar_t *>(class std::allocator<wchar_t> &, wchar_t * *)
.text$mn:0000571C                 public ??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z
.text$mn:0000571C ??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z proc near
.text$mn:0000571C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::destroy<wchar_t *>(wchar_t * *)+Fp
.text$mn:0000571C
.text$mn:0000571C arg_0           = dword ptr  8
.text$mn:0000571C arg_4           = dword ptr  0Ch
.text$mn:0000571C
.text$mn:0000571C                 push    ebp
.text$mn:0000571D                 mov     ebp, esp
.text$mn:0000571F                 mov     eax, [ebp+arg_4]
.text$mn:00005722                 push    eax
.text$mn:00005723                 mov     ecx, [ebp+arg_0]
.text$mn:00005726                 call    ??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z ; std::allocator<wchar_t>::destroy<wchar_t *>(wchar_t * *)
.text$mn:0000572B                 pop     ebp
.text$mn:0000572C                 retn
.text$mn:0000572C ??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z endp
.text$mn:0000572C
.text$mn:0000572C ; ---------------------------------------------------------------------------
.text$mn:0000572D                 align 10h
.text$mn:0000572D _text$mn        ends
.text$mn:0000572D
.text$mn:00005730 ; ===========================================================================
.text$mn:00005730
.text$mn:00005730 ; Segment type: Pure code
.text$mn:00005730 ; Segment permissions: Read/Execute
.text$mn:00005730 _text$mn        segment para public 'CODE' use32
.text$mn:00005730                 assume cs:_text$mn
.text$mn:00005730                 ;org 5730h
.text$mn:00005730 ; COMDAT (pick any)
.text$mn:00005730                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005730
.text$mn:00005730 ; =============== S U B R O U T I N E =======================================
.text$mn:00005730
.text$mn:00005730 ; Attributes: bp-based frame
.text$mn:00005730
.text$mn:00005730 ; public: void __thiscall std::_Wrap_alloc<class std::allocator<struct std::_Container_proxy>>::destroy<struct std::_Container_proxy>(struct std::_Container_proxy *)
.text$mn:00005730                 public ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z
.text$mn:00005730 ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z proc near
.text$mn:00005730                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>::_Free_proxy(void)+22p
.text$mn:00005730                                         ; std::_Vector_alloc<0,std::_Vec_base_types<wchar_t,std::allocator<wchar_t>>>::_Free_proxy(void)+22p
.text$mn:00005730
.text$mn:00005730 var_4           = dword ptr -4
.text$mn:00005730 arg_0           = dword ptr  8
.text$mn:00005730
.text$mn:00005730                 push    ebp
.text$mn:00005731                 mov     ebp, esp
.text$mn:00005733                 push    ecx
.text$mn:00005734                 mov     [ebp+var_4], ecx
.text$mn:00005737                 mov     eax, [ebp+arg_0]
.text$mn:0000573A                 push    eax
.text$mn:0000573B                 mov     ecx, [ebp+var_4]
.text$mn:0000573E                 push    ecx
.text$mn:0000573F                 call    ??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z ; std::allocator_traits<std::allocator<std::_Container_proxy>>::destroy<std::_Container_proxy>(std::allocator<std::_Container_proxy> &,std::_Container_proxy *)
.text$mn:00005744                 add     esp, 8
.text$mn:00005747                 mov     esp, ebp
.text$mn:00005749                 pop     ebp
.text$mn:0000574A                 retn    4
.text$mn:0000574A ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z endp
.text$mn:0000574A
.text$mn:0000574A ; ---------------------------------------------------------------------------
.text$mn:0000574D                 align 10h
.text$mn:0000574D _text$mn        ends
.text$mn:0000574D
.text$mn:00005750 ; ===========================================================================
.text$mn:00005750
.text$mn:00005750 ; Segment type: Pure code
.text$mn:00005750 ; Segment permissions: Read/Execute
.text$mn:00005750 _text$mn        segment para public 'CODE' use32
.text$mn:00005750                 assume cs:_text$mn
.text$mn:00005750                 ;org 5750h
.text$mn:00005750 ; COMDAT (pick any)
.text$mn:00005750                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005750
.text$mn:00005750 ; =============== S U B R O U T I N E =======================================
.text$mn:00005750
.text$mn:00005750 ; Attributes: bp-based frame
.text$mn:00005750
.text$mn:00005750 ; public: void __thiscall std::allocator<struct std::_Container_proxy>::destroy<struct std::_Container_proxy>(struct std::_Container_proxy *)
.text$mn:00005750                 public ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z
.text$mn:00005750 ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z proc near
.text$mn:00005750                                         ; CODE XREF: std::allocator_traits<std::allocator<std::_Container_proxy>>::destroy<std::_Container_proxy>(std::allocator<std::_Container_proxy> &,std::_Container_proxy *)+Ap
.text$mn:00005750                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+22p ...
.text$mn:00005750
.text$mn:00005750 var_4           = dword ptr -4
.text$mn:00005750
.text$mn:00005750                 push    ebp
.text$mn:00005751                 mov     ebp, esp
.text$mn:00005753                 push    ecx
.text$mn:00005754                 mov     [ebp+var_4], ecx
.text$mn:00005757                 mov     esp, ebp
.text$mn:00005759                 pop     ebp
.text$mn:0000575A                 retn    4
.text$mn:0000575A ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z endp
.text$mn:0000575A
.text$mn:0000575A ; ---------------------------------------------------------------------------
.text$mn:0000575D                 align 10h
.text$mn:0000575D _text$mn        ends
.text$mn:0000575D
.text$mn:00005760 ; ===========================================================================
.text$mn:00005760
.text$mn:00005760 ; Segment type: Pure code
.text$mn:00005760 ; Segment permissions: Read/Execute
.text$mn:00005760 _text$mn        segment para public 'CODE' use32
.text$mn:00005760                 assume cs:_text$mn
.text$mn:00005760                 ;org 5760h
.text$mn:00005760 ; COMDAT (pick any)
.text$mn:00005760                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005760
.text$mn:00005760 ; =============== S U B R O U T I N E =======================================
.text$mn:00005760
.text$mn:00005760 ; Attributes: bp-based frame
.text$mn:00005760
.text$mn:00005760 ; public: static void __cdecl std::allocator_traits<class std::allocator<struct std::_Container_proxy>>::destroy<struct std::_Container_proxy>(class std::allocator<struct std::_Container_proxy> &, struct std::_Container_proxy *)
.text$mn:00005760                 public ??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z
.text$mn:00005760 ??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z proc near
.text$mn:00005760                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::destroy<std::_Container_proxy>(std::_Container_proxy *)+Fp
.text$mn:00005760
.text$mn:00005760 arg_0           = dword ptr  8
.text$mn:00005760 arg_4           = dword ptr  0Ch
.text$mn:00005760
.text$mn:00005760                 push    ebp
.text$mn:00005761                 mov     ebp, esp
.text$mn:00005763                 mov     eax, [ebp+arg_4]
.text$mn:00005766                 push    eax
.text$mn:00005767                 mov     ecx, [ebp+arg_0]
.text$mn:0000576A                 call    ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:0000576F                 pop     ebp
.text$mn:00005770                 retn
.text$mn:00005770 ??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z endp
.text$mn:00005770
.text$mn:00005770 ; ---------------------------------------------------------------------------
.text$mn:00005771                 align 4
.text$mn:00005771 _text$mn        ends
.text$mn:00005771
.text$mn:00005774 ; ===========================================================================
.text$mn:00005774
.text$mn:00005774 ; Segment type: Pure code
.text$mn:00005774 ; Segment permissions: Read/Execute
.text$mn:00005774 _text$mn        segment para public 'CODE' use32
.text$mn:00005774                 assume cs:_text$mn
.text$mn:00005774                 ;org 5774h
.text$mn:00005774 ; COMDAT (pick any)
.text$mn:00005774                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005774
.text$mn:00005774 ; =============== S U B R O U T I N E =======================================
.text$mn:00005774
.text$mn:00005774 ; Attributes: bp-based frame
.text$mn:00005774
.text$mn:00005774 ; int __cdecl std::distance<int *>(int *, int *)
.text$mn:00005774                 public ??$distance@PAH@std@@YAHPAH0@Z
.text$mn:00005774 ??$distance@PAH@std@@YAHPAH0@Z proc near
.text$mn:00005774                                         ; CODE XREF: std::rotate<int *>(int *,int *,int *)+95p
.text$mn:00005774
.text$mn:00005774 var_8           = dword ptr -8
.text$mn:00005774 var_1           = byte ptr -1
.text$mn:00005774 arg_0           = dword ptr  8
.text$mn:00005774 arg_4           = dword ptr  0Ch
.text$mn:00005774
.text$mn:00005774                 push    ebp
.text$mn:00005775                 mov     ebp, esp
.text$mn:00005777                 sub     esp, 8
.text$mn:0000577A                 mov     [ebp+var_8], 0
.text$mn:00005781                 lea     eax, [ebp+arg_0]
.text$mn:00005784                 push    eax
.text$mn:00005785                 lea     ecx, [ebp+var_1]
.text$mn:00005788                 push    ecx
.text$mn:00005789                 call    ??$_Iter_cat@PAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH@Z ; std::_Iter_cat<int *>(int * const &)
.text$mn:0000578E                 add     esp, 8
.text$mn:00005791                 mov     dl, [eax]
.text$mn:00005793                 movzx   eax, dl
.text$mn:00005796                 push    eax
.text$mn:00005797                 lea     ecx, [ebp+var_8]
.text$mn:0000579A                 push    ecx
.text$mn:0000579B                 mov     edx, [ebp+arg_4]
.text$mn:0000579E                 push    edx
.text$mn:0000579F                 mov     eax, [ebp+arg_0]
.text$mn:000057A2                 push    eax
.text$mn:000057A3                 call    ??$_Distance2@PAHH@std@@YAXPAH0AAHUrandom_access_iterator_tag@0@@Z ; std::_Distance2<int *,int>(int *,int *,int &,std::random_access_iterator_tag)
.text$mn:000057A8                 add     esp, 10h
.text$mn:000057AB                 mov     eax, [ebp+var_8]
.text$mn:000057AE                 mov     esp, ebp
.text$mn:000057B0                 pop     ebp
.text$mn:000057B1                 retn
.text$mn:000057B1 ??$distance@PAH@std@@YAHPAH0@Z endp
.text$mn:000057B1
.text$mn:000057B1 ; ---------------------------------------------------------------------------
.text$mn:000057B2                 align 4
.text$mn:000057B2 _text$mn        ends
.text$mn:000057B2
.text$mn:000057B4 ; ===========================================================================
.text$mn:000057B4
.text$mn:000057B4 ; Segment type: Pure code
.text$mn:000057B4 ; Segment permissions: Read/Execute
.text$mn:000057B4 _text$mn        segment para public 'CODE' use32
.text$mn:000057B4                 assume cs:_text$mn
.text$mn:000057B4                 ;org 57B4h
.text$mn:000057B4 ; COMDAT (pick any)
.text$mn:000057B4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000057B4
.text$mn:000057B4 ; =============== S U B R O U T I N E =======================================
.text$mn:000057B4
.text$mn:000057B4 ; Attributes: bp-based frame
.text$mn:000057B4
.text$mn:000057B4 ; int __cdecl std::distance<class std::_String_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>>>(class std::_String_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>>, class std::_String_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>>)
.text$mn:000057B4                 public ??$distance@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YAHV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0@Z
.text$mn:000057B4 ??$distance@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YAHV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0@Z proc near
.text$mn:000057B4                                         ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::_Construct<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::forward_iterator_tag)+76p
.text$mn:000057B4
.text$mn:000057B4 var_30          = dword ptr -30h
.text$mn:000057B4 var_2C          = dword ptr -2Ch
.text$mn:000057B4 var_28          = dword ptr -28h
.text$mn:000057B4 var_24          = dword ptr -24h
.text$mn:000057B4 var_20          = dword ptr -20h
.text$mn:000057B4 var_1C          = dword ptr -1Ch
.text$mn:000057B4 var_18          = dword ptr -18h
.text$mn:000057B4 var_14          = dword ptr -14h
.text$mn:000057B4 var_D           = byte ptr -0Dh
.text$mn:000057B4 var_C           = dword ptr -0Ch
.text$mn:000057B4 var_4           = dword ptr -4
.text$mn:000057B4 arg_0           = byte ptr  8
.text$mn:000057B4 arg_C           = byte ptr  14h
.text$mn:000057B4
.text$mn:000057B4                 push    ebp
.text$mn:000057B5                 mov     ebp, esp
.text$mn:000057B7                 push    0FFFFFFFFh
.text$mn:000057B9                 push    offset __ehhandler$??$distance@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YAHV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0@Z
.text$mn:000057BE                 mov     eax, large fs:0
.text$mn:000057C4                 push    eax
.text$mn:000057C5                 sub     esp, 24h
.text$mn:000057C8                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000057CD                 xor     eax, ebp
.text$mn:000057CF                 push    eax
.text$mn:000057D0                 lea     eax, [ebp+var_C]
.text$mn:000057D3                 mov     large fs:0, eax
.text$mn:000057D9                 mov     [ebp+var_4], 1
.text$mn:000057E0                 mov     [ebp+var_14], 0
.text$mn:000057E7                 lea     eax, [ebp+arg_0]
.text$mn:000057EA                 push    eax
.text$mn:000057EB                 lea     ecx, [ebp+var_D]
.text$mn:000057EE                 push    ecx
.text$mn:000057EF                 call    ??$_Iter_cat@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@@Z ; std::_Iter_cat<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:000057F4                 add     esp, 8
.text$mn:000057F7                 mov     dl, [eax]
.text$mn:000057F9                 movzx   eax, dl
.text$mn:000057FC                 push    eax
.text$mn:000057FD                 lea     ecx, [ebp+var_14]
.text$mn:00005800                 push    ecx
.text$mn:00005801                 sub     esp, 0Ch
.text$mn:00005804                 mov     ecx, esp
.text$mn:00005806                 mov     [ebp+var_24], esp
.text$mn:00005809                 lea     edx, [ebp+arg_C]
.text$mn:0000580C                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:0000580D                 call    ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:00005812                 mov     [ebp+var_18], eax
.text$mn:00005815                 mov     eax, [ebp+var_18]
.text$mn:00005818                 mov     [ebp+var_28], eax
.text$mn:0000581B                 mov     byte ptr [ebp+var_4], 2
.text$mn:0000581F                 sub     esp, 0Ch
.text$mn:00005822                 mov     ecx, esp
.text$mn:00005824                 mov     [ebp+var_2C], esp
.text$mn:00005827                 lea     edx, [ebp+arg_0]
.text$mn:0000582A                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:0000582B                 call    ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:00005830                 mov     [ebp+var_1C], eax
.text$mn:00005833                 mov     eax, [ebp+var_1C]
.text$mn:00005836                 mov     [ebp+var_30], eax
.text$mn:00005839                 mov     byte ptr [ebp+var_4], 3
.text$mn:0000583D                 mov     byte ptr [ebp+var_4], 1
.text$mn:00005841                 call    ??$_Distance2@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@H@std@@YAXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0AAHUrandom_access_iterator_tag@0@@Z ; std::_Distance2<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,int>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,int &,std::random_access_iterator_tag)
.text$mn:00005846                 add     esp, 20h
.text$mn:00005849                 mov     ecx, [ebp+var_14]
.text$mn:0000584C                 mov     [ebp+var_20], ecx
.text$mn:0000584F                 mov     byte ptr [ebp+var_4], 0
.text$mn:00005853                 lea     ecx, [ebp+arg_0]
.text$mn:00005856                 call    ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$mn:0000585B                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005862                 lea     ecx, [ebp+arg_C]
.text$mn:00005865                 call    ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$mn:0000586A                 mov     eax, [ebp+var_20]
.text$mn:0000586D                 mov     ecx, [ebp+var_C]
.text$mn:00005870                 mov     large fs:0, ecx
.text$mn:00005877                 pop     ecx
.text$mn:00005878                 mov     esp, ebp
.text$mn:0000587A                 pop     ebp
.text$mn:0000587B                 retn
.text$mn:0000587B ??$distance@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YAHV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0@Z endp
.text$mn:0000587B
.text$mn:0000587B _text$mn        ends
.text$mn:0000587B
.text$x:0000587C ; ===========================================================================
.text$x:0000587C
.text$x:0000587C ; Segment type: Pure code
.text$x:0000587C ; Segment permissions: Read/Execute
.text$x:0000587C _text$x         segment para public 'CODE' use32
.text$x:0000587C                 assume cs:_text$x
.text$x:0000587C                 ;org 587Ch
.text$x:0000587C ; COMDAT (pick associative to section at 57B4)
.text$x:0000587C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000587C
.text$x:0000587C ; =============== S U B R O U T I N E =======================================
.text$x:0000587C
.text$x:0000587C
.text$x:0000587C __unwindfunclet$??$distance@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YAHV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0@Z$0 proc near
.text$x:0000587C                                         ; DATA XREF: .xdata$x:0000D9B0o
.text$x:0000587C                 lea     ecx, [ebp+14h]
.text$x:0000587F                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:0000587F __unwindfunclet$??$distance@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YAHV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0@Z$0 endp
.text$x:0000587F
.text$x:00005884
.text$x:00005884 ; =============== S U B R O U T I N E =======================================
.text$x:00005884
.text$x:00005884
.text$x:00005884 __unwindfunclet$??$distance@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YAHV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0@Z$1 proc near
.text$x:00005884                                         ; DATA XREF: .xdata$x:0000D9B8o
.text$x:00005884                 lea     ecx, [ebp+8]
.text$x:00005887                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00005887 __unwindfunclet$??$distance@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YAHV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0@Z$1 endp
.text$x:00005887
.text$x:0000588C
.text$x:0000588C ; =============== S U B R O U T I N E =======================================
.text$x:0000588C
.text$x:0000588C
.text$x:0000588C __unwindfunclet$??$distance@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YAHV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0@Z$2 proc near
.text$x:0000588C                                         ; DATA XREF: .xdata$x:0000D9C0o
.text$x:0000588C                 mov     ecx, [ebp-24h]
.text$x:0000588F                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:0000588F __unwindfunclet$??$distance@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YAHV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0@Z$2 endp
.text$x:0000588F
.text$x:00005894
.text$x:00005894 ; =============== S U B R O U T I N E =======================================
.text$x:00005894
.text$x:00005894
.text$x:00005894 __unwindfunclet$??$distance@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YAHV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0@Z$3 proc near
.text$x:00005894                                         ; DATA XREF: .xdata$x:0000D9C8o
.text$x:00005894                 mov     ecx, [ebp-2Ch]
.text$x:00005897                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00005897 __unwindfunclet$??$distance@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YAHV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0@Z$3 endp
.text$x:00005897
.text$x:0000589C
.text$x:0000589C ; =============== S U B R O U T I N E =======================================
.text$x:0000589C
.text$x:0000589C
.text$x:0000589C __ehhandler$??$distance@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YAHV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0@Z proc near
.text$x:0000589C                                         ; DATA XREF: std::distance<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)+5o
.text$x:0000589C
.text$x:0000589C arg_4           = dword ptr  8
.text$x:0000589C
.text$x:0000589C                 mov     edx, [esp+arg_4]
.text$x:000058A0                 lea     eax, [edx+0Ch]
.text$x:000058A3                 mov     ecx, [edx-28h]
.text$x:000058A6                 xor     ecx, eax
.text$x:000058A8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000058AD                 mov     eax, offset __ehfuncinfo$??$distance@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YAHV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0@Z
.text$x:000058B2                 jmp     ___CxxFrameHandler3
.text$x:000058B2 __ehhandler$??$distance@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YAHV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0@Z endp
.text$x:000058B2
.text$x:000058B2 ; ---------------------------------------------------------------------------
.text$x:000058B7                 align 4
.text$x:000058B7 _text$x         ends
.text$x:000058B7
.text$mn:000058B8 ; ===========================================================================
.text$mn:000058B8
.text$mn:000058B8 ; Segment type: Pure code
.text$mn:000058B8 ; Segment permissions: Read/Execute
.text$mn:000058B8 _text$mn        segment para public 'CODE' use32
.text$mn:000058B8                 assume cs:_text$mn
.text$mn:000058B8                 ;org 58B8h
.text$mn:000058B8 ; COMDAT (pick any)
.text$mn:000058B8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000058B8
.text$mn:000058B8 ; =============== S U B R O U T I N E =======================================
.text$mn:000058B8
.text$mn:000058B8 ; Attributes: bp-based frame
.text$mn:000058B8
.text$mn:000058B8 ; class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<int>>> __cdecl std::find_if<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<int>>>, class std::binder2nd<struct std::equal_to<int>>>(class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<int>>>, class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<int>>>, class std::binder2nd<struct std::equal_to<int>>)
.text$mn:000058B8                 public ??$find_if@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@V?$binder2nd@U?$equal_to@H@std@@@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0V?$binder2nd@U?$equal_to@H@std@@@0@@Z
.text$mn:000058B8 ??$find_if@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@V?$binder2nd@U?$equal_to@H@std@@@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0V?$binder2nd@U?$equal_to@H@std@@@0@@Z proc near
.text$mn:000058B8                                         ; CODE XREF: std::remove_if<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::binder2nd<std::equal_to<int>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::binder2nd<std::equal_to<int>>)+7Fp
.text$mn:000058B8
.text$mn:000058B8 var_4C          = dword ptr -4Ch
.text$mn:000058B8 var_48          = dword ptr -48h
.text$mn:000058B8 var_44          = dword ptr -44h
.text$mn:000058B8 var_40          = dword ptr -40h
.text$mn:000058B8 var_3C          = dword ptr -3Ch
.text$mn:000058B8 var_38          = dword ptr -38h
.text$mn:000058B8 var_34          = dword ptr -34h
.text$mn:000058B8 var_30          = dword ptr -30h
.text$mn:000058B8 var_2C          = dword ptr -2Ch
.text$mn:000058B8 var_28          = dword ptr -28h
.text$mn:000058B8 var_24          = dword ptr -24h
.text$mn:000058B8 var_20          = dword ptr -20h
.text$mn:000058B8 var_1C          = dword ptr -1Ch
.text$mn:000058B8 var_18          = dword ptr -18h
.text$mn:000058B8 var_14          = dword ptr -14h
.text$mn:000058B8 var_10          = dword ptr -10h
.text$mn:000058B8 var_C           = dword ptr -0Ch
.text$mn:000058B8 var_4           = dword ptr -4
.text$mn:000058B8 arg_0           = dword ptr  8
.text$mn:000058B8 arg_4           = byte ptr  0Ch
.text$mn:000058B8 arg_10          = dword ptr  18h
.text$mn:000058B8 arg_1C          = dword ptr  24h
.text$mn:000058B8 arg_20          = dword ptr  28h
.text$mn:000058B8
.text$mn:000058B8                 push    ebp
.text$mn:000058B9                 mov     ebp, esp
.text$mn:000058BB                 push    0FFFFFFFFh
.text$mn:000058BD                 push    offset __ehhandler$??$find_if@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@V?$binder2nd@U?$equal_to@H@std@@@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0V?$binder2nd@U?$equal_to@H@std@@@0@@Z
.text$mn:000058C2                 mov     eax, large fs:0
.text$mn:000058C8                 push    eax
.text$mn:000058C9                 sub     esp, 40h
.text$mn:000058CC                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000058D1                 xor     eax, ebp
.text$mn:000058D3                 push    eax
.text$mn:000058D4                 lea     eax, [ebp+var_C]
.text$mn:000058D7                 mov     large fs:0, eax
.text$mn:000058DD                 mov     [ebp+var_10], 0
.text$mn:000058E4                 mov     [ebp+var_4], 2
.text$mn:000058EB                 push    35h ; '5'       ; unsigned int
.text$mn:000058ED                 push    offset ??_C@_1JC@HALMDPKM@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000058F2                 sub     esp, 0Ch
.text$mn:000058F5                 mov     ecx, esp
.text$mn:000058F7                 mov     [ebp+var_30], esp
.text$mn:000058FA                 lea     eax, [ebp+arg_10]
.text$mn:000058FD                 push    eax             ; int
.text$mn:000058FE                 call    ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>> const &)
.text$mn:00005903                 mov     [ebp+var_14], eax
.text$mn:00005906                 mov     ecx, [ebp+var_14]
.text$mn:00005909                 mov     [ebp+var_34], ecx
.text$mn:0000590C                 mov     byte ptr [ebp+var_4], 3
.text$mn:00005910                 sub     esp, 0Ch
.text$mn:00005913                 mov     ecx, esp
.text$mn:00005915                 mov     [ebp+var_38], esp
.text$mn:00005918                 lea     edx, [ebp+arg_4]
.text$mn:0000591B                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:0000591C                 call    ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>> const &)
.text$mn:00005921                 mov     [ebp+var_18], eax
.text$mn:00005924                 mov     eax, [ebp+var_18]
.text$mn:00005927                 mov     [ebp+var_3C], eax
.text$mn:0000592A                 mov     byte ptr [ebp+var_4], 4
.text$mn:0000592E                 mov     byte ptr [ebp+var_4], 2
.text$mn:00005932                 call    ??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0PB_WI@Z ; std::_Debug_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,wchar_t const *,uint)
.text$mn:00005937                 add     esp, 20h
.text$mn:0000593A                 push    36h ; '6'
.text$mn:0000593C                 push    offset ??_C@_1JC@HALMDPKM@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00005941                 lea     ecx, [ebp+arg_1C]
.text$mn:00005944                 push    ecx
.text$mn:00005945                 call    ??$_Debug_pointer@V?$binder2nd@U?$equal_to@H@std@@@std@@@std@@YAXAAV?$binder2nd@U?$equal_to@H@std@@@0@PB_WI@Z ; std::_Debug_pointer<std::binder2nd<std::equal_to<int>>>(std::binder2nd<std::equal_to<int>> &,wchar_t const *,uint)
.text$mn:0000594A                 add     esp, 0Ch
.text$mn:0000594D                 mov     edx, [ebp+arg_20]
.text$mn:00005950                 push    edx
.text$mn:00005951                 mov     eax, [ebp+arg_1C]
.text$mn:00005954                 push    eax
.text$mn:00005955                 sub     esp, 0Ch
.text$mn:00005958                 mov     ecx, esp
.text$mn:0000595A                 mov     [ebp+var_40], esp
.text$mn:0000595D                 lea     edx, [ebp+arg_10]
.text$mn:00005960                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:00005961                 call    ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>> const &)
.text$mn:00005966                 mov     [ebp+var_1C], eax
.text$mn:00005969                 mov     eax, [ebp+var_1C]
.text$mn:0000596C                 mov     [ebp+var_44], eax
.text$mn:0000596F                 mov     byte ptr [ebp+var_4], 5
.text$mn:00005973                 mov     byte ptr [ebp+var_4], 2
.text$mn:00005977                 call    ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@YAPAHV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<int>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>)
.text$mn:0000597C                 add     esp, 0Ch
.text$mn:0000597F                 mov     [ebp+var_20], eax
.text$mn:00005982                 mov     ecx, [ebp+var_20]
.text$mn:00005985                 push    ecx
.text$mn:00005986                 sub     esp, 0Ch
.text$mn:00005989                 mov     ecx, esp
.text$mn:0000598B                 mov     [ebp+var_48], esp
.text$mn:0000598E                 lea     edx, [ebp+arg_4]
.text$mn:00005991                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:00005992                 call    ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>> const &)
.text$mn:00005997                 mov     [ebp+var_24], eax
.text$mn:0000599A                 mov     eax, [ebp+var_24]
.text$mn:0000599D                 mov     [ebp+var_4C], eax
.text$mn:000059A0                 mov     byte ptr [ebp+var_4], 6
.text$mn:000059A4                 mov     byte ptr [ebp+var_4], 2
.text$mn:000059A8                 call    ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@YAPAHV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<int>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>)
.text$mn:000059AD                 add     esp, 0Ch
.text$mn:000059B0                 mov     [ebp+var_28], eax
.text$mn:000059B3                 mov     ecx, [ebp+var_28]
.text$mn:000059B6                 push    ecx
.text$mn:000059B7                 call    ??$_Find_if@PAHV?$binder2nd@U?$equal_to@H@std@@@std@@@std@@YAPAHPAH0V?$binder2nd@U?$equal_to@H@std@@@0@@Z ; std::_Find_if<int *,std::binder2nd<std::equal_to<int>>>(int *,int *,std::binder2nd<std::equal_to<int>>)
.text$mn:000059BC                 add     esp, 10h
.text$mn:000059BF                 mov     [ebp+var_2C], eax
.text$mn:000059C2                 mov     edx, [ebp+var_2C]
.text$mn:000059C5                 push    edx
.text$mn:000059C6                 lea     eax, [ebp+arg_4]
.text$mn:000059C9                 push    eax
.text$mn:000059CA                 call    ??$_Rechecked@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@YAAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@AAV10@PAH@Z ; std::_Rechecked<std::_Vector_val<std::_Simple_types<int>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>> &,int *)
.text$mn:000059CF                 add     esp, 8
.text$mn:000059D2                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:000059D3                 mov     ecx, [ebp+arg_0]
.text$mn:000059D6                 call    ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>> const &)
.text$mn:000059DB                 mov     ecx, [ebp+var_10]
.text$mn:000059DE                 or      ecx, 1
.text$mn:000059E1                 mov     [ebp+var_10], ecx
.text$mn:000059E4                 mov     byte ptr [ebp+var_4], 1
.text$mn:000059E8                 lea     ecx, [ebp+arg_4]
.text$mn:000059EB                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$mn:000059F0                 mov     byte ptr [ebp+var_4], 0
.text$mn:000059F4                 lea     ecx, [ebp+arg_10]
.text$mn:000059F7                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$mn:000059FC                 mov     eax, [ebp+arg_0]
.text$mn:000059FF                 mov     ecx, [ebp+var_C]
.text$mn:00005A02                 mov     large fs:0, ecx
.text$mn:00005A09                 pop     ecx
.text$mn:00005A0A                 mov     esp, ebp
.text$mn:00005A0C                 pop     ebp
.text$mn:00005A0D                 retn
.text$mn:00005A0D ??$find_if@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@V?$binder2nd@U?$equal_to@H@std@@@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0V?$binder2nd@U?$equal_to@H@std@@@0@@Z endp
.text$mn:00005A0D
.text$mn:00005A0D ; ---------------------------------------------------------------------------
.text$mn:00005A0E                 align 10h
.text$mn:00005A0E _text$mn        ends
.text$mn:00005A0E
.text$x:00005A10 ; ===========================================================================
.text$x:00005A10
.text$x:00005A10 ; Segment type: Pure code
.text$x:00005A10 ; Segment permissions: Read/Execute
.text$x:00005A10 _text$x         segment para public 'CODE' use32
.text$x:00005A10                 assume cs:_text$x
.text$x:00005A10                 ;org 5A10h
.text$x:00005A10 ; COMDAT (pick associative to section at 58B8)
.text$x:00005A10                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00005A10
.text$x:00005A10 ; =============== S U B R O U T I N E =======================================
.text$x:00005A10
.text$x:00005A10
.text$x:00005A10 __unwindfunclet$??$find_if@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@V?$binder2nd@U?$equal_to@H@std@@@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0V?$binder2nd@U?$equal_to@H@std@@@0@@Z$0 proc near
.text$x:00005A10                                         ; DATA XREF: .xdata$x:0000D79Co
.text$x:00005A10                 lea     ecx, [ebp+18h]
.text$x:00005A13                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$x:00005A13 __unwindfunclet$??$find_if@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@V?$binder2nd@U?$equal_to@H@std@@@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0V?$binder2nd@U?$equal_to@H@std@@@0@@Z$0 endp
.text$x:00005A13
.text$x:00005A18
.text$x:00005A18 ; =============== S U B R O U T I N E =======================================
.text$x:00005A18
.text$x:00005A18
.text$x:00005A18 __unwindfunclet$??$find_if@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@V?$binder2nd@U?$equal_to@H@std@@@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0V?$binder2nd@U?$equal_to@H@std@@@0@@Z$1 proc near
.text$x:00005A18                                         ; DATA XREF: .xdata$x:0000D7A4o
.text$x:00005A18                 lea     ecx, [ebp+0Ch]
.text$x:00005A1B                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$x:00005A1B __unwindfunclet$??$find_if@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@V?$binder2nd@U?$equal_to@H@std@@@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0V?$binder2nd@U?$equal_to@H@std@@@0@@Z$1 endp
.text$x:00005A1B
.text$x:00005A20
.text$x:00005A20 ; =============== S U B R O U T I N E =======================================
.text$x:00005A20
.text$x:00005A20
.text$x:00005A20 __unwindfunclet$??$find_if@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@V?$binder2nd@U?$equal_to@H@std@@@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0V?$binder2nd@U?$equal_to@H@std@@@0@@Z$2 proc near
.text$x:00005A20                                         ; DATA XREF: .xdata$x:0000D7ACo
.text$x:00005A20                 mov     ecx, [ebp-30h]
.text$x:00005A23                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$x:00005A23 __unwindfunclet$??$find_if@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@V?$binder2nd@U?$equal_to@H@std@@@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0V?$binder2nd@U?$equal_to@H@std@@@0@@Z$2 endp
.text$x:00005A23
.text$x:00005A28
.text$x:00005A28 ; =============== S U B R O U T I N E =======================================
.text$x:00005A28
.text$x:00005A28
.text$x:00005A28 __unwindfunclet$??$find_if@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@V?$binder2nd@U?$equal_to@H@std@@@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0V?$binder2nd@U?$equal_to@H@std@@@0@@Z$3 proc near
.text$x:00005A28                                         ; DATA XREF: .xdata$x:0000D7B4o
.text$x:00005A28                 mov     ecx, [ebp-38h]
.text$x:00005A2B                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$x:00005A2B __unwindfunclet$??$find_if@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@V?$binder2nd@U?$equal_to@H@std@@@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0V?$binder2nd@U?$equal_to@H@std@@@0@@Z$3 endp
.text$x:00005A2B
.text$x:00005A30
.text$x:00005A30 ; =============== S U B R O U T I N E =======================================
.text$x:00005A30
.text$x:00005A30
.text$x:00005A30 __unwindfunclet$??$find_if@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@V?$binder2nd@U?$equal_to@H@std@@@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0V?$binder2nd@U?$equal_to@H@std@@@0@@Z$4 proc near
.text$x:00005A30                                         ; DATA XREF: .xdata$x:0000D7BCo
.text$x:00005A30                 mov     ecx, [ebp-40h]
.text$x:00005A33                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$x:00005A33 __unwindfunclet$??$find_if@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@V?$binder2nd@U?$equal_to@H@std@@@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0V?$binder2nd@U?$equal_to@H@std@@@0@@Z$4 endp
.text$x:00005A33
.text$x:00005A38
.text$x:00005A38 ; =============== S U B R O U T I N E =======================================
.text$x:00005A38
.text$x:00005A38
.text$x:00005A38 __unwindfunclet$??$find_if@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@V?$binder2nd@U?$equal_to@H@std@@@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0V?$binder2nd@U?$equal_to@H@std@@@0@@Z$5 proc near
.text$x:00005A38                                         ; DATA XREF: .xdata$x:0000D7C4o
.text$x:00005A38                 mov     ecx, [ebp-48h]
.text$x:00005A3B                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$x:00005A3B __unwindfunclet$??$find_if@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@V?$binder2nd@U?$equal_to@H@std@@@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0V?$binder2nd@U?$equal_to@H@std@@@0@@Z$5 endp
.text$x:00005A3B
.text$x:00005A40
.text$x:00005A40 ; =============== S U B R O U T I N E =======================================
.text$x:00005A40
.text$x:00005A40
.text$x:00005A40 __unwindfunclet$??$find_if@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@V?$binder2nd@U?$equal_to@H@std@@@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0V?$binder2nd@U?$equal_to@H@std@@@0@@Z$6 proc near
.text$x:00005A40                                         ; DATA XREF: .xdata$x:0000D794o
.text$x:00005A40                 mov     eax, [ebp-10h]
.text$x:00005A43                 and     eax, 1
.text$x:00005A46                 jz      $LN10_0
.text$x:00005A4C                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:00005A50                 mov     ecx, [ebp+8]
.text$x:00005A53                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$x:00005A58 ; ---------------------------------------------------------------------------
.text$x:00005A58
.text$x:00005A58 $LN10_0:                                ; CODE XREF: __unwindfunclet$??$find_if@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@V?$binder2nd@U?$equal_to@H@std@@@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0V?$binder2nd@U?$equal_to@H@std@@@0@@Z$6+6j
.text$x:00005A58                 retn
.text$x:00005A58 __unwindfunclet$??$find_if@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@V?$binder2nd@U?$equal_to@H@std@@@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0V?$binder2nd@U?$equal_to@H@std@@@0@@Z$6 endp
.text$x:00005A58
.text$x:00005A59
.text$x:00005A59 ; =============== S U B R O U T I N E =======================================
.text$x:00005A59
.text$x:00005A59
.text$x:00005A59 __ehhandler$??$find_if@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@V?$binder2nd@U?$equal_to@H@std@@@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0V?$binder2nd@U?$equal_to@H@std@@@0@@Z proc near
.text$x:00005A59                                         ; DATA XREF: std::find_if<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::binder2nd<std::equal_to<int>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::binder2nd<std::equal_to<int>>)+5o
.text$x:00005A59
.text$x:00005A59 arg_4           = dword ptr  8
.text$x:00005A59
.text$x:00005A59                 mov     edx, [esp+arg_4]
.text$x:00005A5D                 lea     eax, [edx+0Ch]
.text$x:00005A60                 mov     ecx, [edx-44h]
.text$x:00005A63                 xor     ecx, eax
.text$x:00005A65                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005A6A                 mov     eax, offset __ehfuncinfo$??$find_if@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@V?$binder2nd@U?$equal_to@H@std@@@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0V?$binder2nd@U?$equal_to@H@std@@@0@@Z
.text$x:00005A6F                 jmp     ___CxxFrameHandler3
.text$x:00005A6F __ehhandler$??$find_if@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@V?$binder2nd@U?$equal_to@H@std@@@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0V?$binder2nd@U?$equal_to@H@std@@@0@@Z endp
.text$x:00005A6F
.text$x:00005A6F _text$x         ends
.text$x:00005A6F
.text$mn:00005A74 ; ===========================================================================
.text$mn:00005A74
.text$mn:00005A74 ; Segment type: Pure code
.text$mn:00005A74 ; Segment permissions: Read/Execute
.text$mn:00005A74 _text$mn        segment para public 'CODE' use32
.text$mn:00005A74                 assume cs:_text$mn
.text$mn:00005A74                 ;org 5A74h
.text$mn:00005A74 ; COMDAT (pick any)
.text$mn:00005A74                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005A74
.text$mn:00005A74 ; =============== S U B R O U T I N E =======================================
.text$mn:00005A74
.text$mn:00005A74 ; Attributes: bp-based frame
.text$mn:00005A74
.text$mn:00005A74 ; int & __cdecl std::forward<int &>(int &)
.text$mn:00005A74                 public ??$forward@AAH@std@@YAAAHAAH@Z
.text$mn:00005A74 ??$forward@AAH@std@@YAAAHAAH@Z proc near
.text$mn:00005A74                                         ; CODE XREF: std::pair<int *,int>::pair<int *,int>(int * &,int &)+1Ep
.text$mn:00005A74                                         ; std::_Debug_lt_pred<BufferEquivalent,int &,int &>(BufferEquivalent,int &,int &,wchar_t const *,uint)+7p ...
.text$mn:00005A74
.text$mn:00005A74 arg_0           = dword ptr  8
.text$mn:00005A74
.text$mn:00005A74                 push    ebp
.text$mn:00005A75                 mov     ebp, esp
.text$mn:00005A77                 mov     eax, [ebp+arg_0]
.text$mn:00005A7A                 pop     ebp
.text$mn:00005A7B                 retn
.text$mn:00005A7B ??$forward@AAH@std@@YAAAHAAH@Z endp
.text$mn:00005A7B
.text$mn:00005A7B _text$mn        ends
.text$mn:00005A7B
.text$mn:00005A7C ; ===========================================================================
.text$mn:00005A7C
.text$mn:00005A7C ; Segment type: Pure code
.text$mn:00005A7C ; Segment permissions: Read/Execute
.text$mn:00005A7C _text$mn        segment para public 'CODE' use32
.text$mn:00005A7C                 assume cs:_text$mn
.text$mn:00005A7C                 ;org 5A7Ch
.text$mn:00005A7C ; COMDAT (pick any)
.text$mn:00005A7C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005A7C
.text$mn:00005A7C ; =============== S U B R O U T I N E =======================================
.text$mn:00005A7C
.text$mn:00005A7C ; Attributes: bp-based frame
.text$mn:00005A7C
.text$mn:00005A7C ; char * & __cdecl std::forward<char * &>(char * &)
.text$mn:00005A7C                 public ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
.text$mn:00005A7C ??$forward@AAPAD@std@@YAAAPADAAPAD@Z proc near
.text$mn:00005A7C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)+Bp
.text$mn:00005A7C                                         ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)+4Ap ...
.text$mn:00005A7C
.text$mn:00005A7C arg_0           = dword ptr  8
.text$mn:00005A7C
.text$mn:00005A7C                 push    ebp
.text$mn:00005A7D                 mov     ebp, esp
.text$mn:00005A7F                 mov     eax, [ebp+arg_0]
.text$mn:00005A82                 pop     ebp
.text$mn:00005A83                 retn
.text$mn:00005A83 ??$forward@AAPAD@std@@YAAAPADAAPAD@Z endp
.text$mn:00005A83
.text$mn:00005A83 _text$mn        ends
.text$mn:00005A83
.text$mn:00005A84 ; ===========================================================================
.text$mn:00005A84
.text$mn:00005A84 ; Segment type: Pure code
.text$mn:00005A84 ; Segment permissions: Read/Execute
.text$mn:00005A84 _text$mn        segment para public 'CODE' use32
.text$mn:00005A84                 assume cs:_text$mn
.text$mn:00005A84                 ;org 5A84h
.text$mn:00005A84 ; COMDAT (pick any)
.text$mn:00005A84                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005A84
.text$mn:00005A84 ; =============== S U B R O U T I N E =======================================
.text$mn:00005A84
.text$mn:00005A84 ; Attributes: bp-based frame
.text$mn:00005A84
.text$mn:00005A84 ; int * & __cdecl std::forward<int * &>(int * &)
.text$mn:00005A84                 public ??$forward@AAPAH@std@@YAAAPAHAAPAH@Z
.text$mn:00005A84 ??$forward@AAPAH@std@@YAAAPAHAAPAH@Z proc near
.text$mn:00005A84                                         ; CODE XREF: std::pair<int *,int>::pair<int *,int>(int * &,int &)+Bp
.text$mn:00005A84
.text$mn:00005A84 arg_0           = dword ptr  8
.text$mn:00005A84
.text$mn:00005A84                 push    ebp
.text$mn:00005A85                 mov     ebp, esp
.text$mn:00005A87                 mov     eax, [ebp+arg_0]
.text$mn:00005A8A                 pop     ebp
.text$mn:00005A8B                 retn
.text$mn:00005A8B ??$forward@AAPAH@std@@YAAAPAHAAPAH@Z endp
.text$mn:00005A8B
.text$mn:00005A8B _text$mn        ends
.text$mn:00005A8B
.text$mn:00005A8C ; ===========================================================================
.text$mn:00005A8C
.text$mn:00005A8C ; Segment type: Pure code
.text$mn:00005A8C ; Segment permissions: Read/Execute
.text$mn:00005A8C _text$mn        segment para public 'CODE' use32
.text$mn:00005A8C                 assume cs:_text$mn
.text$mn:00005A8C                 ;org 5A8Ch
.text$mn:00005A8C ; COMDAT (pick any)
.text$mn:00005A8C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005A8C
.text$mn:00005A8C ; =============== S U B R O U T I N E =======================================
.text$mn:00005A8C
.text$mn:00005A8C ; Attributes: bp-based frame
.text$mn:00005A8C
.text$mn:00005A8C ; wchar_t * & __cdecl std::forward<wchar_t * &>(wchar_t * &)
.text$mn:00005A8C                 public ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z
.text$mn:00005A8C ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z proc near
.text$mn:00005A8C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+Bp
.text$mn:00005A8C                                         ; std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+4Ap ...
.text$mn:00005A8C
.text$mn:00005A8C arg_0           = dword ptr  8
.text$mn:00005A8C
.text$mn:00005A8C                 push    ebp
.text$mn:00005A8D                 mov     ebp, esp
.text$mn:00005A8F                 mov     eax, [ebp+arg_0]
.text$mn:00005A92                 pop     ebp
.text$mn:00005A93                 retn
.text$mn:00005A93 ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z endp
.text$mn:00005A93
.text$mn:00005A93 _text$mn        ends
.text$mn:00005A93
.text$mn:00005A94 ; ===========================================================================
.text$mn:00005A94
.text$mn:00005A94 ; Segment type: Pure code
.text$mn:00005A94 ; Segment permissions: Read/Execute
.text$mn:00005A94 _text$mn        segment para public 'CODE' use32
.text$mn:00005A94                 assume cs:_text$mn
.text$mn:00005A94                 ;org 5A94h
.text$mn:00005A94 ; COMDAT (pick any)
.text$mn:00005A94                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005A94
.text$mn:00005A94 ; =============== S U B R O U T I N E =======================================
.text$mn:00005A94
.text$mn:00005A94 ; Attributes: bp-based frame
.text$mn:00005A94
.text$mn:00005A94 ; int && __cdecl std::forward<int>(int &)
.text$mn:00005A94                 public ??$forward@H@std@@YA$$QAHAAH@Z
.text$mn:00005A94 ??$forward@H@std@@YA$$QAHAAH@Z proc near
.text$mn:00005A94                                         ; CODE XREF: std::_Construct<int,int>(int *,int &&)+4Dp
.text$mn:00005A94                                         ; std::_Temp_iterator<int>::operator=(int &&)+21p ...
.text$mn:00005A94
.text$mn:00005A94 arg_0           = dword ptr  8
.text$mn:00005A94
.text$mn:00005A94                 push    ebp
.text$mn:00005A95                 mov     ebp, esp
.text$mn:00005A97                 mov     eax, [ebp+arg_0]
.text$mn:00005A9A                 pop     ebp
.text$mn:00005A9B                 retn
.text$mn:00005A9B ??$forward@H@std@@YA$$QAHAAH@Z endp
.text$mn:00005A9B
.text$mn:00005A9B _text$mn        ends
.text$mn:00005A9B
.text$mn:00005A9C ; ===========================================================================
.text$mn:00005A9C
.text$mn:00005A9C ; Segment type: Pure code
.text$mn:00005A9C ; Segment permissions: Read/Execute
.text$mn:00005A9C _text$mn        segment para public 'CODE' use32
.text$mn:00005A9C                 assume cs:_text$mn
.text$mn:00005A9C                 ;org 5A9Ch
.text$mn:00005A9C ; COMDAT (pick any)
.text$mn:00005A9C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005A9C
.text$mn:00005A9C ; =============== S U B R O U T I N E =======================================
.text$mn:00005A9C
.text$mn:00005A9C ; Attributes: bp-based frame
.text$mn:00005A9C
.text$mn:00005A9C ; struct std::_Container_proxy && __cdecl std::forward<struct std::_Container_proxy>(struct std::_Container_proxy &)
.text$mn:00005A9C                 public ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z
.text$mn:00005A9C ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z proc near
.text$mn:00005A9C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+Bp
.text$mn:00005A9C                                         ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+4Ap ...
.text$mn:00005A9C
.text$mn:00005A9C arg_0           = dword ptr  8
.text$mn:00005A9C
.text$mn:00005A9C                 push    ebp
.text$mn:00005A9D                 mov     ebp, esp
.text$mn:00005A9F                 mov     eax, [ebp+arg_0]
.text$mn:00005AA2                 pop     ebp
.text$mn:00005AA3                 retn
.text$mn:00005AA3 ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z endp
.text$mn:00005AA3
.text$mn:00005AA3 _text$mn        ends
.text$mn:00005AA3
.text$mn:00005AA4 ; ===========================================================================
.text$mn:00005AA4
.text$mn:00005AA4 ; Segment type: Pure code
.text$mn:00005AA4 ; Segment permissions: Read/Execute
.text$mn:00005AA4 _text$mn        segment para public 'CODE' use32
.text$mn:00005AA4                 assume cs:_text$mn
.text$mn:00005AA4                 ;org 5AA4h
.text$mn:00005AA4 ; COMDAT (pick any)
.text$mn:00005AA4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005AA4
.text$mn:00005AA4 ; =============== S U B R O U T I N E =======================================
.text$mn:00005AA4
.text$mn:00005AA4 ; Attributes: bp-based frame
.text$mn:00005AA4
.text$mn:00005AA4 ; wchar_t && __cdecl std::forward<wchar_t>(wchar_t &)
.text$mn:00005AA4                 public ??$forward@_W@std@@YA$$QA_WAA_W@Z
.text$mn:00005AA4 ??$forward@_W@std@@YA$$QA_WAA_W@Z proc near
.text$mn:00005AA4                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::construct<wchar_t,wchar_t>(wchar_t *,wchar_t &&)+Bp
.text$mn:00005AA4                                         ; std::allocator<wchar_t>::construct<wchar_t,wchar_t>(wchar_t *,wchar_t &&)+4Ap ...
.text$mn:00005AA4
.text$mn:00005AA4 arg_0           = dword ptr  8
.text$mn:00005AA4
.text$mn:00005AA4                 push    ebp
.text$mn:00005AA5                 mov     ebp, esp
.text$mn:00005AA7                 mov     eax, [ebp+arg_0]
.text$mn:00005AAA                 pop     ebp
.text$mn:00005AAB                 retn
.text$mn:00005AAB ??$forward@_W@std@@YA$$QA_WAA_W@Z endp
.text$mn:00005AAB
.text$mn:00005AAB _text$mn        ends
.text$mn:00005AAB
.text$mn:00005AAC ; ===========================================================================
.text$mn:00005AAC
.text$mn:00005AAC ; Segment type: Pure code
.text$mn:00005AAC ; Segment permissions: Read/Execute
.text$mn:00005AAC _text$mn        segment para public 'CODE' use32
.text$mn:00005AAC                 assume cs:_text$mn
.text$mn:00005AAC                 ;org 5AACh
.text$mn:00005AAC ; COMDAT (pick any)
.text$mn:00005AAC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005AAC
.text$mn:00005AAC ; =============== S U B R O U T I N E =======================================
.text$mn:00005AAC
.text$mn:00005AAC ; Attributes: bp-based frame
.text$mn:00005AAC
.text$mn:00005AAC ; struct std::pair<int *, int> __cdecl std::get_temporary_buffer<int>(int)
.text$mn:00005AAC                 public ??$get_temporary_buffer@H@std@@YA?AU?$pair@PAHH@0@H@Z
.text$mn:00005AAC ??$get_temporary_buffer@H@std@@YA?AU?$pair@PAHH@0@H@Z proc near
.text$mn:00005AAC                                         ; CODE XREF: std::_Temp_iterator<int>::_Maxlen(void)+2Ep
.text$mn:00005AAC
.text$mn:00005AAC var_4           = dword ptr -4
.text$mn:00005AAC arg_0           = dword ptr  8
.text$mn:00005AAC arg_4           = dword ptr  0Ch
.text$mn:00005AAC
.text$mn:00005AAC                 push    ebp
.text$mn:00005AAD                 mov     ebp, esp
.text$mn:00005AAF                 push    ecx
.text$mn:00005AB0                 cmp     [ebp+arg_4], 0
.text$mn:00005AB4                 jge     short loc_5ABF
.text$mn:00005AB6                 mov     [ebp+arg_4], 0
.text$mn:00005ABD                 jmp     short loc_5ACD
.text$mn:00005ABF ; ---------------------------------------------------------------------------
.text$mn:00005ABF
.text$mn:00005ABF loc_5ABF:                               ; CODE XREF: std::get_temporary_buffer<int>(int)+8j
.text$mn:00005ABF                 cmp     [ebp+arg_4], 3FFFFFFFh
.text$mn:00005AC6                 jbe     short loc_5ACD
.text$mn:00005AC8                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:00005ACD
.text$mn:00005ACD loc_5ACD:                               ; CODE XREF: std::get_temporary_buffer<int>(int)+11j
.text$mn:00005ACD                                         ; std::get_temporary_buffer<int>(int)+1Aj
.text$mn:00005ACD                 mov     [ebp+var_4], 0
.text$mn:00005AD4                 jmp     short loc_5AE1
.text$mn:00005AD6 ; ---------------------------------------------------------------------------
.text$mn:00005AD6
.text$mn:00005AD6 loc_5AD6:                               ; CODE XREF: std::get_temporary_buffer<int>(int):loc_5B06j
.text$mn:00005AD6                 mov     eax, [ebp+arg_4]
.text$mn:00005AD9                 cdq
.text$mn:00005ADA                 sub     eax, edx
.text$mn:00005ADC                 sar     eax, 1
.text$mn:00005ADE                 mov     [ebp+arg_4], eax
.text$mn:00005AE1
.text$mn:00005AE1 loc_5AE1:                               ; CODE XREF: std::get_temporary_buffer<int>(int)+28j
.text$mn:00005AE1                 cmp     [ebp+arg_4], 0
.text$mn:00005AE5                 jle     short loc_5B08
.text$mn:00005AE7                 push    offset ?nothrow@std@@3Unothrow_t@1@B ; struct std::nothrow_t *
.text$mn:00005AEC                 mov     eax, [ebp+arg_4]
.text$mn:00005AEF                 shl     eax, 2
.text$mn:00005AF2                 push    eax             ; unsigned int
.text$mn:00005AF3                 call    ??2@YAPAXIABUnothrow_t@std@@@Z ; operator new(uint,std::nothrow_t const &)
.text$mn:00005AF8                 add     esp, 8
.text$mn:00005AFB                 mov     [ebp+var_4], eax
.text$mn:00005AFE                 cmp     [ebp+var_4], 0
.text$mn:00005B02                 jz      short loc_5B06
.text$mn:00005B04                 jmp     short loc_5B08
.text$mn:00005B06 ; ---------------------------------------------------------------------------
.text$mn:00005B06
.text$mn:00005B06 loc_5B06:                               ; CODE XREF: std::get_temporary_buffer<int>(int)+56j
.text$mn:00005B06                 jmp     short loc_5AD6
.text$mn:00005B08 ; ---------------------------------------------------------------------------
.text$mn:00005B08
.text$mn:00005B08 loc_5B08:                               ; CODE XREF: std::get_temporary_buffer<int>(int)+39j
.text$mn:00005B08                                         ; std::get_temporary_buffer<int>(int)+58j
.text$mn:00005B08                 lea     ecx, [ebp+arg_4]
.text$mn:00005B0B                 push    ecx
.text$mn:00005B0C                 lea     edx, [ebp+var_4]
.text$mn:00005B0F                 push    edx
.text$mn:00005B10                 mov     ecx, [ebp+arg_0]
.text$mn:00005B13                 call    ??$?0AAPAHAAHX@?$pair@PAHH@std@@QAE@AAPAHAAH@Z ; std::pair<int *,int>::pair<int *,int>(int * &,int &)
.text$mn:00005B18                 mov     eax, [ebp+arg_0]
.text$mn:00005B1B                 mov     esp, ebp
.text$mn:00005B1D                 pop     ebp
.text$mn:00005B1E                 retn
.text$mn:00005B1E ??$get_temporary_buffer@H@std@@YA?AU?$pair@PAHH@0@H@Z endp
.text$mn:00005B1E
.text$mn:00005B1E ; ---------------------------------------------------------------------------
.text$mn:00005B1F                 align 10h
.text$mn:00005B1F _text$mn        ends
.text$mn:00005B1F
.text$mn:00005B20 ; ===========================================================================
.text$mn:00005B20
.text$mn:00005B20 ; Segment type: Pure code
.text$mn:00005B20 ; Segment permissions: Read/Execute
.text$mn:00005B20 _text$mn        segment para public 'CODE' use32
.text$mn:00005B20                 assume cs:_text$mn
.text$mn:00005B20                 ;org 5B20h
.text$mn:00005B20 ; COMDAT (pick any)
.text$mn:00005B20                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005B20
.text$mn:00005B20 ; =============== S U B R O U T I N E =======================================
.text$mn:00005B20
.text$mn:00005B20 ; Attributes: bp-based frame
.text$mn:00005B20
.text$mn:00005B20 ; void __cdecl std::iter_swap<int *, int *>(int *, int *)
.text$mn:00005B20                 public ??$iter_swap@PAHPAH@std@@YAXPAH0@Z
.text$mn:00005B20 ??$iter_swap@PAHPAH@std@@YAXPAH0@Z proc near
.text$mn:00005B20                                         ; CODE XREF: std::_Buffered_merge<int *,int,int,BufferEquivalent>(int *,int *,int *,int,int,std::_Temp_iterator<int> &,BufferEquivalent)+86p
.text$mn:00005B20                                         ; std::_Rotate<int *,int,int>(int *,int *,int *,int *,int *)+ABp
.text$mn:00005B20
.text$mn:00005B20 arg_0           = dword ptr  8
.text$mn:00005B20 arg_4           = dword ptr  0Ch
.text$mn:00005B20
.text$mn:00005B20                 push    ebp
.text$mn:00005B21                 mov     ebp, esp
.text$mn:00005B23                 mov     eax, [ebp+arg_4]
.text$mn:00005B26                 push    eax
.text$mn:00005B27                 mov     ecx, [ebp+arg_0]
.text$mn:00005B2A                 push    ecx
.text$mn:00005B2B                 call    ??$swap@H@std@@YAXAAH0@Z ; std::swap<int>(int &,int &)
.text$mn:00005B30                 add     esp, 8
.text$mn:00005B33                 pop     ebp
.text$mn:00005B34                 retn
.text$mn:00005B34 ??$iter_swap@PAHPAH@std@@YAXPAH0@Z endp
.text$mn:00005B34
.text$mn:00005B34 ; ---------------------------------------------------------------------------
.text$mn:00005B35                 align 4
.text$mn:00005B35 _text$mn        ends
.text$mn:00005B35
.text$mn:00005B38 ; ===========================================================================
.text$mn:00005B38
.text$mn:00005B38 ; Segment type: Pure code
.text$mn:00005B38 ; Segment permissions: Read/Execute
.text$mn:00005B38 _text$mn        segment para public 'CODE' use32
.text$mn:00005B38                 assume cs:_text$mn
.text$mn:00005B38                 ;org 5B38h
.text$mn:00005B38 ; COMDAT (pick any)
.text$mn:00005B38                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005B38
.text$mn:00005B38 ; =============== S U B R O U T I N E =======================================
.text$mn:00005B38
.text$mn:00005B38 ; Attributes: bp-based frame
.text$mn:00005B38
.text$mn:00005B38 ; int * __cdecl std::lower_bound<int *, int, struct BufferEquivalent>(int *, int *, int const &, struct BufferEquivalent)
.text$mn:00005B38                 public ??$lower_bound@PAHHUBufferEquivalent@@@std@@YAPAHPAH0ABHUBufferEquivalent@@@Z
.text$mn:00005B38 ??$lower_bound@PAHHUBufferEquivalent@@@std@@YAPAHPAH0ABHUBufferEquivalent@@@Z proc near
.text$mn:00005B38                                         ; CODE XREF: std::_Buffered_merge<int *,int,int,BufferEquivalent>(int *,int *,int *,int,int,std::_Temp_iterator<int> &,BufferEquivalent)+23Cp
.text$mn:00005B38
.text$mn:00005B38 arg_0           = dword ptr  8
.text$mn:00005B38 arg_4           = dword ptr  0Ch
.text$mn:00005B38 arg_8           = dword ptr  10h
.text$mn:00005B38 arg_C           = dword ptr  14h
.text$mn:00005B38 arg_10          = dword ptr  18h
.text$mn:00005B38 arg_14          = dword ptr  1Ch
.text$mn:00005B38 arg_18          = dword ptr  20h
.text$mn:00005B38
.text$mn:00005B38                 push    ebp
.text$mn:00005B39                 mov     ebp, esp
.text$mn:00005B3B                 mov     eax, [ebp+arg_0]
.text$mn:00005B3E                 push    eax
.text$mn:00005B3F                 call    ??$_Dist_type@PAH@std@@YAPAHPAH@Z ; std::_Dist_type<int *>(int *)
.text$mn:00005B44                 add     esp, 4
.text$mn:00005B47                 push    eax
.text$mn:00005B48                 sub     esp, 10h
.text$mn:00005B4B                 mov     ecx, esp
.text$mn:00005B4D                 mov     edx, [ebp+arg_C]
.text$mn:00005B50                 mov     [ecx], edx
.text$mn:00005B52                 mov     eax, [ebp+arg_10]
.text$mn:00005B55                 mov     [ecx+4], eax
.text$mn:00005B58                 mov     edx, [ebp+arg_14]
.text$mn:00005B5B                 mov     [ecx+8], edx
.text$mn:00005B5E                 mov     eax, [ebp+arg_18]
.text$mn:00005B61                 mov     [ecx+0Ch], eax
.text$mn:00005B64                 mov     ecx, [ebp+arg_8]
.text$mn:00005B67                 push    ecx
.text$mn:00005B68                 mov     edx, [ebp+arg_4]
.text$mn:00005B6B                 push    edx
.text$mn:00005B6C                 call    ??$_Unchecked@PAH@std@@YAPAHPAH@Z ; std::_Unchecked<int *>(int *)
.text$mn:00005B71                 add     esp, 4
.text$mn:00005B74                 push    eax
.text$mn:00005B75                 mov     eax, [ebp+arg_0]
.text$mn:00005B78                 push    eax
.text$mn:00005B79                 call    ??$_Unchecked@PAH@std@@YAPAHPAH@Z ; std::_Unchecked<int *>(int *)
.text$mn:00005B7E                 add     esp, 4
.text$mn:00005B81                 push    eax
.text$mn:00005B82                 call    ??$_Lower_bound@PAHHHUBufferEquivalent@@@std@@YAPAHPAH0ABHUBufferEquivalent@@0@Z ; std::_Lower_bound<int *,int,int,BufferEquivalent>(int *,int *,int const &,BufferEquivalent,int *)
.text$mn:00005B87                 add     esp, 20h
.text$mn:00005B8A                 push    eax
.text$mn:00005B8B                 lea     ecx, [ebp+arg_0]
.text$mn:00005B8E                 push    ecx
.text$mn:00005B8F                 call    ??$_Rechecked@PAHPAH@std@@YAAAPAHAAPAHPAH@Z ; std::_Rechecked<int *,int *>(int * &,int *)
.text$mn:00005B94                 add     esp, 8
.text$mn:00005B97                 mov     eax, [eax]
.text$mn:00005B99                 pop     ebp
.text$mn:00005B9A                 retn
.text$mn:00005B9A ??$lower_bound@PAHHUBufferEquivalent@@@std@@YAPAHPAH0ABHUBufferEquivalent@@@Z endp
.text$mn:00005B9A
.text$mn:00005B9A ; ---------------------------------------------------------------------------
.text$mn:00005B9B                 align 4
.text$mn:00005B9B _text$mn        ends
.text$mn:00005B9B
.text$mn:00005B9C ; ===========================================================================
.text$mn:00005B9C
.text$mn:00005B9C ; Segment type: Pure code
.text$mn:00005B9C ; Segment permissions: Read/Execute
.text$mn:00005B9C _text$mn        segment para public 'CODE' use32
.text$mn:00005B9C                 assume cs:_text$mn
.text$mn:00005B9C                 ;org 5B9Ch
.text$mn:00005B9C ; COMDAT (pick any)
.text$mn:00005B9C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005B9C
.text$mn:00005B9C ; =============== S U B R O U T I N E =======================================
.text$mn:00005B9C
.text$mn:00005B9C ; Attributes: bp-based frame
.text$mn:00005B9C
.text$mn:00005B9C ; int && __cdecl std::move<int &>(int &)
.text$mn:00005B9C                 public ??$move@AAH@std@@YA$$QAHAAH@Z
.text$mn:00005B9C ??$move@AAH@std@@YA$$QAHAAH@Z proc near ; CODE XREF: std::_Move<int *,std::_Temp_iterator<int>>(int *,int *,std::_Temp_iterator<int>,std::_Nonscalar_ptr_iterator_tag)+50p
.text$mn:00005B9C
.text$mn:00005B9C arg_0           = dword ptr  8
.text$mn:00005B9C
.text$mn:00005B9C                 push    ebp
.text$mn:00005B9D                 mov     ebp, esp
.text$mn:00005B9F                 mov     eax, [ebp+arg_0]
.text$mn:00005BA2                 pop     ebp
.text$mn:00005BA3                 retn
.text$mn:00005BA3 ??$move@AAH@std@@YA$$QAHAAH@Z endp
.text$mn:00005BA3
.text$mn:00005BA3 _text$mn        ends
.text$mn:00005BA3
.text$mn:00005BA4 ; ===========================================================================
.text$mn:00005BA4
.text$mn:00005BA4 ; Segment type: Pure code
.text$mn:00005BA4 ; Segment permissions: Read/Execute
.text$mn:00005BA4 _text$mn        segment para public 'CODE' use32
.text$mn:00005BA4                 assume cs:_text$mn
.text$mn:00005BA4                 ;org 5BA4h
.text$mn:00005BA4 ; COMDAT (pick any)
.text$mn:00005BA4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005BA4
.text$mn:00005BA4 ; =============== S U B R O U T I N E =======================================
.text$mn:00005BA4
.text$mn:00005BA4 ; Attributes: bp-based frame
.text$mn:00005BA4
.text$mn:00005BA4 ; class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<int>>> __cdecl std::remove_if<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<int>>>, class std::binder2nd<struct std::equal_to<int>>>(class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<int>>>, class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<int>>>, class std::binder2nd<struct std::equal_to<int>>)
.text$mn:00005BA4                 public ??$remove_if@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@V?$binder2nd@U?$equal_to@H@std@@@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0V?$binder2nd@U?$equal_to@H@std@@@0@@Z
.text$mn:00005BA4 ??$remove_if@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@V?$binder2nd@U?$equal_to@H@std@@@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0V?$binder2nd@U?$equal_to@H@std@@@0@@Z proc near
.text$mn:00005BA4                                         ; CODE XREF: WindowsDlg::doClose(void)+3A3p
.text$mn:00005BA4
.text$mn:00005BA4 var_60          = byte ptr -60h
.text$mn:00005BA4 var_54          = dword ptr -54h
.text$mn:00005BA4 var_50          = dword ptr -50h
.text$mn:00005BA4 var_4C          = dword ptr -4Ch
.text$mn:00005BA4 var_48          = dword ptr -48h
.text$mn:00005BA4 var_44          = dword ptr -44h
.text$mn:00005BA4 var_40          = dword ptr -40h
.text$mn:00005BA4 var_3C          = dword ptr -3Ch
.text$mn:00005BA4 var_38          = dword ptr -38h
.text$mn:00005BA4 var_34          = dword ptr -34h
.text$mn:00005BA4 var_30          = dword ptr -30h
.text$mn:00005BA4 var_2C          = dword ptr -2Ch
.text$mn:00005BA4 var_28          = dword ptr -28h
.text$mn:00005BA4 var_24          = dword ptr -24h
.text$mn:00005BA4 var_20          = dword ptr -20h
.text$mn:00005BA4 var_1C          = dword ptr -1Ch
.text$mn:00005BA4 var_18          = dword ptr -18h
.text$mn:00005BA4 var_14          = dword ptr -14h
.text$mn:00005BA4 var_10          = dword ptr -10h
.text$mn:00005BA4 var_C           = dword ptr -0Ch
.text$mn:00005BA4 var_4           = dword ptr -4
.text$mn:00005BA4 arg_0           = dword ptr  8
.text$mn:00005BA4 arg_4           = byte ptr  0Ch
.text$mn:00005BA4 arg_10          = byte ptr  18h
.text$mn:00005BA4 arg_1C          = dword ptr  24h
.text$mn:00005BA4 arg_20          = dword ptr  28h
.text$mn:00005BA4
.text$mn:00005BA4                 push    ebp
.text$mn:00005BA5                 mov     ebp, esp
.text$mn:00005BA7                 push    0FFFFFFFFh
.text$mn:00005BA9                 push    offset __ehhandler$??$remove_if@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@V?$binder2nd@U?$equal_to@H@std@@@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0V?$binder2nd@U?$equal_to@H@std@@@0@@Z
.text$mn:00005BAE                 mov     eax, large fs:0
.text$mn:00005BB4                 push    eax
.text$mn:00005BB5                 sub     esp, 54h
.text$mn:00005BB8                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005BBD                 xor     eax, ebp
.text$mn:00005BBF                 push    eax
.text$mn:00005BC0                 lea     eax, [ebp+var_C]
.text$mn:00005BC3                 mov     large fs:0, eax
.text$mn:00005BC9                 mov     [ebp+var_10], 0
.text$mn:00005BD0                 mov     [ebp+var_4], 2
.text$mn:00005BD7                 mov     eax, [ebp+arg_20]
.text$mn:00005BDA                 push    eax
.text$mn:00005BDB                 mov     ecx, [ebp+arg_1C]
.text$mn:00005BDE                 push    ecx
.text$mn:00005BDF                 sub     esp, 0Ch
.text$mn:00005BE2                 mov     ecx, esp
.text$mn:00005BE4                 mov     [ebp+var_38], esp
.text$mn:00005BE7                 lea     edx, [ebp+arg_10]
.text$mn:00005BEA                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:00005BEB                 call    ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>> const &)
.text$mn:00005BF0                 mov     [ebp+var_14], eax
.text$mn:00005BF3                 mov     eax, [ebp+var_14]
.text$mn:00005BF6                 mov     [ebp+var_3C], eax
.text$mn:00005BF9                 mov     byte ptr [ebp+var_4], 3
.text$mn:00005BFD                 sub     esp, 0Ch
.text$mn:00005C00                 mov     ecx, esp
.text$mn:00005C02                 mov     [ebp+var_40], esp
.text$mn:00005C05                 lea     edx, [ebp+arg_4]
.text$mn:00005C08                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:00005C09                 call    ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>> const &)
.text$mn:00005C0E                 mov     [ebp+var_18], eax
.text$mn:00005C11                 mov     eax, [ebp+var_18]
.text$mn:00005C14                 mov     [ebp+var_44], eax
.text$mn:00005C17                 mov     byte ptr [ebp+var_4], 4
.text$mn:00005C1B                 lea     ecx, [ebp+var_60]
.text$mn:00005C1E                 push    ecx
.text$mn:00005C1F                 mov     byte ptr [ebp+var_4], 2
.text$mn:00005C23                 call    ??$find_if@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@V?$binder2nd@U?$equal_to@H@std@@@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0V?$binder2nd@U?$equal_to@H@std@@@0@@Z ; std::find_if<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::binder2nd<std::equal_to<int>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::binder2nd<std::equal_to<int>>)
.text$mn:00005C28                 add     esp, 24h
.text$mn:00005C2B                 mov     [ebp+var_1C], eax
.text$mn:00005C2E                 mov     edx, [ebp+var_1C]
.text$mn:00005C31                 mov     [ebp+var_20], edx
.text$mn:00005C34                 mov     byte ptr [ebp+var_4], 5
.text$mn:00005C38                 mov     eax, [ebp+var_20]
.text$mn:00005C3B                 push    eax
.text$mn:00005C3C                 lea     ecx, [ebp+arg_4]
.text$mn:00005C3F                 call    ??4?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator=(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>> const &)
.text$mn:00005C44                 mov     byte ptr [ebp+var_4], 2
.text$mn:00005C48                 lea     ecx, [ebp+var_60]
.text$mn:00005C4B                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$mn:00005C50                 lea     ecx, [ebp+arg_10]
.text$mn:00005C53                 push    ecx             ; std::_Iterator_base12 *
.text$mn:00005C54                 lea     ecx, [ebp+arg_4]
.text$mn:00005C57                 call    ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator==(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>> const &)
.text$mn:00005C5C                 movzx   edx, al
.text$mn:00005C5F                 test    edx, edx
.text$mn:00005C61                 jz      short loc_5C9D
.text$mn:00005C63                 lea     eax, [ebp+arg_4]
.text$mn:00005C66                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00005C67                 mov     ecx, [ebp+arg_0]
.text$mn:00005C6A                 call    ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>> const &)
.text$mn:00005C6F                 mov     ecx, [ebp+var_10]
.text$mn:00005C72                 or      ecx, 1
.text$mn:00005C75                 mov     [ebp+var_10], ecx
.text$mn:00005C78                 mov     byte ptr [ebp+var_4], 1
.text$mn:00005C7C                 lea     ecx, [ebp+arg_4]
.text$mn:00005C7F                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$mn:00005C84                 mov     byte ptr [ebp+var_4], 0
.text$mn:00005C88                 lea     ecx, [ebp+arg_10]
.text$mn:00005C8B                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$mn:00005C90                 mov     eax, [ebp+arg_0]
.text$mn:00005C93                 jmp     loc_5D69
.text$mn:00005C98 ; ---------------------------------------------------------------------------
.text$mn:00005C98                 jmp     loc_5D51
.text$mn:00005C9D ; ---------------------------------------------------------------------------
.text$mn:00005C9D
.text$mn:00005C9D loc_5C9D:                               ; CODE XREF: std::remove_if<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::binder2nd<std::equal_to<int>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::binder2nd<std::equal_to<int>>)+BDj
.text$mn:00005C9D                 mov     edx, [ebp+arg_20]
.text$mn:00005CA0                 push    edx
.text$mn:00005CA1                 mov     eax, [ebp+arg_1C]
.text$mn:00005CA4                 push    eax
.text$mn:00005CA5                 sub     esp, 0Ch
.text$mn:00005CA8                 mov     ecx, esp
.text$mn:00005CAA                 mov     [ebp+var_48], esp
.text$mn:00005CAD                 lea     edx, [ebp+arg_10]
.text$mn:00005CB0                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:00005CB1                 call    ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>> const &)
.text$mn:00005CB6                 mov     [ebp+var_24], eax
.text$mn:00005CB9                 mov     eax, [ebp+var_24]
.text$mn:00005CBC                 mov     [ebp+var_4C], eax
.text$mn:00005CBF                 mov     byte ptr [ebp+var_4], 6
.text$mn:00005CC3                 mov     byte ptr [ebp+var_4], 2
.text$mn:00005CC7                 call    ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@YAPAHV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<int>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>)
.text$mn:00005CCC                 add     esp, 0Ch
.text$mn:00005CCF                 mov     [ebp+var_28], eax
.text$mn:00005CD2                 mov     ecx, [ebp+var_28]
.text$mn:00005CD5                 push    ecx
.text$mn:00005CD6                 sub     esp, 0Ch
.text$mn:00005CD9                 mov     ecx, esp
.text$mn:00005CDB                 mov     [ebp+var_50], esp
.text$mn:00005CDE                 lea     edx, [ebp+arg_4]
.text$mn:00005CE1                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:00005CE2                 call    ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>> const &)
.text$mn:00005CE7                 mov     [ebp+var_2C], eax
.text$mn:00005CEA                 mov     eax, [ebp+var_2C]
.text$mn:00005CED                 mov     [ebp+var_54], eax
.text$mn:00005CF0                 mov     byte ptr [ebp+var_4], 7
.text$mn:00005CF4                 mov     byte ptr [ebp+var_4], 2
.text$mn:00005CF8                 call    ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@YAPAHV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<int>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>)
.text$mn:00005CFD                 add     esp, 0Ch
.text$mn:00005D00                 mov     [ebp+var_30], eax
.text$mn:00005D03                 mov     ecx, [ebp+var_30]
.text$mn:00005D06                 push    ecx
.text$mn:00005D07                 call    ??$_Remove_if@PAHV?$binder2nd@U?$equal_to@H@std@@@std@@@std@@YAPAHPAH0V?$binder2nd@U?$equal_to@H@std@@@0@@Z ; std::_Remove_if<int *,std::binder2nd<std::equal_to<int>>>(int *,int *,std::binder2nd<std::equal_to<int>>)
.text$mn:00005D0C                 add     esp, 10h
.text$mn:00005D0F                 mov     [ebp+var_34], eax
.text$mn:00005D12                 mov     edx, [ebp+var_34]
.text$mn:00005D15                 push    edx
.text$mn:00005D16                 lea     eax, [ebp+arg_4]
.text$mn:00005D19                 push    eax
.text$mn:00005D1A                 call    ??$_Rechecked@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@YAAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@AAV10@PAH@Z ; std::_Rechecked<std::_Vector_val<std::_Simple_types<int>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>> &,int *)
.text$mn:00005D1F                 add     esp, 8
.text$mn:00005D22                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00005D23                 mov     ecx, [ebp+arg_0]
.text$mn:00005D26                 call    ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>> const &)
.text$mn:00005D2B                 mov     ecx, [ebp+var_10]
.text$mn:00005D2E                 or      ecx, 1
.text$mn:00005D31                 mov     [ebp+var_10], ecx
.text$mn:00005D34                 mov     byte ptr [ebp+var_4], 1
.text$mn:00005D38                 lea     ecx, [ebp+arg_4]
.text$mn:00005D3B                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$mn:00005D40                 mov     byte ptr [ebp+var_4], 0
.text$mn:00005D44                 lea     ecx, [ebp+arg_10]
.text$mn:00005D47                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$mn:00005D4C                 mov     eax, [ebp+arg_0]
.text$mn:00005D4F                 jmp     short loc_5D69
.text$mn:00005D51 ; ---------------------------------------------------------------------------
.text$mn:00005D51
.text$mn:00005D51 loc_5D51:                               ; CODE XREF: std::remove_if<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::binder2nd<std::equal_to<int>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::binder2nd<std::equal_to<int>>)+F4j
.text$mn:00005D51                 mov     byte ptr [ebp+var_4], 1
.text$mn:00005D55                 lea     ecx, [ebp+arg_4]
.text$mn:00005D58                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$mn:00005D5D                 mov     byte ptr [ebp+var_4], 0
.text$mn:00005D61                 lea     ecx, [ebp+arg_10]
.text$mn:00005D64                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$mn:00005D69
.text$mn:00005D69 loc_5D69:                               ; CODE XREF: std::remove_if<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::binder2nd<std::equal_to<int>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::binder2nd<std::equal_to<int>>)+EFj
.text$mn:00005D69                                         ; std::remove_if<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::binder2nd<std::equal_to<int>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::binder2nd<std::equal_to<int>>)+1ABj
.text$mn:00005D69                 mov     ecx, [ebp+var_C]
.text$mn:00005D6C                 mov     large fs:0, ecx
.text$mn:00005D73                 pop     ecx
.text$mn:00005D74                 mov     esp, ebp
.text$mn:00005D76                 pop     ebp
.text$mn:00005D77                 retn
.text$mn:00005D77 ??$remove_if@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@V?$binder2nd@U?$equal_to@H@std@@@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0V?$binder2nd@U?$equal_to@H@std@@@0@@Z endp
.text$mn:00005D77
.text$mn:00005D77 _text$mn        ends
.text$mn:00005D77
.text$x:00005D78 ; ===========================================================================
.text$x:00005D78
.text$x:00005D78 ; Segment type: Pure code
.text$x:00005D78 ; Segment permissions: Read/Execute
.text$x:00005D78 _text$x         segment para public 'CODE' use32
.text$x:00005D78                 assume cs:_text$x
.text$x:00005D78                 ;org 5D78h
.text$x:00005D78 ; COMDAT (pick associative to section at 5BA4)
.text$x:00005D78                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00005D78
.text$x:00005D78 ; =============== S U B R O U T I N E =======================================
.text$x:00005D78
.text$x:00005D78
.text$x:00005D78 __unwindfunclet$??$remove_if@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@V?$binder2nd@U?$equal_to@H@std@@@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0V?$binder2nd@U?$equal_to@H@std@@@0@@Z$0 proc near
.text$x:00005D78                                         ; DATA XREF: .xdata$x:0000D2B4o
.text$x:00005D78                 lea     ecx, [ebp+18h]
.text$x:00005D7B                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$x:00005D7B __unwindfunclet$??$remove_if@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@V?$binder2nd@U?$equal_to@H@std@@@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0V?$binder2nd@U?$equal_to@H@std@@@0@@Z$0 endp
.text$x:00005D7B
.text$x:00005D80
.text$x:00005D80 ; =============== S U B R O U T I N E =======================================
.text$x:00005D80
.text$x:00005D80
.text$x:00005D80 __unwindfunclet$??$remove_if@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@V?$binder2nd@U?$equal_to@H@std@@@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0V?$binder2nd@U?$equal_to@H@std@@@0@@Z$1 proc near
.text$x:00005D80                                         ; DATA XREF: .xdata$x:0000D2BCo
.text$x:00005D80                 lea     ecx, [ebp+0Ch]
.text$x:00005D83                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$x:00005D83 __unwindfunclet$??$remove_if@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@V?$binder2nd@U?$equal_to@H@std@@@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0V?$binder2nd@U?$equal_to@H@std@@@0@@Z$1 endp
.text$x:00005D83
.text$x:00005D88
.text$x:00005D88 ; =============== S U B R O U T I N E =======================================
.text$x:00005D88
.text$x:00005D88
.text$x:00005D88 __unwindfunclet$??$remove_if@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@V?$binder2nd@U?$equal_to@H@std@@@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0V?$binder2nd@U?$equal_to@H@std@@@0@@Z$2 proc near
.text$x:00005D88                                         ; DATA XREF: .xdata$x:0000D2C4o
.text$x:00005D88                 mov     ecx, [ebp-38h]
.text$x:00005D8B                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$x:00005D8B __unwindfunclet$??$remove_if@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@V?$binder2nd@U?$equal_to@H@std@@@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0V?$binder2nd@U?$equal_to@H@std@@@0@@Z$2 endp
.text$x:00005D8B
.text$x:00005D90
.text$x:00005D90 ; =============== S U B R O U T I N E =======================================
.text$x:00005D90
.text$x:00005D90
.text$x:00005D90 __unwindfunclet$??$remove_if@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@V?$binder2nd@U?$equal_to@H@std@@@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0V?$binder2nd@U?$equal_to@H@std@@@0@@Z$3 proc near
.text$x:00005D90                                         ; DATA XREF: .xdata$x:0000D2CCo
.text$x:00005D90                 mov     ecx, [ebp-40h]
.text$x:00005D93                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$x:00005D93 __unwindfunclet$??$remove_if@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@V?$binder2nd@U?$equal_to@H@std@@@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0V?$binder2nd@U?$equal_to@H@std@@@0@@Z$3 endp
.text$x:00005D93
.text$x:00005D98
.text$x:00005D98 ; =============== S U B R O U T I N E =======================================
.text$x:00005D98
.text$x:00005D98
.text$x:00005D98 __unwindfunclet$??$remove_if@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@V?$binder2nd@U?$equal_to@H@std@@@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0V?$binder2nd@U?$equal_to@H@std@@@0@@Z$4 proc near
.text$x:00005D98                                         ; DATA XREF: .xdata$x:0000D2D4o
.text$x:00005D98                 lea     ecx, [ebp-60h]
.text$x:00005D9B                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$x:00005D9B __unwindfunclet$??$remove_if@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@V?$binder2nd@U?$equal_to@H@std@@@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0V?$binder2nd@U?$equal_to@H@std@@@0@@Z$4 endp
.text$x:00005D9B
.text$x:00005DA0
.text$x:00005DA0 ; =============== S U B R O U T I N E =======================================
.text$x:00005DA0
.text$x:00005DA0
.text$x:00005DA0 __unwindfunclet$??$remove_if@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@V?$binder2nd@U?$equal_to@H@std@@@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0V?$binder2nd@U?$equal_to@H@std@@@0@@Z$5 proc near
.text$x:00005DA0                                         ; DATA XREF: .xdata$x:0000D2ACo
.text$x:00005DA0                 mov     eax, [ebp-10h]
.text$x:00005DA3                 and     eax, 1
.text$x:00005DA6                 jz      $LN11
.text$x:00005DAC                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:00005DB0                 mov     ecx, [ebp+8]
.text$x:00005DB3                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$x:00005DB8 ; ---------------------------------------------------------------------------
.text$x:00005DB8
.text$x:00005DB8 $LN11:                                  ; CODE XREF: __unwindfunclet$??$remove_if@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@V?$binder2nd@U?$equal_to@H@std@@@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0V?$binder2nd@U?$equal_to@H@std@@@0@@Z$5+6j
.text$x:00005DB8                 retn
.text$x:00005DB8 __unwindfunclet$??$remove_if@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@V?$binder2nd@U?$equal_to@H@std@@@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0V?$binder2nd@U?$equal_to@H@std@@@0@@Z$5 endp
.text$x:00005DB8
.text$x:00005DB9
.text$x:00005DB9 ; =============== S U B R O U T I N E =======================================
.text$x:00005DB9
.text$x:00005DB9
.text$x:00005DB9 __unwindfunclet$??$remove_if@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@V?$binder2nd@U?$equal_to@H@std@@@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0V?$binder2nd@U?$equal_to@H@std@@@0@@Z$6 proc near
.text$x:00005DB9                                         ; DATA XREF: .xdata$x:0000D2DCo
.text$x:00005DB9                 mov     ecx, [ebp-48h]
.text$x:00005DBC                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$x:00005DBC __unwindfunclet$??$remove_if@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@V?$binder2nd@U?$equal_to@H@std@@@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0V?$binder2nd@U?$equal_to@H@std@@@0@@Z$6 endp
.text$x:00005DBC
.text$x:00005DC1
.text$x:00005DC1 ; =============== S U B R O U T I N E =======================================
.text$x:00005DC1
.text$x:00005DC1
.text$x:00005DC1 __unwindfunclet$??$remove_if@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@V?$binder2nd@U?$equal_to@H@std@@@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0V?$binder2nd@U?$equal_to@H@std@@@0@@Z$7 proc near
.text$x:00005DC1                                         ; DATA XREF: .xdata$x:0000D2E4o
.text$x:00005DC1                 mov     ecx, [ebp-50h]
.text$x:00005DC4                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$x:00005DC4 __unwindfunclet$??$remove_if@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@V?$binder2nd@U?$equal_to@H@std@@@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0V?$binder2nd@U?$equal_to@H@std@@@0@@Z$7 endp
.text$x:00005DC4
.text$x:00005DC9
.text$x:00005DC9 ; =============== S U B R O U T I N E =======================================
.text$x:00005DC9
.text$x:00005DC9
.text$x:00005DC9 __ehhandler$??$remove_if@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@V?$binder2nd@U?$equal_to@H@std@@@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0V?$binder2nd@U?$equal_to@H@std@@@0@@Z proc near
.text$x:00005DC9                                         ; DATA XREF: std::remove_if<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::binder2nd<std::equal_to<int>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::binder2nd<std::equal_to<int>>)+5o
.text$x:00005DC9
.text$x:00005DC9 arg_4           = dword ptr  8
.text$x:00005DC9
.text$x:00005DC9                 mov     edx, [esp+arg_4]
.text$x:00005DCD                 lea     eax, [edx+0Ch]
.text$x:00005DD0                 mov     ecx, [edx-58h]
.text$x:00005DD3                 xor     ecx, eax
.text$x:00005DD5                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005DDA                 mov     eax, offset __ehfuncinfo$??$remove_if@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@V?$binder2nd@U?$equal_to@H@std@@@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0V?$binder2nd@U?$equal_to@H@std@@@0@@Z
.text$x:00005DDF                 jmp     ___CxxFrameHandler3
.text$x:00005DDF __ehhandler$??$remove_if@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@V?$binder2nd@U?$equal_to@H@std@@@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0V?$binder2nd@U?$equal_to@H@std@@@0@@Z endp
.text$x:00005DDF
.text$x:00005DDF _text$x         ends
.text$x:00005DDF
.text$mn:00005DE4 ; ===========================================================================
.text$mn:00005DE4
.text$mn:00005DE4 ; Segment type: Pure code
.text$mn:00005DE4 ; Segment permissions: Read/Execute
.text$mn:00005DE4 _text$mn        segment para public 'CODE' use32
.text$mn:00005DE4                 assume cs:_text$mn
.text$mn:00005DE4                 ;org 5DE4h
.text$mn:00005DE4 ; COMDAT (pick any)
.text$mn:00005DE4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005DE4
.text$mn:00005DE4 ; =============== S U B R O U T I N E =======================================
.text$mn:00005DE4
.text$mn:00005DE4 ; Attributes: bp-based frame
.text$mn:00005DE4
.text$mn:00005DE4 ; int __cdecl std::return_temporary_buffer<int>(void *)
.text$mn:00005DE4                 public ??$return_temporary_buffer@H@std@@YAXPAH@Z
.text$mn:00005DE4 ??$return_temporary_buffer@H@std@@YAXPAH@Z proc near
.text$mn:00005DE4                                         ; CODE XREF: std::_Temp_iterator<int>::~_Temp_iterator<int>(void)+43p
.text$mn:00005DE4
.text$mn:00005DE4 arg_0           = dword ptr  8
.text$mn:00005DE4
.text$mn:00005DE4                 push    ebp
.text$mn:00005DE5                 mov     ebp, esp
.text$mn:00005DE7                 mov     eax, [ebp+arg_0]
.text$mn:00005DEA                 push    eax             ; void *
.text$mn:00005DEB                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00005DF0                 add     esp, 4
.text$mn:00005DF3                 pop     ebp
.text$mn:00005DF4                 retn
.text$mn:00005DF4 ??$return_temporary_buffer@H@std@@YAXPAH@Z endp
.text$mn:00005DF4
.text$mn:00005DF4 ; ---------------------------------------------------------------------------
.text$mn:00005DF5                 align 4
.text$mn:00005DF5 _text$mn        ends
.text$mn:00005DF5
.text$mn:00005DF8 ; ===========================================================================
.text$mn:00005DF8
.text$mn:00005DF8 ; Segment type: Pure code
.text$mn:00005DF8 ; Segment permissions: Read/Execute
.text$mn:00005DF8 _text$mn        segment para public 'CODE' use32
.text$mn:00005DF8                 assume cs:_text$mn
.text$mn:00005DF8                 ;org 5DF8h
.text$mn:00005DF8 ; COMDAT (pick any)
.text$mn:00005DF8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005DF8
.text$mn:00005DF8 ; =============== S U B R O U T I N E =======================================
.text$mn:00005DF8
.text$mn:00005DF8 ; Attributes: bp-based frame
.text$mn:00005DF8
.text$mn:00005DF8 ; int * __cdecl std::rotate<int *>(int *, int *, int *)
.text$mn:00005DF8                 public ??$rotate@PAH@std@@YAPAHPAH00@Z
.text$mn:00005DF8 ??$rotate@PAH@std@@YAPAHPAH00@Z proc near
.text$mn:00005DF8                                         ; CODE XREF: std::_Buffered_rotate<int *,int,int>(int *,int *,int *,int,int,std::_Temp_iterator<int> &)+192p
.text$mn:00005DF8
.text$mn:00005DF8 var_1           = byte ptr -1
.text$mn:00005DF8 arg_0           = dword ptr  8
.text$mn:00005DF8 arg_4           = dword ptr  0Ch
.text$mn:00005DF8 arg_8           = dword ptr  10h
.text$mn:00005DF8
.text$mn:00005DF8                 push    ebp
.text$mn:00005DF9                 mov     ebp, esp
.text$mn:00005DFB                 push    ecx
.text$mn:00005DFC                 push    0CA9h           ; unsigned int
.text$mn:00005E01                 push    offset ??_C@_1JA@EADLBAJ@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00005E06                 mov     eax, [ebp+arg_4]
.text$mn:00005E09                 push    eax             ; int
.text$mn:00005E0A                 mov     ecx, [ebp+arg_0]
.text$mn:00005E0D                 push    ecx             ; int
.text$mn:00005E0E                 call    ??$_Debug_range@PAH@std@@YAXPAH0PB_WI@Z ; std::_Debug_range<int *>(int *,int *,wchar_t const *,uint)
.text$mn:00005E13                 add     esp, 10h
.text$mn:00005E16                 push    0CAAh           ; unsigned int
.text$mn:00005E1B                 push    offset ??_C@_1JA@EADLBAJ@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00005E20                 mov     edx, [ebp+arg_8]
.text$mn:00005E23                 push    edx             ; int
.text$mn:00005E24                 mov     eax, [ebp+arg_4]
.text$mn:00005E27                 push    eax             ; int
.text$mn:00005E28                 call    ??$_Debug_range@PAH@std@@YAXPAH0PB_WI@Z ; std::_Debug_range<int *>(int *,int *,wchar_t const *,uint)
.text$mn:00005E2D                 add     esp, 10h
.text$mn:00005E30                 mov     ecx, [ebp+arg_0]
.text$mn:00005E33                 cmp     ecx, [ebp+arg_4]
.text$mn:00005E36                 jz      short loc_5E85
.text$mn:00005E38                 mov     edx, [ebp+arg_4]
.text$mn:00005E3B                 cmp     edx, [ebp+arg_8]
.text$mn:00005E3E                 jz      short loc_5E85
.text$mn:00005E40                 lea     eax, [ebp+arg_0]
.text$mn:00005E43                 push    eax
.text$mn:00005E44                 lea     ecx, [ebp+var_1]
.text$mn:00005E47                 push    ecx
.text$mn:00005E48                 call    ??$_Iter_cat@PAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH@Z ; std::_Iter_cat<int *>(int * const &)
.text$mn:00005E4D                 add     esp, 8
.text$mn:00005E50                 mov     dl, [eax]
.text$mn:00005E52                 movzx   eax, dl
.text$mn:00005E55                 push    eax
.text$mn:00005E56                 mov     ecx, [ebp+arg_8]
.text$mn:00005E59                 push    ecx
.text$mn:00005E5A                 call    ??$_Unchecked@PAH@std@@YAPAHPAH@Z ; std::_Unchecked<int *>(int *)
.text$mn:00005E5F                 add     esp, 4
.text$mn:00005E62                 push    eax
.text$mn:00005E63                 mov     edx, [ebp+arg_4]
.text$mn:00005E66                 push    edx
.text$mn:00005E67                 call    ??$_Unchecked@PAH@std@@YAPAHPAH@Z ; std::_Unchecked<int *>(int *)
.text$mn:00005E6C                 add     esp, 4
.text$mn:00005E6F                 push    eax
.text$mn:00005E70                 mov     eax, [ebp+arg_0]
.text$mn:00005E73                 push    eax
.text$mn:00005E74                 call    ??$_Unchecked@PAH@std@@YAPAHPAH@Z ; std::_Unchecked<int *>(int *)
.text$mn:00005E79                 add     esp, 4
.text$mn:00005E7C                 push    eax
.text$mn:00005E7D                 call    ??$_Rotate@PAH@std@@YAXPAH00Urandom_access_iterator_tag@0@@Z ; std::_Rotate<int *>(int *,int *,int *,std::random_access_iterator_tag)
.text$mn:00005E82                 add     esp, 10h
.text$mn:00005E85
.text$mn:00005E85 loc_5E85:                               ; CODE XREF: std::rotate<int *>(int *,int *,int *)+3Ej
.text$mn:00005E85                                         ; std::rotate<int *>(int *,int *,int *)+46j
.text$mn:00005E85                 mov     ecx, [ebp+arg_8]
.text$mn:00005E88                 push    ecx
.text$mn:00005E89                 mov     edx, [ebp+arg_4]
.text$mn:00005E8C                 push    edx
.text$mn:00005E8D                 call    ??$distance@PAH@std@@YAHPAH0@Z ; std::distance<int *>(int *,int *)
.text$mn:00005E92                 add     esp, 8
.text$mn:00005E95                 push    eax
.text$mn:00005E96                 lea     eax, [ebp+arg_0]
.text$mn:00005E99                 push    eax
.text$mn:00005E9A                 call    ??$advance@PAHH@std@@YAXAAPAHH@Z ; std::advance<int *,int>(int * &,int)
.text$mn:00005E9F                 add     esp, 8
.text$mn:00005EA2                 mov     eax, [ebp+arg_0]
.text$mn:00005EA5                 mov     esp, ebp
.text$mn:00005EA7                 pop     ebp
.text$mn:00005EA8                 retn
.text$mn:00005EA8 ??$rotate@PAH@std@@YAPAHPAH00@Z endp
.text$mn:00005EA8
.text$mn:00005EA8 ; ---------------------------------------------------------------------------
.text$mn:00005EA9                 align 4
.text$mn:00005EA9 _text$mn        ends
.text$mn:00005EA9
.text$mn:00005EAC ; ===========================================================================
.text$mn:00005EAC
.text$mn:00005EAC ; Segment type: Pure code
.text$mn:00005EAC ; Segment permissions: Read/Execute
.text$mn:00005EAC _text$mn        segment para public 'CODE' use32
.text$mn:00005EAC                 assume cs:_text$mn
.text$mn:00005EAC                 ;org 5EACh
.text$mn:00005EAC ; COMDAT (pick any)
.text$mn:00005EAC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005EAC
.text$mn:00005EAC ; =============== S U B R O U T I N E =======================================
.text$mn:00005EAC
.text$mn:00005EAC ; Attributes: bp-based frame
.text$mn:00005EAC
.text$mn:00005EAC ; void __cdecl std::stable_sort<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<int>>>, struct BufferEquivalent>(class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<int>>>, class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<int>>>, struct BufferEquivalent)
.text$mn:00005EAC                 public ??$stable_sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@UBufferEquivalent@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0UBufferEquivalent@@@Z
.text$mn:00005EAC ??$stable_sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@UBufferEquivalent@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0UBufferEquivalent@@@Z proc near
.text$mn:00005EAC                                         ; CODE XREF: WindowsDlg::run_dlgProc(uint,uint,long)+532p
.text$mn:00005EAC
.text$mn:00005EAC var_64          = dword ptr -64h
.text$mn:00005EAC var_60          = dword ptr -60h
.text$mn:00005EAC var_5C          = dword ptr -5Ch
.text$mn:00005EAC var_58          = dword ptr -58h
.text$mn:00005EAC var_54          = dword ptr -54h
.text$mn:00005EAC var_50          = dword ptr -50h
.text$mn:00005EAC var_4C          = dword ptr -4Ch
.text$mn:00005EAC var_48          = dword ptr -48h
.text$mn:00005EAC var_44          = dword ptr -44h
.text$mn:00005EAC var_40          = dword ptr -40h
.text$mn:00005EAC var_3C          = dword ptr -3Ch
.text$mn:00005EAC var_38          = dword ptr -38h
.text$mn:00005EAC Src             = dword ptr -34h
.text$mn:00005EAC var_30          = dword ptr -30h
.text$mn:00005EAC var_2C          = dword ptr -2Ch
.text$mn:00005EAC var_28          = dword ptr -28h
.text$mn:00005EAC var_24          = dword ptr -24h
.text$mn:00005EAC var_20          = dword ptr -20h
.text$mn:00005EAC var_1C          = dword ptr -1Ch
.text$mn:00005EAC var_18          = dword ptr -18h
.text$mn:00005EAC var_14          = dword ptr -14h
.text$mn:00005EAC var_10          = dword ptr -10h
.text$mn:00005EAC var_C           = dword ptr -0Ch
.text$mn:00005EAC var_4           = dword ptr -4
.text$mn:00005EAC arg_0           = byte ptr  8
.text$mn:00005EAC arg_C           = dword ptr  14h
.text$mn:00005EAC arg_18          = dword ptr  20h
.text$mn:00005EAC arg_1C          = dword ptr  24h
.text$mn:00005EAC arg_20          = dword ptr  28h
.text$mn:00005EAC arg_24          = dword ptr  2Ch
.text$mn:00005EAC
.text$mn:00005EAC                 push    ebp
.text$mn:00005EAD                 mov     ebp, esp
.text$mn:00005EAF                 push    0FFFFFFFFh
.text$mn:00005EB1                 push    offset __ehhandler$??$stable_sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@UBufferEquivalent@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0UBufferEquivalent@@@Z
.text$mn:00005EB6                 mov     eax, large fs:0
.text$mn:00005EBC                 push    eax
.text$mn:00005EBD                 sub     esp, 58h
.text$mn:00005EC0                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005EC5                 xor     eax, ebp
.text$mn:00005EC7                 push    eax
.text$mn:00005EC8                 lea     eax, [ebp+var_C]
.text$mn:00005ECB                 mov     large fs:0, eax
.text$mn:00005ED1                 mov     [ebp+var_4], 1
.text$mn:00005ED8                 push    0CC8h           ; unsigned int
.text$mn:00005EDD                 push    offset ??_C@_1JC@HALMDPKM@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00005EE2                 sub     esp, 0Ch
.text$mn:00005EE5                 mov     ecx, esp
.text$mn:00005EE7                 mov     [ebp+var_38], esp
.text$mn:00005EEA                 lea     eax, [ebp+arg_C]
.text$mn:00005EED                 push    eax             ; int
.text$mn:00005EEE                 call    ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>> const &)
.text$mn:00005EF3                 mov     [ebp+var_10], eax
.text$mn:00005EF6                 mov     ecx, [ebp+var_10]
.text$mn:00005EF9                 mov     [ebp+var_3C], ecx
.text$mn:00005EFC                 mov     byte ptr [ebp+var_4], 2
.text$mn:00005F00                 sub     esp, 0Ch
.text$mn:00005F03                 mov     ecx, esp
.text$mn:00005F05                 mov     [ebp+var_40], esp
.text$mn:00005F08                 lea     edx, [ebp+arg_0]
.text$mn:00005F0B                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:00005F0C                 call    ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>> const &)
.text$mn:00005F11                 mov     [ebp+var_14], eax
.text$mn:00005F14                 mov     eax, [ebp+var_14]
.text$mn:00005F17                 mov     [ebp+var_44], eax
.text$mn:00005F1A                 mov     byte ptr [ebp+var_4], 3
.text$mn:00005F1E                 mov     byte ptr [ebp+var_4], 1
.text$mn:00005F22                 call    ??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0PB_WI@Z ; std::_Debug_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,wchar_t const *,uint)
.text$mn:00005F27                 add     esp, 20h
.text$mn:00005F2A                 push    0CC9h
.text$mn:00005F2F                 push    offset ??_C@_1JC@HALMDPKM@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00005F34                 lea     ecx, [ebp+arg_18]
.text$mn:00005F37                 push    ecx             ; int
.text$mn:00005F38                 call    ??$_Debug_pointer@UBufferEquivalent@@@std@@YAXAAUBufferEquivalent@@PB_WI@Z ; std::_Debug_pointer<BufferEquivalent>(BufferEquivalent &,wchar_t const *,uint)
.text$mn:00005F3D                 add     esp, 0Ch
.text$mn:00005F40                 lea     edx, [ebp+arg_C]
.text$mn:00005F43                 push    edx             ; int
.text$mn:00005F44                 lea     ecx, [ebp+arg_0]
.text$mn:00005F47                 call    ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator!=(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>> const &)
.text$mn:00005F4C                 movzx   eax, al
.text$mn:00005F4F                 test    eax, eax
.text$mn:00005F51                 jz      loc_603F
.text$mn:00005F57                 sub     esp, 10h
.text$mn:00005F5A                 mov     ecx, esp
.text$mn:00005F5C                 mov     edx, [ebp+arg_18]
.text$mn:00005F5F                 mov     [ecx], edx
.text$mn:00005F61                 mov     eax, [ebp+arg_1C]
.text$mn:00005F64                 mov     [ecx+4], eax
.text$mn:00005F67                 mov     edx, [ebp+arg_20]
.text$mn:00005F6A                 mov     [ecx+8], edx
.text$mn:00005F6D                 mov     eax, [ebp+arg_24]
.text$mn:00005F70                 mov     [ecx+0Ch], eax
.text$mn:00005F73                 sub     esp, 0Ch
.text$mn:00005F76                 mov     ecx, esp
.text$mn:00005F78                 mov     [ebp+var_48], esp
.text$mn:00005F7B                 lea     edx, [ebp+arg_0]
.text$mn:00005F7E                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:00005F7F                 call    ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>> const &)
.text$mn:00005F84                 mov     [ebp+var_18], eax
.text$mn:00005F87                 mov     eax, [ebp+var_18]
.text$mn:00005F8A                 mov     [ebp+var_4C], eax
.text$mn:00005F8D                 mov     byte ptr [ebp+var_4], 4
.text$mn:00005F91                 mov     byte ptr [ebp+var_4], 1
.text$mn:00005F95                 call    ??$_Val_type@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAPAHV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@@Z ; std::_Val_type<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>)
.text$mn:00005F9A                 add     esp, 0Ch
.text$mn:00005F9D                 mov     [ebp+var_1C], eax
.text$mn:00005FA0                 mov     ecx, [ebp+var_1C]
.text$mn:00005FA3                 push    ecx             ; int
.text$mn:00005FA4                 sub     esp, 0Ch
.text$mn:00005FA7                 mov     ecx, esp
.text$mn:00005FA9                 mov     [ebp+var_50], esp
.text$mn:00005FAC                 lea     edx, [ebp+arg_0]
.text$mn:00005FAF                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:00005FB0                 call    ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>> const &)
.text$mn:00005FB5                 mov     [ebp+var_20], eax
.text$mn:00005FB8                 mov     eax, [ebp+var_20]
.text$mn:00005FBB                 mov     [ebp+var_54], eax
.text$mn:00005FBE                 mov     byte ptr [ebp+var_4], 5
.text$mn:00005FC2                 mov     byte ptr [ebp+var_4], 1
.text$mn:00005FC6                 call    ??$_Dist_type@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAPAHV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@@Z ; std::_Dist_type<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>)
.text$mn:00005FCB                 add     esp, 0Ch
.text$mn:00005FCE                 mov     [ebp+var_24], eax
.text$mn:00005FD1                 mov     ecx, [ebp+var_24]
.text$mn:00005FD4                 push    ecx             ; int
.text$mn:00005FD5                 sub     esp, 0Ch
.text$mn:00005FD8                 mov     ecx, esp
.text$mn:00005FDA                 mov     [ebp+var_58], esp
.text$mn:00005FDD                 lea     edx, [ebp+arg_C]
.text$mn:00005FE0                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:00005FE1                 call    ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>> const &)
.text$mn:00005FE6                 mov     [ebp+var_28], eax
.text$mn:00005FE9                 mov     eax, [ebp+var_28]
.text$mn:00005FEC                 mov     [ebp+var_5C], eax
.text$mn:00005FEF                 mov     byte ptr [ebp+var_4], 6
.text$mn:00005FF3                 mov     byte ptr [ebp+var_4], 1
.text$mn:00005FF7                 call    ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@YAPAHV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<int>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>)
.text$mn:00005FFC                 add     esp, 0Ch
.text$mn:00005FFF                 mov     [ebp+var_2C], eax
.text$mn:00006002                 mov     ecx, [ebp+var_2C]
.text$mn:00006005                 push    ecx             ; int
.text$mn:00006006                 sub     esp, 0Ch
.text$mn:00006009                 mov     ecx, esp
.text$mn:0000600B                 mov     [ebp+var_60], esp
.text$mn:0000600E                 lea     edx, [ebp+arg_0]
.text$mn:00006011                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:00006012                 call    ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>> const &)
.text$mn:00006017                 mov     [ebp+var_30], eax
.text$mn:0000601A                 mov     eax, [ebp+var_30]
.text$mn:0000601D                 mov     [ebp+var_64], eax
.text$mn:00006020                 mov     byte ptr [ebp+var_4], 7
.text$mn:00006024                 mov     byte ptr [ebp+var_4], 1
.text$mn:00006028                 call    ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@YAPAHV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<int>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>)
.text$mn:0000602D                 add     esp, 0Ch
.text$mn:00006030                 mov     [ebp+Src], eax
.text$mn:00006033                 mov     ecx, [ebp+Src]
.text$mn:00006036                 push    ecx             ; Src
.text$mn:00006037                 call    ??$_Stable_sort@PAHHHUBufferEquivalent@@@std@@YAXPAH000UBufferEquivalent@@@Z ; std::_Stable_sort<int *,int,int,BufferEquivalent>(int *,int *,int *,int *,BufferEquivalent)
.text$mn:0000603C                 add     esp, 20h
.text$mn:0000603F
.text$mn:0000603F loc_603F:                               ; CODE XREF: std::stable_sort<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,BufferEquivalent>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,BufferEquivalent)+A5j
.text$mn:0000603F                 mov     byte ptr [ebp+var_4], 0
.text$mn:00006043                 lea     ecx, [ebp+arg_0]
.text$mn:00006046                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$mn:0000604B                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006052                 lea     ecx, [ebp+arg_C]
.text$mn:00006055                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$mn:0000605A                 mov     ecx, [ebp+var_C]
.text$mn:0000605D                 mov     large fs:0, ecx
.text$mn:00006064                 pop     ecx
.text$mn:00006065                 mov     esp, ebp
.text$mn:00006067                 pop     ebp
.text$mn:00006068                 retn
.text$mn:00006068 ??$stable_sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@UBufferEquivalent@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0UBufferEquivalent@@@Z endp
.text$mn:00006068
.text$mn:00006068 ; ---------------------------------------------------------------------------
.text$mn:00006069                 align 4
.text$mn:00006069 _text$mn        ends
.text$mn:00006069
.text$x:0000606C ; ===========================================================================
.text$x:0000606C
.text$x:0000606C ; Segment type: Pure code
.text$x:0000606C ; Segment permissions: Read/Execute
.text$x:0000606C _text$x         segment para public 'CODE' use32
.text$x:0000606C                 assume cs:_text$x
.text$x:0000606C                 ;org 606Ch
.text$x:0000606C ; COMDAT (pick associative to section at 5EAC)
.text$x:0000606C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000606C
.text$x:0000606C ; =============== S U B R O U T I N E =======================================
.text$x:0000606C
.text$x:0000606C
.text$x:0000606C __unwindfunclet$??$stable_sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@UBufferEquivalent@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0UBufferEquivalent@@@Z$0 proc near
.text$x:0000606C                                         ; DATA XREF: .xdata$x:0000D248o
.text$x:0000606C                 lea     ecx, [ebp+14h]
.text$x:0000606F                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$x:0000606F __unwindfunclet$??$stable_sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@UBufferEquivalent@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0UBufferEquivalent@@@Z$0 endp
.text$x:0000606F
.text$x:00006074
.text$x:00006074 ; =============== S U B R O U T I N E =======================================
.text$x:00006074
.text$x:00006074
.text$x:00006074 __unwindfunclet$??$stable_sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@UBufferEquivalent@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0UBufferEquivalent@@@Z$1 proc near
.text$x:00006074                                         ; DATA XREF: .xdata$x:0000D250o
.text$x:00006074                 lea     ecx, [ebp+8]
.text$x:00006077                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$x:00006077 __unwindfunclet$??$stable_sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@UBufferEquivalent@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0UBufferEquivalent@@@Z$1 endp
.text$x:00006077
.text$x:0000607C
.text$x:0000607C ; =============== S U B R O U T I N E =======================================
.text$x:0000607C
.text$x:0000607C
.text$x:0000607C __unwindfunclet$??$stable_sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@UBufferEquivalent@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0UBufferEquivalent@@@Z$2 proc near
.text$x:0000607C                                         ; DATA XREF: .xdata$x:0000D258o
.text$x:0000607C                 mov     ecx, [ebp-38h]
.text$x:0000607F                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$x:0000607F __unwindfunclet$??$stable_sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@UBufferEquivalent@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0UBufferEquivalent@@@Z$2 endp
.text$x:0000607F
.text$x:00006084
.text$x:00006084 ; =============== S U B R O U T I N E =======================================
.text$x:00006084
.text$x:00006084
.text$x:00006084 __unwindfunclet$??$stable_sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@UBufferEquivalent@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0UBufferEquivalent@@@Z$3 proc near
.text$x:00006084                                         ; DATA XREF: .xdata$x:0000D260o
.text$x:00006084                 mov     ecx, [ebp-40h]
.text$x:00006087                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$x:00006087 __unwindfunclet$??$stable_sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@UBufferEquivalent@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0UBufferEquivalent@@@Z$3 endp
.text$x:00006087
.text$x:0000608C
.text$x:0000608C ; =============== S U B R O U T I N E =======================================
.text$x:0000608C
.text$x:0000608C
.text$x:0000608C __unwindfunclet$??$stable_sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@UBufferEquivalent@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0UBufferEquivalent@@@Z$4 proc near
.text$x:0000608C                                         ; DATA XREF: .xdata$x:0000D268o
.text$x:0000608C                 mov     ecx, [ebp-48h]
.text$x:0000608F                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$x:0000608F __unwindfunclet$??$stable_sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@UBufferEquivalent@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0UBufferEquivalent@@@Z$4 endp
.text$x:0000608F
.text$x:00006094
.text$x:00006094 ; =============== S U B R O U T I N E =======================================
.text$x:00006094
.text$x:00006094
.text$x:00006094 __unwindfunclet$??$stable_sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@UBufferEquivalent@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0UBufferEquivalent@@@Z$5 proc near
.text$x:00006094                                         ; DATA XREF: .xdata$x:0000D270o
.text$x:00006094                 mov     ecx, [ebp-50h]
.text$x:00006097                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$x:00006097 __unwindfunclet$??$stable_sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@UBufferEquivalent@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0UBufferEquivalent@@@Z$5 endp
.text$x:00006097
.text$x:0000609C
.text$x:0000609C ; =============== S U B R O U T I N E =======================================
.text$x:0000609C
.text$x:0000609C
.text$x:0000609C __unwindfunclet$??$stable_sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@UBufferEquivalent@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0UBufferEquivalent@@@Z$6 proc near
.text$x:0000609C                                         ; DATA XREF: .xdata$x:0000D278o
.text$x:0000609C                 mov     ecx, [ebp-58h]
.text$x:0000609F                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$x:0000609F __unwindfunclet$??$stable_sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@UBufferEquivalent@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0UBufferEquivalent@@@Z$6 endp
.text$x:0000609F
.text$x:000060A4
.text$x:000060A4 ; =============== S U B R O U T I N E =======================================
.text$x:000060A4
.text$x:000060A4
.text$x:000060A4 __unwindfunclet$??$stable_sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@UBufferEquivalent@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0UBufferEquivalent@@@Z$7 proc near
.text$x:000060A4                                         ; DATA XREF: .xdata$x:0000D280o
.text$x:000060A4                 mov     ecx, [ebp-60h]
.text$x:000060A7                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$x:000060A7 __unwindfunclet$??$stable_sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@UBufferEquivalent@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0UBufferEquivalent@@@Z$7 endp
.text$x:000060A7
.text$x:000060AC
.text$x:000060AC ; =============== S U B R O U T I N E =======================================
.text$x:000060AC
.text$x:000060AC
.text$x:000060AC __ehhandler$??$stable_sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@UBufferEquivalent@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0UBufferEquivalent@@@Z proc near
.text$x:000060AC                                         ; DATA XREF: std::stable_sort<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,BufferEquivalent>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,BufferEquivalent)+5o
.text$x:000060AC
.text$x:000060AC arg_4           = dword ptr  8
.text$x:000060AC
.text$x:000060AC                 mov     edx, [esp+arg_4]
.text$x:000060B0                 lea     eax, [edx+0Ch]
.text$x:000060B3                 mov     ecx, [edx-5Ch]
.text$x:000060B6                 xor     ecx, eax
.text$x:000060B8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000060BD                 mov     eax, offset __ehfuncinfo$??$stable_sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@UBufferEquivalent@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0UBufferEquivalent@@@Z
.text$x:000060C2                 jmp     ___CxxFrameHandler3
.text$x:000060C2 __ehhandler$??$stable_sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@UBufferEquivalent@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0UBufferEquivalent@@@Z endp
.text$x:000060C2
.text$x:000060C2 ; ---------------------------------------------------------------------------
.text$x:000060C7                 align 4
.text$x:000060C7 _text$x         ends
.text$x:000060C7
.text$mn:000060C8 ; ===========================================================================
.text$mn:000060C8
.text$mn:000060C8 ; Segment type: Pure code
.text$mn:000060C8 ; Segment permissions: Read/Execute
.text$mn:000060C8 _text$mn        segment para public 'CODE' use32
.text$mn:000060C8                 assume cs:_text$mn
.text$mn:000060C8                 ;org 60C8h
.text$mn:000060C8 ; COMDAT (pick any)
.text$mn:000060C8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000060C8
.text$mn:000060C8 ; =============== S U B R O U T I N E =======================================
.text$mn:000060C8
.text$mn:000060C8 ; Attributes: bp-based frame
.text$mn:000060C8
.text$mn:000060C8 ; void __cdecl std::swap<int>(int &, int &)
.text$mn:000060C8                 public ??$swap@H@std@@YAXAAH0@Z
.text$mn:000060C8 ??$swap@H@std@@YAXAAH0@Z proc near      ; CODE XREF: std::iter_swap<int *,int *>(int *,int *)+Bp
.text$mn:000060C8                                         ; BufferEquivalent::operator()(int,int)+26p
.text$mn:000060C8
.text$mn:000060C8 var_4           = dword ptr -4
.text$mn:000060C8 arg_0           = dword ptr  8
.text$mn:000060C8 arg_4           = dword ptr  0Ch
.text$mn:000060C8
.text$mn:000060C8                 push    ebp
.text$mn:000060C9                 mov     ebp, esp
.text$mn:000060CB                 push    ecx
.text$mn:000060CC                 mov     eax, [ebp+arg_0]
.text$mn:000060CF                 push    eax
.text$mn:000060D0                 call    ??$_Move@AAH@std@@YA$$QAHAAH@Z ; std::_Move<int &>(int &)
.text$mn:000060D5                 add     esp, 4
.text$mn:000060D8                 mov     ecx, [eax]
.text$mn:000060DA                 mov     [ebp+var_4], ecx
.text$mn:000060DD                 mov     edx, [ebp+arg_4]
.text$mn:000060E0                 push    edx
.text$mn:000060E1                 call    ??$_Move@AAH@std@@YA$$QAHAAH@Z ; std::_Move<int &>(int &)
.text$mn:000060E6                 add     esp, 4
.text$mn:000060E9                 mov     ecx, [ebp+arg_0]
.text$mn:000060EC                 mov     edx, [eax]
.text$mn:000060EE                 mov     [ecx], edx
.text$mn:000060F0                 lea     eax, [ebp+var_4]
.text$mn:000060F3                 push    eax
.text$mn:000060F4                 call    ??$_Move@AAH@std@@YA$$QAHAAH@Z ; std::_Move<int &>(int &)
.text$mn:000060F9                 add     esp, 4
.text$mn:000060FC                 mov     ecx, [ebp+arg_4]
.text$mn:000060FF                 mov     edx, [eax]
.text$mn:00006101                 mov     [ecx], edx
.text$mn:00006103                 mov     esp, ebp
.text$mn:00006105                 pop     ebp
.text$mn:00006106                 retn
.text$mn:00006106 ??$swap@H@std@@YAXAAH0@Z endp
.text$mn:00006106
.text$mn:00006106 ; ---------------------------------------------------------------------------
.text$mn:00006107                 align 4
.text$mn:00006107 _text$mn        ends
.text$mn:00006107
.text$mn:00006108 ; ===========================================================================
.text$mn:00006108
.text$mn:00006108 ; Segment type: Pure code
.text$mn:00006108 ; Segment permissions: Read/Execute
.text$mn:00006108 _text$mn        segment para public 'CODE' use32
.text$mn:00006108                 assume cs:_text$mn
.text$mn:00006108                 ;org 6108h
.text$mn:00006108 ; COMDAT (pick any)
.text$mn:00006108                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006108
.text$mn:00006108 ; =============== S U B R O U T I N E =======================================
.text$mn:00006108
.text$mn:00006108 ; Attributes: bp-based frame
.text$mn:00006108
.text$mn:00006108 ; int * __cdecl std::upper_bound<int *, int, struct BufferEquivalent>(int *, int *, int const &, struct BufferEquivalent)
.text$mn:00006108                 public ??$upper_bound@PAHHUBufferEquivalent@@@std@@YAPAHPAH0ABHUBufferEquivalent@@@Z
.text$mn:00006108 ??$upper_bound@PAHHUBufferEquivalent@@@std@@YAPAHPAH0ABHUBufferEquivalent@@@Z proc near
.text$mn:00006108                                         ; CODE XREF: std::_Buffered_merge<int *,int,int,BufferEquivalent>(int *,int *,int *,int,int,std::_Temp_iterator<int> &,BufferEquivalent)+2AAp
.text$mn:00006108
.text$mn:00006108 arg_0           = dword ptr  8
.text$mn:00006108 arg_4           = dword ptr  0Ch
.text$mn:00006108 arg_8           = dword ptr  10h
.text$mn:00006108 arg_C           = dword ptr  14h
.text$mn:00006108 arg_10          = dword ptr  18h
.text$mn:00006108 arg_14          = dword ptr  1Ch
.text$mn:00006108 arg_18          = dword ptr  20h
.text$mn:00006108
.text$mn:00006108                 push    ebp
.text$mn:00006109                 mov     ebp, esp
.text$mn:0000610B                 mov     eax, [ebp+arg_0]
.text$mn:0000610E                 push    eax
.text$mn:0000610F                 call    ??$_Dist_type@PAH@std@@YAPAHPAH@Z ; std::_Dist_type<int *>(int *)
.text$mn:00006114                 add     esp, 4
.text$mn:00006117                 push    eax
.text$mn:00006118                 sub     esp, 10h
.text$mn:0000611B                 mov     ecx, esp
.text$mn:0000611D                 mov     edx, [ebp+arg_C]
.text$mn:00006120                 mov     [ecx], edx
.text$mn:00006122                 mov     eax, [ebp+arg_10]
.text$mn:00006125                 mov     [ecx+4], eax
.text$mn:00006128                 mov     edx, [ebp+arg_14]
.text$mn:0000612B                 mov     [ecx+8], edx
.text$mn:0000612E                 mov     eax, [ebp+arg_18]
.text$mn:00006131                 mov     [ecx+0Ch], eax
.text$mn:00006134                 mov     ecx, [ebp+arg_8]
.text$mn:00006137                 push    ecx
.text$mn:00006138                 mov     edx, [ebp+arg_4]
.text$mn:0000613B                 push    edx
.text$mn:0000613C                 call    ??$_Unchecked@PAH@std@@YAPAHPAH@Z ; std::_Unchecked<int *>(int *)
.text$mn:00006141                 add     esp, 4
.text$mn:00006144                 push    eax
.text$mn:00006145                 mov     eax, [ebp+arg_0]
.text$mn:00006148                 push    eax
.text$mn:00006149                 call    ??$_Unchecked@PAH@std@@YAPAHPAH@Z ; std::_Unchecked<int *>(int *)
.text$mn:0000614E                 add     esp, 4
.text$mn:00006151                 push    eax
.text$mn:00006152                 call    ??$_Upper_bound@PAHHHUBufferEquivalent@@@std@@YAPAHPAH0ABHUBufferEquivalent@@0@Z ; std::_Upper_bound<int *,int,int,BufferEquivalent>(int *,int *,int const &,BufferEquivalent,int *)
.text$mn:00006157                 add     esp, 20h
.text$mn:0000615A                 push    eax
.text$mn:0000615B                 lea     ecx, [ebp+arg_0]
.text$mn:0000615E                 push    ecx
.text$mn:0000615F                 call    ??$_Rechecked@PAHPAH@std@@YAAAPAHAAPAHPAH@Z ; std::_Rechecked<int *,int *>(int * &,int *)
.text$mn:00006164                 add     esp, 8
.text$mn:00006167                 mov     eax, [eax]
.text$mn:00006169                 pop     ebp
.text$mn:0000616A                 retn
.text$mn:0000616A ??$upper_bound@PAHHUBufferEquivalent@@@std@@YAPAHPAH0ABHUBufferEquivalent@@@Z endp
.text$mn:0000616A
.text$mn:0000616A ; ---------------------------------------------------------------------------
.text$mn:0000616B                 align 4
.text$mn:0000616B _text$mn        ends
.text$mn:0000616B
.text$mn:0000616C ; ===========================================================================
.text$mn:0000616C
.text$mn:0000616C ; Segment type: Pure code
.text$mn:0000616C ; Segment permissions: Read/Execute
.text$mn:0000616C _text$mn        segment para public 'CODE' use32
.text$mn:0000616C                 assume cs:_text$mn
.text$mn:0000616C                 ;org 616Ch
.text$mn:0000616C ; COMDAT (pick any)
.text$mn:0000616C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000616C
.text$mn:0000616C ; =============== S U B R O U T I N E =======================================
.text$mn:0000616C
.text$mn:0000616C ; Attributes: bp-based frame
.text$mn:0000616C
.text$mn:0000616C ; int __stdcall std::_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>(struct std::_Iterator_base12 *)
.text$mn:0000616C                 public ??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@ABU01@@Z
.text$mn:0000616C ??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@ABU01@@Z proc near
.text$mn:0000616C                                         ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>> const &)+2Dp
.text$mn:0000616C
.text$mn:0000616C var_10          = dword ptr -10h
.text$mn:0000616C var_C           = dword ptr -0Ch
.text$mn:0000616C var_4           = dword ptr -4
.text$mn:0000616C arg_0           = dword ptr  8
.text$mn:0000616C
.text$mn:0000616C                 push    ebp
.text$mn:0000616D                 mov     ebp, esp
.text$mn:0000616F                 push    0FFFFFFFFh
.text$mn:00006171                 push    offset __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@ABU01@@Z
.text$mn:00006176                 mov     eax, large fs:0
.text$mn:0000617C                 push    eax
.text$mn:0000617D                 push    ecx
.text$mn:0000617E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006183                 xor     eax, ebp
.text$mn:00006185                 push    eax
.text$mn:00006186                 lea     eax, [ebp+var_C]
.text$mn:00006189                 mov     large fs:0, eax
.text$mn:0000618F                 mov     [ebp+var_10], ecx
.text$mn:00006192                 mov     eax, [ebp+arg_0]
.text$mn:00006195                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00006196                 mov     ecx, [ebp+var_10] ; this
.text$mn:00006199                 call    ??0_Iterator_base12@std@@QAE@ABU01@@Z ; std::_Iterator_base12::_Iterator_base12(std::_Iterator_base12 const &)
.text$mn:0000619E                 mov     [ebp+var_4], 0
.text$mn:000061A5                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000061AC                 mov     eax, [ebp+var_10]
.text$mn:000061AF                 mov     ecx, [ebp+var_C]
.text$mn:000061B2                 mov     large fs:0, ecx
.text$mn:000061B9                 pop     ecx
.text$mn:000061BA                 mov     esp, ebp
.text$mn:000061BC                 pop     ebp
.text$mn:000061BD                 retn    4
.text$mn:000061BD ??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@ABU01@@Z endp
.text$mn:000061BD
.text$mn:000061BD _text$mn        ends
.text$mn:000061BD
.text$x:000061C0 ; ===========================================================================
.text$x:000061C0
.text$x:000061C0 ; Segment type: Pure code
.text$x:000061C0 ; Segment permissions: Read/Execute
.text$x:000061C0 _text$x         segment para public 'CODE' use32
.text$x:000061C0                 assume cs:_text$x
.text$x:000061C0                 ;org 61C0h
.text$x:000061C0 ; COMDAT (pick associative to section at 616C)
.text$x:000061C0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000061C0
.text$x:000061C0 ; =============== S U B R O U T I N E =======================================
.text$x:000061C0
.text$x:000061C0
.text$x:000061C0 __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@ABU01@@Z$0 proc near
.text$x:000061C0                                         ; DATA XREF: .xdata$x:0000D0F0o
.text$x:000061C0                 mov     ecx, [ebp-10h]  ; this
.text$x:000061C3                 jmp     ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$x:000061C3 __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@ABU01@@Z$0 endp
.text$x:000061C3
.text$x:000061C8
.text$x:000061C8 ; =============== S U B R O U T I N E =======================================
.text$x:000061C8
.text$x:000061C8
.text$x:000061C8 __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@ABU01@@Z proc near
.text$x:000061C8                                         ; DATA XREF: std::_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>(std::_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12> const &)+5o
.text$x:000061C8
.text$x:000061C8 arg_4           = dword ptr  8
.text$x:000061C8
.text$x:000061C8                 mov     edx, [esp+arg_4]
.text$x:000061CC                 lea     eax, [edx+0Ch]
.text$x:000061CF                 mov     ecx, [edx-8]
.text$x:000061D2                 xor     ecx, eax
.text$x:000061D4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000061D9                 mov     eax, offset __ehfuncinfo$??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@ABU01@@Z
.text$x:000061DE                 jmp     ___CxxFrameHandler3
.text$x:000061DE __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@ABU01@@Z endp
.text$x:000061DE
.text$x:000061DE ; ---------------------------------------------------------------------------
.text$x:000061E3                 align 4
.text$x:000061E3 _text$x         ends
.text$x:000061E3
.text$mn:000061E4 ; ===========================================================================
.text$mn:000061E4
.text$mn:000061E4 ; Segment type: Pure code
.text$mn:000061E4 ; Segment permissions: Read/Execute
.text$mn:000061E4 _text$mn        segment para public 'CODE' use32
.text$mn:000061E4                 assume cs:_text$mn
.text$mn:000061E4                 ;org 61E4h
.text$mn:000061E4 ; COMDAT (pick any)
.text$mn:000061E4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000061E4
.text$mn:000061E4 ; =============== S U B R O U T I N E =======================================
.text$mn:000061E4
.text$mn:000061E4 ; Attributes: bp-based frame
.text$mn:000061E4
.text$mn:000061E4 ; public: __thiscall std::_Iterator012<struct std::random_access_iterator_tag, int, int, int const *, int const &, struct std::_Iterator_base12>::_Iterator012<struct std::random_access_iterator_tag, int, int, int const *, int const &, struct std::_Iterator_base12>(void)
.text$mn:000061E4                 public ??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ
.text$mn:000061E4 ??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ proc near
.text$mn:000061E4                                         ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>(int *,std::_Container_base12 const *)+29p
.text$mn:000061E4
.text$mn:000061E4 var_10          = dword ptr -10h
.text$mn:000061E4 var_C           = dword ptr -0Ch
.text$mn:000061E4 var_4           = dword ptr -4
.text$mn:000061E4
.text$mn:000061E4                 push    ebp
.text$mn:000061E5                 mov     ebp, esp
.text$mn:000061E7                 push    0FFFFFFFFh
.text$mn:000061E9                 push    offset __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ
.text$mn:000061EE                 mov     eax, large fs:0
.text$mn:000061F4                 push    eax
.text$mn:000061F5                 push    ecx
.text$mn:000061F6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000061FB                 xor     eax, ebp
.text$mn:000061FD                 push    eax
.text$mn:000061FE                 lea     eax, [ebp+var_C]
.text$mn:00006201                 mov     large fs:0, eax
.text$mn:00006207                 mov     [ebp+var_10], ecx
.text$mn:0000620A                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000620D                 call    ??0_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::_Iterator_base12(void)
.text$mn:00006212                 mov     [ebp+var_4], 0
.text$mn:00006219                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006220                 mov     eax, [ebp+var_10]
.text$mn:00006223                 mov     ecx, [ebp+var_C]
.text$mn:00006226                 mov     large fs:0, ecx
.text$mn:0000622D                 pop     ecx
.text$mn:0000622E                 mov     esp, ebp
.text$mn:00006230                 pop     ebp
.text$mn:00006231                 retn
.text$mn:00006231 ??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ endp
.text$mn:00006231
.text$mn:00006231 ; ---------------------------------------------------------------------------
.text$mn:00006232                 align 4
.text$mn:00006232 _text$mn        ends
.text$mn:00006232
.text$x:00006234 ; ===========================================================================
.text$x:00006234
.text$x:00006234 ; Segment type: Pure code
.text$x:00006234 ; Segment permissions: Read/Execute
.text$x:00006234 _text$x         segment para public 'CODE' use32
.text$x:00006234                 assume cs:_text$x
.text$x:00006234                 ;org 6234h
.text$x:00006234 ; COMDAT (pick associative to section at 61E4)
.text$x:00006234                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00006234
.text$x:00006234 ; =============== S U B R O U T I N E =======================================
.text$x:00006234
.text$x:00006234
.text$x:00006234 __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ$0 proc near
.text$x:00006234                                         ; DATA XREF: .xdata$x:0000D098o
.text$x:00006234                 mov     ecx, [ebp-10h]  ; this
.text$x:00006237                 jmp     ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$x:00006237 __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ$0 endp
.text$x:00006237
.text$x:0000623C
.text$x:0000623C ; =============== S U B R O U T I N E =======================================
.text$x:0000623C
.text$x:0000623C
.text$x:0000623C __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ proc near
.text$x:0000623C                                         ; DATA XREF: std::_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>(void)+5o
.text$x:0000623C
.text$x:0000623C arg_4           = dword ptr  8
.text$x:0000623C
.text$x:0000623C                 mov     edx, [esp+arg_4]
.text$x:00006240                 lea     eax, [edx+0Ch]
.text$x:00006243                 mov     ecx, [edx-8]
.text$x:00006246                 xor     ecx, eax
.text$x:00006248                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000624D                 mov     eax, offset __ehfuncinfo$??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ
.text$x:00006252                 jmp     ___CxxFrameHandler3
.text$x:00006252 __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ endp
.text$x:00006252
.text$x:00006252 ; ---------------------------------------------------------------------------
.text$x:00006257                 align 4
.text$x:00006257 _text$x         ends
.text$x:00006257
.text$mn:00006258 ; ===========================================================================
.text$mn:00006258
.text$mn:00006258 ; Segment type: Pure code
.text$mn:00006258 ; Segment permissions: Read/Execute
.text$mn:00006258 _text$mn        segment para public 'CODE' use32
.text$mn:00006258                 assume cs:_text$mn
.text$mn:00006258                 ;org 6258h
.text$mn:00006258 ; COMDAT (pick any)
.text$mn:00006258                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006258
.text$mn:00006258 ; =============== S U B R O U T I N E =======================================
.text$mn:00006258
.text$mn:00006258 ; Attributes: bp-based frame
.text$mn:00006258
.text$mn:00006258 ; int __stdcall std::_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>(struct std::_Iterator_base12 *)
.text$mn:00006258                 public ??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@ABU01@@Z
.text$mn:00006258 ??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@ABU01@@Z proc near
.text$mn:00006258                                         ; CODE XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &):loc_6469p
.text$mn:00006258
.text$mn:00006258 var_10          = dword ptr -10h
.text$mn:00006258 var_C           = dword ptr -0Ch
.text$mn:00006258 var_4           = dword ptr -4
.text$mn:00006258 arg_0           = dword ptr  8
.text$mn:00006258
.text$mn:00006258                 push    ebp
.text$mn:00006259                 mov     ebp, esp
.text$mn:0000625B                 push    0FFFFFFFFh
.text$mn:0000625D                 push    offset __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@ABU01@@Z
.text$mn:00006262                 mov     eax, large fs:0
.text$mn:00006268                 push    eax
.text$mn:00006269                 push    ecx
.text$mn:0000626A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000626F                 xor     eax, ebp
.text$mn:00006271                 push    eax
.text$mn:00006272                 lea     eax, [ebp+var_C]
.text$mn:00006275                 mov     large fs:0, eax
.text$mn:0000627B                 mov     [ebp+var_10], ecx
.text$mn:0000627E                 mov     eax, [ebp+arg_0]
.text$mn:00006281                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00006282                 mov     ecx, [ebp+var_10] ; this
.text$mn:00006285                 call    ??0_Iterator_base12@std@@QAE@ABU01@@Z ; std::_Iterator_base12::_Iterator_base12(std::_Iterator_base12 const &)
.text$mn:0000628A                 mov     [ebp+var_4], 0
.text$mn:00006291                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006298                 mov     eax, [ebp+var_10]
.text$mn:0000629B                 mov     ecx, [ebp+var_C]
.text$mn:0000629E                 mov     large fs:0, ecx
.text$mn:000062A5                 pop     ecx
.text$mn:000062A6                 mov     esp, ebp
.text$mn:000062A8                 pop     ebp
.text$mn:000062A9                 retn    4
.text$mn:000062A9 ??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@ABU01@@Z endp
.text$mn:000062A9
.text$mn:000062A9 _text$mn        ends
.text$mn:000062A9
.text$x:000062AC ; ===========================================================================
.text$x:000062AC
.text$x:000062AC ; Segment type: Pure code
.text$x:000062AC ; Segment permissions: Read/Execute
.text$x:000062AC _text$x         segment para public 'CODE' use32
.text$x:000062AC                 assume cs:_text$x
.text$x:000062AC                 ;org 62ACh
.text$x:000062AC ; COMDAT (pick associative to section at 6258)
.text$x:000062AC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000062AC
.text$x:000062AC ; =============== S U B R O U T I N E =======================================
.text$x:000062AC
.text$x:000062AC
.text$x:000062AC __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@ABU01@@Z$0 proc near
.text$x:000062AC                                         ; DATA XREF: .xdata$x:0000D344o
.text$x:000062AC                 mov     ecx, [ebp-10h]  ; this
.text$x:000062AF                 jmp     ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$x:000062AF __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@ABU01@@Z$0 endp
.text$x:000062AF
.text$x:000062B4
.text$x:000062B4 ; =============== S U B R O U T I N E =======================================
.text$x:000062B4
.text$x:000062B4
.text$x:000062B4 __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@ABU01@@Z proc near
.text$x:000062B4                                         ; DATA XREF: std::_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>(std::_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12> const &)+5o
.text$x:000062B4
.text$x:000062B4 arg_4           = dword ptr  8
.text$x:000062B4
.text$x:000062B4                 mov     edx, [esp+arg_4]
.text$x:000062B8                 lea     eax, [edx+0Ch]
.text$x:000062BB                 mov     ecx, [edx-8]
.text$x:000062BE                 xor     ecx, eax
.text$x:000062C0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000062C5                 mov     eax, offset __ehfuncinfo$??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@ABU01@@Z
.text$x:000062CA                 jmp     ___CxxFrameHandler3
.text$x:000062CA __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@ABU01@@Z endp
.text$x:000062CA
.text$x:000062CA ; ---------------------------------------------------------------------------
.text$x:000062CF                 align 10h
.text$x:000062CF _text$x         ends
.text$x:000062CF
.text$mn:000062D0 ; ===========================================================================
.text$mn:000062D0
.text$mn:000062D0 ; Segment type: Pure code
.text$mn:000062D0 ; Segment permissions: Read/Execute
.text$mn:000062D0 _text$mn        segment para public 'CODE' use32
.text$mn:000062D0                 assume cs:_text$mn
.text$mn:000062D0                 ;org 62D0h
.text$mn:000062D0 ; COMDAT (pick any)
.text$mn:000062D0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000062D0
.text$mn:000062D0 ; =============== S U B R O U T I N E =======================================
.text$mn:000062D0
.text$mn:000062D0 ; Attributes: bp-based frame
.text$mn:000062D0
.text$mn:000062D0 ; public: __thiscall std::_Iterator012<struct std::random_access_iterator_tag, wchar_t, int, wchar_t const *, wchar_t const &, struct std::_Iterator_base12>::_Iterator012<struct std::random_access_iterator_tag, wchar_t, int, wchar_t const *, wchar_t const &, struct std::_Iterator_base12>(void)
.text$mn:000062D0                 public ??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ
.text$mn:000062D0 ??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ proc near
.text$mn:000062D0                                         ; CODE XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(wchar_t const *,std::_Container_base12 const *)+29p
.text$mn:000062D0
.text$mn:000062D0 var_10          = dword ptr -10h
.text$mn:000062D0 var_C           = dword ptr -0Ch
.text$mn:000062D0 var_4           = dword ptr -4
.text$mn:000062D0
.text$mn:000062D0                 push    ebp
.text$mn:000062D1                 mov     ebp, esp
.text$mn:000062D3                 push    0FFFFFFFFh
.text$mn:000062D5                 push    offset __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ
.text$mn:000062DA                 mov     eax, large fs:0
.text$mn:000062E0                 push    eax
.text$mn:000062E1                 push    ecx
.text$mn:000062E2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000062E7                 xor     eax, ebp
.text$mn:000062E9                 push    eax
.text$mn:000062EA                 lea     eax, [ebp+var_C]
.text$mn:000062ED                 mov     large fs:0, eax
.text$mn:000062F3                 mov     [ebp+var_10], ecx
.text$mn:000062F6                 mov     ecx, [ebp+var_10] ; this
.text$mn:000062F9                 call    ??0_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::_Iterator_base12(void)
.text$mn:000062FE                 mov     [ebp+var_4], 0
.text$mn:00006305                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000630C                 mov     eax, [ebp+var_10]
.text$mn:0000630F                 mov     ecx, [ebp+var_C]
.text$mn:00006312                 mov     large fs:0, ecx
.text$mn:00006319                 pop     ecx
.text$mn:0000631A                 mov     esp, ebp
.text$mn:0000631C                 pop     ebp
.text$mn:0000631D                 retn
.text$mn:0000631D ??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ endp
.text$mn:0000631D
.text$mn:0000631D ; ---------------------------------------------------------------------------
.text$mn:0000631E                 align 10h
.text$mn:0000631E _text$mn        ends
.text$mn:0000631E
.text$x:00006320 ; ===========================================================================
.text$x:00006320
.text$x:00006320 ; Segment type: Pure code
.text$x:00006320 ; Segment permissions: Read/Execute
.text$x:00006320 _text$x         segment para public 'CODE' use32
.text$x:00006320                 assume cs:_text$x
.text$x:00006320                 ;org 6320h
.text$x:00006320 ; COMDAT (pick associative to section at 62D0)
.text$x:00006320                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00006320
.text$x:00006320 ; =============== S U B R O U T I N E =======================================
.text$x:00006320
.text$x:00006320
.text$x:00006320 __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ$0 proc near
.text$x:00006320                                         ; DATA XREF: .xdata$x:0000D2ECo
.text$x:00006320                 mov     ecx, [ebp-10h]  ; this
.text$x:00006323                 jmp     ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$x:00006323 __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ$0 endp
.text$x:00006323
.text$x:00006328
.text$x:00006328 ; =============== S U B R O U T I N E =======================================
.text$x:00006328
.text$x:00006328
.text$x:00006328 __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ proc near
.text$x:00006328                                         ; DATA XREF: std::_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>(void)+5o
.text$x:00006328
.text$x:00006328 arg_4           = dword ptr  8
.text$x:00006328
.text$x:00006328                 mov     edx, [esp+arg_4]
.text$x:0000632C                 lea     eax, [edx+0Ch]
.text$x:0000632F                 mov     ecx, [edx-8]
.text$x:00006332                 xor     ecx, eax
.text$x:00006334                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006339                 mov     eax, offset __ehfuncinfo$??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ
.text$x:0000633E                 jmp     ___CxxFrameHandler3
.text$x:0000633E __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ endp
.text$x:0000633E
.text$x:0000633E ; ---------------------------------------------------------------------------
.text$x:00006343                 align 4
.text$x:00006343 _text$x         ends
.text$x:00006343
.text$mn:00006344 ; ===========================================================================
.text$mn:00006344
.text$mn:00006344 ; Segment type: Pure code
.text$mn:00006344 ; Segment permissions: Read/Execute
.text$mn:00006344 _text$mn        segment para public 'CODE' use32
.text$mn:00006344                 assume cs:_text$mn
.text$mn:00006344                 ;org 6344h
.text$mn:00006344 ; COMDAT (pick any)
.text$mn:00006344                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006344
.text$mn:00006344 ; =============== S U B R O U T I N E =======================================
.text$mn:00006344
.text$mn:00006344 ; Attributes: bp-based frame
.text$mn:00006344
.text$mn:00006344 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>(class std::allocator<char> const &)
.text$mn:00006344                 public ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$mn:00006344 ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
.text$mn:00006344                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+34p
.text$mn:00006344
.text$mn:00006344 var_10          = dword ptr -10h
.text$mn:00006344 var_C           = dword ptr -0Ch
.text$mn:00006344 var_4           = dword ptr -4
.text$mn:00006344
.text$mn:00006344                 push    ebp
.text$mn:00006345                 mov     ebp, esp
.text$mn:00006347                 push    0FFFFFFFFh
.text$mn:00006349                 push    offset __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$mn:0000634E                 mov     eax, large fs:0
.text$mn:00006354                 push    eax
.text$mn:00006355                 push    ecx
.text$mn:00006356                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000635B                 xor     eax, ebp
.text$mn:0000635D                 push    eax
.text$mn:0000635E                 lea     eax, [ebp+var_C]
.text$mn:00006361                 mov     large fs:0, eax
.text$mn:00006367                 mov     [ebp+var_10], ecx
.text$mn:0000636A                 mov     ecx, [ebp+var_10]
.text$mn:0000636D                 call    ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)
.text$mn:00006372                 mov     [ebp+var_4], 0
.text$mn:00006379                 mov     ecx, [ebp+var_10]
.text$mn:0000637C                 call    ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)
.text$mn:00006381                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006388                 mov     eax, [ebp+var_10]
.text$mn:0000638B                 mov     ecx, [ebp+var_C]
.text$mn:0000638E                 mov     large fs:0, ecx
.text$mn:00006395                 pop     ecx
.text$mn:00006396                 mov     esp, ebp
.text$mn:00006398                 pop     ebp
.text$mn:00006399                 retn    4
.text$mn:00006399 ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp
.text$mn:00006399
.text$mn:00006399 _text$mn        ends
.text$mn:00006399
.text$x:0000639C ; ===========================================================================
.text$x:0000639C
.text$x:0000639C ; Segment type: Pure code
.text$x:0000639C ; Segment permissions: Read/Execute
.text$x:0000639C _text$x         segment para public 'CODE' use32
.text$x:0000639C                 assume cs:_text$x
.text$x:0000639C                 ;org 639Ch
.text$x:0000639C ; COMDAT (pick associative to section at 6344)
.text$x:0000639C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000639C
.text$x:0000639C ; =============== S U B R O U T I N E =======================================
.text$x:0000639C
.text$x:0000639C
.text$x:0000639C __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 proc near
.text$x:0000639C                                         ; DATA XREF: .xdata$x:0000C6A8o
.text$x:0000639C                 mov     ecx, [ebp-10h]
.text$x:0000639F                 jmp     ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$x:0000639F __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 endp
.text$x:0000639F
.text$x:000063A4
.text$x:000063A4 ; =============== S U B R O U T I N E =======================================
.text$x:000063A4
.text$x:000063A4
.text$x:000063A4 __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
.text$x:000063A4                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+5o
.text$x:000063A4
.text$x:000063A4 arg_4           = dword ptr  8
.text$x:000063A4
.text$x:000063A4                 mov     edx, [esp+arg_4]
.text$x:000063A8                 lea     eax, [edx+0Ch]
.text$x:000063AB                 mov     ecx, [edx-8]
.text$x:000063AE                 xor     ecx, eax
.text$x:000063B0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000063B5                 mov     eax, offset __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$x:000063BA                 jmp     ___CxxFrameHandler3
.text$x:000063BA __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp
.text$x:000063BA
.text$x:000063BA ; ---------------------------------------------------------------------------
.text$x:000063BF                 align 10h
.text$x:000063BF _text$x         ends
.text$x:000063BF
.text$mn:000063C0 ; ===========================================================================
.text$mn:000063C0
.text$mn:000063C0 ; Segment type: Pure code
.text$mn:000063C0 ; Segment permissions: Read/Execute
.text$mn:000063C0 _text$mn        segment para public 'CODE' use32
.text$mn:000063C0                 assume cs:_text$mn
.text$mn:000063C0                 ;org 63C0h
.text$mn:000063C0 ; COMDAT (pick any)
.text$mn:000063C0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000063C0
.text$mn:000063C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000063C0
.text$mn:000063C0 ; Attributes: bp-based frame
.text$mn:000063C0
.text$mn:000063C0 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>(class std::allocator<wchar_t> const &)
.text$mn:000063C0                 public ??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z
.text$mn:000063C0 ??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z proc near
.text$mn:000063C0                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)+34p
.text$mn:000063C0
.text$mn:000063C0 var_10          = dword ptr -10h
.text$mn:000063C0 var_C           = dword ptr -0Ch
.text$mn:000063C0 var_4           = dword ptr -4
.text$mn:000063C0
.text$mn:000063C0                 push    ebp
.text$mn:000063C1                 mov     ebp, esp
.text$mn:000063C3                 push    0FFFFFFFFh
.text$mn:000063C5                 push    offset __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z
.text$mn:000063CA                 mov     eax, large fs:0
.text$mn:000063D0                 push    eax
.text$mn:000063D1                 push    ecx
.text$mn:000063D2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000063D7                 xor     eax, ebp
.text$mn:000063D9                 push    eax
.text$mn:000063DA                 lea     eax, [ebp+var_C]
.text$mn:000063DD                 mov     large fs:0, eax
.text$mn:000063E3                 mov     [ebp+var_10], ecx
.text$mn:000063E6                 mov     ecx, [ebp+var_10]
.text$mn:000063E9                 call    ??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t>>::_String_val<std::_Simple_types<wchar_t>>(void)
.text$mn:000063EE                 mov     [ebp+var_4], 0
.text$mn:000063F5                 mov     ecx, [ebp+var_10]
.text$mn:000063F8                 call    ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Alloc_proxy(void)
.text$mn:000063FD                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006404                 mov     eax, [ebp+var_10]
.text$mn:00006407                 mov     ecx, [ebp+var_C]
.text$mn:0000640A                 mov     large fs:0, ecx
.text$mn:00006411                 pop     ecx
.text$mn:00006412                 mov     esp, ebp
.text$mn:00006414                 pop     ebp
.text$mn:00006415                 retn    4
.text$mn:00006415 ??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z endp
.text$mn:00006415
.text$mn:00006415 _text$mn        ends
.text$mn:00006415
.text$x:00006418 ; ===========================================================================
.text$x:00006418
.text$x:00006418 ; Segment type: Pure code
.text$x:00006418 ; Segment permissions: Read/Execute
.text$x:00006418 _text$x         segment para public 'CODE' use32
.text$x:00006418                 assume cs:_text$x
.text$x:00006418                 ;org 6418h
.text$x:00006418 ; COMDAT (pick associative to section at 63C0)
.text$x:00006418                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00006418
.text$x:00006418 ; =============== S U B R O U T I N E =======================================
.text$x:00006418
.text$x:00006418
.text$x:00006418 __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z$0 proc near
.text$x:00006418                                         ; DATA XREF: .xdata$x:0000C9C8o
.text$x:00006418                 mov     ecx, [ebp-10h]
.text$x:0000641B                 jmp     ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t>>::~_String_val<std::_Simple_types<wchar_t>>(void)
.text$x:0000641B __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z$0 endp
.text$x:0000641B
.text$x:00006420
.text$x:00006420 ; =============== S U B R O U T I N E =======================================
.text$x:00006420
.text$x:00006420
.text$x:00006420 __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z proc near
.text$x:00006420                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(std::allocator<wchar_t> const &)+5o
.text$x:00006420
.text$x:00006420 arg_4           = dword ptr  8
.text$x:00006420
.text$x:00006420                 mov     edx, [esp+arg_4]
.text$x:00006424                 lea     eax, [edx+0Ch]
.text$x:00006427                 mov     ecx, [edx-8]
.text$x:0000642A                 xor     ecx, eax
.text$x:0000642C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006431                 mov     eax, offset __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z
.text$x:00006436                 jmp     ___CxxFrameHandler3
.text$x:00006436 __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z endp
.text$x:00006436
.text$x:00006436 ; ---------------------------------------------------------------------------
.text$x:0000643B                 align 4
.text$x:0000643B _text$x         ends
.text$x:0000643B
.text$mn:0000643C ; ===========================================================================
.text$mn:0000643C
.text$mn:0000643C ; Segment type: Pure code
.text$mn:0000643C ; Segment permissions: Read/Execute
.text$mn:0000643C _text$mn        segment para public 'CODE' use32
.text$mn:0000643C                 assume cs:_text$mn
.text$mn:0000643C                 ;org 643Ch
.text$mn:0000643C ; COMDAT (pick any)
.text$mn:0000643C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000643C
.text$mn:0000643C ; =============== S U B R O U T I N E =======================================
.text$mn:0000643C
.text$mn:0000643C ; Attributes: bp-based frame
.text$mn:0000643C
.text$mn:0000643C ; int __stdcall std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(struct std::_Iterator_base12 *)
.text$mn:0000643C                 public ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z
.text$mn:0000643C ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z proc near
.text$mn:0000643C                                         ; CODE XREF: std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)+2Dp
.text$mn:0000643C                                         ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator-(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)+33p
.text$mn:0000643C
.text$mn:0000643C var_10          = dword ptr -10h
.text$mn:0000643C var_C           = dword ptr -0Ch
.text$mn:0000643C var_4           = dword ptr -4
.text$mn:0000643C arg_0           = dword ptr  8
.text$mn:0000643C
.text$mn:0000643C                 push    ebp
.text$mn:0000643D                 mov     ebp, esp
.text$mn:0000643F                 push    0FFFFFFFFh
.text$mn:00006441                 push    offset __ehhandler$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z
.text$mn:00006446                 mov     eax, large fs:0
.text$mn:0000644C                 push    eax
.text$mn:0000644D                 push    ecx
.text$mn:0000644E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006453                 xor     eax, ebp
.text$mn:00006455                 push    eax
.text$mn:00006456                 lea     eax, [ebp+var_C]
.text$mn:00006459                 mov     large fs:0, eax
.text$mn:0000645F                 mov     [ebp+var_10], ecx
.text$mn:00006462                 mov     eax, [ebp+arg_0]
.text$mn:00006465                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00006466                 mov     ecx, [ebp+var_10]
.text$mn:00006469
.text$mn:00006469 loc_6469:                               ; DATA XREF: .rdata:$SG132597o
.text$mn:00006469                 call    ??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@ABU01@@Z ; std::_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>(std::_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12> const &)
.text$mn:0000646E                 mov     [ebp+var_4], 0
.text$mn:00006475                 mov     ecx, [ebp+var_10]
.text$mn:00006478                 mov     edx, [ebp+arg_0]
.text$mn:0000647B                 mov     eax, [edx+8]
.text$mn:0000647E                 mov     [ecx+8], eax
.text$mn:00006481                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006488                 mov     eax, [ebp+var_10]
.text$mn:0000648B                 mov     ecx, [ebp+var_C]
.text$mn:0000648E                 mov     large fs:0, ecx
.text$mn:00006495                 pop     ecx
.text$mn:00006496                 mov     esp, ebp
.text$mn:00006498                 pop     ebp
.text$mn:00006499                 retn    4
.text$mn:00006499 ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z endp
.text$mn:00006499
.text$mn:00006499 _text$mn        ends
.text$mn:00006499
.text$x:0000649C ; ===========================================================================
.text$x:0000649C
.text$x:0000649C ; Segment type: Pure code
.text$x:0000649C ; Segment permissions: Read/Execute
.text$x:0000649C _text$x         segment para public 'CODE' use32
.text$x:0000649C                 assume cs:_text$x
.text$x:0000649C                 ;org 649Ch
.text$x:0000649C ; COMDAT (pick associative to section at 643C)
.text$x:0000649C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000649C
.text$x:0000649C ; =============== S U B R O U T I N E =======================================
.text$x:0000649C
.text$x:0000649C
.text$x:0000649C __unwindfunclet$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z$0 proc near
.text$x:0000649C                                         ; DATA XREF: .xdata$x:0000D3C8o
.text$x:0000649C                 mov     ecx, [ebp-10h]
.text$x:0000649F                 jmp     ??1?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>(void)
.text$x:0000649F __unwindfunclet$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z$0 endp
.text$x:0000649F
.text$x:000064A4
.text$x:000064A4 ; =============== S U B R O U T I N E =======================================
.text$x:000064A4
.text$x:000064A4
.text$x:000064A4 __ehhandler$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z proc near
.text$x:000064A4                                         ; DATA XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)+5o
.text$x:000064A4
.text$x:000064A4 arg_4           = dword ptr  8
.text$x:000064A4
.text$x:000064A4                 mov     edx, [esp+arg_4]
.text$x:000064A8                 lea     eax, [edx+0Ch]
.text$x:000064AB                 mov     ecx, [edx-8]
.text$x:000064AE                 xor     ecx, eax
.text$x:000064B0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000064B5                 mov     eax, offset __ehfuncinfo$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z
.text$x:000064BA                 jmp     ___CxxFrameHandler3
.text$x:000064BA __ehhandler$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z endp
.text$x:000064BA
.text$x:000064BA ; ---------------------------------------------------------------------------
.text$x:000064BF                 align 10h
.text$x:000064BF _text$x         ends
.text$x:000064BF
.text$mn:000064C0 ; ===========================================================================
.text$mn:000064C0
.text$mn:000064C0 ; Segment type: Pure code
.text$mn:000064C0 ; Segment permissions: Read/Execute
.text$mn:000064C0 _text$mn        segment para public 'CODE' use32
.text$mn:000064C0                 assume cs:_text$mn
.text$mn:000064C0                 ;org 64C0h
.text$mn:000064C0 ; COMDAT (pick any)
.text$mn:000064C0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000064C0
.text$mn:000064C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000064C0
.text$mn:000064C0 ; Attributes: bp-based frame
.text$mn:000064C0
.text$mn:000064C0 ; int __stdcall std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(int, struct std::_Container_base12 *)
.text$mn:000064C0                 public ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PB_WPBU_Container_base12@1@@Z
.text$mn:000064C0 ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PB_WPBU_Container_base12@1@@Z proc near
.text$mn:000064C0                                         ; CODE XREF: std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(wchar_t *,std::_Container_base12 const *)+31p
.text$mn:000064C0
.text$mn:000064C0 var_10          = dword ptr -10h
.text$mn:000064C0 var_C           = dword ptr -0Ch
.text$mn:000064C0 var_4           = dword ptr -4
.text$mn:000064C0 arg_0           = dword ptr  8
.text$mn:000064C0 arg_4           = dword ptr  0Ch
.text$mn:000064C0
.text$mn:000064C0                 push    ebp
.text$mn:000064C1                 mov     ebp, esp
.text$mn:000064C3                 push    0FFFFFFFFh
.text$mn:000064C5                 push    offset __ehhandler$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PB_WPBU_Container_base12@1@@Z
.text$mn:000064CA                 mov     eax, large fs:0
.text$mn:000064D0                 push    eax
.text$mn:000064D1                 push    ecx
.text$mn:000064D2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000064D7                 xor     eax, ebp
.text$mn:000064D9                 push    eax
.text$mn:000064DA                 lea     eax, [ebp+var_C]
.text$mn:000064DD                 mov     large fs:0, eax
.text$mn:000064E3                 mov     [ebp+var_10], ecx
.text$mn:000064E6                 mov     ecx, [ebp+var_10]
.text$mn:000064E9                 call    ??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>(void)
.text$mn:000064EE                 mov     [ebp+var_4], 0
.text$mn:000064F5                 mov     eax, [ebp+arg_4]
.text$mn:000064F8                 push    eax             ; struct std::_Container_base12 *
.text$mn:000064F9                 mov     ecx, [ebp+var_10] ; this
.text$mn:000064FC                 call    ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt(std::_Container_base12 const *)
.text$mn:00006501                 mov     ecx, [ebp+var_10]
.text$mn:00006504                 mov     edx, [ebp+arg_0]
.text$mn:00006507                 mov     [ecx+8], edx
.text$mn:0000650A                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006511                 mov     eax, [ebp+var_10]
.text$mn:00006514                 mov     ecx, [ebp+var_C]
.text$mn:00006517                 mov     large fs:0, ecx
.text$mn:0000651E                 pop     ecx
.text$mn:0000651F                 mov     esp, ebp
.text$mn:00006521                 pop     ebp
.text$mn:00006522                 retn    8
.text$mn:00006522 ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PB_WPBU_Container_base12@1@@Z endp
.text$mn:00006522
.text$mn:00006522 ; ---------------------------------------------------------------------------
.text$mn:00006525                 align 4
.text$mn:00006525 _text$mn        ends
.text$mn:00006525
.text$x:00006528 ; ===========================================================================
.text$x:00006528
.text$x:00006528 ; Segment type: Pure code
.text$x:00006528 ; Segment permissions: Read/Execute
.text$x:00006528 _text$x         segment para public 'CODE' use32
.text$x:00006528                 assume cs:_text$x
.text$x:00006528                 ;org 6528h
.text$x:00006528 ; COMDAT (pick associative to section at 64C0)
.text$x:00006528                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00006528
.text$x:00006528 ; =============== S U B R O U T I N E =======================================
.text$x:00006528
.text$x:00006528
.text$x:00006528 __unwindfunclet$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PB_WPBU_Container_base12@1@@Z$0 proc near
.text$x:00006528                                         ; DATA XREF: .xdata$x:0000D370o
.text$x:00006528                 mov     ecx, [ebp-10h]
.text$x:0000652B                 jmp     ??1?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>(void)
.text$x:0000652B __unwindfunclet$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PB_WPBU_Container_base12@1@@Z$0 endp
.text$x:0000652B
.text$x:00006530
.text$x:00006530 ; =============== S U B R O U T I N E =======================================
.text$x:00006530
.text$x:00006530
.text$x:00006530 __ehhandler$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PB_WPBU_Container_base12@1@@Z proc near
.text$x:00006530                                         ; DATA XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(wchar_t const *,std::_Container_base12 const *)+5o
.text$x:00006530
.text$x:00006530 arg_4           = dword ptr  8
.text$x:00006530
.text$x:00006530                 mov     edx, [esp+arg_4]
.text$x:00006534                 lea     eax, [edx+0Ch]
.text$x:00006537                 mov     ecx, [edx-8]
.text$x:0000653A                 xor     ecx, eax
.text$x:0000653C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006541                 mov     eax, offset __ehfuncinfo$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PB_WPBU_Container_base12@1@@Z
.text$x:00006546                 jmp     ___CxxFrameHandler3
.text$x:00006546 __ehhandler$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PB_WPBU_Container_base12@1@@Z endp
.text$x:00006546
.text$x:00006546 ; ---------------------------------------------------------------------------
.text$x:0000654B                 align 4
.text$x:0000654B _text$x         ends
.text$x:0000654B
.text$mn:0000654C ; ===========================================================================
.text$mn:0000654C
.text$mn:0000654C ; Segment type: Pure code
.text$mn:0000654C ; Segment permissions: Read/Execute
.text$mn:0000654C _text$mn        segment para public 'CODE' use32
.text$mn:0000654C                 assume cs:_text$mn
.text$mn:0000654C                 ;org 654Ch
.text$mn:0000654C ; COMDAT (pick any)
.text$mn:0000654C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000654C
.text$mn:0000654C ; =============== S U B R O U T I N E =======================================
.text$mn:0000654C
.text$mn:0000654C ; Attributes: bp-based frame
.text$mn:0000654C
.text$mn:0000654C ; int __stdcall std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(struct std::_Iterator_base12 *)
.text$mn:0000654C                 public ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z
.text$mn:0000654C ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z proc near
.text$mn:0000654C                                         ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::vector<wchar_t,std::allocator<wchar_t>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)+50p
.text$mn:0000654C                                         ; std::vector<wchar_t,std::allocator<wchar_t>>::vector<wchar_t,std::allocator<wchar_t>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)+6Ep ...
.text$mn:0000654C
.text$mn:0000654C var_10          = dword ptr -10h
.text$mn:0000654C var_C           = dword ptr -0Ch
.text$mn:0000654C var_4           = dword ptr -4
.text$mn:0000654C arg_0           = dword ptr  8
.text$mn:0000654C
.text$mn:0000654C                 push    ebp
.text$mn:0000654D                 mov     ebp, esp
.text$mn:0000654F                 push    0FFFFFFFFh
.text$mn:00006551                 push    offset __ehhandler$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z
.text$mn:00006556                 mov     eax, large fs:0
.text$mn:0000655C                 push    eax
.text$mn:0000655D                 push    ecx
.text$mn:0000655E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006563                 xor     eax, ebp
.text$mn:00006565                 push    eax
.text$mn:00006566                 lea     eax, [ebp+var_C]
.text$mn:00006569                 mov     large fs:0, eax
.text$mn:0000656F                 mov     [ebp+var_10], ecx
.text$mn:00006572                 mov     eax, [ebp+arg_0]
.text$mn:00006575                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00006576                 mov     ecx, [ebp+var_10]
.text$mn:00006579                 call    ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:0000657E                 mov     [ebp+var_4], 0
.text$mn:00006585                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000658C                 mov     eax, [ebp+var_10]
.text$mn:0000658F                 mov     ecx, [ebp+var_C]
.text$mn:00006592                 mov     large fs:0, ecx
.text$mn:00006599                 pop     ecx
.text$mn:0000659A                 mov     esp, ebp
.text$mn:0000659C                 pop     ebp
.text$mn:0000659D                 retn    4
.text$mn:0000659D ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z endp
.text$mn:0000659D
.text$mn:0000659D _text$mn        ends
.text$mn:0000659D
.text$x:000065A0 ; ===========================================================================
.text$x:000065A0
.text$x:000065A0 ; Segment type: Pure code
.text$x:000065A0 ; Segment permissions: Read/Execute
.text$x:000065A0 _text$x         segment para public 'CODE' use32
.text$x:000065A0                 assume cs:_text$x
.text$x:000065A0                 ;org 65A0h
.text$x:000065A0 ; COMDAT (pick associative to section at 654C)
.text$x:000065A0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000065A0
.text$x:000065A0 ; =============== S U B R O U T I N E =======================================
.text$x:000065A0
.text$x:000065A0
.text$x:000065A0 __unwindfunclet$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z$0 proc near
.text$x:000065A0                                         ; DATA XREF: .xdata$x:0000D478o
.text$x:000065A0                 mov     ecx, [ebp-10h]
.text$x:000065A3                 jmp     ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:000065A3 __unwindfunclet$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z$0 endp
.text$x:000065A3
.text$x:000065A8
.text$x:000065A8 ; =============== S U B R O U T I N E =======================================
.text$x:000065A8
.text$x:000065A8
.text$x:000065A8 __ehhandler$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z proc near
.text$x:000065A8                                         ; DATA XREF: std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)+5o
.text$x:000065A8
.text$x:000065A8 arg_4           = dword ptr  8
.text$x:000065A8
.text$x:000065A8                 mov     edx, [esp+arg_4]
.text$x:000065AC                 lea     eax, [edx+0Ch]
.text$x:000065AF                 mov     ecx, [edx-8]
.text$x:000065B2                 xor     ecx, eax
.text$x:000065B4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000065B9                 mov     eax, offset __ehfuncinfo$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z
.text$x:000065BE                 jmp     ___CxxFrameHandler3
.text$x:000065BE __ehhandler$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z endp
.text$x:000065BE
.text$x:000065BE ; ---------------------------------------------------------------------------
.text$x:000065C3                 align 4
.text$x:000065C3 _text$x         ends
.text$x:000065C3
.text$mn:000065C4 ; ===========================================================================
.text$mn:000065C4
.text$mn:000065C4 ; Segment type: Pure code
.text$mn:000065C4 ; Segment permissions: Read/Execute
.text$mn:000065C4 _text$mn        segment para public 'CODE' use32
.text$mn:000065C4                 assume cs:_text$mn
.text$mn:000065C4                 ;org 65C4h
.text$mn:000065C4 ; COMDAT (pick any)
.text$mn:000065C4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000065C4
.text$mn:000065C4 ; =============== S U B R O U T I N E =======================================
.text$mn:000065C4
.text$mn:000065C4 ; Attributes: bp-based frame
.text$mn:000065C4
.text$mn:000065C4 ; int __stdcall std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(int, struct std::_Container_base12 *)
.text$mn:000065C4                 public ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base12@1@@Z
.text$mn:000065C4 ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base12@1@@Z proc near
.text$mn:000065C4                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::begin(void)+3Fp
.text$mn:000065C4                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::end(void)+48p
.text$mn:000065C4
.text$mn:000065C4 var_10          = dword ptr -10h
.text$mn:000065C4 var_C           = dword ptr -0Ch
.text$mn:000065C4 var_4           = dword ptr -4
.text$mn:000065C4 arg_0           = dword ptr  8
.text$mn:000065C4 arg_4           = dword ptr  0Ch
.text$mn:000065C4
.text$mn:000065C4                 push    ebp
.text$mn:000065C5                 mov     ebp, esp
.text$mn:000065C7                 push    0FFFFFFFFh
.text$mn:000065C9                 push    offset __ehhandler$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base12@1@@Z
.text$mn:000065CE                 mov     eax, large fs:0
.text$mn:000065D4                 push    eax
.text$mn:000065D5                 push    ecx
.text$mn:000065D6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000065DB                 xor     eax, ebp
.text$mn:000065DD                 push    eax
.text$mn:000065DE                 lea     eax, [ebp+var_C]
.text$mn:000065E1                 mov     large fs:0, eax
.text$mn:000065E7                 mov     [ebp+var_10], ecx
.text$mn:000065EA                 mov     eax, [ebp+arg_4]
.text$mn:000065ED                 push    eax             ; struct std::_Container_base12 *
.text$mn:000065EE                 mov     ecx, [ebp+arg_0]
.text$mn:000065F1                 push    ecx             ; int
.text$mn:000065F2                 mov     ecx, [ebp+var_10]
.text$mn:000065F5                 call    ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PB_WPBU_Container_base12@1@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(wchar_t const *,std::_Container_base12 const *)
.text$mn:000065FA                 mov     [ebp+var_4], 0
.text$mn:00006601                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006608                 mov     eax, [ebp+var_10]
.text$mn:0000660B                 mov     ecx, [ebp+var_C]
.text$mn:0000660E                 mov     large fs:0, ecx
.text$mn:00006615                 pop     ecx
.text$mn:00006616                 mov     esp, ebp
.text$mn:00006618                 pop     ebp
.text$mn:00006619                 retn    8
.text$mn:00006619 ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base12@1@@Z endp
.text$mn:00006619
.text$mn:00006619 _text$mn        ends
.text$mn:00006619
.text$x:0000661C ; ===========================================================================
.text$x:0000661C
.text$x:0000661C ; Segment type: Pure code
.text$x:0000661C ; Segment permissions: Read/Execute
.text$x:0000661C _text$x         segment para public 'CODE' use32
.text$x:0000661C                 assume cs:_text$x
.text$x:0000661C                 ;org 661Ch
.text$x:0000661C ; COMDAT (pick associative to section at 65C4)
.text$x:0000661C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000661C
.text$x:0000661C ; =============== S U B R O U T I N E =======================================
.text$x:0000661C
.text$x:0000661C
.text$x:0000661C __unwindfunclet$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base12@1@@Z$0 proc near
.text$x:0000661C                                         ; DATA XREF: .xdata$x:0000D3F4o
.text$x:0000661C                 mov     ecx, [ebp-10h]
.text$x:0000661F                 jmp     ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:0000661F __unwindfunclet$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base12@1@@Z$0 endp
.text$x:0000661F
.text$x:00006624
.text$x:00006624 ; =============== S U B R O U T I N E =======================================
.text$x:00006624
.text$x:00006624
.text$x:00006624 __ehhandler$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base12@1@@Z proc near
.text$x:00006624                                         ; DATA XREF: std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(wchar_t *,std::_Container_base12 const *)+5o
.text$x:00006624
.text$x:00006624 arg_4           = dword ptr  8
.text$x:00006624
.text$x:00006624                 mov     edx, [esp+arg_4]
.text$x:00006628                 lea     eax, [edx+0Ch]
.text$x:0000662B                 mov     ecx, [edx-8]
.text$x:0000662E                 xor     ecx, eax
.text$x:00006630                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006635                 mov     eax, offset __ehfuncinfo$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base12@1@@Z
.text$x:0000663A                 jmp     ___CxxFrameHandler3
.text$x:0000663A __ehhandler$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base12@1@@Z endp
.text$x:0000663A
.text$x:0000663A ; ---------------------------------------------------------------------------
.text$x:0000663F                 align 10h
.text$x:0000663F _text$x         ends
.text$x:0000663F
.text$mn:00006640 ; ===========================================================================
.text$mn:00006640
.text$mn:00006640 ; Segment type: Pure code
.text$mn:00006640 ; Segment permissions: Read/Execute
.text$mn:00006640 _text$mn        segment para public 'CODE' use32
.text$mn:00006640                 assume cs:_text$mn
.text$mn:00006640                 ;org 6640h
.text$mn:00006640 ; COMDAT (pick any)
.text$mn:00006640                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006640
.text$mn:00006640 ; =============== S U B R O U T I N E =======================================
.text$mn:00006640
.text$mn:00006640 ; Attributes: bp-based frame
.text$mn:00006640
.text$mn:00006640 ; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::_String_val<struct std::_Simple_types<char>>(void)
.text$mn:00006640                 public ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00006640 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$mn:00006640                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+29p
.text$mn:00006640
.text$mn:00006640 var_10          = dword ptr -10h
.text$mn:00006640 var_C           = dword ptr -0Ch
.text$mn:00006640 var_4           = dword ptr -4
.text$mn:00006640
.text$mn:00006640                 push    ebp
.text$mn:00006641                 mov     ebp, esp
.text$mn:00006643                 push    0FFFFFFFFh
.text$mn:00006645                 push    offset __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:0000664A                 mov     eax, large fs:0
.text$mn:00006650                 push    eax
.text$mn:00006651                 push    ecx
.text$mn:00006652                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006657                 xor     eax, ebp
.text$mn:00006659                 push    eax
.text$mn:0000665A                 lea     eax, [ebp+var_C]
.text$mn:0000665D                 mov     large fs:0, eax
.text$mn:00006663                 mov     [ebp+var_10], ecx
.text$mn:00006666                 mov     ecx, [ebp+var_10] ; this
.text$mn:00006669                 call    ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
.text$mn:0000666E                 mov     [ebp+var_4], 0
.text$mn:00006675                 mov     eax, [ebp+var_10]
.text$mn:00006678                 mov     dword ptr [eax+14h], 0
.text$mn:0000667F                 mov     ecx, [ebp+var_10]
.text$mn:00006682                 mov     dword ptr [ecx+18h], 0
.text$mn:00006689                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006690                 mov     eax, [ebp+var_10]
.text$mn:00006693                 mov     ecx, [ebp+var_C]
.text$mn:00006696                 mov     large fs:0, ecx
.text$mn:0000669D                 pop     ecx
.text$mn:0000669E                 mov     esp, ebp
.text$mn:000066A0                 pop     ebp
.text$mn:000066A1                 retn
.text$mn:000066A1 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$mn:000066A1
.text$mn:000066A1 ; ---------------------------------------------------------------------------
.text$mn:000066A2                 align 4
.text$mn:000066A2 _text$mn        ends
.text$mn:000066A2
.text$x:000066A4 ; ===========================================================================
.text$x:000066A4
.text$x:000066A4 ; Segment type: Pure code
.text$x:000066A4 ; Segment permissions: Read/Execute
.text$x:000066A4 _text$x         segment para public 'CODE' use32
.text$x:000066A4                 assume cs:_text$x
.text$x:000066A4                 ;org 66A4h
.text$x:000066A4 ; COMDAT (pick associative to section at 6640)
.text$x:000066A4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000066A4
.text$x:000066A4 ; =============== S U B R O U T I N E =======================================
.text$x:000066A4
.text$x:000066A4
.text$x:000066A4 __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 proc near
.text$x:000066A4                                         ; DATA XREF: .xdata$x:0000C650o
.text$x:000066A4                 mov     ecx, [ebp-10h]  ; this
.text$x:000066A7                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:000066A7 __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 endp
.text$x:000066A7
.text$x:000066AC
.text$x:000066AC ; =============== S U B R O U T I N E =======================================
.text$x:000066AC
.text$x:000066AC
.text$x:000066AC __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$x:000066AC                                         ; DATA XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+5o
.text$x:000066AC
.text$x:000066AC arg_4           = dword ptr  8
.text$x:000066AC
.text$x:000066AC                 mov     edx, [esp+arg_4]
.text$x:000066B0                 lea     eax, [edx+0Ch]
.text$x:000066B3                 mov     ecx, [edx-8]
.text$x:000066B6                 xor     ecx, eax
.text$x:000066B8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000066BD                 mov     eax, offset __ehfuncinfo$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$x:000066C2                 jmp     ___CxxFrameHandler3
.text$x:000066C2 __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$x:000066C2
.text$x:000066C2 ; ---------------------------------------------------------------------------
.text$x:000066C7                 align 4
.text$x:000066C7 _text$x         ends
.text$x:000066C7
.text$mn:000066C8 ; ===========================================================================
.text$mn:000066C8
.text$mn:000066C8 ; Segment type: Pure code
.text$mn:000066C8 ; Segment permissions: Read/Execute
.text$mn:000066C8 _text$mn        segment para public 'CODE' use32
.text$mn:000066C8                 assume cs:_text$mn
.text$mn:000066C8                 ;org 66C8h
.text$mn:000066C8 ; COMDAT (pick any)
.text$mn:000066C8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000066C8
.text$mn:000066C8 ; =============== S U B R O U T I N E =======================================
.text$mn:000066C8
.text$mn:000066C8 ; Attributes: bp-based frame
.text$mn:000066C8
.text$mn:000066C8 ; public: __thiscall std::_String_val<struct std::_Simple_types<wchar_t>>::_String_val<struct std::_Simple_types<wchar_t>>(void)
.text$mn:000066C8                 public ??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$mn:000066C8 ??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ proc near
.text$mn:000066C8                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(std::allocator<wchar_t> const &)+29p
.text$mn:000066C8
.text$mn:000066C8 var_10          = dword ptr -10h
.text$mn:000066C8 var_C           = dword ptr -0Ch
.text$mn:000066C8 var_4           = dword ptr -4
.text$mn:000066C8
.text$mn:000066C8                 push    ebp
.text$mn:000066C9                 mov     ebp, esp
.text$mn:000066CB                 push    0FFFFFFFFh
.text$mn:000066CD                 push    offset __ehhandler$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$mn:000066D2                 mov     eax, large fs:0
.text$mn:000066D8                 push    eax
.text$mn:000066D9                 push    ecx
.text$mn:000066DA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000066DF                 xor     eax, ebp
.text$mn:000066E1                 push    eax
.text$mn:000066E2                 lea     eax, [ebp+var_C]
.text$mn:000066E5                 mov     large fs:0, eax
.text$mn:000066EB                 mov     [ebp+var_10], ecx
.text$mn:000066EE                 mov     ecx, [ebp+var_10] ; this
.text$mn:000066F1                 call    ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
.text$mn:000066F6                 mov     [ebp+var_4], 0
.text$mn:000066FD                 mov     eax, [ebp+var_10]
.text$mn:00006700                 mov     dword ptr [eax+14h], 0
.text$mn:00006707                 mov     ecx, [ebp+var_10]
.text$mn:0000670A                 mov     dword ptr [ecx+18h], 0
.text$mn:00006711                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006718                 mov     eax, [ebp+var_10]
.text$mn:0000671B                 mov     ecx, [ebp+var_C]
.text$mn:0000671E                 mov     large fs:0, ecx
.text$mn:00006725                 pop     ecx
.text$mn:00006726                 mov     esp, ebp
.text$mn:00006728                 pop     ebp
.text$mn:00006729                 retn
.text$mn:00006729 ??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ endp
.text$mn:00006729
.text$mn:00006729 ; ---------------------------------------------------------------------------
.text$mn:0000672A                 align 4
.text$mn:0000672A _text$mn        ends
.text$mn:0000672A
.text$x:0000672C ; ===========================================================================
.text$x:0000672C
.text$x:0000672C ; Segment type: Pure code
.text$x:0000672C ; Segment permissions: Read/Execute
.text$x:0000672C _text$x         segment para public 'CODE' use32
.text$x:0000672C                 assume cs:_text$x
.text$x:0000672C                 ;org 672Ch
.text$x:0000672C ; COMDAT (pick associative to section at 66C8)
.text$x:0000672C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000672C
.text$x:0000672C ; =============== S U B R O U T I N E =======================================
.text$x:0000672C
.text$x:0000672C
.text$x:0000672C __unwindfunclet$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0 proc near
.text$x:0000672C                                         ; DATA XREF: .xdata$x:0000C970o
.text$x:0000672C                 mov     ecx, [ebp-10h]  ; this
.text$x:0000672F                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:0000672F __unwindfunclet$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0 endp
.text$x:0000672F
.text$x:00006734
.text$x:00006734 ; =============== S U B R O U T I N E =======================================
.text$x:00006734
.text$x:00006734
.text$x:00006734 __ehhandler$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ proc near
.text$x:00006734                                         ; DATA XREF: std::_String_val<std::_Simple_types<wchar_t>>::_String_val<std::_Simple_types<wchar_t>>(void)+5o
.text$x:00006734
.text$x:00006734 arg_4           = dword ptr  8
.text$x:00006734
.text$x:00006734                 mov     edx, [esp+arg_4]
.text$x:00006738                 lea     eax, [edx+0Ch]
.text$x:0000673B                 mov     ecx, [edx-8]
.text$x:0000673E                 xor     ecx, eax
.text$x:00006740                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006745                 mov     eax, offset __ehfuncinfo$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$x:0000674A                 jmp     ___CxxFrameHandler3
.text$x:0000674A __ehhandler$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ endp
.text$x:0000674A
.text$x:0000674A ; ---------------------------------------------------------------------------
.text$x:0000674F                 align 10h
.text$x:0000674F _text$x         ends
.text$x:0000674F
.text$mn:00006750 ; ===========================================================================
.text$mn:00006750
.text$mn:00006750 ; Segment type: Pure code
.text$mn:00006750 ; Segment permissions: Read/Execute
.text$mn:00006750 _text$mn        segment para public 'CODE' use32
.text$mn:00006750                 assume cs:_text$mn
.text$mn:00006750                 ;org 6750h
.text$mn:00006750 ; COMDAT (pick any)
.text$mn:00006750                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006750
.text$mn:00006750 ; =============== S U B R O U T I N E =======================================
.text$mn:00006750
.text$mn:00006750 ; Attributes: bp-based frame
.text$mn:00006750
.text$mn:00006750 ; public: __thiscall std::_Temp_iterator<int>::_Temp_iterator<int>(class std::_Temp_iterator<int> const &)
.text$mn:00006750                 public ??0?$_Temp_iterator@H@std@@QAE@ABV01@@Z
.text$mn:00006750 ??0?$_Temp_iterator@H@std@@QAE@ABV01@@Z proc near
.text$mn:00006750                                         ; CODE XREF: std::_Buffered_merge<int *,int,int,BufferEquivalent>(int *,int *,int *,int,int,std::_Temp_iterator<int> &,BufferEquivalent)+C1p
.text$mn:00006750                                         ; std::_Buffered_merge<int *,int,int,BufferEquivalent>(int *,int *,int *,int,int,std::_Temp_iterator<int> &,BufferEquivalent)+165p ...
.text$mn:00006750
.text$mn:00006750 var_4           = dword ptr -4
.text$mn:00006750 arg_0           = dword ptr  8
.text$mn:00006750
.text$mn:00006750                 push    ebp
.text$mn:00006751                 mov     ebp, esp
.text$mn:00006753                 push    ecx
.text$mn:00006754                 mov     [ebp+var_4], ecx
.text$mn:00006757                 mov     eax, [ebp+var_4]
.text$mn:0000675A                 mov     dword ptr [eax], 0
.text$mn:00006760                 mov     ecx, [ebp+var_4]
.text$mn:00006763                 mov     dword ptr [ecx+4], 0
.text$mn:0000676A                 mov     edx, [ebp+var_4]
.text$mn:0000676D                 mov     dword ptr [edx+8], 0
.text$mn:00006774                 mov     eax, [ebp+var_4]
.text$mn:00006777                 mov     dword ptr [eax+0Ch], 0
.text$mn:0000677E                 mov     ecx, [ebp+arg_0]
.text$mn:00006781                 push    ecx
.text$mn:00006782                 mov     ecx, [ebp+var_4]
.text$mn:00006785                 call    ??4?$_Temp_iterator@H@std@@QAEAAV01@ABV01@@Z ; std::_Temp_iterator<int>::operator=(std::_Temp_iterator<int> const &)
.text$mn:0000678A                 mov     eax, [ebp+var_4]
.text$mn:0000678D                 mov     esp, ebp
.text$mn:0000678F                 pop     ebp
.text$mn:00006790                 retn    4
.text$mn:00006790 ??0?$_Temp_iterator@H@std@@QAE@ABV01@@Z endp
.text$mn:00006790
.text$mn:00006790 ; ---------------------------------------------------------------------------
.text$mn:00006793                 align 4
.text$mn:00006793 _text$mn        ends
.text$mn:00006793
.text$mn:00006794 ; ===========================================================================
.text$mn:00006794
.text$mn:00006794 ; Segment type: Pure code
.text$mn:00006794 ; Segment permissions: Read/Execute
.text$mn:00006794 _text$mn        segment para public 'CODE' use32
.text$mn:00006794                 assume cs:_text$mn
.text$mn:00006794                 ;org 6794h
.text$mn:00006794 ; COMDAT (pick any)
.text$mn:00006794                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006794
.text$mn:00006794 ; =============== S U B R O U T I N E =======================================
.text$mn:00006794
.text$mn:00006794 ; Attributes: bp-based frame
.text$mn:00006794
.text$mn:00006794 ; public: __thiscall std::_Temp_iterator<int>::_Temp_iterator<int>(int)
.text$mn:00006794                 public ??0?$_Temp_iterator@H@std@@QAE@H@Z
.text$mn:00006794 ??0?$_Temp_iterator@H@std@@QAE@H@Z proc near
.text$mn:00006794                                         ; CODE XREF: std::_Stable_sort<int *,int,int,BufferEquivalent>(int *,int *,int *,int *,BufferEquivalent)+4Fp
.text$mn:00006794
.text$mn:00006794 var_4           = dword ptr -4
.text$mn:00006794 arg_0           = dword ptr  8
.text$mn:00006794
.text$mn:00006794                 push    ebp
.text$mn:00006795                 mov     ebp, esp
.text$mn:00006797                 push    ecx
.text$mn:00006798                 mov     [ebp+var_4], ecx
.text$mn:0000679B                 mov     eax, [ebp+var_4]
.text$mn:0000679E                 mov     dword ptr [eax], 0
.text$mn:000067A4                 mov     ecx, [ebp+var_4]
.text$mn:000067A7                 mov     dword ptr [ecx+4], 0
.text$mn:000067AE                 mov     edx, [ebp+var_4]
.text$mn:000067B1                 mov     dword ptr [edx+8], 0
.text$mn:000067B8                 mov     eax, [ebp+var_4]
.text$mn:000067BB                 mov     ecx, [ebp+arg_0]
.text$mn:000067BE                 mov     [eax+0Ch], ecx
.text$mn:000067C1                 mov     edx, [ebp+var_4]
.text$mn:000067C4                 mov     eax, [ebp+var_4]
.text$mn:000067C7                 mov     [eax+10h], edx
.text$mn:000067CA                 mov     eax, [ebp+var_4]
.text$mn:000067CD                 mov     esp, ebp
.text$mn:000067CF                 pop     ebp
.text$mn:000067D0                 retn    4
.text$mn:000067D0 ??0?$_Temp_iterator@H@std@@QAE@H@Z endp
.text$mn:000067D0
.text$mn:000067D0 ; ---------------------------------------------------------------------------
.text$mn:000067D3                 align 4
.text$mn:000067D3 _text$mn        ends
.text$mn:000067D3
.text$mn:000067D4 ; ===========================================================================
.text$mn:000067D4
.text$mn:000067D4 ; Segment type: Pure code
.text$mn:000067D4 ; Segment permissions: Read/Execute
.text$mn:000067D4 _text$mn        segment para public 'CODE' use32
.text$mn:000067D4                 assume cs:_text$mn
.text$mn:000067D4                 ;org 67D4h
.text$mn:000067D4 ; COMDAT (pick any)
.text$mn:000067D4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000067D4
.text$mn:000067D4 ; =============== S U B R O U T I N E =======================================
.text$mn:000067D4
.text$mn:000067D4 ; Attributes: bp-based frame
.text$mn:000067D4
.text$mn:000067D4 ; public: __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<int, class std::allocator<int>>>::_Vector_alloc<0, struct std::_Vec_base_types<int, class std::allocator<int>>>(class std::allocator<int> const &)
.text$mn:000067D4                 public ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@ABV?$allocator@H@1@@Z
.text$mn:000067D4 ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@ABV?$allocator@H@1@@Z proc near
.text$mn:000067D4                                         ; CODE XREF: std::vector<int,std::allocator<int>>::vector<int,std::allocator<int>>(void)+34p
.text$mn:000067D4
.text$mn:000067D4 var_10          = dword ptr -10h
.text$mn:000067D4 var_C           = dword ptr -0Ch
.text$mn:000067D4 var_4           = dword ptr -4
.text$mn:000067D4
.text$mn:000067D4                 push    ebp
.text$mn:000067D5                 mov     ebp, esp
.text$mn:000067D7                 push    0FFFFFFFFh
.text$mn:000067D9                 push    offset __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@ABV?$allocator@H@1@@Z
.text$mn:000067DE                 mov     eax, large fs:0
.text$mn:000067E4                 push    eax
.text$mn:000067E5                 push    ecx
.text$mn:000067E6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000067EB                 xor     eax, ebp
.text$mn:000067ED                 push    eax
.text$mn:000067EE                 lea     eax, [ebp+var_C]
.text$mn:000067F1                 mov     large fs:0, eax
.text$mn:000067F7                 mov     [ebp+var_10], ecx
.text$mn:000067FA                 mov     ecx, [ebp+var_10]
.text$mn:000067FD                 call    ??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<int>>::_Vector_val<std::_Simple_types<int>>(void)
.text$mn:00006802                 mov     [ebp+var_4], 0
.text$mn:00006809                 mov     ecx, [ebp+var_10]
.text$mn:0000680C                 call    ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>::_Alloc_proxy(void)
.text$mn:00006811                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006818                 mov     eax, [ebp+var_10]
.text$mn:0000681B                 mov     ecx, [ebp+var_C]
.text$mn:0000681E                 mov     large fs:0, ecx
.text$mn:00006825                 pop     ecx
.text$mn:00006826                 mov     esp, ebp
.text$mn:00006828                 pop     ebp
.text$mn:00006829                 retn    4
.text$mn:00006829 ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@ABV?$allocator@H@1@@Z endp
.text$mn:00006829
.text$mn:00006829 _text$mn        ends
.text$mn:00006829
.text$x:0000682C ; ===========================================================================
.text$x:0000682C
.text$x:0000682C ; Segment type: Pure code
.text$x:0000682C ; Segment permissions: Read/Execute
.text$x:0000682C _text$x         segment para public 'CODE' use32
.text$x:0000682C                 assume cs:_text$x
.text$x:0000682C                 ;org 682Ch
.text$x:0000682C ; COMDAT (pick associative to section at 67D4)
.text$x:0000682C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000682C
.text$x:0000682C ; =============== S U B R O U T I N E =======================================
.text$x:0000682C
.text$x:0000682C
.text$x:0000682C __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@ABV?$allocator@H@1@@Z$0 proc near
.text$x:0000682C                                         ; DATA XREF: .xdata$x:0000CD80o
.text$x:0000682C                 mov     ecx, [ebp-10h]
.text$x:0000682F                 jmp     ??1?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<int>>::~_Vector_val<std::_Simple_types<int>>(void)
.text$x:0000682F __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@ABV?$allocator@H@1@@Z$0 endp
.text$x:0000682F
.text$x:00006834
.text$x:00006834 ; =============== S U B R O U T I N E =======================================
.text$x:00006834
.text$x:00006834
.text$x:00006834 __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@ABV?$allocator@H@1@@Z proc near
.text$x:00006834                                         ; DATA XREF: std::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>(std::allocator<int> const &)+5o
.text$x:00006834
.text$x:00006834 arg_4           = dword ptr  8
.text$x:00006834
.text$x:00006834                 mov     edx, [esp+arg_4]
.text$x:00006838                 lea     eax, [edx+0Ch]
.text$x:0000683B                 mov     ecx, [edx-8]
.text$x:0000683E                 xor     ecx, eax
.text$x:00006840                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006845                 mov     eax, offset __ehfuncinfo$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@ABV?$allocator@H@1@@Z
.text$x:0000684A                 jmp     ___CxxFrameHandler3
.text$x:0000684A __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@ABV?$allocator@H@1@@Z endp
.text$x:0000684A
.text$x:0000684A ; ---------------------------------------------------------------------------
.text$x:0000684F                 align 10h
.text$x:0000684F _text$x         ends
.text$x:0000684F
.text$mn:00006850 ; ===========================================================================
.text$mn:00006850
.text$mn:00006850 ; Segment type: Pure code
.text$mn:00006850 ; Segment permissions: Read/Execute
.text$mn:00006850 _text$mn        segment para public 'CODE' use32
.text$mn:00006850                 assume cs:_text$mn
.text$mn:00006850                 ;org 6850h
.text$mn:00006850 ; COMDAT (pick any)
.text$mn:00006850                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006850
.text$mn:00006850 ; =============== S U B R O U T I N E =======================================
.text$mn:00006850
.text$mn:00006850 ; Attributes: bp-based frame
.text$mn:00006850
.text$mn:00006850 ; public: __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<wchar_t, class std::allocator<wchar_t>>>::_Vector_alloc<0, struct std::_Vec_base_types<wchar_t, class std::allocator<wchar_t>>>(class std::allocator<wchar_t> const &)
.text$mn:00006850                 public ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z
.text$mn:00006850 ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z proc near
.text$mn:00006850                                         ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::vector<wchar_t,std::allocator<wchar_t>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)+3Bp
.text$mn:00006850
.text$mn:00006850 var_10          = dword ptr -10h
.text$mn:00006850 var_C           = dword ptr -0Ch
.text$mn:00006850 var_4           = dword ptr -4
.text$mn:00006850
.text$mn:00006850                 push    ebp
.text$mn:00006851                 mov     ebp, esp
.text$mn:00006853                 push    0FFFFFFFFh
.text$mn:00006855                 push    offset __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z
.text$mn:0000685A                 mov     eax, large fs:0
.text$mn:00006860                 push    eax
.text$mn:00006861                 push    ecx
.text$mn:00006862                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006867                 xor     eax, ebp
.text$mn:00006869                 push    eax
.text$mn:0000686A                 lea     eax, [ebp+var_C]
.text$mn:0000686D                 mov     large fs:0, eax
.text$mn:00006873                 mov     [ebp+var_10], ecx
.text$mn:00006876                 mov     ecx, [ebp+var_10]
.text$mn:00006879                 call    ??0?$_Vector_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<wchar_t>>::_Vector_val<std::_Simple_types<wchar_t>>(void)
.text$mn:0000687E                 mov     [ebp+var_4], 0
.text$mn:00006885                 mov     ecx, [ebp+var_10]
.text$mn:00006888                 call    ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<0,std::_Vec_base_types<wchar_t,std::allocator<wchar_t>>>::_Alloc_proxy(void)
.text$mn:0000688D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006894                 mov     eax, [ebp+var_10]
.text$mn:00006897                 mov     ecx, [ebp+var_C]
.text$mn:0000689A                 mov     large fs:0, ecx
.text$mn:000068A1                 pop     ecx
.text$mn:000068A2                 mov     esp, ebp
.text$mn:000068A4                 pop     ebp
.text$mn:000068A5                 retn    4
.text$mn:000068A5 ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z endp
.text$mn:000068A5
.text$mn:000068A5 _text$mn        ends
.text$mn:000068A5
.text$x:000068A8 ; ===========================================================================
.text$x:000068A8
.text$x:000068A8 ; Segment type: Pure code
.text$x:000068A8 ; Segment permissions: Read/Execute
.text$x:000068A8 _text$x         segment para public 'CODE' use32
.text$x:000068A8                 assume cs:_text$x
.text$x:000068A8                 ;org 68A8h
.text$x:000068A8 ; COMDAT (pick associative to section at 6850)
.text$x:000068A8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000068A8
.text$x:000068A8 ; =============== S U B R O U T I N E =======================================
.text$x:000068A8
.text$x:000068A8
.text$x:000068A8 __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z$0 proc near
.text$x:000068A8                                         ; DATA XREF: .xdata$x:0000D4FCo
.text$x:000068A8                 mov     ecx, [ebp-10h]
.text$x:000068AB                 jmp     ??1?$_Vector_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<wchar_t>>::~_Vector_val<std::_Simple_types<wchar_t>>(void)
.text$x:000068AB __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z$0 endp
.text$x:000068AB
.text$x:000068B0
.text$x:000068B0 ; =============== S U B R O U T I N E =======================================
.text$x:000068B0
.text$x:000068B0
.text$x:000068B0 __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z proc near
.text$x:000068B0                                         ; DATA XREF: std::_Vector_alloc<0,std::_Vec_base_types<wchar_t,std::allocator<wchar_t>>>::_Vector_alloc<0,std::_Vec_base_types<wchar_t,std::allocator<wchar_t>>>(std::allocator<wchar_t> const &)+5o
.text$x:000068B0
.text$x:000068B0 arg_4           = dword ptr  8
.text$x:000068B0
.text$x:000068B0                 mov     edx, [esp+arg_4]
.text$x:000068B4                 lea     eax, [edx+0Ch]
.text$x:000068B7                 mov     ecx, [edx-8]
.text$x:000068BA                 xor     ecx, eax
.text$x:000068BC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000068C1                 mov     eax, offset __ehfuncinfo$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z
.text$x:000068C6                 jmp     ___CxxFrameHandler3
.text$x:000068C6 __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z endp
.text$x:000068C6
.text$x:000068C6 ; ---------------------------------------------------------------------------
.text$x:000068CB                 align 4
.text$x:000068CB _text$x         ends
.text$x:000068CB
.text$mn:000068CC ; ===========================================================================
.text$mn:000068CC
.text$mn:000068CC ; Segment type: Pure code
.text$mn:000068CC ; Segment permissions: Read/Execute
.text$mn:000068CC _text$mn        segment para public 'CODE' use32
.text$mn:000068CC                 assume cs:_text$mn
.text$mn:000068CC                 ;org 68CCh
.text$mn:000068CC ; COMDAT (pick any)
.text$mn:000068CC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000068CC
.text$mn:000068CC ; =============== S U B R O U T I N E =======================================
.text$mn:000068CC
.text$mn:000068CC ; Attributes: bp-based frame
.text$mn:000068CC
.text$mn:000068CC ; int __stdcall std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>(struct std::_Iterator_base12 *)
.text$mn:000068CC                 public ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z
.text$mn:000068CC ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z proc near
.text$mn:000068CC                                         ; CODE XREF: WindowsDlg::doClose(void)+317p
.text$mn:000068CC                                         ; WindowsDlg::doClose(void)+3C7p ...
.text$mn:000068CC
.text$mn:000068CC var_10          = dword ptr -10h
.text$mn:000068CC var_C           = dword ptr -0Ch
.text$mn:000068CC var_4           = dword ptr -4
.text$mn:000068CC arg_0           = dword ptr  8
.text$mn:000068CC
.text$mn:000068CC                 push    ebp
.text$mn:000068CD                 mov     ebp, esp
.text$mn:000068CF                 push    0FFFFFFFFh
.text$mn:000068D1                 push    offset __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z
.text$mn:000068D6                 mov     eax, large fs:0
.text$mn:000068DC                 push    eax
.text$mn:000068DD                 push    ecx
.text$mn:000068DE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000068E3                 xor     eax, ebp
.text$mn:000068E5                 push    eax
.text$mn:000068E6                 lea     eax, [ebp+var_C]
.text$mn:000068E9                 mov     large fs:0, eax
.text$mn:000068EF                 mov     [ebp+var_10], ecx
.text$mn:000068F2                 mov     eax, [ebp+arg_0]
.text$mn:000068F5                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:000068F6                 mov     ecx, [ebp+var_10]
.text$mn:000068F9                 call    ??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@ABU01@@Z ; std::_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>(std::_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12> const &)
.text$mn:000068FE                 mov     [ebp+var_4], 0
.text$mn:00006905                 mov     ecx, [ebp+var_10]
.text$mn:00006908                 mov     edx, [ebp+arg_0]
.text$mn:0000690B                 mov     eax, [edx+8]
.text$mn:0000690E                 mov     [ecx+8], eax
.text$mn:00006911                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006918                 mov     eax, [ebp+var_10]
.text$mn:0000691B                 mov     ecx, [ebp+var_C]
.text$mn:0000691E                 mov     large fs:0, ecx
.text$mn:00006925                 pop     ecx
.text$mn:00006926                 mov     esp, ebp
.text$mn:00006928                 pop     ebp
.text$mn:00006929                 retn    4
.text$mn:00006929 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z endp
.text$mn:00006929
.text$mn:00006929 _text$mn        ends
.text$mn:00006929
.text$x:0000692C ; ===========================================================================
.text$x:0000692C
.text$x:0000692C ; Segment type: Pure code
.text$x:0000692C ; Segment permissions: Read/Execute
.text$x:0000692C _text$x         segment para public 'CODE' use32
.text$x:0000692C                 assume cs:_text$x
.text$x:0000692C                 ;org 692Ch
.text$x:0000692C ; COMDAT (pick associative to section at 68CC)
.text$x:0000692C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000692C
.text$x:0000692C ; =============== S U B R O U T I N E =======================================
.text$x:0000692C
.text$x:0000692C
.text$x:0000692C __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z$0 proc near
.text$x:0000692C                                         ; DATA XREF: .xdata$x:0000D174o
.text$x:0000692C                 mov     ecx, [ebp-10h]
.text$x:0000692F                 jmp     ??1?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>(void)
.text$x:0000692F __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z$0 endp
.text$x:0000692F
.text$x:00006934
.text$x:00006934 ; =============== S U B R O U T I N E =======================================
.text$x:00006934
.text$x:00006934
.text$x:00006934 __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z proc near
.text$x:00006934                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>> const &)+5o
.text$x:00006934
.text$x:00006934 arg_4           = dword ptr  8
.text$x:00006934
.text$x:00006934                 mov     edx, [esp+arg_4]
.text$x:00006938                 lea     eax, [edx+0Ch]
.text$x:0000693B                 mov     ecx, [edx-8]
.text$x:0000693E                 xor     ecx, eax
.text$x:00006940                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006945                 mov     eax, offset __ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z
.text$x:0000694A                 jmp     ___CxxFrameHandler3
.text$x:0000694A __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z endp
.text$x:0000694A
.text$x:0000694A ; ---------------------------------------------------------------------------
.text$x:0000694F                 align 10h
.text$x:0000694F _text$x         ends
.text$x:0000694F
.text$mn:00006950 ; ===========================================================================
.text$mn:00006950
.text$mn:00006950 ; Segment type: Pure code
.text$mn:00006950 ; Segment permissions: Read/Execute
.text$mn:00006950 _text$mn        segment para public 'CODE' use32
.text$mn:00006950                 assume cs:_text$mn
.text$mn:00006950                 ;org 6950h
.text$mn:00006950 ; COMDAT (pick any)
.text$mn:00006950                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006950
.text$mn:00006950 ; =============== S U B R O U T I N E =======================================
.text$mn:00006950
.text$mn:00006950 ; Attributes: bp-based frame
.text$mn:00006950
.text$mn:00006950 ; int __stdcall std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>(int, struct std::_Container_base12 *)
.text$mn:00006950                 public ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z
.text$mn:00006950 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z proc near
.text$mn:00006950                                         ; CODE XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(int *,std::_Container_base12 const *)+31p
.text$mn:00006950
.text$mn:00006950 var_10          = dword ptr -10h
.text$mn:00006950 var_C           = dword ptr -0Ch
.text$mn:00006950 var_4           = dword ptr -4
.text$mn:00006950 arg_0           = dword ptr  8
.text$mn:00006950 arg_4           = dword ptr  0Ch
.text$mn:00006950
.text$mn:00006950                 push    ebp
.text$mn:00006951                 mov     ebp, esp
.text$mn:00006953                 push    0FFFFFFFFh
.text$mn:00006955                 push    offset __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z
.text$mn:0000695A                 mov     eax, large fs:0
.text$mn:00006960                 push    eax
.text$mn:00006961                 push    ecx
.text$mn:00006962                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006967                 xor     eax, ebp
.text$mn:00006969                 push    eax
.text$mn:0000696A                 lea     eax, [ebp+var_C]
.text$mn:0000696D                 mov     large fs:0, eax
.text$mn:00006973                 mov     [ebp+var_10], ecx
.text$mn:00006976                 mov     ecx, [ebp+var_10]
.text$mn:00006979                 call    ??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>(void)
.text$mn:0000697E                 mov     [ebp+var_4], 0
.text$mn:00006985                 mov     eax, [ebp+var_10]
.text$mn:00006988                 mov     ecx, [ebp+arg_0]
.text$mn:0000698B                 mov     [eax+8], ecx
.text$mn:0000698E                 mov     edx, [ebp+arg_4]
.text$mn:00006991                 push    edx             ; struct std::_Container_base12 *
.text$mn:00006992                 mov     ecx, [ebp+var_10] ; this
.text$mn:00006995                 call    ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt(std::_Container_base12 const *)
.text$mn:0000699A                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000069A1                 mov     eax, [ebp+var_10]
.text$mn:000069A4                 mov     ecx, [ebp+var_C]
.text$mn:000069A7                 mov     large fs:0, ecx
.text$mn:000069AE                 pop     ecx
.text$mn:000069AF                 mov     esp, ebp
.text$mn:000069B1                 pop     ebp
.text$mn:000069B2                 retn    8
.text$mn:000069B2 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z endp
.text$mn:000069B2
.text$mn:000069B2 ; ---------------------------------------------------------------------------
.text$mn:000069B5                 align 4
.text$mn:000069B5 _text$mn        ends
.text$mn:000069B5
.text$x:000069B8 ; ===========================================================================
.text$x:000069B8
.text$x:000069B8 ; Segment type: Pure code
.text$x:000069B8 ; Segment permissions: Read/Execute
.text$x:000069B8 _text$x         segment para public 'CODE' use32
.text$x:000069B8                 assume cs:_text$x
.text$x:000069B8                 ;org 69B8h
.text$x:000069B8 ; COMDAT (pick associative to section at 6950)
.text$x:000069B8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000069B8
.text$x:000069B8 ; =============== S U B R O U T I N E =======================================
.text$x:000069B8
.text$x:000069B8
.text$x:000069B8 __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z$0 proc near
.text$x:000069B8                                         ; DATA XREF: .xdata$x:0000D11Co
.text$x:000069B8                 mov     ecx, [ebp-10h]
.text$x:000069BB                 jmp     ??1?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>(void)
.text$x:000069BB __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z$0 endp
.text$x:000069BB
.text$x:000069C0
.text$x:000069C0 ; =============== S U B R O U T I N E =======================================
.text$x:000069C0
.text$x:000069C0
.text$x:000069C0 __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z proc near
.text$x:000069C0                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>(int *,std::_Container_base12 const *)+5o
.text$x:000069C0
.text$x:000069C0 arg_4           = dword ptr  8
.text$x:000069C0
.text$x:000069C0                 mov     edx, [esp+arg_4]
.text$x:000069C4                 lea     eax, [edx+0Ch]
.text$x:000069C7                 mov     ecx, [edx-8]
.text$x:000069CA                 xor     ecx, eax
.text$x:000069CC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000069D1                 mov     eax, offset __ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z
.text$x:000069D6                 jmp     ___CxxFrameHandler3
.text$x:000069D6 __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z endp
.text$x:000069D6
.text$x:000069D6 ; ---------------------------------------------------------------------------
.text$x:000069DB                 align 4
.text$x:000069DB _text$x         ends
.text$x:000069DB
.text$mn:000069DC ; ===========================================================================
.text$mn:000069DC
.text$mn:000069DC ; Segment type: Pure code
.text$mn:000069DC ; Segment permissions: Read/Execute
.text$mn:000069DC _text$mn        segment para public 'CODE' use32
.text$mn:000069DC                 assume cs:_text$mn
.text$mn:000069DC                 ;org 69DCh
.text$mn:000069DC ; COMDAT (pick any)
.text$mn:000069DC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000069DC
.text$mn:000069DC ; =============== S U B R O U T I N E =======================================
.text$mn:000069DC
.text$mn:000069DC ; Attributes: bp-based frame
.text$mn:000069DC
.text$mn:000069DC ; int __stdcall std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(struct std::_Iterator_base12 *)
.text$mn:000069DC                 public ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z
.text$mn:000069DC ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z proc near
.text$mn:000069DC                                         ; CODE XREF: std::_Debug_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,wchar_t const *,uint)+56p
.text$mn:000069DC                                         ; std::_Debug_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,wchar_t const *,uint)+74p ...
.text$mn:000069DC
.text$mn:000069DC var_10          = dword ptr -10h
.text$mn:000069DC var_C           = dword ptr -0Ch
.text$mn:000069DC var_4           = dword ptr -4
.text$mn:000069DC arg_0           = dword ptr  8
.text$mn:000069DC
.text$mn:000069DC                 push    ebp
.text$mn:000069DD                 mov     ebp, esp
.text$mn:000069DF                 push    0FFFFFFFFh
.text$mn:000069E1                 push    offset __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z
.text$mn:000069E6                 mov     eax, large fs:0
.text$mn:000069EC                 push    eax
.text$mn:000069ED                 push    ecx
.text$mn:000069EE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000069F3                 xor     eax, ebp
.text$mn:000069F5                 push    eax
.text$mn:000069F6                 lea     eax, [ebp+var_C]
.text$mn:000069F9                 mov     large fs:0, eax
.text$mn:000069FF                 mov     [ebp+var_10], ecx
.text$mn:00006A02                 mov     eax, [ebp+arg_0]
.text$mn:00006A05                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00006A06                 mov     ecx, [ebp+var_10]
.text$mn:00006A09                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>> const &)
.text$mn:00006A0E                 mov     [ebp+var_4], 0
.text$mn:00006A15                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006A1C                 mov     eax, [ebp+var_10]
.text$mn:00006A1F                 mov     ecx, [ebp+var_C]
.text$mn:00006A22                 mov     large fs:0, ecx
.text$mn:00006A29                 pop     ecx
.text$mn:00006A2A                 mov     esp, ebp
.text$mn:00006A2C                 pop     ebp
.text$mn:00006A2D                 retn    4
.text$mn:00006A2D ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z endp
.text$mn:00006A2D
.text$mn:00006A2D _text$mn        ends
.text$mn:00006A2D
.text$x:00006A30 ; ===========================================================================
.text$x:00006A30
.text$x:00006A30 ; Segment type: Pure code
.text$x:00006A30 ; Segment permissions: Read/Execute
.text$x:00006A30 _text$x         segment para public 'CODE' use32
.text$x:00006A30                 assume cs:_text$x
.text$x:00006A30                 ;org 6A30h
.text$x:00006A30 ; COMDAT (pick associative to section at 69DC)
.text$x:00006A30                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00006A30
.text$x:00006A30 ; =============== S U B R O U T I N E =======================================
.text$x:00006A30
.text$x:00006A30
.text$x:00006A30 __unwindfunclet$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z$0 proc near
.text$x:00006A30                                         ; DATA XREF: .xdata$x:0000D1F8o
.text$x:00006A30                 mov     ecx, [ebp-10h]
.text$x:00006A33                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$x:00006A33 __unwindfunclet$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z$0 endp
.text$x:00006A33
.text$x:00006A38
.text$x:00006A38 ; =============== S U B R O U T I N E =======================================
.text$x:00006A38
.text$x:00006A38
.text$x:00006A38 __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z proc near
.text$x:00006A38                                         ; DATA XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>> const &)+5o
.text$x:00006A38
.text$x:00006A38 arg_4           = dword ptr  8
.text$x:00006A38
.text$x:00006A38                 mov     edx, [esp+arg_4]
.text$x:00006A3C                 lea     eax, [edx+0Ch]
.text$x:00006A3F                 mov     ecx, [edx-8]
.text$x:00006A42                 xor     ecx, eax
.text$x:00006A44                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006A49                 mov     eax, offset __ehfuncinfo$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z
.text$x:00006A4E                 jmp     ___CxxFrameHandler3
.text$x:00006A4E __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z endp
.text$x:00006A4E
.text$x:00006A4E ; ---------------------------------------------------------------------------
.text$x:00006A53                 align 4
.text$x:00006A53 _text$x         ends
.text$x:00006A53
.text$mn:00006A54 ; ===========================================================================
.text$mn:00006A54
.text$mn:00006A54 ; Segment type: Pure code
.text$mn:00006A54 ; Segment permissions: Read/Execute
.text$mn:00006A54 _text$mn        segment para public 'CODE' use32
.text$mn:00006A54                 assume cs:_text$mn
.text$mn:00006A54                 ;org 6A54h
.text$mn:00006A54 ; COMDAT (pick any)
.text$mn:00006A54                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006A54
.text$mn:00006A54 ; =============== S U B R O U T I N E =======================================
.text$mn:00006A54
.text$mn:00006A54 ; Attributes: bp-based frame
.text$mn:00006A54
.text$mn:00006A54 ; int __stdcall std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(int, struct std::_Container_base12 *)
.text$mn:00006A54                 public ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z
.text$mn:00006A54 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z proc near
.text$mn:00006A54                                         ; CODE XREF: std::vector<int,std::allocator<int>>::_Make_iter(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>)+41p
.text$mn:00006A54                                         ; std::vector<int,std::allocator<int>>::begin(void)+3Dp ...
.text$mn:00006A54
.text$mn:00006A54 var_10          = dword ptr -10h
.text$mn:00006A54 var_C           = dword ptr -0Ch
.text$mn:00006A54 var_4           = dword ptr -4
.text$mn:00006A54 arg_0           = dword ptr  8
.text$mn:00006A54 arg_4           = dword ptr  0Ch
.text$mn:00006A54
.text$mn:00006A54                 push    ebp
.text$mn:00006A55                 mov     ebp, esp
.text$mn:00006A57                 push    0FFFFFFFFh
.text$mn:00006A59                 push    offset __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z
.text$mn:00006A5E                 mov     eax, large fs:0
.text$mn:00006A64                 push    eax
.text$mn:00006A65                 push    ecx
.text$mn:00006A66                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006A6B                 xor     eax, ebp
.text$mn:00006A6D                 push    eax
.text$mn:00006A6E                 lea     eax, [ebp+var_C]
.text$mn:00006A71                 mov     large fs:0, eax
.text$mn:00006A77                 mov     [ebp+var_10], ecx
.text$mn:00006A7A                 mov     eax, [ebp+arg_4]
.text$mn:00006A7D                 push    eax             ; struct std::_Container_base12 *
.text$mn:00006A7E                 mov     ecx, [ebp+arg_0]
.text$mn:00006A81                 push    ecx             ; int
.text$mn:00006A82                 mov     ecx, [ebp+var_10]
.text$mn:00006A85                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>(int *,std::_Container_base12 const *)
.text$mn:00006A8A                 mov     [ebp+var_4], 0
.text$mn:00006A91                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006A98                 mov     eax, [ebp+var_10]
.text$mn:00006A9B                 mov     ecx, [ebp+var_C]
.text$mn:00006A9E                 mov     large fs:0, ecx
.text$mn:00006AA5                 pop     ecx
.text$mn:00006AA6                 mov     esp, ebp
.text$mn:00006AA8                 pop     ebp
.text$mn:00006AA9                 retn    8
.text$mn:00006AA9 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z endp
.text$mn:00006AA9
.text$mn:00006AA9 _text$mn        ends
.text$mn:00006AA9
.text$x:00006AAC ; ===========================================================================
.text$x:00006AAC
.text$x:00006AAC ; Segment type: Pure code
.text$x:00006AAC ; Segment permissions: Read/Execute
.text$x:00006AAC _text$x         segment para public 'CODE' use32
.text$x:00006AAC                 assume cs:_text$x
.text$x:00006AAC                 ;org 6AACh
.text$x:00006AAC ; COMDAT (pick associative to section at 6A54)
.text$x:00006AAC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00006AAC
.text$x:00006AAC ; =============== S U B R O U T I N E =======================================
.text$x:00006AAC
.text$x:00006AAC
.text$x:00006AAC __unwindfunclet$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z$0 proc near
.text$x:00006AAC                                         ; DATA XREF: .xdata$x:0000D1A0o
.text$x:00006AAC                 mov     ecx, [ebp-10h]
.text$x:00006AAF                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$x:00006AAF __unwindfunclet$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z$0 endp
.text$x:00006AAF
.text$x:00006AB4
.text$x:00006AB4 ; =============== S U B R O U T I N E =======================================
.text$x:00006AB4
.text$x:00006AB4
.text$x:00006AB4 __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z proc near
.text$x:00006AB4                                         ; DATA XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(int *,std::_Container_base12 const *)+5o
.text$x:00006AB4
.text$x:00006AB4 arg_4           = dword ptr  8
.text$x:00006AB4
.text$x:00006AB4                 mov     edx, [esp+arg_4]
.text$x:00006AB8                 lea     eax, [edx+0Ch]
.text$x:00006ABB                 mov     ecx, [edx-8]
.text$x:00006ABE                 xor     ecx, eax
.text$x:00006AC0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006AC5                 mov     eax, offset __ehfuncinfo$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z
.text$x:00006ACA                 jmp     ___CxxFrameHandler3
.text$x:00006ACA __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z endp
.text$x:00006ACA
.text$x:00006ACA ; ---------------------------------------------------------------------------
.text$x:00006ACF                 align 10h
.text$x:00006ACF _text$x         ends
.text$x:00006ACF
.text$mn:00006AD0 ; ===========================================================================
.text$mn:00006AD0
.text$mn:00006AD0 ; Segment type: Pure code
.text$mn:00006AD0 ; Segment permissions: Read/Execute
.text$mn:00006AD0 _text$mn        segment para public 'CODE' use32
.text$mn:00006AD0                 assume cs:_text$mn
.text$mn:00006AD0                 ;org 6AD0h
.text$mn:00006AD0 ; COMDAT (pick any)
.text$mn:00006AD0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006AD0
.text$mn:00006AD0 ; =============== S U B R O U T I N E =======================================
.text$mn:00006AD0
.text$mn:00006AD0 ; Attributes: bp-based frame
.text$mn:00006AD0
.text$mn:00006AD0 ; public: __thiscall std::_Vector_val<struct std::_Simple_types<int>>::_Vector_val<struct std::_Simple_types<int>>(void)
.text$mn:00006AD0                 public ??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ
.text$mn:00006AD0 ??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ proc near
.text$mn:00006AD0                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>(std::allocator<int> const &)+29p
.text$mn:00006AD0
.text$mn:00006AD0 var_10          = dword ptr -10h
.text$mn:00006AD0 var_C           = dword ptr -0Ch
.text$mn:00006AD0 var_4           = dword ptr -4
.text$mn:00006AD0
.text$mn:00006AD0                 push    ebp
.text$mn:00006AD1                 mov     ebp, esp
.text$mn:00006AD3                 push    0FFFFFFFFh
.text$mn:00006AD5                 push    offset __ehhandler$??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ
.text$mn:00006ADA                 mov     eax, large fs:0
.text$mn:00006AE0                 push    eax
.text$mn:00006AE1                 push    ecx
.text$mn:00006AE2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006AE7                 xor     eax, ebp
.text$mn:00006AE9                 push    eax
.text$mn:00006AEA                 lea     eax, [ebp+var_C]
.text$mn:00006AED                 mov     large fs:0, eax
.text$mn:00006AF3                 mov     [ebp+var_10], ecx
.text$mn:00006AF6                 mov     ecx, [ebp+var_10] ; this
.text$mn:00006AF9                 call    ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
.text$mn:00006AFE                 mov     [ebp+var_4], 0
.text$mn:00006B05                 mov     eax, [ebp+var_10]
.text$mn:00006B08                 mov     dword ptr [eax+4], 0
.text$mn:00006B0F                 mov     ecx, [ebp+var_10]
.text$mn:00006B12                 mov     dword ptr [ecx+8], 0
.text$mn:00006B19                 mov     edx, [ebp+var_10]
.text$mn:00006B1C                 mov     dword ptr [edx+0Ch], 0
.text$mn:00006B23                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006B2A                 mov     eax, [ebp+var_10]
.text$mn:00006B2D                 mov     ecx, [ebp+var_C]
.text$mn:00006B30                 mov     large fs:0, ecx
.text$mn:00006B37                 pop     ecx
.text$mn:00006B38                 mov     esp, ebp
.text$mn:00006B3A                 pop     ebp
.text$mn:00006B3B                 retn
.text$mn:00006B3B ??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ endp
.text$mn:00006B3B
.text$mn:00006B3B _text$mn        ends
.text$mn:00006B3B
.text$x:00006B3C ; ===========================================================================
.text$x:00006B3C
.text$x:00006B3C ; Segment type: Pure code
.text$x:00006B3C ; Segment permissions: Read/Execute
.text$x:00006B3C _text$x         segment para public 'CODE' use32
.text$x:00006B3C                 assume cs:_text$x
.text$x:00006B3C                 ;org 6B3Ch
.text$x:00006B3C ; COMDAT (pick associative to section at 6AD0)
.text$x:00006B3C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00006B3C
.text$x:00006B3C ; =============== S U B R O U T I N E =======================================
.text$x:00006B3C
.text$x:00006B3C
.text$x:00006B3C __unwindfunclet$??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ$0 proc near
.text$x:00006B3C                                         ; DATA XREF: .xdata$x:0000CD28o
.text$x:00006B3C                 mov     ecx, [ebp-10h]  ; this
.text$x:00006B3F                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00006B3F __unwindfunclet$??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ$0 endp
.text$x:00006B3F
.text$x:00006B44
.text$x:00006B44 ; =============== S U B R O U T I N E =======================================
.text$x:00006B44
.text$x:00006B44
.text$x:00006B44 __ehhandler$??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ proc near
.text$x:00006B44                                         ; DATA XREF: std::_Vector_val<std::_Simple_types<int>>::_Vector_val<std::_Simple_types<int>>(void)+5o
.text$x:00006B44
.text$x:00006B44 arg_4           = dword ptr  8
.text$x:00006B44
.text$x:00006B44                 mov     edx, [esp+arg_4]
.text$x:00006B48                 lea     eax, [edx+0Ch]
.text$x:00006B4B                 mov     ecx, [edx-8]
.text$x:00006B4E                 xor     ecx, eax
.text$x:00006B50                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006B55                 mov     eax, offset __ehfuncinfo$??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ
.text$x:00006B5A                 jmp     ___CxxFrameHandler3
.text$x:00006B5A __ehhandler$??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ endp
.text$x:00006B5A
.text$x:00006B5A ; ---------------------------------------------------------------------------
.text$x:00006B5F                 align 10h
.text$x:00006B5F _text$x         ends
.text$x:00006B5F
.text$mn:00006B60 ; ===========================================================================
.text$mn:00006B60
.text$mn:00006B60 ; Segment type: Pure code
.text$mn:00006B60 ; Segment permissions: Read/Execute
.text$mn:00006B60 _text$mn        segment para public 'CODE' use32
.text$mn:00006B60                 assume cs:_text$mn
.text$mn:00006B60                 ;org 6B60h
.text$mn:00006B60 ; COMDAT (pick any)
.text$mn:00006B60                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006B60
.text$mn:00006B60 ; =============== S U B R O U T I N E =======================================
.text$mn:00006B60
.text$mn:00006B60 ; Attributes: bp-based frame
.text$mn:00006B60
.text$mn:00006B60 ; public: __thiscall std::_Vector_val<struct std::_Simple_types<wchar_t>>::_Vector_val<struct std::_Simple_types<wchar_t>>(void)
.text$mn:00006B60                 public ??0?$_Vector_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$mn:00006B60 ??0?$_Vector_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ proc near
.text$mn:00006B60                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<wchar_t,std::allocator<wchar_t>>>::_Vector_alloc<0,std::_Vec_base_types<wchar_t,std::allocator<wchar_t>>>(std::allocator<wchar_t> const &)+29p
.text$mn:00006B60
.text$mn:00006B60 var_10          = dword ptr -10h
.text$mn:00006B60 var_C           = dword ptr -0Ch
.text$mn:00006B60 var_4           = dword ptr -4
.text$mn:00006B60
.text$mn:00006B60                 push    ebp
.text$mn:00006B61                 mov     ebp, esp
.text$mn:00006B63                 push    0FFFFFFFFh
.text$mn:00006B65                 push    offset __ehhandler$??0?$_Vector_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$mn:00006B6A                 mov     eax, large fs:0
.text$mn:00006B70                 push    eax
.text$mn:00006B71                 push    ecx
.text$mn:00006B72                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006B77                 xor     eax, ebp
.text$mn:00006B79                 push    eax
.text$mn:00006B7A                 lea     eax, [ebp+var_C]
.text$mn:00006B7D                 mov     large fs:0, eax
.text$mn:00006B83                 mov     [ebp+var_10], ecx
.text$mn:00006B86                 mov     ecx, [ebp+var_10] ; this
.text$mn:00006B89                 call    ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
.text$mn:00006B8E                 mov     [ebp+var_4], 0
.text$mn:00006B95                 mov     eax, [ebp+var_10]
.text$mn:00006B98                 mov     dword ptr [eax+4], 0
.text$mn:00006B9F                 mov     ecx, [ebp+var_10]
.text$mn:00006BA2                 mov     dword ptr [ecx+8], 0
.text$mn:00006BA9                 mov     edx, [ebp+var_10]
.text$mn:00006BAC                 mov     dword ptr [edx+0Ch], 0
.text$mn:00006BB3                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006BBA                 mov     eax, [ebp+var_10]
.text$mn:00006BBD                 mov     ecx, [ebp+var_C]
.text$mn:00006BC0                 mov     large fs:0, ecx
.text$mn:00006BC7                 pop     ecx
.text$mn:00006BC8                 mov     esp, ebp
.text$mn:00006BCA                 pop     ebp
.text$mn:00006BCB                 retn
.text$mn:00006BCB ??0?$_Vector_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ endp
.text$mn:00006BCB
.text$mn:00006BCB _text$mn        ends
.text$mn:00006BCB
.text$x:00006BCC ; ===========================================================================
.text$x:00006BCC
.text$x:00006BCC ; Segment type: Pure code
.text$x:00006BCC ; Segment permissions: Read/Execute
.text$x:00006BCC _text$x         segment para public 'CODE' use32
.text$x:00006BCC                 assume cs:_text$x
.text$x:00006BCC                 ;org 6BCCh
.text$x:00006BCC ; COMDAT (pick associative to section at 6B60)
.text$x:00006BCC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00006BCC
.text$x:00006BCC ; =============== S U B R O U T I N E =======================================
.text$x:00006BCC
.text$x:00006BCC
.text$x:00006BCC __unwindfunclet$??0?$_Vector_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0 proc near
.text$x:00006BCC                                         ; DATA XREF: .xdata$x:0000D4A4o
.text$x:00006BCC                 mov     ecx, [ebp-10h]  ; this
.text$x:00006BCF                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00006BCF __unwindfunclet$??0?$_Vector_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0 endp
.text$x:00006BCF
.text$x:00006BD4
.text$x:00006BD4 ; =============== S U B R O U T I N E =======================================
.text$x:00006BD4
.text$x:00006BD4
.text$x:00006BD4 __ehhandler$??0?$_Vector_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ proc near
.text$x:00006BD4                                         ; DATA XREF: std::_Vector_val<std::_Simple_types<wchar_t>>::_Vector_val<std::_Simple_types<wchar_t>>(void)+5o
.text$x:00006BD4
.text$x:00006BD4 arg_4           = dword ptr  8
.text$x:00006BD4
.text$x:00006BD4                 mov     edx, [esp+arg_4]
.text$x:00006BD8                 lea     eax, [edx+0Ch]
.text$x:00006BDB                 mov     ecx, [edx-8]
.text$x:00006BDE                 xor     ecx, eax
.text$x:00006BE0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006BE5                 mov     eax, offset __ehfuncinfo$??0?$_Vector_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$x:00006BEA                 jmp     ___CxxFrameHandler3
.text$x:00006BEA __ehhandler$??0?$_Vector_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ endp
.text$x:00006BEA
.text$x:00006BEA ; ---------------------------------------------------------------------------
.text$x:00006BEF                 align 10h
.text$x:00006BEF _text$x         ends
.text$x:00006BEF
.text$mn:00006BF0 ; ===========================================================================
.text$mn:00006BF0
.text$mn:00006BF0 ; Segment type: Pure code
.text$mn:00006BF0 ; Segment permissions: Read/Execute
.text$mn:00006BF0 _text$mn        segment para public 'CODE' use32
.text$mn:00006BF0                 assume cs:_text$mn
.text$mn:00006BF0                 ;org 6BF0h
.text$mn:00006BF0 ; COMDAT (pick any)
.text$mn:00006BF0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006BF0
.text$mn:00006BF0 ; =============== S U B R O U T I N E =======================================
.text$mn:00006BF0
.text$mn:00006BF0 ; Attributes: bp-based frame
.text$mn:00006BF0
.text$mn:00006BF0 ; public: __thiscall std::_Wrap_alloc<class std::allocator<char>>::_Wrap_alloc<class std::allocator<char>>(void)
.text$mn:00006BF0                 public ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
.text$mn:00006BF0 ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ proc near
.text$mn:00006BF0                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)+Ap
.text$mn:00006BF0
.text$mn:00006BF0 var_4           = dword ptr -4
.text$mn:00006BF0
.text$mn:00006BF0                 push    ebp
.text$mn:00006BF1                 mov     ebp, esp
.text$mn:00006BF3                 push    ecx
.text$mn:00006BF4                 mov     [ebp+var_4], ecx
.text$mn:00006BF7                 mov     ecx, [ebp+var_4]
.text$mn:00006BFA                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:00006BFF                 mov     eax, [ebp+var_4]
.text$mn:00006C02                 mov     esp, ebp
.text$mn:00006C04                 pop     ebp
.text$mn:00006C05                 retn
.text$mn:00006C05 ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ endp
.text$mn:00006C05
.text$mn:00006C05 ; ---------------------------------------------------------------------------
.text$mn:00006C06                 align 4
.text$mn:00006C06 _text$mn        ends
.text$mn:00006C06
.text$mn:00006C08 ; ===========================================================================
.text$mn:00006C08
.text$mn:00006C08 ; Segment type: Pure code
.text$mn:00006C08 ; Segment permissions: Read/Execute
.text$mn:00006C08 _text$mn        segment para public 'CODE' use32
.text$mn:00006C08                 assume cs:_text$mn
.text$mn:00006C08                 ;org 6C08h
.text$mn:00006C08 ; COMDAT (pick any)
.text$mn:00006C08                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006C08
.text$mn:00006C08 ; =============== S U B R O U T I N E =======================================
.text$mn:00006C08
.text$mn:00006C08 ; Attributes: bp-based frame
.text$mn:00006C08
.text$mn:00006C08 ; public: __thiscall std::_Wrap_alloc<class std::allocator<int>>::_Wrap_alloc<class std::allocator<int>>(void)
.text$mn:00006C08                 public ??0?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAE@XZ
.text$mn:00006C08 ??0?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAE@XZ proc near
.text$mn:00006C08                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>::_Getal(void)+Ap
.text$mn:00006C08
.text$mn:00006C08 var_4           = dword ptr -4
.text$mn:00006C08
.text$mn:00006C08                 push    ebp
.text$mn:00006C09                 mov     ebp, esp
.text$mn:00006C0B                 push    ecx
.text$mn:00006C0C                 mov     [ebp+var_4], ecx
.text$mn:00006C0F                 mov     ecx, [ebp+var_4]
.text$mn:00006C12                 call    ??0?$allocator@H@std@@QAE@XZ ; std::allocator<int>::allocator<int>(void)
.text$mn:00006C17                 mov     eax, [ebp+var_4]
.text$mn:00006C1A                 mov     esp, ebp
.text$mn:00006C1C                 pop     ebp
.text$mn:00006C1D                 retn
.text$mn:00006C1D ??0?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAE@XZ endp
.text$mn:00006C1D
.text$mn:00006C1D ; ---------------------------------------------------------------------------
.text$mn:00006C1E                 align 10h
.text$mn:00006C1E _text$mn        ends
.text$mn:00006C1E
.text$mn:00006C20 ; ===========================================================================
.text$mn:00006C20
.text$mn:00006C20 ; Segment type: Pure code
.text$mn:00006C20 ; Segment permissions: Read/Execute
.text$mn:00006C20 _text$mn        segment para public 'CODE' use32
.text$mn:00006C20                 assume cs:_text$mn
.text$mn:00006C20                 ;org 6C20h
.text$mn:00006C20 ; COMDAT (pick any)
.text$mn:00006C20                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006C20
.text$mn:00006C20 ; =============== S U B R O U T I N E =======================================
.text$mn:00006C20
.text$mn:00006C20 ; Attributes: bp-based frame
.text$mn:00006C20
.text$mn:00006C20 ; public: __thiscall std::_Wrap_alloc<class std::allocator<struct std::_Container_proxy>>::_Wrap_alloc<class std::allocator<struct std::_Container_proxy>>(void)
.text$mn:00006C20                 public ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ
.text$mn:00006C20 ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00006C20                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>::_Alloc_proxy(void)+Cp
.text$mn:00006C20                                         ; std::_Vector_alloc<0,std::_Vec_base_types<wchar_t,std::allocator<wchar_t>>>::_Alloc_proxy(void)+Cp ...
.text$mn:00006C20
.text$mn:00006C20 var_4           = dword ptr -4
.text$mn:00006C20
.text$mn:00006C20                 push    ebp
.text$mn:00006C21                 mov     ebp, esp
.text$mn:00006C23                 push    ecx
.text$mn:00006C24                 mov     [ebp+var_4], ecx
.text$mn:00006C27                 mov     ecx, [ebp+var_4]
.text$mn:00006C2A                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:00006C2F                 mov     eax, [ebp+var_4]
.text$mn:00006C32                 mov     esp, ebp
.text$mn:00006C34                 pop     ebp
.text$mn:00006C35                 retn
.text$mn:00006C35 ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ endp
.text$mn:00006C35
.text$mn:00006C35 ; ---------------------------------------------------------------------------
.text$mn:00006C36                 align 4
.text$mn:00006C36 _text$mn        ends
.text$mn:00006C36
.text$mn:00006C38 ; ===========================================================================
.text$mn:00006C38
.text$mn:00006C38 ; Segment type: Pure code
.text$mn:00006C38 ; Segment permissions: Read/Execute
.text$mn:00006C38 _text$mn        segment para public 'CODE' use32
.text$mn:00006C38                 assume cs:_text$mn
.text$mn:00006C38                 ;org 6C38h
.text$mn:00006C38 ; COMDAT (pick any)
.text$mn:00006C38                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006C38
.text$mn:00006C38 ; =============== S U B R O U T I N E =======================================
.text$mn:00006C38
.text$mn:00006C38 ; Attributes: bp-based frame
.text$mn:00006C38
.text$mn:00006C38 ; public: __thiscall std::_Wrap_alloc<class std::allocator<wchar_t>>::_Wrap_alloc<class std::allocator<wchar_t>>(void)
.text$mn:00006C38                 public ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ
.text$mn:00006C38 ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ proc near
.text$mn:00006C38                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)+Ap
.text$mn:00006C38                                         ; std::_Vector_alloc<0,std::_Vec_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)+Ap
.text$mn:00006C38
.text$mn:00006C38 var_4           = dword ptr -4
.text$mn:00006C38
.text$mn:00006C38                 push    ebp
.text$mn:00006C39                 mov     ebp, esp
.text$mn:00006C3B                 push    ecx
.text$mn:00006C3C                 mov     [ebp+var_4], ecx
.text$mn:00006C3F                 mov     ecx, [ebp+var_4]
.text$mn:00006C42                 call    ??0?$allocator@_W@std@@QAE@XZ ; std::allocator<wchar_t>::allocator<wchar_t>(void)
.text$mn:00006C47                 mov     eax, [ebp+var_4]
.text$mn:00006C4A                 mov     esp, ebp
.text$mn:00006C4C                 pop     ebp
.text$mn:00006C4D                 retn
.text$mn:00006C4D ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ endp
.text$mn:00006C4D
.text$mn:00006C4D ; ---------------------------------------------------------------------------
.text$mn:00006C4E                 align 10h
.text$mn:00006C4E _text$mn        ends
.text$mn:00006C4E
.text$mn:00006C50 ; ===========================================================================
.text$mn:00006C50
.text$mn:00006C50 ; Segment type: Pure code
.text$mn:00006C50 ; Segment permissions: Read/Execute
.text$mn:00006C50 _text$mn        segment para public 'CODE' use32
.text$mn:00006C50                 assume cs:_text$mn
.text$mn:00006C50                 ;org 6C50h
.text$mn:00006C50 ; COMDAT (pick any)
.text$mn:00006C50                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006C50
.text$mn:00006C50 ; =============== S U B R O U T I N E =======================================
.text$mn:00006C50
.text$mn:00006C50 ; Attributes: bp-based frame
.text$mn:00006C50
.text$mn:00006C50 ; public: __thiscall std::allocator<char>::allocator<char>(void)
.text$mn:00006C50                 public ??0?$allocator@D@std@@QAE@XZ
.text$mn:00006C50 ??0?$allocator@D@std@@QAE@XZ proc near  ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)+Ap
.text$mn:00006C50                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+2Bp
.text$mn:00006C50
.text$mn:00006C50 var_4           = dword ptr -4
.text$mn:00006C50
.text$mn:00006C50                 push    ebp
.text$mn:00006C51                 mov     ebp, esp
.text$mn:00006C53                 push    ecx
.text$mn:00006C54                 mov     [ebp+var_4], ecx
.text$mn:00006C57                 mov     eax, [ebp+var_4]
.text$mn:00006C5A                 mov     esp, ebp
.text$mn:00006C5C                 pop     ebp
.text$mn:00006C5D                 retn
.text$mn:00006C5D ??0?$allocator@D@std@@QAE@XZ endp
.text$mn:00006C5D
.text$mn:00006C5D ; ---------------------------------------------------------------------------
.text$mn:00006C5E                 align 10h
.text$mn:00006C5E _text$mn        ends
.text$mn:00006C5E
.text$mn:00006C60 ; ===========================================================================
.text$mn:00006C60
.text$mn:00006C60 ; Segment type: Pure code
.text$mn:00006C60 ; Segment permissions: Read/Execute
.text$mn:00006C60 _text$mn        segment para public 'CODE' use32
.text$mn:00006C60                 assume cs:_text$mn
.text$mn:00006C60                 ;org 6C60h
.text$mn:00006C60 ; COMDAT (pick any)
.text$mn:00006C60                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006C60
.text$mn:00006C60 ; =============== S U B R O U T I N E =======================================
.text$mn:00006C60
.text$mn:00006C60 ; Attributes: bp-based frame
.text$mn:00006C60
.text$mn:00006C60 ; public: __thiscall std::allocator<int>::allocator<int>(void)
.text$mn:00006C60                 public ??0?$allocator@H@std@@QAE@XZ
.text$mn:00006C60 ??0?$allocator@H@std@@QAE@XZ proc near  ; CODE XREF: std::_Wrap_alloc<std::allocator<int>>::_Wrap_alloc<std::allocator<int>>(void)+Ap
.text$mn:00006C60                                         ; std::vector<int,std::allocator<int>>::vector<int,std::allocator<int>>(void)+2Bp
.text$mn:00006C60
.text$mn:00006C60 var_4           = dword ptr -4
.text$mn:00006C60
.text$mn:00006C60                 push    ebp
.text$mn:00006C61                 mov     ebp, esp
.text$mn:00006C63                 push    ecx
.text$mn:00006C64                 mov     [ebp+var_4], ecx
.text$mn:00006C67                 mov     eax, [ebp+var_4]
.text$mn:00006C6A                 mov     esp, ebp
.text$mn:00006C6C                 pop     ebp
.text$mn:00006C6D                 retn
.text$mn:00006C6D ??0?$allocator@H@std@@QAE@XZ endp
.text$mn:00006C6D
.text$mn:00006C6D ; ---------------------------------------------------------------------------
.text$mn:00006C6E                 align 10h
.text$mn:00006C6E _text$mn        ends
.text$mn:00006C6E
.text$mn:00006C70 ; ===========================================================================
.text$mn:00006C70
.text$mn:00006C70 ; Segment type: Pure code
.text$mn:00006C70 ; Segment permissions: Read/Execute
.text$mn:00006C70 _text$mn        segment para public 'CODE' use32
.text$mn:00006C70                 assume cs:_text$mn
.text$mn:00006C70                 ;org 6C70h
.text$mn:00006C70 ; COMDAT (pick any)
.text$mn:00006C70                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006C70
.text$mn:00006C70 ; =============== S U B R O U T I N E =======================================
.text$mn:00006C70
.text$mn:00006C70 ; Attributes: bp-based frame
.text$mn:00006C70
.text$mn:00006C70 ; public: __thiscall std::allocator<struct std::_Container_proxy>::allocator<struct std::_Container_proxy>(void)
.text$mn:00006C70                 public ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ
.text$mn:00006C70 ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ proc near
.text$mn:00006C70                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::_Wrap_alloc<std::allocator<std::_Container_proxy>>(void)+Ap
.text$mn:00006C70                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+Cp ...
.text$mn:00006C70
.text$mn:00006C70 var_4           = dword ptr -4
.text$mn:00006C70
.text$mn:00006C70                 push    ebp
.text$mn:00006C71                 mov     ebp, esp
.text$mn:00006C73                 push    ecx
.text$mn:00006C74                 mov     [ebp+var_4], ecx
.text$mn:00006C77                 mov     eax, [ebp+var_4]
.text$mn:00006C7A                 mov     esp, ebp
.text$mn:00006C7C                 pop     ebp
.text$mn:00006C7D                 retn
.text$mn:00006C7D ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ endp
.text$mn:00006C7D
.text$mn:00006C7D ; ---------------------------------------------------------------------------
.text$mn:00006C7E                 align 10h
.text$mn:00006C7E _text$mn        ends
.text$mn:00006C7E
.text$mn:00006C80 ; ===========================================================================
.text$mn:00006C80
.text$mn:00006C80 ; Segment type: Pure code
.text$mn:00006C80 ; Segment permissions: Read/Execute
.text$mn:00006C80 _text$mn        segment para public 'CODE' use32
.text$mn:00006C80                 assume cs:_text$mn
.text$mn:00006C80                 ;org 6C80h
.text$mn:00006C80 ; COMDAT (pick any)
.text$mn:00006C80                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006C80
.text$mn:00006C80 ; =============== S U B R O U T I N E =======================================
.text$mn:00006C80
.text$mn:00006C80 ; Attributes: bp-based frame
.text$mn:00006C80
.text$mn:00006C80 ; public: __thiscall std::allocator<wchar_t>::allocator<wchar_t>(void)
.text$mn:00006C80                 public ??0?$allocator@_W@std@@QAE@XZ
.text$mn:00006C80 ??0?$allocator@_W@std@@QAE@XZ proc near ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::vector<wchar_t,std::allocator<wchar_t>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)+32p
.text$mn:00006C80                                         ; std::_Wrap_alloc<std::allocator<wchar_t>>::_Wrap_alloc<std::allocator<wchar_t>>(void)+Ap ...
.text$mn:00006C80
.text$mn:00006C80 var_4           = dword ptr -4
.text$mn:00006C80
.text$mn:00006C80                 push    ebp
.text$mn:00006C81                 mov     ebp, esp
.text$mn:00006C83                 push    ecx
.text$mn:00006C84                 mov     [ebp+var_4], ecx
.text$mn:00006C87                 mov     eax, [ebp+var_4]
.text$mn:00006C8A                 mov     esp, ebp
.text$mn:00006C8C                 pop     ebp
.text$mn:00006C8D                 retn
.text$mn:00006C8D ??0?$allocator@_W@std@@QAE@XZ endp
.text$mn:00006C8D
.text$mn:00006C8D ; ---------------------------------------------------------------------------
.text$mn:00006C8E                 align 10h
.text$mn:00006C8E _text$mn        ends
.text$mn:00006C8E
.text$mn:00006C90 ; ===========================================================================
.text$mn:00006C90
.text$mn:00006C90 ; Segment type: Pure code
.text$mn:00006C90 ; Segment permissions: Read/Execute
.text$mn:00006C90 _text$mn        segment para public 'CODE' use32
.text$mn:00006C90                 assume cs:_text$mn
.text$mn:00006C90                 ;org 6C90h
.text$mn:00006C90 ; COMDAT (pick any)
.text$mn:00006C90                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006C90
.text$mn:00006C90 ; =============== S U B R O U T I N E =======================================
.text$mn:00006C90
.text$mn:00006C90 ; Attributes: bp-based frame
.text$mn:00006C90
.text$mn:00006C90 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char *Str)
.text$mn:00006C90                 public ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$mn:00006C90 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
.text$mn:00006C90                                         ; CODE XREF: std::_Generic_error_category::message(int)+5Ap
.text$mn:00006C90                                         ; std::_Iostream_error_category::message(int)+3Dp ...
.text$mn:00006C90
.text$mn:00006C90 var_14          = dword ptr -14h
.text$mn:00006C90 var_D           = byte ptr -0Dh
.text$mn:00006C90 var_C           = dword ptr -0Ch
.text$mn:00006C90 var_4           = dword ptr -4
.text$mn:00006C90 Str             = dword ptr  8
.text$mn:00006C90
.text$mn:00006C90                 push    ebp
.text$mn:00006C91                 mov     ebp, esp
.text$mn:00006C93                 push    0FFFFFFFFh
.text$mn:00006C95                 push    offset __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$mn:00006C9A                 mov     eax, large fs:0
.text$mn:00006CA0                 push    eax
.text$mn:00006CA1                 sub     esp, 8
.text$mn:00006CA4                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006CA9                 xor     eax, ebp
.text$mn:00006CAB                 push    eax
.text$mn:00006CAC                 lea     eax, [ebp+var_C]
.text$mn:00006CAF                 mov     large fs:0, eax
.text$mn:00006CB5                 mov     [ebp+var_14], ecx
.text$mn:00006CB8                 lea     ecx, [ebp+var_D]
.text$mn:00006CBB                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:00006CC0                 push    eax
.text$mn:00006CC1                 mov     ecx, [ebp+var_14]
.text$mn:00006CC4                 call    ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)
.text$mn:00006CC9                 mov     [ebp+var_4], 0
.text$mn:00006CD0                 push    0               ; Size
.text$mn:00006CD2                 push    0               ; char
.text$mn:00006CD4                 mov     ecx, [ebp+var_14]
.text$mn:00006CD7                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00006CDC                 mov     eax, [ebp+Str]
.text$mn:00006CDF                 push    eax             ; Str
.text$mn:00006CE0                 mov     ecx, [ebp+var_14]
.text$mn:00006CE3                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)
.text$mn:00006CE8                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006CEF                 mov     eax, [ebp+var_14]
.text$mn:00006CF2                 mov     ecx, [ebp+var_C]
.text$mn:00006CF5                 mov     large fs:0, ecx
.text$mn:00006CFC                 pop     ecx
.text$mn:00006CFD                 mov     esp, ebp
.text$mn:00006CFF                 pop     ebp
.text$mn:00006D00                 retn    4
.text$mn:00006D00 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp
.text$mn:00006D00
.text$mn:00006D00 ; ---------------------------------------------------------------------------
.text$mn:00006D03                 align 4
.text$mn:00006D03 _text$mn        ends
.text$mn:00006D03
.text$x:00006D04 ; ===========================================================================
.text$x:00006D04
.text$x:00006D04 ; Segment type: Pure code
.text$x:00006D04 ; Segment permissions: Read/Execute
.text$x:00006D04 _text$x         segment para public 'CODE' use32
.text$x:00006D04                 assume cs:_text$x
.text$x:00006D04                 ;org 6D04h
.text$x:00006D04 ; COMDAT (pick associative to section at 6C90)
.text$x:00006D04                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00006D04
.text$x:00006D04 ; =============== S U B R O U T I N E =======================================
.text$x:00006D04
.text$x:00006D04
.text$x:00006D04 __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 proc near
.text$x:00006D04                                         ; DATA XREF: .xdata$x:0000C700o
.text$x:00006D04                 mov     ecx, [ebp-14h]
.text$x:00006D07                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:00006D07 __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 endp
.text$x:00006D07
.text$x:00006D0C
.text$x:00006D0C ; =============== S U B R O U T I N E =======================================
.text$x:00006D0C
.text$x:00006D0C
.text$x:00006D0C __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
.text$x:00006D0C                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+5o
.text$x:00006D0C
.text$x:00006D0C arg_4           = dword ptr  8
.text$x:00006D0C
.text$x:00006D0C                 mov     edx, [esp+arg_4]
.text$x:00006D10                 lea     eax, [edx+0Ch]
.text$x:00006D13                 mov     ecx, [edx-0Ch]
.text$x:00006D16                 xor     ecx, eax
.text$x:00006D18                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006D1D                 mov     eax, offset __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$x:00006D22                 jmp     ___CxxFrameHandler3
.text$x:00006D22 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp
.text$x:00006D22
.text$x:00006D22 ; ---------------------------------------------------------------------------
.text$x:00006D27                 align 4
.text$x:00006D27 _text$x         ends
.text$x:00006D27
.text$mn:00006D28 ; ===========================================================================
.text$mn:00006D28
.text$mn:00006D28 ; Segment type: Pure code
.text$mn:00006D28 ; Segment permissions: Read/Execute
.text$mn:00006D28 _text$mn        segment para public 'CODE' use32
.text$mn:00006D28                 assume cs:_text$mn
.text$mn:00006D28                 ;org 6D28h
.text$mn:00006D28 ; COMDAT (pick any)
.text$mn:00006D28                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006D28
.text$mn:00006D28 ; =============== S U B R O U T I N E =======================================
.text$mn:00006D28
.text$mn:00006D28 ; Attributes: bp-based frame
.text$mn:00006D28
.text$mn:00006D28 ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t *Str)
.text$mn:00006D28                 public ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z
.text$mn:00006D28 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z proc near
.text$mn:00006D28                                         ; CODE XREF: WindowsMenu::init(HINSTANCE__ *,HMENU__ *,wchar_t const *)+62p
.text$mn:00006D28                                         ; WindowsMenu::initPopupMenu(HMENU__ *,DocTabView *)+FEp
.text$mn:00006D28
.text$mn:00006D28 var_14          = dword ptr -14h
.text$mn:00006D28 var_D           = byte ptr -0Dh
.text$mn:00006D28 var_C           = dword ptr -0Ch
.text$mn:00006D28 var_4           = dword ptr -4
.text$mn:00006D28 Str             = dword ptr  8
.text$mn:00006D28
.text$mn:00006D28                 push    ebp
.text$mn:00006D29                 mov     ebp, esp
.text$mn:00006D2B                 push    0FFFFFFFFh
.text$mn:00006D2D                 push    offset __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z
.text$mn:00006D32                 mov     eax, large fs:0
.text$mn:00006D38                 push    eax
.text$mn:00006D39                 sub     esp, 8
.text$mn:00006D3C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006D41                 xor     eax, ebp
.text$mn:00006D43                 push    eax
.text$mn:00006D44                 lea     eax, [ebp+var_C]
.text$mn:00006D47                 mov     large fs:0, eax
.text$mn:00006D4D                 mov     [ebp+var_14], ecx
.text$mn:00006D50                 lea     ecx, [ebp+var_D]
.text$mn:00006D53                 call    ??0?$allocator@_W@std@@QAE@XZ ; std::allocator<wchar_t>::allocator<wchar_t>(void)
.text$mn:00006D58                 push    eax
.text$mn:00006D59                 mov     ecx, [ebp+var_14]
.text$mn:00006D5C                 call    ??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(std::allocator<wchar_t> const &)
.text$mn:00006D61                 mov     [ebp+var_4], 0
.text$mn:00006D68                 push    0
.text$mn:00006D6A                 push    0
.text$mn:00006D6C                 mov     ecx, [ebp+var_14]
.text$mn:00006D6F                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:00006D74                 mov     eax, [ebp+Str]
.text$mn:00006D77                 push    eax             ; Str
.text$mn:00006D78                 mov     ecx, [ebp+var_14]
.text$mn:00006D7B                 call    ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *)
.text$mn:00006D80                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006D87                 mov     eax, [ebp+var_14]
.text$mn:00006D8A                 mov     ecx, [ebp+var_C]
.text$mn:00006D8D                 mov     large fs:0, ecx
.text$mn:00006D94                 pop     ecx
.text$mn:00006D95                 mov     esp, ebp
.text$mn:00006D97                 pop     ebp
.text$mn:00006D98                 retn    4
.text$mn:00006D98 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z endp
.text$mn:00006D98
.text$mn:00006D98 ; ---------------------------------------------------------------------------
.text$mn:00006D9B                 align 4
.text$mn:00006D9B _text$mn        ends
.text$mn:00006D9B
.text$x:00006D9C ; ===========================================================================
.text$x:00006D9C
.text$x:00006D9C ; Segment type: Pure code
.text$x:00006D9C ; Segment permissions: Read/Execute
.text$x:00006D9C _text$x         segment para public 'CODE' use32
.text$x:00006D9C                 assume cs:_text$x
.text$x:00006D9C                 ;org 6D9Ch
.text$x:00006D9C ; COMDAT (pick associative to section at 6D28)
.text$x:00006D9C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00006D9C
.text$x:00006D9C ; =============== S U B R O U T I N E =======================================
.text$x:00006D9C
.text$x:00006D9C
.text$x:00006D9C __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z$0 proc near
.text$x:00006D9C                                         ; DATA XREF: .xdata$x:0000CA20o
.text$x:00006D9C                 mov     ecx, [ebp-14h]
.text$x:00006D9F                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)
.text$x:00006D9F __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z$0 endp
.text$x:00006D9F
.text$x:00006DA4
.text$x:00006DA4 ; =============== S U B R O U T I N E =======================================
.text$x:00006DA4
.text$x:00006DA4
.text$x:00006DA4 __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z proc near
.text$x:00006DA4                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)+5o
.text$x:00006DA4
.text$x:00006DA4 arg_4           = dword ptr  8
.text$x:00006DA4
.text$x:00006DA4                 mov     edx, [esp+arg_4]
.text$x:00006DA8                 lea     eax, [edx+0Ch]
.text$x:00006DAB                 mov     ecx, [edx-0Ch]
.text$x:00006DAE                 xor     ecx, eax
.text$x:00006DB0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006DB5                 mov     eax, offset __ehfuncinfo$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z
.text$x:00006DBA                 jmp     ___CxxFrameHandler3
.text$x:00006DBA __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z endp
.text$x:00006DBA
.text$x:00006DBA ; ---------------------------------------------------------------------------
.text$x:00006DBF                 align 10h
.text$x:00006DBF _text$x         ends
.text$x:00006DBF
.text$mn:00006DC0 ; ===========================================================================
.text$mn:00006DC0
.text$mn:00006DC0 ; Segment type: Pure code
.text$mn:00006DC0 ; Segment permissions: Read/Execute
.text$mn:00006DC0 _text$mn        segment para public 'CODE' use32
.text$mn:00006DC0                 assume cs:_text$mn
.text$mn:00006DC0                 ;org 6DC0h
.text$mn:00006DC0 ; COMDAT (pick any)
.text$mn:00006DC0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006DC0
.text$mn:00006DC0 ; =============== S U B R O U T I N E =======================================
.text$mn:00006DC0
.text$mn:00006DC0 ; Attributes: bp-based frame
.text$mn:00006DC0
.text$mn:00006DC0 ; public: __thiscall std::binder2nd<struct std::equal_to<int>>::binder2nd<struct std::equal_to<int>>(struct std::equal_to<int> const &, int const &)
.text$mn:00006DC0                 public ??0?$binder2nd@U?$equal_to@H@std@@@std@@QAE@ABU?$equal_to@H@1@ABH@Z
.text$mn:00006DC0 ??0?$binder2nd@U?$equal_to@H@std@@@std@@QAE@ABU?$equal_to@H@1@ABH@Z proc near
.text$mn:00006DC0                                         ; CODE XREF: std::bind2nd<std::equal_to<int>,int>(std::equal_to<int> const &,int const &)+17p
.text$mn:00006DC0
.text$mn:00006DC0 var_4           = dword ptr -4
.text$mn:00006DC0 arg_4           = dword ptr  0Ch
.text$mn:00006DC0
.text$mn:00006DC0                 push    ebp
.text$mn:00006DC1                 mov     ebp, esp
.text$mn:00006DC3                 push    ecx
.text$mn:00006DC4                 mov     [ebp+var_4], ecx
.text$mn:00006DC7                 mov     eax, [ebp+var_4]
.text$mn:00006DCA                 mov     ecx, [ebp+arg_4]
.text$mn:00006DCD                 mov     edx, [ecx]
.text$mn:00006DCF                 mov     [eax+4], edx
.text$mn:00006DD2                 mov     eax, [ebp+var_4]
.text$mn:00006DD5                 mov     esp, ebp
.text$mn:00006DD7                 pop     ebp
.text$mn:00006DD8                 retn    8
.text$mn:00006DD8 ??0?$binder2nd@U?$equal_to@H@std@@@std@@QAE@ABU?$equal_to@H@1@ABH@Z endp
.text$mn:00006DD8
.text$mn:00006DD8 ; ---------------------------------------------------------------------------
.text$mn:00006DDB                 align 4
.text$mn:00006DDB _text$mn        ends
.text$mn:00006DDB
.text$mn:00006DDC ; ===========================================================================
.text$mn:00006DDC
.text$mn:00006DDC ; Segment type: Pure code
.text$mn:00006DDC ; Segment permissions: Read/Execute
.text$mn:00006DDC _text$mn        segment para public 'CODE' use32
.text$mn:00006DDC                 assume cs:_text$mn
.text$mn:00006DDC                 ;org 6DDCh
.text$mn:00006DDC ; COMDAT (pick any)
.text$mn:00006DDC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006DDC
.text$mn:00006DDC ; =============== S U B R O U T I N E =======================================
.text$mn:00006DDC
.text$mn:00006DDC ; Attributes: bp-based frame
.text$mn:00006DDC
.text$mn:00006DDC ; public: __thiscall std::vector<int, class std::allocator<int>>::vector<int, class std::allocator<int>>(void)
.text$mn:00006DDC                 public ??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
.text$mn:00006DDC ??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ proc near
.text$mn:00006DDC                                         ; CODE XREF: WindowsDlg::WindowsDlg(void)+49p
.text$mn:00006DDC                                         ; WindowsDlg::run_dlgProc(uint,uint,long)+43Ap ...
.text$mn:00006DDC
.text$mn:00006DDC var_14          = dword ptr -14h
.text$mn:00006DDC var_D           = byte ptr -0Dh
.text$mn:00006DDC var_C           = dword ptr -0Ch
.text$mn:00006DDC var_4           = dword ptr -4
.text$mn:00006DDC
.text$mn:00006DDC                 push    ebp
.text$mn:00006DDD                 mov     ebp, esp
.text$mn:00006DDF                 push    0FFFFFFFFh
.text$mn:00006DE1                 push    offset __ehhandler$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
.text$mn:00006DE6                 mov     eax, large fs:0
.text$mn:00006DEC                 push    eax
.text$mn:00006DED                 sub     esp, 8
.text$mn:00006DF0                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006DF5                 xor     eax, ebp
.text$mn:00006DF7                 push    eax
.text$mn:00006DF8                 lea     eax, [ebp+var_C]
.text$mn:00006DFB                 mov     large fs:0, eax
.text$mn:00006E01                 mov     [ebp+var_14], ecx
.text$mn:00006E04                 lea     ecx, [ebp+var_D]
.text$mn:00006E07                 call    ??0?$allocator@H@std@@QAE@XZ ; std::allocator<int>::allocator<int>(void)
.text$mn:00006E0C                 push    eax
.text$mn:00006E0D                 mov     ecx, [ebp+var_14]
.text$mn:00006E10                 call    ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@ABV?$allocator@H@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>(std::allocator<int> const &)
.text$mn:00006E15                 mov     [ebp+var_4], 0
.text$mn:00006E1C                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006E23                 mov     eax, [ebp+var_14]
.text$mn:00006E26                 mov     ecx, [ebp+var_C]
.text$mn:00006E29                 mov     large fs:0, ecx
.text$mn:00006E30                 pop     ecx
.text$mn:00006E31                 mov     esp, ebp
.text$mn:00006E33                 pop     ebp
.text$mn:00006E34                 retn
.text$mn:00006E34 ??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ endp
.text$mn:00006E34
.text$mn:00006E34 ; ---------------------------------------------------------------------------
.text$mn:00006E35                 align 4
.text$mn:00006E35 _text$mn        ends
.text$mn:00006E35
.text$x:00006E38 ; ===========================================================================
.text$x:00006E38
.text$x:00006E38 ; Segment type: Pure code
.text$x:00006E38 ; Segment permissions: Read/Execute
.text$x:00006E38 _text$x         segment para public 'CODE' use32
.text$x:00006E38                 assume cs:_text$x
.text$x:00006E38                 ;org 6E38h
.text$x:00006E38 ; COMDAT (pick associative to section at 6DDC)
.text$x:00006E38                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00006E38
.text$x:00006E38 ; =============== S U B R O U T I N E =======================================
.text$x:00006E38
.text$x:00006E38
.text$x:00006E38 __unwindfunclet$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ$0 proc near
.text$x:00006E38                                         ; DATA XREF: .xdata$x:0000CDD8o
.text$x:00006E38                 mov     ecx, [ebp-14h]
.text$x:00006E3B                 jmp     ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>::~_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>(void)
.text$x:00006E3B __unwindfunclet$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ$0 endp
.text$x:00006E3B
.text$x:00006E40
.text$x:00006E40 ; =============== S U B R O U T I N E =======================================
.text$x:00006E40
.text$x:00006E40
.text$x:00006E40 __ehhandler$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ proc near
.text$x:00006E40                                         ; DATA XREF: std::vector<int,std::allocator<int>>::vector<int,std::allocator<int>>(void)+5o
.text$x:00006E40
.text$x:00006E40 arg_4           = dword ptr  8
.text$x:00006E40
.text$x:00006E40                 mov     edx, [esp+arg_4]
.text$x:00006E44                 lea     eax, [edx+0Ch]
.text$x:00006E47                 mov     ecx, [edx-0Ch]
.text$x:00006E4A                 xor     ecx, eax
.text$x:00006E4C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006E51                 mov     eax, offset __ehfuncinfo$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
.text$x:00006E56                 jmp     ___CxxFrameHandler3
.text$x:00006E56 __ehhandler$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ endp
.text$x:00006E56
.text$x:00006E56 ; ---------------------------------------------------------------------------
.text$x:00006E5B                 align 4
.text$x:00006E5B _text$x         ends
.text$x:00006E5B
.text$mn:00006E5C ; ===========================================================================
.text$mn:00006E5C
.text$mn:00006E5C ; Segment type: Pure code
.text$mn:00006E5C ; Segment permissions: Read/Execute
.text$mn:00006E5C _text$mn        segment para public 'CODE' use32
.text$mn:00006E5C                 assume cs:_text$mn
.text$mn:00006E5C                 ;org 6E5Ch
.text$mn:00006E5C ; COMDAT (pick any)
.text$mn:00006E5C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006E5C
.text$mn:00006E5C ; =============== S U B R O U T I N E =======================================
.text$mn:00006E5C
.text$mn:00006E5C ; Attributes: bp-based frame
.text$mn:00006E5C
.text$mn:00006E5C ; _DWORD __thiscall BufferEquivalent::BufferEquivalent(BufferEquivalent *this, struct DocTabView *, int, bool)
.text$mn:00006E5C                 public ??0BufferEquivalent@@QAE@PAVDocTabView@@H_N@Z
.text$mn:00006E5C ??0BufferEquivalent@@QAE@PAVDocTabView@@H_N@Z proc near
.text$mn:00006E5C                                         ; CODE XREF: WindowsDlg::run_dlgProc(uint,uint,long)+4C0p
.text$mn:00006E5C
.text$mn:00006E5C var_4           = dword ptr -4
.text$mn:00006E5C arg_0           = dword ptr  8
.text$mn:00006E5C arg_4           = dword ptr  0Ch
.text$mn:00006E5C arg_8           = byte ptr  10h
.text$mn:00006E5C
.text$mn:00006E5C                 push    ebp
.text$mn:00006E5D                 mov     ebp, esp
.text$mn:00006E5F                 push    ecx
.text$mn:00006E60                 mov     [ebp+var_4], ecx
.text$mn:00006E63                 mov     eax, [ebp+var_4]
.text$mn:00006E66                 mov     ecx, [ebp+arg_0]
.text$mn:00006E69                 mov     [eax+4], ecx
.text$mn:00006E6C                 mov     edx, [ebp+var_4]
.text$mn:00006E6F                 mov     eax, [ebp+arg_4]
.text$mn:00006E72                 mov     [edx+8], eax
.text$mn:00006E75                 mov     ecx, [ebp+var_4]
.text$mn:00006E78                 mov     dl, [ebp+arg_8]
.text$mn:00006E7B                 mov     [ecx+0Ch], dl
.text$mn:00006E7E                 mov     eax, [ebp+var_4]
.text$mn:00006E81                 mov     esp, ebp
.text$mn:00006E83                 pop     ebp
.text$mn:00006E84                 retn    0Ch
.text$mn:00006E84 ??0BufferEquivalent@@QAE@PAVDocTabView@@H_N@Z endp
.text$mn:00006E84
.text$mn:00006E84 ; ---------------------------------------------------------------------------
.text$mn:00006E87                 align 4
.text$mn:00006E87 _text$mn        ends
.text$mn:00006E87
.text$mn:00006E88 ; ===========================================================================
.text$mn:00006E88
.text$mn:00006E88 ; Segment type: Pure code
.text$mn:00006E88 ; Segment permissions: Read/Execute
.text$mn:00006E88 _text$mn        segment para public 'CODE' use32
.text$mn:00006E88                 assume cs:_text$mn
.text$mn:00006E88                 ;org 6E88h
.text$mn:00006E88 ; COMDAT (pick any)
.text$mn:00006E88                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006E88
.text$mn:00006E88 ; =============== S U B R O U T I N E =======================================
.text$mn:00006E88
.text$mn:00006E88 ; Attributes: bp-based frame
.text$mn:00006E88
.text$mn:00006E88 ; _DWORD __thiscall NMWINDLG::NMWINDLG(NMWINDLG *__hidden this)
.text$mn:00006E88                 public ??0NMWINDLG@@QAE@XZ
.text$mn:00006E88 ??0NMWINDLG@@QAE@XZ proc near           ; CODE XREF: WindowsDlg::doSave(void)+Cp
.text$mn:00006E88                                         ; WindowsDlg::doClose(void)+32p ...
.text$mn:00006E88
.text$mn:00006E88 Dst             = dword ptr -4
.text$mn:00006E88
.text$mn:00006E88                 push    ebp
.text$mn:00006E89                 mov     ebp, esp
.text$mn:00006E8B                 push    ecx
.text$mn:00006E8C                 mov     [ebp+Dst], ecx
.text$mn:00006E8F                 push    20h ; ' '       ; Size
.text$mn:00006E91                 push    0               ; Val
.text$mn:00006E93                 mov     eax, [ebp+Dst]
.text$mn:00006E96                 push    eax             ; Dst
.text$mn:00006E97                 call    _memset
.text$mn:00006E9C                 add     esp, 0Ch
.text$mn:00006E9F                 mov     eax, [ebp+Dst]
.text$mn:00006EA2                 mov     esp, ebp
.text$mn:00006EA4                 pop     ebp
.text$mn:00006EA5                 retn
.text$mn:00006EA5 ??0NMWINDLG@@QAE@XZ endp
.text$mn:00006EA5
.text$mn:00006EA5 ; ---------------------------------------------------------------------------
.text$mn:00006EA6                 align 4
.text$mn:00006EA6 _text$mn        ends
.text$mn:00006EA6
.text$mn:00006EA8 ; ===========================================================================
.text$mn:00006EA8
.text$mn:00006EA8 ; Segment type: Pure code
.text$mn:00006EA8 ; Segment permissions: Read/Execute
.text$mn:00006EA8 _text$mn        segment para public 'CODE' use32
.text$mn:00006EA8                 assume cs:_text$mn
.text$mn:00006EA8                 ;org 6EA8h
.text$mn:00006EA8 ; COMDAT (pick any)
.text$mn:00006EA8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006EA8
.text$mn:00006EA8 ; =============== S U B R O U T I N E =======================================
.text$mn:00006EA8
.text$mn:00006EA8 ; Attributes: bp-based frame
.text$mn:00006EA8
.text$mn:00006EA8 ; _DWORD __thiscall std::_Container_base12::_Container_base12(std::_Container_base12 *__hidden this)
.text$mn:00006EA8                 public ??0_Container_base12@std@@QAE@XZ
.text$mn:00006EA8 ??0_Container_base12@std@@QAE@XZ proc near
.text$mn:00006EA8                                         ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+29p
.text$mn:00006EA8                                         ; std::_String_val<std::_Simple_types<wchar_t>>::_String_val<std::_Simple_types<wchar_t>>(void)+29p ...
.text$mn:00006EA8
.text$mn:00006EA8 var_4           = dword ptr -4
.text$mn:00006EA8
.text$mn:00006EA8                 push    ebp
.text$mn:00006EA9                 mov     ebp, esp
.text$mn:00006EAB                 push    ecx
.text$mn:00006EAC                 mov     [ebp+var_4], ecx
.text$mn:00006EAF                 mov     eax, [ebp+var_4]
.text$mn:00006EB2                 mov     dword ptr [eax], 0
.text$mn:00006EB8                 mov     eax, [ebp+var_4]
.text$mn:00006EBB                 mov     esp, ebp
.text$mn:00006EBD                 pop     ebp
.text$mn:00006EBE                 retn
.text$mn:00006EBE ??0_Container_base12@std@@QAE@XZ endp
.text$mn:00006EBE
.text$mn:00006EBE ; ---------------------------------------------------------------------------
.text$mn:00006EBF                 align 10h
.text$mn:00006EBF _text$mn        ends
.text$mn:00006EBF
.text$mn:00006EC0 ; ===========================================================================
.text$mn:00006EC0
.text$mn:00006EC0 ; Segment type: Pure code
.text$mn:00006EC0 ; Segment permissions: Read/Execute
.text$mn:00006EC0 _text$mn        segment para public 'CODE' use32
.text$mn:00006EC0                 assume cs:_text$mn
.text$mn:00006EC0                 ;org 6EC0h
.text$mn:00006EC0 ; COMDAT (pick any)
.text$mn:00006EC0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006EC0
.text$mn:00006EC0 ; =============== S U B R O U T I N E =======================================
.text$mn:00006EC0
.text$mn:00006EC0 ; Attributes: bp-based frame
.text$mn:00006EC0
.text$mn:00006EC0 ; _DWORD __thiscall std::_Container_proxy::_Container_proxy(std::_Container_proxy *__hidden this)
.text$mn:00006EC0                 public ??0_Container_proxy@std@@QAE@XZ
.text$mn:00006EC0 ??0_Container_proxy@std@@QAE@XZ proc near
.text$mn:00006EC0                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+23p
.text$mn:00006EC0                                         ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Alloc_proxy(void)+23p ...
.text$mn:00006EC0
.text$mn:00006EC0 var_4           = dword ptr -4
.text$mn:00006EC0
.text$mn:00006EC0                 push    ebp
.text$mn:00006EC1                 mov     ebp, esp
.text$mn:00006EC3                 push    ecx
.text$mn:00006EC4                 mov     [ebp+var_4], ecx
.text$mn:00006EC7                 mov     eax, [ebp+var_4]
.text$mn:00006ECA                 mov     dword ptr [eax], 0
.text$mn:00006ED0                 mov     ecx, [ebp+var_4]
.text$mn:00006ED3                 mov     dword ptr [ecx+4], 0
.text$mn:00006EDA                 mov     eax, [ebp+var_4]
.text$mn:00006EDD                 mov     esp, ebp
.text$mn:00006EDF                 pop     ebp
.text$mn:00006EE0                 retn
.text$mn:00006EE0 ??0_Container_proxy@std@@QAE@XZ endp
.text$mn:00006EE0
.text$mn:00006EE0 ; ---------------------------------------------------------------------------
.text$mn:00006EE1                 align 4
.text$mn:00006EE1 _text$mn        ends
.text$mn:00006EE1
.text$mn:00006EE4 ; ===========================================================================
.text$mn:00006EE4
.text$mn:00006EE4 ; Segment type: Pure code
.text$mn:00006EE4 ; Segment permissions: Read/Execute
.text$mn:00006EE4 _text$mn        segment para public 'CODE' use32
.text$mn:00006EE4                 assume cs:_text$mn
.text$mn:00006EE4                 ;org 6EE4h
.text$mn:00006EE4 ; COMDAT (pick any)
.text$mn:00006EE4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006EE4
.text$mn:00006EE4 ; =============== S U B R O U T I N E =======================================
.text$mn:00006EE4
.text$mn:00006EE4 ; Attributes: bp-based frame
.text$mn:00006EE4
.text$mn:00006EE4 ; _DWORD __thiscall std::_Generic_error_category::_Generic_error_category(std::_Generic_error_category *__hidden this)
.text$mn:00006EE4                 public ??0_Generic_error_category@std@@QAE@XZ
.text$mn:00006EE4 ??0_Generic_error_category@std@@QAE@XZ proc near
.text$mn:00006EE4                                         ; CODE XREF: std::_Iostream_error_category::_Iostream_error_category(void)+29p
.text$mn:00006EE4                                         ; std::_System_error_category::_System_error_category(void)+29p ...
.text$mn:00006EE4
.text$mn:00006EE4 var_10          = dword ptr -10h
.text$mn:00006EE4 var_C           = dword ptr -0Ch
.text$mn:00006EE4 var_4           = dword ptr -4
.text$mn:00006EE4
.text$mn:00006EE4                 push    ebp
.text$mn:00006EE5                 mov     ebp, esp
.text$mn:00006EE7                 push    0FFFFFFFFh
.text$mn:00006EE9                 push    offset __ehhandler$??0_Generic_error_category@std@@QAE@XZ
.text$mn:00006EEE                 mov     eax, large fs:0
.text$mn:00006EF4                 push    eax
.text$mn:00006EF5                 push    ecx
.text$mn:00006EF6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006EFB                 xor     eax, ebp
.text$mn:00006EFD                 push    eax
.text$mn:00006EFE                 lea     eax, [ebp+var_C]
.text$mn:00006F01                 mov     large fs:0, eax
.text$mn:00006F07                 mov     [ebp+var_10], ecx
.text$mn:00006F0A                 mov     ecx, [ebp+var_10] ; this
.text$mn:00006F0D                 call    ??0error_category@std@@QAE@XZ ; std::error_category::error_category(void)
.text$mn:00006F12                 mov     [ebp+var_4], 0
.text$mn:00006F19                 mov     eax, [ebp+var_10]
.text$mn:00006F1C                 mov     dword ptr [eax], offset ??_7_Generic_error_category@std@@6B@ ; const std::_Generic_error_category::`vftable'
.text$mn:00006F22                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006F29                 mov     eax, [ebp+var_10]
.text$mn:00006F2C                 mov     ecx, [ebp+var_C]
.text$mn:00006F2F                 mov     large fs:0, ecx
.text$mn:00006F36                 pop     ecx
.text$mn:00006F37                 mov     esp, ebp
.text$mn:00006F39                 pop     ebp
.text$mn:00006F3A                 retn
.text$mn:00006F3A ??0_Generic_error_category@std@@QAE@XZ endp
.text$mn:00006F3A
.text$mn:00006F3A ; ---------------------------------------------------------------------------
.text$mn:00006F3B                 align 4
.text$mn:00006F3B _text$mn        ends
.text$mn:00006F3B
.text$x:00006F3C ; ===========================================================================
.text$x:00006F3C
.text$x:00006F3C ; Segment type: Pure code
.text$x:00006F3C ; Segment permissions: Read/Execute
.text$x:00006F3C _text$x         segment para public 'CODE' use32
.text$x:00006F3C                 assume cs:_text$x
.text$x:00006F3C                 ;org 6F3Ch
.text$x:00006F3C ; COMDAT (pick associative to section at 6EE4)
.text$x:00006F3C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00006F3C
.text$x:00006F3C ; =============== S U B R O U T I N E =======================================
.text$x:00006F3C
.text$x:00006F3C
.text$x:00006F3C __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0 proc near
.text$x:00006F3C                                         ; DATA XREF: .xdata$x:0000C7E4o
.text$x:00006F3C                 mov     ecx, [ebp-10h]  ; this
.text$x:00006F3F                 jmp     ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$x:00006F3F __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0 endp
.text$x:00006F3F
.text$x:00006F44
.text$x:00006F44 ; =============== S U B R O U T I N E =======================================
.text$x:00006F44
.text$x:00006F44
.text$x:00006F44 __ehhandler$??0_Generic_error_category@std@@QAE@XZ proc near
.text$x:00006F44                                         ; DATA XREF: std::_Generic_error_category::_Generic_error_category(void)+5o
.text$x:00006F44
.text$x:00006F44 arg_4           = dword ptr  8
.text$x:00006F44
.text$x:00006F44                 mov     edx, [esp+arg_4]
.text$x:00006F48                 lea     eax, [edx+0Ch]
.text$x:00006F4B                 mov     ecx, [edx-8]
.text$x:00006F4E                 xor     ecx, eax
.text$x:00006F50                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006F55                 mov     eax, offset __ehfuncinfo$??0_Generic_error_category@std@@QAE@XZ
.text$x:00006F5A                 jmp     ___CxxFrameHandler3
.text$x:00006F5A __ehhandler$??0_Generic_error_category@std@@QAE@XZ endp
.text$x:00006F5A
.text$x:00006F5A ; ---------------------------------------------------------------------------
.text$x:00006F5F                 align 10h
.text$x:00006F5F _text$x         ends
.text$x:00006F5F
.text$mn:00006F60 ; ===========================================================================
.text$mn:00006F60
.text$mn:00006F60 ; Segment type: Pure code
.text$mn:00006F60 ; Segment permissions: Read/Execute
.text$mn:00006F60 _text$mn        segment para public 'CODE' use32
.text$mn:00006F60                 assume cs:_text$mn
.text$mn:00006F60                 ;org 6F60h
.text$mn:00006F60 ; COMDAT (pick any)
.text$mn:00006F60                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006F60
.text$mn:00006F60 ; =============== S U B R O U T I N E =======================================
.text$mn:00006F60
.text$mn:00006F60 ; Attributes: bp-based frame
.text$mn:00006F60
.text$mn:00006F60 ; _DWORD __thiscall std::_Ignore::_Ignore(std::_Ignore *__hidden this)
.text$mn:00006F60                 public ??0_Ignore@std@@QAE@XZ
.text$mn:00006F60 ??0_Ignore@std@@QAE@XZ proc near        ; CODE XREF: std::`dynamic initializer for 'ignore''(void)+8p
.text$mn:00006F60
.text$mn:00006F60 var_4           = dword ptr -4
.text$mn:00006F60
.text$mn:00006F60                 push    ebp
.text$mn:00006F61                 mov     ebp, esp
.text$mn:00006F63                 push    ecx
.text$mn:00006F64                 mov     [ebp+var_4], ecx
.text$mn:00006F67                 mov     eax, [ebp+var_4]
.text$mn:00006F6A                 mov     esp, ebp
.text$mn:00006F6C                 pop     ebp
.text$mn:00006F6D                 retn
.text$mn:00006F6D ??0_Ignore@std@@QAE@XZ endp
.text$mn:00006F6D
.text$mn:00006F6D ; ---------------------------------------------------------------------------
.text$mn:00006F6E                 align 10h
.text$mn:00006F6E _text$mn        ends
.text$mn:00006F6E
.text$mn:00006F70 ; ===========================================================================
.text$mn:00006F70
.text$mn:00006F70 ; Segment type: Pure code
.text$mn:00006F70 ; Segment permissions: Read/Execute
.text$mn:00006F70 _text$mn        segment para public 'CODE' use32
.text$mn:00006F70                 assume cs:_text$mn
.text$mn:00006F70                 ;org 6F70h
.text$mn:00006F70 ; COMDAT (pick any)
.text$mn:00006F70                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006F70
.text$mn:00006F70 ; =============== S U B R O U T I N E =======================================
.text$mn:00006F70
.text$mn:00006F70 ; Attributes: bp-based frame
.text$mn:00006F70
.text$mn:00006F70 ; _DWORD __thiscall std::_Iostream_error_category::_Iostream_error_category(std::_Iostream_error_category *__hidden this)
.text$mn:00006F70                 public ??0_Iostream_error_category@std@@QAE@XZ
.text$mn:00006F70 ??0_Iostream_error_category@std@@QAE@XZ proc near
.text$mn:00006F70                                         ; CODE XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p
.text$mn:00006F70
.text$mn:00006F70 var_10          = dword ptr -10h
.text$mn:00006F70 var_C           = dword ptr -0Ch
.text$mn:00006F70 var_4           = dword ptr -4
.text$mn:00006F70
.text$mn:00006F70                 push    ebp
.text$mn:00006F71                 mov     ebp, esp
.text$mn:00006F73                 push    0FFFFFFFFh
.text$mn:00006F75                 push    offset __ehhandler$??0_Iostream_error_category@std@@QAE@XZ
.text$mn:00006F7A                 mov     eax, large fs:0
.text$mn:00006F80                 push    eax
.text$mn:00006F81                 push    ecx
.text$mn:00006F82                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006F87                 xor     eax, ebp
.text$mn:00006F89                 push    eax
.text$mn:00006F8A                 lea     eax, [ebp+var_C]
.text$mn:00006F8D                 mov     large fs:0, eax
.text$mn:00006F93                 mov     [ebp+var_10], ecx
.text$mn:00006F96                 mov     ecx, [ebp+var_10] ; this
.text$mn:00006F99                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$mn:00006F9E                 mov     [ebp+var_4], 0
.text$mn:00006FA5                 mov     eax, [ebp+var_10]
.text$mn:00006FA8                 mov     dword ptr [eax], offset ??_7_Iostream_error_category@std@@6B@ ; const std::_Iostream_error_category::`vftable'
.text$mn:00006FAE                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006FB5                 mov     eax, [ebp+var_10]
.text$mn:00006FB8                 mov     ecx, [ebp+var_C]
.text$mn:00006FBB                 mov     large fs:0, ecx
.text$mn:00006FC2                 pop     ecx
.text$mn:00006FC3                 mov     esp, ebp
.text$mn:00006FC5                 pop     ebp
.text$mn:00006FC6                 retn
.text$mn:00006FC6 ??0_Iostream_error_category@std@@QAE@XZ endp
.text$mn:00006FC6
.text$mn:00006FC6 ; ---------------------------------------------------------------------------
.text$mn:00006FC7                 align 4
.text$mn:00006FC7 _text$mn        ends
.text$mn:00006FC7
.text$x:00006FC8 ; ===========================================================================
.text$x:00006FC8
.text$x:00006FC8 ; Segment type: Pure code
.text$x:00006FC8 ; Segment permissions: Read/Execute
.text$x:00006FC8 _text$x         segment para public 'CODE' use32
.text$x:00006FC8                 assume cs:_text$x
.text$x:00006FC8                 ;org 6FC8h
.text$x:00006FC8 ; COMDAT (pick associative to section at 6F70)
.text$x:00006FC8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00006FC8
.text$x:00006FC8 ; =============== S U B R O U T I N E =======================================
.text$x:00006FC8
.text$x:00006FC8
.text$x:00006FC8 __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0 proc near
.text$x:00006FC8                                         ; DATA XREF: .xdata$x:0000C868o
.text$x:00006FC8                 mov     ecx, [ebp-10h]  ; this
.text$x:00006FCB                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00006FCB __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0 endp
.text$x:00006FCB
.text$x:00006FD0
.text$x:00006FD0 ; =============== S U B R O U T I N E =======================================
.text$x:00006FD0
.text$x:00006FD0
.text$x:00006FD0 __ehhandler$??0_Iostream_error_category@std@@QAE@XZ proc near
.text$x:00006FD0                                         ; DATA XREF: std::_Iostream_error_category::_Iostream_error_category(void)+5o
.text$x:00006FD0
.text$x:00006FD0 arg_4           = dword ptr  8
.text$x:00006FD0
.text$x:00006FD0                 mov     edx, [esp+arg_4]
.text$x:00006FD4                 lea     eax, [edx+0Ch]
.text$x:00006FD7                 mov     ecx, [edx-8]
.text$x:00006FDA                 xor     ecx, eax
.text$x:00006FDC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006FE1                 mov     eax, offset __ehfuncinfo$??0_Iostream_error_category@std@@QAE@XZ
.text$x:00006FE6                 jmp     ___CxxFrameHandler3
.text$x:00006FE6 __ehhandler$??0_Iostream_error_category@std@@QAE@XZ endp
.text$x:00006FE6
.text$x:00006FE6 ; ---------------------------------------------------------------------------
.text$x:00006FEB                 align 4
.text$x:00006FEB _text$x         ends
.text$x:00006FEB
.text$mn:00006FEC ; ===========================================================================
.text$mn:00006FEC
.text$mn:00006FEC ; Segment type: Pure code
.text$mn:00006FEC ; Segment permissions: Read/Execute
.text$mn:00006FEC _text$mn        segment para public 'CODE' use32
.text$mn:00006FEC                 assume cs:_text$mn
.text$mn:00006FEC                 ;org 6FECh
.text$mn:00006FEC ; COMDAT (pick any)
.text$mn:00006FEC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006FEC
.text$mn:00006FEC ; =============== S U B R O U T I N E =======================================
.text$mn:00006FEC
.text$mn:00006FEC ; Attributes: bp-based frame
.text$mn:00006FEC
.text$mn:00006FEC ; _DWORD __thiscall std::_Iterator_base12::_Iterator_base12(std::_Iterator_base12 *this, const struct std::_Iterator_base12 *)
.text$mn:00006FEC                 public ??0_Iterator_base12@std@@QAE@ABU01@@Z
.text$mn:00006FEC ??0_Iterator_base12@std@@QAE@ABU01@@Z proc near
.text$mn:00006FEC                                         ; CODE XREF: std::_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>(std::_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12> const &)+2Dp
.text$mn:00006FEC                                         ; std::_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>(std::_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12> const &)+2Dp
.text$mn:00006FEC
.text$mn:00006FEC var_4           = dword ptr -4
.text$mn:00006FEC arg_0           = dword ptr  8
.text$mn:00006FEC
.text$mn:00006FEC                 push    ebp
.text$mn:00006FED                 mov     ebp, esp
.text$mn:00006FEF                 push    ecx
.text$mn:00006FF0                 mov     [ebp+var_4], ecx
.text$mn:00006FF3                 mov     eax, [ebp+var_4]
.text$mn:00006FF6                 mov     dword ptr [eax], 0
.text$mn:00006FFC                 mov     ecx, [ebp+var_4]
.text$mn:00006FFF                 mov     dword ptr [ecx+4], 0
.text$mn:00007006                 mov     edx, [ebp+arg_0]
.text$mn:00007009                 push    edx
.text$mn:0000700A                 mov     ecx, [ebp+var_4]
.text$mn:0000700D                 call    ??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z ; std::_Iterator_base12::operator=(std::_Iterator_base12 const &)
.text$mn:00007012                 mov     eax, [ebp+var_4]
.text$mn:00007015                 mov     esp, ebp
.text$mn:00007017                 pop     ebp
.text$mn:00007018                 retn    4
.text$mn:00007018 ??0_Iterator_base12@std@@QAE@ABU01@@Z endp
.text$mn:00007018
.text$mn:00007018 ; ---------------------------------------------------------------------------
.text$mn:0000701B                 align 4
.text$mn:0000701B _text$mn        ends
.text$mn:0000701B
.text$mn:0000701C ; ===========================================================================
.text$mn:0000701C
.text$mn:0000701C ; Segment type: Pure code
.text$mn:0000701C ; Segment permissions: Read/Execute
.text$mn:0000701C _text$mn        segment para public 'CODE' use32
.text$mn:0000701C                 assume cs:_text$mn
.text$mn:0000701C                 ;org 701Ch
.text$mn:0000701C ; COMDAT (pick any)
.text$mn:0000701C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000701C
.text$mn:0000701C ; =============== S U B R O U T I N E =======================================
.text$mn:0000701C
.text$mn:0000701C ; Attributes: bp-based frame
.text$mn:0000701C
.text$mn:0000701C ; _DWORD __thiscall std::_Iterator_base12::_Iterator_base12(std::_Iterator_base12 *__hidden this)
.text$mn:0000701C                 public ??0_Iterator_base12@std@@QAE@XZ
.text$mn:0000701C ??0_Iterator_base12@std@@QAE@XZ proc near
.text$mn:0000701C                                         ; CODE XREF: std::_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>(void)+29p
.text$mn:0000701C                                         ; std::_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>(void)+29p
.text$mn:0000701C
.text$mn:0000701C var_4           = dword ptr -4
.text$mn:0000701C
.text$mn:0000701C                 push    ebp
.text$mn:0000701D                 mov     ebp, esp
.text$mn:0000701F                 push    ecx
.text$mn:00007020                 mov     [ebp+var_4], ecx
.text$mn:00007023                 mov     eax, [ebp+var_4]
.text$mn:00007026                 mov     dword ptr [eax], 0
.text$mn:0000702C                 mov     ecx, [ebp+var_4]
.text$mn:0000702F                 mov     dword ptr [ecx+4], 0
.text$mn:00007036                 mov     eax, [ebp+var_4]
.text$mn:00007039                 mov     esp, ebp
.text$mn:0000703B                 pop     ebp
.text$mn:0000703C                 retn
.text$mn:0000703C ??0_Iterator_base12@std@@QAE@XZ endp
.text$mn:0000703C
.text$mn:0000703C ; ---------------------------------------------------------------------------
.text$mn:0000703D                 align 10h
.text$mn:0000703D _text$mn        ends
.text$mn:0000703D
.text$mn:00007040 ; ===========================================================================
.text$mn:00007040
.text$mn:00007040 ; Segment type: Pure code
.text$mn:00007040 ; Segment permissions: Read/Execute
.text$mn:00007040 _text$mn        segment para public 'CODE' use32
.text$mn:00007040                 assume cs:_text$mn
.text$mn:00007040                 ;org 7040h
.text$mn:00007040 ; COMDAT (pick any)
.text$mn:00007040                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007040
.text$mn:00007040 ; =============== S U B R O U T I N E =======================================
.text$mn:00007040
.text$mn:00007040 ; Attributes: bp-based frame
.text$mn:00007040
.text$mn:00007040 ; _DWORD __thiscall std::_System_error_category::_System_error_category(std::_System_error_category *__hidden this)
.text$mn:00007040                 public ??0_System_error_category@std@@QAE@XZ
.text$mn:00007040 ??0_System_error_category@std@@QAE@XZ proc near
.text$mn:00007040                                         ; CODE XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p
.text$mn:00007040
.text$mn:00007040 var_10          = dword ptr -10h
.text$mn:00007040 var_C           = dword ptr -0Ch
.text$mn:00007040 var_4           = dword ptr -4
.text$mn:00007040
.text$mn:00007040                 push    ebp
.text$mn:00007041                 mov     ebp, esp
.text$mn:00007043                 push    0FFFFFFFFh
.text$mn:00007045                 push    offset __ehhandler$??0_System_error_category@std@@QAE@XZ
.text$mn:0000704A                 mov     eax, large fs:0
.text$mn:00007050                 push    eax
.text$mn:00007051                 push    ecx
.text$mn:00007052                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00007057                 xor     eax, ebp
.text$mn:00007059                 push    eax
.text$mn:0000705A                 lea     eax, [ebp+var_C]
.text$mn:0000705D                 mov     large fs:0, eax
.text$mn:00007063                 mov     [ebp+var_10], ecx
.text$mn:00007066                 mov     ecx, [ebp+var_10] ; this
.text$mn:00007069                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$mn:0000706E                 mov     [ebp+var_4], 0
.text$mn:00007075                 mov     eax, [ebp+var_10]
.text$mn:00007078                 mov     dword ptr [eax], offset ??_7_System_error_category@std@@6B@ ; const std::_System_error_category::`vftable'
.text$mn:0000707E                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00007085                 mov     eax, [ebp+var_10]
.text$mn:00007088                 mov     ecx, [ebp+var_C]
.text$mn:0000708B                 mov     large fs:0, ecx
.text$mn:00007092                 pop     ecx
.text$mn:00007093                 mov     esp, ebp
.text$mn:00007095                 pop     ebp
.text$mn:00007096                 retn
.text$mn:00007096 ??0_System_error_category@std@@QAE@XZ endp
.text$mn:00007096
.text$mn:00007096 ; ---------------------------------------------------------------------------
.text$mn:00007097                 align 4
.text$mn:00007097 _text$mn        ends
.text$mn:00007097
.text$x:00007098 ; ===========================================================================
.text$x:00007098
.text$x:00007098 ; Segment type: Pure code
.text$x:00007098 ; Segment permissions: Read/Execute
.text$x:00007098 _text$x         segment para public 'CODE' use32
.text$x:00007098                 assume cs:_text$x
.text$x:00007098                 ;org 7098h
.text$x:00007098 ; COMDAT (pick associative to section at 7040)
.text$x:00007098                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00007098
.text$x:00007098 ; =============== S U B R O U T I N E =======================================
.text$x:00007098
.text$x:00007098
.text$x:00007098 __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0 proc near
.text$x:00007098                                         ; DATA XREF: .xdata$x:0000C8ECo
.text$x:00007098                 mov     ecx, [ebp-10h]  ; this
.text$x:0000709B                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:0000709B __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0 endp
.text$x:0000709B
.text$x:000070A0
.text$x:000070A0 ; =============== S U B R O U T I N E =======================================
.text$x:000070A0
.text$x:000070A0
.text$x:000070A0 __ehhandler$??0_System_error_category@std@@QAE@XZ proc near
.text$x:000070A0                                         ; DATA XREF: std::_System_error_category::_System_error_category(void)+5o
.text$x:000070A0
.text$x:000070A0 arg_4           = dword ptr  8
.text$x:000070A0
.text$x:000070A0                 mov     edx, [esp+arg_4]
.text$x:000070A4                 lea     eax, [edx+0Ch]
.text$x:000070A7                 mov     ecx, [edx-8]
.text$x:000070AA                 xor     ecx, eax
.text$x:000070AC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000070B1                 mov     eax, offset __ehfuncinfo$??0_System_error_category@std@@QAE@XZ
.text$x:000070B6                 jmp     ___CxxFrameHandler3
.text$x:000070B6 __ehhandler$??0_System_error_category@std@@QAE@XZ endp
.text$x:000070B6
.text$x:000070B6 ; ---------------------------------------------------------------------------
.text$x:000070BB                 align 4
.text$x:000070BB _text$x         ends
.text$x:000070BB
.text$mn:000070BC ; ===========================================================================
.text$mn:000070BC
.text$mn:000070BC ; Segment type: Pure code
.text$mn:000070BC ; Segment permissions: Read/Execute
.text$mn:000070BC _text$mn        segment para public 'CODE' use32
.text$mn:000070BC                 assume cs:_text$mn
.text$mn:000070BC                 ;org 70BCh
.text$mn:000070BC ; COMDAT (pick any)
.text$mn:000070BC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000070BC
.text$mn:000070BC ; =============== S U B R O U T I N E =======================================
.text$mn:000070BC
.text$mn:000070BC ; Attributes: bp-based frame
.text$mn:000070BC
.text$mn:000070BC ; _DWORD __thiscall std::error_category::error_category(std::error_category *__hidden this)
.text$mn:000070BC                 public ??0error_category@std@@QAE@XZ
.text$mn:000070BC ??0error_category@std@@QAE@XZ proc near ; CODE XREF: std::_Generic_error_category::_Generic_error_category(void)+29p
.text$mn:000070BC
.text$mn:000070BC var_4           = dword ptr -4
.text$mn:000070BC
.text$mn:000070BC                 push    ebp
.text$mn:000070BD                 mov     ebp, esp
.text$mn:000070BF                 push    ecx
.text$mn:000070C0                 mov     [ebp+var_4], ecx
.text$mn:000070C3                 mov     eax, [ebp+var_4]
.text$mn:000070C6                 mov     dword ptr [eax], offset ??_7error_category@std@@6B@ ; const std::error_category::`vftable'
.text$mn:000070CC                 mov     eax, [ebp+var_4]
.text$mn:000070CF                 mov     esp, ebp
.text$mn:000070D1                 pop     ebp
.text$mn:000070D2                 retn
.text$mn:000070D2 ??0error_category@std@@QAE@XZ endp
.text$mn:000070D2
.text$mn:000070D2 ; ---------------------------------------------------------------------------
.text$mn:000070D3                 align 4
.text$mn:000070D3 _text$mn        ends
.text$mn:000070D3
.text$mn:000070D4 ; ===========================================================================
.text$mn:000070D4
.text$mn:000070D4 ; Segment type: Pure code
.text$mn:000070D4 ; Segment permissions: Read/Execute
.text$mn:000070D4 _text$mn        segment para public 'CODE' use32
.text$mn:000070D4                 assume cs:_text$mn
.text$mn:000070D4                 ;org 70D4h
.text$mn:000070D4 ; COMDAT (pick any)
.text$mn:000070D4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000070D4
.text$mn:000070D4 ; =============== S U B R O U T I N E =======================================
.text$mn:000070D4
.text$mn:000070D4 ; Attributes: bp-based frame
.text$mn:000070D4
.text$mn:000070D4 ; _DWORD __thiscall std::error_condition::error_condition(std::error_condition *this, int, const struct std::error_category *)
.text$mn:000070D4                 public ??0error_condition@std@@QAE@HABVerror_category@1@@Z
.text$mn:000070D4 ??0error_condition@std@@QAE@HABVerror_category@1@@Z proc near
.text$mn:000070D4                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+24p
.text$mn:000070D4                                         ; std::_System_error_category::default_error_condition(int)+3Dp ...
.text$mn:000070D4
.text$mn:000070D4 var_4           = dword ptr -4
.text$mn:000070D4 arg_0           = dword ptr  8
.text$mn:000070D4 arg_4           = dword ptr  0Ch
.text$mn:000070D4
.text$mn:000070D4                 push    ebp
.text$mn:000070D5                 mov     ebp, esp
.text$mn:000070D7                 push    ecx
.text$mn:000070D8                 mov     [ebp+var_4], ecx
.text$mn:000070DB                 mov     eax, [ebp+var_4]
.text$mn:000070DE                 mov     ecx, [ebp+arg_0]
.text$mn:000070E1                 mov     [eax], ecx
.text$mn:000070E3                 mov     edx, [ebp+var_4]
.text$mn:000070E6                 mov     eax, [ebp+arg_4]
.text$mn:000070E9                 mov     [edx+4], eax
.text$mn:000070EC                 mov     eax, [ebp+var_4]
.text$mn:000070EF                 mov     esp, ebp
.text$mn:000070F1                 pop     ebp
.text$mn:000070F2                 retn    8
.text$mn:000070F2 ??0error_condition@std@@QAE@HABVerror_category@1@@Z endp
.text$mn:000070F2
.text$mn:000070F2 ; ---------------------------------------------------------------------------
.text$mn:000070F5                 align 4
.text$mn:000070F5 _text$mn        ends
.text$mn:000070F5
.text$mn:000070F8 ; ===========================================================================
.text$mn:000070F8
.text$mn:000070F8 ; Segment type: Pure code
.text$mn:000070F8 ; Segment permissions: Read/Execute
.text$mn:000070F8 _text$mn        segment para public 'CODE' use32
.text$mn:000070F8                 assume cs:_text$mn
.text$mn:000070F8                 ;org 70F8h
.text$mn:000070F8 ; COMDAT (pick any)
.text$mn:000070F8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000070F8
.text$mn:000070F8 ; =============== S U B R O U T I N E =======================================
.text$mn:000070F8
.text$mn:000070F8 ; Attributes: bp-based frame
.text$mn:000070F8
.text$mn:000070F8 ; _DWORD __thiscall std::locale::id::id(std::locale::id *this, unsigned int)
.text$mn:000070F8                 public ??0id@locale@std@@QAE@I@Z
.text$mn:000070F8 ??0id@locale@std@@QAE@I@Z proc near     ; CODE XREF: `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)+Ap
.text$mn:000070F8                                         ; `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)+Ap ...
.text$mn:000070F8
.text$mn:000070F8 var_4           = dword ptr -4
.text$mn:000070F8 arg_0           = dword ptr  8
.text$mn:000070F8
.text$mn:000070F8                 push    ebp
.text$mn:000070F9                 mov     ebp, esp
.text$mn:000070FB                 push    ecx
.text$mn:000070FC                 mov     [ebp+var_4], ecx
.text$mn:000070FF                 mov     eax, [ebp+var_4]
.text$mn:00007102                 mov     ecx, [ebp+arg_0]
.text$mn:00007105                 mov     [eax], ecx
.text$mn:00007107                 mov     eax, [ebp+var_4]
.text$mn:0000710A                 mov     esp, ebp
.text$mn:0000710C                 pop     ebp
.text$mn:0000710D                 retn    4
.text$mn:0000710D ??0id@locale@std@@QAE@I@Z endp
.text$mn:0000710D
.text$mn:0000710D _text$mn        ends
.text$mn:0000710D
.text$mn:00007110 ; ===========================================================================
.text$mn:00007110
.text$mn:00007110 ; Segment type: Pure code
.text$mn:00007110 ; Segment permissions: Read/Execute
.text$mn:00007110 _text$mn        segment para public 'CODE' use32
.text$mn:00007110                 assume cs:_text$mn
.text$mn:00007110                 ;org 7110h
.text$mn:00007110 ; COMDAT (pick any)
.text$mn:00007110                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007110
.text$mn:00007110 ; =============== S U B R O U T I N E =======================================
.text$mn:00007110
.text$mn:00007110 ; Attributes: bp-based frame
.text$mn:00007110
.text$mn:00007110 ; public: __thiscall std::_Iterator012<struct std::random_access_iterator_tag, int, int, int const *, int const &, struct std::_Iterator_base12>::~_Iterator012<struct std::random_access_iterator_tag, int, int, int const *, int const &, struct std::_Iterator_base12>(void)
.text$mn:00007110                 public ??1?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ
.text$mn:00007110 ??1?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ proc near
.text$mn:00007110                                         ; CODE XREF: __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z$0+3j
.text$mn:00007110                                         ; __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z$0+3j ...
.text$mn:00007110
.text$mn:00007110 var_10          = dword ptr -10h
.text$mn:00007110 var_C           = dword ptr -0Ch
.text$mn:00007110 var_4           = dword ptr -4
.text$mn:00007110
.text$mn:00007110                 push    ebp
.text$mn:00007111                 mov     ebp, esp
.text$mn:00007113                 push    0FFFFFFFFh
.text$mn:00007115                 push    offset __ehhandler$??1?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ
.text$mn:0000711A                 mov     eax, large fs:0
.text$mn:00007120                 push    eax
.text$mn:00007121                 push    ecx
.text$mn:00007122                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00007127                 xor     eax, ebp
.text$mn:00007129                 push    eax
.text$mn:0000712A                 lea     eax, [ebp+var_C]
.text$mn:0000712D                 mov     large fs:0, eax
.text$mn:00007133                 mov     [ebp+var_10], ecx
.text$mn:00007136                 mov     [ebp+var_4], 0
.text$mn:0000713D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00007144                 mov     ecx, [ebp+var_10] ; this
.text$mn:00007147                 call    ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$mn:0000714C                 mov     ecx, [ebp+var_C]
.text$mn:0000714F                 mov     large fs:0, ecx
.text$mn:00007156                 pop     ecx
.text$mn:00007157                 mov     esp, ebp
.text$mn:00007159                 pop     ebp
.text$mn:0000715A                 retn
.text$mn:0000715A ??1?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ endp
.text$mn:0000715A
.text$mn:0000715A ; ---------------------------------------------------------------------------
.text$mn:0000715B                 align 4
.text$mn:0000715B _text$mn        ends
.text$mn:0000715B
.text$x:0000715C ; ===========================================================================
.text$x:0000715C
.text$x:0000715C ; Segment type: Pure code
.text$x:0000715C ; Segment permissions: Read/Execute
.text$x:0000715C _text$x         segment para public 'CODE' use32
.text$x:0000715C                 assume cs:_text$x
.text$x:0000715C                 ;org 715Ch
.text$x:0000715C ; COMDAT (pick associative to section at 7110)
.text$x:0000715C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000715C
.text$x:0000715C ; =============== S U B R O U T I N E =======================================
.text$x:0000715C
.text$x:0000715C
.text$x:0000715C __unwindfunclet$??1?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ$0 proc near
.text$x:0000715C                                         ; DATA XREF: .xdata$x:0000D0C4o
.text$x:0000715C                 mov     ecx, [ebp-10h]  ; this
.text$x:0000715F                 jmp     ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$x:0000715F __unwindfunclet$??1?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ$0 endp
.text$x:0000715F
.text$x:00007164
.text$x:00007164 ; =============== S U B R O U T I N E =======================================
.text$x:00007164
.text$x:00007164
.text$x:00007164 __ehhandler$??1?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ proc near
.text$x:00007164                                         ; DATA XREF: std::_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>(void)+5o
.text$x:00007164
.text$x:00007164 arg_4           = dword ptr  8
.text$x:00007164
.text$x:00007164                 mov     edx, [esp+arg_4]
.text$x:00007168                 lea     eax, [edx+0Ch]
.text$x:0000716B                 mov     ecx, [edx-8]
.text$x:0000716E                 xor     ecx, eax
.text$x:00007170                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00007175                 mov     eax, offset __ehfuncinfo$??1?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ
.text$x:0000717A                 jmp     ___CxxFrameHandler3
.text$x:0000717A __ehhandler$??1?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ endp
.text$x:0000717A
.text$x:0000717A ; ---------------------------------------------------------------------------
.text$x:0000717F                 align 10h
.text$x:0000717F _text$x         ends
.text$x:0000717F
.text$mn:00007180 ; ===========================================================================
.text$mn:00007180
.text$mn:00007180 ; Segment type: Pure code
.text$mn:00007180 ; Segment permissions: Read/Execute
.text$mn:00007180 _text$mn        segment para public 'CODE' use32
.text$mn:00007180                 assume cs:_text$mn
.text$mn:00007180                 ;org 7180h
.text$mn:00007180 ; COMDAT (pick any)
.text$mn:00007180                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007180
.text$mn:00007180 ; =============== S U B R O U T I N E =======================================
.text$mn:00007180
.text$mn:00007180 ; Attributes: bp-based frame
.text$mn:00007180
.text$mn:00007180 ; public: __thiscall std::_Iterator012<struct std::random_access_iterator_tag, wchar_t, int, wchar_t const *, wchar_t const &, struct std::_Iterator_base12>::~_Iterator012<struct std::random_access_iterator_tag, wchar_t, int, wchar_t const *, wchar_t const &, struct std::_Iterator_base12>(void)
.text$mn:00007180                 public ??1?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ
.text$mn:00007180 ??1?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ proc near
.text$mn:00007180                                         ; CODE XREF: __unwindfunclet$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z$0+3j
.text$mn:00007180                                         ; __unwindfunclet$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PB_WPBU_Container_base12@1@@Z$0+3j ...
.text$mn:00007180
.text$mn:00007180 var_10          = dword ptr -10h
.text$mn:00007180 var_C           = dword ptr -0Ch
.text$mn:00007180 var_4           = dword ptr -4
.text$mn:00007180
.text$mn:00007180                 push    ebp
.text$mn:00007181                 mov     ebp, esp
.text$mn:00007183                 push    0FFFFFFFFh
.text$mn:00007185                 push    offset __ehhandler$??1?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ
.text$mn:0000718A                 mov     eax, large fs:0
.text$mn:00007190                 push    eax
.text$mn:00007191                 push    ecx
.text$mn:00007192                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00007197                 xor     eax, ebp
.text$mn:00007199                 push    eax
.text$mn:0000719A                 lea     eax, [ebp+var_C]
.text$mn:0000719D                 mov     large fs:0, eax
.text$mn:000071A3                 mov     [ebp+var_10], ecx
.text$mn:000071A6                 mov     [ebp+var_4], 0
.text$mn:000071AD                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000071B4                 mov     ecx, [ebp+var_10] ; this
.text$mn:000071B7                 call    ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$mn:000071BC                 mov     ecx, [ebp+var_C]
.text$mn:000071BF                 mov     large fs:0, ecx
.text$mn:000071C6                 pop     ecx
.text$mn:000071C7                 mov     esp, ebp
.text$mn:000071C9                 pop     ebp
.text$mn:000071CA                 retn
.text$mn:000071CA ??1?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ endp
.text$mn:000071CA
.text$mn:000071CA ; ---------------------------------------------------------------------------
.text$mn:000071CB                 align 4
.text$mn:000071CB _text$mn        ends
.text$mn:000071CB
.text$x:000071CC ; ===========================================================================
.text$x:000071CC
.text$x:000071CC ; Segment type: Pure code
.text$x:000071CC ; Segment permissions: Read/Execute
.text$x:000071CC _text$x         segment para public 'CODE' use32
.text$x:000071CC                 assume cs:_text$x
.text$x:000071CC                 ;org 71CCh
.text$x:000071CC ; COMDAT (pick associative to section at 7180)
.text$x:000071CC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000071CC
.text$x:000071CC ; =============== S U B R O U T I N E =======================================
.text$x:000071CC
.text$x:000071CC
.text$x:000071CC __unwindfunclet$??1?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ$0 proc near
.text$x:000071CC                                         ; DATA XREF: .xdata$x:0000D318o
.text$x:000071CC                 mov     ecx, [ebp-10h]  ; this
.text$x:000071CF                 jmp     ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$x:000071CF __unwindfunclet$??1?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ$0 endp
.text$x:000071CF
.text$x:000071D4
.text$x:000071D4 ; =============== S U B R O U T I N E =======================================
.text$x:000071D4
.text$x:000071D4
.text$x:000071D4 __ehhandler$??1?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ proc near
.text$x:000071D4                                         ; DATA XREF: std::_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>(void)+5o
.text$x:000071D4
.text$x:000071D4 arg_4           = dword ptr  8
.text$x:000071D4
.text$x:000071D4                 mov     edx, [esp+arg_4]
.text$x:000071D8                 lea     eax, [edx+0Ch]
.text$x:000071DB                 mov     ecx, [edx-8]
.text$x:000071DE                 xor     ecx, eax
.text$x:000071E0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000071E5                 mov     eax, offset __ehfuncinfo$??1?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ
.text$x:000071EA                 jmp     ___CxxFrameHandler3
.text$x:000071EA __ehhandler$??1?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ endp
.text$x:000071EA
.text$x:000071EA ; ---------------------------------------------------------------------------
.text$x:000071EF                 align 10h
.text$x:000071EF _text$x         ends
.text$x:000071EF
.text$mn:000071F0 ; ===========================================================================
.text$mn:000071F0
.text$mn:000071F0 ; Segment type: Pure code
.text$mn:000071F0 ; Segment permissions: Read/Execute
.text$mn:000071F0 _text$mn        segment para public 'CODE' use32
.text$mn:000071F0                 assume cs:_text$mn
.text$mn:000071F0                 ;org 71F0h
.text$mn:000071F0 ; COMDAT (pick any)
.text$mn:000071F0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000071F0
.text$mn:000071F0 ; =============== S U B R O U T I N E =======================================
.text$mn:000071F0
.text$mn:000071F0 ; Attributes: bp-based frame
.text$mn:000071F0
.text$mn:000071F0 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::~_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>(void)
.text$mn:000071F0                 public ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$mn:000071F0 ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
.text$mn:000071F0                                         ; CODE XREF: __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0+3j
.text$mn:000071F0                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+43p ...
.text$mn:000071F0
.text$mn:000071F0 var_10          = dword ptr -10h
.text$mn:000071F0 var_C           = dword ptr -0Ch
.text$mn:000071F0 var_4           = dword ptr -4
.text$mn:000071F0
.text$mn:000071F0                 push    ebp
.text$mn:000071F1                 mov     ebp, esp
.text$mn:000071F3                 push    0FFFFFFFFh
.text$mn:000071F5                 push    offset __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$mn:000071FA                 mov     eax, large fs:0
.text$mn:00007200                 push    eax
.text$mn:00007201                 push    ecx
.text$mn:00007202                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00007207                 xor     eax, ebp
.text$mn:00007209                 push    eax
.text$mn:0000720A                 lea     eax, [ebp+var_C]
.text$mn:0000720D                 mov     large fs:0, eax
.text$mn:00007213                 mov     [ebp+var_10], ecx
.text$mn:00007216                 mov     [ebp+var_4], 0
.text$mn:0000721D                 mov     ecx, [ebp+var_10]
.text$mn:00007220                 call    ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)
.text$mn:00007225                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000722C                 mov     ecx, [ebp+var_10]
.text$mn:0000722F                 call    ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$mn:00007234                 mov     ecx, [ebp+var_C]
.text$mn:00007237                 mov     large fs:0, ecx
.text$mn:0000723E                 pop     ecx
.text$mn:0000723F                 mov     esp, ebp
.text$mn:00007241                 pop     ebp
.text$mn:00007242                 retn
.text$mn:00007242 ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp
.text$mn:00007242
.text$mn:00007242 ; ---------------------------------------------------------------------------
.text$mn:00007243                 align 4
.text$mn:00007243 _text$mn        ends
.text$mn:00007243
.text$x:00007244 ; ===========================================================================
.text$x:00007244
.text$x:00007244 ; Segment type: Pure code
.text$x:00007244 ; Segment permissions: Read/Execute
.text$x:00007244 _text$x         segment para public 'CODE' use32
.text$x:00007244                 assume cs:_text$x
.text$x:00007244                 ;org 7244h
.text$x:00007244 ; COMDAT (pick associative to section at 71F0)
.text$x:00007244                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00007244
.text$x:00007244 ; =============== S U B R O U T I N E =======================================
.text$x:00007244
.text$x:00007244
.text$x:00007244 __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00007244                                         ; DATA XREF: .xdata$x:0000C6D4o
.text$x:00007244                 mov     ecx, [ebp-10h]
.text$x:00007247                 jmp     ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$x:00007247 __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:00007247
.text$x:0000724C
.text$x:0000724C ; =============== S U B R O U T I N E =======================================
.text$x:0000724C
.text$x:0000724C
.text$x:0000724C __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
.text$x:0000724C                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+5o
.text$x:0000724C
.text$x:0000724C arg_4           = dword ptr  8
.text$x:0000724C
.text$x:0000724C                 mov     edx, [esp+arg_4]
.text$x:00007250                 lea     eax, [edx+0Ch]
.text$x:00007253                 mov     ecx, [edx-8]
.text$x:00007256                 xor     ecx, eax
.text$x:00007258                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000725D                 mov     eax, offset __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$x:00007262                 jmp     ___CxxFrameHandler3
.text$x:00007262 __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp
.text$x:00007262
.text$x:00007262 ; ---------------------------------------------------------------------------
.text$x:00007267                 align 4
.text$x:00007267 _text$x         ends
.text$x:00007267
.text$mn:00007268 ; ===========================================================================
.text$mn:00007268
.text$mn:00007268 ; Segment type: Pure code
.text$mn:00007268 ; Segment permissions: Read/Execute
.text$mn:00007268 _text$mn        segment para public 'CODE' use32
.text$mn:00007268                 assume cs:_text$mn
.text$mn:00007268                 ;org 7268h
.text$mn:00007268 ; COMDAT (pick any)
.text$mn:00007268                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007268
.text$mn:00007268 ; =============== S U B R O U T I N E =======================================
.text$mn:00007268
.text$mn:00007268 ; Attributes: bp-based frame
.text$mn:00007268
.text$mn:00007268 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>::~_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>(void)
.text$mn:00007268                 public ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
.text$mn:00007268 ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00007268                                         ; CODE XREF: __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z$0+3j
.text$mn:00007268                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)+43p ...
.text$mn:00007268
.text$mn:00007268 var_10          = dword ptr -10h
.text$mn:00007268 var_C           = dword ptr -0Ch
.text$mn:00007268 var_4           = dword ptr -4
.text$mn:00007268
.text$mn:00007268                 push    ebp
.text$mn:00007269                 mov     ebp, esp
.text$mn:0000726B                 push    0FFFFFFFFh
.text$mn:0000726D                 push    offset __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
.text$mn:00007272                 mov     eax, large fs:0
.text$mn:00007278                 push    eax
.text$mn:00007279                 push    ecx
.text$mn:0000727A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000727F                 xor     eax, ebp
.text$mn:00007281                 push    eax
.text$mn:00007282                 lea     eax, [ebp+var_C]
.text$mn:00007285                 mov     large fs:0, eax
.text$mn:0000728B                 mov     [ebp+var_10], ecx
.text$mn:0000728E                 mov     [ebp+var_4], 0
.text$mn:00007295                 mov     ecx, [ebp+var_10]
.text$mn:00007298                 call    ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Free_proxy(void)
.text$mn:0000729D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000072A4                 mov     ecx, [ebp+var_10]
.text$mn:000072A7                 call    ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t>>::~_String_val<std::_Simple_types<wchar_t>>(void)
.text$mn:000072AC                 mov     ecx, [ebp+var_C]
.text$mn:000072AF                 mov     large fs:0, ecx
.text$mn:000072B6                 pop     ecx
.text$mn:000072B7                 mov     esp, ebp
.text$mn:000072B9                 pop     ebp
.text$mn:000072BA                 retn
.text$mn:000072BA ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ endp
.text$mn:000072BA
.text$mn:000072BA ; ---------------------------------------------------------------------------
.text$mn:000072BB                 align 4
.text$mn:000072BB _text$mn        ends
.text$mn:000072BB
.text$x:000072BC ; ===========================================================================
.text$x:000072BC
.text$x:000072BC ; Segment type: Pure code
.text$x:000072BC ; Segment permissions: Read/Execute
.text$x:000072BC _text$x         segment para public 'CODE' use32
.text$x:000072BC                 assume cs:_text$x
.text$x:000072BC                 ;org 72BCh
.text$x:000072BC ; COMDAT (pick associative to section at 7268)
.text$x:000072BC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000072BC
.text$x:000072BC ; =============== S U B R O U T I N E =======================================
.text$x:000072BC
.text$x:000072BC
.text$x:000072BC __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:000072BC                                         ; DATA XREF: .xdata$x:0000C9F4o
.text$x:000072BC                 mov     ecx, [ebp-10h]
.text$x:000072BF                 jmp     ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t>>::~_String_val<std::_Simple_types<wchar_t>>(void)
.text$x:000072BF __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:000072BF
.text$x:000072C4
.text$x:000072C4 ; =============== S U B R O U T I N E =======================================
.text$x:000072C4
.text$x:000072C4
.text$x:000072C4 __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ proc near
.text$x:000072C4                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)+5o
.text$x:000072C4
.text$x:000072C4 arg_4           = dword ptr  8
.text$x:000072C4
.text$x:000072C4                 mov     edx, [esp+arg_4]
.text$x:000072C8                 lea     eax, [edx+0Ch]
.text$x:000072CB                 mov     ecx, [edx-8]
.text$x:000072CE                 xor     ecx, eax
.text$x:000072D0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000072D5                 mov     eax, offset __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
.text$x:000072DA                 jmp     ___CxxFrameHandler3
.text$x:000072DA __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ endp
.text$x:000072DA
.text$x:000072DA ; ---------------------------------------------------------------------------
.text$x:000072DF                 align 10h
.text$x:000072DF _text$x         ends
.text$x:000072DF
.text$mn:000072E0 ; ===========================================================================
.text$mn:000072E0
.text$mn:000072E0 ; Segment type: Pure code
.text$mn:000072E0 ; Segment permissions: Read/Execute
.text$mn:000072E0 _text$mn        segment para public 'CODE' use32
.text$mn:000072E0                 assume cs:_text$mn
.text$mn:000072E0                 ;org 72E0h
.text$mn:000072E0 ; COMDAT (pick any)
.text$mn:000072E0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000072E0
.text$mn:000072E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000072E0
.text$mn:000072E0 ; Attributes: bp-based frame
.text$mn:000072E0
.text$mn:000072E0 ; public: __thiscall std::_String_const_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>>::~_String_const_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>>(void)
.text$mn:000072E0                 public ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ
.text$mn:000072E0 ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ proc near
.text$mn:000072E0                                         ; CODE XREF: __unwindfunclet$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z$0+3j
.text$mn:000072E0                                         ; __unwindfunclet$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base12@1@@Z$0+3j ...
.text$mn:000072E0
.text$mn:000072E0 var_10          = dword ptr -10h
.text$mn:000072E0 var_C           = dword ptr -0Ch
.text$mn:000072E0 var_4           = dword ptr -4
.text$mn:000072E0
.text$mn:000072E0                 push    ebp
.text$mn:000072E1                 mov     ebp, esp
.text$mn:000072E3                 push    0FFFFFFFFh
.text$mn:000072E5                 push    offset __ehhandler$??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ
.text$mn:000072EA                 mov     eax, large fs:0
.text$mn:000072F0                 push    eax
.text$mn:000072F1                 push    ecx
.text$mn:000072F2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000072F7                 xor     eax, ebp
.text$mn:000072F9                 push    eax
.text$mn:000072FA                 lea     eax, [ebp+var_C]
.text$mn:000072FD                 mov     large fs:0, eax
.text$mn:00007303                 mov     [ebp+var_10], ecx
.text$mn:00007306                 mov     [ebp+var_4], 0
.text$mn:0000730D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00007314                 mov     ecx, [ebp+var_10]
.text$mn:00007317                 call    ??1?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>(void)
.text$mn:0000731C                 mov     ecx, [ebp+var_C]
.text$mn:0000731F                 mov     large fs:0, ecx
.text$mn:00007326                 pop     ecx
.text$mn:00007327                 mov     esp, ebp
.text$mn:00007329                 pop     ebp
.text$mn:0000732A                 retn
.text$mn:0000732A ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ endp
.text$mn:0000732A
.text$mn:0000732A ; ---------------------------------------------------------------------------
.text$mn:0000732B                 align 4
.text$mn:0000732B _text$mn        ends
.text$mn:0000732B
.text$x:0000732C ; ===========================================================================
.text$x:0000732C
.text$x:0000732C ; Segment type: Pure code
.text$x:0000732C ; Segment permissions: Read/Execute
.text$x:0000732C _text$x         segment para public 'CODE' use32
.text$x:0000732C                 assume cs:_text$x
.text$x:0000732C                 ;org 732Ch
.text$x:0000732C ; COMDAT (pick associative to section at 72E0)
.text$x:0000732C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000732C
.text$x:0000732C ; =============== S U B R O U T I N E =======================================
.text$x:0000732C
.text$x:0000732C
.text$x:0000732C __unwindfunclet$??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:0000732C                                         ; DATA XREF: .xdata$x:0000D39Co
.text$x:0000732C                 mov     ecx, [ebp-10h]
.text$x:0000732F                 jmp     ??1?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>(void)
.text$x:0000732F __unwindfunclet$??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:0000732F
.text$x:00007334
.text$x:00007334 ; =============== S U B R O U T I N E =======================================
.text$x:00007334
.text$x:00007334
.text$x:00007334 __ehhandler$??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ proc near
.text$x:00007334                                         ; DATA XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)+5o
.text$x:00007334
.text$x:00007334 arg_4           = dword ptr  8
.text$x:00007334
.text$x:00007334                 mov     edx, [esp+arg_4]
.text$x:00007338                 lea     eax, [edx+0Ch]
.text$x:0000733B                 mov     ecx, [edx-8]
.text$x:0000733E                 xor     ecx, eax
.text$x:00007340                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00007345                 mov     eax, offset __ehfuncinfo$??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ
.text$x:0000734A                 jmp     ___CxxFrameHandler3
.text$x:0000734A __ehhandler$??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ endp
.text$x:0000734A
.text$x:0000734A ; ---------------------------------------------------------------------------
.text$x:0000734F                 align 10h
.text$x:0000734F _text$x         ends
.text$x:0000734F
.text$mn:00007350 ; ===========================================================================
.text$mn:00007350
.text$mn:00007350 ; Segment type: Pure code
.text$mn:00007350 ; Segment permissions: Read/Execute
.text$mn:00007350 _text$mn        segment para public 'CODE' use32
.text$mn:00007350                 assume cs:_text$mn
.text$mn:00007350                 ;org 7350h
.text$mn:00007350 ; COMDAT (pick any)
.text$mn:00007350                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007350
.text$mn:00007350 ; =============== S U B R O U T I N E =======================================
.text$mn:00007350
.text$mn:00007350 ; Attributes: bp-based frame
.text$mn:00007350
.text$mn:00007350 ; public: __thiscall std::_String_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>>::~_String_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>>(void)
.text$mn:00007350                 public ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ
.text$mn:00007350 ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00007350                                         ; CODE XREF: __unwindfunclet$?initPopupMenu@WindowsMenu@@QAEXPAUHMENU__@@PAVDocTabView@@@Z$2+6j
.text$mn:00007350                                         ; __unwindfunclet$?initPopupMenu@WindowsMenu@@QAEXPAUHMENU__@@PAVDocTabView@@@Z$3+3j ...
.text$mn:00007350
.text$mn:00007350 var_10          = dword ptr -10h
.text$mn:00007350 var_C           = dword ptr -0Ch
.text$mn:00007350 var_4           = dword ptr -4
.text$mn:00007350
.text$mn:00007350                 push    ebp
.text$mn:00007351                 mov     ebp, esp
.text$mn:00007353                 push    0FFFFFFFFh
.text$mn:00007355                 push    offset __ehhandler$??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ
.text$mn:0000735A                 mov     eax, large fs:0
.text$mn:00007360                 push    eax
.text$mn:00007361                 push    ecx
.text$mn:00007362                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00007367                 xor     eax, ebp
.text$mn:00007369                 push    eax
.text$mn:0000736A                 lea     eax, [ebp+var_C]
.text$mn:0000736D                 mov     large fs:0, eax
.text$mn:00007373                 mov     [ebp+var_10], ecx
.text$mn:00007376                 mov     [ebp+var_4], 0
.text$mn:0000737D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00007384                 mov     ecx, [ebp+var_10]
.text$mn:00007387                 call    ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$mn:0000738C                 mov     ecx, [ebp+var_C]
.text$mn:0000738F                 mov     large fs:0, ecx
.text$mn:00007396                 pop     ecx
.text$mn:00007397                 mov     esp, ebp
.text$mn:00007399                 pop     ebp
.text$mn:0000739A                 retn
.text$mn:0000739A ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ endp
.text$mn:0000739A
.text$mn:0000739A ; ---------------------------------------------------------------------------
.text$mn:0000739B                 align 4
.text$mn:0000739B _text$mn        ends
.text$mn:0000739B
.text$x:0000739C ; ===========================================================================
.text$x:0000739C
.text$x:0000739C ; Segment type: Pure code
.text$x:0000739C ; Segment permissions: Read/Execute
.text$x:0000739C _text$x         segment para public 'CODE' use32
.text$x:0000739C                 assume cs:_text$x
.text$x:0000739C                 ;org 739Ch
.text$x:0000739C ; COMDAT (pick associative to section at 7350)
.text$x:0000739C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000739C
.text$x:0000739C ; =============== S U B R O U T I N E =======================================
.text$x:0000739C
.text$x:0000739C
.text$x:0000739C __unwindfunclet$??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:0000739C                                         ; DATA XREF: .xdata$x:0000D44Co
.text$x:0000739C                 mov     ecx, [ebp-10h]
.text$x:0000739F                 jmp     ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:0000739F __unwindfunclet$??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:0000739F
.text$x:000073A4
.text$x:000073A4 ; =============== S U B R O U T I N E =======================================
.text$x:000073A4
.text$x:000073A4
.text$x:000073A4 __ehhandler$??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ proc near
.text$x:000073A4                                         ; DATA XREF: std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)+5o
.text$x:000073A4
.text$x:000073A4 arg_4           = dword ptr  8
.text$x:000073A4
.text$x:000073A4                 mov     edx, [esp+arg_4]
.text$x:000073A8                 lea     eax, [edx+0Ch]
.text$x:000073AB                 mov     ecx, [edx-8]
.text$x:000073AE                 xor     ecx, eax
.text$x:000073B0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000073B5                 mov     eax, offset __ehfuncinfo$??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ
.text$x:000073BA                 jmp     ___CxxFrameHandler3
.text$x:000073BA __ehhandler$??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ endp
.text$x:000073BA
.text$x:000073BA ; ---------------------------------------------------------------------------
.text$x:000073BF                 align 10h
.text$x:000073BF _text$x         ends
.text$x:000073BF
.text$mn:000073C0 ; ===========================================================================
.text$mn:000073C0
.text$mn:000073C0 ; Segment type: Pure code
.text$mn:000073C0 ; Segment permissions: Read/Execute
.text$mn:000073C0 _text$mn        segment para public 'CODE' use32
.text$mn:000073C0                 assume cs:_text$mn
.text$mn:000073C0                 ;org 73C0h
.text$mn:000073C0 ; COMDAT (pick any)
.text$mn:000073C0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000073C0
.text$mn:000073C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000073C0
.text$mn:000073C0 ; Attributes: bp-based frame
.text$mn:000073C0
.text$mn:000073C0 ; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::~_String_val<struct std::_Simple_types<char>>(void)
.text$mn:000073C0                 public ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:000073C0 ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$mn:000073C0                                         ; CODE XREF: __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0+3j
.text$mn:000073C0                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+3Fp ...
.text$mn:000073C0
.text$mn:000073C0 var_10          = dword ptr -10h
.text$mn:000073C0 var_C           = dword ptr -0Ch
.text$mn:000073C0 var_4           = dword ptr -4
.text$mn:000073C0
.text$mn:000073C0                 push    ebp
.text$mn:000073C1                 mov     ebp, esp
.text$mn:000073C3                 push    0FFFFFFFFh
.text$mn:000073C5                 push    offset __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:000073CA                 mov     eax, large fs:0
.text$mn:000073D0                 push    eax
.text$mn:000073D1                 push    ecx
.text$mn:000073D2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000073D7                 xor     eax, ebp
.text$mn:000073D9                 push    eax
.text$mn:000073DA                 lea     eax, [ebp+var_C]
.text$mn:000073DD                 mov     large fs:0, eax
.text$mn:000073E3                 mov     [ebp+var_10], ecx
.text$mn:000073E6                 mov     [ebp+var_4], 0
.text$mn:000073ED                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000073F4                 mov     ecx, [ebp+var_10] ; this
.text$mn:000073F7                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:000073FC                 mov     ecx, [ebp+var_C]
.text$mn:000073FF                 mov     large fs:0, ecx
.text$mn:00007406                 pop     ecx
.text$mn:00007407                 mov     esp, ebp
.text$mn:00007409                 pop     ebp
.text$mn:0000740A                 retn
.text$mn:0000740A ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$mn:0000740A
.text$mn:0000740A ; ---------------------------------------------------------------------------
.text$mn:0000740B                 align 4
.text$mn:0000740B _text$mn        ends
.text$mn:0000740B
.text$x:0000740C ; ===========================================================================
.text$x:0000740C
.text$x:0000740C ; Segment type: Pure code
.text$x:0000740C ; Segment permissions: Read/Execute
.text$x:0000740C _text$x         segment para public 'CODE' use32
.text$x:0000740C                 assume cs:_text$x
.text$x:0000740C                 ;org 740Ch
.text$x:0000740C ; COMDAT (pick associative to section at 73C0)
.text$x:0000740C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000740C
.text$x:0000740C ; =============== S U B R O U T I N E =======================================
.text$x:0000740C
.text$x:0000740C
.text$x:0000740C __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 proc near
.text$x:0000740C                                         ; DATA XREF: .xdata$x:0000C67Co
.text$x:0000740C                 mov     ecx, [ebp-10h]  ; this
.text$x:0000740F                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:0000740F __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 endp
.text$x:0000740F
.text$x:00007414
.text$x:00007414 ; =============== S U B R O U T I N E =======================================
.text$x:00007414
.text$x:00007414
.text$x:00007414 __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$x:00007414                                         ; DATA XREF: std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)+5o
.text$x:00007414
.text$x:00007414 arg_4           = dword ptr  8
.text$x:00007414
.text$x:00007414                 mov     edx, [esp+arg_4]
.text$x:00007418                 lea     eax, [edx+0Ch]
.text$x:0000741B                 mov     ecx, [edx-8]
.text$x:0000741E                 xor     ecx, eax
.text$x:00007420                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00007425                 mov     eax, offset __ehfuncinfo$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$x:0000742A                 jmp     ___CxxFrameHandler3
.text$x:0000742A __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$x:0000742A
.text$x:0000742A ; ---------------------------------------------------------------------------
.text$x:0000742F                 align 10h
.text$x:0000742F _text$x         ends
.text$x:0000742F
.text$mn:00007430 ; ===========================================================================
.text$mn:00007430
.text$mn:00007430 ; Segment type: Pure code
.text$mn:00007430 ; Segment permissions: Read/Execute
.text$mn:00007430 _text$mn        segment para public 'CODE' use32
.text$mn:00007430                 assume cs:_text$mn
.text$mn:00007430                 ;org 7430h
.text$mn:00007430 ; COMDAT (pick any)
.text$mn:00007430                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007430
.text$mn:00007430 ; =============== S U B R O U T I N E =======================================
.text$mn:00007430
.text$mn:00007430 ; Attributes: bp-based frame
.text$mn:00007430
.text$mn:00007430 ; public: __thiscall std::_String_val<struct std::_Simple_types<wchar_t>>::~_String_val<struct std::_Simple_types<wchar_t>>(void)
.text$mn:00007430                 public ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$mn:00007430 ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ proc near
.text$mn:00007430                                         ; CODE XREF: __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z$0+3j
.text$mn:00007430                                         ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)+3Fp ...
.text$mn:00007430
.text$mn:00007430 var_10          = dword ptr -10h
.text$mn:00007430 var_C           = dword ptr -0Ch
.text$mn:00007430 var_4           = dword ptr -4
.text$mn:00007430
.text$mn:00007430                 push    ebp
.text$mn:00007431                 mov     ebp, esp
.text$mn:00007433                 push    0FFFFFFFFh
.text$mn:00007435                 push    offset __ehhandler$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$mn:0000743A                 mov     eax, large fs:0
.text$mn:00007440                 push    eax
.text$mn:00007441                 push    ecx
.text$mn:00007442                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00007447                 xor     eax, ebp
.text$mn:00007449                 push    eax
.text$mn:0000744A                 lea     eax, [ebp+var_C]
.text$mn:0000744D                 mov     large fs:0, eax
.text$mn:00007453                 mov     [ebp+var_10], ecx
.text$mn:00007456                 mov     [ebp+var_4], 0
.text$mn:0000745D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00007464                 mov     ecx, [ebp+var_10] ; this
.text$mn:00007467                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:0000746C                 mov     ecx, [ebp+var_C]
.text$mn:0000746F                 mov     large fs:0, ecx
.text$mn:00007476                 pop     ecx
.text$mn:00007477                 mov     esp, ebp
.text$mn:00007479                 pop     ebp
.text$mn:0000747A                 retn
.text$mn:0000747A ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ endp
.text$mn:0000747A
.text$mn:0000747A ; ---------------------------------------------------------------------------
.text$mn:0000747B                 align 4
.text$mn:0000747B _text$mn        ends
.text$mn:0000747B
.text$x:0000747C ; ===========================================================================
.text$x:0000747C
.text$x:0000747C ; Segment type: Pure code
.text$x:0000747C ; Segment permissions: Read/Execute
.text$x:0000747C _text$x         segment para public 'CODE' use32
.text$x:0000747C                 assume cs:_text$x
.text$x:0000747C                 ;org 747Ch
.text$x:0000747C ; COMDAT (pick associative to section at 7430)
.text$x:0000747C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000747C
.text$x:0000747C ; =============== S U B R O U T I N E =======================================
.text$x:0000747C
.text$x:0000747C
.text$x:0000747C __unwindfunclet$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0 proc near
.text$x:0000747C                                         ; DATA XREF: .xdata$x:0000C99Co
.text$x:0000747C                 mov     ecx, [ebp-10h]  ; this
.text$x:0000747F                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:0000747F __unwindfunclet$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0 endp
.text$x:0000747F
.text$x:00007484
.text$x:00007484 ; =============== S U B R O U T I N E =======================================
.text$x:00007484
.text$x:00007484
.text$x:00007484 __ehhandler$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ proc near
.text$x:00007484                                         ; DATA XREF: std::_String_val<std::_Simple_types<wchar_t>>::~_String_val<std::_Simple_types<wchar_t>>(void)+5o
.text$x:00007484
.text$x:00007484 arg_4           = dword ptr  8
.text$x:00007484
.text$x:00007484                 mov     edx, [esp+arg_4]
.text$x:00007488                 lea     eax, [edx+0Ch]
.text$x:0000748B                 mov     ecx, [edx-8]
.text$x:0000748E                 xor     ecx, eax
.text$x:00007490                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00007495                 mov     eax, offset __ehfuncinfo$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$x:0000749A                 jmp     ___CxxFrameHandler3
.text$x:0000749A __ehhandler$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ endp
.text$x:0000749A
.text$x:0000749A ; ---------------------------------------------------------------------------
.text$x:0000749F                 align 10h
.text$x:0000749F _text$x         ends
.text$x:0000749F
.text$mn:000074A0 ; ===========================================================================
.text$mn:000074A0
.text$mn:000074A0 ; Segment type: Pure code
.text$mn:000074A0 ; Segment permissions: Read/Execute
.text$mn:000074A0 _text$mn        segment para public 'CODE' use32
.text$mn:000074A0                 assume cs:_text$mn
.text$mn:000074A0                 ;org 74A0h
.text$mn:000074A0 ; COMDAT (pick any)
.text$mn:000074A0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000074A0
.text$mn:000074A0 ; =============== S U B R O U T I N E =======================================
.text$mn:000074A0
.text$mn:000074A0 ; Attributes: bp-based frame
.text$mn:000074A0
.text$mn:000074A0 ; public: __thiscall std::_Temp_iterator<int>::~_Temp_iterator<int>(void)
.text$mn:000074A0                 public ??1?$_Temp_iterator@H@std@@QAE@XZ
.text$mn:000074A0 ??1?$_Temp_iterator@H@std@@QAE@XZ proc near
.text$mn:000074A0                                         ; CODE XREF: std::_Buffered_merge<int *,int,int,BufferEquivalent>(int *,int *,int *,int,int,std::_Temp_iterator<int> &,BufferEquivalent)+F7p
.text$mn:000074A0                                         ; std::_Buffered_merge<int *,int,int,BufferEquivalent>(int *,int *,int *,int,int,std::_Temp_iterator<int> &,BufferEquivalent)+19Bp ...
.text$mn:000074A0
.text$mn:000074A0 var_8           = dword ptr -8
.text$mn:000074A0 var_4           = dword ptr -4
.text$mn:000074A0
.text$mn:000074A0                 push    ebp
.text$mn:000074A1                 mov     ebp, esp
.text$mn:000074A3                 sub     esp, 8
.text$mn:000074A6                 mov     [ebp+var_8], ecx
.text$mn:000074A9                 mov     eax, [ebp+var_8]
.text$mn:000074AC                 cmp     dword ptr [eax], 0
.text$mn:000074AF                 jz      short loc_74EB
.text$mn:000074B1                 mov     ecx, [ebp+var_8]
.text$mn:000074B4                 mov     edx, [ecx]
.text$mn:000074B6                 mov     [ebp+var_4], edx
.text$mn:000074B9                 jmp     short loc_74C4
.text$mn:000074BB ; ---------------------------------------------------------------------------
.text$mn:000074BB
.text$mn:000074BB loc_74BB:                               ; CODE XREF: std::_Temp_iterator<int>::~_Temp_iterator<int>(void)+3Bj
.text$mn:000074BB                 mov     eax, [ebp+var_4]
.text$mn:000074BE                 add     eax, 4
.text$mn:000074C1                 mov     [ebp+var_4], eax
.text$mn:000074C4
.text$mn:000074C4 loc_74C4:                               ; CODE XREF: std::_Temp_iterator<int>::~_Temp_iterator<int>(void)+19j
.text$mn:000074C4                 mov     ecx, [ebp+var_8]
.text$mn:000074C7                 mov     edx, [ebp+var_4]
.text$mn:000074CA                 cmp     edx, [ecx+8]
.text$mn:000074CD                 jz      short loc_74DD
.text$mn:000074CF                 mov     eax, [ebp+var_4]
.text$mn:000074D2                 push    eax
.text$mn:000074D3                 call    ??$_Destroy@H@std@@YAXPAH@Z ; std::_Destroy<int>(int *)
.text$mn:000074D8                 add     esp, 4
.text$mn:000074DB                 jmp     short loc_74BB
.text$mn:000074DD ; ---------------------------------------------------------------------------
.text$mn:000074DD
.text$mn:000074DD loc_74DD:                               ; CODE XREF: std::_Temp_iterator<int>::~_Temp_iterator<int>(void)+2Dj
.text$mn:000074DD                 mov     ecx, [ebp+var_8]
.text$mn:000074E0                 mov     edx, [ecx]
.text$mn:000074E2                 push    edx             ; void *
.text$mn:000074E3                 call    ??$return_temporary_buffer@H@std@@YAXPAH@Z ; std::return_temporary_buffer<int>(int *)
.text$mn:000074E8                 add     esp, 4
.text$mn:000074EB
.text$mn:000074EB loc_74EB:                               ; CODE XREF: std::_Temp_iterator<int>::~_Temp_iterator<int>(void)+Fj
.text$mn:000074EB                 mov     esp, ebp
.text$mn:000074ED                 pop     ebp
.text$mn:000074EE                 retn
.text$mn:000074EE ??1?$_Temp_iterator@H@std@@QAE@XZ endp
.text$mn:000074EE
.text$mn:000074EE ; ---------------------------------------------------------------------------
.text$mn:000074EF                 align 10h
.text$mn:000074EF _text$mn        ends
.text$mn:000074EF
.text$mn:000074F0 ; ===========================================================================
.text$mn:000074F0
.text$mn:000074F0 ; Segment type: Pure code
.text$mn:000074F0 ; Segment permissions: Read/Execute
.text$mn:000074F0 _text$mn        segment para public 'CODE' use32
.text$mn:000074F0                 assume cs:_text$mn
.text$mn:000074F0                 ;org 74F0h
.text$mn:000074F0 ; COMDAT (pick any)
.text$mn:000074F0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000074F0
.text$mn:000074F0 ; =============== S U B R O U T I N E =======================================
.text$mn:000074F0
.text$mn:000074F0 ; Attributes: bp-based frame
.text$mn:000074F0
.text$mn:000074F0 ; public: __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<int, class std::allocator<int>>>::~_Vector_alloc<0, struct std::_Vec_base_types<int, class std::allocator<int>>>(void)
.text$mn:000074F0                 public ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@XZ
.text$mn:000074F0 ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@XZ proc near
.text$mn:000074F0                                         ; CODE XREF: __unwindfunclet$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ$0+3j
.text$mn:000074F0                                         ; std::vector<int,std::allocator<int>>::~vector<int,std::allocator<int>>(void)+3Fp ...
.text$mn:000074F0
.text$mn:000074F0 var_10          = dword ptr -10h
.text$mn:000074F0 var_C           = dword ptr -0Ch
.text$mn:000074F0 var_4           = dword ptr -4
.text$mn:000074F0
.text$mn:000074F0                 push    ebp
.text$mn:000074F1                 mov     ebp, esp
.text$mn:000074F3                 push    0FFFFFFFFh
.text$mn:000074F5                 push    offset __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@XZ
.text$mn:000074FA                 mov     eax, large fs:0
.text$mn:00007500                 push    eax
.text$mn:00007501                 push    ecx
.text$mn:00007502                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00007507                 xor     eax, ebp
.text$mn:00007509                 push    eax
.text$mn:0000750A                 lea     eax, [ebp+var_C]
.text$mn:0000750D                 mov     large fs:0, eax
.text$mn:00007513                 mov     [ebp+var_10], ecx
.text$mn:00007516                 mov     [ebp+var_4], 0
.text$mn:0000751D                 mov     ecx, [ebp+var_10]
.text$mn:00007520                 call    ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>::_Free_proxy(void)
.text$mn:00007525                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000752C                 mov     ecx, [ebp+var_10]
.text$mn:0000752F                 call    ??1?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<int>>::~_Vector_val<std::_Simple_types<int>>(void)
.text$mn:00007534                 mov     ecx, [ebp+var_C]
.text$mn:00007537                 mov     large fs:0, ecx
.text$mn:0000753E                 pop     ecx
.text$mn:0000753F                 mov     esp, ebp
.text$mn:00007541                 pop     ebp
.text$mn:00007542                 retn
.text$mn:00007542 ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@XZ endp
.text$mn:00007542
.text$mn:00007542 ; ---------------------------------------------------------------------------
.text$mn:00007543                 align 4
.text$mn:00007543 _text$mn        ends
.text$mn:00007543
.text$x:00007544 ; ===========================================================================
.text$x:00007544
.text$x:00007544 ; Segment type: Pure code
.text$x:00007544 ; Segment permissions: Read/Execute
.text$x:00007544 _text$x         segment para public 'CODE' use32
.text$x:00007544                 assume cs:_text$x
.text$x:00007544                 ;org 7544h
.text$x:00007544 ; COMDAT (pick associative to section at 74F0)
.text$x:00007544                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00007544
.text$x:00007544 ; =============== S U B R O U T I N E =======================================
.text$x:00007544
.text$x:00007544
.text$x:00007544 __unwindfunclet$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00007544                                         ; DATA XREF: .xdata$x:0000CDACo
.text$x:00007544                 mov     ecx, [ebp-10h]
.text$x:00007547                 jmp     ??1?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<int>>::~_Vector_val<std::_Simple_types<int>>(void)
.text$x:00007547 __unwindfunclet$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:00007547
.text$x:0000754C
.text$x:0000754C ; =============== S U B R O U T I N E =======================================
.text$x:0000754C
.text$x:0000754C
.text$x:0000754C __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@XZ proc near
.text$x:0000754C                                         ; DATA XREF: std::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>::~_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>(void)+5o
.text$x:0000754C
.text$x:0000754C arg_4           = dword ptr  8
.text$x:0000754C
.text$x:0000754C                 mov     edx, [esp+arg_4]
.text$x:00007550                 lea     eax, [edx+0Ch]
.text$x:00007553                 mov     ecx, [edx-8]
.text$x:00007556                 xor     ecx, eax
.text$x:00007558                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000755D                 mov     eax, offset __ehfuncinfo$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@XZ
.text$x:00007562                 jmp     ___CxxFrameHandler3
.text$x:00007562 __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@XZ endp
.text$x:00007562
.text$x:00007562 ; ---------------------------------------------------------------------------
.text$x:00007567                 align 4
.text$x:00007567 _text$x         ends
.text$x:00007567
.text$mn:00007568 ; ===========================================================================
.text$mn:00007568
.text$mn:00007568 ; Segment type: Pure code
.text$mn:00007568 ; Segment permissions: Read/Execute
.text$mn:00007568 _text$mn        segment para public 'CODE' use32
.text$mn:00007568                 assume cs:_text$mn
.text$mn:00007568                 ;org 7568h
.text$mn:00007568 ; COMDAT (pick any)
.text$mn:00007568                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007568
.text$mn:00007568 ; =============== S U B R O U T I N E =======================================
.text$mn:00007568
.text$mn:00007568 ; Attributes: bp-based frame
.text$mn:00007568
.text$mn:00007568 ; public: __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<wchar_t, class std::allocator<wchar_t>>>::~_Vector_alloc<0, struct std::_Vec_base_types<wchar_t, class std::allocator<wchar_t>>>(void)
.text$mn:00007568                 public ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
.text$mn:00007568 ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00007568                                         ; CODE XREF: __unwindfunclet$??$?0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@X@?$vector@_WV?$allocator@_W@std@@@std@@QAE@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$2+3j
.text$mn:00007568                                         ; std::vector<wchar_t,std::allocator<wchar_t>>::~vector<wchar_t,std::allocator<wchar_t>>(void)+3Fp ...
.text$mn:00007568
.text$mn:00007568 var_10          = dword ptr -10h
.text$mn:00007568 var_C           = dword ptr -0Ch
.text$mn:00007568 var_4           = dword ptr -4
.text$mn:00007568
.text$mn:00007568                 push    ebp
.text$mn:00007569                 mov     ebp, esp
.text$mn:0000756B                 push    0FFFFFFFFh
.text$mn:0000756D                 push    offset __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
.text$mn:00007572                 mov     eax, large fs:0
.text$mn:00007578                 push    eax
.text$mn:00007579                 push    ecx
.text$mn:0000757A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000757F                 xor     eax, ebp
.text$mn:00007581                 push    eax
.text$mn:00007582                 lea     eax, [ebp+var_C]
.text$mn:00007585                 mov     large fs:0, eax
.text$mn:0000758B                 mov     [ebp+var_10], ecx
.text$mn:0000758E                 mov     [ebp+var_4], 0
.text$mn:00007595                 mov     ecx, [ebp+var_10]
.text$mn:00007598                 call    ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<0,std::_Vec_base_types<wchar_t,std::allocator<wchar_t>>>::_Free_proxy(void)
.text$mn:0000759D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000075A4                 mov     ecx, [ebp+var_10]
.text$mn:000075A7                 call    ??1?$_Vector_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<wchar_t>>::~_Vector_val<std::_Simple_types<wchar_t>>(void)
.text$mn:000075AC                 mov     ecx, [ebp+var_C]
.text$mn:000075AF                 mov     large fs:0, ecx
.text$mn:000075B6                 pop     ecx
.text$mn:000075B7                 mov     esp, ebp
.text$mn:000075B9                 pop     ebp
.text$mn:000075BA                 retn
.text$mn:000075BA ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ endp
.text$mn:000075BA
.text$mn:000075BA ; ---------------------------------------------------------------------------
.text$mn:000075BB                 align 4
.text$mn:000075BB _text$mn        ends
.text$mn:000075BB
.text$x:000075BC ; ===========================================================================
.text$x:000075BC
.text$x:000075BC ; Segment type: Pure code
.text$x:000075BC ; Segment permissions: Read/Execute
.text$x:000075BC _text$x         segment para public 'CODE' use32
.text$x:000075BC                 assume cs:_text$x
.text$x:000075BC                 ;org 75BCh
.text$x:000075BC ; COMDAT (pick associative to section at 7568)
.text$x:000075BC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000075BC
.text$x:000075BC ; =============== S U B R O U T I N E =======================================
.text$x:000075BC
.text$x:000075BC
.text$x:000075BC __unwindfunclet$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:000075BC                                         ; DATA XREF: .xdata$x:0000D528o
.text$x:000075BC                 mov     ecx, [ebp-10h]
.text$x:000075BF                 jmp     ??1?$_Vector_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<wchar_t>>::~_Vector_val<std::_Simple_types<wchar_t>>(void)
.text$x:000075BF __unwindfunclet$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:000075BF
.text$x:000075C4
.text$x:000075C4 ; =============== S U B R O U T I N E =======================================
.text$x:000075C4
.text$x:000075C4
.text$x:000075C4 __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ proc near
.text$x:000075C4                                         ; DATA XREF: std::_Vector_alloc<0,std::_Vec_base_types<wchar_t,std::allocator<wchar_t>>>::~_Vector_alloc<0,std::_Vec_base_types<wchar_t,std::allocator<wchar_t>>>(void)+5o
.text$x:000075C4
.text$x:000075C4 arg_4           = dword ptr  8
.text$x:000075C4
.text$x:000075C4                 mov     edx, [esp+arg_4]
.text$x:000075C8                 lea     eax, [edx+0Ch]
.text$x:000075CB                 mov     ecx, [edx-8]
.text$x:000075CE                 xor     ecx, eax
.text$x:000075D0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000075D5                 mov     eax, offset __ehfuncinfo$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
.text$x:000075DA                 jmp     ___CxxFrameHandler3
.text$x:000075DA __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ endp
.text$x:000075DA
.text$x:000075DA ; ---------------------------------------------------------------------------
.text$x:000075DF                 align 10h
.text$x:000075DF _text$x         ends
.text$x:000075DF
.text$mn:000075E0 ; ===========================================================================
.text$mn:000075E0
.text$mn:000075E0 ; Segment type: Pure code
.text$mn:000075E0 ; Segment permissions: Read/Execute
.text$mn:000075E0 _text$mn        segment para public 'CODE' use32
.text$mn:000075E0                 assume cs:_text$mn
.text$mn:000075E0                 ;org 75E0h
.text$mn:000075E0 ; COMDAT (pick any)
.text$mn:000075E0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000075E0
.text$mn:000075E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000075E0
.text$mn:000075E0 ; Attributes: bp-based frame
.text$mn:000075E0
.text$mn:000075E0 ; public: __thiscall std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<int>>>::~_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<int>>>(void)
.text$mn:000075E0                 public ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
.text$mn:000075E0 ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ proc near
.text$mn:000075E0                                         ; CODE XREF: __unwindfunclet$?doClose@WindowsDlg@@IAEXXZ$5+6j
.text$mn:000075E0                                         ; __unwindfunclet$?doClose@WindowsDlg@@IAEXXZ$9+6j ...
.text$mn:000075E0
.text$mn:000075E0 var_10          = dword ptr -10h
.text$mn:000075E0 var_C           = dword ptr -0Ch
.text$mn:000075E0 var_4           = dword ptr -4
.text$mn:000075E0
.text$mn:000075E0                 push    ebp
.text$mn:000075E1                 mov     ebp, esp
.text$mn:000075E3                 push    0FFFFFFFFh
.text$mn:000075E5                 push    offset __ehhandler$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
.text$mn:000075EA                 mov     eax, large fs:0
.text$mn:000075F0                 push    eax
.text$mn:000075F1                 push    ecx
.text$mn:000075F2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000075F7                 xor     eax, ebp
.text$mn:000075F9                 push    eax
.text$mn:000075FA                 lea     eax, [ebp+var_C]
.text$mn:000075FD                 mov     large fs:0, eax
.text$mn:00007603                 mov     [ebp+var_10], ecx
.text$mn:00007606                 mov     [ebp+var_4], 0
.text$mn:0000760D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00007614                 mov     ecx, [ebp+var_10]
.text$mn:00007617                 call    ??1?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>(void)
.text$mn:0000761C                 mov     ecx, [ebp+var_C]
.text$mn:0000761F                 mov     large fs:0, ecx
.text$mn:00007626                 pop     ecx
.text$mn:00007627                 mov     esp, ebp
.text$mn:00007629                 pop     ebp
.text$mn:0000762A                 retn
.text$mn:0000762A ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ endp
.text$mn:0000762A
.text$mn:0000762A ; ---------------------------------------------------------------------------
.text$mn:0000762B                 align 4
.text$mn:0000762B _text$mn        ends
.text$mn:0000762B
.text$x:0000762C ; ===========================================================================
.text$x:0000762C
.text$x:0000762C ; Segment type: Pure code
.text$x:0000762C ; Segment permissions: Read/Execute
.text$x:0000762C _text$x         segment para public 'CODE' use32
.text$x:0000762C                 assume cs:_text$x
.text$x:0000762C                 ;org 762Ch
.text$x:0000762C ; COMDAT (pick associative to section at 75E0)
.text$x:0000762C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000762C
.text$x:0000762C ; =============== S U B R O U T I N E =======================================
.text$x:0000762C
.text$x:0000762C
.text$x:0000762C __unwindfunclet$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:0000762C                                         ; DATA XREF: .xdata$x:0000D148o
.text$x:0000762C                 mov     ecx, [ebp-10h]
.text$x:0000762F                 jmp     ??1?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>(void)
.text$x:0000762F __unwindfunclet$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:0000762F
.text$x:00007634
.text$x:00007634 ; =============== S U B R O U T I N E =======================================
.text$x:00007634
.text$x:00007634
.text$x:00007634 __ehhandler$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ proc near
.text$x:00007634                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)+5o
.text$x:00007634
.text$x:00007634 arg_4           = dword ptr  8
.text$x:00007634
.text$x:00007634                 mov     edx, [esp+arg_4]
.text$x:00007638                 lea     eax, [edx+0Ch]
.text$x:0000763B                 mov     ecx, [edx-8]
.text$x:0000763E                 xor     ecx, eax
.text$x:00007640                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00007645                 mov     eax, offset __ehfuncinfo$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
.text$x:0000764A                 jmp     ___CxxFrameHandler3
.text$x:0000764A __ehhandler$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ endp
.text$x:0000764A
.text$x:0000764A ; ---------------------------------------------------------------------------
.text$x:0000764F                 align 10h
.text$x:0000764F _text$x         ends
.text$x:0000764F
.text$mn:00007650 ; ===========================================================================
.text$mn:00007650
.text$mn:00007650 ; Segment type: Pure code
.text$mn:00007650 ; Segment permissions: Read/Execute
.text$mn:00007650 _text$mn        segment para public 'CODE' use32
.text$mn:00007650                 assume cs:_text$mn
.text$mn:00007650                 ;org 7650h
.text$mn:00007650 ; COMDAT (pick any)
.text$mn:00007650                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007650
.text$mn:00007650 ; =============== S U B R O U T I N E =======================================
.text$mn:00007650
.text$mn:00007650 ; Attributes: bp-based frame
.text$mn:00007650
.text$mn:00007650 ; public: __thiscall std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<int>>>::~_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<int>>>(void)
.text$mn:00007650                 public ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
.text$mn:00007650 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00007650                                         ; CODE XREF: WindowsDlg::resetSelection(void)+105p
.text$mn:00007650                                         ; WindowsDlg::resetSelection(void)+114p ...
.text$mn:00007650
.text$mn:00007650 var_10          = dword ptr -10h
.text$mn:00007650 var_C           = dword ptr -0Ch
.text$mn:00007650 var_4           = dword ptr -4
.text$mn:00007650
.text$mn:00007650                 push    ebp
.text$mn:00007651                 mov     ebp, esp
.text$mn:00007653                 push    0FFFFFFFFh
.text$mn:00007655                 push    offset __ehhandler$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
.text$mn:0000765A                 mov     eax, large fs:0
.text$mn:00007660                 push    eax
.text$mn:00007661                 push    ecx
.text$mn:00007662                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00007667                 xor     eax, ebp
.text$mn:00007669                 push    eax
.text$mn:0000766A                 lea     eax, [ebp+var_C]
.text$mn:0000766D                 mov     large fs:0, eax
.text$mn:00007673                 mov     [ebp+var_10], ecx
.text$mn:00007676                 mov     [ebp+var_4], 0
.text$mn:0000767D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00007684                 mov     ecx, [ebp+var_10]
.text$mn:00007687                 call    ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$mn:0000768C                 mov     ecx, [ebp+var_C]
.text$mn:0000768F                 mov     large fs:0, ecx
.text$mn:00007696                 pop     ecx
.text$mn:00007697                 mov     esp, ebp
.text$mn:00007699                 pop     ebp
.text$mn:0000769A                 retn
.text$mn:0000769A ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ endp
.text$mn:0000769A
.text$mn:0000769A ; ---------------------------------------------------------------------------
.text$mn:0000769B                 align 4
.text$mn:0000769B _text$mn        ends
.text$mn:0000769B
.text$x:0000769C ; ===========================================================================
.text$x:0000769C
.text$x:0000769C ; Segment type: Pure code
.text$x:0000769C ; Segment permissions: Read/Execute
.text$x:0000769C _text$x         segment para public 'CODE' use32
.text$x:0000769C                 assume cs:_text$x
.text$x:0000769C                 ;org 769Ch
.text$x:0000769C ; COMDAT (pick associative to section at 7650)
.text$x:0000769C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000769C
.text$x:0000769C ; =============== S U B R O U T I N E =======================================
.text$x:0000769C
.text$x:0000769C
.text$x:0000769C __unwindfunclet$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:0000769C                                         ; DATA XREF: .xdata$x:0000D1CCo
.text$x:0000769C                 mov     ecx, [ebp-10h]
.text$x:0000769F                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$x:0000769F __unwindfunclet$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:0000769F
.text$x:000076A4
.text$x:000076A4 ; =============== S U B R O U T I N E =======================================
.text$x:000076A4
.text$x:000076A4
.text$x:000076A4 __ehhandler$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ proc near
.text$x:000076A4                                         ; DATA XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)+5o
.text$x:000076A4
.text$x:000076A4 arg_4           = dword ptr  8
.text$x:000076A4
.text$x:000076A4                 mov     edx, [esp+arg_4]
.text$x:000076A8                 lea     eax, [edx+0Ch]
.text$x:000076AB                 mov     ecx, [edx-8]
.text$x:000076AE                 xor     ecx, eax
.text$x:000076B0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000076B5                 mov     eax, offset __ehfuncinfo$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
.text$x:000076BA                 jmp     ___CxxFrameHandler3
.text$x:000076BA __ehhandler$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ endp
.text$x:000076BA
.text$x:000076BA ; ---------------------------------------------------------------------------
.text$x:000076BF                 align 10h
.text$x:000076BF _text$x         ends
.text$x:000076BF
.text$mn:000076C0 ; ===========================================================================
.text$mn:000076C0
.text$mn:000076C0 ; Segment type: Pure code
.text$mn:000076C0 ; Segment permissions: Read/Execute
.text$mn:000076C0 _text$mn        segment para public 'CODE' use32
.text$mn:000076C0                 assume cs:_text$mn
.text$mn:000076C0                 ;org 76C0h
.text$mn:000076C0 ; COMDAT (pick any)
.text$mn:000076C0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000076C0
.text$mn:000076C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000076C0
.text$mn:000076C0 ; Attributes: bp-based frame
.text$mn:000076C0
.text$mn:000076C0 ; public: __thiscall std::_Vector_val<struct std::_Simple_types<int>>::~_Vector_val<struct std::_Simple_types<int>>(void)
.text$mn:000076C0                 public ??1?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ
.text$mn:000076C0 ??1?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ proc near
.text$mn:000076C0                                         ; CODE XREF: __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@ABV?$allocator@H@1@@Z$0+3j
.text$mn:000076C0                                         ; std::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>::~_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>(void)+3Fp ...
.text$mn:000076C0
.text$mn:000076C0 var_10          = dword ptr -10h
.text$mn:000076C0 var_C           = dword ptr -0Ch
.text$mn:000076C0 var_4           = dword ptr -4
.text$mn:000076C0
.text$mn:000076C0                 push    ebp
.text$mn:000076C1                 mov     ebp, esp
.text$mn:000076C3                 push    0FFFFFFFFh
.text$mn:000076C5                 push    offset __ehhandler$??1?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ
.text$mn:000076CA                 mov     eax, large fs:0
.text$mn:000076D0                 push    eax
.text$mn:000076D1                 push    ecx
.text$mn:000076D2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000076D7                 xor     eax, ebp
.text$mn:000076D9                 push    eax
.text$mn:000076DA                 lea     eax, [ebp+var_C]
.text$mn:000076DD                 mov     large fs:0, eax
.text$mn:000076E3                 mov     [ebp+var_10], ecx
.text$mn:000076E6                 mov     [ebp+var_4], 0
.text$mn:000076ED                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000076F4                 mov     ecx, [ebp+var_10] ; this
.text$mn:000076F7                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:000076FC                 mov     ecx, [ebp+var_C]
.text$mn:000076FF                 mov     large fs:0, ecx
.text$mn:00007706                 pop     ecx
.text$mn:00007707                 mov     esp, ebp
.text$mn:00007709                 pop     ebp
.text$mn:0000770A                 retn
.text$mn:0000770A ??1?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ endp
.text$mn:0000770A
.text$mn:0000770A ; ---------------------------------------------------------------------------
.text$mn:0000770B                 align 4
.text$mn:0000770B _text$mn        ends
.text$mn:0000770B
.text$x:0000770C ; ===========================================================================
.text$x:0000770C
.text$x:0000770C ; Segment type: Pure code
.text$x:0000770C ; Segment permissions: Read/Execute
.text$x:0000770C _text$x         segment para public 'CODE' use32
.text$x:0000770C                 assume cs:_text$x
.text$x:0000770C                 ;org 770Ch
.text$x:0000770C ; COMDAT (pick associative to section at 76C0)
.text$x:0000770C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000770C
.text$x:0000770C ; =============== S U B R O U T I N E =======================================
.text$x:0000770C
.text$x:0000770C
.text$x:0000770C __unwindfunclet$??1?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ$0 proc near
.text$x:0000770C                                         ; DATA XREF: .xdata$x:0000CD54o
.text$x:0000770C                 mov     ecx, [ebp-10h]  ; this
.text$x:0000770F                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:0000770F __unwindfunclet$??1?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ$0 endp
.text$x:0000770F
.text$x:00007714
.text$x:00007714 ; =============== S U B R O U T I N E =======================================
.text$x:00007714
.text$x:00007714
.text$x:00007714 __ehhandler$??1?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ proc near
.text$x:00007714                                         ; DATA XREF: std::_Vector_val<std::_Simple_types<int>>::~_Vector_val<std::_Simple_types<int>>(void)+5o
.text$x:00007714
.text$x:00007714 arg_4           = dword ptr  8
.text$x:00007714
.text$x:00007714                 mov     edx, [esp+arg_4]
.text$x:00007718                 lea     eax, [edx+0Ch]
.text$x:0000771B                 mov     ecx, [edx-8]
.text$x:0000771E                 xor     ecx, eax
.text$x:00007720                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00007725                 mov     eax, offset __ehfuncinfo$??1?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ
.text$x:0000772A                 jmp     ___CxxFrameHandler3
.text$x:0000772A __ehhandler$??1?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ endp
.text$x:0000772A
.text$x:0000772A ; ---------------------------------------------------------------------------
.text$x:0000772F                 align 10h
.text$x:0000772F _text$x         ends
.text$x:0000772F
.text$mn:00007730 ; ===========================================================================
.text$mn:00007730
.text$mn:00007730 ; Segment type: Pure code
.text$mn:00007730 ; Segment permissions: Read/Execute
.text$mn:00007730 _text$mn        segment para public 'CODE' use32
.text$mn:00007730                 assume cs:_text$mn
.text$mn:00007730                 ;org 7730h
.text$mn:00007730 ; COMDAT (pick any)
.text$mn:00007730                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007730
.text$mn:00007730 ; =============== S U B R O U T I N E =======================================
.text$mn:00007730
.text$mn:00007730 ; Attributes: bp-based frame
.text$mn:00007730
.text$mn:00007730 ; public: __thiscall std::_Vector_val<struct std::_Simple_types<wchar_t>>::~_Vector_val<struct std::_Simple_types<wchar_t>>(void)
.text$mn:00007730                 public ??1?$_Vector_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$mn:00007730 ??1?$_Vector_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ proc near
.text$mn:00007730                                         ; CODE XREF: __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z$0+3j
.text$mn:00007730                                         ; std::_Vector_alloc<0,std::_Vec_base_types<wchar_t,std::allocator<wchar_t>>>::~_Vector_alloc<0,std::_Vec_base_types<wchar_t,std::allocator<wchar_t>>>(void)+3Fp ...
.text$mn:00007730
.text$mn:00007730 var_10          = dword ptr -10h
.text$mn:00007730 var_C           = dword ptr -0Ch
.text$mn:00007730 var_4           = dword ptr -4
.text$mn:00007730
.text$mn:00007730                 push    ebp
.text$mn:00007731                 mov     ebp, esp
.text$mn:00007733                 push    0FFFFFFFFh
.text$mn:00007735                 push    offset __ehhandler$??1?$_Vector_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$mn:0000773A                 mov     eax, large fs:0
.text$mn:00007740                 push    eax
.text$mn:00007741                 push    ecx
.text$mn:00007742                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00007747                 xor     eax, ebp
.text$mn:00007749                 push    eax
.text$mn:0000774A                 lea     eax, [ebp+var_C]
.text$mn:0000774D                 mov     large fs:0, eax
.text$mn:00007753                 mov     [ebp+var_10], ecx
.text$mn:00007756                 mov     [ebp+var_4], 0
.text$mn:0000775D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00007764                 mov     ecx, [ebp+var_10] ; this
.text$mn:00007767                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:0000776C                 mov     ecx, [ebp+var_C]
.text$mn:0000776F                 mov     large fs:0, ecx
.text$mn:00007776                 pop     ecx
.text$mn:00007777                 mov     esp, ebp
.text$mn:00007779                 pop     ebp
.text$mn:0000777A                 retn
.text$mn:0000777A ??1?$_Vector_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ endp
.text$mn:0000777A
.text$mn:0000777A ; ---------------------------------------------------------------------------
.text$mn:0000777B                 align 4
.text$mn:0000777B _text$mn        ends
.text$mn:0000777B
.text$x:0000777C ; ===========================================================================
.text$x:0000777C
.text$x:0000777C ; Segment type: Pure code
.text$x:0000777C ; Segment permissions: Read/Execute
.text$x:0000777C _text$x         segment para public 'CODE' use32
.text$x:0000777C                 assume cs:_text$x
.text$x:0000777C                 ;org 777Ch
.text$x:0000777C ; COMDAT (pick associative to section at 7730)
.text$x:0000777C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000777C
.text$x:0000777C ; =============== S U B R O U T I N E =======================================
.text$x:0000777C
.text$x:0000777C
.text$x:0000777C __unwindfunclet$??1?$_Vector_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0 proc near
.text$x:0000777C                                         ; DATA XREF: .xdata$x:0000D4D0o
.text$x:0000777C                 mov     ecx, [ebp-10h]  ; this
.text$x:0000777F                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:0000777F __unwindfunclet$??1?$_Vector_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0 endp
.text$x:0000777F
.text$x:00007784
.text$x:00007784 ; =============== S U B R O U T I N E =======================================
.text$x:00007784
.text$x:00007784
.text$x:00007784 __ehhandler$??1?$_Vector_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ proc near
.text$x:00007784                                         ; DATA XREF: std::_Vector_val<std::_Simple_types<wchar_t>>::~_Vector_val<std::_Simple_types<wchar_t>>(void)+5o
.text$x:00007784
.text$x:00007784 arg_4           = dword ptr  8
.text$x:00007784
.text$x:00007784                 mov     edx, [esp+arg_4]
.text$x:00007788                 lea     eax, [edx+0Ch]
.text$x:0000778B                 mov     ecx, [edx-8]
.text$x:0000778E                 xor     ecx, eax
.text$x:00007790                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00007795                 mov     eax, offset __ehfuncinfo$??1?$_Vector_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$x:0000779A                 jmp     ___CxxFrameHandler3
.text$x:0000779A __ehhandler$??1?$_Vector_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ endp
.text$x:0000779A
.text$x:0000779A ; ---------------------------------------------------------------------------
.text$x:0000779F                 align 10h
.text$x:0000779F _text$x         ends
.text$x:0000779F
.text$mn:000077A0 ; ===========================================================================
.text$mn:000077A0
.text$mn:000077A0 ; Segment type: Pure code
.text$mn:000077A0 ; Segment permissions: Read/Execute
.text$mn:000077A0 _text$mn        segment para public 'CODE' use32
.text$mn:000077A0                 assume cs:_text$mn
.text$mn:000077A0                 ;org 77A0h
.text$mn:000077A0 ; COMDAT (pick any)
.text$mn:000077A0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000077A0
.text$mn:000077A0 ; =============== S U B R O U T I N E =======================================
.text$mn:000077A0
.text$mn:000077A0 ; Attributes: bp-based frame
.text$mn:000077A0
.text$mn:000077A0 ; public: __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::~basic_string<char, struct std::char_traits<char>, class std::allocator<char>>(void)
.text$mn:000077A0                 public ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:000077A0 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$mn:000077A0                                         ; CODE XREF: __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+13j
.text$mn:000077A0                                         ; __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+13j ...
.text$mn:000077A0
.text$mn:000077A0 var_10          = dword ptr -10h
.text$mn:000077A0 var_C           = dword ptr -0Ch
.text$mn:000077A0 var_4           = dword ptr -4
.text$mn:000077A0
.text$mn:000077A0                 push    ebp
.text$mn:000077A1                 mov     ebp, esp
.text$mn:000077A3                 push    0FFFFFFFFh
.text$mn:000077A5                 push    offset __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:000077AA                 mov     eax, large fs:0
.text$mn:000077B0                 push    eax
.text$mn:000077B1                 push    ecx
.text$mn:000077B2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000077B7                 xor     eax, ebp
.text$mn:000077B9                 push    eax
.text$mn:000077BA                 lea     eax, [ebp+var_C]
.text$mn:000077BD                 mov     large fs:0, eax
.text$mn:000077C3                 mov     [ebp+var_10], ecx
.text$mn:000077C6                 mov     [ebp+var_4], 0
.text$mn:000077CD                 push    0               ; Size
.text$mn:000077CF                 push    1               ; char
.text$mn:000077D1                 mov     ecx, [ebp+var_10]
.text$mn:000077D4                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:000077D9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000077E0                 mov     ecx, [ebp+var_10]
.text$mn:000077E3                 call    ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$mn:000077E8                 mov     ecx, [ebp+var_C]
.text$mn:000077EB                 mov     large fs:0, ecx
.text$mn:000077F2                 pop     ecx
.text$mn:000077F3                 mov     esp, ebp
.text$mn:000077F5                 pop     ebp
.text$mn:000077F6                 retn
.text$mn:000077F6 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$mn:000077F6
.text$mn:000077F6 ; ---------------------------------------------------------------------------
.text$mn:000077F7                 align 4
.text$mn:000077F7 _text$mn        ends
.text$mn:000077F7
.text$x:000077F8 ; ===========================================================================
.text$x:000077F8
.text$x:000077F8 ; Segment type: Pure code
.text$x:000077F8 ; Segment permissions: Read/Execute
.text$x:000077F8 _text$x         segment para public 'CODE' use32
.text$x:000077F8                 assume cs:_text$x
.text$x:000077F8                 ;org 77F8h
.text$x:000077F8 ; COMDAT (pick associative to section at 77A0)
.text$x:000077F8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000077F8
.text$x:000077F8 ; =============== S U B R O U T I N E =======================================
.text$x:000077F8
.text$x:000077F8
.text$x:000077F8 __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 proc near
.text$x:000077F8                                         ; DATA XREF: .xdata$x:0000C72Co
.text$x:000077F8                 mov     ecx, [ebp-10h]
.text$x:000077FB                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:000077FB __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 endp
.text$x:000077FB
.text$x:00007800
.text$x:00007800 ; =============== S U B R O U T I N E =======================================
.text$x:00007800
.text$x:00007800
.text$x:00007800 __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$x:00007800                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+5o
.text$x:00007800
.text$x:00007800 arg_4           = dword ptr  8
.text$x:00007800
.text$x:00007800                 mov     edx, [esp+arg_4]
.text$x:00007804                 lea     eax, [edx+0Ch]
.text$x:00007807                 mov     ecx, [edx-8]
.text$x:0000780A                 xor     ecx, eax
.text$x:0000780C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00007811                 mov     eax, offset __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$x:00007816                 jmp     ___CxxFrameHandler3
.text$x:00007816 __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$x:00007816
.text$x:00007816 ; ---------------------------------------------------------------------------
.text$x:0000781B                 align 4
.text$x:0000781B _text$x         ends
.text$x:0000781B
.text$mn:0000781C ; ===========================================================================
.text$mn:0000781C
.text$mn:0000781C ; Segment type: Pure code
.text$mn:0000781C ; Segment permissions: Read/Execute
.text$mn:0000781C _text$mn        segment para public 'CODE' use32
.text$mn:0000781C                 assume cs:_text$mn
.text$mn:0000781C                 ;org 781Ch
.text$mn:0000781C ; COMDAT (pick any)
.text$mn:0000781C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000781C
.text$mn:0000781C ; =============== S U B R O U T I N E =======================================
.text$mn:0000781C
.text$mn:0000781C ; Attributes: bp-based frame
.text$mn:0000781C
.text$mn:0000781C ; public: __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::~basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>(void)
.text$mn:0000781C                 public ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.text$mn:0000781C ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ proc near
.text$mn:0000781C                                         ; CODE XREF: WindowsMenu::init(HINSTANCE__ *,HMENU__ *,wchar_t const *)+A6p
.text$mn:0000781C                                         ; WindowsMenu::initPopupMenu(HMENU__ *,DocTabView *)+127p ...
.text$mn:0000781C
.text$mn:0000781C var_10          = dword ptr -10h
.text$mn:0000781C var_C           = dword ptr -0Ch
.text$mn:0000781C var_4           = dword ptr -4
.text$mn:0000781C
.text$mn:0000781C                 push    ebp
.text$mn:0000781D                 mov     ebp, esp
.text$mn:0000781F                 push    0FFFFFFFFh
.text$mn:00007821                 push    offset __ehhandler$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.text$mn:00007826                 mov     eax, large fs:0
.text$mn:0000782C                 push    eax
.text$mn:0000782D                 push    ecx
.text$mn:0000782E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00007833                 xor     eax, ebp
.text$mn:00007835                 push    eax
.text$mn:00007836                 lea     eax, [ebp+var_C]
.text$mn:00007839                 mov     large fs:0, eax
.text$mn:0000783F                 mov     [ebp+var_10], ecx
.text$mn:00007842                 mov     [ebp+var_4], 0
.text$mn:00007849                 push    0
.text$mn:0000784B                 push    1
.text$mn:0000784D                 mov     ecx, [ebp+var_10]
.text$mn:00007850                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:00007855                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000785C                 mov     ecx, [ebp+var_10]
.text$mn:0000785F                 call    ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)
.text$mn:00007864                 mov     ecx, [ebp+var_C]
.text$mn:00007867                 mov     large fs:0, ecx
.text$mn:0000786E                 pop     ecx
.text$mn:0000786F                 mov     esp, ebp
.text$mn:00007871                 pop     ebp
.text$mn:00007872                 retn
.text$mn:00007872 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ endp
.text$mn:00007872
.text$mn:00007872 ; ---------------------------------------------------------------------------
.text$mn:00007873                 align 4
.text$mn:00007873 _text$mn        ends
.text$mn:00007873
.text$x:00007874 ; ===========================================================================
.text$x:00007874
.text$x:00007874 ; Segment type: Pure code
.text$x:00007874 ; Segment permissions: Read/Execute
.text$x:00007874 _text$x         segment para public 'CODE' use32
.text$x:00007874                 assume cs:_text$x
.text$x:00007874                 ;org 7874h
.text$x:00007874 ; COMDAT (pick associative to section at 781C)
.text$x:00007874                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00007874
.text$x:00007874 ; =============== S U B R O U T I N E =======================================
.text$x:00007874
.text$x:00007874
.text$x:00007874 __unwindfunclet$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ$0 proc near
.text$x:00007874                                         ; DATA XREF: .xdata$x:0000CA4Co
.text$x:00007874                 mov     ecx, [ebp-10h]
.text$x:00007877                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)
.text$x:00007877 __unwindfunclet$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ$0 endp
.text$x:00007877
.text$x:0000787C
.text$x:0000787C ; =============== S U B R O U T I N E =======================================
.text$x:0000787C
.text$x:0000787C
.text$x:0000787C __ehhandler$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ proc near
.text$x:0000787C                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)+5o
.text$x:0000787C
.text$x:0000787C arg_4           = dword ptr  8
.text$x:0000787C
.text$x:0000787C                 mov     edx, [esp+arg_4]
.text$x:00007880                 lea     eax, [edx+0Ch]
.text$x:00007883                 mov     ecx, [edx-8]
.text$x:00007886                 xor     ecx, eax
.text$x:00007888                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000788D                 mov     eax, offset __ehfuncinfo$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.text$x:00007892                 jmp     ___CxxFrameHandler3
.text$x:00007892 __ehhandler$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ endp
.text$x:00007892
.text$x:00007892 ; ---------------------------------------------------------------------------
.text$x:00007897                 align 4
.text$x:00007897 _text$x         ends
.text$x:00007897
.text$mn:00007898 ; ===========================================================================
.text$mn:00007898
.text$mn:00007898 ; Segment type: Pure code
.text$mn:00007898 ; Segment permissions: Read/Execute
.text$mn:00007898 _text$mn        segment para public 'CODE' use32
.text$mn:00007898                 assume cs:_text$mn
.text$mn:00007898                 ;org 7898h
.text$mn:00007898 ; COMDAT (pick any)
.text$mn:00007898                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007898
.text$mn:00007898 ; =============== S U B R O U T I N E =======================================
.text$mn:00007898
.text$mn:00007898 ; Attributes: bp-based frame
.text$mn:00007898
.text$mn:00007898 ; public: __thiscall std::vector<int, class std::allocator<int>>::~vector<int, class std::allocator<int>>(void)
.text$mn:00007898                 public ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
.text$mn:00007898 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ proc near
.text$mn:00007898                                         ; CODE XREF: WindowsDlg::run_dlgProc(uint,uint,long)+5EAp
.text$mn:00007898                                         ; WindowsDlg::doClose(void)+50Dp ...
.text$mn:00007898
.text$mn:00007898 var_10          = dword ptr -10h
.text$mn:00007898 var_C           = dword ptr -0Ch
.text$mn:00007898 var_4           = dword ptr -4
.text$mn:00007898
.text$mn:00007898                 push    ebp
.text$mn:00007899                 mov     ebp, esp
.text$mn:0000789B                 push    0FFFFFFFFh
.text$mn:0000789D                 push    offset __ehhandler$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
.text$mn:000078A2                 mov     eax, large fs:0
.text$mn:000078A8                 push    eax
.text$mn:000078A9                 push    ecx
.text$mn:000078AA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000078AF                 xor     eax, ebp
.text$mn:000078B1                 push    eax
.text$mn:000078B2                 lea     eax, [ebp+var_C]
.text$mn:000078B5                 mov     large fs:0, eax
.text$mn:000078BB                 mov     [ebp+var_10], ecx
.text$mn:000078BE                 mov     [ebp+var_4], 0
.text$mn:000078C5                 mov     ecx, [ebp+var_10]
.text$mn:000078C8                 call    ?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ; std::vector<int,std::allocator<int>>::_Tidy(void)
.text$mn:000078CD                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000078D4                 mov     ecx, [ebp+var_10]
.text$mn:000078D7                 call    ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>::~_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>(void)
.text$mn:000078DC                 mov     ecx, [ebp+var_C]
.text$mn:000078DF                 mov     large fs:0, ecx
.text$mn:000078E6                 pop     ecx
.text$mn:000078E7                 mov     esp, ebp
.text$mn:000078E9                 pop     ebp
.text$mn:000078EA                 retn
.text$mn:000078EA ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ endp
.text$mn:000078EA
.text$mn:000078EA ; ---------------------------------------------------------------------------
.text$mn:000078EB                 align 4
.text$mn:000078EB _text$mn        ends
.text$mn:000078EB
.text$x:000078EC ; ===========================================================================
.text$x:000078EC
.text$x:000078EC ; Segment type: Pure code
.text$x:000078EC ; Segment permissions: Read/Execute
.text$x:000078EC _text$x         segment para public 'CODE' use32
.text$x:000078EC                 assume cs:_text$x
.text$x:000078EC                 ;org 78ECh
.text$x:000078EC ; COMDAT (pick associative to section at 7898)
.text$x:000078EC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000078EC
.text$x:000078EC ; =============== S U B R O U T I N E =======================================
.text$x:000078EC
.text$x:000078EC
.text$x:000078EC __unwindfunclet$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ$0 proc near
.text$x:000078EC                                         ; DATA XREF: .xdata$x:0000CE04o
.text$x:000078EC                 mov     ecx, [ebp-10h]
.text$x:000078EF                 jmp     ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>::~_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>(void)
.text$x:000078EF __unwindfunclet$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ$0 endp
.text$x:000078EF
.text$x:000078F4
.text$x:000078F4 ; =============== S U B R O U T I N E =======================================
.text$x:000078F4
.text$x:000078F4
.text$x:000078F4 __ehhandler$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ proc near
.text$x:000078F4                                         ; DATA XREF: std::vector<int,std::allocator<int>>::~vector<int,std::allocator<int>>(void)+5o
.text$x:000078F4
.text$x:000078F4 arg_4           = dword ptr  8
.text$x:000078F4
.text$x:000078F4                 mov     edx, [esp+arg_4]
.text$x:000078F8                 lea     eax, [edx+0Ch]
.text$x:000078FB                 mov     ecx, [edx-8]
.text$x:000078FE                 xor     ecx, eax
.text$x:00007900                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00007905                 mov     eax, offset __ehfuncinfo$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
.text$x:0000790A                 jmp     ___CxxFrameHandler3
.text$x:0000790A __ehhandler$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ endp
.text$x:0000790A
.text$x:0000790A ; ---------------------------------------------------------------------------
.text$x:0000790F                 align 10h
.text$x:0000790F _text$x         ends
.text$x:0000790F
.text$mn:00007910 ; ===========================================================================
.text$mn:00007910
.text$mn:00007910 ; Segment type: Pure code
.text$mn:00007910 ; Segment permissions: Read/Execute
.text$mn:00007910 _text$mn        segment para public 'CODE' use32
.text$mn:00007910                 assume cs:_text$mn
.text$mn:00007910                 ;org 7910h
.text$mn:00007910 ; COMDAT (pick any)
.text$mn:00007910                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007910
.text$mn:00007910 ; =============== S U B R O U T I N E =======================================
.text$mn:00007910
.text$mn:00007910 ; Attributes: bp-based frame
.text$mn:00007910
.text$mn:00007910 ; public: __thiscall std::vector<wchar_t, class std::allocator<wchar_t>>::~vector<wchar_t, class std::allocator<wchar_t>>(void)
.text$mn:00007910                 public ??1?$vector@_WV?$allocator@_W@std@@@std@@QAE@XZ
.text$mn:00007910 ??1?$vector@_WV?$allocator@_W@std@@@std@@QAE@XZ proc near
.text$mn:00007910                                         ; CODE XREF: WindowsMenu::initPopupMenu(HMENU__ *,DocTabView *)+235p
.text$mn:00007910                                         ; __unwindfunclet$?initPopupMenu@WindowsMenu@@QAEXPAUHMENU__@@PAVDocTabView@@@Z$4+6j
.text$mn:00007910
.text$mn:00007910 var_10          = dword ptr -10h
.text$mn:00007910 var_C           = dword ptr -0Ch
.text$mn:00007910 var_4           = dword ptr -4
.text$mn:00007910
.text$mn:00007910                 push    ebp
.text$mn:00007911                 mov     ebp, esp
.text$mn:00007913                 push    0FFFFFFFFh
.text$mn:00007915                 push    offset __ehhandler$??1?$vector@_WV?$allocator@_W@std@@@std@@QAE@XZ
.text$mn:0000791A                 mov     eax, large fs:0
.text$mn:00007920                 push    eax
.text$mn:00007921                 push    ecx
.text$mn:00007922                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00007927                 xor     eax, ebp
.text$mn:00007929                 push    eax
.text$mn:0000792A                 lea     eax, [ebp+var_C]
.text$mn:0000792D                 mov     large fs:0, eax
.text$mn:00007933                 mov     [ebp+var_10], ecx
.text$mn:00007936                 mov     [ebp+var_4], 0
.text$mn:0000793D                 mov     ecx, [ebp+var_10]
.text$mn:00007940                 call    ?_Tidy@?$vector@_WV?$allocator@_W@std@@@std@@IAEXXZ ; std::vector<wchar_t,std::allocator<wchar_t>>::_Tidy(void)
.text$mn:00007945                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000794C                 mov     ecx, [ebp+var_10]
.text$mn:0000794F                 call    ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<wchar_t,std::allocator<wchar_t>>>::~_Vector_alloc<0,std::_Vec_base_types<wchar_t,std::allocator<wchar_t>>>(void)
.text$mn:00007954                 mov     ecx, [ebp+var_C]
.text$mn:00007957                 mov     large fs:0, ecx
.text$mn:0000795E                 pop     ecx
.text$mn:0000795F                 mov     esp, ebp
.text$mn:00007961                 pop     ebp
.text$mn:00007962                 retn
.text$mn:00007962 ??1?$vector@_WV?$allocator@_W@std@@@std@@QAE@XZ endp
.text$mn:00007962
.text$mn:00007962 ; ---------------------------------------------------------------------------
.text$mn:00007963                 align 4
.text$mn:00007963 _text$mn        ends
.text$mn:00007963
.text$x:00007964 ; ===========================================================================
.text$x:00007964
.text$x:00007964 ; Segment type: Pure code
.text$x:00007964 ; Segment permissions: Read/Execute
.text$x:00007964 _text$x         segment para public 'CODE' use32
.text$x:00007964                 assume cs:_text$x
.text$x:00007964                 ;org 7964h
.text$x:00007964 ; COMDAT (pick associative to section at 7910)
.text$x:00007964                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00007964
.text$x:00007964 ; =============== S U B R O U T I N E =======================================
.text$x:00007964
.text$x:00007964
.text$x:00007964 __unwindfunclet$??1?$vector@_WV?$allocator@_W@std@@@std@@QAE@XZ$0 proc near
.text$x:00007964                                         ; DATA XREF: .xdata$x:0000D554o
.text$x:00007964                 mov     ecx, [ebp-10h]
.text$x:00007967                 jmp     ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<wchar_t,std::allocator<wchar_t>>>::~_Vector_alloc<0,std::_Vec_base_types<wchar_t,std::allocator<wchar_t>>>(void)
.text$x:00007967 __unwindfunclet$??1?$vector@_WV?$allocator@_W@std@@@std@@QAE@XZ$0 endp
.text$x:00007967
.text$x:0000796C
.text$x:0000796C ; =============== S U B R O U T I N E =======================================
.text$x:0000796C
.text$x:0000796C
.text$x:0000796C __ehhandler$??1?$vector@_WV?$allocator@_W@std@@@std@@QAE@XZ proc near
.text$x:0000796C                                         ; DATA XREF: std::vector<wchar_t,std::allocator<wchar_t>>::~vector<wchar_t,std::allocator<wchar_t>>(void)+5o
.text$x:0000796C
.text$x:0000796C arg_4           = dword ptr  8
.text$x:0000796C
.text$x:0000796C                 mov     edx, [esp+arg_4]
.text$x:00007970                 lea     eax, [edx+0Ch]
.text$x:00007973                 mov     ecx, [edx-8]
.text$x:00007976                 xor     ecx, eax
.text$x:00007978                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000797D                 mov     eax, offset __ehfuncinfo$??1?$vector@_WV?$allocator@_W@std@@@std@@QAE@XZ
.text$x:00007982                 jmp     ___CxxFrameHandler3
.text$x:00007982 __ehhandler$??1?$vector@_WV?$allocator@_W@std@@@std@@QAE@XZ endp
.text$x:00007982
.text$x:00007982 ; ---------------------------------------------------------------------------
.text$x:00007987                 align 4
.text$x:00007987 _text$x         ends
.text$x:00007987
.text$mn:00007988 ; ===========================================================================
.text$mn:00007988
.text$mn:00007988 ; Segment type: Pure code
.text$mn:00007988 ; Segment permissions: Read/Execute
.text$mn:00007988 _text$mn        segment para public 'CODE' use32
.text$mn:00007988                 assume cs:_text$mn
.text$mn:00007988                 ;org 7988h
.text$mn:00007988 ; COMDAT (pick any)
.text$mn:00007988                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007988
.text$mn:00007988 ; =============== S U B R O U T I N E =======================================
.text$mn:00007988
.text$mn:00007988 ; Attributes: bp-based frame
.text$mn:00007988
.text$mn:00007988 ; _DWORD __thiscall SizeableDlg::~SizeableDlg(SizeableDlg *__hidden this)
.text$mn:00007988                 public ??1SizeableDlg@@UAE@XZ
.text$mn:00007988 ??1SizeableDlg@@UAE@XZ proc near        ; CODE XREF: __unwindfunclet$??0WindowsDlg@@QAE@XZ$0+3j
.text$mn:00007988                                         ; WindowsDlg::~WindowsDlg(void)+46p ...
.text$mn:00007988
.text$mn:00007988 var_10          = dword ptr -10h
.text$mn:00007988 var_C           = dword ptr -0Ch
.text$mn:00007988 var_4           = dword ptr -4
.text$mn:00007988
.text$mn:00007988                 push    ebp
.text$mn:00007989                 mov     ebp, esp
.text$mn:0000798B                 push    0FFFFFFFFh
.text$mn:0000798D                 push    offset __ehhandler$??1SizeableDlg@@UAE@XZ
.text$mn:00007992                 mov     eax, large fs:0
.text$mn:00007998                 push    eax
.text$mn:00007999                 push    ecx
.text$mn:0000799A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000799F                 xor     eax, ebp
.text$mn:000079A1                 push    eax
.text$mn:000079A2                 lea     eax, [ebp+var_C]
.text$mn:000079A5                 mov     large fs:0, eax
.text$mn:000079AB                 mov     [ebp+var_10], ecx
.text$mn:000079AE                 mov     [ebp+var_4], 1
.text$mn:000079B5                 mov     byte ptr [ebp+var_4], 0
.text$mn:000079B9                 mov     ecx, [ebp+var_10]
.text$mn:000079BC                 add     ecx, 20h ; ' '  ; this
.text$mn:000079BF                 call    ??1CWinMgr@@UAE@XZ ; CWinMgr::~CWinMgr(void)
.text$mn:000079C4                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000079CB                 mov     ecx, [ebp+var_10] ; this
.text$mn:000079CE                 call    ??1StaticDialog@@UAE@XZ ; StaticDialog::~StaticDialog(void)
.text$mn:000079D3                 mov     ecx, [ebp+var_C]
.text$mn:000079D6                 mov     large fs:0, ecx
.text$mn:000079DD                 pop     ecx
.text$mn:000079DE                 mov     esp, ebp
.text$mn:000079E0                 pop     ebp
.text$mn:000079E1                 retn
.text$mn:000079E1 ??1SizeableDlg@@UAE@XZ endp
.text$mn:000079E1
.text$mn:000079E1 ; ---------------------------------------------------------------------------
.text$mn:000079E2                 align 4
.text$mn:000079E2 _text$mn        ends
.text$mn:000079E2
.text$x:000079E4 ; ===========================================================================
.text$x:000079E4
.text$x:000079E4 ; Segment type: Pure code
.text$x:000079E4 ; Segment permissions: Read/Execute
.text$x:000079E4 _text$x         segment para public 'CODE' use32
.text$x:000079E4                 assume cs:_text$x
.text$x:000079E4                 ;org 79E4h
.text$x:000079E4 ; COMDAT (pick associative to section at 7988)
.text$x:000079E4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000079E4
.text$x:000079E4 ; =============== S U B R O U T I N E =======================================
.text$x:000079E4
.text$x:000079E4
.text$x:000079E4 __unwindfunclet$??1SizeableDlg@@UAE@XZ$0 proc near
.text$x:000079E4                                         ; DATA XREF: .xdata$x:0000C61Co
.text$x:000079E4                 mov     ecx, [ebp-10h]  ; this
.text$x:000079E7                 jmp     ??1StaticDialog@@UAE@XZ ; StaticDialog::~StaticDialog(void)
.text$x:000079E7 __unwindfunclet$??1SizeableDlg@@UAE@XZ$0 endp
.text$x:000079E7
.text$x:000079EC
.text$x:000079EC ; =============== S U B R O U T I N E =======================================
.text$x:000079EC
.text$x:000079EC
.text$x:000079EC __unwindfunclet$??1SizeableDlg@@UAE@XZ$1 proc near
.text$x:000079EC                                         ; DATA XREF: .xdata$x:0000C624o
.text$x:000079EC                 mov     ecx, [ebp-10h]
.text$x:000079EF                 add     ecx, 20h ; ' '  ; this
.text$x:000079F2                 jmp     ??1CWinMgr@@UAE@XZ ; CWinMgr::~CWinMgr(void)
.text$x:000079F2 __unwindfunclet$??1SizeableDlg@@UAE@XZ$1 endp
.text$x:000079F2
.text$x:000079F7
.text$x:000079F7 ; =============== S U B R O U T I N E =======================================
.text$x:000079F7
.text$x:000079F7
.text$x:000079F7 __ehhandler$??1SizeableDlg@@UAE@XZ proc near
.text$x:000079F7                                         ; DATA XREF: SizeableDlg::~SizeableDlg(void)+5o
.text$x:000079F7
.text$x:000079F7 arg_4           = dword ptr  8
.text$x:000079F7
.text$x:000079F7                 mov     edx, [esp+arg_4]
.text$x:000079FB                 lea     eax, [edx+0Ch]
.text$x:000079FE                 mov     ecx, [edx-8]
.text$x:00007A01                 xor     ecx, eax
.text$x:00007A03                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00007A08                 mov     eax, offset __ehfuncinfo$??1SizeableDlg@@UAE@XZ
.text$x:00007A0D                 jmp     ___CxxFrameHandler3
.text$x:00007A0D __ehhandler$??1SizeableDlg@@UAE@XZ endp
.text$x:00007A0D
.text$x:00007A0D ; ---------------------------------------------------------------------------
.text$x:00007A12                 align 4
.text$x:00007A12 _text$x         ends
.text$x:00007A12
.text$mn:00007A14 ; ===========================================================================
.text$mn:00007A14
.text$mn:00007A14 ; Segment type: Pure code
.text$mn:00007A14 ; Segment permissions: Read/Execute
.text$mn:00007A14 _text$mn        segment para public 'CODE' use32
.text$mn:00007A14                 assume cs:_text$mn
.text$mn:00007A14                 ;org 7A14h
.text$mn:00007A14 ; COMDAT (pick any)
.text$mn:00007A14                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007A14
.text$mn:00007A14 ; =============== S U B R O U T I N E =======================================
.text$mn:00007A14
.text$mn:00007A14 ; Attributes: bp-based frame
.text$mn:00007A14
.text$mn:00007A14 ; _DWORD __thiscall StaticDialog::~StaticDialog(StaticDialog *__hidden this)
.text$mn:00007A14                 public ??1StaticDialog@@UAE@XZ
.text$mn:00007A14 ??1StaticDialog@@UAE@XZ proc near       ; CODE XREF: SizeableDlg::~SizeableDlg(void)+46p
.text$mn:00007A14                                         ; __unwindfunclet$??1SizeableDlg@@UAE@XZ$0+3j ...
.text$mn:00007A14
.text$mn:00007A14 var_10          = dword ptr -10h
.text$mn:00007A14 var_C           = dword ptr -0Ch
.text$mn:00007A14 var_4           = dword ptr -4
.text$mn:00007A14
.text$mn:00007A14                 push    ebp
.text$mn:00007A15                 mov     ebp, esp
.text$mn:00007A17                 push    0FFFFFFFFh
.text$mn:00007A19                 push    offset __ehhandler$??1StaticDialog@@UAE@XZ
.text$mn:00007A1E                 mov     eax, large fs:0
.text$mn:00007A24                 push    eax
.text$mn:00007A25                 push    ecx
.text$mn:00007A26                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00007A2B                 xor     eax, ebp
.text$mn:00007A2D                 push    eax
.text$mn:00007A2E                 lea     eax, [ebp+var_C]
.text$mn:00007A31                 mov     large fs:0, eax
.text$mn:00007A37                 mov     [ebp+var_10], ecx
.text$mn:00007A3A                 mov     eax, [ebp+var_10]
.text$mn:00007A3D                 mov     dword ptr [eax], offset ??_7StaticDialog@@6B@ ; const StaticDialog::`vftable'
.text$mn:00007A43                 mov     [ebp+var_4], 0
.text$mn:00007A4A                 mov     ecx, [ebp+var_10] ; this
.text$mn:00007A4D                 call    ?isCreated@StaticDialog@@UBE_NXZ ; StaticDialog::isCreated(void)
.text$mn:00007A52                 movzx   ecx, al
.text$mn:00007A55                 test    ecx, ecx
.text$mn:00007A57                 jz      short loc_7A72
.text$mn:00007A59                 push    0               ; dwNewLong
.text$mn:00007A5B                 push    0FFFFFFEBh      ; nIndex
.text$mn:00007A5D                 mov     edx, [ebp+var_10]
.text$mn:00007A60                 mov     eax, [edx+0Ch]
.text$mn:00007A63                 push    eax             ; hWnd
.text$mn:00007A64                 call    dword ptr ds:__imp__SetWindowLongW@12 ; SetWindowLongW(x,x,x)
.text$mn:00007A6A                 mov     ecx, [ebp+var_10] ; this
.text$mn:00007A6D                 call    ?destroy@StaticDialog@@UAEXXZ ; StaticDialog::destroy(void)
.text$mn:00007A72
.text$mn:00007A72 loc_7A72:                               ; CODE XREF: StaticDialog::~StaticDialog(void)+43j
.text$mn:00007A72                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00007A79                 mov     ecx, [ebp+var_10] ; this
.text$mn:00007A7C                 call    ??1Window@@UAE@XZ ; Window::~Window(void)
.text$mn:00007A81                 mov     ecx, [ebp+var_C]
.text$mn:00007A84                 mov     large fs:0, ecx
.text$mn:00007A8B                 pop     ecx
.text$mn:00007A8C                 mov     esp, ebp
.text$mn:00007A8E                 pop     ebp
.text$mn:00007A8F                 retn
.text$mn:00007A8F ??1StaticDialog@@UAE@XZ endp
.text$mn:00007A8F
.text$mn:00007A8F _text$mn        ends
.text$mn:00007A8F
.text$x:00007A90 ; ===========================================================================
.text$x:00007A90
.text$x:00007A90 ; Segment type: Pure code
.text$x:00007A90 ; Segment permissions: Read/Execute
.text$x:00007A90 _text$x         segment para public 'CODE' use32
.text$x:00007A90                 assume cs:_text$x
.text$x:00007A90                 ;org 7A90h
.text$x:00007A90 ; COMDAT (pick associative to section at 7A14)
.text$x:00007A90                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00007A90
.text$x:00007A90 ; =============== S U B R O U T I N E =======================================
.text$x:00007A90
.text$x:00007A90
.text$x:00007A90 __unwindfunclet$??1StaticDialog@@UAE@XZ$0 proc near
.text$x:00007A90                                         ; DATA XREF: .xdata$x:0000C5F0o
.text$x:00007A90                 mov     ecx, [ebp-10h]  ; this
.text$x:00007A93                 jmp     ??1Window@@UAE@XZ ; Window::~Window(void)
.text$x:00007A93 __unwindfunclet$??1StaticDialog@@UAE@XZ$0 endp
.text$x:00007A93
.text$x:00007A98
.text$x:00007A98 ; =============== S U B R O U T I N E =======================================
.text$x:00007A98
.text$x:00007A98
.text$x:00007A98 __ehhandler$??1StaticDialog@@UAE@XZ proc near
.text$x:00007A98                                         ; DATA XREF: StaticDialog::~StaticDialog(void)+5o
.text$x:00007A98
.text$x:00007A98 arg_4           = dword ptr  8
.text$x:00007A98
.text$x:00007A98                 mov     edx, [esp+arg_4]
.text$x:00007A9C                 lea     eax, [edx+0Ch]
.text$x:00007A9F                 mov     ecx, [edx-8]
.text$x:00007AA2                 xor     ecx, eax
.text$x:00007AA4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00007AA9                 mov     eax, offset __ehfuncinfo$??1StaticDialog@@UAE@XZ
.text$x:00007AAE                 jmp     ___CxxFrameHandler3
.text$x:00007AAE __ehhandler$??1StaticDialog@@UAE@XZ endp
.text$x:00007AAE
.text$x:00007AAE ; ---------------------------------------------------------------------------
.text$x:00007AB3                 align 4
.text$x:00007AB3 _text$x         ends
.text$x:00007AB3
.text$mn:00007AB4 ; ===========================================================================
.text$mn:00007AB4
.text$mn:00007AB4 ; Segment type: Pure code
.text$mn:00007AB4 ; Segment permissions: Read/Execute
.text$mn:00007AB4 _text$mn        segment para public 'CODE' use32
.text$mn:00007AB4                 assume cs:_text$mn
.text$mn:00007AB4                 ;org 7AB4h
.text$mn:00007AB4 ; COMDAT (pick any)
.text$mn:00007AB4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007AB4
.text$mn:00007AB4 ; =============== S U B R O U T I N E =======================================
.text$mn:00007AB4
.text$mn:00007AB4 ; Attributes: bp-based frame
.text$mn:00007AB4
.text$mn:00007AB4 ; _DWORD __thiscall Window::~Window(Window *__hidden this)
.text$mn:00007AB4                 public ??1Window@@UAE@XZ
.text$mn:00007AB4 ??1Window@@UAE@XZ proc near             ; CODE XREF: StaticDialog::~StaticDialog(void)+68p
.text$mn:00007AB4                                         ; __unwindfunclet$??1StaticDialog@@UAE@XZ$0+3j ...
.text$mn:00007AB4
.text$mn:00007AB4 var_4           = dword ptr -4
.text$mn:00007AB4
.text$mn:00007AB4                 push    ebp
.text$mn:00007AB5                 mov     ebp, esp
.text$mn:00007AB7                 push    ecx
.text$mn:00007AB8                 mov     [ebp+var_4], ecx
.text$mn:00007ABB                 mov     eax, [ebp+var_4]
.text$mn:00007ABE                 mov     dword ptr [eax], offset ??_7Window@@6B@ ; const Window::`vftable'
.text$mn:00007AC4                 mov     esp, ebp
.text$mn:00007AC6                 pop     ebp
.text$mn:00007AC7                 retn
.text$mn:00007AC7 ??1Window@@UAE@XZ endp
.text$mn:00007AC7
.text$mn:00007AC7 _text$mn        ends
.text$mn:00007AC7
.text$mn:00007AC8 ; ===========================================================================
.text$mn:00007AC8
.text$mn:00007AC8 ; Segment type: Pure code
.text$mn:00007AC8 ; Segment permissions: Read/Execute
.text$mn:00007AC8 _text$mn        segment para public 'CODE' use32
.text$mn:00007AC8                 assume cs:_text$mn
.text$mn:00007AC8                 ;org 7AC8h
.text$mn:00007AC8 ; COMDAT (pick any)
.text$mn:00007AC8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007AC8
.text$mn:00007AC8 ; =============== S U B R O U T I N E =======================================
.text$mn:00007AC8
.text$mn:00007AC8 ; Attributes: bp-based frame
.text$mn:00007AC8
.text$mn:00007AC8 ; _DWORD __thiscall WindowsDlg::~WindowsDlg(WindowsDlg *__hidden this)
.text$mn:00007AC8                 public ??1WindowsDlg@@UAE@XZ
.text$mn:00007AC8 ??1WindowsDlg@@UAE@XZ proc near         ; CODE XREF: WindowsDlg::`scalar deleting destructor'(uint)+Ap
.text$mn:00007AC8
.text$mn:00007AC8 var_10          = dword ptr -10h
.text$mn:00007AC8 var_C           = dword ptr -0Ch
.text$mn:00007AC8 var_4           = dword ptr -4
.text$mn:00007AC8
.text$mn:00007AC8                 push    ebp
.text$mn:00007AC9                 mov     ebp, esp
.text$mn:00007ACB                 push    0FFFFFFFFh
.text$mn:00007ACD                 push    offset __ehhandler$??1WindowsDlg@@UAE@XZ
.text$mn:00007AD2                 mov     eax, large fs:0
.text$mn:00007AD8                 push    eax
.text$mn:00007AD9                 push    ecx
.text$mn:00007ADA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00007ADF                 xor     eax, ebp
.text$mn:00007AE1                 push    eax
.text$mn:00007AE2                 lea     eax, [ebp+var_C]
.text$mn:00007AE5                 mov     large fs:0, eax
.text$mn:00007AEB                 mov     [ebp+var_10], ecx
.text$mn:00007AEE                 mov     [ebp+var_4], 1
.text$mn:00007AF5                 mov     byte ptr [ebp+var_4], 0
.text$mn:00007AF9                 mov     ecx, [ebp+var_10]
.text$mn:00007AFC                 add     ecx, 40h ; '@'
.text$mn:00007AFF                 call    ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int>>::~vector<int,std::allocator<int>>(void)
.text$mn:00007B04                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00007B0B                 mov     ecx, [ebp+var_10] ; this
.text$mn:00007B0E                 call    ??1SizeableDlg@@UAE@XZ ; SizeableDlg::~SizeableDlg(void)
.text$mn:00007B13                 mov     ecx, [ebp+var_C]
.text$mn:00007B16                 mov     large fs:0, ecx
.text$mn:00007B1D                 pop     ecx
.text$mn:00007B1E                 mov     esp, ebp
.text$mn:00007B20                 pop     ebp
.text$mn:00007B21                 retn
.text$mn:00007B21 ??1WindowsDlg@@UAE@XZ endp
.text$mn:00007B21
.text$mn:00007B21 ; ---------------------------------------------------------------------------
.text$mn:00007B22                 align 4
.text$mn:00007B22 _text$mn        ends
.text$mn:00007B22
.text$x:00007B24 ; ===========================================================================
.text$x:00007B24
.text$x:00007B24 ; Segment type: Pure code
.text$x:00007B24 ; Segment permissions: Read/Execute
.text$x:00007B24 _text$x         segment para public 'CODE' use32
.text$x:00007B24                 assume cs:_text$x
.text$x:00007B24                 ;org 7B24h
.text$x:00007B24 ; COMDAT (pick associative to section at 7AC8)
.text$x:00007B24                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00007B24
.text$x:00007B24 ; =============== S U B R O U T I N E =======================================
.text$x:00007B24
.text$x:00007B24
.text$x:00007B24 __unwindfunclet$??1WindowsDlg@@UAE@XZ$0 proc near
.text$x:00007B24                                         ; DATA XREF: .xdata$x:0000D064o
.text$x:00007B24                 mov     ecx, [ebp-10h]  ; this
.text$x:00007B27                 jmp     ??1SizeableDlg@@UAE@XZ ; SizeableDlg::~SizeableDlg(void)
.text$x:00007B27 __unwindfunclet$??1WindowsDlg@@UAE@XZ$0 endp
.text$x:00007B27
.text$x:00007B2C
.text$x:00007B2C ; =============== S U B R O U T I N E =======================================
.text$x:00007B2C
.text$x:00007B2C
.text$x:00007B2C __unwindfunclet$??1WindowsDlg@@UAE@XZ$1 proc near
.text$x:00007B2C                                         ; DATA XREF: .xdata$x:0000D06Co
.text$x:00007B2C                 mov     ecx, [ebp-10h]
.text$x:00007B2F                 add     ecx, 40h ; '@'
.text$x:00007B32                 jmp     ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int>>::~vector<int,std::allocator<int>>(void)
.text$x:00007B32 __unwindfunclet$??1WindowsDlg@@UAE@XZ$1 endp
.text$x:00007B32
.text$x:00007B37
.text$x:00007B37 ; =============== S U B R O U T I N E =======================================
.text$x:00007B37
.text$x:00007B37
.text$x:00007B37 __ehhandler$??1WindowsDlg@@UAE@XZ proc near
.text$x:00007B37                                         ; DATA XREF: WindowsDlg::~WindowsDlg(void)+5o
.text$x:00007B37
.text$x:00007B37 arg_4           = dword ptr  8
.text$x:00007B37
.text$x:00007B37                 mov     edx, [esp+arg_4]
.text$x:00007B3B                 lea     eax, [edx+0Ch]
.text$x:00007B3E                 mov     ecx, [edx-8]
.text$x:00007B41                 xor     ecx, eax
.text$x:00007B43                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00007B48                 mov     eax, offset __ehfuncinfo$??1WindowsDlg@@UAE@XZ
.text$x:00007B4D                 jmp     ___CxxFrameHandler3
.text$x:00007B4D __ehhandler$??1WindowsDlg@@UAE@XZ endp
.text$x:00007B4D
.text$x:00007B4D ; ---------------------------------------------------------------------------
.text$x:00007B52                 align 4
.text$x:00007B52 _text$x         ends
.text$x:00007B52
.text$mn:00007B54 ; ===========================================================================
.text$mn:00007B54
.text$mn:00007B54 ; Segment type: Pure code
.text$mn:00007B54 ; Segment permissions: Read/Execute
.text$mn:00007B54 _text$mn        segment para public 'CODE' use32
.text$mn:00007B54                 assume cs:_text$mn
.text$mn:00007B54                 ;org 7B54h
.text$mn:00007B54 ; COMDAT (pick any)
.text$mn:00007B54                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007B54
.text$mn:00007B54 ; =============== S U B R O U T I N E =======================================
.text$mn:00007B54
.text$mn:00007B54 ; Attributes: bp-based frame
.text$mn:00007B54
.text$mn:00007B54 ; _DWORD __thiscall std::_Container_base12::~_Container_base12(std::_Container_base12 *__hidden this)
.text$mn:00007B54                 public ??1_Container_base12@std@@QAE@XZ
.text$mn:00007B54 ??1_Container_base12@std@@QAE@XZ proc near
.text$mn:00007B54                                         ; CODE XREF: __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0+3j
.text$mn:00007B54                                         ; __unwindfunclet$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0+3j ...
.text$mn:00007B54
.text$mn:00007B54 var_4           = dword ptr -4
.text$mn:00007B54
.text$mn:00007B54                 push    ebp
.text$mn:00007B55                 mov     ebp, esp
.text$mn:00007B57                 push    ecx
.text$mn:00007B58                 mov     [ebp+var_4], ecx
.text$mn:00007B5B                 mov     ecx, [ebp+var_4] ; this
.text$mn:00007B5E                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00007B63                 mov     esp, ebp
.text$mn:00007B65                 pop     ebp
.text$mn:00007B66                 retn
.text$mn:00007B66 ??1_Container_base12@std@@QAE@XZ endp
.text$mn:00007B66
.text$mn:00007B66 ; ---------------------------------------------------------------------------
.text$mn:00007B67                 align 4
.text$mn:00007B67 _text$mn        ends
.text$mn:00007B67
.text$mn:00007B68 ; ===========================================================================
.text$mn:00007B68
.text$mn:00007B68 ; Segment type: Pure code
.text$mn:00007B68 ; Segment permissions: Read/Execute
.text$mn:00007B68 _text$mn        segment para public 'CODE' use32
.text$mn:00007B68                 assume cs:_text$mn
.text$mn:00007B68                 ;org 7B68h
.text$mn:00007B68 ; COMDAT (pick any)
.text$mn:00007B68                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007B68
.text$mn:00007B68 ; =============== S U B R O U T I N E =======================================
.text$mn:00007B68
.text$mn:00007B68 ; Attributes: bp-based frame
.text$mn:00007B68
.text$mn:00007B68 ; _DWORD __thiscall std::_Generic_error_category::~_Generic_error_category(std::_Generic_error_category *__hidden this)
.text$mn:00007B68                 public ??1_Generic_error_category@std@@UAE@XZ
.text$mn:00007B68 ??1_Generic_error_category@std@@UAE@XZ proc near
.text$mn:00007B68                                         ; CODE XREF: __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0+3j
.text$mn:00007B68                                         ; __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0+3j ...
.text$mn:00007B68
.text$mn:00007B68 var_10          = dword ptr -10h
.text$mn:00007B68 var_C           = dword ptr -0Ch
.text$mn:00007B68 var_4           = dword ptr -4
.text$mn:00007B68
.text$mn:00007B68                 push    ebp
.text$mn:00007B69                 mov     ebp, esp
.text$mn:00007B6B                 push    0FFFFFFFFh
.text$mn:00007B6D                 push    offset __ehhandler$??1_Generic_error_category@std@@UAE@XZ
.text$mn:00007B72                 mov     eax, large fs:0
.text$mn:00007B78                 push    eax
.text$mn:00007B79                 push    ecx
.text$mn:00007B7A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00007B7F                 xor     eax, ebp
.text$mn:00007B81                 push    eax
.text$mn:00007B82                 lea     eax, [ebp+var_C]
.text$mn:00007B85                 mov     large fs:0, eax
.text$mn:00007B8B                 mov     [ebp+var_10], ecx
.text$mn:00007B8E                 mov     [ebp+var_4], 0
.text$mn:00007B95                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00007B9C                 mov     ecx, [ebp+var_10] ; this
.text$mn:00007B9F                 call    ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$mn:00007BA4                 mov     ecx, [ebp+var_C]
.text$mn:00007BA7                 mov     large fs:0, ecx
.text$mn:00007BAE                 pop     ecx
.text$mn:00007BAF                 mov     esp, ebp
.text$mn:00007BB1                 pop     ebp
.text$mn:00007BB2                 retn
.text$mn:00007BB2 ??1_Generic_error_category@std@@UAE@XZ endp
.text$mn:00007BB2
.text$mn:00007BB2 ; ---------------------------------------------------------------------------
.text$mn:00007BB3                 align 4
.text$mn:00007BB3 _text$mn        ends
.text$mn:00007BB3
.text$x:00007BB4 ; ===========================================================================
.text$x:00007BB4
.text$x:00007BB4 ; Segment type: Pure code
.text$x:00007BB4 ; Segment permissions: Read/Execute
.text$x:00007BB4 _text$x         segment para public 'CODE' use32
.text$x:00007BB4                 assume cs:_text$x
.text$x:00007BB4                 ;org 7BB4h
.text$x:00007BB4 ; COMDAT (pick associative to section at 7B68)
.text$x:00007BB4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00007BB4
.text$x:00007BB4 ; =============== S U B R O U T I N E =======================================
.text$x:00007BB4
.text$x:00007BB4
.text$x:00007BB4 __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0 proc near
.text$x:00007BB4                                         ; DATA XREF: .xdata$x:0000C83Co
.text$x:00007BB4                 mov     ecx, [ebp-10h]  ; this
.text$x:00007BB7                 jmp     ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$x:00007BB7 __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0 endp
.text$x:00007BB7
.text$x:00007BBC
.text$x:00007BBC ; =============== S U B R O U T I N E =======================================
.text$x:00007BBC
.text$x:00007BBC
.text$x:00007BBC __ehhandler$??1_Generic_error_category@std@@UAE@XZ proc near
.text$x:00007BBC                                         ; DATA XREF: std::_Generic_error_category::~_Generic_error_category(void)+5o
.text$x:00007BBC
.text$x:00007BBC arg_4           = dword ptr  8
.text$x:00007BBC
.text$x:00007BBC                 mov     edx, [esp+arg_4]
.text$x:00007BC0                 lea     eax, [edx+0Ch]
.text$x:00007BC3                 mov     ecx, [edx-8]
.text$x:00007BC6                 xor     ecx, eax
.text$x:00007BC8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00007BCD                 mov     eax, offset __ehfuncinfo$??1_Generic_error_category@std@@UAE@XZ
.text$x:00007BD2                 jmp     ___CxxFrameHandler3
.text$x:00007BD2 __ehhandler$??1_Generic_error_category@std@@UAE@XZ endp
.text$x:00007BD2
.text$x:00007BD2 ; ---------------------------------------------------------------------------
.text$x:00007BD7                 align 4
.text$x:00007BD7 _text$x         ends
.text$x:00007BD7
.text$mn:00007BD8 ; ===========================================================================
.text$mn:00007BD8
.text$mn:00007BD8 ; Segment type: Pure code
.text$mn:00007BD8 ; Segment permissions: Read/Execute
.text$mn:00007BD8 _text$mn        segment para public 'CODE' use32
.text$mn:00007BD8                 assume cs:_text$mn
.text$mn:00007BD8                 ;org 7BD8h
.text$mn:00007BD8 ; COMDAT (pick any)
.text$mn:00007BD8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007BD8
.text$mn:00007BD8 ; =============== S U B R O U T I N E =======================================
.text$mn:00007BD8
.text$mn:00007BD8 ; Attributes: bp-based frame
.text$mn:00007BD8
.text$mn:00007BD8 ; _DWORD __thiscall std::_Iostream_error_category::~_Iostream_error_category(std::_Iostream_error_category *__hidden this)
.text$mn:00007BD8                 public ??1_Iostream_error_category@std@@UAE@XZ
.text$mn:00007BD8 ??1_Iostream_error_category@std@@UAE@XZ proc near
.text$mn:00007BD8                                         ; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+Ap
.text$mn:00007BD8                                         ; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p
.text$mn:00007BD8
.text$mn:00007BD8 var_10          = dword ptr -10h
.text$mn:00007BD8 var_C           = dword ptr -0Ch
.text$mn:00007BD8 var_4           = dword ptr -4
.text$mn:00007BD8
.text$mn:00007BD8                 push    ebp
.text$mn:00007BD9                 mov     ebp, esp
.text$mn:00007BDB                 push    0FFFFFFFFh
.text$mn:00007BDD                 push    offset __ehhandler$??1_Iostream_error_category@std@@UAE@XZ
.text$mn:00007BE2                 mov     eax, large fs:0
.text$mn:00007BE8                 push    eax
.text$mn:00007BE9                 push    ecx
.text$mn:00007BEA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00007BEF                 xor     eax, ebp
.text$mn:00007BF1                 push    eax
.text$mn:00007BF2                 lea     eax, [ebp+var_C]
.text$mn:00007BF5                 mov     large fs:0, eax
.text$mn:00007BFB                 mov     [ebp+var_10], ecx
.text$mn:00007BFE                 mov     [ebp+var_4], 0
.text$mn:00007C05                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00007C0C                 mov     ecx, [ebp+var_10] ; this
.text$mn:00007C0F                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:00007C14                 mov     ecx, [ebp+var_C]
.text$mn:00007C17                 mov     large fs:0, ecx
.text$mn:00007C1E                 pop     ecx
.text$mn:00007C1F                 mov     esp, ebp
.text$mn:00007C21                 pop     ebp
.text$mn:00007C22                 retn
.text$mn:00007C22 ??1_Iostream_error_category@std@@UAE@XZ endp
.text$mn:00007C22
.text$mn:00007C22 ; ---------------------------------------------------------------------------
.text$mn:00007C23                 align 4
.text$mn:00007C23 _text$mn        ends
.text$mn:00007C23
.text$x:00007C24 ; ===========================================================================
.text$x:00007C24
.text$x:00007C24 ; Segment type: Pure code
.text$x:00007C24 ; Segment permissions: Read/Execute
.text$x:00007C24 _text$x         segment para public 'CODE' use32
.text$x:00007C24                 assume cs:_text$x
.text$x:00007C24                 ;org 7C24h
.text$x:00007C24 ; COMDAT (pick associative to section at 7BD8)
.text$x:00007C24                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00007C24
.text$x:00007C24 ; =============== S U B R O U T I N E =======================================
.text$x:00007C24
.text$x:00007C24
.text$x:00007C24 __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0 proc near
.text$x:00007C24                                         ; DATA XREF: .xdata$x:0000C8C0o
.text$x:00007C24                 mov     ecx, [ebp-10h]  ; this
.text$x:00007C27                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00007C27 __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0 endp
.text$x:00007C27
.text$x:00007C2C
.text$x:00007C2C ; =============== S U B R O U T I N E =======================================
.text$x:00007C2C
.text$x:00007C2C
.text$x:00007C2C __ehhandler$??1_Iostream_error_category@std@@UAE@XZ proc near
.text$x:00007C2C                                         ; DATA XREF: std::_Iostream_error_category::~_Iostream_error_category(void)+5o
.text$x:00007C2C
.text$x:00007C2C arg_4           = dword ptr  8
.text$x:00007C2C
.text$x:00007C2C                 mov     edx, [esp+arg_4]
.text$x:00007C30                 lea     eax, [edx+0Ch]
.text$x:00007C33                 mov     ecx, [edx-8]
.text$x:00007C36                 xor     ecx, eax
.text$x:00007C38                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00007C3D                 mov     eax, offset __ehfuncinfo$??1_Iostream_error_category@std@@UAE@XZ
.text$x:00007C42                 jmp     ___CxxFrameHandler3
.text$x:00007C42 __ehhandler$??1_Iostream_error_category@std@@UAE@XZ endp
.text$x:00007C42
.text$x:00007C42 ; ---------------------------------------------------------------------------
.text$x:00007C47                 align 4
.text$x:00007C47 _text$x         ends
.text$x:00007C47
.text$mn:00007C48 ; ===========================================================================
.text$mn:00007C48
.text$mn:00007C48 ; Segment type: Pure code
.text$mn:00007C48 ; Segment permissions: Read/Execute
.text$mn:00007C48 _text$mn        segment para public 'CODE' use32
.text$mn:00007C48                 assume cs:_text$mn
.text$mn:00007C48                 ;org 7C48h
.text$mn:00007C48 ; COMDAT (pick any)
.text$mn:00007C48                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007C48
.text$mn:00007C48 ; =============== S U B R O U T I N E =======================================
.text$mn:00007C48
.text$mn:00007C48 ; Attributes: bp-based frame
.text$mn:00007C48
.text$mn:00007C48 ; _DWORD __thiscall std::_Iterator_base12::~_Iterator_base12(std::_Iterator_base12 *__hidden this)
.text$mn:00007C48                 public ??1_Iterator_base12@std@@QAE@XZ
.text$mn:00007C48 ??1_Iterator_base12@std@@QAE@XZ proc near
.text$mn:00007C48                                         ; CODE XREF: __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@ABU01@@Z$0+3j
.text$mn:00007C48                                         ; __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ$0+3j ...
.text$mn:00007C48
.text$mn:00007C48 var_14          = byte ptr -14h
.text$mn:00007C48 var_10          = dword ptr -10h
.text$mn:00007C48 var_C           = dword ptr -0Ch
.text$mn:00007C48 var_4           = dword ptr -4
.text$mn:00007C48
.text$mn:00007C48                 push    ebp
.text$mn:00007C49                 mov     ebp, esp
.text$mn:00007C4B                 push    0FFFFFFFFh
.text$mn:00007C4D                 push    offset __ehhandler$??1_Iterator_base12@std@@QAE@XZ
.text$mn:00007C52                 mov     eax, large fs:0
.text$mn:00007C58                 push    eax
.text$mn:00007C59                 sub     esp, 8
.text$mn:00007C5C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00007C61                 xor     eax, ebp
.text$mn:00007C63                 push    eax
.text$mn:00007C64                 lea     eax, [ebp+var_C]
.text$mn:00007C67                 mov     large fs:0, eax
.text$mn:00007C6D                 mov     [ebp+var_10], ecx
.text$mn:00007C70                 push    3               ; int
.text$mn:00007C72                 lea     ecx, [ebp+var_14] ; this
.text$mn:00007C75                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:00007C7A                 mov     [ebp+var_4], 0
.text$mn:00007C81                 mov     ecx, [ebp+var_10] ; this
.text$mn:00007C84                 call    ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me(void)
.text$mn:00007C89                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00007C90                 lea     ecx, [ebp+var_14] ; this
.text$mn:00007C93                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:00007C98                 mov     ecx, [ebp+var_C]
.text$mn:00007C9B                 mov     large fs:0, ecx
.text$mn:00007CA2                 pop     ecx
.text$mn:00007CA3                 mov     esp, ebp
.text$mn:00007CA5                 pop     ebp
.text$mn:00007CA6                 retn
.text$mn:00007CA6 ??1_Iterator_base12@std@@QAE@XZ endp
.text$mn:00007CA6
.text$mn:00007CA6 ; ---------------------------------------------------------------------------
.text$mn:00007CA7                 align 4
.text$mn:00007CA7 _text$mn        ends
.text$mn:00007CA7
.text$x:00007CA8 ; ===========================================================================
.text$x:00007CA8
.text$x:00007CA8 ; Segment type: Pure code
.text$x:00007CA8 ; Segment permissions: Read/Execute
.text$x:00007CA8 _text$x         segment para public 'CODE' use32
.text$x:00007CA8                 assume cs:_text$x
.text$x:00007CA8                 ;org 7CA8h
.text$x:00007CA8 ; COMDAT (pick associative to section at 7C48)
.text$x:00007CA8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00007CA8
.text$x:00007CA8 ; =============== S U B R O U T I N E =======================================
.text$x:00007CA8
.text$x:00007CA8
.text$x:00007CA8 __unwindfunclet$??1_Iterator_base12@std@@QAE@XZ$0 proc near
.text$x:00007CA8                                         ; DATA XREF: .xdata$x:0000C590o
.text$x:00007CA8                 lea     ecx, [ebp-14h]  ; this
.text$x:00007CAB                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:00007CAB __unwindfunclet$??1_Iterator_base12@std@@QAE@XZ$0 endp
.text$x:00007CAB
.text$x:00007CB0
.text$x:00007CB0 ; =============== S U B R O U T I N E =======================================
.text$x:00007CB0
.text$x:00007CB0
.text$x:00007CB0 __ehhandler$??1_Iterator_base12@std@@QAE@XZ proc near
.text$x:00007CB0                                         ; DATA XREF: std::_Iterator_base12::~_Iterator_base12(void)+5o
.text$x:00007CB0
.text$x:00007CB0 arg_4           = dword ptr  8
.text$x:00007CB0
.text$x:00007CB0                 mov     edx, [esp+arg_4]
.text$x:00007CB4                 lea     eax, [edx+0Ch]
.text$x:00007CB7                 mov     ecx, [edx-0Ch]
.text$x:00007CBA                 xor     ecx, eax
.text$x:00007CBC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00007CC1                 mov     eax, offset __ehfuncinfo$??1_Iterator_base12@std@@QAE@XZ
.text$x:00007CC6                 jmp     ___CxxFrameHandler3
.text$x:00007CC6 __ehhandler$??1_Iterator_base12@std@@QAE@XZ endp
.text$x:00007CC6
.text$x:00007CC6 ; ---------------------------------------------------------------------------
.text$x:00007CCB                 align 4
.text$x:00007CCB _text$x         ends
.text$x:00007CCB
.text$mn:00007CCC ; ===========================================================================
.text$mn:00007CCC
.text$mn:00007CCC ; Segment type: Pure code
.text$mn:00007CCC ; Segment permissions: Read/Execute
.text$mn:00007CCC _text$mn        segment para public 'CODE' use32
.text$mn:00007CCC                 assume cs:_text$mn
.text$mn:00007CCC                 ;org 7CCCh
.text$mn:00007CCC ; COMDAT (pick any)
.text$mn:00007CCC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007CCC
.text$mn:00007CCC ; =============== S U B R O U T I N E =======================================
.text$mn:00007CCC
.text$mn:00007CCC ; Attributes: bp-based frame
.text$mn:00007CCC
.text$mn:00007CCC ; _DWORD __thiscall std::_System_error_category::~_System_error_category(std::_System_error_category *__hidden this)
.text$mn:00007CCC                 public ??1_System_error_category@std@@UAE@XZ
.text$mn:00007CCC ??1_System_error_category@std@@UAE@XZ proc near
.text$mn:00007CCC                                         ; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+Ap
.text$mn:00007CCC                                         ; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p
.text$mn:00007CCC
.text$mn:00007CCC var_10          = dword ptr -10h
.text$mn:00007CCC var_C           = dword ptr -0Ch
.text$mn:00007CCC var_4           = dword ptr -4
.text$mn:00007CCC
.text$mn:00007CCC                 push    ebp
.text$mn:00007CCD                 mov     ebp, esp
.text$mn:00007CCF                 push    0FFFFFFFFh
.text$mn:00007CD1                 push    offset __ehhandler$??1_System_error_category@std@@UAE@XZ
.text$mn:00007CD6                 mov     eax, large fs:0
.text$mn:00007CDC                 push    eax
.text$mn:00007CDD                 push    ecx
.text$mn:00007CDE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00007CE3                 xor     eax, ebp
.text$mn:00007CE5                 push    eax
.text$mn:00007CE6                 lea     eax, [ebp+var_C]
.text$mn:00007CE9                 mov     large fs:0, eax
.text$mn:00007CEF                 mov     [ebp+var_10], ecx
.text$mn:00007CF2                 mov     [ebp+var_4], 0
.text$mn:00007CF9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00007D00                 mov     ecx, [ebp+var_10] ; this
.text$mn:00007D03                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:00007D08                 mov     ecx, [ebp+var_C]
.text$mn:00007D0B                 mov     large fs:0, ecx
.text$mn:00007D12                 pop     ecx
.text$mn:00007D13                 mov     esp, ebp
.text$mn:00007D15                 pop     ebp
.text$mn:00007D16                 retn
.text$mn:00007D16 ??1_System_error_category@std@@UAE@XZ endp
.text$mn:00007D16
.text$mn:00007D16 ; ---------------------------------------------------------------------------
.text$mn:00007D17                 align 4
.text$mn:00007D17 _text$mn        ends
.text$mn:00007D17
.text$x:00007D18 ; ===========================================================================
.text$x:00007D18
.text$x:00007D18 ; Segment type: Pure code
.text$x:00007D18 ; Segment permissions: Read/Execute
.text$x:00007D18 _text$x         segment para public 'CODE' use32
.text$x:00007D18                 assume cs:_text$x
.text$x:00007D18                 ;org 7D18h
.text$x:00007D18 ; COMDAT (pick associative to section at 7CCC)
.text$x:00007D18                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00007D18
.text$x:00007D18 ; =============== S U B R O U T I N E =======================================
.text$x:00007D18
.text$x:00007D18
.text$x:00007D18 __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0 proc near
.text$x:00007D18                                         ; DATA XREF: .xdata$x:0000C944o
.text$x:00007D18                 mov     ecx, [ebp-10h]  ; this
.text$x:00007D1B                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00007D1B __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0 endp
.text$x:00007D1B
.text$x:00007D20
.text$x:00007D20 ; =============== S U B R O U T I N E =======================================
.text$x:00007D20
.text$x:00007D20
.text$x:00007D20 __ehhandler$??1_System_error_category@std@@UAE@XZ proc near
.text$x:00007D20                                         ; DATA XREF: std::_System_error_category::~_System_error_category(void)+5o
.text$x:00007D20
.text$x:00007D20 arg_4           = dword ptr  8
.text$x:00007D20
.text$x:00007D20                 mov     edx, [esp+arg_4]
.text$x:00007D24                 lea     eax, [edx+0Ch]
.text$x:00007D27                 mov     ecx, [edx-8]
.text$x:00007D2A                 xor     ecx, eax
.text$x:00007D2C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00007D31                 mov     eax, offset __ehfuncinfo$??1_System_error_category@std@@UAE@XZ
.text$x:00007D36                 jmp     ___CxxFrameHandler3
.text$x:00007D36 __ehhandler$??1_System_error_category@std@@UAE@XZ endp
.text$x:00007D36
.text$x:00007D36 ; ---------------------------------------------------------------------------
.text$x:00007D3B                 align 4
.text$x:00007D3B _text$x         ends
.text$x:00007D3B
.text$mn:00007D3C ; ===========================================================================
.text$mn:00007D3C
.text$mn:00007D3C ; Segment type: Pure code
.text$mn:00007D3C ; Segment permissions: Read/Execute
.text$mn:00007D3C _text$mn        segment para public 'CODE' use32
.text$mn:00007D3C                 assume cs:_text$mn
.text$mn:00007D3C                 ;org 7D3Ch
.text$mn:00007D3C ; COMDAT (pick any)
.text$mn:00007D3C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007D3C
.text$mn:00007D3C ; =============== S U B R O U T I N E =======================================
.text$mn:00007D3C
.text$mn:00007D3C ; Attributes: bp-based frame
.text$mn:00007D3C
.text$mn:00007D3C ; _DWORD __thiscall std::error_category::~error_category(std::error_category *__hidden this)
.text$mn:00007D3C                 public ??1error_category@std@@UAE@XZ
.text$mn:00007D3C ??1error_category@std@@UAE@XZ proc near ; CODE XREF: __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0+3j
.text$mn:00007D3C                                         ; std::_Generic_error_category::~_Generic_error_category(void)+37p ...
.text$mn:00007D3C
.text$mn:00007D3C var_4           = dword ptr -4
.text$mn:00007D3C
.text$mn:00007D3C                 push    ebp
.text$mn:00007D3D                 mov     ebp, esp
.text$mn:00007D3F                 push    ecx
.text$mn:00007D40                 mov     [ebp+var_4], ecx
.text$mn:00007D43                 mov     eax, [ebp+var_4]
.text$mn:00007D46                 mov     dword ptr [eax], offset ??_7error_category@std@@6B@ ; const std::error_category::`vftable'
.text$mn:00007D4C                 mov     esp, ebp
.text$mn:00007D4E                 pop     ebp
.text$mn:00007D4F                 retn
.text$mn:00007D4F ??1error_category@std@@UAE@XZ endp
.text$mn:00007D4F
.text$mn:00007D4F _text$mn        ends
.text$mn:00007D4F
.text$mn:00007D50 ; ===========================================================================
.text$mn:00007D50
.text$mn:00007D50 ; Segment type: Pure code
.text$mn:00007D50 ; Segment permissions: Read/Execute
.text$mn:00007D50 _text$mn        segment para public 'CODE' use32
.text$mn:00007D50                 assume cs:_text$mn
.text$mn:00007D50                 ;org 7D50h
.text$mn:00007D50 ; COMDAT (pick any)
.text$mn:00007D50                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007D50
.text$mn:00007D50 ; =============== S U B R O U T I N E =======================================
.text$mn:00007D50
.text$mn:00007D50 ; Attributes: bp-based frame
.text$mn:00007D50
.text$mn:00007D50 ; void *__cdecl operator new(unsigned int, void *)
.text$mn:00007D50                 public ??2@YAPAXIPAX@Z
.text$mn:00007D50 ??2@YAPAXIPAX@Z proc near               ; CODE XREF: std::_Construct<int,int>(int *,int &&)+31p
.text$mn:00007D50                                         ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)+2Ep ...
.text$mn:00007D50
.text$mn:00007D50 arg_4           = dword ptr  0Ch
.text$mn:00007D50
.text$mn:00007D50                 push    ebp
.text$mn:00007D51                 mov     ebp, esp
.text$mn:00007D53                 mov     eax, [ebp+arg_4]
.text$mn:00007D56                 pop     ebp
.text$mn:00007D57                 retn
.text$mn:00007D57 ??2@YAPAXIPAX@Z endp
.text$mn:00007D57
.text$mn:00007D57 _text$mn        ends
.text$mn:00007D57
.text$mn:00007D58 ; ===========================================================================
.text$mn:00007D58
.text$mn:00007D58 ; Segment type: Pure code
.text$mn:00007D58 ; Segment permissions: Read/Execute
.text$mn:00007D58 _text$mn        segment para public 'CODE' use32
.text$mn:00007D58                 assume cs:_text$mn
.text$mn:00007D58                 ;org 7D58h
.text$mn:00007D58 ; COMDAT (pick any)
.text$mn:00007D58                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007D58
.text$mn:00007D58 ; =============== S U B R O U T I N E =======================================
.text$mn:00007D58
.text$mn:00007D58 ; Attributes: bp-based frame
.text$mn:00007D58
.text$mn:00007D58 ; void __cdecl operator delete(void *)
.text$mn:00007D58                 public ??3@YAXPAX0@Z
.text$mn:00007D58 ??3@YAXPAX0@Z   proc near               ; CODE XREF: __unwindfunclet$??$_Construct@HH@std@@YAXPAH$$QAH@Z$0+8p
.text$mn:00007D58                                         ; __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0+8p ...
.text$mn:00007D58                 push    ebp
.text$mn:00007D59                 mov     ebp, esp
.text$mn:00007D5B                 pop     ebp
.text$mn:00007D5C                 retn
.text$mn:00007D5C ??3@YAXPAX0@Z   endp
.text$mn:00007D5C
.text$mn:00007D5C ; ---------------------------------------------------------------------------
.text$mn:00007D5D                 align 10h
.text$mn:00007D5D _text$mn        ends
.text$mn:00007D5D
.text$mn:00007D60 ; ===========================================================================
.text$mn:00007D60
.text$mn:00007D60 ; Segment type: Pure code
.text$mn:00007D60 ; Segment permissions: Read/Execute
.text$mn:00007D60 _text$mn        segment para public 'CODE' use32
.text$mn:00007D60                 assume cs:_text$mn
.text$mn:00007D60                 ;org 7D60h
.text$mn:00007D60 ; COMDAT (pick any)
.text$mn:00007D60                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007D60
.text$mn:00007D60 ; =============== S U B R O U T I N E =======================================
.text$mn:00007D60
.text$mn:00007D60 ; Attributes: bp-based frame
.text$mn:00007D60
.text$mn:00007D60 ; public: struct std::_Iterator012<struct std::random_access_iterator_tag, int, int, int const *, int const &, struct std::_Iterator_base12> & __thiscall std::_Iterator012<struct std::random_access_iterator_tag, int, int, int const *, int const &, struct std::_Iterator_base12>::operator=(struct std::_Iterator012<struct std::random_access_iterator_tag, int, int, int const *, int const &, struct std::_Iterator_base12> const &)
.text$mn:00007D60                 public ??4?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAEAAU01@ABU01@@Z
.text$mn:00007D60 ??4?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAEAAU01@ABU01@@Z proc near
.text$mn:00007D60                                         ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator=(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>> const &)+Ep
.text$mn:00007D60
.text$mn:00007D60 var_4           = dword ptr -4
.text$mn:00007D60 arg_0           = dword ptr  8
.text$mn:00007D60
.text$mn:00007D60                 push    ebp
.text$mn:00007D61                 mov     ebp, esp
.text$mn:00007D63                 push    ecx
.text$mn:00007D64                 mov     [ebp+var_4], ecx
.text$mn:00007D67                 mov     eax, [ebp+arg_0]
.text$mn:00007D6A                 push    eax
.text$mn:00007D6B                 mov     ecx, [ebp+var_4]
.text$mn:00007D6E                 call    ??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z ; std::_Iterator_base12::operator=(std::_Iterator_base12 const &)
.text$mn:00007D73                 mov     eax, [ebp+var_4]
.text$mn:00007D76                 mov     esp, ebp
.text$mn:00007D78                 pop     ebp
.text$mn:00007D79                 retn    4
.text$mn:00007D79 ??4?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAEAAU01@ABU01@@Z endp
.text$mn:00007D79
.text$mn:00007D79 _text$mn        ends
.text$mn:00007D79
.text$mn:00007D7C ; ===========================================================================
.text$mn:00007D7C
.text$mn:00007D7C ; Segment type: Pure code
.text$mn:00007D7C ; Segment permissions: Read/Execute
.text$mn:00007D7C _text$mn        segment para public 'CODE' use32
.text$mn:00007D7C                 assume cs:_text$mn
.text$mn:00007D7C                 ;org 7D7Ch
.text$mn:00007D7C ; COMDAT (pick any)
.text$mn:00007D7C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007D7C
.text$mn:00007D7C ; =============== S U B R O U T I N E =======================================
.text$mn:00007D7C
.text$mn:00007D7C ; Attributes: bp-based frame
.text$mn:00007D7C
.text$mn:00007D7C ; public: class std::_Temp_iterator<int> & __thiscall std::_Temp_iterator<int>::operator=(int &&)
.text$mn:00007D7C                 public ??4?$_Temp_iterator@H@std@@QAEAAV01@$$QAH@Z
.text$mn:00007D7C ??4?$_Temp_iterator@H@std@@QAEAAV01@$$QAH@Z proc near
.text$mn:00007D7C                                         ; CODE XREF: std::_Merge<int *,int *,std::_Temp_iterator<int>,BufferEquivalent>(int *,int *,int *,int *,std::_Temp_iterator<int>,BufferEquivalent)+B4p
.text$mn:00007D7C                                         ; std::_Merge<int *,int *,std::_Temp_iterator<int>,BufferEquivalent>(int *,int *,int *,int *,std::_Temp_iterator<int>,BufferEquivalent)+FAp ...
.text$mn:00007D7C
.text$mn:00007D7C var_C           = dword ptr -0Ch
.text$mn:00007D7C var_8           = dword ptr -8
.text$mn:00007D7C var_4           = dword ptr -4
.text$mn:00007D7C arg_0           = dword ptr  8
.text$mn:00007D7C
.text$mn:00007D7C                 push    ebp
.text$mn:00007D7D                 mov     ebp, esp
.text$mn:00007D7F                 sub     esp, 0Ch
.text$mn:00007D82                 mov     [ebp+var_4], ecx
.text$mn:00007D85                 mov     eax, [ebp+var_4]
.text$mn:00007D88                 mov     ecx, [eax+10h]
.text$mn:00007D8B                 mov     edx, [ebp+var_4]
.text$mn:00007D8E                 mov     eax, [edx+10h]
.text$mn:00007D91                 mov     ecx, [ecx+4]
.text$mn:00007D94                 cmp     ecx, [eax+8]
.text$mn:00007D97                 jnb     short loc_7DC9
.text$mn:00007D99                 mov     edx, [ebp+arg_0]
.text$mn:00007D9C                 push    edx
.text$mn:00007D9D                 call    ??$forward@H@std@@YA$$QAHAAH@Z ; std::forward<int>(int &)
.text$mn:00007DA2                 add     esp, 4
.text$mn:00007DA5                 mov     ecx, [ebp+var_4]
.text$mn:00007DA8                 mov     edx, [ecx+10h]
.text$mn:00007DAB                 mov     ecx, [edx+4]
.text$mn:00007DAE                 mov     edx, [eax]
.text$mn:00007DB0                 mov     [ecx], edx
.text$mn:00007DB2                 mov     eax, [ebp+var_4]
.text$mn:00007DB5                 mov     ecx, [eax+10h]
.text$mn:00007DB8                 mov     edx, [ecx+4]
.text$mn:00007DBB                 add     edx, 4
.text$mn:00007DBE                 mov     eax, [ebp+var_4]
.text$mn:00007DC1                 mov     ecx, [eax+10h]
.text$mn:00007DC4                 mov     [ecx+4], edx
.text$mn:00007DC7                 jmp     short loc_7E15
.text$mn:00007DC9 ; ---------------------------------------------------------------------------
.text$mn:00007DC9
.text$mn:00007DC9 loc_7DC9:                               ; CODE XREF: std::_Temp_iterator<int>::operator=(int &&)+1Bj
.text$mn:00007DC9                 mov     edx, [ebp+var_4]
.text$mn:00007DCC                 mov     eax, [edx+10h]
.text$mn:00007DCF                 mov     ecx, [eax+4]
.text$mn:00007DD2                 mov     [ebp+var_C], ecx
.text$mn:00007DD5                 mov     edx, [ebp+arg_0]
.text$mn:00007DD8                 push    edx
.text$mn:00007DD9                 call    ??$forward@H@std@@YA$$QAHAAH@Z ; std::forward<int>(int &)
.text$mn:00007DDE                 add     esp, 4
.text$mn:00007DE1                 push    eax
.text$mn:00007DE2                 mov     eax, [ebp+var_C]
.text$mn:00007DE5                 push    eax
.text$mn:00007DE6                 call    ??$_Construct@HH@std@@YAXPAH$$QAH@Z ; std::_Construct<int,int>(int *,int &&)
.text$mn:00007DEB                 add     esp, 8
.text$mn:00007DEE                 mov     ecx, [ebp+var_4]
.text$mn:00007DF1                 mov     edx, [ecx+10h]
.text$mn:00007DF4                 mov     eax, [edx+4]
.text$mn:00007DF7                 add     eax, 4
.text$mn:00007DFA                 mov     [ebp+var_8], eax
.text$mn:00007DFD                 mov     ecx, [ebp+var_4]
.text$mn:00007E00                 mov     edx, [ecx+10h]
.text$mn:00007E03                 mov     eax, [ebp+var_8]
.text$mn:00007E06                 mov     [edx+4], eax
.text$mn:00007E09                 mov     ecx, [ebp+var_4]
.text$mn:00007E0C                 mov     edx, [ecx+10h]
.text$mn:00007E0F                 mov     eax, [ebp+var_8]
.text$mn:00007E12                 mov     [edx+8], eax
.text$mn:00007E15
.text$mn:00007E15 loc_7E15:                               ; CODE XREF: std::_Temp_iterator<int>::operator=(int &&)+4Bj
.text$mn:00007E15                 mov     eax, [ebp+var_4]
.text$mn:00007E18                 mov     esp, ebp
.text$mn:00007E1A                 pop     ebp
.text$mn:00007E1B                 retn    4
.text$mn:00007E1B ??4?$_Temp_iterator@H@std@@QAEAAV01@$$QAH@Z endp
.text$mn:00007E1B
.text$mn:00007E1B ; ---------------------------------------------------------------------------
.text$mn:00007E1E                 align 10h
.text$mn:00007E1E _text$mn        ends
.text$mn:00007E1E
.text$mn:00007E20 ; ===========================================================================
.text$mn:00007E20
.text$mn:00007E20 ; Segment type: Pure code
.text$mn:00007E20 ; Segment permissions: Read/Execute
.text$mn:00007E20 _text$mn        segment para public 'CODE' use32
.text$mn:00007E20                 assume cs:_text$mn
.text$mn:00007E20                 ;org 7E20h
.text$mn:00007E20 ; COMDAT (pick any)
.text$mn:00007E20                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007E20
.text$mn:00007E20 ; =============== S U B R O U T I N E =======================================
.text$mn:00007E20
.text$mn:00007E20 ; Attributes: bp-based frame
.text$mn:00007E20
.text$mn:00007E20 ; public: class std::_Temp_iterator<int> & __thiscall std::_Temp_iterator<int>::operator=(class std::_Temp_iterator<int> const &)
.text$mn:00007E20                 public ??4?$_Temp_iterator@H@std@@QAEAAV01@ABV01@@Z
.text$mn:00007E20 ??4?$_Temp_iterator@H@std@@QAEAAV01@ABV01@@Z proc near
.text$mn:00007E20                                         ; CODE XREF: std::_Chunked_merge<int *,std::_Temp_iterator<int>,int,BufferEquivalent>(int *,int *,std::_Temp_iterator<int>,int,int,BufferEquivalent)+E8p
.text$mn:00007E20                                         ; std::_Merge<int *,int *,std::_Temp_iterator<int>,BufferEquivalent>(int *,int *,int *,int *,std::_Temp_iterator<int>,BufferEquivalent)+161p ...
.text$mn:00007E20
.text$mn:00007E20 var_4           = dword ptr -4
.text$mn:00007E20 arg_0           = dword ptr  8
.text$mn:00007E20
.text$mn:00007E20                 push    ebp
.text$mn:00007E21                 mov     ebp, esp
.text$mn:00007E23                 push    ecx
.text$mn:00007E24                 mov     [ebp+var_4], ecx
.text$mn:00007E27                 mov     eax, [ebp+var_4]
.text$mn:00007E2A                 mov     ecx, [ebp+arg_0]
.text$mn:00007E2D                 mov     edx, [ecx+10h]
.text$mn:00007E30                 mov     [eax+10h], edx
.text$mn:00007E33                 mov     eax, [ebp+var_4]
.text$mn:00007E36                 mov     esp, ebp
.text$mn:00007E38                 pop     ebp
.text$mn:00007E39                 retn    4
.text$mn:00007E39 ??4?$_Temp_iterator@H@std@@QAEAAV01@ABV01@@Z endp
.text$mn:00007E39
.text$mn:00007E39 _text$mn        ends
.text$mn:00007E39
.text$mn:00007E3C ; ===========================================================================
.text$mn:00007E3C
.text$mn:00007E3C ; Segment type: Pure code
.text$mn:00007E3C ; Segment permissions: Read/Execute
.text$mn:00007E3C _text$mn        segment para public 'CODE' use32
.text$mn:00007E3C                 assume cs:_text$mn
.text$mn:00007E3C                 ;org 7E3Ch
.text$mn:00007E3C ; COMDAT (pick any)
.text$mn:00007E3C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007E3C
.text$mn:00007E3C ; =============== S U B R O U T I N E =======================================
.text$mn:00007E3C
.text$mn:00007E3C ; Attributes: bp-based frame
.text$mn:00007E3C
.text$mn:00007E3C ; public: class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<int>>> & __thiscall std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<int>>>::operator=(class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<int>>> const &)
.text$mn:00007E3C                 public ??4?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAEAAV01@ABV01@@Z
.text$mn:00007E3C ??4?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAEAAV01@ABV01@@Z proc near
.text$mn:00007E3C                                         ; CODE XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator=(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>> const &)+Ep
.text$mn:00007E3C
.text$mn:00007E3C var_4           = dword ptr -4
.text$mn:00007E3C arg_0           = dword ptr  8
.text$mn:00007E3C
.text$mn:00007E3C                 push    ebp
.text$mn:00007E3D                 mov     ebp, esp
.text$mn:00007E3F                 push    ecx
.text$mn:00007E40                 mov     [ebp+var_4], ecx
.text$mn:00007E43                 mov     eax, [ebp+arg_0]
.text$mn:00007E46                 push    eax
.text$mn:00007E47                 mov     ecx, [ebp+var_4]
.text$mn:00007E4A                 call    ??4?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAEAAU01@ABU01@@Z ; std::_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>::operator=(std::_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12> const &)
.text$mn:00007E4F                 mov     ecx, [ebp+var_4]
.text$mn:00007E52                 mov     edx, [ebp+arg_0]
.text$mn:00007E55                 mov     eax, [edx+8]
.text$mn:00007E58                 mov     [ecx+8], eax
.text$mn:00007E5B                 mov     eax, [ebp+var_4]
.text$mn:00007E5E                 mov     esp, ebp
.text$mn:00007E60                 pop     ebp
.text$mn:00007E61                 retn    4
.text$mn:00007E61 ??4?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAEAAV01@ABV01@@Z endp
.text$mn:00007E61
.text$mn:00007E61 _text$mn        ends
.text$mn:00007E61
.text$mn:00007E64 ; ===========================================================================
.text$mn:00007E64
.text$mn:00007E64 ; Segment type: Pure code
.text$mn:00007E64 ; Segment permissions: Read/Execute
.text$mn:00007E64 _text$mn        segment para public 'CODE' use32
.text$mn:00007E64                 assume cs:_text$mn
.text$mn:00007E64                 ;org 7E64h
.text$mn:00007E64 ; COMDAT (pick any)
.text$mn:00007E64                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007E64
.text$mn:00007E64 ; =============== S U B R O U T I N E =======================================
.text$mn:00007E64
.text$mn:00007E64 ; Attributes: bp-based frame
.text$mn:00007E64
.text$mn:00007E64 ; public: class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<int>>> & __thiscall std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<int>>>::operator=(class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<int>>> const &)
.text$mn:00007E64                 public ??4?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAEAAV01@ABV01@@Z
.text$mn:00007E64 ??4?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAEAAV01@ABV01@@Z proc near
.text$mn:00007E64                                         ; CODE XREF: std::remove_if<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::binder2nd<std::equal_to<int>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::binder2nd<std::equal_to<int>>)+9Bp
.text$mn:00007E64
.text$mn:00007E64 var_4           = dword ptr -4
.text$mn:00007E64 arg_0           = dword ptr  8
.text$mn:00007E64
.text$mn:00007E64                 push    ebp
.text$mn:00007E65                 mov     ebp, esp
.text$mn:00007E67                 push    ecx
.text$mn:00007E68                 mov     [ebp+var_4], ecx
.text$mn:00007E6B                 mov     eax, [ebp+arg_0]
.text$mn:00007E6E                 push    eax
.text$mn:00007E6F                 mov     ecx, [ebp+var_4]
.text$mn:00007E72                 call    ??4?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator=(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>> const &)
.text$mn:00007E77                 mov     eax, [ebp+var_4]
.text$mn:00007E7A                 mov     esp, ebp
.text$mn:00007E7C                 pop     ebp
.text$mn:00007E7D                 retn    4
.text$mn:00007E7D ??4?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAEAAV01@ABV01@@Z endp
.text$mn:00007E7D
.text$mn:00007E7D _text$mn        ends
.text$mn:00007E7D
.text$mn:00007E80 ; ===========================================================================
.text$mn:00007E80
.text$mn:00007E80 ; Segment type: Pure code
.text$mn:00007E80 ; Segment permissions: Read/Execute
.text$mn:00007E80 _text$mn        segment para public 'CODE' use32
.text$mn:00007E80                 assume cs:_text$mn
.text$mn:00007E80                 ;org 7E80h
.text$mn:00007E80 ; COMDAT (pick any)
.text$mn:00007E80                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007E80
.text$mn:00007E80 ; =============== S U B R O U T I N E =======================================
.text$mn:00007E80
.text$mn:00007E80 ; Attributes: bp-based frame
.text$mn:00007E80
.text$mn:00007E80 ; public: struct std::_Iterator_base12 & __thiscall std::_Iterator_base12::operator=(struct std::_Iterator_base12 const &)
.text$mn:00007E80                 public ??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z
.text$mn:00007E80 ??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z proc near
.text$mn:00007E80                                         ; CODE XREF: std::_Iterator_base12::_Iterator_base12(std::_Iterator_base12 const &)+21p
.text$mn:00007E80                                         ; std::_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>::operator=(std::_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12> const &)+Ep
.text$mn:00007E80
.text$mn:00007E80 var_14          = byte ptr -14h
.text$mn:00007E80 var_10          = dword ptr -10h
.text$mn:00007E80 var_C           = dword ptr -0Ch
.text$mn:00007E80 var_4           = dword ptr -4
.text$mn:00007E80 arg_0           = dword ptr  8
.text$mn:00007E80
.text$mn:00007E80                 push    ebp
.text$mn:00007E81                 mov     ebp, esp
.text$mn:00007E83                 push    0FFFFFFFFh
.text$mn:00007E85                 push    offset __ehhandler$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z
.text$mn:00007E8A                 mov     eax, large fs:0
.text$mn:00007E90                 push    eax
.text$mn:00007E91                 sub     esp, 8
.text$mn:00007E94                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00007E99                 xor     eax, ebp
.text$mn:00007E9B                 push    eax
.text$mn:00007E9C                 lea     eax, [ebp+var_C]
.text$mn:00007E9F                 mov     large fs:0, eax
.text$mn:00007EA5                 mov     [ebp+var_10], ecx
.text$mn:00007EA8                 mov     eax, [ebp+var_10]
.text$mn:00007EAB                 mov     ecx, [ebp+arg_0]
.text$mn:00007EAE                 mov     edx, [eax]
.text$mn:00007EB0                 cmp     edx, [ecx]
.text$mn:00007EB2                 jnz     short loc_7EB6
.text$mn:00007EB4                 jmp     short loc_7EF8
.text$mn:00007EB6 ; ---------------------------------------------------------------------------
.text$mn:00007EB6
.text$mn:00007EB6 loc_7EB6:                               ; CODE XREF: std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+32j
.text$mn:00007EB6                 mov     eax, [ebp+arg_0]
.text$mn:00007EB9                 cmp     dword ptr [eax], 0
.text$mn:00007EBC                 jz      short loc_7ED0
.text$mn:00007EBE                 mov     ecx, [ebp+arg_0]
.text$mn:00007EC1                 mov     edx, [ecx]
.text$mn:00007EC3                 mov     eax, [edx]
.text$mn:00007EC5                 push    eax             ; struct std::_Container_base12 *
.text$mn:00007EC6                 mov     ecx, [ebp+var_10] ; this
.text$mn:00007EC9                 call    ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt(std::_Container_base12 const *)
.text$mn:00007ECE                 jmp     short loc_7EF8
.text$mn:00007ED0 ; ---------------------------------------------------------------------------
.text$mn:00007ED0
.text$mn:00007ED0 loc_7ED0:                               ; CODE XREF: std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+3Cj
.text$mn:00007ED0                 push    3               ; int
.text$mn:00007ED2                 lea     ecx, [ebp+var_14] ; this
.text$mn:00007ED5                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:00007EDA                 mov     [ebp+var_4], 0
.text$mn:00007EE1                 mov     ecx, [ebp+var_10] ; this
.text$mn:00007EE4                 call    ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me(void)
.text$mn:00007EE9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00007EF0                 lea     ecx, [ebp+var_14] ; this
.text$mn:00007EF3                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:00007EF8
.text$mn:00007EF8 loc_7EF8:                               ; CODE XREF: std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+34j
.text$mn:00007EF8                                         ; std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+4Ej
.text$mn:00007EF8                 mov     eax, [ebp+var_10]
.text$mn:00007EFB                 mov     ecx, [ebp+var_C]
.text$mn:00007EFE                 mov     large fs:0, ecx
.text$mn:00007F05                 pop     ecx
.text$mn:00007F06                 mov     esp, ebp
.text$mn:00007F08                 pop     ebp
.text$mn:00007F09                 retn    4
.text$mn:00007F09 ??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z endp
.text$mn:00007F09
.text$mn:00007F09 _text$mn        ends
.text$mn:00007F09
.text$x:00007F0C ; ===========================================================================
.text$x:00007F0C
.text$x:00007F0C ; Segment type: Pure code
.text$x:00007F0C ; Segment permissions: Read/Execute
.text$x:00007F0C _text$x         segment para public 'CODE' use32
.text$x:00007F0C                 assume cs:_text$x
.text$x:00007F0C                 ;org 7F0Ch
.text$x:00007F0C ; COMDAT (pick associative to section at 7E80)
.text$x:00007F0C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00007F0C
.text$x:00007F0C ; =============== S U B R O U T I N E =======================================
.text$x:00007F0C
.text$x:00007F0C
.text$x:00007F0C __unwindfunclet$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z$0 proc near
.text$x:00007F0C                                         ; DATA XREF: .xdata$x:0000C564o
.text$x:00007F0C                 lea     ecx, [ebp-14h]  ; this
.text$x:00007F0F                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:00007F0F __unwindfunclet$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z$0 endp
.text$x:00007F0F
.text$x:00007F14
.text$x:00007F14 ; =============== S U B R O U T I N E =======================================
.text$x:00007F14
.text$x:00007F14
.text$x:00007F14 __ehhandler$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z proc near
.text$x:00007F14                                         ; DATA XREF: std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+5o
.text$x:00007F14
.text$x:00007F14 arg_4           = dword ptr  8
.text$x:00007F14
.text$x:00007F14                 mov     edx, [esp+arg_4]
.text$x:00007F18                 lea     eax, [edx+0Ch]
.text$x:00007F1B                 mov     ecx, [edx-0Ch]
.text$x:00007F1E                 xor     ecx, eax
.text$x:00007F20                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00007F25                 mov     eax, offset __ehfuncinfo$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z
.text$x:00007F2A                 jmp     ___CxxFrameHandler3
.text$x:00007F2A __ehhandler$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z endp
.text$x:00007F2A
.text$x:00007F2A ; ---------------------------------------------------------------------------
.text$x:00007F2F                 align 10h
.text$x:00007F2F _text$x         ends
.text$x:00007F2F
.text$mn:00007F30 ; ===========================================================================
.text$mn:00007F30
.text$mn:00007F30 ; Segment type: Pure code
.text$mn:00007F30 ; Segment permissions: Read/Execute
.text$mn:00007F30 _text$mn        segment para public 'CODE' use32
.text$mn:00007F30                 assume cs:_text$mn
.text$mn:00007F30                 ;org 7F30h
.text$mn:00007F30 ; COMDAT (pick any)
.text$mn:00007F30                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007F30
.text$mn:00007F30 ; =============== S U B R O U T I N E =======================================
.text$mn:00007F30
.text$mn:00007F30 ; Attributes: bp-based frame
.text$mn:00007F30
.text$mn:00007F30 ; int __stdcall std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator==(std::_Iterator_base12 *)
.text$mn:00007F30                 public ??8?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE_NABV01@@Z
.text$mn:00007F30 ??8?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE_NABV01@@Z proc near
.text$mn:00007F30                                         ; CODE XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator!=(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)+10p
.text$mn:00007F30
.text$mn:00007F30 var_8           = dword ptr -8
.text$mn:00007F30 var_4           = dword ptr -4
.text$mn:00007F30 arg_0           = dword ptr  8
.text$mn:00007F30
.text$mn:00007F30                 push    ebp
.text$mn:00007F31                 mov     ebp, esp
.text$mn:00007F33                 sub     esp, 8
.text$mn:00007F36                 mov     [ebp+var_4], ecx
.text$mn:00007F39                 mov     eax, [ebp+arg_0]
.text$mn:00007F3C                 push    eax             ; std::_Iterator_base12 *
.text$mn:00007F3D                 mov     ecx, [ebp+var_4]
.text$mn:00007F40                 call    ?_Compat@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEXABV12@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_Compat(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:00007F45                 mov     ecx, [ebp+var_4]
.text$mn:00007F48                 mov     edx, [ebp+arg_0]
.text$mn:00007F4B                 mov     eax, [ecx+8]
.text$mn:00007F4E                 cmp     eax, [edx+8]
.text$mn:00007F51                 jnz     short loc_7F5C
.text$mn:00007F53                 mov     [ebp+var_8], 1
.text$mn:00007F5A                 jmp     short loc_7F63
.text$mn:00007F5C ; ---------------------------------------------------------------------------
.text$mn:00007F5C
.text$mn:00007F5C loc_7F5C:                               ; CODE XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator==(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)+21j
.text$mn:00007F5C                 mov     [ebp+var_8], 0
.text$mn:00007F63
.text$mn:00007F63 loc_7F63:                               ; CODE XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator==(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)+2Aj
.text$mn:00007F63                 mov     al, byte ptr [ebp+var_8]
.text$mn:00007F66                 mov     esp, ebp
.text$mn:00007F68                 pop     ebp
.text$mn:00007F69                 retn    4
.text$mn:00007F69 ??8?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE_NABV01@@Z endp
.text$mn:00007F69
.text$mn:00007F69 _text$mn        ends
.text$mn:00007F69
.text$mn:00007F6C ; ===========================================================================
.text$mn:00007F6C
.text$mn:00007F6C ; Segment type: Pure code
.text$mn:00007F6C ; Segment permissions: Read/Execute
.text$mn:00007F6C _text$mn        segment para public 'CODE' use32
.text$mn:00007F6C                 assume cs:_text$mn
.text$mn:00007F6C                 ;org 7F6Ch
.text$mn:00007F6C ; COMDAT (pick any)
.text$mn:00007F6C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007F6C
.text$mn:00007F6C ; =============== S U B R O U T I N E =======================================
.text$mn:00007F6C
.text$mn:00007F6C ; Attributes: bp-based frame
.text$mn:00007F6C
.text$mn:00007F6C ; int __stdcall std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator==(std::_Iterator_base12 *)
.text$mn:00007F6C                 public ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBE_NABV01@@Z
.text$mn:00007F6C ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBE_NABV01@@Z proc near
.text$mn:00007F6C                                         ; CODE XREF: std::remove_if<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::binder2nd<std::equal_to<int>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::binder2nd<std::equal_to<int>>)+B3p
.text$mn:00007F6C                                         ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator!=(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>> const &)+10p ...
.text$mn:00007F6C
.text$mn:00007F6C var_8           = dword ptr -8
.text$mn:00007F6C var_4           = dword ptr -4
.text$mn:00007F6C arg_0           = dword ptr  8
.text$mn:00007F6C
.text$mn:00007F6C                 push    ebp
.text$mn:00007F6D                 mov     ebp, esp
.text$mn:00007F6F                 sub     esp, 8
.text$mn:00007F72                 mov     [ebp+var_4], ecx
.text$mn:00007F75                 mov     eax, [ebp+arg_0]
.text$mn:00007F78                 push    eax             ; std::_Iterator_base12 *
.text$mn:00007F79                 mov     ecx, [ebp+var_4]
.text$mn:00007F7C                 call    ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Compat(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>> const &)
.text$mn:00007F81                 mov     ecx, [ebp+var_4]
.text$mn:00007F84                 mov     edx, [ebp+arg_0]
.text$mn:00007F87                 mov     eax, [ecx+8]
.text$mn:00007F8A                 cmp     eax, [edx+8]
.text$mn:00007F8D                 jnz     short loc_7F98
.text$mn:00007F8F                 mov     [ebp+var_8], 1
.text$mn:00007F96                 jmp     short loc_7F9F
.text$mn:00007F98 ; ---------------------------------------------------------------------------
.text$mn:00007F98
.text$mn:00007F98 loc_7F98:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator==(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>> const &)+21j
.text$mn:00007F98                 mov     [ebp+var_8], 0
.text$mn:00007F9F
.text$mn:00007F9F loc_7F9F:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator==(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>> const &)+2Aj
.text$mn:00007F9F                 mov     al, byte ptr [ebp+var_8]
.text$mn:00007FA2                 mov     esp, ebp
.text$mn:00007FA4                 pop     ebp
.text$mn:00007FA5                 retn    4
.text$mn:00007FA5 ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBE_NABV01@@Z endp
.text$mn:00007FA5
.text$mn:00007FA5 _text$mn        ends
.text$mn:00007FA5
.text$mn:00007FA8 ; ===========================================================================
.text$mn:00007FA8
.text$mn:00007FA8 ; Segment type: Pure code
.text$mn:00007FA8 ; Segment permissions: Read/Execute
.text$mn:00007FA8 _text$mn        segment para public 'CODE' use32
.text$mn:00007FA8                 assume cs:_text$mn
.text$mn:00007FA8                 ;org 7FA8h
.text$mn:00007FA8 ; COMDAT (pick any)
.text$mn:00007FA8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007FA8
.text$mn:00007FA8 ; =============== S U B R O U T I N E =======================================
.text$mn:00007FA8
.text$mn:00007FA8 ; Attributes: bp-based frame
.text$mn:00007FA8
.text$mn:00007FA8 ; public: bool __thiscall std::error_category::operator==(class std::error_category const &)const
.text$mn:00007FA8                 public ??8error_category@std@@QBE_NABV01@@Z
.text$mn:00007FA8 ??8error_category@std@@QBE_NABV01@@Z proc near
.text$mn:00007FA8                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+1Dp
.text$mn:00007FA8                                         ; std::error_category::equivalent(std::error_code const &,int)+15p
.text$mn:00007FA8
.text$mn:00007FA8 var_8           = dword ptr -8
.text$mn:00007FA8 var_4           = dword ptr -4
.text$mn:00007FA8 arg_0           = dword ptr  8
.text$mn:00007FA8
.text$mn:00007FA8                 push    ebp
.text$mn:00007FA9                 mov     ebp, esp
.text$mn:00007FAB                 sub     esp, 8
.text$mn:00007FAE                 mov     [ebp+var_8], ecx
.text$mn:00007FB1                 mov     eax, [ebp+var_8]
.text$mn:00007FB4                 cmp     eax, [ebp+arg_0]
.text$mn:00007FB7                 jnz     short loc_7FC2
.text$mn:00007FB9                 mov     [ebp+var_4], 1
.text$mn:00007FC0                 jmp     short loc_7FC9
.text$mn:00007FC2 ; ---------------------------------------------------------------------------
.text$mn:00007FC2
.text$mn:00007FC2 loc_7FC2:                               ; CODE XREF: std::error_category::operator==(std::error_category const &)+Fj
.text$mn:00007FC2                 mov     [ebp+var_4], 0
.text$mn:00007FC9
.text$mn:00007FC9 loc_7FC9:                               ; CODE XREF: std::error_category::operator==(std::error_category const &)+18j
.text$mn:00007FC9                 mov     al, byte ptr [ebp+var_4]
.text$mn:00007FCC                 mov     esp, ebp
.text$mn:00007FCE                 pop     ebp
.text$mn:00007FCF                 retn    4
.text$mn:00007FCF ??8error_category@std@@QBE_NABV01@@Z endp
.text$mn:00007FCF
.text$mn:00007FCF ; ---------------------------------------------------------------------------
.text$mn:00007FD2                 align 4
.text$mn:00007FD2 _text$mn        ends
.text$mn:00007FD2
.text$mn:00007FD4 ; ===========================================================================
.text$mn:00007FD4
.text$mn:00007FD4 ; Segment type: Pure code
.text$mn:00007FD4 ; Segment permissions: Read/Execute
.text$mn:00007FD4 _text$mn        segment para public 'CODE' use32
.text$mn:00007FD4                 assume cs:_text$mn
.text$mn:00007FD4                 ;org 7FD4h
.text$mn:00007FD4 ; COMDAT (pick any)
.text$mn:00007FD4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007FD4
.text$mn:00007FD4 ; =============== S U B R O U T I N E =======================================
.text$mn:00007FD4
.text$mn:00007FD4 ; Attributes: bp-based frame
.text$mn:00007FD4
.text$mn:00007FD4 ; int __stdcall std::error_condition::operator==(std::error_condition *)
.text$mn:00007FD4                 public ??8error_condition@std@@QBE_NABV01@@Z
.text$mn:00007FD4 ??8error_condition@std@@QBE_NABV01@@Z proc near
.text$mn:00007FD4                                         ; CODE XREF: std::error_category::equivalent(int,std::error_condition const &)+24p
.text$mn:00007FD4
.text$mn:00007FD4 var_8           = dword ptr -8
.text$mn:00007FD4 var_4           = dword ptr -4
.text$mn:00007FD4 arg_0           = dword ptr  8
.text$mn:00007FD4
.text$mn:00007FD4                 push    ebp
.text$mn:00007FD5                 mov     ebp, esp
.text$mn:00007FD7                 sub     esp, 8
.text$mn:00007FDA                 push    esi
.text$mn:00007FDB                 mov     [ebp+var_4], ecx
.text$mn:00007FDE                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00007FE1                 call    ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
.text$mn:00007FE6                 push    eax
.text$mn:00007FE7                 mov     ecx, [ebp+var_4] ; this
.text$mn:00007FEA                 call    ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
.text$mn:00007FEF                 mov     ecx, eax
.text$mn:00007FF1                 call    ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
.text$mn:00007FF6                 movzx   eax, al
.text$mn:00007FF9                 test    eax, eax
.text$mn:00007FFB                 jz      short loc_801C
.text$mn:00007FFD                 mov     ecx, [ebp+var_4] ; this
.text$mn:00008000                 call    ?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
.text$mn:00008005                 mov     esi, eax
.text$mn:00008007                 mov     ecx, [ebp+arg_0] ; this
.text$mn:0000800A                 call    ?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
.text$mn:0000800F                 cmp     esi, eax
.text$mn:00008011                 jnz     short loc_801C
.text$mn:00008013                 mov     [ebp+var_8], 1
.text$mn:0000801A                 jmp     short loc_8023
.text$mn:0000801C ; ---------------------------------------------------------------------------
.text$mn:0000801C
.text$mn:0000801C loc_801C:                               ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+27j
.text$mn:0000801C                                         ; std::error_condition::operator==(std::error_condition const &)+3Dj
.text$mn:0000801C                 mov     [ebp+var_8], 0
.text$mn:00008023
.text$mn:00008023 loc_8023:                               ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+46j
.text$mn:00008023                 mov     al, byte ptr [ebp+var_8]
.text$mn:00008026                 pop     esi
.text$mn:00008027                 mov     esp, ebp
.text$mn:00008029                 pop     ebp
.text$mn:0000802A                 retn    4
.text$mn:0000802A ??8error_condition@std@@QBE_NABV01@@Z endp
.text$mn:0000802A
.text$mn:0000802A ; ---------------------------------------------------------------------------
.text$mn:0000802D                 align 10h
.text$mn:0000802D _text$mn        ends
.text$mn:0000802D
.text$mn:00008030 ; ===========================================================================
.text$mn:00008030
.text$mn:00008030 ; Segment type: Pure code
.text$mn:00008030 ; Segment permissions: Read/Execute
.text$mn:00008030 _text$mn        segment para public 'CODE' use32
.text$mn:00008030                 assume cs:_text$mn
.text$mn:00008030                 ;org 8030h
.text$mn:00008030 ; COMDAT (pick any)
.text$mn:00008030                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008030
.text$mn:00008030 ; =============== S U B R O U T I N E =======================================
.text$mn:00008030
.text$mn:00008030 ; Attributes: bp-based frame
.text$mn:00008030
.text$mn:00008030 ; int __stdcall std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator!=(std::_Iterator_base12 *)
.text$mn:00008030                 public ??9?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE_NABV01@@Z
.text$mn:00008030 ??9?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE_NABV01@@Z proc near
.text$mn:00008030                                         ; CODE XREF: std::_Distance2<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,int>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,int &,std::random_access_iterator_tag)+30p
.text$mn:00008030
.text$mn:00008030 var_8           = dword ptr -8
.text$mn:00008030 var_4           = dword ptr -4
.text$mn:00008030 arg_0           = dword ptr  8
.text$mn:00008030
.text$mn:00008030                 push    ebp
.text$mn:00008031                 mov     ebp, esp
.text$mn:00008033                 sub     esp, 8
.text$mn:00008036                 mov     [ebp+var_8], ecx
.text$mn:00008039                 mov     eax, [ebp+arg_0]
.text$mn:0000803C                 push    eax             ; std::_Iterator_base12 *
.text$mn:0000803D                 mov     ecx, [ebp+var_8]
.text$mn:00008040                 call    ??8?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE_NABV01@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator==(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:00008045                 movzx   ecx, al
.text$mn:00008048                 test    ecx, ecx
.text$mn:0000804A                 jnz     short loc_8055
.text$mn:0000804C                 mov     [ebp+var_4], 1
.text$mn:00008053                 jmp     short loc_805C
.text$mn:00008055 ; ---------------------------------------------------------------------------
.text$mn:00008055
.text$mn:00008055 loc_8055:                               ; CODE XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator!=(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)+1Aj
.text$mn:00008055                 mov     [ebp+var_4], 0
.text$mn:0000805C
.text$mn:0000805C loc_805C:                               ; CODE XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator!=(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)+23j
.text$mn:0000805C                 mov     al, byte ptr [ebp+var_4]
.text$mn:0000805F                 mov     esp, ebp
.text$mn:00008061                 pop     ebp
.text$mn:00008062                 retn    4
.text$mn:00008062 ??9?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE_NABV01@@Z endp
.text$mn:00008062
.text$mn:00008062 ; ---------------------------------------------------------------------------
.text$mn:00008065                 align 4
.text$mn:00008065 _text$mn        ends
.text$mn:00008065
.text$mn:00008068 ; ===========================================================================
.text$mn:00008068
.text$mn:00008068 ; Segment type: Pure code
.text$mn:00008068 ; Segment permissions: Read/Execute
.text$mn:00008068 _text$mn        segment para public 'CODE' use32
.text$mn:00008068                 assume cs:_text$mn
.text$mn:00008068                 ;org 8068h
.text$mn:00008068 ; COMDAT (pick any)
.text$mn:00008068                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008068
.text$mn:00008068 ; =============== S U B R O U T I N E =======================================
.text$mn:00008068
.text$mn:00008068 ; Attributes: bp-based frame
.text$mn:00008068
.text$mn:00008068 ; int __stdcall std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator!=(std::_Iterator_base12 *)
.text$mn:00008068                 public ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBE_NABV01@@Z
.text$mn:00008068 ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBE_NABV01@@Z proc near
.text$mn:00008068                                         ; CODE XREF: WindowsDlg::resetSelection(void)+83p
.text$mn:00008068                                         ; WindowsDlg::doClose(void)+28Dp ...
.text$mn:00008068
.text$mn:00008068 var_8           = dword ptr -8
.text$mn:00008068 var_4           = dword ptr -4
.text$mn:00008068 arg_0           = dword ptr  8
.text$mn:00008068
.text$mn:00008068                 push    ebp
.text$mn:00008069                 mov     ebp, esp
.text$mn:0000806B                 sub     esp, 8
.text$mn:0000806E                 mov     [ebp+var_8], ecx
.text$mn:00008071                 mov     eax, [ebp+arg_0]
.text$mn:00008074                 push    eax             ; std::_Iterator_base12 *
.text$mn:00008075                 mov     ecx, [ebp+var_8]
.text$mn:00008078                 call    ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator==(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>> const &)
.text$mn:0000807D                 movzx   ecx, al
.text$mn:00008080                 test    ecx, ecx
.text$mn:00008082                 jnz     short loc_808D
.text$mn:00008084                 mov     [ebp+var_4], 1
.text$mn:0000808B                 jmp     short loc_8094
.text$mn:0000808D ; ---------------------------------------------------------------------------
.text$mn:0000808D
.text$mn:0000808D loc_808D:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator!=(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>> const &)+1Aj
.text$mn:0000808D                 mov     [ebp+var_4], 0
.text$mn:00008094
.text$mn:00008094 loc_8094:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator!=(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>> const &)+23j
.text$mn:00008094                 mov     al, byte ptr [ebp+var_4]
.text$mn:00008097                 mov     esp, ebp
.text$mn:00008099                 pop     ebp
.text$mn:0000809A                 retn    4
.text$mn:0000809A ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBE_NABV01@@Z endp
.text$mn:0000809A
.text$mn:0000809A ; ---------------------------------------------------------------------------
.text$mn:0000809D                 align 10h
.text$mn:0000809D _text$mn        ends
.text$mn:0000809D
.text$mn:000080A0 ; ===========================================================================
.text$mn:000080A0
.text$mn:000080A0 ; Segment type: Pure code
.text$mn:000080A0 ; Segment permissions: Read/Execute
.text$mn:000080A0 _text$mn        segment para public 'CODE' use32
.text$mn:000080A0                 assume cs:_text$mn
.text$mn:000080A0                 ;org 80A0h
.text$mn:000080A0 ; COMDAT (pick any)
.text$mn:000080A0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000080A0
.text$mn:000080A0 ; =============== S U B R O U T I N E =======================================
.text$mn:000080A0
.text$mn:000080A0 ; Attributes: bp-based frame
.text$mn:000080A0
.text$mn:000080A0 ; public: int & __thiscall std::vector<int, class std::allocator<int>>::operator[](unsigned int)
.text$mn:000080A0                 public ??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z
.text$mn:000080A0 ??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z proc near
.text$mn:000080A0                                         ; CODE XREF: WindowsDlg::doRefresh(bool)+D3p
.text$mn:000080A0                                         ; WindowsDlg::run_dlgProc(uint,uint,long)+1CFp ...
.text$mn:000080A0
.text$mn:000080A0 var_4           = dword ptr -4
.text$mn:000080A0 arg_0           = dword ptr  8
.text$mn:000080A0
.text$mn:000080A0                 push    ebp
.text$mn:000080A1                 mov     ebp, esp
.text$mn:000080A3                 push    ecx
.text$mn:000080A4                 mov     [ebp+var_4], ecx
.text$mn:000080A7                 mov     ecx, [ebp+var_4]
.text$mn:000080AA                 call    ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int>>::size(void)
.text$mn:000080AF                 cmp     eax, [ebp+arg_0]
.text$mn:000080B2                 ja      short loc_811C
.text$mn:000080B4                 push    4B1h            ; unsigned int
.text$mn:000080B9                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000080BE                 push    offset ??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "vector subscript out of range"
.text$mn:000080C3                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:000080C8                 add     esp, 0Ch
.text$mn:000080CB                 mov     eax, offset ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ ; "Standard C++ Libraries Out of Range"
.text$mn:000080D0                 test    eax, eax
.text$mn:000080D2                 jz      short loc_80D8
.text$mn:000080D4                 xor     ecx, ecx
.text$mn:000080D6                 jnz     short loc_80FE
.text$mn:000080D8
.text$mn:000080D8 loc_80D8:                               ; CODE XREF: std::vector<int,std::allocator<int>>::operator[](uint)+32j
.text$mn:000080D8                 push    offset ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@ ; "\"Standard C++ Libraries Out of Range\""...
.text$mn:000080DD                 push    offset ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ ; "%s"
.text$mn:000080E2                 push    0
.text$mn:000080E4                 push    4B2h
.text$mn:000080E9                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000080EE                 push    2
.text$mn:000080F0                 call    __CrtDbgReportW
.text$mn:000080F5                 add     esp, 18h
.text$mn:000080F8                 cmp     eax, 1
.text$mn:000080FB                 jnz     short loc_80FE
.text$mn:000080FD                 int     3               ; Trap to Debugger
.text$mn:000080FE
.text$mn:000080FE loc_80FE:                               ; CODE XREF: std::vector<int,std::allocator<int>>::operator[](uint)+36j
.text$mn:000080FE                                         ; std::vector<int,std::allocator<int>>::operator[](uint)+5Bj
.text$mn:000080FE                 push    0
.text$mn:00008100                 push    4B2h
.text$mn:00008105                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000810A                 push    offset ??_C@_1HC@HBCEAHKD@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAi?$AAn?$AAt?$AA?0?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAa?$AAl?$AAl?$AAo?$AAc@ ; "std::vector<int,class std::allocator<in"...
.text$mn:0000810F                 push    offset ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@ ; "\"out of range\""
.text$mn:00008114                 call    __invalid_parameter
.text$mn:00008119                 add     esp, 14h
.text$mn:0000811C
.text$mn:0000811C loc_811C:                               ; CODE XREF: std::vector<int,std::allocator<int>>::operator[](uint)+12j
.text$mn:0000811C                 mov     eax, [ebp+var_4]
.text$mn:0000811F                 mov     ecx, [eax+4]
.text$mn:00008122                 mov     edx, [ebp+arg_0]
.text$mn:00008125                 lea     eax, [ecx+edx*4]
.text$mn:00008128                 mov     esp, ebp
.text$mn:0000812A                 pop     ebp
.text$mn:0000812B                 retn    4
.text$mn:0000812B ??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z endp
.text$mn:0000812B
.text$mn:0000812B ; ---------------------------------------------------------------------------
.text$mn:0000812E                 align 10h
.text$mn:0000812E _text$mn        ends
.text$mn:0000812E
.text$mn:00008130 ; ===========================================================================
.text$mn:00008130
.text$mn:00008130 ; Segment type: Pure code
.text$mn:00008130 ; Segment permissions: Read/Execute
.text$mn:00008130 _text$mn        segment para public 'CODE' use32
.text$mn:00008130                 assume cs:_text$mn
.text$mn:00008130                 ;org 8130h
.text$mn:00008130 ; COMDAT (pick any)
.text$mn:00008130                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008130
.text$mn:00008130 ; =============== S U B R O U T I N E =======================================
.text$mn:00008130
.text$mn:00008130 ; Attributes: bp-based frame
.text$mn:00008130
.text$mn:00008130 ; public: wchar_t & __thiscall std::vector<wchar_t, class std::allocator<wchar_t>>::operator[](unsigned int)
.text$mn:00008130                 public ??A?$vector@_WV?$allocator@_W@std@@@std@@QAEAA_WI@Z
.text$mn:00008130 ??A?$vector@_WV?$allocator@_W@std@@@std@@QAEAA_WI@Z proc near
.text$mn:00008130                                         ; CODE XREF: WindowsMenu::initPopupMenu(HMENU__ *,DocTabView *)+1A7p
.text$mn:00008130
.text$mn:00008130 var_4           = dword ptr -4
.text$mn:00008130 arg_0           = dword ptr  8
.text$mn:00008130
.text$mn:00008130                 push    ebp
.text$mn:00008131                 mov     ebp, esp
.text$mn:00008133                 push    ecx
.text$mn:00008134                 mov     [ebp+var_4], ecx
.text$mn:00008137                 mov     ecx, [ebp+var_4]
.text$mn:0000813A                 call    ?size@?$vector@_WV?$allocator@_W@std@@@std@@QBEIXZ ; std::vector<wchar_t,std::allocator<wchar_t>>::size(void)
.text$mn:0000813F                 cmp     eax, [ebp+arg_0]
.text$mn:00008142                 ja      short loc_81AC
.text$mn:00008144                 push    4B1h            ; unsigned int
.text$mn:00008149                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000814E                 push    offset ??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "vector subscript out of range"
.text$mn:00008153                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00008158                 add     esp, 0Ch
.text$mn:0000815B                 mov     eax, offset ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ ; "Standard C++ Libraries Out of Range"
.text$mn:00008160                 test    eax, eax
.text$mn:00008162                 jz      short loc_8168
.text$mn:00008164                 xor     ecx, ecx
.text$mn:00008166                 jnz     short loc_818E
.text$mn:00008168
.text$mn:00008168 loc_8168:                               ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::operator[](uint)+32j
.text$mn:00008168                 push    offset ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@ ; "\"Standard C++ Libraries Out of Range\""...
.text$mn:0000816D                 push    offset ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ ; "%s"
.text$mn:00008172                 push    0
.text$mn:00008174                 push    4B2h
.text$mn:00008179                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000817E                 push    2
.text$mn:00008180                 call    __CrtDbgReportW
.text$mn:00008185                 add     esp, 18h
.text$mn:00008188                 cmp     eax, 1
.text$mn:0000818B                 jnz     short loc_818E
.text$mn:0000818D                 int     3               ; Trap to Debugger
.text$mn:0000818E
.text$mn:0000818E loc_818E:                               ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::operator[](uint)+36j
.text$mn:0000818E                                         ; std::vector<wchar_t,std::allocator<wchar_t>>::operator[](uint)+5Bj
.text$mn:0000818E                 push    0
.text$mn:00008190                 push    4B2h
.text$mn:00008195                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000819A                 push    offset ??_C@_1IC@MBIJKJB@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAw?$AAc?$AAh?$AAa?$AAr?$AA_?$AAt?$AA?0?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAa@ ; "std::vector<wchar_t,class std::allocato"...
.text$mn:0000819F                 push    offset ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@ ; "\"out of range\""
.text$mn:000081A4                 call    __invalid_parameter
.text$mn:000081A9                 add     esp, 14h
.text$mn:000081AC
.text$mn:000081AC loc_81AC:                               ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::operator[](uint)+12j
.text$mn:000081AC                 mov     eax, [ebp+var_4]
.text$mn:000081AF                 mov     ecx, [eax+4]
.text$mn:000081B2                 mov     edx, [ebp+arg_0]
.text$mn:000081B5                 lea     eax, [ecx+edx*2]
.text$mn:000081B8                 mov     esp, ebp
.text$mn:000081BA                 pop     ebp
.text$mn:000081BB                 retn    4
.text$mn:000081BB ??A?$vector@_WV?$allocator@_W@std@@@std@@QAEAA_WI@Z endp
.text$mn:000081BB
.text$mn:000081BB ; ---------------------------------------------------------------------------
.text$mn:000081BE                 align 10h
.text$mn:000081BE _text$mn        ends
.text$mn:000081BE
.text$mn:000081C0 ; ===========================================================================
.text$mn:000081C0
.text$mn:000081C0 ; Segment type: Pure code
.text$mn:000081C0 ; Segment permissions: Read/Execute
.text$mn:000081C0 _text$mn        segment para public 'CODE' use32
.text$mn:000081C0                 assume cs:_text$mn
.text$mn:000081C0                 ;org 81C0h
.text$mn:000081C0 ; COMDAT (pick any)
.text$mn:000081C0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000081C0
.text$mn:000081C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000081C0
.text$mn:000081C0 ; Attributes: bp-based frame
.text$mn:000081C0
.text$mn:000081C0 ; public: class std::_Temp_iterator<int> & __thiscall std::_Temp_iterator<int>::operator*(void)
.text$mn:000081C0                 public ??D?$_Temp_iterator@H@std@@QAEAAV01@XZ
.text$mn:000081C0 ??D?$_Temp_iterator@H@std@@QAEAAV01@XZ proc near
.text$mn:000081C0                                         ; CODE XREF: std::_Merge<int *,int *,std::_Temp_iterator<int>,BufferEquivalent>(int *,int *,int *,int *,std::_Temp_iterator<int>,BufferEquivalent)+ADp
.text$mn:000081C0                                         ; std::_Merge<int *,int *,std::_Temp_iterator<int>,BufferEquivalent>(int *,int *,int *,int *,std::_Temp_iterator<int>,BufferEquivalent)+F3p ...
.text$mn:000081C0
.text$mn:000081C0 var_4           = dword ptr -4
.text$mn:000081C0
.text$mn:000081C0                 push    ebp
.text$mn:000081C1                 mov     ebp, esp
.text$mn:000081C3                 push    ecx
.text$mn:000081C4                 mov     [ebp+var_4], ecx
.text$mn:000081C7                 mov     eax, [ebp+var_4]
.text$mn:000081CA                 mov     esp, ebp
.text$mn:000081CC                 pop     ebp
.text$mn:000081CD                 retn
.text$mn:000081CD ??D?$_Temp_iterator@H@std@@QAEAAV01@XZ endp
.text$mn:000081CD
.text$mn:000081CD ; ---------------------------------------------------------------------------
.text$mn:000081CE                 align 10h
.text$mn:000081CE _text$mn        ends
.text$mn:000081CE
.text$mn:000081D0 ; ===========================================================================
.text$mn:000081D0
.text$mn:000081D0 ; Segment type: Pure code
.text$mn:000081D0 ; Segment permissions: Read/Execute
.text$mn:000081D0 _text$mn        segment para public 'CODE' use32
.text$mn:000081D0                 assume cs:_text$mn
.text$mn:000081D0                 ;org 81D0h
.text$mn:000081D0 ; COMDAT (pick any)
.text$mn:000081D0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000081D0
.text$mn:000081D0 ; =============== S U B R O U T I N E =======================================
.text$mn:000081D0
.text$mn:000081D0 ; Attributes: bp-based frame
.text$mn:000081D0
.text$mn:000081D0 ; public: int const & __thiscall std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<int>>>::operator*(void)const
.text$mn:000081D0                 public ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBEABHXZ
.text$mn:000081D0 ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBEABHXZ proc near
.text$mn:000081D0                                         ; CODE XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator*(void)+Ap
.text$mn:000081D0
.text$mn:000081D0 var_4           = dword ptr -4
.text$mn:000081D0
.text$mn:000081D0                 push    ebp
.text$mn:000081D1                 mov     ebp, esp
.text$mn:000081D3                 push    ecx
.text$mn:000081D4                 mov     [ebp+var_4], ecx
.text$mn:000081D7                 mov     ecx, [ebp+var_4] ; this
.text$mn:000081DA                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:000081DF                 test    eax, eax
.text$mn:000081E1                 jz      short loc_8212
.text$mn:000081E3                 mov     eax, [ebp+var_4]
.text$mn:000081E6                 cmp     dword ptr [eax+8], 0
.text$mn:000081EA                 jz      short loc_8212
.text$mn:000081EC                 mov     ecx, [ebp+var_4] ; this
.text$mn:000081EF                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:000081F4                 mov     ecx, [ebp+var_4]
.text$mn:000081F7                 mov     edx, [ecx+8]
.text$mn:000081FA                 cmp     edx, [eax+4]
.text$mn:000081FD                 jb      short loc_8212
.text$mn:000081FF                 mov     ecx, [ebp+var_4] ; this
.text$mn:00008202                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:00008207                 mov     ecx, [ebp+var_4]
.text$mn:0000820A                 mov     edx, [eax+8]
.text$mn:0000820D                 cmp     edx, [ecx+8]
.text$mn:00008210                 ja      short loc_8271
.text$mn:00008212
.text$mn:00008212 loc_8212:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator*(void)+11j
.text$mn:00008212                                         ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator*(void)+1Aj ...
.text$mn:00008212                 push    48h ; 'H'       ; unsigned int
.text$mn:00008214                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00008219                 push    offset ??_C@_1EG@FOHJJHAC@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAa?$AAb@ ; "vector iterator not dereferencable"
.text$mn:0000821E                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00008223                 add     esp, 0Ch
.text$mn:00008226                 mov     eax, offset ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ ; "Standard C++ Libraries Out of Range"
.text$mn:0000822B                 test    eax, eax
.text$mn:0000822D                 jz      short loc_8233
.text$mn:0000822F                 xor     ecx, ecx
.text$mn:00008231                 jnz     short loc_8256
.text$mn:00008233
.text$mn:00008233 loc_8233:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator*(void)+5Dj
.text$mn:00008233                 push    offset ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@ ; "\"Standard C++ Libraries Out of Range\""...
.text$mn:00008238                 push    offset ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ ; "%s"
.text$mn:0000823D                 push    0
.text$mn:0000823F                 push    49h ; 'I'
.text$mn:00008241                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00008246                 push    2
.text$mn:00008248                 call    __CrtDbgReportW
.text$mn:0000824D                 add     esp, 18h
.text$mn:00008250                 cmp     eax, 1
.text$mn:00008253                 jnz     short loc_8256
.text$mn:00008255                 int     3               ; Trap to Debugger
.text$mn:00008256
.text$mn:00008256 loc_8256:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator*(void)+61j
.text$mn:00008256                                         ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator*(void)+83j
.text$mn:00008256                 push    0
.text$mn:00008258                 push    49h ; 'I'
.text$mn:0000825A                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000825F                 push    offset ??_C@_1ME@LLCFNFIO@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ ; "std::_Vector_const_iterator<class std::"...
.text$mn:00008264                 push    offset ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@ ; "\"out of range\""
.text$mn:00008269                 call    __invalid_parameter
.text$mn:0000826E                 add     esp, 14h
.text$mn:00008271
.text$mn:00008271 loc_8271:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator*(void)+40j
.text$mn:00008271                 mov     eax, [ebp+var_4]
.text$mn:00008274                 mov     eax, [eax+8]
.text$mn:00008277                 mov     esp, ebp
.text$mn:00008279                 pop     ebp
.text$mn:0000827A                 retn
.text$mn:0000827A ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBEABHXZ endp
.text$mn:0000827A
.text$mn:0000827A ; ---------------------------------------------------------------------------
.text$mn:0000827B                 align 4
.text$mn:0000827B _text$mn        ends
.text$mn:0000827B
.text$mn:0000827C ; ===========================================================================
.text$mn:0000827C
.text$mn:0000827C ; Segment type: Pure code
.text$mn:0000827C ; Segment permissions: Read/Execute
.text$mn:0000827C _text$mn        segment para public 'CODE' use32
.text$mn:0000827C                 assume cs:_text$mn
.text$mn:0000827C                 ;org 827Ch
.text$mn:0000827C ; COMDAT (pick any)
.text$mn:0000827C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000827C
.text$mn:0000827C ; =============== S U B R O U T I N E =======================================
.text$mn:0000827C
.text$mn:0000827C ; Attributes: bp-based frame
.text$mn:0000827C
.text$mn:0000827C ; public: int & __thiscall std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<int>>>::operator*(void)const
.text$mn:0000827C                 public ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBEAAHXZ
.text$mn:0000827C ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBEAAHXZ proc near
.text$mn:0000827C                                         ; CODE XREF: WindowsDlg::resetSelection(void)+92p
.text$mn:0000827C                                         ; WindowsDlg::doClose(void)+219p ...
.text$mn:0000827C
.text$mn:0000827C var_4           = dword ptr -4
.text$mn:0000827C
.text$mn:0000827C                 push    ebp
.text$mn:0000827D                 mov     ebp, esp
.text$mn:0000827F                 push    ecx
.text$mn:00008280                 mov     [ebp+var_4], ecx
.text$mn:00008283                 mov     ecx, [ebp+var_4]
.text$mn:00008286                 call    ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBEABHXZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator*(void)
.text$mn:0000828B                 mov     esp, ebp
.text$mn:0000828D                 pop     ebp
.text$mn:0000828E                 retn
.text$mn:0000828E ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBEAAHXZ endp
.text$mn:0000828E
.text$mn:0000828E ; ---------------------------------------------------------------------------
.text$mn:0000828F                 align 10h
.text$mn:0000828F _text$mn        ends
.text$mn:0000828F
.text$mn:00008290 ; ===========================================================================
.text$mn:00008290
.text$mn:00008290 ; Segment type: Pure code
.text$mn:00008290 ; Segment permissions: Read/Execute
.text$mn:00008290 _text$mn        segment para public 'CODE' use32
.text$mn:00008290                 assume cs:_text$mn
.text$mn:00008290                 ;org 8290h
.text$mn:00008290 ; COMDAT (pick any)
.text$mn:00008290                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008290
.text$mn:00008290 ; =============== S U B R O U T I N E =======================================
.text$mn:00008290
.text$mn:00008290 ; Attributes: bp-based frame
.text$mn:00008290
.text$mn:00008290 ; public: class std::_Temp_iterator<int> & __thiscall std::_Temp_iterator<int>::operator++(int)
.text$mn:00008290                 public ??E?$_Temp_iterator@H@std@@QAEAAV01@H@Z
.text$mn:00008290 ??E?$_Temp_iterator@H@std@@QAEAAV01@H@Z proc near
.text$mn:00008290                                         ; CODE XREF: std::_Merge<int *,int *,std::_Temp_iterator<int>,BufferEquivalent>(int *,int *,int *,int *,std::_Temp_iterator<int>,BufferEquivalent)+A6p
.text$mn:00008290                                         ; std::_Merge<int *,int *,std::_Temp_iterator<int>,BufferEquivalent>(int *,int *,int *,int *,std::_Temp_iterator<int>,BufferEquivalent)+ECp
.text$mn:00008290
.text$mn:00008290 var_4           = dword ptr -4
.text$mn:00008290
.text$mn:00008290                 push    ebp
.text$mn:00008291                 mov     ebp, esp
.text$mn:00008293                 push    ecx
.text$mn:00008294                 mov     [ebp+var_4], ecx
.text$mn:00008297                 mov     eax, [ebp+var_4]
.text$mn:0000829A                 mov     esp, ebp
.text$mn:0000829C                 pop     ebp
.text$mn:0000829D                 retn    4
.text$mn:0000829D ??E?$_Temp_iterator@H@std@@QAEAAV01@H@Z endp
.text$mn:0000829D
.text$mn:0000829D _text$mn        ends
.text$mn:0000829D
.text$mn:000082A0 ; ===========================================================================
.text$mn:000082A0
.text$mn:000082A0 ; Segment type: Pure code
.text$mn:000082A0 ; Segment permissions: Read/Execute
.text$mn:000082A0 _text$mn        segment para public 'CODE' use32
.text$mn:000082A0                 assume cs:_text$mn
.text$mn:000082A0                 ;org 82A0h
.text$mn:000082A0 ; COMDAT (pick any)
.text$mn:000082A0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000082A0
.text$mn:000082A0 ; =============== S U B R O U T I N E =======================================
.text$mn:000082A0
.text$mn:000082A0 ; Attributes: bp-based frame
.text$mn:000082A0
.text$mn:000082A0 ; public: class std::_Temp_iterator<int> & __thiscall std::_Temp_iterator<int>::operator++(void)
.text$mn:000082A0                 public ??E?$_Temp_iterator@H@std@@QAEAAV01@XZ
.text$mn:000082A0 ??E?$_Temp_iterator@H@std@@QAEAAV01@XZ proc near
.text$mn:000082A0                                         ; CODE XREF: std::_Move<int *,std::_Temp_iterator<int>>(int *,int *,std::_Temp_iterator<int>,std::_Nonscalar_ptr_iterator_tag)+36p
.text$mn:000082A0
.text$mn:000082A0 var_4           = dword ptr -4
.text$mn:000082A0
.text$mn:000082A0                 push    ebp
.text$mn:000082A1                 mov     ebp, esp
.text$mn:000082A3                 push    ecx
.text$mn:000082A4                 mov     [ebp+var_4], ecx
.text$mn:000082A7                 mov     eax, [ebp+var_4]
.text$mn:000082AA                 mov     esp, ebp
.text$mn:000082AC                 pop     ebp
.text$mn:000082AD                 retn
.text$mn:000082AD ??E?$_Temp_iterator@H@std@@QAEAAV01@XZ endp
.text$mn:000082AD
.text$mn:000082AD ; ---------------------------------------------------------------------------
.text$mn:000082AE                 align 10h
.text$mn:000082AE _text$mn        ends
.text$mn:000082AE
.text$mn:000082B0 ; ===========================================================================
.text$mn:000082B0
.text$mn:000082B0 ; Segment type: Pure code
.text$mn:000082B0 ; Segment permissions: Read/Execute
.text$mn:000082B0 _text$mn        segment para public 'CODE' use32
.text$mn:000082B0                 assume cs:_text$mn
.text$mn:000082B0                 ;org 82B0h
.text$mn:000082B0 ; COMDAT (pick any)
.text$mn:000082B0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000082B0
.text$mn:000082B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000082B0
.text$mn:000082B0 ; Attributes: bp-based frame
.text$mn:000082B0
.text$mn:000082B0 ; public: class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<int>>> & __thiscall std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<int>>>::operator++(void)
.text$mn:000082B0                 public ??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAEAAV01@XZ
.text$mn:000082B0 ??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAEAAV01@XZ proc near
.text$mn:000082B0                                         ; CODE XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator++(void)+Ap
.text$mn:000082B0
.text$mn:000082B0 var_4           = dword ptr -4
.text$mn:000082B0
.text$mn:000082B0                 push    ebp
.text$mn:000082B1                 mov     ebp, esp
.text$mn:000082B3                 push    ecx
.text$mn:000082B4                 mov     [ebp+var_4], ecx
.text$mn:000082B7                 mov     ecx, [ebp+var_4] ; this
.text$mn:000082BA                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:000082BF                 test    eax, eax
.text$mn:000082C1                 jz      short loc_82DF
.text$mn:000082C3                 mov     eax, [ebp+var_4]
.text$mn:000082C6                 cmp     dword ptr [eax+8], 0
.text$mn:000082CA                 jz      short loc_82DF
.text$mn:000082CC                 mov     ecx, [ebp+var_4] ; this
.text$mn:000082CF                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:000082D4                 mov     ecx, [ebp+var_4]
.text$mn:000082D7                 mov     edx, [eax+8]
.text$mn:000082DA                 cmp     edx, [ecx+8]
.text$mn:000082DD                 ja      short loc_833E
.text$mn:000082DF
.text$mn:000082DF loc_82DF:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator++(void)+11j
.text$mn:000082DF                                         ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator++(void)+1Aj
.text$mn:000082DF                 push    65h ; 'e'       ; unsigned int
.text$mn:000082E1                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000082E6                 push    offset ??_C@_1EE@EJDKCLKB@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAi?$AAn?$AAc?$AAr?$AAe?$AAm?$AAe?$AAn?$AAt?$AAa?$AAb?$AAl@ ; "vector iterator not incrementable"
.text$mn:000082EB                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:000082F0                 add     esp, 0Ch
.text$mn:000082F3                 mov     eax, offset ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ ; "Standard C++ Libraries Out of Range"
.text$mn:000082F8                 test    eax, eax
.text$mn:000082FA                 jz      short loc_8300
.text$mn:000082FC                 xor     ecx, ecx
.text$mn:000082FE                 jnz     short loc_8323
.text$mn:00008300
.text$mn:00008300 loc_8300:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator++(void)+4Aj
.text$mn:00008300                 push    offset ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@ ; "\"Standard C++ Libraries Out of Range\""...
.text$mn:00008305                 push    offset ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ ; "%s"
.text$mn:0000830A                 push    0
.text$mn:0000830C                 push    66h ; 'f'
.text$mn:0000830E                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00008313                 push    2
.text$mn:00008315                 call    __CrtDbgReportW
.text$mn:0000831A                 add     esp, 18h
.text$mn:0000831D                 cmp     eax, 1
.text$mn:00008320                 jnz     short loc_8323
.text$mn:00008322                 int     3               ; Trap to Debugger
.text$mn:00008323
.text$mn:00008323 loc_8323:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator++(void)+4Ej
.text$mn:00008323                                         ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator++(void)+70j
.text$mn:00008323                 push    0
.text$mn:00008325                 push    66h ; 'f'
.text$mn:00008327                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000832C                 push    offset ??_C@_1MG@OPNGNDCB@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ ; "std::_Vector_const_iterator<class std::"...
.text$mn:00008331                 push    offset ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@ ; "\"out of range\""
.text$mn:00008336                 call    __invalid_parameter
.text$mn:0000833B                 add     esp, 14h
.text$mn:0000833E
.text$mn:0000833E loc_833E:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator++(void)+2Dj
.text$mn:0000833E                 mov     eax, [ebp+var_4]
.text$mn:00008341                 mov     ecx, [eax+8]
.text$mn:00008344                 add     ecx, 4
.text$mn:00008347                 mov     edx, [ebp+var_4]
.text$mn:0000834A                 mov     [edx+8], ecx
.text$mn:0000834D                 mov     eax, [ebp+var_4]
.text$mn:00008350                 mov     esp, ebp
.text$mn:00008352                 pop     ebp
.text$mn:00008353                 retn
.text$mn:00008353 ??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAEAAV01@XZ endp
.text$mn:00008353
.text$mn:00008353 _text$mn        ends
.text$mn:00008353
.text$mn:00008354 ; ===========================================================================
.text$mn:00008354
.text$mn:00008354 ; Segment type: Pure code
.text$mn:00008354 ; Segment permissions: Read/Execute
.text$mn:00008354 _text$mn        segment para public 'CODE' use32
.text$mn:00008354                 assume cs:_text$mn
.text$mn:00008354                 ;org 8354h
.text$mn:00008354 ; COMDAT (pick any)
.text$mn:00008354                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008354
.text$mn:00008354 ; =============== S U B R O U T I N E =======================================
.text$mn:00008354
.text$mn:00008354 ; Attributes: bp-based frame
.text$mn:00008354
.text$mn:00008354 ; public: class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<int>>> & __thiscall std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<int>>>::operator++(void)
.text$mn:00008354                 public ??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAEAAV01@XZ
.text$mn:00008354 ??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAEAAV01@XZ proc near
.text$mn:00008354                                         ; CODE XREF: WindowsDlg::resetSelection(void)+6Ep
.text$mn:00008354                                         ; WindowsDlg::doClose(void)+1F2p ...
.text$mn:00008354
.text$mn:00008354 var_4           = dword ptr -4
.text$mn:00008354
.text$mn:00008354                 push    ebp
.text$mn:00008355                 mov     ebp, esp
.text$mn:00008357                 push    ecx
.text$mn:00008358                 mov     [ebp+var_4], ecx
.text$mn:0000835B                 mov     ecx, [ebp+var_4]
.text$mn:0000835E                 call    ??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator++(void)
.text$mn:00008363                 mov     eax, [ebp+var_4]
.text$mn:00008366                 mov     esp, ebp
.text$mn:00008368                 pop     ebp
.text$mn:00008369                 retn
.text$mn:00008369 ??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAEAAV01@XZ endp
.text$mn:00008369
.text$mn:00008369 ; ---------------------------------------------------------------------------
.text$mn:0000836A                 align 4
.text$mn:0000836A _text$mn        ends
.text$mn:0000836A
.text$mn:0000836C ; ===========================================================================
.text$mn:0000836C
.text$mn:0000836C ; Segment type: Pure code
.text$mn:0000836C ; Segment permissions: Read/Execute
.text$mn:0000836C _text$mn        segment para public 'CODE' use32
.text$mn:0000836C                 assume cs:_text$mn
.text$mn:0000836C                 ;org 836Ch
.text$mn:0000836C ; COMDAT (pick any)
.text$mn:0000836C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000836C
.text$mn:0000836C ; =============== S U B R O U T I N E =======================================
.text$mn:0000836C
.text$mn:0000836C ; Attributes: bp-based frame
.text$mn:0000836C
.text$mn:0000836C ; int __stdcall std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator-(std::_Iterator_base12 *)
.text$mn:0000836C                 public ??G?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEHABV01@@Z
.text$mn:0000836C ??G?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEHABV01@@Z proc near
.text$mn:0000836C                                         ; CODE XREF: std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator-(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)+4Bp
.text$mn:0000836C
.text$mn:0000836C var_4           = dword ptr -4
.text$mn:0000836C arg_0           = dword ptr  8
.text$mn:0000836C
.text$mn:0000836C                 push    ebp
.text$mn:0000836D                 mov     ebp, esp
.text$mn:0000836F                 push    ecx
.text$mn:00008370                 mov     [ebp+var_4], ecx
.text$mn:00008373                 mov     eax, [ebp+arg_0]
.text$mn:00008376                 push    eax             ; std::_Iterator_base12 *
.text$mn:00008377                 mov     ecx, [ebp+var_4]
.text$mn:0000837A                 call    ?_Compat@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEXABV12@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_Compat(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:0000837F                 mov     ecx, [ebp+var_4]
.text$mn:00008382                 mov     edx, [ebp+arg_0]
.text$mn:00008385                 mov     eax, [ecx+8]
.text$mn:00008388                 sub     eax, [edx+8]
.text$mn:0000838B                 sar     eax, 1
.text$mn:0000838D                 mov     esp, ebp
.text$mn:0000838F                 pop     ebp
.text$mn:00008390                 retn    4
.text$mn:00008390 ??G?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEHABV01@@Z endp
.text$mn:00008390
.text$mn:00008390 ; ---------------------------------------------------------------------------
.text$mn:00008393                 align 4
.text$mn:00008393 _text$mn        ends
.text$mn:00008393
.text$mn:00008394 ; ===========================================================================
.text$mn:00008394
.text$mn:00008394 ; Segment type: Pure code
.text$mn:00008394 ; Segment permissions: Read/Execute
.text$mn:00008394 _text$mn        segment para public 'CODE' use32
.text$mn:00008394                 assume cs:_text$mn
.text$mn:00008394                 ;org 8394h
.text$mn:00008394 ; COMDAT (pick any)
.text$mn:00008394                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008394
.text$mn:00008394 ; =============== S U B R O U T I N E =======================================
.text$mn:00008394
.text$mn:00008394 ; Attributes: bp-based frame
.text$mn:00008394
.text$mn:00008394 ; int __stdcall std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator-(std::_Iterator_base12 *)
.text$mn:00008394                 public ??G?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEHABV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@@Z
.text$mn:00008394 ??G?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEHABV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@@Z proc near
.text$mn:00008394                                         ; CODE XREF: std::_Distance2<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,int>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,int &,std::random_access_iterator_tag)+6Fp
.text$mn:00008394
.text$mn:00008394 var_28          = byte ptr -28h
.text$mn:00008394 var_1C          = dword ptr -1Ch
.text$mn:00008394 var_18          = dword ptr -18h
.text$mn:00008394 var_14          = dword ptr -14h
.text$mn:00008394 var_10          = dword ptr -10h
.text$mn:00008394 var_C           = dword ptr -0Ch
.text$mn:00008394 var_4           = dword ptr -4
.text$mn:00008394 arg_0           = dword ptr  8
.text$mn:00008394
.text$mn:00008394                 push    ebp
.text$mn:00008395                 mov     ebp, esp
.text$mn:00008397                 push    0FFFFFFFFh
.text$mn:00008399                 push    offset __ehhandler$??G?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEHABV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@@Z
.text$mn:0000839E                 mov     eax, large fs:0
.text$mn:000083A4                 push    eax
.text$mn:000083A5                 sub     esp, 1Ch
.text$mn:000083A8                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000083AD                 xor     eax, ebp
.text$mn:000083AF                 push    eax
.text$mn:000083B0                 lea     eax, [ebp+var_C]
.text$mn:000083B3                 mov     large fs:0, eax
.text$mn:000083B9                 mov     [ebp+var_10], ecx
.text$mn:000083BC                 mov     eax, [ebp+arg_0]
.text$mn:000083BF                 push    eax             ; std::_Iterator_base12 *
.text$mn:000083C0                 mov     ecx, [ebp+var_10]
.text$mn:000083C3                 push    ecx             ; struct std::_Iterator_base12 *
.text$mn:000083C4                 lea     ecx, [ebp+var_28]
.text$mn:000083C7                 call    ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:000083CC                 mov     [ebp+var_14], eax
.text$mn:000083CF                 mov     edx, [ebp+var_14]
.text$mn:000083D2                 mov     [ebp+var_18], edx
.text$mn:000083D5                 mov     [ebp+var_4], 0
.text$mn:000083DC                 mov     ecx, [ebp+var_18]
.text$mn:000083DF                 call    ??G?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEHABV01@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator-(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:000083E4                 mov     [ebp+var_1C], eax
.text$mn:000083E7                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000083EE                 lea     ecx, [ebp+var_28]
.text$mn:000083F1                 call    ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$mn:000083F6                 mov     eax, [ebp+var_1C]
.text$mn:000083F9                 mov     ecx, [ebp+var_C]
.text$mn:000083FC                 mov     large fs:0, ecx
.text$mn:00008403                 pop     ecx
.text$mn:00008404                 mov     esp, ebp
.text$mn:00008406                 pop     ebp
.text$mn:00008407                 retn    4
.text$mn:00008407 ??G?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEHABV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@@Z endp
.text$mn:00008407
.text$mn:00008407 ; ---------------------------------------------------------------------------
.text$mn:0000840A                 align 4
.text$mn:0000840A _text$mn        ends
.text$mn:0000840A
.text$x:0000840C ; ===========================================================================
.text$x:0000840C
.text$x:0000840C ; Segment type: Pure code
.text$x:0000840C ; Segment permissions: Read/Execute
.text$x:0000840C _text$x         segment para public 'CODE' use32
.text$x:0000840C                 assume cs:_text$x
.text$x:0000840C                 ;org 840Ch
.text$x:0000840C ; COMDAT (pick associative to section at 8394)
.text$x:0000840C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000840C
.text$x:0000840C ; =============== S U B R O U T I N E =======================================
.text$x:0000840C
.text$x:0000840C
.text$x:0000840C __unwindfunclet$??G?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEHABV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@@Z$0 proc near
.text$x:0000840C                                         ; DATA XREF: .xdata$x:0000D420o
.text$x:0000840C                 lea     ecx, [ebp-28h]
.text$x:0000840F                 jmp     ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:0000840F __unwindfunclet$??G?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEHABV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@@Z$0 endp
.text$x:0000840F
.text$x:00008414
.text$x:00008414 ; =============== S U B R O U T I N E =======================================
.text$x:00008414
.text$x:00008414
.text$x:00008414 __ehhandler$??G?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEHABV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@@Z proc near
.text$x:00008414                                         ; DATA XREF: std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator-(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)+5o
.text$x:00008414
.text$x:00008414 arg_4           = dword ptr  8
.text$x:00008414
.text$x:00008414                 mov     edx, [esp+arg_4]
.text$x:00008418                 lea     eax, [edx+0Ch]
.text$x:0000841B                 mov     ecx, [edx-20h]
.text$x:0000841E                 xor     ecx, eax
.text$x:00008420                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00008425                 mov     eax, offset __ehfuncinfo$??G?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEHABV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@@Z
.text$x:0000842A                 jmp     ___CxxFrameHandler3
.text$x:0000842A __ehhandler$??G?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEHABV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@@Z endp
.text$x:0000842A
.text$x:0000842A ; ---------------------------------------------------------------------------
.text$x:0000842F                 align 10h
.text$x:0000842F _text$x         ends
.text$x:0000842F
.text$mn:00008430 ; ===========================================================================
.text$mn:00008430
.text$mn:00008430 ; Segment type: Pure code
.text$mn:00008430 ; Segment permissions: Read/Execute
.text$mn:00008430 _text$mn        segment para public 'CODE' use32
.text$mn:00008430                 assume cs:_text$mn
.text$mn:00008430                 ;org 8430h
.text$mn:00008430 ; COMDAT (pick any)
.text$mn:00008430                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008430
.text$mn:00008430 ; =============== S U B R O U T I N E =======================================
.text$mn:00008430
.text$mn:00008430 ; Attributes: bp-based frame
.text$mn:00008430
.text$mn:00008430 ; int __stdcall std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator<(std::_Iterator_base12 *)
.text$mn:00008430                 public ??M?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBE_NABV01@@Z
.text$mn:00008430 ??M?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBE_NABV01@@Z proc near
.text$mn:00008430                                         ; CODE XREF: std::_Debug_range2<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,wchar_t const *,uint,std::random_access_iterator_tag)+6Bp
.text$mn:00008430                                         ; std::vector<int,std::allocator<int>>::erase(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>)+1B2p
.text$mn:00008430
.text$mn:00008430 var_8           = dword ptr -8
.text$mn:00008430 var_4           = dword ptr -4
.text$mn:00008430 arg_0           = dword ptr  8
.text$mn:00008430
.text$mn:00008430                 push    ebp
.text$mn:00008431                 mov     ebp, esp
.text$mn:00008433                 sub     esp, 8
.text$mn:00008436                 mov     [ebp+var_4], ecx
.text$mn:00008439                 mov     eax, [ebp+arg_0]
.text$mn:0000843C                 push    eax             ; std::_Iterator_base12 *
.text$mn:0000843D                 mov     ecx, [ebp+var_4]
.text$mn:00008440                 call    ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Compat(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>> const &)
.text$mn:00008445                 mov     ecx, [ebp+var_4]
.text$mn:00008448                 mov     edx, [ebp+arg_0]
.text$mn:0000844B                 mov     eax, [ecx+8]
.text$mn:0000844E                 cmp     eax, [edx+8]
.text$mn:00008451                 jnb     short loc_845C
.text$mn:00008453                 mov     [ebp+var_8], 1
.text$mn:0000845A                 jmp     short loc_8463
.text$mn:0000845C ; ---------------------------------------------------------------------------
.text$mn:0000845C
.text$mn:0000845C loc_845C:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator<(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>> const &)+21j
.text$mn:0000845C                 mov     [ebp+var_8], 0
.text$mn:00008463
.text$mn:00008463 loc_8463:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator<(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>> const &)+2Aj
.text$mn:00008463                 mov     al, byte ptr [ebp+var_8]
.text$mn:00008466                 mov     esp, ebp
.text$mn:00008468                 pop     ebp
.text$mn:00008469                 retn    4
.text$mn:00008469 ??M?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBE_NABV01@@Z endp
.text$mn:00008469
.text$mn:00008469 _text$mn        ends
.text$mn:00008469
.text$mn:0000846C ; ===========================================================================
.text$mn:0000846C
.text$mn:0000846C ; Segment type: Pure code
.text$mn:0000846C ; Segment permissions: Read/Execute
.text$mn:0000846C _text$mn        segment para public 'CODE' use32
.text$mn:0000846C                 assume cs:_text$mn
.text$mn:0000846C                 ;org 846Ch
.text$mn:0000846C ; COMDAT (pick any)
.text$mn:0000846C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000846C
.text$mn:0000846C ; =============== S U B R O U T I N E =======================================
.text$mn:0000846C
.text$mn:0000846C ; Attributes: bp-based frame
.text$mn:0000846C
.text$mn:0000846C ; public: bool __thiscall std::binder2nd<struct std::equal_to<int>>::operator()(int &)const
.text$mn:0000846C                 public ??R?$binder2nd@U?$equal_to@H@std@@@std@@QBE_NAAH@Z
.text$mn:0000846C ??R?$binder2nd@U?$equal_to@H@std@@@std@@QBE_NAAH@Z proc near
.text$mn:0000846C                                         ; CODE XREF: std::_Find_if<int *,std::binder2nd<std::equal_to<int>>>(int *,int *,std::binder2nd<std::equal_to<int>>)+1Dp
.text$mn:0000846C                                         ; std::_Remove_if<int *,std::binder2nd<std::equal_to<int>>>(int *,int *,std::binder2nd<std::equal_to<int>>)+2Dp
.text$mn:0000846C
.text$mn:0000846C var_4           = dword ptr -4
.text$mn:0000846C arg_0           = dword ptr  8
.text$mn:0000846C
.text$mn:0000846C                 push    ebp
.text$mn:0000846D                 mov     ebp, esp
.text$mn:0000846F                 push    ecx
.text$mn:00008470                 mov     [ebp+var_4], ecx
.text$mn:00008473                 mov     eax, [ebp+var_4]
.text$mn:00008476                 add     eax, 4
.text$mn:00008479                 push    eax
.text$mn:0000847A                 mov     ecx, [ebp+arg_0]
.text$mn:0000847D                 push    ecx
.text$mn:0000847E                 mov     ecx, [ebp+var_4]
.text$mn:00008481                 call    ??R?$equal_to@H@std@@QBE_NABH0@Z ; std::equal_to<int>::operator()(int const &,int const &)
.text$mn:00008486                 mov     esp, ebp
.text$mn:00008488                 pop     ebp
.text$mn:00008489                 retn    4
.text$mn:00008489 ??R?$binder2nd@U?$equal_to@H@std@@@std@@QBE_NAAH@Z endp
.text$mn:00008489
.text$mn:00008489 _text$mn        ends
.text$mn:00008489
.text$mn:0000848C ; ===========================================================================
.text$mn:0000848C
.text$mn:0000848C ; Segment type: Pure code
.text$mn:0000848C ; Segment permissions: Read/Execute
.text$mn:0000848C _text$mn        segment para public 'CODE' use32
.text$mn:0000848C                 assume cs:_text$mn
.text$mn:0000848C                 ;org 848Ch
.text$mn:0000848C ; COMDAT (pick any)
.text$mn:0000848C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000848C
.text$mn:0000848C ; =============== S U B R O U T I N E =======================================
.text$mn:0000848C
.text$mn:0000848C ; Attributes: bp-based frame
.text$mn:0000848C
.text$mn:0000848C ; public: bool __thiscall std::equal_to<int>::operator()(int const &, int const &)const
.text$mn:0000848C                 public ??R?$equal_to@H@std@@QBE_NABH0@Z
.text$mn:0000848C ??R?$equal_to@H@std@@QBE_NABH0@Z proc near
.text$mn:0000848C                                         ; CODE XREF: std::binder2nd<std::equal_to<int>>::operator()(int &)+15p
.text$mn:0000848C
.text$mn:0000848C var_8           = dword ptr -8
.text$mn:0000848C var_4           = dword ptr -4
.text$mn:0000848C arg_0           = dword ptr  8
.text$mn:0000848C arg_4           = dword ptr  0Ch
.text$mn:0000848C
.text$mn:0000848C                 push    ebp
.text$mn:0000848D                 mov     ebp, esp
.text$mn:0000848F                 sub     esp, 8
.text$mn:00008492                 mov     [ebp+var_8], ecx
.text$mn:00008495                 mov     eax, [ebp+arg_0]
.text$mn:00008498                 mov     ecx, [ebp+arg_4]
.text$mn:0000849B                 mov     edx, [eax]
.text$mn:0000849D                 cmp     edx, [ecx]
.text$mn:0000849F                 jnz     short loc_84AA
.text$mn:000084A1                 mov     [ebp+var_4], 1
.text$mn:000084A8                 jmp     short loc_84B1
.text$mn:000084AA ; ---------------------------------------------------------------------------
.text$mn:000084AA
.text$mn:000084AA loc_84AA:                               ; CODE XREF: std::equal_to<int>::operator()(int const &,int const &)+13j
.text$mn:000084AA                 mov     [ebp+var_4], 0
.text$mn:000084B1
.text$mn:000084B1 loc_84B1:                               ; CODE XREF: std::equal_to<int>::operator()(int const &,int const &)+1Cj
.text$mn:000084B1                 mov     al, byte ptr [ebp+var_4]
.text$mn:000084B4                 mov     esp, ebp
.text$mn:000084B6                 pop     ebp
.text$mn:000084B7                 retn    8
.text$mn:000084B7 ??R?$equal_to@H@std@@QBE_NABH0@Z endp
.text$mn:000084B7
.text$mn:000084B7 ; ---------------------------------------------------------------------------
.text$mn:000084BA                 align 4
.text$mn:000084BA _text$mn        ends
.text$mn:000084BA
.text$mn:000084BC ; ===========================================================================
.text$mn:000084BC
.text$mn:000084BC ; Segment type: Pure code
.text$mn:000084BC ; Segment permissions: Read/Execute
.text$mn:000084BC _text$mn        segment para public 'CODE' use32
.text$mn:000084BC                 assume cs:_text$mn
.text$mn:000084BC                 ;org 84BCh
.text$mn:000084BC ; COMDAT (pick any)
.text$mn:000084BC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000084BC
.text$mn:000084BC ; =============== S U B R O U T I N E =======================================
.text$mn:000084BC
.text$mn:000084BC ; Attributes: bp-based frame
.text$mn:000084BC
.text$mn:000084BC ; public: bool __thiscall BufferEquivalent::operator()(int, int)const
.text$mn:000084BC                 public ??RBufferEquivalent@@QBE_NHH@Z
.text$mn:000084BC ??RBufferEquivalent@@QBE_NHH@Z proc near
.text$mn:000084BC                                         ; CODE XREF: std::_Debug_lt_pred<BufferEquivalent,int &,int &>(BufferEquivalent,int &,int &,wchar_t const *,uint)+24p
.text$mn:000084BC                                         ; std::_Debug_lt_pred<BufferEquivalent,int &,int &>(BufferEquivalent,int &,int &,wchar_t const *,uint)+57p ...
.text$mn:000084BC
.text$mn:000084BC var_4           = dword ptr -4
.text$mn:000084BC arg_0           = dword ptr  8
.text$mn:000084BC arg_4           = dword ptr  0Ch
.text$mn:000084BC
.text$mn:000084BC                 push    ebp
.text$mn:000084BD                 mov     ebp, esp
.text$mn:000084BF                 push    ecx
.text$mn:000084C0                 mov     [ebp+var_4], ecx
.text$mn:000084C3                 mov     eax, [ebp+arg_0]
.text$mn:000084C6                 cmp     eax, [ebp+arg_4]
.text$mn:000084C9                 jnz     short loc_84CF
.text$mn:000084CB                 xor     al, al
.text$mn:000084CD                 jmp     short loc_84FA
.text$mn:000084CF ; ---------------------------------------------------------------------------
.text$mn:000084CF
.text$mn:000084CF loc_84CF:                               ; CODE XREF: BufferEquivalent::operator()(int,int)+Dj
.text$mn:000084CF                 mov     ecx, [ebp+var_4]
.text$mn:000084D2                 movzx   edx, byte ptr [ecx+0Ch]
.text$mn:000084D6                 test    edx, edx
.text$mn:000084D8                 jz      short loc_84EA
.text$mn:000084DA                 lea     eax, [ebp+arg_4]
.text$mn:000084DD                 push    eax
.text$mn:000084DE                 lea     ecx, [ebp+arg_0]
.text$mn:000084E1                 push    ecx
.text$mn:000084E2                 call    ??$swap@H@std@@YAXAAH0@Z ; std::swap<int>(int &,int &)
.text$mn:000084E7                 add     esp, 8
.text$mn:000084EA
.text$mn:000084EA loc_84EA:                               ; CODE XREF: BufferEquivalent::operator()(int,int)+1Cj
.text$mn:000084EA                 mov     edx, [ebp+arg_4]
.text$mn:000084ED                 push    edx             ; int
.text$mn:000084EE                 mov     eax, [ebp+arg_0]
.text$mn:000084F1                 push    eax             ; int
.text$mn:000084F2                 mov     ecx, [ebp+var_4] ; this
.text$mn:000084F5                 call    ?compare@BufferEquivalent@@QBE_NHH@Z ; BufferEquivalent::compare(int,int)
.text$mn:000084FA
.text$mn:000084FA loc_84FA:                               ; CODE XREF: BufferEquivalent::operator()(int,int)+11j
.text$mn:000084FA                 mov     esp, ebp
.text$mn:000084FC                 pop     ebp
.text$mn:000084FD                 retn    8
.text$mn:000084FD ??RBufferEquivalent@@QBE_NHH@Z endp
.text$mn:000084FD
.text$mn:000084FD _text$mn        ends
.text$mn:000084FD
.text$mn:00008500 ; ===========================================================================
.text$mn:00008500
.text$mn:00008500 ; Segment type: Pure code
.text$mn:00008500 ; Segment permissions: Read/Execute
.text$mn:00008500 _text$mn        segment para public 'CODE' use32
.text$mn:00008500                 assume cs:_text$mn
.text$mn:00008500                 ;org 8500h
.text$mn:00008500 ; COMDAT (pick any)
.text$mn:00008500                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008500
.text$mn:00008500 ; =============== S U B R O U T I N E =======================================
.text$mn:00008500
.text$mn:00008500 ; Attributes: bp-based frame
.text$mn:00008500
.text$mn:00008500 ; int __stdcall NumericStringEquivalence::operator()(wchar_t *Str, wchar_t *)
.text$mn:00008500                 public ??RNumericStringEquivalence@@QBE_NPB_W0@Z
.text$mn:00008500 ??RNumericStringEquivalence@@QBE_NPB_W0@Z proc near
.text$mn:00008500                                         ; CODE XREF: BufferEquivalent::compare(int,int)+7Dp
.text$mn:00008500                                         ; BufferEquivalent::compare(int,int)+B0p
.text$mn:00008500
.text$mn:00008500 var_8           = dword ptr -8
.text$mn:00008500 var_4           = dword ptr -4
.text$mn:00008500 Str             = dword ptr  8
.text$mn:00008500 arg_4           = dword ptr  0Ch
.text$mn:00008500
.text$mn:00008500                 push    ebp
.text$mn:00008501                 mov     ebp, esp
.text$mn:00008503                 sub     esp, 8
.text$mn:00008506                 mov     [ebp+var_8], ecx
.text$mn:00008509                 mov     eax, [ebp+arg_4]
.text$mn:0000850C                 push    eax             ; wchar_t *
.text$mn:0000850D                 mov     ecx, [ebp+Str]
.text$mn:00008510                 push    ecx             ; Str
.text$mn:00008511                 call    ?numstrcmp@NumericStringEquivalence@@SAHPB_W0@Z ; NumericStringEquivalence::numstrcmp(wchar_t const *,wchar_t const *)
.text$mn:00008516                 add     esp, 8
.text$mn:00008519                 test    eax, eax
.text$mn:0000851B                 jge     short loc_8526
.text$mn:0000851D                 mov     [ebp+var_4], 1
.text$mn:00008524                 jmp     short loc_852D
.text$mn:00008526 ; ---------------------------------------------------------------------------
.text$mn:00008526
.text$mn:00008526 loc_8526:                               ; CODE XREF: NumericStringEquivalence::operator()(wchar_t const *,wchar_t const *)+1Bj
.text$mn:00008526                 mov     [ebp+var_4], 0
.text$mn:0000852D
.text$mn:0000852D loc_852D:                               ; CODE XREF: NumericStringEquivalence::operator()(wchar_t const *,wchar_t const *)+24j
.text$mn:0000852D                 mov     al, byte ptr [ebp+var_4]
.text$mn:00008530                 mov     esp, ebp
.text$mn:00008532                 pop     ebp
.text$mn:00008533                 retn    8
.text$mn:00008533 ??RNumericStringEquivalence@@QBE_NPB_W0@Z endp
.text$mn:00008533
.text$mn:00008533 ; ---------------------------------------------------------------------------
.text$mn:00008536                 align 4
.text$mn:00008536 _text$mn        ends
.text$mn:00008536
.text$mn:00008538 ; ===========================================================================
.text$mn:00008538
.text$mn:00008538 ; Segment type: Pure code
.text$mn:00008538 ; Segment permissions: Read/Execute
.text$mn:00008538 _text$mn        segment para public 'CODE' use32
.text$mn:00008538                 assume cs:_text$mn
.text$mn:00008538                 ;org 8538h
.text$mn:00008538 ; COMDAT (pick any)
.text$mn:00008538                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008538
.text$mn:00008538 ; =============== S U B R O U T I N E =======================================
.text$mn:00008538
.text$mn:00008538 ; Attributes: bp-based frame
.text$mn:00008538
.text$mn:00008538 ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator+=(wchar_t *Str)
.text$mn:00008538                 public ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z
.text$mn:00008538 ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z proc near
.text$mn:00008538                                         ; CODE XREF: WindowsMenu::init(HINSTANCE__ *,HMENU__ *,wchar_t const *)+76p
.text$mn:00008538
.text$mn:00008538 var_4           = dword ptr -4
.text$mn:00008538 Str             = dword ptr  8
.text$mn:00008538
.text$mn:00008538                 push    ebp
.text$mn:00008539                 mov     ebp, esp
.text$mn:0000853B                 push    ecx
.text$mn:0000853C                 mov     [ebp+var_4], ecx
.text$mn:0000853F                 mov     eax, [ebp+Str]
.text$mn:00008542                 push    eax             ; Str
.text$mn:00008543                 mov     ecx, [ebp+var_4]
.text$mn:00008546                 call    ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *)
.text$mn:0000854B                 mov     esp, ebp
.text$mn:0000854D                 pop     ebp
.text$mn:0000854E                 retn    4
.text$mn:0000854E ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z endp
.text$mn:0000854E
.text$mn:0000854E ; ---------------------------------------------------------------------------
.text$mn:00008551                 align 4
.text$mn:00008551 _text$mn        ends
.text$mn:00008551
.text$mn:00008554 ; ===========================================================================
.text$mn:00008554
.text$mn:00008554 ; Segment type: Pure code
.text$mn:00008554 ; Segment permissions: Read/Execute
.text$mn:00008554 _text$mn        segment para public 'CODE' use32
.text$mn:00008554                 assume cs:_text$mn
.text$mn:00008554                 ;org 8554h
.text$mn:00008554 ; COMDAT (pick any)
.text$mn:00008554                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008554
.text$mn:00008554 ; =============== S U B R O U T I N E =======================================
.text$mn:00008554
.text$mn:00008554 ; Attributes: bp-based frame
.text$mn:00008554
.text$mn:00008554 ; public: virtual void * __thiscall StaticDialog::`scalar deleting destructor'(unsigned int)
.text$mn:00008554                 public ??_GStaticDialog@@UAEPAXI@Z
.text$mn:00008554 ??_GStaticDialog@@UAEPAXI@Z proc near
.text$mn:00008554
.text$mn:00008554 var_4           = dword ptr -4
.text$mn:00008554 arg_0           = dword ptr  8
.text$mn:00008554
.text$mn:00008554                 push    ebp
.text$mn:00008555                 mov     ebp, esp
.text$mn:00008557                 push    ecx
.text$mn:00008558                 mov     [ebp+var_4], ecx
.text$mn:0000855B                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000855E                 call    ??1StaticDialog@@UAE@XZ ; StaticDialog::~StaticDialog(void)
.text$mn:00008563                 mov     eax, [ebp+arg_0]
.text$mn:00008566                 and     eax, 1
.text$mn:00008569                 jz      short loc_8577
.text$mn:0000856B                 mov     ecx, [ebp+var_4]
.text$mn:0000856E                 push    ecx             ; void *
.text$mn:0000856F                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00008574                 add     esp, 4
.text$mn:00008577
.text$mn:00008577 loc_8577:                               ; CODE XREF: StaticDialog::`scalar deleting destructor'(uint)+15j
.text$mn:00008577                 mov     eax, [ebp+var_4]
.text$mn:0000857A                 mov     esp, ebp
.text$mn:0000857C                 pop     ebp
.text$mn:0000857D                 retn    4
.text$mn:0000857D ??_GStaticDialog@@UAEPAXI@Z endp
.text$mn:0000857D
.text$mn:0000857D _text$mn        ends
.text$mn:0000857D
.text$mn:00008580 ; ===========================================================================
.text$mn:00008580
.text$mn:00008580 ; Segment type: Pure code
.text$mn:00008580 ; Segment permissions: Read/Execute
.text$mn:00008580 _text$mn        segment para public 'CODE' use32
.text$mn:00008580                 assume cs:_text$mn
.text$mn:00008580                 ;org 8580h
.text$mn:00008580 ; COMDAT (pick any)
.text$mn:00008580                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008580
.text$mn:00008580 ; =============== S U B R O U T I N E =======================================
.text$mn:00008580
.text$mn:00008580 ; Attributes: bp-based frame
.text$mn:00008580
.text$mn:00008580 ; public: virtual void * __thiscall Window::`scalar deleting destructor'(unsigned int)
.text$mn:00008580                 public ??_GWindow@@UAEPAXI@Z
.text$mn:00008580 ??_GWindow@@UAEPAXI@Z proc near
.text$mn:00008580
.text$mn:00008580 var_4           = dword ptr -4
.text$mn:00008580 arg_0           = dword ptr  8
.text$mn:00008580
.text$mn:00008580                 push    ebp
.text$mn:00008581                 mov     ebp, esp
.text$mn:00008583                 push    ecx
.text$mn:00008584                 mov     [ebp+var_4], ecx
.text$mn:00008587                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000858A                 call    ??1Window@@UAE@XZ ; Window::~Window(void)
.text$mn:0000858F                 mov     eax, [ebp+arg_0]
.text$mn:00008592                 and     eax, 1
.text$mn:00008595                 jz      short loc_85A3
.text$mn:00008597                 mov     ecx, [ebp+var_4]
.text$mn:0000859A                 push    ecx             ; void *
.text$mn:0000859B                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:000085A0                 add     esp, 4
.text$mn:000085A3
.text$mn:000085A3 loc_85A3:                               ; CODE XREF: Window::`scalar deleting destructor'(uint)+15j
.text$mn:000085A3                 mov     eax, [ebp+var_4]
.text$mn:000085A6                 mov     esp, ebp
.text$mn:000085A8                 pop     ebp
.text$mn:000085A9                 retn    4
.text$mn:000085A9 ??_GWindow@@UAEPAXI@Z endp
.text$mn:000085A9
.text$mn:000085A9 _text$mn        ends
.text$mn:000085A9
.text$mn:000085AC ; ===========================================================================
.text$mn:000085AC
.text$mn:000085AC ; Segment type: Pure code
.text$mn:000085AC ; Segment permissions: Read/Execute
.text$mn:000085AC _text$mn        segment para public 'CODE' use32
.text$mn:000085AC                 assume cs:_text$mn
.text$mn:000085AC                 ;org 85ACh
.text$mn:000085AC ; COMDAT (pick any)
.text$mn:000085AC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000085AC
.text$mn:000085AC ; =============== S U B R O U T I N E =======================================
.text$mn:000085AC
.text$mn:000085AC ; Attributes: bp-based frame
.text$mn:000085AC
.text$mn:000085AC ; public: virtual void * __thiscall WindowsDlg::`scalar deleting destructor'(unsigned int)
.text$mn:000085AC                 public ??_GWindowsDlg@@UAEPAXI@Z
.text$mn:000085AC ??_GWindowsDlg@@UAEPAXI@Z proc near
.text$mn:000085AC
.text$mn:000085AC var_4           = dword ptr -4
.text$mn:000085AC arg_0           = dword ptr  8
.text$mn:000085AC
.text$mn:000085AC                 push    ebp
.text$mn:000085AD                 mov     ebp, esp
.text$mn:000085AF                 push    ecx
.text$mn:000085B0                 mov     [ebp+var_4], ecx
.text$mn:000085B3                 mov     ecx, [ebp+var_4] ; this
.text$mn:000085B6                 call    ??1WindowsDlg@@UAE@XZ ; WindowsDlg::~WindowsDlg(void)
.text$mn:000085BB                 mov     eax, [ebp+arg_0]
.text$mn:000085BE                 and     eax, 1
.text$mn:000085C1                 jz      short loc_85CF
.text$mn:000085C3                 mov     ecx, [ebp+var_4]
.text$mn:000085C6                 push    ecx             ; void *
.text$mn:000085C7                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:000085CC                 add     esp, 4
.text$mn:000085CF
.text$mn:000085CF loc_85CF:                               ; CODE XREF: WindowsDlg::`scalar deleting destructor'(uint)+15j
.text$mn:000085CF                 mov     eax, [ebp+var_4]
.text$mn:000085D2                 mov     esp, ebp
.text$mn:000085D4                 pop     ebp
.text$mn:000085D5                 retn    4
.text$mn:000085D5 ??_GWindowsDlg@@UAEPAXI@Z endp
.text$mn:000085D5
.text$mn:000085D5 _text$mn        ends
.text$mn:000085D5
.text$mn:000085D8 ; ===========================================================================
.text$mn:000085D8
.text$mn:000085D8 ; Segment type: Pure code
.text$mn:000085D8 ; Segment permissions: Read/Execute
.text$mn:000085D8 _text$mn        segment para public 'CODE' use32
.text$mn:000085D8                 assume cs:_text$mn
.text$mn:000085D8                 ;org 85D8h
.text$mn:000085D8 ; COMDAT (pick any)
.text$mn:000085D8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000085D8
.text$mn:000085D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000085D8
.text$mn:000085D8 ; Attributes: bp-based frame
.text$mn:000085D8
.text$mn:000085D8 ; public: virtual void * __thiscall std::_Generic_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:000085D8                 public ??_G_Generic_error_category@std@@UAEPAXI@Z
.text$mn:000085D8 ??_G_Generic_error_category@std@@UAEPAXI@Z proc near
.text$mn:000085D8
.text$mn:000085D8 var_4           = dword ptr -4
.text$mn:000085D8 arg_0           = dword ptr  8
.text$mn:000085D8
.text$mn:000085D8                 push    ebp
.text$mn:000085D9                 mov     ebp, esp
.text$mn:000085DB                 push    ecx
.text$mn:000085DC                 mov     [ebp+var_4], ecx
.text$mn:000085DF                 mov     ecx, [ebp+var_4] ; this
.text$mn:000085E2                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:000085E7                 mov     eax, [ebp+arg_0]
.text$mn:000085EA                 and     eax, 1
.text$mn:000085ED                 jz      short loc_85FB
.text$mn:000085EF                 mov     ecx, [ebp+var_4]
.text$mn:000085F2                 push    ecx             ; void *
.text$mn:000085F3                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:000085F8                 add     esp, 4
.text$mn:000085FB
.text$mn:000085FB loc_85FB:                               ; CODE XREF: std::_Generic_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:000085FB                 mov     eax, [ebp+var_4]
.text$mn:000085FE                 mov     esp, ebp
.text$mn:00008600                 pop     ebp
.text$mn:00008601                 retn    4
.text$mn:00008601 ??_G_Generic_error_category@std@@UAEPAXI@Z endp
.text$mn:00008601
.text$mn:00008601 _text$mn        ends
.text$mn:00008601
.text$mn:00008604 ; ===========================================================================
.text$mn:00008604
.text$mn:00008604 ; Segment type: Pure code
.text$mn:00008604 ; Segment permissions: Read/Execute
.text$mn:00008604 _text$mn        segment para public 'CODE' use32
.text$mn:00008604                 assume cs:_text$mn
.text$mn:00008604                 ;org 8604h
.text$mn:00008604 ; COMDAT (pick any)
.text$mn:00008604                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008604
.text$mn:00008604 ; =============== S U B R O U T I N E =======================================
.text$mn:00008604
.text$mn:00008604 ; Attributes: bp-based frame
.text$mn:00008604
.text$mn:00008604 ; public: virtual void * __thiscall std::_Iostream_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00008604                 public ??_G_Iostream_error_category@std@@UAEPAXI@Z
.text$mn:00008604 ??_G_Iostream_error_category@std@@UAEPAXI@Z proc near
.text$mn:00008604
.text$mn:00008604 var_4           = dword ptr -4
.text$mn:00008604 arg_0           = dword ptr  8
.text$mn:00008604
.text$mn:00008604                 push    ebp
.text$mn:00008605                 mov     ebp, esp
.text$mn:00008607                 push    ecx
.text$mn:00008608                 mov     [ebp+var_4], ecx
.text$mn:0000860B                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000860E                 call    ??1_Iostream_error_category@std@@UAE@XZ ; std::_Iostream_error_category::~_Iostream_error_category(void)
.text$mn:00008613                 mov     eax, [ebp+arg_0]
.text$mn:00008616                 and     eax, 1
.text$mn:00008619                 jz      short loc_8627
.text$mn:0000861B                 mov     ecx, [ebp+var_4]
.text$mn:0000861E                 push    ecx             ; void *
.text$mn:0000861F                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00008624                 add     esp, 4
.text$mn:00008627
.text$mn:00008627 loc_8627:                               ; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00008627                 mov     eax, [ebp+var_4]
.text$mn:0000862A                 mov     esp, ebp
.text$mn:0000862C                 pop     ebp
.text$mn:0000862D                 retn    4
.text$mn:0000862D ??_G_Iostream_error_category@std@@UAEPAXI@Z endp
.text$mn:0000862D
.text$mn:0000862D _text$mn        ends
.text$mn:0000862D
.text$mn:00008630 ; ===========================================================================
.text$mn:00008630
.text$mn:00008630 ; Segment type: Pure code
.text$mn:00008630 ; Segment permissions: Read/Execute
.text$mn:00008630 _text$mn        segment para public 'CODE' use32
.text$mn:00008630                 assume cs:_text$mn
.text$mn:00008630                 ;org 8630h
.text$mn:00008630 ; COMDAT (pick any)
.text$mn:00008630                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008630
.text$mn:00008630 ; =============== S U B R O U T I N E =======================================
.text$mn:00008630
.text$mn:00008630 ; Attributes: bp-based frame
.text$mn:00008630
.text$mn:00008630 ; public: virtual void * __thiscall std::_System_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00008630                 public ??_G_System_error_category@std@@UAEPAXI@Z
.text$mn:00008630 ??_G_System_error_category@std@@UAEPAXI@Z proc near
.text$mn:00008630
.text$mn:00008630 var_4           = dword ptr -4
.text$mn:00008630 arg_0           = dword ptr  8
.text$mn:00008630
.text$mn:00008630                 push    ebp
.text$mn:00008631                 mov     ebp, esp
.text$mn:00008633                 push    ecx
.text$mn:00008634                 mov     [ebp+var_4], ecx
.text$mn:00008637                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000863A                 call    ??1_System_error_category@std@@UAE@XZ ; std::_System_error_category::~_System_error_category(void)
.text$mn:0000863F                 mov     eax, [ebp+arg_0]
.text$mn:00008642                 and     eax, 1
.text$mn:00008645                 jz      short loc_8653
.text$mn:00008647                 mov     ecx, [ebp+var_4]
.text$mn:0000864A                 push    ecx             ; void *
.text$mn:0000864B                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00008650                 add     esp, 4
.text$mn:00008653
.text$mn:00008653 loc_8653:                               ; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00008653                 mov     eax, [ebp+var_4]
.text$mn:00008656                 mov     esp, ebp
.text$mn:00008658                 pop     ebp
.text$mn:00008659                 retn    4
.text$mn:00008659 ??_G_System_error_category@std@@UAEPAXI@Z endp
.text$mn:00008659
.text$mn:00008659 _text$mn        ends
.text$mn:00008659
.text$mn:0000865C ; ===========================================================================
.text$mn:0000865C
.text$mn:0000865C ; Segment type: Pure code
.text$mn:0000865C ; Segment permissions: Read/Execute
.text$mn:0000865C _text$mn        segment para public 'CODE' use32
.text$mn:0000865C                 assume cs:_text$mn
.text$mn:0000865C                 ;org 865Ch
.text$mn:0000865C ; COMDAT (pick any)
.text$mn:0000865C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000865C
.text$mn:0000865C ; =============== S U B R O U T I N E =======================================
.text$mn:0000865C
.text$mn:0000865C ; Attributes: bp-based frame
.text$mn:0000865C
.text$mn:0000865C ; public: virtual void * __thiscall std::error_category::`scalar deleting destructor'(unsigned int)
.text$mn:0000865C                 public ??_Gerror_category@std@@UAEPAXI@Z
.text$mn:0000865C ??_Gerror_category@std@@UAEPAXI@Z proc near
.text$mn:0000865C
.text$mn:0000865C var_4           = dword ptr -4
.text$mn:0000865C arg_0           = dword ptr  8
.text$mn:0000865C
.text$mn:0000865C                 push    ebp
.text$mn:0000865D                 mov     ebp, esp
.text$mn:0000865F                 push    ecx
.text$mn:00008660                 mov     [ebp+var_4], ecx
.text$mn:00008663                 mov     ecx, [ebp+var_4] ; this
.text$mn:00008666                 call    ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$mn:0000866B                 mov     eax, [ebp+arg_0]
.text$mn:0000866E                 and     eax, 1
.text$mn:00008671                 jz      short loc_867F
.text$mn:00008673                 mov     ecx, [ebp+var_4]
.text$mn:00008676                 push    ecx             ; void *
.text$mn:00008677                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:0000867C                 add     esp, 4
.text$mn:0000867F
.text$mn:0000867F loc_867F:                               ; CODE XREF: std::error_category::`scalar deleting destructor'(uint)+15j
.text$mn:0000867F                 mov     eax, [ebp+var_4]
.text$mn:00008682                 mov     esp, ebp
.text$mn:00008684                 pop     ebp
.text$mn:00008685                 retn    4
.text$mn:00008685 ??_Gerror_category@std@@UAEPAXI@Z endp
.text$mn:00008685
.text$mn:00008685 _text$mn        ends
.text$mn:00008685
.text$di:00008688 ; ===========================================================================
.text$di:00008688
.text$di:00008688 ; Segment type: Pure code
.text$di:00008688 ; Segment permissions: Read/Execute
.text$di:00008688 _text$di        segment para public 'CODE' use32
.text$di:00008688                 assume cs:_text$di
.text$di:00008688                 ;org 8688h
.text$di:00008688 ; COMDAT (pick any)
.text$di:00008688                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00008688
.text$di:00008688 ; =============== S U B R O U T I N E =======================================
.text$di:00008688
.text$di:00008688 ; Attributes: bp-based frame
.text$di:00008688
.text$di:00008688 ; void __cdecl `dynamic initializer for 'public: static class std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
.text$di:00008688 ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc near
.text$di:00008688                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Generic_object$initializer$)(void)o
.text$di:00008688                 push    ebp
.text$di:00008689                 mov     ebp, esp
.text$di:0000868B                 mov     ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
.text$di:00008690                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$di:00008695                 push    offset ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:0000869A                 call    _atexit
.text$di:0000869F                 add     esp, 4
.text$di:000086A2                 pop     ebp
.text$di:000086A3                 retn
.text$di:000086A3 ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp
.text$di:000086A3
.text$di:000086A3 _text$di        ends
.text$di:000086A3
.text$di:000086A4 ; ===========================================================================
.text$di:000086A4
.text$di:000086A4 ; Segment type: Pure code
.text$di:000086A4 ; Segment permissions: Read/Execute
.text$di:000086A4 _text$di        segment para public 'CODE' use32
.text$di:000086A4                 assume cs:_text$di
.text$di:000086A4                 ;org 86A4h
.text$di:000086A4 ; COMDAT (pick any)
.text$di:000086A4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:000086A4
.text$di:000086A4 ; =============== S U B R O U T I N E =======================================
.text$di:000086A4
.text$di:000086A4 ; Attributes: bp-based frame
.text$di:000086A4
.text$di:000086A4 ; void __cdecl `dynamic initializer for 'public: static class std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
.text$di:000086A4 ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
.text$di:000086A4                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Iostream_object$initializer$)(void)o
.text$di:000086A4                 push    ebp
.text$di:000086A5                 mov     ebp, esp
.text$di:000086A7                 mov     ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
.text$di:000086AC                 call    ??0_Iostream_error_category@std@@QAE@XZ ; std::_Iostream_error_category::_Iostream_error_category(void)
.text$di:000086B1                 push    offset ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:000086B6                 call    _atexit
.text$di:000086BB                 add     esp, 4
.text$di:000086BE                 pop     ebp
.text$di:000086BF                 retn
.text$di:000086BF ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp
.text$di:000086BF
.text$di:000086BF _text$di        ends
.text$di:000086BF
.text$di:000086C0 ; ===========================================================================
.text$di:000086C0
.text$di:000086C0 ; Segment type: Pure code
.text$di:000086C0 ; Segment permissions: Read/Execute
.text$di:000086C0 _text$di        segment para public 'CODE' use32
.text$di:000086C0                 assume cs:_text$di
.text$di:000086C0                 ;org 86C0h
.text$di:000086C0 ; COMDAT (pick any)
.text$di:000086C0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:000086C0
.text$di:000086C0 ; =============== S U B R O U T I N E =======================================
.text$di:000086C0
.text$di:000086C0 ; Attributes: bp-based frame
.text$di:000086C0
.text$di:000086C0 ; void __cdecl `dynamic initializer for 'public: static class std::_System_error_category std::_Error_objects<int>::_System_object''(void)
.text$di:000086C0 ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
.text$di:000086C0                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_System_object$initializer$)(void)o
.text$di:000086C0                 push    ebp
.text$di:000086C1                 mov     ebp, esp
.text$di:000086C3                 mov     ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
.text$di:000086C8                 call    ??0_System_error_category@std@@QAE@XZ ; std::_System_error_category::_System_error_category(void)
.text$di:000086CD                 push    offset ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:000086D2                 call    _atexit
.text$di:000086D7                 add     esp, 4
.text$di:000086DA                 pop     ebp
.text$di:000086DB                 retn
.text$di:000086DB ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp
.text$di:000086DB
.text$di:000086DB _text$di        ends
.text$di:000086DB
.text$di:000086DC ; ===========================================================================
.text$di:000086DC
.text$di:000086DC ; Segment type: Pure code
.text$di:000086DC ; Segment permissions: Read/Execute
.text$di:000086DC _text$di        segment para public 'CODE' use32
.text$di:000086DC                 assume cs:_text$di
.text$di:000086DC                 ;org 86DCh
.text$di:000086DC ; COMDAT (pick any)
.text$di:000086DC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:000086DC
.text$di:000086DC ; =============== S U B R O U T I N E =======================================
.text$di:000086DC
.text$di:000086DC ; Attributes: bp-based frame
.text$di:000086DC
.text$di:000086DC ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::num_put<char, class std::back_insert_iterator<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>::id''(void)
.text$di:000086DC ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:000086DC                                         ; DATA XREF: .CRT$XCU:void (*std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id$initializer$)(void)o
.text$di:000086DC                 push    ebp
.text$di:000086DD                 mov     ebp, esp
.text$di:000086DF                 push    0               ; unsigned int
.text$di:000086E1                 mov     ecx, offset ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; this
.text$di:000086E6                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:000086EB                 pop     ebp
.text$di:000086EC                 retn
.text$di:000086EC ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ endp
.text$di:000086EC
.text$di:000086EC ; ---------------------------------------------------------------------------
.text$di:000086ED                 align 10h
.text$di:000086ED _text$di        ends
.text$di:000086ED
.text$di:000086F0 ; ===========================================================================
.text$di:000086F0
.text$di:000086F0 ; Segment type: Pure code
.text$di:000086F0 ; Segment permissions: Read/Execute
.text$di:000086F0 _text$di        segment para public 'CODE' use32
.text$di:000086F0                 assume cs:_text$di
.text$di:000086F0                 ;org 86F0h
.text$di:000086F0 ; COMDAT (pick any)
.text$di:000086F0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:000086F0
.text$di:000086F0 ; =============== S U B R O U T I N E =======================================
.text$di:000086F0
.text$di:000086F0 ; Attributes: bp-based frame
.text$di:000086F0
.text$di:000086F0 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::num_put<wchar_t, class std::back_insert_iterator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::id''(void)
.text$di:000086F0 ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:000086F0                                         ; DATA XREF: .CRT$XCU:void (*std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id$initializer$)(void)o
.text$di:000086F0                 push    ebp
.text$di:000086F1                 mov     ebp, esp
.text$di:000086F3                 push    0               ; unsigned int
.text$di:000086F5                 mov     ecx, offset ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; this
.text$di:000086FA                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:000086FF                 pop     ebp
.text$di:00008700                 retn
.text$di:00008700 ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00008700
.text$di:00008700 ; ---------------------------------------------------------------------------
.text$di:00008701                 align 4
.text$di:00008701 _text$di        ends
.text$di:00008701
.text$di:00008704 ; ===========================================================================
.text$di:00008704
.text$di:00008704 ; Segment type: Pure code
.text$di:00008704 ; Segment permissions: Read/Execute
.text$di:00008704 _text$di        segment para public 'CODE' use32
.text$di:00008704                 assume cs:_text$di
.text$di:00008704                 ;org 8704h
.text$di:00008704 ; COMDAT (pick any)
.text$di:00008704                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00008704
.text$di:00008704 ; =============== S U B R O U T I N E =======================================
.text$di:00008704
.text$di:00008704 ; Attributes: bp-based frame
.text$di:00008704
.text$di:00008704 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::numpunct<char>::id''(void)
.text$di:00008704 ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00008704                                         ; DATA XREF: .CRT$XCU:void (*std::numpunct<char>::id$initializer$)(void)o
.text$di:00008704                 push    ebp
.text$di:00008705                 mov     ebp, esp
.text$di:00008707                 push    0               ; unsigned int
.text$di:00008709                 mov     ecx, offset ?id@?$numpunct@D@std@@2V0locale@2@A ; this
.text$di:0000870E                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00008713                 pop     ebp
.text$di:00008714                 retn
.text$di:00008714 ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00008714
.text$di:00008714 ; ---------------------------------------------------------------------------
.text$di:00008715                 align 4
.text$di:00008715 _text$di        ends
.text$di:00008715
.text$di:00008718 ; ===========================================================================
.text$di:00008718
.text$di:00008718 ; Segment type: Pure code
.text$di:00008718 ; Segment permissions: Read/Execute
.text$di:00008718 _text$di        segment para public 'CODE' use32
.text$di:00008718                 assume cs:_text$di
.text$di:00008718                 ;org 8718h
.text$di:00008718 ; COMDAT (pick any)
.text$di:00008718                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00008718
.text$di:00008718 ; =============== S U B R O U T I N E =======================================
.text$di:00008718
.text$di:00008718 ; Attributes: bp-based frame
.text$di:00008718
.text$di:00008718 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::numpunct<wchar_t>::id''(void)
.text$di:00008718 ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00008718                                         ; DATA XREF: .CRT$XCU:void (*std::numpunct<wchar_t>::id$initializer$)(void)o
.text$di:00008718                 push    ebp
.text$di:00008719                 mov     ebp, esp
.text$di:0000871B                 push    0               ; unsigned int
.text$di:0000871D                 mov     ecx, offset ?id@?$numpunct@_W@std@@2V0locale@2@A ; this
.text$di:00008722                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00008727                 pop     ebp
.text$di:00008728                 retn
.text$di:00008728 ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00008728
.text$di:00008728 ; ---------------------------------------------------------------------------
.text$di:00008729                 align 4
.text$di:00008729 _text$di        ends
.text$di:00008729
.text$di:0000872C ; ===========================================================================
.text$di:0000872C
.text$di:0000872C ; Segment type: Pure code
.text$di:0000872C ; Segment permissions: Read/Execute
.text$di:0000872C _text$di        segment para public 'CODE' use32
.text$di:0000872C                 assume cs:_text$di
.text$di:0000872C                 ;org 872Ch
.text$di:0000872C ; COMDAT (pick any)
.text$di:0000872C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:0000872C
.text$di:0000872C ; =============== S U B R O U T I N E =======================================
.text$di:0000872C
.text$di:0000872C ; Attributes: bp-based frame
.text$di:0000872C
.text$di:0000872C ; void __cdecl `dynamic initializer for 'WDN_NOTIFY''(void)
.text$di:0000872C ??__EWDN_NOTIFY@@YAXXZ proc near        ; DATA XREF: .CRT$XCU:_WDN_NOTIFY$initializer$o
.text$di:0000872C                 push    ebp
.text$di:0000872D                 mov     ebp, esp
.text$di:0000872F                 push    offset $SG132116 ; "WDN_NOTIFY"
.text$di:00008734                 call    dword ptr ds:__imp__RegisterWindowMessageW@4 ; RegisterWindowMessageW(x)
.text$di:0000873A                 mov     ds:?WDN_NOTIFY@@3IB, eax ; uint const WDN_NOTIFY
.text$di:0000873F                 pop     ebp
.text$di:00008740                 retn
.text$di:00008740 ??__EWDN_NOTIFY@@YAXXZ endp
.text$di:00008740
.text$di:00008740 ; ---------------------------------------------------------------------------
.text$di:00008741                 align 4
.text$di:00008741 _text$di        ends
.text$di:00008741
.text$di:00008744 ; ===========================================================================
.text$di:00008744
.text$di:00008744 ; Segment type: Pure code
.text$di:00008744 ; Segment permissions: Read/Execute
.text$di:00008744 _text$di        segment para public 'CODE' use32
.text$di:00008744                 assume cs:_text$di
.text$di:00008744                 ;org 8744h
.text$di:00008744 ; COMDAT (pick any)
.text$di:00008744                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00008744
.text$di:00008744 ; =============== S U B R O U T I N E =======================================
.text$di:00008744
.text$di:00008744 ; Attributes: bp-based frame
.text$di:00008744
.text$di:00008744 ; void __cdecl `dynamic initializer for 'WindowsDlgMap''(void)
.text$di:00008744 ??__EWindowsDlgMap@@YAXXZ proc near     ; DATA XREF: .CRT$XCU:_WindowsDlgMap$initializer$o
.text$di:00008744                 push    ebp
.text$di:00008745                 mov     ebp, esp
.text$di:00008747                 push    80008h
.text$di:0000874C                 push    0
.text$di:0000874E                 push    13h
.text$di:00008750                 mov     ecx, offset ?WindowsDlgMap@@3PAVWINRECT@@A ; WINRECT * WindowsDlgMap
.text$di:00008755                 call    ??0WINRECT@@QAE@GHJ@Z ; WINRECT::WINRECT(ushort,int,long)
.text$di:0000875A                 push    0
.text$di:0000875C                 push    0
.text$di:0000875E                 push    23h ; '#'
.text$di:00008760                 mov     ecx, offset unk_18C
.text$di:00008765                 call    ??0WINRECT@@QAE@GHJ@Z ; WINRECT::WINRECT(ushort,int,long)
.text$di:0000876A                 push    0
.text$di:0000876C                 push    0
.text$di:0000876E                 push    13h
.text$di:00008770                 mov     ecx, offset unk_1B0
.text$di:00008775                 call    ??0WINRECT@@QAE@GHJ@Z ; WINRECT::WINRECT(ushort,int,long)
.text$di:0000877A                 push    0
.text$di:0000877C                 push    1B59h
.text$di:00008781                 push    3
.text$di:00008783                 mov     ecx, offset unk_1D4
.text$di:00008788                 call    ??0WINRECT@@QAE@GHJ@Z ; WINRECT::WINRECT(ushort,int,long)
.text$di:0000878D                 push    14h
.text$di:0000878F                 push    0FFFFFFFFh
.text$di:00008791                 push    1
.text$di:00008793                 mov     ecx, offset unk_1F8
.text$di:00008798                 call    ??0WINRECT@@QAE@GHJ@Z ; WINRECT::WINRECT(ushort,int,long)
.text$di:0000879D                 push    0
.text$di:0000879F                 push    0FFFFFFFFh
.text$di:000087A1                 push    0F0h ; '='
.text$di:000087A6                 mov     ecx, offset unk_21C
.text$di:000087AB                 call    ??0WINRECT@@QAE@GHJ@Z ; WINRECT::WINRECT(ushort,int,long)
.text$di:000087B0                 push    0Ch
.text$di:000087B2                 push    0FFFFFFFFh
.text$di:000087B4                 push    1
.text$di:000087B6                 mov     ecx, offset unk_240
.text$di:000087BB                 call    ??0WINRECT@@QAE@GHJ@Z ; WINRECT::WINRECT(ushort,int,long)
.text$di:000087C0                 push    0
.text$di:000087C2                 push    0
.text$di:000087C4                 push    14h
.text$di:000087C6                 mov     ecx, offset unk_264
.text$di:000087CB                 call    ??0WINRECT@@QAE@GHJ@Z ; WINRECT::WINRECT(ushort,int,long)
.text$di:000087D0                 push    0Ch
.text$di:000087D2                 push    0FFFFFFFFh
.text$di:000087D4                 push    1
.text$di:000087D6                 mov     ecx, offset unk_288
.text$di:000087DB                 call    ??0WINRECT@@QAE@GHJ@Z ; WINRECT::WINRECT(ushort,int,long)
.text$di:000087E0                 push    0
.text$di:000087E2                 push    1
.text$di:000087E4                 push    4
.text$di:000087E6                 mov     ecx, offset unk_2AC
.text$di:000087EB                 call    ??0WINRECT@@QAE@GHJ@Z ; WINRECT::WINRECT(ushort,int,long)
.text$di:000087F0                 push    0FFFFFFF4h
.text$di:000087F2                 push    0FFFFFFFFh
.text$di:000087F4                 push    1
.text$di:000087F6                 mov     ecx, offset unk_2D0
.text$di:000087FB                 call    ??0WINRECT@@QAE@GHJ@Z ; WINRECT::WINRECT(ushort,int,long)
.text$di:00008800                 push    0
.text$di:00008802                 push    1B5Ah
.text$di:00008807                 push    4
.text$di:00008809                 mov     ecx, offset unk_2F4
.text$di:0000880E                 call    ??0WINRECT@@QAE@GHJ@Z ; WINRECT::WINRECT(ushort,int,long)
.text$di:00008813                 push    0FFFFFFF4h
.text$di:00008815                 push    0FFFFFFFFh
.text$di:00008817                 push    1
.text$di:00008819                 mov     ecx, offset unk_318
.text$di:0000881E                 call    ??0WINRECT@@QAE@GHJ@Z ; WINRECT::WINRECT(ushort,int,long)
.text$di:00008823                 push    0
.text$di:00008825                 push    1B5Bh
.text$di:0000882A                 push    4
.text$di:0000882C                 mov     ecx, offset unk_33C
.text$di:00008831                 call    ??0WINRECT@@QAE@GHJ@Z ; WINRECT::WINRECT(ushort,int,long)
.text$di:00008836                 push    0FFFFFFF4h
.text$di:00008838                 push    0FFFFFFFFh
.text$di:0000883A                 push    1
.text$di:0000883C                 mov     ecx, offset unk_360
.text$di:00008841                 call    ??0WINRECT@@QAE@GHJ@Z ; WINRECT::WINRECT(ushort,int,long)
.text$di:00008846                 push    0
.text$di:00008848                 push    1B5Ch
.text$di:0000884D                 push    4
.text$di:0000884F                 mov     ecx, offset unk_384
.text$di:00008854                 call    ??0WINRECT@@QAE@GHJ@Z ; WINRECT::WINRECT(ushort,int,long)
.text$di:00008859                 push    0
.text$di:0000885B                 push    0FFFFFFFFh
.text$di:0000885D                 push    3
.text$di:0000885F                 mov     ecx, offset unk_3A8
.text$di:00008864                 call    ??0WINRECT@@QAE@GHJ@Z ; WINRECT::WINRECT(ushort,int,long)
.text$di:00008869                 push    0
.text$di:0000886B                 push    2
.text$di:0000886D                 push    4
.text$di:0000886F                 mov     ecx, offset unk_3CC
.text$di:00008874                 call    ??0WINRECT@@QAE@GHJ@Z ; WINRECT::WINRECT(ushort,int,long)
.text$di:00008879                 push    0
.text$di:0000887B                 push    0FFFFFFFFh
.text$di:0000887D                 push    0F0h ; '='
.text$di:00008882                 mov     ecx, offset unk_3F0
.text$di:00008887                 call    ??0WINRECT@@QAE@GHJ@Z ; WINRECT::WINRECT(ushort,int,long)
.text$di:0000888C                 push    0
.text$di:0000888E                 push    0FFFFFFFFh
.text$di:00008890                 push    0F0h ; '='
.text$di:00008895                 mov     ecx, offset unk_414
.text$di:0000889A                 call    ??0WINRECT@@QAE@GHJ@Z ; WINRECT::WINRECT(ushort,int,long)
.text$di:0000889F                 push    0
.text$di:000088A1                 push    0FFFFFFFFh
.text$di:000088A3                 push    0F0h ; '='
.text$di:000088A8                 mov     ecx, offset unk_438
.text$di:000088AD                 call    ??0WINRECT@@QAE@GHJ@Z ; WINRECT::WINRECT(ushort,int,long)
.text$di:000088B2                 push    0
.text$di:000088B4                 push    0FFFFFFFFh
.text$di:000088B6                 push    0
.text$di:000088B8                 mov     ecx, offset unk_45C
.text$di:000088BD                 call    ??0WINRECT@@QAE@GHJ@Z ; WINRECT::WINRECT(ushort,int,long)
.text$di:000088C2                 pop     ebp
.text$di:000088C3                 retn
.text$di:000088C3 ??__EWindowsDlgMap@@YAXXZ endp
.text$di:000088C3
.text$di:000088C3 _text$di        ends
.text$di:000088C3
.text$di:000088C4 ; ===========================================================================
.text$di:000088C4
.text$di:000088C4 ; Segment type: Pure code
.text$di:000088C4 ; Segment permissions: Read/Execute
.text$di:000088C4 _text$di        segment para public 'CODE' use32
.text$di:000088C4                 assume cs:_text$di
.text$di:000088C4                 ;org 88C4h
.text$di:000088C4 ; COMDAT (pick any)
.text$di:000088C4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:000088C4
.text$di:000088C4 ; =============== S U B R O U T I N E =======================================
.text$di:000088C4
.text$di:000088C4 ; Attributes: bp-based frame
.text$di:000088C4
.text$di:000088C4 ; void __cdecl std::`dynamic initializer for '_Tuple_alloc''(void)
.text$di:000088C4 ??__E_Tuple_alloc@std@@YAXXZ proc near  ; DATA XREF: .CRT$XCU:__Tuple_alloc$initializer$o
.text$di:000088C4
.text$di:000088C4 var_1           = byte ptr -1
.text$di:000088C4
.text$di:000088C4                 push    ebp
.text$di:000088C5                 mov     ebp, esp
.text$di:000088C7                 push    ecx
.text$di:000088C8                 xor     eax, eax
.text$di:000088CA                 mov     [ebp+var_1], al
.text$di:000088CD                 mov     esp, ebp
.text$di:000088CF                 pop     ebp
.text$di:000088D0                 retn
.text$di:000088D0 ??__E_Tuple_alloc@std@@YAXXZ endp
.text$di:000088D0
.text$di:000088D0 ; ---------------------------------------------------------------------------
.text$di:000088D1                 align 4
.text$di:000088D1 _text$di        ends
.text$di:000088D1
.text$di:000088D4 ; ===========================================================================
.text$di:000088D4
.text$di:000088D4 ; Segment type: Pure code
.text$di:000088D4 ; Segment permissions: Read/Execute
.text$di:000088D4 _text$di        segment para public 'CODE' use32
.text$di:000088D4                 assume cs:_text$di
.text$di:000088D4                 ;org 88D4h
.text$di:000088D4 ; COMDAT (pick any)
.text$di:000088D4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:000088D4
.text$di:000088D4 ; =============== S U B R O U T I N E =======================================
.text$di:000088D4
.text$di:000088D4 ; Attributes: bp-based frame
.text$di:000088D4
.text$di:000088D4 ; void __cdecl std::`dynamic initializer for 'allocator_arg''(void)
.text$di:000088D4 ??__Eallocator_arg@std@@YAXXZ proc near ; DATA XREF: .CRT$XCU:_allocator_arg$initializer$o
.text$di:000088D4
.text$di:000088D4 var_1           = byte ptr -1
.text$di:000088D4
.text$di:000088D4                 push    ebp
.text$di:000088D5                 mov     ebp, esp
.text$di:000088D7                 push    ecx
.text$di:000088D8                 xor     eax, eax
.text$di:000088DA                 mov     [ebp+var_1], al
.text$di:000088DD                 mov     esp, ebp
.text$di:000088DF                 pop     ebp
.text$di:000088E0                 retn
.text$di:000088E0 ??__Eallocator_arg@std@@YAXXZ endp
.text$di:000088E0
.text$di:000088E0 ; ---------------------------------------------------------------------------
.text$di:000088E1                 align 4
.text$di:000088E1 _text$di        ends
.text$di:000088E1
.text$di:000088E4 ; ===========================================================================
.text$di:000088E4
.text$di:000088E4 ; Segment type: Pure code
.text$di:000088E4 ; Segment permissions: Read/Execute
.text$di:000088E4 _text$di        segment para public 'CODE' use32
.text$di:000088E4                 assume cs:_text$di
.text$di:000088E4                 ;org 88E4h
.text$di:000088E4 ; COMDAT (pick any)
.text$di:000088E4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:000088E4
.text$di:000088E4 ; =============== S U B R O U T I N E =======================================
.text$di:000088E4
.text$di:000088E4 ; Attributes: bp-based frame
.text$di:000088E4
.text$di:000088E4 ; void __cdecl std::`dynamic initializer for 'ignore''(void)
.text$di:000088E4 ??__Eignore@std@@YAXXZ proc near        ; DATA XREF: .CRT$XCU:_ignore$initializer$o
.text$di:000088E4                 push    ebp
.text$di:000088E5                 mov     ebp, esp
.text$di:000088E7                 mov     ecx, offset _ignore ; this
.text$di:000088EC                 call    ??0_Ignore@std@@QAE@XZ ; std::_Ignore::_Ignore(void)
.text$di:000088F1                 pop     ebp
.text$di:000088F2                 retn
.text$di:000088F2 ??__Eignore@std@@YAXXZ endp
.text$di:000088F2
.text$di:000088F2 ; ---------------------------------------------------------------------------
.text$di:000088F3                 align 4
.text$di:000088F3 _text$di        ends
.text$di:000088F3
.text$di:000088F4 ; ===========================================================================
.text$di:000088F4
.text$di:000088F4 ; Segment type: Pure code
.text$di:000088F4 ; Segment permissions: Read/Execute
.text$di:000088F4 _text$di        segment para public 'CODE' use32
.text$di:000088F4                 assume cs:_text$di
.text$di:000088F4                 ;org 88F4h
.text$di:000088F4 ; COMDAT (pick any)
.text$di:000088F4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:000088F4
.text$di:000088F4 ; =============== S U B R O U T I N E =======================================
.text$di:000088F4
.text$di:000088F4 ; Attributes: bp-based frame
.text$di:000088F4
.text$di:000088F4 ; void __cdecl std::`dynamic initializer for 'piecewise_construct''(void)
.text$di:000088F4 ??__Epiecewise_construct@std@@YAXXZ proc near
.text$di:000088F4                                         ; DATA XREF: .CRT$XCU:_piecewise_construct$initializer$o
.text$di:000088F4
.text$di:000088F4 var_1           = byte ptr -1
.text$di:000088F4
.text$di:000088F4                 push    ebp
.text$di:000088F5                 mov     ebp, esp
.text$di:000088F7                 push    ecx
.text$di:000088F8                 xor     eax, eax
.text$di:000088FA                 mov     [ebp+var_1], al
.text$di:000088FD                 mov     esp, ebp
.text$di:000088FF                 pop     ebp
.text$di:00008900                 retn
.text$di:00008900 ??__Epiecewise_construct@std@@YAXXZ endp
.text$di:00008900
.text$di:00008900 ; ---------------------------------------------------------------------------
.text$di:00008901                 align 4
.text$di:00008901 _text$di        ends
.text$di:00008901
.text$yd:00008904 ; ===========================================================================
.text$yd:00008904
.text$yd:00008904 ; Segment type: Pure code
.text$yd:00008904 ; Segment permissions: Read/Execute
.text$yd:00008904 _text$yd        segment para public 'CODE' use32
.text$yd:00008904                 assume cs:_text$yd
.text$yd:00008904                 ;org 8904h
.text$yd:00008904 ; COMDAT (pick any)
.text$yd:00008904                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$yd:00008904
.text$yd:00008904 ; =============== S U B R O U T I N E =======================================
.text$yd:00008904
.text$yd:00008904 ; Attributes: bp-based frame
.text$yd:00008904
.text$yd:00008904 ; void __cdecl `dynamic atexit destructor for 'public: static std::_Generic_error_category std::_Error_objects<int>::_Generic_object''()
.text$yd:00008904 ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc near
.text$yd:00008904                                         ; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+Do
.text$yd:00008904                 push    ebp
.text$yd:00008905                 mov     ebp, esp
.text$yd:00008907                 mov     ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
.text$yd:0000890C                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$yd:00008911                 pop     ebp
.text$yd:00008912                 retn
.text$yd:00008912 ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp
.text$yd:00008912
.text$yd:00008912 ; ---------------------------------------------------------------------------
.text$yd:00008913                 align 4
.text$yd:00008913 _text$yd        ends
.text$yd:00008913
.text$yd:00008914 ; ===========================================================================
.text$yd:00008914
.text$yd:00008914 ; Segment type: Pure code
.text$yd:00008914 ; Segment permissions: Read/Execute
.text$yd:00008914 _text$yd        segment para public 'CODE' use32
.text$yd:00008914                 assume cs:_text$yd
.text$yd:00008914                 ;org 8914h
.text$yd:00008914 ; COMDAT (pick any)
.text$yd:00008914                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$yd:00008914
.text$yd:00008914 ; =============== S U B R O U T I N E =======================================
.text$yd:00008914
.text$yd:00008914 ; Attributes: bp-based frame
.text$yd:00008914
.text$yd:00008914 ; void __cdecl `dynamic atexit destructor for 'public: static std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''()
.text$yd:00008914 ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
.text$yd:00008914                                         ; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+Do
.text$yd:00008914                 push    ebp
.text$yd:00008915                 mov     ebp, esp
.text$yd:00008917                 mov     ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
.text$yd:0000891C                 call    ??1_Iostream_error_category@std@@UAE@XZ ; std::_Iostream_error_category::~_Iostream_error_category(void)
.text$yd:00008921                 pop     ebp
.text$yd:00008922                 retn
.text$yd:00008922 ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp
.text$yd:00008922
.text$yd:00008922 ; ---------------------------------------------------------------------------
.text$yd:00008923                 align 4
.text$yd:00008923 _text$yd        ends
.text$yd:00008923
.text$yd:00008924 ; ===========================================================================
.text$yd:00008924
.text$yd:00008924 ; Segment type: Pure code
.text$yd:00008924 ; Segment permissions: Read/Execute
.text$yd:00008924 _text$yd        segment para public 'CODE' use32
.text$yd:00008924                 assume cs:_text$yd
.text$yd:00008924                 ;org 8924h
.text$yd:00008924 ; COMDAT (pick any)
.text$yd:00008924                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$yd:00008924
.text$yd:00008924 ; =============== S U B R O U T I N E =======================================
.text$yd:00008924
.text$yd:00008924 ; Attributes: bp-based frame
.text$yd:00008924
.text$yd:00008924 ; void __cdecl `dynamic atexit destructor for 'public: static std::_System_error_category std::_Error_objects<int>::_System_object''()
.text$yd:00008924 ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
.text$yd:00008924                                         ; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+Do
.text$yd:00008924                 push    ebp
.text$yd:00008925                 mov     ebp, esp
.text$yd:00008927                 mov     ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
.text$yd:0000892C                 call    ??1_System_error_category@std@@UAE@XZ ; std::_System_error_category::~_System_error_category(void)
.text$yd:00008931                 pop     ebp
.text$yd:00008932                 retn
.text$yd:00008932 ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp
.text$yd:00008932
.text$yd:00008932 ; ---------------------------------------------------------------------------
.text$yd:00008933                 align 4
.text$yd:00008933 _text$yd        ends
.text$yd:00008933
.text$mn:00008934 ; ===========================================================================
.text$mn:00008934
.text$mn:00008934 ; Segment type: Pure code
.text$mn:00008934 ; Segment permissions: Read/Execute
.text$mn:00008934 _text$mn        segment para public 'CODE' use32
.text$mn:00008934                 assume cs:_text$mn
.text$mn:00008934                 ;org 8934h
.text$mn:00008934 ; COMDAT (pick any)
.text$mn:00008934                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008934
.text$mn:00008934 ; =============== S U B R O U T I N E =======================================
.text$mn:00008934
.text$mn:00008934 ; Attributes: bp-based frame
.text$mn:00008934
.text$mn:00008934 ; void __thiscall CWinMgr::CalcLayout(CWinMgr *this, HWND)
.text$mn:00008934                 public ?CalcLayout@CWinMgr@@QAEXPAUHWND__@@@Z
.text$mn:00008934 ?CalcLayout@CWinMgr@@QAEXPAUHWND__@@@Z proc near
.text$mn:00008934                                         ; CODE XREF: WindowsDlg::onInitDialog(void)+9Dp
.text$mn:00008934
.text$mn:00008934 var_18          = dword ptr -18h
.text$mn:00008934 Rect            = tagRECT ptr -14h
.text$mn:00008934 var_4           = dword ptr -4
.text$mn:00008934 hWnd            = dword ptr  8
.text$mn:00008934
.text$mn:00008934                 push    ebp
.text$mn:00008935                 mov     ebp, esp
.text$mn:00008937                 sub     esp, 18h
.text$mn:0000893A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000893F                 xor     eax, ebp
.text$mn:00008941                 mov     [ebp+var_4], eax
.text$mn:00008944                 mov     [ebp+var_18], ecx
.text$mn:00008947                 cmp     [ebp+hWnd], 0
.text$mn:0000894B                 jnz     short loc_8964
.text$mn:0000894D                 push    0EFh ; 'n'      ; Line
.text$mn:00008952                 push    offset ??_C@_1KO@LJAFCIDL@?$AAc?$AA?3?$AA?2?$AAw?$AAo?$AAr?$AAk?$AAs?$AAp?$AAa?$AAc?$AAe?$AA?2?$AAn?$AAo?$AAt?$AAe?$AAp?$AAa?$AAd?$AA?9?$AAp?$AAl?$AAu?$AAs?$AA?9?$AAp?$AAl?$AAu?$AAs?$AA?9?$AA6@ ; "c:\\workspace\\notepad-plus-plus-6.7.9."...
.text$mn:00008957                 push    offset ??_C@_19HBMCHKM@?$AAh?$AAW?$AAn?$AAd?$AA?$AA@ ; "hWnd"
.text$mn:0000895C                 call    __wassert
.text$mn:00008961 ; ---------------------------------------------------------------------------
.text$mn:00008961                 add     esp, 0Ch
.text$mn:00008964
.text$mn:00008964 loc_8964:                               ; CODE XREF: CWinMgr::CalcLayout(HWND__ *)+17j
.text$mn:00008964                 lea     ecx, [ebp+Rect]
.text$mn:00008967                 push    ecx             ; lpRect
.text$mn:00008968                 mov     edx, [ebp+hWnd]
.text$mn:0000896B                 push    edx             ; hWnd
.text$mn:0000896C                 call    dword ptr ds:__imp__GetClientRect@8 ; GetClientRect(x,x)
.text$mn:00008972                 mov     eax, [ebp+hWnd]
.text$mn:00008975                 push    eax             ; HWND
.text$mn:00008976                 sub     esp, 10h
.text$mn:00008979                 mov     ecx, esp
.text$mn:0000897B                 mov     edx, [ebp+Rect.left]
.text$mn:0000897E                 mov     [ecx], edx
.text$mn:00008980                 mov     eax, [ebp+Rect.top]
.text$mn:00008983                 mov     [ecx+4], eax
.text$mn:00008986                 mov     edx, [ebp+Rect.right]
.text$mn:00008989                 mov     [ecx+8], edx
.text$mn:0000898C                 mov     eax, [ebp+Rect.bottom]
.text$mn:0000898F                 mov     [ecx+0Ch], eax
.text$mn:00008992                 mov     ecx, [ebp+var_18] ; this
.text$mn:00008995                 call    ?CalcLayout@CWinMgr@@QAEXUtagRECT@@PAUHWND__@@@Z ; CWinMgr::CalcLayout(tagRECT,HWND__ *)
.text$mn:0000899A                 mov     ecx, [ebp+var_4]
.text$mn:0000899D                 xor     ecx, ebp
.text$mn:0000899F                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:000089A4                 mov     esp, ebp
.text$mn:000089A6                 pop     ebp
.text$mn:000089A7                 retn    4
.text$mn:000089A7 ?CalcLayout@CWinMgr@@QAEXPAUHWND__@@@Z endp
.text$mn:000089A7
.text$mn:000089A7 ; ---------------------------------------------------------------------------
.text$mn:000089AA                 align 4
.text$mn:000089AA _text$mn        ends
.text$mn:000089AA
.text$mn:000089AC ; ===========================================================================
.text$mn:000089AC
.text$mn:000089AC ; Segment type: Pure code
.text$mn:000089AC ; Segment permissions: Read/Execute
.text$mn:000089AC _text$mn        segment para public 'CODE' use32
.text$mn:000089AC                 assume cs:_text$mn
.text$mn:000089AC                 ;org 89ACh
.text$mn:000089AC ; COMDAT (pick any)
.text$mn:000089AC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000089AC
.text$mn:000089AC ; =============== S U B R O U T I N E =======================================
.text$mn:000089AC
.text$mn:000089AC ; Attributes: bp-based frame
.text$mn:000089AC
.text$mn:000089AC ; void __thiscall CWinMgr::CalcLayout(CWinMgr *this, struct tagRECT, HWND)
.text$mn:000089AC                 public ?CalcLayout@CWinMgr@@QAEXUtagRECT@@PAUHWND__@@@Z
.text$mn:000089AC ?CalcLayout@CWinMgr@@QAEXUtagRECT@@PAUHWND__@@@Z proc near
.text$mn:000089AC                                         ; CODE XREF: CWinMgr::CalcLayout(HWND__ *)+61p
.text$mn:000089AC
.text$mn:000089AC var_4           = dword ptr -4
.text$mn:000089AC arg_0           = tagRECT ptr  8
.text$mn:000089AC arg_10          = dword ptr  18h
.text$mn:000089AC
.text$mn:000089AC                 push    ebp
.text$mn:000089AD                 mov     ebp, esp
.text$mn:000089AF                 push    ecx
.text$mn:000089B0                 mov     [ebp+var_4], ecx
.text$mn:000089B3                 mov     eax, [ebp+var_4]
.text$mn:000089B6                 cmp     dword ptr [eax+4], 0
.text$mn:000089BA                 jnz     short loc_89D3
.text$mn:000089BC                 push    0FDh ; ''      ; Line
.text$mn:000089C1                 push    offset ??_C@_1KO@LJAFCIDL@?$AAc?$AA?3?$AA?2?$AAw?$AAo?$AAr?$AAk?$AAs?$AAp?$AAa?$AAc?$AAe?$AA?2?$AAn?$AAo?$AAt?$AAe?$AAp?$AAa?$AAd?$AA?9?$AAp?$AAl?$AAu?$AAs?$AA?9?$AAp?$AAl?$AAu?$AAs?$AA?9?$AA6@ ; "c:\\workspace\\notepad-plus-plus-6.7.9."...
.text$mn:000089C6                 push    offset ??_C@_1M@JJLBEALK@?$AAm?$AA_?$AAm?$AAa?$AAp?$AA?$AA@ ; "m_map"
.text$mn:000089CB                 call    __wassert
.text$mn:000089D0 ; ---------------------------------------------------------------------------
.text$mn:000089D0                 add     esp, 0Ch
.text$mn:000089D3
.text$mn:000089D3 loc_89D3:                               ; CODE XREF: CWinMgr::CalcLayout(tagRECT,HWND__ *)+Ej
.text$mn:000089D3                 lea     edx, [ebp+arg_0]
.text$mn:000089D6                 push    edx             ; struct tagRECT *
.text$mn:000089D7                 mov     eax, [ebp+var_4]
.text$mn:000089DA                 mov     ecx, [eax+4]    ; this
.text$mn:000089DD                 call    ?SetRect@WINRECT@@QAEXABUtagRECT@@@Z ; WINRECT::SetRect(tagRECT const &)
.text$mn:000089E2                 mov     ecx, [ebp+arg_10]
.text$mn:000089E5                 push    ecx
.text$mn:000089E6                 mov     edx, [ebp+var_4]
.text$mn:000089E9                 mov     eax, [edx+4]
.text$mn:000089EC                 push    eax
.text$mn:000089ED                 mov     ecx, [ebp+var_4]
.text$mn:000089F0                 mov     edx, [ecx]
.text$mn:000089F2                 mov     ecx, [ebp+var_4]
.text$mn:000089F5                 mov     eax, [edx+10h]
.text$mn:000089F8                 call    eax
.text$mn:000089FA                 mov     esp, ebp
.text$mn:000089FC                 pop     ebp
.text$mn:000089FD                 retn    14h
.text$mn:000089FD ?CalcLayout@CWinMgr@@QAEXUtagRECT@@PAUHWND__@@@Z endp
.text$mn:000089FD
.text$mn:000089FD _text$mn        ends
.text$mn:000089FD
.text$mn:00008A00 ; ===========================================================================
.text$mn:00008A00
.text$mn:00008A00 ; Segment type: Pure code
.text$mn:00008A00 ; Segment permissions: Read/Execute
.text$mn:00008A00 _text$mn        segment para public 'CODE' use32
.text$mn:00008A00                 assume cs:_text$mn
.text$mn:00008A00                 ;org 8A00h
.text$mn:00008A00 ; COMDAT (pick any)
.text$mn:00008A00                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008A00
.text$mn:00008A00 ; =============== S U B R O U T I N E =======================================
.text$mn:00008A00
.text$mn:00008A00 ; Attributes: bp-based frame
.text$mn:00008A00
.text$mn:00008A00 ; const char *__thiscall TiXmlDeclarationA::Encoding(TiXmlDeclarationA *__hidden this)
.text$mn:00008A00                 public ?Encoding@TiXmlDeclarationA@@QBEPBDXZ
.text$mn:00008A00 ?Encoding@TiXmlDeclarationA@@QBEPBDXZ proc near
.text$mn:00008A00                                         ; CODE XREF: WindowsDlg::changeDlgLang(void)+4Dp
.text$mn:00008A00
.text$mn:00008A00 var_4           = dword ptr -4
.text$mn:00008A00
.text$mn:00008A00                 push    ebp
.text$mn:00008A01                 mov     ebp, esp
.text$mn:00008A03                 push    ecx
.text$mn:00008A04                 mov     [ebp+var_4], ecx
.text$mn:00008A07                 mov     ecx, [ebp+var_4]
.text$mn:00008A0A                 add     ecx, 60h ; '`'
.text$mn:00008A0D                 call    ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::c_str(void)
.text$mn:00008A12                 mov     esp, ebp
.text$mn:00008A14                 pop     ebp
.text$mn:00008A15                 retn
.text$mn:00008A15 ?Encoding@TiXmlDeclarationA@@QBEPBDXZ endp
.text$mn:00008A15
.text$mn:00008A15 ; ---------------------------------------------------------------------------
.text$mn:00008A16                 align 4
.text$mn:00008A16 _text$mn        ends
.text$mn:00008A16
.text$mn:00008A18 ; ===========================================================================
.text$mn:00008A18
.text$mn:00008A18 ; Segment type: Pure code
.text$mn:00008A18 ; Segment permissions: Read/Execute
.text$mn:00008A18 _text$mn        segment para public 'CODE' use32
.text$mn:00008A18                 assume cs:_text$mn
.text$mn:00008A18                 ;org 8A18h
.text$mn:00008A18 ; COMDAT (pick any)
.text$mn:00008A18                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008A18
.text$mn:00008A18 ; =============== S U B R O U T I N E =======================================
.text$mn:00008A18
.text$mn:00008A18 ; Attributes: bp-based frame
.text$mn:00008A18
.text$mn:00008A18 ; struct TiXmlNodeA *__thiscall TiXmlNodeA::FirstChild(TiXmlNodeA *__hidden this)
.text$mn:00008A18                 public ?FirstChild@TiXmlNodeA@@QBEPAV1@XZ
.text$mn:00008A18 ?FirstChild@TiXmlNodeA@@QBEPAV1@XZ proc near
.text$mn:00008A18                                         ; CODE XREF: WindowsDlg::changeDlgLang(void)+35p
.text$mn:00008A18
.text$mn:00008A18 var_4           = dword ptr -4
.text$mn:00008A18
.text$mn:00008A18                 push    ebp
.text$mn:00008A19                 mov     ebp, esp
.text$mn:00008A1B                 push    ecx
.text$mn:00008A1C                 mov     [ebp+var_4], ecx
.text$mn:00008A1F                 mov     eax, [ebp+var_4]
.text$mn:00008A22                 mov     eax, [eax+14h]
.text$mn:00008A25                 mov     esp, ebp
.text$mn:00008A27                 pop     ebp
.text$mn:00008A28                 retn
.text$mn:00008A28 ?FirstChild@TiXmlNodeA@@QBEPAV1@XZ endp
.text$mn:00008A28
.text$mn:00008A28 ; ---------------------------------------------------------------------------
.text$mn:00008A29                 align 4
.text$mn:00008A29 _text$mn        ends
.text$mn:00008A29
.text$mn:00008A2C ; ===========================================================================
.text$mn:00008A2C
.text$mn:00008A2C ; Segment type: Pure code
.text$mn:00008A2C ; Segment permissions: Read/Execute
.text$mn:00008A2C _text$mn        segment para public 'CODE' use32
.text$mn:00008A2C                 assume cs:_text$mn
.text$mn:00008A2C                 ;org 8A2Ch
.text$mn:00008A2C ; COMDAT (pick any)
.text$mn:00008A2C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008A2C
.text$mn:00008A2C ; =============== S U B R O U T I N E =======================================
.text$mn:00008A2C
.text$mn:00008A2C ; Attributes: bp-based frame
.text$mn:00008A2C
.text$mn:00008A2C ; struct tagRECT *__thiscall CWinMgr::GetRect(CWinMgr *this, struct tagRECT *retstr, unsigned int)
.text$mn:00008A2C                 public ?GetRect@CWinMgr@@QAE?AUtagRECT@@I@Z
.text$mn:00008A2C ?GetRect@CWinMgr@@QAE?AUtagRECT@@I@Z proc near
.text$mn:00008A2C                                         ; CODE XREF: WindowsDlg::onInitDialog(void)+31p
.text$mn:00008A2C                                         ; WindowsDlg::onInitDialog(void)+63p
.text$mn:00008A2C
.text$mn:00008A2C var_4           = dword ptr -4
.text$mn:00008A2C retstr          = dword ptr  8
.text$mn:00008A2C arg_4           = dword ptr  0Ch
.text$mn:00008A2C
.text$mn:00008A2C                 push    ebp
.text$mn:00008A2D                 mov     ebp, esp
.text$mn:00008A2F                 push    ecx
.text$mn:00008A30                 mov     [ebp+var_4], ecx
.text$mn:00008A33                 mov     eax, [ebp+arg_4]
.text$mn:00008A36                 push    eax             ; int
.text$mn:00008A37                 mov     ecx, [ebp+var_4] ; this
.text$mn:00008A3A                 call    ?FindRect@CWinMgr@@QAEPAVWINRECT@@H@Z ; CWinMgr::FindRect(int)
.text$mn:00008A3F                 mov     ecx, eax        ; this
.text$mn:00008A41                 call    ?GetRect@WINRECT@@QAEAAUtagRECT@@XZ ; WINRECT::GetRect(void)
.text$mn:00008A46                 mov     ecx, [ebp+retstr]
.text$mn:00008A49                 mov     edx, [eax]
.text$mn:00008A4B                 mov     [ecx], edx
.text$mn:00008A4D                 mov     edx, [eax+4]
.text$mn:00008A50                 mov     [ecx+4], edx
.text$mn:00008A53                 mov     edx, [eax+8]
.text$mn:00008A56                 mov     [ecx+8], edx
.text$mn:00008A59                 mov     eax, [eax+0Ch]
.text$mn:00008A5C                 mov     [ecx+0Ch], eax
.text$mn:00008A5F                 mov     eax, [ebp+retstr]
.text$mn:00008A62                 mov     esp, ebp
.text$mn:00008A64                 pop     ebp
.text$mn:00008A65                 retn    8
.text$mn:00008A65 ?GetRect@CWinMgr@@QAE?AUtagRECT@@I@Z endp
.text$mn:00008A65
.text$mn:00008A65 _text$mn        ends
.text$mn:00008A65
.text$mn:00008A68 ; ===========================================================================
.text$mn:00008A68
.text$mn:00008A68 ; Segment type: Pure code
.text$mn:00008A68 ; Segment permissions: Read/Execute
.text$mn:00008A68 _text$mn        segment para public 'CODE' use32
.text$mn:00008A68                 assume cs:_text$mn
.text$mn:00008A68                 ;org 8A68h
.text$mn:00008A68 ; COMDAT (pick any)
.text$mn:00008A68                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008A68
.text$mn:00008A68 ; =============== S U B R O U T I N E =======================================
.text$mn:00008A68
.text$mn:00008A68 ; Attributes: bp-based frame
.text$mn:00008A68
.text$mn:00008A68 ; struct tagRECT *__thiscall WINRECT::GetRect(WINRECT *__hidden this)
.text$mn:00008A68                 public ?GetRect@WINRECT@@QAEAAUtagRECT@@XZ
.text$mn:00008A68 ?GetRect@WINRECT@@QAEAAUtagRECT@@XZ proc near
.text$mn:00008A68                                         ; CODE XREF: CWinMgr::GetRect(uint)+15p
.text$mn:00008A68
.text$mn:00008A68 var_4           = dword ptr -4
.text$mn:00008A68
.text$mn:00008A68                 push    ebp
.text$mn:00008A69                 mov     ebp, esp
.text$mn:00008A6B                 push    ecx
.text$mn:00008A6C                 mov     [ebp+var_4], ecx
.text$mn:00008A6F                 mov     eax, [ebp+var_4]
.text$mn:00008A72                 add     eax, 8
.text$mn:00008A75                 mov     esp, ebp
.text$mn:00008A77                 pop     ebp
.text$mn:00008A78                 retn
.text$mn:00008A78 ?GetRect@WINRECT@@QAEAAUtagRECT@@XZ endp
.text$mn:00008A78
.text$mn:00008A78 ; ---------------------------------------------------------------------------
.text$mn:00008A79                 align 4
.text$mn:00008A79 _text$mn        ends
.text$mn:00008A79
.text$mn:00008A7C ; ===========================================================================
.text$mn:00008A7C
.text$mn:00008A7C ; Segment type: Pure code
.text$mn:00008A7C ; Segment permissions: Read/Execute
.text$mn:00008A7C _text$mn        segment para public 'CODE' use32
.text$mn:00008A7C                 assume cs:_text$mn
.text$mn:00008A7C                 ;org 8A7Ch
.text$mn:00008A7C ; COMDAT (pick any)
.text$mn:00008A7C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008A7C
.text$mn:00008A7C ; =============== S U B R O U T I N E =======================================
.text$mn:00008A7C
.text$mn:00008A7C ; Attributes: bp-based frame
.text$mn:00008A7C
.text$mn:00008A7C ; struct tagSIZE __cdecl GetSize(__int32, __int32)
.text$mn:00008A7C                 public ?GetSize@@YA?AUtagSIZE@@JJ@Z
.text$mn:00008A7C ?GetSize@@YA?AUtagSIZE@@JJ@Z proc near  ; CODE XREF: RectToSize(tagRECT const &)+20p
.text$mn:00008A7C
.text$mn:00008A7C var_8           = dword ptr -8
.text$mn:00008A7C var_4           = dword ptr -4
.text$mn:00008A7C arg_0           = dword ptr  8
.text$mn:00008A7C arg_4           = dword ptr  0Ch
.text$mn:00008A7C
.text$mn:00008A7C                 push    ebp
.text$mn:00008A7D                 mov     ebp, esp
.text$mn:00008A7F                 sub     esp, 8
.text$mn:00008A82                 mov     eax, [ebp+arg_0]
.text$mn:00008A85                 mov     [ebp+var_8], eax
.text$mn:00008A88                 mov     ecx, [ebp+arg_4]
.text$mn:00008A8B                 mov     [ebp+var_4], ecx
.text$mn:00008A8E                 mov     eax, [ebp+var_8]
.text$mn:00008A91                 mov     edx, [ebp+var_4]
.text$mn:00008A94                 mov     esp, ebp
.text$mn:00008A96                 pop     ebp
.text$mn:00008A97                 retn
.text$mn:00008A97 ?GetSize@@YA?AUtagSIZE@@JJ@Z endp
.text$mn:00008A97
.text$mn:00008A97 _text$mn        ends
.text$mn:00008A97
.text$mn:00008A98 ; ===========================================================================
.text$mn:00008A98
.text$mn:00008A98 ; Segment type: Pure code
.text$mn:00008A98 ; Segment permissions: Read/Execute
.text$mn:00008A98 _text$mn        segment para public 'CODE' use32
.text$mn:00008A98                 assume cs:_text$mn
.text$mn:00008A98                 ;org 8A98h
.text$mn:00008A98 ; COMDAT (pick any)
.text$mn:00008A98                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008A98
.text$mn:00008A98 ; =============== S U B R O U T I N E =======================================
.text$mn:00008A98
.text$mn:00008A98 ; Attributes: bp-based frame
.text$mn:00008A98
.text$mn:00008A98 ; __int32 __cdecl RectHeight(const struct tagRECT *)
.text$mn:00008A98                 public ?RectHeight@@YAJABUtagRECT@@@Z
.text$mn:00008A98 ?RectHeight@@YAJABUtagRECT@@@Z proc near
.text$mn:00008A98                                         ; CODE XREF: RectToSize(tagRECT const &)+Ap
.text$mn:00008A98
.text$mn:00008A98 arg_0           = dword ptr  8
.text$mn:00008A98
.text$mn:00008A98                 push    ebp
.text$mn:00008A99                 mov     ebp, esp
.text$mn:00008A9B                 mov     eax, [ebp+arg_0]
.text$mn:00008A9E                 mov     ecx, [ebp+arg_0]
.text$mn:00008AA1                 mov     eax, [eax+0Ch]
.text$mn:00008AA4                 sub     eax, [ecx+4]
.text$mn:00008AA7                 pop     ebp
.text$mn:00008AA8                 retn
.text$mn:00008AA8 ?RectHeight@@YAJABUtagRECT@@@Z endp
.text$mn:00008AA8
.text$mn:00008AA8 ; ---------------------------------------------------------------------------
.text$mn:00008AA9                 align 4
.text$mn:00008AA9 _text$mn        ends
.text$mn:00008AA9
.text$mn:00008AAC ; ===========================================================================
.text$mn:00008AAC
.text$mn:00008AAC ; Segment type: Pure code
.text$mn:00008AAC ; Segment permissions: Read/Execute
.text$mn:00008AAC _text$mn        segment para public 'CODE' use32
.text$mn:00008AAC                 assume cs:_text$mn
.text$mn:00008AAC                 ;org 8AACh
.text$mn:00008AAC ; COMDAT (pick any)
.text$mn:00008AAC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008AAC
.text$mn:00008AAC ; =============== S U B R O U T I N E =======================================
.text$mn:00008AAC
.text$mn:00008AAC ; Attributes: bp-based frame
.text$mn:00008AAC
.text$mn:00008AAC ; struct tagSIZE __cdecl RectToSize(const struct tagRECT *)
.text$mn:00008AAC                 public ?RectToSize@@YA?AUtagSIZE@@ABUtagRECT@@@Z
.text$mn:00008AAC ?RectToSize@@YA?AUtagSIZE@@ABUtagRECT@@@Z proc near
.text$mn:00008AAC                                         ; CODE XREF: WindowsDlg::onInitDialog(void)+37p
.text$mn:00008AAC                                         ; WindowsDlg::onInitDialog(void)+69p
.text$mn:00008AAC
.text$mn:00008AAC var_8           = dword ptr -8
.text$mn:00008AAC var_4           = dword ptr -4
.text$mn:00008AAC arg_0           = dword ptr  8
.text$mn:00008AAC
.text$mn:00008AAC                 push    ebp
.text$mn:00008AAD                 mov     ebp, esp
.text$mn:00008AAF                 sub     esp, 8
.text$mn:00008AB2                 mov     eax, [ebp+arg_0]
.text$mn:00008AB5                 push    eax             ; struct tagRECT *
.text$mn:00008AB6                 call    ?RectHeight@@YAJABUtagRECT@@@Z ; RectHeight(tagRECT const &)
.text$mn:00008ABB                 add     esp, 4
.text$mn:00008ABE                 push    eax             ; __int32
.text$mn:00008ABF                 mov     ecx, [ebp+arg_0]
.text$mn:00008AC2                 push    ecx             ; struct tagRECT *
.text$mn:00008AC3                 call    ?RectWidth@@YAJABUtagRECT@@@Z ; RectWidth(tagRECT const &)
.text$mn:00008AC8                 add     esp, 4
.text$mn:00008ACB                 push    eax             ; __int32
.text$mn:00008ACC                 call    ?GetSize@@YA?AUtagSIZE@@JJ@Z ; GetSize(long,long)
.text$mn:00008AD1                 add     esp, 8
.text$mn:00008AD4                 mov     [ebp+var_8], eax
.text$mn:00008AD7                 mov     [ebp+var_4], edx
.text$mn:00008ADA                 mov     eax, [ebp+var_8]
.text$mn:00008ADD                 mov     edx, [ebp+var_4]
.text$mn:00008AE0                 mov     esp, ebp
.text$mn:00008AE2                 pop     ebp
.text$mn:00008AE3                 retn
.text$mn:00008AE3 ?RectToSize@@YA?AUtagSIZE@@ABUtagRECT@@@Z endp
.text$mn:00008AE3
.text$mn:00008AE3 _text$mn        ends
.text$mn:00008AE3
.text$mn:00008AE4 ; ===========================================================================
.text$mn:00008AE4
.text$mn:00008AE4 ; Segment type: Pure code
.text$mn:00008AE4 ; Segment permissions: Read/Execute
.text$mn:00008AE4 _text$mn        segment para public 'CODE' use32
.text$mn:00008AE4                 assume cs:_text$mn
.text$mn:00008AE4                 ;org 8AE4h
.text$mn:00008AE4 ; COMDAT (pick any)
.text$mn:00008AE4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008AE4
.text$mn:00008AE4 ; =============== S U B R O U T I N E =======================================
.text$mn:00008AE4
.text$mn:00008AE4 ; Attributes: bp-based frame
.text$mn:00008AE4
.text$mn:00008AE4 ; __int32 __cdecl RectWidth(const struct tagRECT *)
.text$mn:00008AE4                 public ?RectWidth@@YAJABUtagRECT@@@Z
.text$mn:00008AE4 ?RectWidth@@YAJABUtagRECT@@@Z proc near ; CODE XREF: RectToSize(tagRECT const &)+17p
.text$mn:00008AE4
.text$mn:00008AE4 arg_0           = dword ptr  8
.text$mn:00008AE4
.text$mn:00008AE4                 push    ebp
.text$mn:00008AE5                 mov     ebp, esp
.text$mn:00008AE7                 mov     eax, [ebp+arg_0]
.text$mn:00008AEA                 mov     ecx, [ebp+arg_0]
.text$mn:00008AED                 mov     eax, [eax+8]
.text$mn:00008AF0                 sub     eax, [ecx]
.text$mn:00008AF2                 pop     ebp
.text$mn:00008AF3                 retn
.text$mn:00008AF3 ?RectWidth@@YAJABUtagRECT@@@Z endp
.text$mn:00008AF3
.text$mn:00008AF3 _text$mn        ends
.text$mn:00008AF3
.text$mn:00008AF4 ; ===========================================================================
.text$mn:00008AF4
.text$mn:00008AF4 ; Segment type: Pure code
.text$mn:00008AF4 ; Segment permissions: Read/Execute
.text$mn:00008AF4 _text$mn        segment para public 'CODE' use32
.text$mn:00008AF4                 assume cs:_text$mn
.text$mn:00008AF4                 ;org 8AF4h
.text$mn:00008AF4 ; COMDAT (pick any)
.text$mn:00008AF4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008AF4
.text$mn:00008AF4 ; =============== S U B R O U T I N E =======================================
.text$mn:00008AF4
.text$mn:00008AF4 ; Attributes: bp-based frame
.text$mn:00008AF4
.text$mn:00008AF4 ; void __thiscall WINRECT::SetRect(WINRECT *this, const struct tagRECT *)
.text$mn:00008AF4                 public ?SetRect@WINRECT@@QAEXABUtagRECT@@@Z
.text$mn:00008AF4 ?SetRect@WINRECT@@QAEXABUtagRECT@@@Z proc near
.text$mn:00008AF4                                         ; CODE XREF: CWinMgr::CalcLayout(tagRECT,HWND__ *)+31p
.text$mn:00008AF4
.text$mn:00008AF4 var_4           = dword ptr -4
.text$mn:00008AF4 arg_0           = dword ptr  8
.text$mn:00008AF4
.text$mn:00008AF4                 push    ebp
.text$mn:00008AF5                 mov     ebp, esp
.text$mn:00008AF7                 push    ecx
.text$mn:00008AF8                 mov     [ebp+var_4], ecx
.text$mn:00008AFB                 mov     eax, [ebp+var_4]
.text$mn:00008AFE                 add     eax, 8
.text$mn:00008B01                 mov     ecx, [ebp+arg_0]
.text$mn:00008B04                 mov     edx, [ecx]
.text$mn:00008B06                 mov     [eax], edx
.text$mn:00008B08                 mov     edx, [ecx+4]
.text$mn:00008B0B                 mov     [eax+4], edx
.text$mn:00008B0E                 mov     edx, [ecx+8]
.text$mn:00008B11                 mov     [eax+8], edx
.text$mn:00008B14                 mov     ecx, [ecx+0Ch]
.text$mn:00008B17                 mov     [eax+0Ch], ecx
.text$mn:00008B1A                 mov     esp, ebp
.text$mn:00008B1C                 pop     ebp
.text$mn:00008B1D                 retn    4
.text$mn:00008B1D ?SetRect@WINRECT@@QAEXABUtagRECT@@@Z endp
.text$mn:00008B1D
.text$mn:00008B1D _text$mn        ends
.text$mn:00008B1D
.text$mn:00008B20 ; ===========================================================================
.text$mn:00008B20
.text$mn:00008B20 ; Segment type: Pure code
.text$mn:00008B20 ; Segment permissions: Read/Execute
.text$mn:00008B20 _text$mn        segment para public 'CODE' use32
.text$mn:00008B20                 assume cs:_text$mn
.text$mn:00008B20                 ;org 8B20h
.text$mn:00008B20 ; COMDAT (pick any)
.text$mn:00008B20                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008B20
.text$mn:00008B20 ; =============== S U B R O U T I N E =======================================
.text$mn:00008B20
.text$mn:00008B20 ; Attributes: bp-based frame
.text$mn:00008B20
.text$mn:00008B20 ; struct TiXmlDeclarationA *__thiscall TiXmlNodeA::ToDeclaration(TiXmlNodeA *__hidden this)
.text$mn:00008B20                 public ?ToDeclaration@TiXmlNodeA@@QBEPAVTiXmlDeclarationA@@XZ
.text$mn:00008B20 ?ToDeclaration@TiXmlNodeA@@QBEPAVTiXmlDeclarationA@@XZ proc near
.text$mn:00008B20                                         ; CODE XREF: WindowsDlg::changeDlgLang(void)+3Cp
.text$mn:00008B20
.text$mn:00008B20 var_8           = dword ptr -8
.text$mn:00008B20 var_4           = dword ptr -4
.text$mn:00008B20
.text$mn:00008B20                 push    ebp
.text$mn:00008B21                 mov     ebp, esp
.text$mn:00008B23                 sub     esp, 8
.text$mn:00008B26                 mov     [ebp+var_4], ecx
.text$mn:00008B29                 cmp     [ebp+var_4], 0
.text$mn:00008B2D                 jz      short loc_8B40
.text$mn:00008B2F                 mov     eax, [ebp+var_4]
.text$mn:00008B32                 cmp     dword ptr [eax+10h], 5
.text$mn:00008B36                 jnz     short loc_8B40
.text$mn:00008B38                 mov     ecx, [ebp+var_4]
.text$mn:00008B3B                 mov     [ebp+var_8], ecx
.text$mn:00008B3E                 jmp     short loc_8B47
.text$mn:00008B40 ; ---------------------------------------------------------------------------
.text$mn:00008B40
.text$mn:00008B40 loc_8B40:                               ; CODE XREF: TiXmlNodeA::ToDeclaration(void)+Dj
.text$mn:00008B40                                         ; TiXmlNodeA::ToDeclaration(void)+16j
.text$mn:00008B40                 mov     [ebp+var_8], 0
.text$mn:00008B47
.text$mn:00008B47 loc_8B47:                               ; CODE XREF: TiXmlNodeA::ToDeclaration(void)+1Ej
.text$mn:00008B47                 mov     eax, [ebp+var_8]
.text$mn:00008B4A                 mov     esp, ebp
.text$mn:00008B4C                 pop     ebp
.text$mn:00008B4D                 retn
.text$mn:00008B4D ?ToDeclaration@TiXmlNodeA@@QBEPAVTiXmlDeclarationA@@XZ endp
.text$mn:00008B4D
.text$mn:00008B4D ; ---------------------------------------------------------------------------
.text$mn:00008B4E                 align 10h
.text$mn:00008B4E _text$mn        ends
.text$mn:00008B4E
.text$mn:00008B50 ; ===========================================================================
.text$mn:00008B50
.text$mn:00008B50 ; Segment type: Pure code
.text$mn:00008B50 ; Segment permissions: Read/Execute
.text$mn:00008B50 _text$mn        segment para public 'CODE' use32
.text$mn:00008B50                 assume cs:_text$mn
.text$mn:00008B50                 ;org 8B50h
.text$mn:00008B50 ; COMDAT (pick any)
.text$mn:00008B50                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008B50
.text$mn:00008B50 ; =============== S U B R O U T I N E =======================================
.text$mn:00008B50
.text$mn:00008B50 ; Attributes: bp-based frame
.text$mn:00008B50
.text$mn:00008B50 ; struct TiXmlElementA *__thiscall TiXmlNodeA::ToElement(TiXmlNodeA *__hidden this)
.text$mn:00008B50                 public ?ToElement@TiXmlNodeA@@QBEPAVTiXmlElementA@@XZ
.text$mn:00008B50 ?ToElement@TiXmlNodeA@@QBEPAVTiXmlElementA@@XZ proc near
.text$mn:00008B50                                         ; CODE XREF: WindowsDlg::changeDlgLang(void)+77p
.text$mn:00008B50                                         ; WindowsDlg::changeDlgLang(void)+FBp
.text$mn:00008B50
.text$mn:00008B50 var_8           = dword ptr -8
.text$mn:00008B50 var_4           = dword ptr -4
.text$mn:00008B50
.text$mn:00008B50                 push    ebp
.text$mn:00008B51                 mov     ebp, esp
.text$mn:00008B53                 sub     esp, 8
.text$mn:00008B56                 mov     [ebp+var_4], ecx
.text$mn:00008B59                 cmp     [ebp+var_4], 0
.text$mn:00008B5D                 jz      short loc_8B70
.text$mn:00008B5F                 mov     eax, [ebp+var_4]
.text$mn:00008B62                 cmp     dword ptr [eax+10h], 1
.text$mn:00008B66                 jnz     short loc_8B70
.text$mn:00008B68                 mov     ecx, [ebp+var_4]
.text$mn:00008B6B                 mov     [ebp+var_8], ecx
.text$mn:00008B6E                 jmp     short loc_8B77
.text$mn:00008B70 ; ---------------------------------------------------------------------------
.text$mn:00008B70
.text$mn:00008B70 loc_8B70:                               ; CODE XREF: TiXmlNodeA::ToElement(void)+Dj
.text$mn:00008B70                                         ; TiXmlNodeA::ToElement(void)+16j
.text$mn:00008B70                 mov     [ebp+var_8], 0
.text$mn:00008B77
.text$mn:00008B77 loc_8B77:                               ; CODE XREF: TiXmlNodeA::ToElement(void)+1Ej
.text$mn:00008B77                 mov     eax, [ebp+var_8]
.text$mn:00008B7A                 mov     esp, ebp
.text$mn:00008B7C                 pop     ebp
.text$mn:00008B7D                 retn
.text$mn:00008B7D ?ToElement@TiXmlNodeA@@QBEPAVTiXmlElementA@@XZ endp
.text$mn:00008B7D
.text$mn:00008B7D ; ---------------------------------------------------------------------------
.text$mn:00008B7E                 align 10h
.text$mn:00008B7E _text$mn        ends
.text$mn:00008B7E
.text$mn:00008B80 ; ===========================================================================
.text$mn:00008B80
.text$mn:00008B80 ; Segment type: Pure code
.text$mn:00008B80 ; Segment permissions: Read/Execute
.text$mn:00008B80 _text$mn        segment para public 'CODE' use32
.text$mn:00008B80                 assume cs:_text$mn
.text$mn:00008B80                 ;org 8B80h
.text$mn:00008B80 ; COMDAT (pick any)
.text$mn:00008B80                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008B80
.text$mn:00008B80 ; =============== S U B R O U T I N E =======================================
.text$mn:00008B80
.text$mn:00008B80 ; Attributes: bp-based frame
.text$mn:00008B80
.text$mn:00008B80 ; void __thiscall std::_Iterator_base12::_Adopt(std::_Iterator_base12 *this, const struct std::_Container_base12 *)
.text$mn:00008B80                 public ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
.text$mn:00008B80 ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z proc near
.text$mn:00008B80                                         ; CODE XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(wchar_t const *,std::_Container_base12 const *)+3Cp
.text$mn:00008B80                                         ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>(int *,std::_Container_base12 const *)+45p ...
.text$mn:00008B80
.text$mn:00008B80 var_1C          = byte ptr -1Ch
.text$mn:00008B80 var_18          = byte ptr -18h
.text$mn:00008B80 var_14          = dword ptr -14h
.text$mn:00008B80 var_10          = dword ptr -10h
.text$mn:00008B80 var_C           = dword ptr -0Ch
.text$mn:00008B80 var_4           = dword ptr -4
.text$mn:00008B80 arg_0           = dword ptr  8
.text$mn:00008B80
.text$mn:00008B80                 push    ebp
.text$mn:00008B81                 mov     ebp, esp
.text$mn:00008B83                 push    0FFFFFFFFh
.text$mn:00008B85                 push    offset __ehhandler$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
.text$mn:00008B8A                 mov     eax, large fs:0
.text$mn:00008B90                 push    eax
.text$mn:00008B91                 sub     esp, 10h
.text$mn:00008B94                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00008B99                 xor     eax, ebp
.text$mn:00008B9B                 push    eax
.text$mn:00008B9C                 lea     eax, [ebp+var_C]
.text$mn:00008B9F                 mov     large fs:0, eax
.text$mn:00008BA5                 mov     [ebp+var_10], ecx
.text$mn:00008BA8                 cmp     [ebp+arg_0], 0
.text$mn:00008BAC                 jnz     short loc_8BD8
.text$mn:00008BAE                 push    3               ; int
.text$mn:00008BB0                 lea     ecx, [ebp+var_18] ; this
.text$mn:00008BB3                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:00008BB8                 mov     [ebp+var_4], 0
.text$mn:00008BBF                 mov     ecx, [ebp+var_10] ; this
.text$mn:00008BC2                 call    ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me(void)
.text$mn:00008BC7                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00008BCE                 lea     ecx, [ebp+var_18] ; this
.text$mn:00008BD1                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:00008BD6                 jmp     short loc_8C2F
.text$mn:00008BD8 ; ---------------------------------------------------------------------------
.text$mn:00008BD8
.text$mn:00008BD8 loc_8BD8:                               ; CODE XREF: std::_Iterator_base12::_Adopt(std::_Container_base12 const *)+2Cj
.text$mn:00008BD8                 mov     eax, [ebp+arg_0]
.text$mn:00008BDB                 mov     ecx, [eax]
.text$mn:00008BDD                 mov     [ebp+var_14], ecx
.text$mn:00008BE0                 mov     edx, [ebp+var_10]
.text$mn:00008BE3                 mov     eax, [edx]
.text$mn:00008BE5                 cmp     eax, [ebp+var_14]
.text$mn:00008BE8                 jz      short loc_8C2F
.text$mn:00008BEA                 push    3               ; int
.text$mn:00008BEC                 lea     ecx, [ebp+var_1C] ; this
.text$mn:00008BEF                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:00008BF4                 mov     [ebp+var_4], 1
.text$mn:00008BFB                 mov     ecx, [ebp+var_10] ; this
.text$mn:00008BFE                 call    ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me(void)
.text$mn:00008C03                 mov     ecx, [ebp+var_10]
.text$mn:00008C06                 mov     edx, [ebp+var_14]
.text$mn:00008C09                 mov     eax, [edx+4]
.text$mn:00008C0C                 mov     [ecx+4], eax
.text$mn:00008C0F                 mov     ecx, [ebp+var_14]
.text$mn:00008C12                 mov     edx, [ebp+var_10]
.text$mn:00008C15                 mov     [ecx+4], edx
.text$mn:00008C18                 mov     eax, [ebp+var_10]
.text$mn:00008C1B                 mov     ecx, [ebp+var_14]
.text$mn:00008C1E                 mov     [eax], ecx
.text$mn:00008C20                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00008C27                 lea     ecx, [ebp+var_1C] ; this
.text$mn:00008C2A                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:00008C2F
.text$mn:00008C2F loc_8C2F:                               ; CODE XREF: std::_Iterator_base12::_Adopt(std::_Container_base12 const *)+56j
.text$mn:00008C2F                                         ; std::_Iterator_base12::_Adopt(std::_Container_base12 const *)+68j
.text$mn:00008C2F                 mov     ecx, [ebp+var_C]
.text$mn:00008C32                 mov     large fs:0, ecx
.text$mn:00008C39                 pop     ecx
.text$mn:00008C3A                 mov     esp, ebp
.text$mn:00008C3C                 pop     ebp
.text$mn:00008C3D                 retn    4
.text$mn:00008C3D ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z endp
.text$mn:00008C3D
.text$mn:00008C3D _text$mn        ends
.text$mn:00008C3D
.text$x:00008C40 ; ===========================================================================
.text$x:00008C40
.text$x:00008C40 ; Segment type: Pure code
.text$x:00008C40 ; Segment permissions: Read/Execute
.text$x:00008C40 _text$x         segment para public 'CODE' use32
.text$x:00008C40                 assume cs:_text$x
.text$x:00008C40                 ;org 8C40h
.text$x:00008C40 ; COMDAT (pick associative to section at 8B80)
.text$x:00008C40                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00008C40
.text$x:00008C40 ; =============== S U B R O U T I N E =======================================
.text$x:00008C40
.text$x:00008C40
.text$x:00008C40 __unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$0 proc near
.text$x:00008C40                                         ; DATA XREF: .xdata$x:0000C5BCo
.text$x:00008C40                 lea     ecx, [ebp-18h]  ; this
.text$x:00008C43                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:00008C43 __unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$0 endp
.text$x:00008C43
.text$x:00008C48
.text$x:00008C48 ; =============== S U B R O U T I N E =======================================
.text$x:00008C48
.text$x:00008C48
.text$x:00008C48 __unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$1 proc near
.text$x:00008C48                                         ; DATA XREF: .xdata$x:0000C5C4o
.text$x:00008C48                 lea     ecx, [ebp-1Ch]  ; this
.text$x:00008C4B                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:00008C4B __unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$1 endp
.text$x:00008C4B
.text$x:00008C50
.text$x:00008C50 ; =============== S U B R O U T I N E =======================================
.text$x:00008C50
.text$x:00008C50
.text$x:00008C50 __ehhandler$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z proc near
.text$x:00008C50                                         ; DATA XREF: std::_Iterator_base12::_Adopt(std::_Container_base12 const *)+5o
.text$x:00008C50
.text$x:00008C50 arg_4           = dword ptr  8
.text$x:00008C50
.text$x:00008C50                 mov     edx, [esp+arg_4]
.text$x:00008C54                 lea     eax, [edx+0Ch]
.text$x:00008C57                 mov     ecx, [edx-14h]
.text$x:00008C5A                 xor     ecx, eax
.text$x:00008C5C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00008C61                 mov     eax, offset __ehfuncinfo$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
.text$x:00008C66                 jmp     ___CxxFrameHandler3
.text$x:00008C66 __ehhandler$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z endp
.text$x:00008C66
.text$x:00008C66 ; ---------------------------------------------------------------------------
.text$x:00008C6B                 align 4
.text$x:00008C6B _text$x         ends
.text$x:00008C6B
.text$mn:00008C6C ; ===========================================================================
.text$mn:00008C6C
.text$mn:00008C6C ; Segment type: Pure code
.text$mn:00008C6C ; Segment permissions: Read/Execute
.text$mn:00008C6C _text$mn        segment para public 'CODE' use32
.text$mn:00008C6C                 assume cs:_text$mn
.text$mn:00008C6C                 ;org 8C6Ch
.text$mn:00008C6C ; COMDAT (pick any)
.text$mn:00008C6C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008C6C
.text$mn:00008C6C ; =============== S U B R O U T I N E =======================================
.text$mn:00008C6C
.text$mn:00008C6C ; Attributes: bp-based frame
.text$mn:00008C6C
.text$mn:00008C6C ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Alloc_proxy(void)
.text$mn:00008C6C                 public ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
.text$mn:00008C6C ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00008C6C                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+38p
.text$mn:00008C6C
.text$mn:00008C6C var_10          = byte ptr -10h
.text$mn:00008C6C var_8           = dword ptr -8
.text$mn:00008C6C var_1           = byte ptr -1
.text$mn:00008C6C
.text$mn:00008C6C                 push    ebp
.text$mn:00008C6D                 mov     ebp, esp
.text$mn:00008C6F                 sub     esp, 10h
.text$mn:00008C72                 mov     [ebp+var_8], ecx
.text$mn:00008C75                 lea     ecx, [ebp+var_1]
.text$mn:00008C78                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:00008C7D                 push    1
.text$mn:00008C7F                 lea     ecx, [ebp+var_1]
.text$mn:00008C82                 call    ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate(uint)
.text$mn:00008C87                 mov     ecx, [ebp+var_8]
.text$mn:00008C8A                 mov     [ecx], eax
.text$mn:00008C8C                 lea     ecx, [ebp+var_10] ; this
.text$mn:00008C8F                 call    ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy(void)
.text$mn:00008C94                 push    eax             ; int
.text$mn:00008C95                 mov     edx, [ebp+var_8]
.text$mn:00008C98                 mov     eax, [edx]
.text$mn:00008C9A                 push    eax             ; void *
.text$mn:00008C9B                 lea     ecx, [ebp+var_1]
.text$mn:00008C9E                 call    ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:00008CA3                 mov     ecx, [ebp+var_8]
.text$mn:00008CA6                 mov     edx, [ecx]
.text$mn:00008CA8                 mov     eax, [ebp+var_8]
.text$mn:00008CAB                 mov     [edx], eax
.text$mn:00008CAD                 mov     esp, ebp
.text$mn:00008CAF                 pop     ebp
.text$mn:00008CB0                 retn
.text$mn:00008CB0 ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp
.text$mn:00008CB0
.text$mn:00008CB0 ; ---------------------------------------------------------------------------
.text$mn:00008CB1                 align 4
.text$mn:00008CB1 _text$mn        ends
.text$mn:00008CB1
.text$mn:00008CB4 ; ===========================================================================
.text$mn:00008CB4
.text$mn:00008CB4 ; Segment type: Pure code
.text$mn:00008CB4 ; Segment permissions: Read/Execute
.text$mn:00008CB4 _text$mn        segment para public 'CODE' use32
.text$mn:00008CB4                 assume cs:_text$mn
.text$mn:00008CB4                 ;org 8CB4h
.text$mn:00008CB4 ; COMDAT (pick any)
.text$mn:00008CB4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008CB4
.text$mn:00008CB4 ; =============== S U B R O U T I N E =======================================
.text$mn:00008CB4
.text$mn:00008CB4 ; Attributes: bp-based frame
.text$mn:00008CB4
.text$mn:00008CB4 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>::_Alloc_proxy(void)
.text$mn:00008CB4                 public ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ
.text$mn:00008CB4 ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00008CB4                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(std::allocator<wchar_t> const &)+38p
.text$mn:00008CB4
.text$mn:00008CB4 var_10          = byte ptr -10h
.text$mn:00008CB4 var_8           = dword ptr -8
.text$mn:00008CB4 var_1           = byte ptr -1
.text$mn:00008CB4
.text$mn:00008CB4                 push    ebp
.text$mn:00008CB5                 mov     ebp, esp
.text$mn:00008CB7                 sub     esp, 10h
.text$mn:00008CBA                 mov     [ebp+var_8], ecx
.text$mn:00008CBD                 lea     ecx, [ebp+var_1]
.text$mn:00008CC0                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:00008CC5                 push    1
.text$mn:00008CC7                 lea     ecx, [ebp+var_1]
.text$mn:00008CCA                 call    ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate(uint)
.text$mn:00008CCF                 mov     ecx, [ebp+var_8]
.text$mn:00008CD2                 mov     [ecx], eax
.text$mn:00008CD4                 lea     ecx, [ebp+var_10] ; this
.text$mn:00008CD7                 call    ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy(void)
.text$mn:00008CDC                 push    eax             ; int
.text$mn:00008CDD                 mov     edx, [ebp+var_8]
.text$mn:00008CE0                 mov     eax, [edx]
.text$mn:00008CE2                 push    eax             ; void *
.text$mn:00008CE3                 lea     ecx, [ebp+var_1]
.text$mn:00008CE6                 call    ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:00008CEB                 mov     ecx, [ebp+var_8]
.text$mn:00008CEE                 mov     edx, [ecx]
.text$mn:00008CF0                 mov     eax, [ebp+var_8]
.text$mn:00008CF3                 mov     [edx], eax
.text$mn:00008CF5                 mov     esp, ebp
.text$mn:00008CF7                 pop     ebp
.text$mn:00008CF8                 retn
.text$mn:00008CF8 ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ endp
.text$mn:00008CF8
.text$mn:00008CF8 ; ---------------------------------------------------------------------------
.text$mn:00008CF9                 align 4
.text$mn:00008CF9 _text$mn        ends
.text$mn:00008CF9
.text$mn:00008CFC ; ===========================================================================
.text$mn:00008CFC
.text$mn:00008CFC ; Segment type: Pure code
.text$mn:00008CFC ; Segment permissions: Read/Execute
.text$mn:00008CFC _text$mn        segment para public 'CODE' use32
.text$mn:00008CFC                 assume cs:_text$mn
.text$mn:00008CFC                 ;org 8CFCh
.text$mn:00008CFC ; COMDAT (pick any)
.text$mn:00008CFC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008CFC
.text$mn:00008CFC ; =============== S U B R O U T I N E =======================================
.text$mn:00008CFC
.text$mn:00008CFC ; Attributes: bp-based frame
.text$mn:00008CFC
.text$mn:00008CFC ; public: void __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<int, class std::allocator<int>>>::_Alloc_proxy(void)
.text$mn:00008CFC                 public ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEXXZ
.text$mn:00008CFC ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00008CFC                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>(std::allocator<int> const &)+38p
.text$mn:00008CFC
.text$mn:00008CFC var_10          = byte ptr -10h
.text$mn:00008CFC var_8           = dword ptr -8
.text$mn:00008CFC var_1           = byte ptr -1
.text$mn:00008CFC
.text$mn:00008CFC                 push    ebp
.text$mn:00008CFD                 mov     ebp, esp
.text$mn:00008CFF                 sub     esp, 10h
.text$mn:00008D02                 mov     [ebp+var_8], ecx
.text$mn:00008D05                 lea     ecx, [ebp+var_1]
.text$mn:00008D08                 call    ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::_Wrap_alloc<std::allocator<std::_Container_proxy>>(void)
.text$mn:00008D0D                 push    1
.text$mn:00008D0F                 lea     ecx, [ebp+var_1]
.text$mn:00008D12                 call    ?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::allocate(uint)
.text$mn:00008D17                 mov     ecx, [ebp+var_8]
.text$mn:00008D1A                 mov     [ecx], eax
.text$mn:00008D1C                 lea     ecx, [ebp+var_10] ; this
.text$mn:00008D1F                 call    ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy(void)
.text$mn:00008D24                 push    eax             ; int
.text$mn:00008D25                 mov     edx, [ebp+var_8]
.text$mn:00008D28                 mov     eax, [edx]
.text$mn:00008D2A                 push    eax             ; void *
.text$mn:00008D2B                 lea     ecx, [ebp+var_1]
.text$mn:00008D2E                 call    ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:00008D33                 mov     ecx, [ebp+var_8]
.text$mn:00008D36                 mov     edx, [ecx]
.text$mn:00008D38                 mov     eax, [ebp+var_8]
.text$mn:00008D3B                 mov     [edx], eax
.text$mn:00008D3D                 mov     esp, ebp
.text$mn:00008D3F                 pop     ebp
.text$mn:00008D40                 retn
.text$mn:00008D40 ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEXXZ endp
.text$mn:00008D40
.text$mn:00008D40 ; ---------------------------------------------------------------------------
.text$mn:00008D41                 align 4
.text$mn:00008D41 _text$mn        ends
.text$mn:00008D41
.text$mn:00008D44 ; ===========================================================================
.text$mn:00008D44
.text$mn:00008D44 ; Segment type: Pure code
.text$mn:00008D44 ; Segment permissions: Read/Execute
.text$mn:00008D44 _text$mn        segment para public 'CODE' use32
.text$mn:00008D44                 assume cs:_text$mn
.text$mn:00008D44                 ;org 8D44h
.text$mn:00008D44 ; COMDAT (pick any)
.text$mn:00008D44                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008D44
.text$mn:00008D44 ; =============== S U B R O U T I N E =======================================
.text$mn:00008D44
.text$mn:00008D44 ; Attributes: bp-based frame
.text$mn:00008D44
.text$mn:00008D44 ; public: void __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<wchar_t, class std::allocator<wchar_t>>>::_Alloc_proxy(void)
.text$mn:00008D44                 public ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ
.text$mn:00008D44 ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00008D44                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<wchar_t,std::allocator<wchar_t>>>::_Vector_alloc<0,std::_Vec_base_types<wchar_t,std::allocator<wchar_t>>>(std::allocator<wchar_t> const &)+38p
.text$mn:00008D44
.text$mn:00008D44 var_10          = byte ptr -10h
.text$mn:00008D44 var_8           = dword ptr -8
.text$mn:00008D44 var_1           = byte ptr -1
.text$mn:00008D44
.text$mn:00008D44                 push    ebp
.text$mn:00008D45                 mov     ebp, esp
.text$mn:00008D47                 sub     esp, 10h
.text$mn:00008D4A                 mov     [ebp+var_8], ecx
.text$mn:00008D4D                 lea     ecx, [ebp+var_1]
.text$mn:00008D50                 call    ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::_Wrap_alloc<std::allocator<std::_Container_proxy>>(void)
.text$mn:00008D55                 push    1
.text$mn:00008D57                 lea     ecx, [ebp+var_1]
.text$mn:00008D5A                 call    ?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::allocate(uint)
.text$mn:00008D5F                 mov     ecx, [ebp+var_8]
.text$mn:00008D62                 mov     [ecx], eax
.text$mn:00008D64                 lea     ecx, [ebp+var_10] ; this
.text$mn:00008D67                 call    ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy(void)
.text$mn:00008D6C                 push    eax             ; int
.text$mn:00008D6D                 mov     edx, [ebp+var_8]
.text$mn:00008D70                 mov     eax, [edx]
.text$mn:00008D72                 push    eax             ; void *
.text$mn:00008D73                 lea     ecx, [ebp+var_1]
.text$mn:00008D76                 call    ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:00008D7B                 mov     ecx, [ebp+var_8]
.text$mn:00008D7E                 mov     edx, [ecx]
.text$mn:00008D80                 mov     eax, [ebp+var_8]
.text$mn:00008D83                 mov     [edx], eax
.text$mn:00008D85                 mov     esp, ebp
.text$mn:00008D87                 pop     ebp
.text$mn:00008D88                 retn
.text$mn:00008D88 ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ endp
.text$mn:00008D88
.text$mn:00008D88 ; ---------------------------------------------------------------------------
.text$mn:00008D89                 align 4
.text$mn:00008D89 _text$mn        ends
.text$mn:00008D89
.text$mn:00008D8C ; ===========================================================================
.text$mn:00008D8C
.text$mn:00008D8C ; Segment type: Pure code
.text$mn:00008D8C ; Segment permissions: Read/Execute
.text$mn:00008D8C _text$mn        segment para public 'CODE' use32
.text$mn:00008D8C                 assume cs:_text$mn
.text$mn:00008D8C                 ;org 8D8Ch
.text$mn:00008D8C ; COMDAT (pick any)
.text$mn:00008D8C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008D8C
.text$mn:00008D8C ; =============== S U B R O U T I N E =======================================
.text$mn:00008D8C
.text$mn:00008D8C ; Attributes: bp-based frame
.text$mn:00008D8C
.text$mn:00008D8C ; protected: bool __thiscall std::vector<wchar_t, class std::allocator<wchar_t>>::_Buy(unsigned int)
.text$mn:00008D8C                 public ?_Buy@?$vector@_WV?$allocator@_W@std@@@std@@IAE_NI@Z
.text$mn:00008D8C ?_Buy@?$vector@_WV?$allocator@_W@std@@@std@@IAE_NI@Z proc near
.text$mn:00008D8C                                         ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::_Construct<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::forward_iterator_tag)+88p
.text$mn:00008D8C
.text$mn:00008D8C var_8           = dword ptr -8
.text$mn:00008D8C var_1           = byte ptr -1
.text$mn:00008D8C arg_0           = dword ptr  8
.text$mn:00008D8C
.text$mn:00008D8C                 push    ebp
.text$mn:00008D8D                 mov     ebp, esp
.text$mn:00008D8F                 sub     esp, 8
.text$mn:00008D92                 mov     [ebp+var_8], ecx
.text$mn:00008D95                 mov     eax, [ebp+var_8]
.text$mn:00008D98                 mov     dword ptr [eax+4], 0
.text$mn:00008D9F                 mov     ecx, [ebp+var_8]
.text$mn:00008DA2                 mov     dword ptr [ecx+8], 0
.text$mn:00008DA9                 mov     edx, [ebp+var_8]
.text$mn:00008DAC                 mov     dword ptr [edx+0Ch], 0
.text$mn:00008DB3                 cmp     [ebp+arg_0], 0
.text$mn:00008DB7                 jnz     short loc_8DBF
.text$mn:00008DB9                 xor     al, al
.text$mn:00008DBB                 jmp     short loc_8E13
.text$mn:00008DBD ; ---------------------------------------------------------------------------
.text$mn:00008DBD                 jmp     short loc_8E11
.text$mn:00008DBF ; ---------------------------------------------------------------------------
.text$mn:00008DBF
.text$mn:00008DBF loc_8DBF:                               ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::_Buy(uint)+2Bj
.text$mn:00008DBF                 mov     ecx, [ebp+var_8]
.text$mn:00008DC2                 call    ?max_size@?$vector@_WV?$allocator@_W@std@@@std@@QBEIXZ ; std::vector<wchar_t,std::allocator<wchar_t>>::max_size(void)
.text$mn:00008DC7                 cmp     eax, [ebp+arg_0]
.text$mn:00008DCA                 jnb     short loc_8DD6
.text$mn:00008DCC                 mov     ecx, [ebp+var_8]
.text$mn:00008DCF                 call    ?_Xlen@?$vector@_WV?$allocator@_W@std@@@std@@IBEXXZ ; std::vector<wchar_t,std::allocator<wchar_t>>::_Xlen(void)
.text$mn:00008DD4                 jmp     short loc_8E11
.text$mn:00008DD6 ; ---------------------------------------------------------------------------
.text$mn:00008DD6
.text$mn:00008DD6 loc_8DD6:                               ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::_Buy(uint)+3Ej
.text$mn:00008DD6                 mov     eax, [ebp+arg_0]
.text$mn:00008DD9                 push    eax
.text$mn:00008DDA                 lea     ecx, [ebp+var_1]
.text$mn:00008DDD                 push    ecx
.text$mn:00008DDE                 mov     ecx, [ebp+var_8]
.text$mn:00008DE1                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:00008DE6                 mov     ecx, eax
.text$mn:00008DE8                 call    ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::allocate(uint)
.text$mn:00008DED                 mov     edx, [ebp+var_8]
.text$mn:00008DF0                 mov     [edx+4], eax
.text$mn:00008DF3                 mov     eax, [ebp+var_8]
.text$mn:00008DF6                 mov     ecx, [ebp+var_8]
.text$mn:00008DF9                 mov     edx, [ecx+4]
.text$mn:00008DFC                 mov     [eax+8], edx
.text$mn:00008DFF                 mov     eax, [ebp+var_8]
.text$mn:00008E02                 mov     ecx, [eax+4]
.text$mn:00008E05                 mov     edx, [ebp+arg_0]
.text$mn:00008E08                 lea     eax, [ecx+edx*2]
.text$mn:00008E0B                 mov     ecx, [ebp+var_8]
.text$mn:00008E0E                 mov     [ecx+0Ch], eax
.text$mn:00008E11
.text$mn:00008E11 loc_8E11:                               ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::_Buy(uint)+31j
.text$mn:00008E11                                         ; std::vector<wchar_t,std::allocator<wchar_t>>::_Buy(uint)+48j
.text$mn:00008E11                 mov     al, 1
.text$mn:00008E13
.text$mn:00008E13 loc_8E13:                               ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::_Buy(uint)+2Fj
.text$mn:00008E13                 mov     esp, ebp
.text$mn:00008E15                 pop     ebp
.text$mn:00008E16                 retn    4
.text$mn:00008E16 ?_Buy@?$vector@_WV?$allocator@_W@std@@@std@@IAE_NI@Z endp
.text$mn:00008E16
.text$mn:00008E16 ; ---------------------------------------------------------------------------
.text$mn:00008E19                 align 4
.text$mn:00008E19 _text$mn        ends
.text$mn:00008E19
.text$mn:00008E1C ; ===========================================================================
.text$mn:00008E1C
.text$mn:00008E1C ; Segment type: Pure code
.text$mn:00008E1C ; Segment permissions: Read/Execute
.text$mn:00008E1C _text$mn        segment para public 'CODE' use32
.text$mn:00008E1C                 assume cs:_text$mn
.text$mn:00008E1C                 ;org 8E1Ch
.text$mn:00008E1C ; COMDAT (pick any)
.text$mn:00008E1C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008E1C
.text$mn:00008E1C ; =============== S U B R O U T I N E =======================================
.text$mn:00008E1C
.text$mn:00008E1C ; Attributes: bp-based frame
.text$mn:00008E1C
.text$mn:00008E1C ; void __thiscall std::_Iterator_base12::_Clrcont(std::_Iterator_base12 *__hidden this)
.text$mn:00008E1C                 public ?_Clrcont@_Iterator_base12@std@@QAEXXZ
.text$mn:00008E1C ?_Clrcont@_Iterator_base12@std@@QAEXXZ proc near
.text$mn:00008E1C                                         ; CODE XREF: std::vector<int,std::allocator<int>>::_Orphan_range(int *,int *)+80p
.text$mn:00008E1C                                         ; std::vector<wchar_t,std::allocator<wchar_t>>::_Orphan_range(wchar_t *,wchar_t *)+80p
.text$mn:00008E1C
.text$mn:00008E1C var_4           = dword ptr -4
.text$mn:00008E1C
.text$mn:00008E1C                 push    ebp
.text$mn:00008E1D                 mov     ebp, esp
.text$mn:00008E1F                 push    ecx
.text$mn:00008E20                 mov     [ebp+var_4], ecx
.text$mn:00008E23                 mov     eax, [ebp+var_4]
.text$mn:00008E26                 mov     dword ptr [eax], 0
.text$mn:00008E2C                 mov     esp, ebp
.text$mn:00008E2E                 pop     ebp
.text$mn:00008E2F                 retn
.text$mn:00008E2F ?_Clrcont@_Iterator_base12@std@@QAEXXZ endp
.text$mn:00008E2F
.text$mn:00008E2F _text$mn        ends
.text$mn:00008E2F
.text$mn:00008E30 ; ===========================================================================
.text$mn:00008E30
.text$mn:00008E30 ; Segment type: Pure code
.text$mn:00008E30 ; Segment permissions: Read/Execute
.text$mn:00008E30 _text$mn        segment para public 'CODE' use32
.text$mn:00008E30                 assume cs:_text$mn
.text$mn:00008E30                 ;org 8E30h
.text$mn:00008E30 ; COMDAT (pick any)
.text$mn:00008E30                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008E30
.text$mn:00008E30 ; =============== S U B R O U T I N E =======================================
.text$mn:00008E30
.text$mn:00008E30 ; Attributes: bp-based frame
.text$mn:00008E30
.text$mn:00008E30 ; int __stdcall std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_Compat(std::_Iterator_base12 *)
.text$mn:00008E30                 public ?_Compat@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEXABV12@@Z
.text$mn:00008E30 ?_Compat@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEXABV12@@Z proc near
.text$mn:00008E30                                         ; CODE XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator==(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)+10p
.text$mn:00008E30                                         ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator-(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)+Ep
.text$mn:00008E30
.text$mn:00008E30 var_4           = dword ptr -4
.text$mn:00008E30 arg_0           = dword ptr  8
.text$mn:00008E30
.text$mn:00008E30                 push    ebp
.text$mn:00008E31                 mov     ebp, esp
.text$mn:00008E33                 push    ecx
.text$mn:00008E34                 push    esi
.text$mn:00008E35                 mov     [ebp+var_4], ecx
.text$mn:00008E38                 mov     ecx, [ebp+var_4] ; this
.text$mn:00008E3B                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:00008E40                 test    eax, eax
.text$mn:00008E42                 jz      short loc_8E5A
.text$mn:00008E44                 mov     ecx, [ebp+var_4] ; this
.text$mn:00008E47                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:00008E4C                 mov     esi, eax
.text$mn:00008E4E                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00008E51                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:00008E56                 cmp     esi, eax
.text$mn:00008E58                 jz      short loc_8EC2
.text$mn:00008E5A
.text$mn:00008E5A loc_8E5A:                               ; CODE XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_Compat(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)+12j
.text$mn:00008E5A                 push    0FAh ; ''      ; unsigned int
.text$mn:00008E5F                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00008E64                 push    offset ??_C@_1DM@KDEKGMPF@?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AAs?$AA?5?$AAi?$AAn?$AAc?$AAo?$AAm?$AAp?$AAa?$AAt?$AAi?$AAb?$AAl?$AAe?$AA?$AA@ ; "string iterators incompatible"
.text$mn:00008E69                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00008E6E                 add     esp, 0Ch
.text$mn:00008E71                 mov     eax, offset ??_C@_0CI@FNPHFCCM@Standard?5C?$CL?$CL?5Libraries?5Invalid?5A@ ; "Standard C++ Libraries Invalid Argument"
.text$mn:00008E76                 test    eax, eax
.text$mn:00008E78                 jz      short loc_8E7E
.text$mn:00008E7A                 xor     ecx, ecx
.text$mn:00008E7C                 jnz     short loc_8EA4
.text$mn:00008E7E
.text$mn:00008E7E loc_8E7E:                               ; CODE XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_Compat(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)+48j
.text$mn:00008E7E                 push    offset ??_C@_1FO@GJIHNDLM@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5@ ; "\"Standard C++ Libraries Invalid Argume"...
.text$mn:00008E83                 push    offset ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ ; "%s"
.text$mn:00008E88                 push    0
.text$mn:00008E8A                 push    0FBh ; 'v'
.text$mn:00008E8F                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00008E94                 push    2
.text$mn:00008E96                 call    __CrtDbgReportW
.text$mn:00008E9B                 add     esp, 18h
.text$mn:00008E9E                 cmp     eax, 1
.text$mn:00008EA1                 jnz     short loc_8EA4
.text$mn:00008EA3                 int     3               ; Trap to Debugger
.text$mn:00008EA4
.text$mn:00008EA4 loc_8EA4:                               ; CODE XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_Compat(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)+4Cj
.text$mn:00008EA4                                         ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_Compat(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)+71j
.text$mn:00008EA4                 push    0
.text$mn:00008EA6                 push    0FBh ; 'v'
.text$mn:00008EAB                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00008EB0                 push    offset ??_C@_1MG@CLNEOJNJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAS?$AAt?$AAr?$AAi?$AAn?$AAg?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ ; "std::_String_const_iterator<class std::"...
.text$mn:00008EB5                 push    offset ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@ ; "\"invalid argument\""
.text$mn:00008EBA                 call    __invalid_parameter
.text$mn:00008EBF                 add     esp, 14h
.text$mn:00008EC2
.text$mn:00008EC2 loc_8EC2:                               ; CODE XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_Compat(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)+28j
.text$mn:00008EC2                 pop     esi
.text$mn:00008EC3                 mov     esp, ebp
.text$mn:00008EC5                 pop     ebp
.text$mn:00008EC6                 retn    4
.text$mn:00008EC6 ?_Compat@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEXABV12@@Z endp
.text$mn:00008EC6
.text$mn:00008EC6 ; ---------------------------------------------------------------------------
.text$mn:00008EC9                 align 4
.text$mn:00008EC9 _text$mn        ends
.text$mn:00008EC9
.text$mn:00008ECC ; ===========================================================================
.text$mn:00008ECC
.text$mn:00008ECC ; Segment type: Pure code
.text$mn:00008ECC ; Segment permissions: Read/Execute
.text$mn:00008ECC _text$mn        segment para public 'CODE' use32
.text$mn:00008ECC                 assume cs:_text$mn
.text$mn:00008ECC                 ;org 8ECCh
.text$mn:00008ECC ; COMDAT (pick any)
.text$mn:00008ECC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008ECC
.text$mn:00008ECC ; =============== S U B R O U T I N E =======================================
.text$mn:00008ECC
.text$mn:00008ECC ; Attributes: bp-based frame
.text$mn:00008ECC
.text$mn:00008ECC ; int __stdcall std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Compat(std::_Iterator_base12 *)
.text$mn:00008ECC                 public ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBEXABV12@@Z
.text$mn:00008ECC ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBEXABV12@@Z proc near
.text$mn:00008ECC                                         ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator==(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>> const &)+10p
.text$mn:00008ECC                                         ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator<(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>> const &)+10p
.text$mn:00008ECC
.text$mn:00008ECC var_4           = dword ptr -4
.text$mn:00008ECC arg_0           = dword ptr  8
.text$mn:00008ECC
.text$mn:00008ECC                 push    ebp
.text$mn:00008ECD                 mov     ebp, esp
.text$mn:00008ECF                 push    ecx
.text$mn:00008ED0                 push    esi
.text$mn:00008ED1                 mov     [ebp+var_4], ecx
.text$mn:00008ED4                 mov     ecx, [ebp+var_4] ; this
.text$mn:00008ED7                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:00008EDC                 test    eax, eax
.text$mn:00008EDE                 jz      short loc_8EF6
.text$mn:00008EE0                 mov     ecx, [ebp+var_4] ; this
.text$mn:00008EE3                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:00008EE8                 mov     esi, eax
.text$mn:00008EEA                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00008EED                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:00008EF2                 cmp     esi, eax
.text$mn:00008EF4                 jz      short loc_8F5E
.text$mn:00008EF6
.text$mn:00008EF6 loc_8EF6:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Compat(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>> const &)+12j
.text$mn:00008EF6                 push    0F0h ; '='      ; unsigned int
.text$mn:00008EFB                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00008F00                 push    offset ??_C@_1DM@HINDPMBP@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AAs?$AA?5?$AAi?$AAn?$AAc?$AAo?$AAm?$AAp?$AAa?$AAt?$AAi?$AAb?$AAl?$AAe?$AA?$AA@ ; "vector iterators incompatible"
.text$mn:00008F05                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00008F0A                 add     esp, 0Ch
.text$mn:00008F0D                 mov     eax, offset ??_C@_0CI@FNPHFCCM@Standard?5C?$CL?$CL?5Libraries?5Invalid?5A@ ; "Standard C++ Libraries Invalid Argument"
.text$mn:00008F12                 test    eax, eax
.text$mn:00008F14                 jz      short loc_8F1A
.text$mn:00008F16                 xor     ecx, ecx
.text$mn:00008F18                 jnz     short loc_8F40
.text$mn:00008F1A
.text$mn:00008F1A loc_8F1A:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Compat(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>> const &)+48j
.text$mn:00008F1A                 push    offset ??_C@_1FO@GJIHNDLM@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5@ ; "\"Standard C++ Libraries Invalid Argume"...
.text$mn:00008F1F                 push    offset ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ ; "%s"
.text$mn:00008F24                 push    0
.text$mn:00008F26                 push    0F1h ; ''
.text$mn:00008F2B                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00008F30                 push    2
.text$mn:00008F32                 call    __CrtDbgReportW
.text$mn:00008F37                 add     esp, 18h
.text$mn:00008F3A                 cmp     eax, 1
.text$mn:00008F3D                 jnz     short loc_8F40
.text$mn:00008F3F                 int     3               ; Trap to Debugger
.text$mn:00008F40
.text$mn:00008F40 loc_8F40:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Compat(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>> const &)+4Cj
.text$mn:00008F40                                         ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Compat(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>> const &)+71j
.text$mn:00008F40                 push    0
.text$mn:00008F42                 push    0F1h ; ''
.text$mn:00008F47                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00008F4C                 push    offset ??_C@_1LO@MGELDLOO@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ ; "std::_Vector_const_iterator<class std::"...
.text$mn:00008F51                 push    offset ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@ ; "\"invalid argument\""
.text$mn:00008F56                 call    __invalid_parameter
.text$mn:00008F5B                 add     esp, 14h
.text$mn:00008F5E
.text$mn:00008F5E loc_8F5E:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Compat(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>> const &)+28j
.text$mn:00008F5E                 pop     esi
.text$mn:00008F5F                 mov     esp, ebp
.text$mn:00008F61                 pop     ebp
.text$mn:00008F62                 retn    4
.text$mn:00008F62 ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBEXABV12@@Z endp
.text$mn:00008F62
.text$mn:00008F62 ; ---------------------------------------------------------------------------
.text$mn:00008F65                 align 4
.text$mn:00008F65 _text$mn        ends
.text$mn:00008F65
.text$mn:00008F68 ; ===========================================================================
.text$mn:00008F68
.text$mn:00008F68 ; Segment type: Pure code
.text$mn:00008F68 ; Segment permissions: Read/Execute
.text$mn:00008F68 _text$mn        segment para public 'CODE' use32
.text$mn:00008F68                 assume cs:_text$mn
.text$mn:00008F68                 ;org 8F68h
.text$mn:00008F68 ; COMDAT (pick any)
.text$mn:00008F68                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008F68
.text$mn:00008F68 ; =============== S U B R O U T I N E =======================================
.text$mn:00008F68
.text$mn:00008F68 ; Attributes: bp-based frame
.text$mn:00008F68
.text$mn:00008F68 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Copy(unsigned int, unsigned int)
.text$mn:00008F68                 public ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00008F68 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
.text$mn:00008F68                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+37p
.text$mn:00008F68
.text$mn:00008F68 var_20          = dword ptr -20h
.text$mn:00008F68 var_1C          = dword ptr -1Ch
.text$mn:00008F68 var_18          = dword ptr -18h
.text$mn:00008F68 var_11          = byte ptr -11h
.text$mn:00008F68 var_10          = dword ptr -10h
.text$mn:00008F68 var_C           = byte ptr -0Ch
.text$mn:00008F68 var_4           = dword ptr -4
.text$mn:00008F68 arg_0           = dword ptr  8
.text$mn:00008F68
.text$mn:00008F68 ; FUNCTION CHUNK AT .text$mn:0000908A SIZE 00000009 BYTES
.text$mn:00008F68
.text$mn:00008F68                 push    ebp
.text$mn:00008F69                 mov     ebp, esp
.text$mn:00008F6B                 push    0FFFFFFFFh
.text$mn:00008F6D                 push    offset __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00008F72                 mov     eax, large fs:0
.text$mn:00008F78                 push    eax
.text$mn:00008F79                 push    ecx
.text$mn:00008F7A                 sub     esp, 10h
.text$mn:00008F7D                 push    ebx
.text$mn:00008F7E                 push    esi
.text$mn:00008F7F                 push    edi
.text$mn:00008F80                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00008F85                 xor     eax, ebp
.text$mn:00008F87                 push    eax
.text$mn:00008F88                 lea     eax, [ebp+var_C]
.text$mn:00008F8B                 mov     large fs:0, eax
.text$mn:00008F91                 mov     [ebp+var_10], esp
.text$mn:00008F94                 mov     [ebp+var_18], ecx
.text$mn:00008F97                 mov     eax, [ebp+arg_0]
.text$mn:00008F9A                 or      eax, 0Fh
.text$mn:00008F9D                 mov     [ebp+var_1C], eax
.text$mn:00008FA0                 mov     ecx, [ebp+var_18]
.text$mn:00008FA3                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00008FA8                 cmp     eax, [ebp+var_1C]
.text$mn:00008FAB                 jnb     short loc_8FB5
.text$mn:00008FAD                 mov     ecx, [ebp+arg_0]
.text$mn:00008FB0                 mov     [ebp+var_1C], ecx
.text$mn:00008FB3                 jmp     short loc_9007
.text$mn:00008FB5 ; ---------------------------------------------------------------------------
.text$mn:00008FB5
.text$mn:00008FB5 loc_8FB5:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+43j
.text$mn:00008FB5                 mov     edx, [ebp+var_18]
.text$mn:00008FB8                 mov     ecx, [edx+18h]
.text$mn:00008FBB                 shr     ecx, 1
.text$mn:00008FBD                 mov     eax, [ebp+var_1C]
.text$mn:00008FC0                 xor     edx, edx
.text$mn:00008FC2                 mov     esi, 3
.text$mn:00008FC7                 div     esi
.text$mn:00008FC9                 cmp     ecx, eax
.text$mn:00008FCB                 ja      short loc_8FCF
.text$mn:00008FCD                 jmp     short loc_9007
.text$mn:00008FCF ; ---------------------------------------------------------------------------
.text$mn:00008FCF
.text$mn:00008FCF loc_8FCF:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+63j
.text$mn:00008FCF                 mov     ecx, [ebp+var_18]
.text$mn:00008FD2                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00008FD7                 mov     edx, [ebp+var_18]
.text$mn:00008FDA                 mov     ecx, [edx+18h]
.text$mn:00008FDD                 shr     ecx, 1
.text$mn:00008FDF                 sub     eax, ecx
.text$mn:00008FE1                 mov     edx, [ebp+var_18]
.text$mn:00008FE4                 cmp     [edx+18h], eax
.text$mn:00008FE7                 ja      short loc_8FFC
.text$mn:00008FE9                 mov     eax, [ebp+var_18]
.text$mn:00008FEC                 mov     ecx, [eax+18h]
.text$mn:00008FEF                 shr     ecx, 1
.text$mn:00008FF1                 mov     edx, [ebp+var_18]
.text$mn:00008FF4                 add     ecx, [edx+18h]
.text$mn:00008FF7                 mov     [ebp+var_1C], ecx
.text$mn:00008FFA                 jmp     short loc_9007
.text$mn:00008FFC ; ---------------------------------------------------------------------------
.text$mn:00008FFC
.text$mn:00008FFC loc_8FFC:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+7Fj
.text$mn:00008FFC                 mov     ecx, [ebp+var_18]
.text$mn:00008FFF                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00009004                 mov     [ebp+var_1C], eax
.text$mn:00009007
.text$mn:00009007 loc_9007:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+4Bj
.text$mn:00009007                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+65j ...
.text$mn:00009007                 mov     [ebp+var_4], 0
.text$mn:0000900E                 mov     eax, [ebp+var_1C]
.text$mn:00009011                 add     eax, 1
.text$mn:00009014                 push    eax
.text$mn:00009015                 lea     ecx, [ebp+var_11]
.text$mn:00009018                 push    ecx
.text$mn:00009019                 mov     ecx, [ebp+var_18]
.text$mn:0000901C                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00009021                 mov     ecx, eax
.text$mn:00009023                 call    ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
.text$mn:00009028                 mov     [ebp+var_20], eax
.text$mn:0000902B                 jmp     short loc_908A
.text$mn:0000902B ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp
.text$mn:0000902B
.text$mn:0000902D
.text$mn:0000902D ; =============== S U B R O U T I N E =======================================
.text$mn:0000902D
.text$mn:0000902D
.text$mn:0000902D __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 proc near
.text$mn:0000902D                                         ; DATA XREF: .xdata$x:0000C760o
.text$mn:0000902D
.text$mn:0000902D ; FUNCTION CHUNK AT .text$mn:00009074 SIZE 00000009 BYTES
.text$mn:0000902D ; FUNCTION CHUNK AT .text$mn:00009084 SIZE 00000006 BYTES
.text$mn:0000902D
.text$mn:0000902D                 mov     [ebp-10h], esp
.text$mn:00009030                 mov     edx, [ebp+8]
.text$mn:00009033                 mov     [ebp-1Ch], edx
.text$mn:00009036                 mov     byte ptr [ebp-4], 2
.text$mn:0000903A                 mov     eax, [ebp-1Ch]
.text$mn:0000903D                 add     eax, 1
.text$mn:00009040                 push    eax
.text$mn:00009041                 lea     ecx, [ebp-12h]
.text$mn:00009044                 push    ecx
.text$mn:00009045                 mov     ecx, [ebp-18h]
.text$mn:00009048                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:0000904D                 mov     ecx, eax
.text$mn:0000904F                 call    ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
.text$mn:00009054                 mov     [ebp-20h], eax
.text$mn:00009057                 jmp     short loc_9074
.text$mn:00009057 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 endp
.text$mn:00009057
.text$mn:00009059
.text$mn:00009059 ; =============== S U B R O U T I N E =======================================
.text$mn:00009059
.text$mn:00009059 ; Attributes: noreturn
.text$mn:00009059
.text$mn:00009059 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 proc near
.text$mn:00009059                                         ; DATA XREF: .xdata$x:0000C770o
.text$mn:00009059                 push    0               ; Size
.text$mn:0000905B                 push    1               ; char
.text$mn:0000905D                 mov     ecx, [ebp-18h]
.text$mn:00009060                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00009065                 push    0
.text$mn:00009067                 push    0
.text$mn:00009069                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00009069 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 endp
.text$mn:00009069
.text$mn:0000906E ; ---------------------------------------------------------------------------
.text$mn:0000906E                 mov     eax, offset $LN17
.text$mn:00009073                 retn
.text$mn:00009074 ; ---------------------------------------------------------------------------
.text$mn:00009074 ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00009074
.text$mn:00009074 loc_9074:                               ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+2Aj
.text$mn:00009074                 mov     dword ptr [ebp-4], 1
.text$mn:0000907B                 jmp     short loc_9084
.text$mn:0000907B ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:0000907D
.text$mn:0000907D ; =============== S U B R O U T I N E =======================================
.text$mn:0000907D
.text$mn:0000907D
.text$mn:0000907D $LN17           proc near               ; DATA XREF: .text$mn:0000906Eo
.text$mn:0000907D                 mov     dword ptr [ebp-4], 1
.text$mn:0000907D $LN17           endp ; sp-analysis failed
.text$mn:0000907D
.text$mn:00009084 ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00009084
.text$mn:00009084 loc_9084:                               ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+4Ej
.text$mn:00009084                 mov     eax, offset $LN19
.text$mn:00009089                 retn
.text$mn:00009089 ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:0000908A ; ---------------------------------------------------------------------------
.text$mn:0000908A ; START OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:0000908A
.text$mn:0000908A loc_908A:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+C3j
.text$mn:0000908A                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00009091                 jmp     short loc_909A
.text$mn:00009091 ; END OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00009093
.text$mn:00009093 ; =============== S U B R O U T I N E =======================================
.text$mn:00009093
.text$mn:00009093
.text$mn:00009093 $LN19           proc near               ; DATA XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:loc_9084o
.text$mn:00009093                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:0000909A
.text$mn:0000909A loc_909A:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+129j
.text$mn:0000909A                 cmp     dword ptr [ebp+0Ch], 0
.text$mn:0000909E                 jbe     short loc_90B9
.text$mn:000090A0                 mov     edx, [ebp+0Ch]
.text$mn:000090A3                 push    edx             ; Size
.text$mn:000090A4                 mov     ecx, [ebp-18h]
.text$mn:000090A7                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000090AC                 push    eax             ; Src
.text$mn:000090AD                 mov     eax, [ebp-20h]
.text$mn:000090B0                 push    eax             ; Dst
.text$mn:000090B1                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:000090B6                 add     esp, 0Ch
.text$mn:000090B9
.text$mn:000090B9 loc_90B9:                               ; CODE XREF: $LN19+Bj
.text$mn:000090B9                 push    0               ; Size
.text$mn:000090BB                 push    1               ; char
.text$mn:000090BD                 mov     ecx, [ebp-18h]
.text$mn:000090C0                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:000090C5                 lea     ecx, [ebp-20h]
.text$mn:000090C8                 push    ecx             ; int
.text$mn:000090C9                 mov     edx, [ebp-18h]
.text$mn:000090CC                 add     edx, 4
.text$mn:000090CF                 push    edx             ; void *
.text$mn:000090D0                 lea     eax, [ebp-13h]
.text$mn:000090D3                 push    eax
.text$mn:000090D4                 mov     ecx, [ebp-18h]
.text$mn:000090D7                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:000090DC                 mov     ecx, eax
.text$mn:000090DE                 call    ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)
.text$mn:000090E3                 mov     ecx, [ebp-18h]
.text$mn:000090E6                 mov     edx, [ebp-1Ch]
.text$mn:000090E9                 mov     [ecx+18h], edx
.text$mn:000090EC                 mov     eax, [ebp+0Ch]
.text$mn:000090EF                 push    eax
.text$mn:000090F0                 mov     ecx, [ebp-18h]
.text$mn:000090F3                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000090F8                 mov     ecx, [ebp-0Ch]
.text$mn:000090FB                 mov     large fs:0, ecx
.text$mn:00009102                 pop     ecx
.text$mn:00009103                 pop     edi
.text$mn:00009104                 pop     esi
.text$mn:00009105                 pop     ebx
.text$mn:00009106                 mov     esp, ebp
.text$mn:00009108                 pop     ebp
.text$mn:00009109                 retn    8
.text$mn:00009109 $LN19           endp ; sp-analysis failed
.text$mn:00009109
.text$mn:00009109 _text$mn        ends
.text$mn:00009109
.text$x:0000910C ; ===========================================================================
.text$x:0000910C
.text$x:0000910C ; Segment type: Pure code
.text$x:0000910C ; Segment permissions: Read/Execute
.text$x:0000910C _text$x         segment para public 'CODE' use32
.text$x:0000910C                 assume cs:_text$x
.text$x:0000910C                 ;org 910Ch
.text$x:0000910C ; COMDAT (pick associative to section at 8F68)
.text$x:0000910C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000910C
.text$x:0000910C ; =============== S U B R O U T I N E =======================================
.text$x:0000910C
.text$x:0000910C
.text$x:0000910C __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
.text$x:0000910C                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+5o
.text$x:0000910C
.text$x:0000910C arg_4           = dword ptr  8
.text$x:0000910C
.text$x:0000910C                 mov     edx, [esp+arg_4]
.text$x:00009110                 lea     eax, [edx+0Ch]
.text$x:00009113                 mov     ecx, [edx-24h]
.text$x:00009116                 xor     ecx, eax
.text$x:00009118                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000911D                 mov     eax, offset __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$x:00009122                 jmp     ___CxxFrameHandler3
.text$x:00009122 __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp
.text$x:00009122
.text$x:00009122 ; ---------------------------------------------------------------------------
.text$x:00009127                 align 4
.text$x:00009127 _text$x         ends
.text$x:00009127
.text$mn:00009128 ; ===========================================================================
.text$mn:00009128
.text$mn:00009128 ; Segment type: Pure code
.text$mn:00009128 ; Segment permissions: Read/Execute
.text$mn:00009128 _text$mn        segment para public 'CODE' use32
.text$mn:00009128                 assume cs:_text$mn
.text$mn:00009128                 ;org 9128h
.text$mn:00009128 ; COMDAT (pick any)
.text$mn:00009128                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009128
.text$mn:00009128 ; =============== S U B R O U T I N E =======================================
.text$mn:00009128
.text$mn:00009128 ; Attributes: bp-based frame
.text$mn:00009128
.text$mn:00009128 ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Copy(unsigned int, unsigned int)
.text$mn:00009128                 public ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.text$mn:00009128 ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z proc near
.text$mn:00009128                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+37p
.text$mn:00009128
.text$mn:00009128 var_20          = dword ptr -20h
.text$mn:00009128 var_1C          = dword ptr -1Ch
.text$mn:00009128 var_18          = dword ptr -18h
.text$mn:00009128 var_11          = byte ptr -11h
.text$mn:00009128 var_10          = dword ptr -10h
.text$mn:00009128 var_C           = byte ptr -0Ch
.text$mn:00009128 var_4           = dword ptr -4
.text$mn:00009128 arg_0           = dword ptr  8
.text$mn:00009128
.text$mn:00009128 ; FUNCTION CHUNK AT .text$mn:0000924A SIZE 00000009 BYTES
.text$mn:00009128
.text$mn:00009128                 push    ebp
.text$mn:00009129                 mov     ebp, esp
.text$mn:0000912B                 push    0FFFFFFFFh
.text$mn:0000912D                 push    offset __ehhandler$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.text$mn:00009132                 mov     eax, large fs:0
.text$mn:00009138                 push    eax
.text$mn:00009139                 push    ecx
.text$mn:0000913A                 sub     esp, 10h
.text$mn:0000913D                 push    ebx
.text$mn:0000913E                 push    esi
.text$mn:0000913F                 push    edi
.text$mn:00009140                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00009145                 xor     eax, ebp
.text$mn:00009147                 push    eax
.text$mn:00009148                 lea     eax, [ebp+var_C]
.text$mn:0000914B                 mov     large fs:0, eax
.text$mn:00009151                 mov     [ebp+var_10], esp
.text$mn:00009154                 mov     [ebp+var_18], ecx
.text$mn:00009157                 mov     eax, [ebp+arg_0]
.text$mn:0000915A                 or      eax, 7
.text$mn:0000915D                 mov     [ebp+var_1C], eax
.text$mn:00009160                 mov     ecx, [ebp+var_18]
.text$mn:00009163                 call    ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)
.text$mn:00009168                 cmp     eax, [ebp+var_1C]
.text$mn:0000916B                 jnb     short loc_9175
.text$mn:0000916D                 mov     ecx, [ebp+arg_0]
.text$mn:00009170                 mov     [ebp+var_1C], ecx
.text$mn:00009173                 jmp     short loc_91C7
.text$mn:00009175 ; ---------------------------------------------------------------------------
.text$mn:00009175
.text$mn:00009175 loc_9175:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+43j
.text$mn:00009175                 mov     edx, [ebp+var_18]
.text$mn:00009178                 mov     ecx, [edx+18h]
.text$mn:0000917B                 shr     ecx, 1
.text$mn:0000917D                 mov     eax, [ebp+var_1C]
.text$mn:00009180                 xor     edx, edx
.text$mn:00009182                 mov     esi, 3
.text$mn:00009187                 div     esi
.text$mn:00009189                 cmp     ecx, eax
.text$mn:0000918B                 ja      short loc_918F
.text$mn:0000918D                 jmp     short loc_91C7
.text$mn:0000918F ; ---------------------------------------------------------------------------
.text$mn:0000918F
.text$mn:0000918F loc_918F:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+63j
.text$mn:0000918F                 mov     ecx, [ebp+var_18]
.text$mn:00009192                 call    ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)
.text$mn:00009197                 mov     edx, [ebp+var_18]
.text$mn:0000919A                 mov     ecx, [edx+18h]
.text$mn:0000919D                 shr     ecx, 1
.text$mn:0000919F                 sub     eax, ecx
.text$mn:000091A1                 mov     edx, [ebp+var_18]
.text$mn:000091A4                 cmp     [edx+18h], eax
.text$mn:000091A7                 ja      short loc_91BC
.text$mn:000091A9                 mov     eax, [ebp+var_18]
.text$mn:000091AC                 mov     ecx, [eax+18h]
.text$mn:000091AF                 shr     ecx, 1
.text$mn:000091B1                 mov     edx, [ebp+var_18]
.text$mn:000091B4                 add     ecx, [edx+18h]
.text$mn:000091B7                 mov     [ebp+var_1C], ecx
.text$mn:000091BA                 jmp     short loc_91C7
.text$mn:000091BC ; ---------------------------------------------------------------------------
.text$mn:000091BC
.text$mn:000091BC loc_91BC:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+7Fj
.text$mn:000091BC                 mov     ecx, [ebp+var_18]
.text$mn:000091BF                 call    ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)
.text$mn:000091C4                 mov     [ebp+var_1C], eax
.text$mn:000091C7
.text$mn:000091C7 loc_91C7:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+4Bj
.text$mn:000091C7                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+65j ...
.text$mn:000091C7                 mov     [ebp+var_4], 0
.text$mn:000091CE                 mov     eax, [ebp+var_1C]
.text$mn:000091D1                 add     eax, 1
.text$mn:000091D4                 push    eax
.text$mn:000091D5                 lea     ecx, [ebp+var_11]
.text$mn:000091D8                 push    ecx
.text$mn:000091D9                 mov     ecx, [ebp+var_18]
.text$mn:000091DC                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:000091E1                 mov     ecx, eax
.text$mn:000091E3                 call    ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::allocate(uint)
.text$mn:000091E8                 mov     [ebp+var_20], eax
.text$mn:000091EB                 jmp     short loc_924A
.text$mn:000091EB ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z endp
.text$mn:000091EB
.text$mn:000091ED
.text$mn:000091ED ; =============== S U B R O U T I N E =======================================
.text$mn:000091ED
.text$mn:000091ED
.text$mn:000091ED __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0 proc near
.text$mn:000091ED                                         ; DATA XREF: .xdata$x:0000CAD8o
.text$mn:000091ED
.text$mn:000091ED ; FUNCTION CHUNK AT .text$mn:00009234 SIZE 00000009 BYTES
.text$mn:000091ED ; FUNCTION CHUNK AT .text$mn:00009244 SIZE 00000006 BYTES
.text$mn:000091ED
.text$mn:000091ED                 mov     [ebp-10h], esp
.text$mn:000091F0                 mov     edx, [ebp+8]
.text$mn:000091F3                 mov     [ebp-1Ch], edx
.text$mn:000091F6                 mov     byte ptr [ebp-4], 2
.text$mn:000091FA                 mov     eax, [ebp-1Ch]
.text$mn:000091FD                 add     eax, 1
.text$mn:00009200                 push    eax
.text$mn:00009201                 lea     ecx, [ebp-12h]
.text$mn:00009204                 push    ecx
.text$mn:00009205                 mov     ecx, [ebp-18h]
.text$mn:00009208                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:0000920D                 mov     ecx, eax
.text$mn:0000920F                 call    ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::allocate(uint)
.text$mn:00009214                 mov     [ebp-20h], eax
.text$mn:00009217                 jmp     short loc_9234
.text$mn:00009217 __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0 endp
.text$mn:00009217
.text$mn:00009219
.text$mn:00009219 ; =============== S U B R O U T I N E =======================================
.text$mn:00009219
.text$mn:00009219 ; Attributes: noreturn
.text$mn:00009219
.text$mn:00009219 __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$1 proc near
.text$mn:00009219                                         ; DATA XREF: .xdata$x:0000CAE8o
.text$mn:00009219                 push    0
.text$mn:0000921B                 push    1
.text$mn:0000921D                 mov     ecx, [ebp-18h]
.text$mn:00009220                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:00009225                 push    0
.text$mn:00009227                 push    0
.text$mn:00009229                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00009229 __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$1 endp
.text$mn:00009229
.text$mn:0000922E ; ---------------------------------------------------------------------------
.text$mn:0000922E                 mov     eax, offset $LN17_0
.text$mn:00009233                 retn
.text$mn:00009234 ; ---------------------------------------------------------------------------
.text$mn:00009234 ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0
.text$mn:00009234
.text$mn:00009234 loc_9234:                               ; CODE XREF: __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0+2Aj
.text$mn:00009234                 mov     dword ptr [ebp-4], 1
.text$mn:0000923B                 jmp     short loc_9244
.text$mn:0000923B ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0
.text$mn:0000923D
.text$mn:0000923D ; =============== S U B R O U T I N E =======================================
.text$mn:0000923D
.text$mn:0000923D
.text$mn:0000923D $LN17_0         proc near               ; DATA XREF: .text$mn:0000922Eo
.text$mn:0000923D                 mov     dword ptr [ebp-4], 1
.text$mn:0000923D $LN17_0         endp ; sp-analysis failed
.text$mn:0000923D
.text$mn:00009244 ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0
.text$mn:00009244
.text$mn:00009244 loc_9244:                               ; CODE XREF: __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0+4Ej
.text$mn:00009244                 mov     eax, offset $LN19_0
.text$mn:00009249                 retn
.text$mn:00009249 ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0
.text$mn:0000924A ; ---------------------------------------------------------------------------
.text$mn:0000924A ; START OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.text$mn:0000924A
.text$mn:0000924A loc_924A:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+C3j
.text$mn:0000924A                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00009251                 jmp     short loc_925A
.text$mn:00009251 ; END OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.text$mn:00009253
.text$mn:00009253 ; =============== S U B R O U T I N E =======================================
.text$mn:00009253
.text$mn:00009253
.text$mn:00009253 $LN19_0         proc near               ; DATA XREF: __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0:loc_9244o
.text$mn:00009253                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:0000925A
.text$mn:0000925A loc_925A:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+129j
.text$mn:0000925A                 cmp     dword ptr [ebp+0Ch], 0
.text$mn:0000925E                 jbe     short loc_9279
.text$mn:00009260                 mov     edx, [ebp+0Ch]
.text$mn:00009263                 push    edx             ; int
.text$mn:00009264                 mov     ecx, [ebp-18h]
.text$mn:00009267                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000926C                 push    eax             ; Src
.text$mn:0000926D                 mov     eax, [ebp-20h]
.text$mn:00009270                 push    eax             ; Dst
.text$mn:00009271                 call    ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)
.text$mn:00009276                 add     esp, 0Ch
.text$mn:00009279
.text$mn:00009279 loc_9279:                               ; CODE XREF: $LN19_0+Bj
.text$mn:00009279                 push    0
.text$mn:0000927B                 push    1
.text$mn:0000927D                 mov     ecx, [ebp-18h]
.text$mn:00009280                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:00009285                 lea     ecx, [ebp-20h]
.text$mn:00009288                 push    ecx             ; int
.text$mn:00009289                 mov     edx, [ebp-18h]
.text$mn:0000928C                 add     edx, 4
.text$mn:0000928F                 push    edx             ; void *
.text$mn:00009290                 lea     eax, [ebp-13h]
.text$mn:00009293                 push    eax
.text$mn:00009294                 mov     ecx, [ebp-18h]
.text$mn:00009297                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:0000929C                 mov     ecx, eax
.text$mn:0000929E                 call    ??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)
.text$mn:000092A3                 mov     ecx, [ebp-18h]
.text$mn:000092A6                 mov     edx, [ebp-1Ch]
.text$mn:000092A9                 mov     [ecx+18h], edx
.text$mn:000092AC                 mov     eax, [ebp+0Ch]
.text$mn:000092AF                 push    eax
.text$mn:000092B0                 mov     ecx, [ebp-18h]
.text$mn:000092B3                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:000092B8                 mov     ecx, [ebp-0Ch]
.text$mn:000092BB                 mov     large fs:0, ecx
.text$mn:000092C2                 pop     ecx
.text$mn:000092C3                 pop     edi
.text$mn:000092C4                 pop     esi
.text$mn:000092C5                 pop     ebx
.text$mn:000092C6                 mov     esp, ebp
.text$mn:000092C8                 pop     ebp
.text$mn:000092C9                 retn    8
.text$mn:000092C9 $LN19_0         endp ; sp-analysis failed
.text$mn:000092C9
.text$mn:000092C9 _text$mn        ends
.text$mn:000092C9
.text$x:000092CC ; ===========================================================================
.text$x:000092CC
.text$x:000092CC ; Segment type: Pure code
.text$x:000092CC ; Segment permissions: Read/Execute
.text$x:000092CC _text$x         segment para public 'CODE' use32
.text$x:000092CC                 assume cs:_text$x
.text$x:000092CC                 ;org 92CCh
.text$x:000092CC ; COMDAT (pick associative to section at 9128)
.text$x:000092CC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000092CC
.text$x:000092CC ; =============== S U B R O U T I N E =======================================
.text$x:000092CC
.text$x:000092CC
.text$x:000092CC __ehhandler$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z proc near
.text$x:000092CC                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+5o
.text$x:000092CC
.text$x:000092CC arg_4           = dword ptr  8
.text$x:000092CC
.text$x:000092CC                 mov     edx, [esp+arg_4]
.text$x:000092D0                 lea     eax, [edx+0Ch]
.text$x:000092D3                 mov     ecx, [edx-24h]
.text$x:000092D6                 xor     ecx, eax
.text$x:000092D8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000092DD                 mov     eax, offset __ehfuncinfo$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.text$x:000092E2                 jmp     ___CxxFrameHandler3
.text$x:000092E2 __ehhandler$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z endp
.text$x:000092E2
.text$x:000092E2 ; ---------------------------------------------------------------------------
.text$x:000092E7                 align 4
.text$x:000092E7 _text$x         ends
.text$x:000092E7
.text$mn:000092E8 ; ===========================================================================
.text$mn:000092E8
.text$mn:000092E8 ; Segment type: Pure code
.text$mn:000092E8 ; Segment permissions: Read/Execute
.text$mn:000092E8 _text$mn        segment para public 'CODE' use32
.text$mn:000092E8                 assume cs:_text$mn
.text$mn:000092E8                 ;org 92E8h
.text$mn:000092E8 ; COMDAT (pick any)
.text$mn:000092E8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000092E8
.text$mn:000092E8 ; =============== S U B R O U T I N E =======================================
.text$mn:000092E8
.text$mn:000092E8 ; Attributes: bp-based frame
.text$mn:000092E8
.text$mn:000092E8 ; protected: void __thiscall std::vector<int, class std::allocator<int>>::_Destroy(int *, int *)
.text$mn:000092E8                 public ?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z
.text$mn:000092E8 ?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z proc near
.text$mn:000092E8                                         ; CODE XREF: std::vector<int,std::allocator<int>>::_Pop_back_n(uint)+3Bp
.text$mn:000092E8                                         ; std::vector<int,std::allocator<int>>::_Reallocate(uint)+CBp ...
.text$mn:000092E8
.text$mn:000092E8 var_8           = dword ptr -8
.text$mn:000092E8 var_1           = byte ptr -1
.text$mn:000092E8 arg_0           = dword ptr  8
.text$mn:000092E8 arg_4           = dword ptr  0Ch
.text$mn:000092E8
.text$mn:000092E8                 push    ebp
.text$mn:000092E9                 mov     ebp, esp
.text$mn:000092EB                 sub     esp, 8
.text$mn:000092EE                 mov     [ebp+var_8], ecx
.text$mn:000092F1                 lea     eax, [ebp+var_1]
.text$mn:000092F4                 push    eax
.text$mn:000092F5                 mov     ecx, [ebp+var_8]
.text$mn:000092F8                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@H@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>::_Getal(void)
.text$mn:000092FD                 lea     ecx, [ebp+var_1]
.text$mn:00009300                 push    ecx
.text$mn:00009301                 mov     edx, [ebp+arg_4]
.text$mn:00009304                 push    edx
.text$mn:00009305                 mov     eax, [ebp+arg_0]
.text$mn:00009308                 push    eax
.text$mn:00009309                 call    ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@@std@@YAXPAH0AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<int>>>(int *,int *,std::_Wrap_alloc<std::allocator<int>> &)
.text$mn:0000930E                 add     esp, 0Ch
.text$mn:00009311                 mov     esp, ebp
.text$mn:00009313                 pop     ebp
.text$mn:00009314                 retn    8
.text$mn:00009314 ?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z endp
.text$mn:00009314
.text$mn:00009314 ; ---------------------------------------------------------------------------
.text$mn:00009317                 align 4
.text$mn:00009317 _text$mn        ends
.text$mn:00009317
.text$mn:00009318 ; ===========================================================================
.text$mn:00009318
.text$mn:00009318 ; Segment type: Pure code
.text$mn:00009318 ; Segment permissions: Read/Execute
.text$mn:00009318 _text$mn        segment para public 'CODE' use32
.text$mn:00009318                 assume cs:_text$mn
.text$mn:00009318                 ;org 9318h
.text$mn:00009318 ; COMDAT (pick any)
.text$mn:00009318                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009318
.text$mn:00009318 ; =============== S U B R O U T I N E =======================================
.text$mn:00009318
.text$mn:00009318 ; Attributes: bp-based frame
.text$mn:00009318
.text$mn:00009318 ; protected: void __thiscall std::vector<wchar_t, class std::allocator<wchar_t>>::_Destroy(wchar_t *, wchar_t *)
.text$mn:00009318                 public ?_Destroy@?$vector@_WV?$allocator@_W@std@@@std@@IAEXPA_W0@Z
.text$mn:00009318 ?_Destroy@?$vector@_WV?$allocator@_W@std@@@std@@IAEXPA_W0@Z proc near
.text$mn:00009318                                         ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::_Reallocate(uint)+CBp
.text$mn:00009318                                         ; std::vector<wchar_t,std::allocator<wchar_t>>::_Tidy(void)+2Bp
.text$mn:00009318
.text$mn:00009318 var_8           = dword ptr -8
.text$mn:00009318 var_1           = byte ptr -1
.text$mn:00009318 arg_0           = dword ptr  8
.text$mn:00009318 arg_4           = dword ptr  0Ch
.text$mn:00009318
.text$mn:00009318                 push    ebp
.text$mn:00009319                 mov     ebp, esp
.text$mn:0000931B                 sub     esp, 8
.text$mn:0000931E                 mov     [ebp+var_8], ecx
.text$mn:00009321                 lea     eax, [ebp+var_1]
.text$mn:00009324                 push    eax
.text$mn:00009325                 mov     ecx, [ebp+var_8]
.text$mn:00009328                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:0000932D                 lea     ecx, [ebp+var_1]
.text$mn:00009330                 push    ecx
.text$mn:00009331                 mov     edx, [ebp+arg_4]
.text$mn:00009334                 push    edx
.text$mn:00009335                 mov     eax, [ebp+arg_0]
.text$mn:00009338                 push    eax
.text$mn:00009339                 call    ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YAXPA_W0AAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<wchar_t>>>(wchar_t *,wchar_t *,std::_Wrap_alloc<std::allocator<wchar_t>> &)
.text$mn:0000933E                 add     esp, 0Ch
.text$mn:00009341                 mov     esp, ebp
.text$mn:00009343                 pop     ebp
.text$mn:00009344                 retn    8
.text$mn:00009344 ?_Destroy@?$vector@_WV?$allocator@_W@std@@@std@@IAEXPA_W0@Z endp
.text$mn:00009344
.text$mn:00009344 ; ---------------------------------------------------------------------------
.text$mn:00009347                 align 4
.text$mn:00009347 _text$mn        ends
.text$mn:00009347
.text$mn:00009348 ; ===========================================================================
.text$mn:00009348
.text$mn:00009348 ; Segment type: Pure code
.text$mn:00009348 ; Segment permissions: Read/Execute
.text$mn:00009348 _text$mn        segment para public 'CODE' use32
.text$mn:00009348                 assume cs:_text$mn
.text$mn:00009348                 ;org 9348h
.text$mn:00009348 ; COMDAT (pick any)
.text$mn:00009348                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009348
.text$mn:00009348 ; =============== S U B R O U T I N E =======================================
.text$mn:00009348
.text$mn:00009348 ; Attributes: bp-based frame
.text$mn:00009348
.text$mn:00009348 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Eos(unsigned int)
.text$mn:00009348                 public ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
.text$mn:00009348 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z proc near
.text$mn:00009348                                         ; CODE XREF: $LN19+60p
.text$mn:00009348                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+83p ...
.text$mn:00009348
.text$mn:00009348 var_8           = dword ptr -8
.text$mn:00009348 var_1           = byte ptr -1
.text$mn:00009348 arg_0           = dword ptr  8
.text$mn:00009348
.text$mn:00009348                 push    ebp
.text$mn:00009349                 mov     ebp, esp
.text$mn:0000934B                 sub     esp, 8
.text$mn:0000934E                 mov     [ebp+var_8], ecx
.text$mn:00009351                 mov     [ebp+var_1], 0
.text$mn:00009355                 mov     eax, [ebp+var_8]
.text$mn:00009358                 mov     ecx, [ebp+arg_0]
.text$mn:0000935B                 mov     [eax+14h], ecx
.text$mn:0000935E                 lea     edx, [ebp+var_1]
.text$mn:00009361                 push    edx
.text$mn:00009362                 mov     ecx, [ebp+var_8]
.text$mn:00009365                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000936A                 add     eax, [ebp+arg_0]
.text$mn:0000936D                 push    eax
.text$mn:0000936E                 call    ?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign(char &,char const &)
.text$mn:00009373                 add     esp, 8
.text$mn:00009376                 mov     esp, ebp
.text$mn:00009378                 pop     ebp
.text$mn:00009379                 retn    4
.text$mn:00009379 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z endp
.text$mn:00009379
.text$mn:00009379 _text$mn        ends
.text$mn:00009379
.text$mn:0000937C ; ===========================================================================
.text$mn:0000937C
.text$mn:0000937C ; Segment type: Pure code
.text$mn:0000937C ; Segment permissions: Read/Execute
.text$mn:0000937C _text$mn        segment para public 'CODE' use32
.text$mn:0000937C                 assume cs:_text$mn
.text$mn:0000937C                 ;org 937Ch
.text$mn:0000937C ; COMDAT (pick any)
.text$mn:0000937C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000937C
.text$mn:0000937C ; =============== S U B R O U T I N E =======================================
.text$mn:0000937C
.text$mn:0000937C ; Attributes: bp-based frame
.text$mn:0000937C
.text$mn:0000937C ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Eos(unsigned int)
.text$mn:0000937C                 public ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z
.text$mn:0000937C ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z proc near
.text$mn:0000937C                                         ; CODE XREF: $LN19_0+60p
.text$mn:0000937C                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+83p ...
.text$mn:0000937C
.text$mn:0000937C var_8           = dword ptr -8
.text$mn:0000937C var_2           = word ptr -2
.text$mn:0000937C arg_0           = dword ptr  8
.text$mn:0000937C
.text$mn:0000937C                 push    ebp
.text$mn:0000937D                 mov     ebp, esp
.text$mn:0000937F                 sub     esp, 8
.text$mn:00009382                 mov     [ebp+var_8], ecx
.text$mn:00009385                 xor     eax, eax
.text$mn:00009387                 mov     [ebp+var_2], ax
.text$mn:0000938B                 mov     ecx, [ebp+var_8]
.text$mn:0000938E                 mov     edx, [ebp+arg_0]
.text$mn:00009391                 mov     [ecx+14h], edx
.text$mn:00009394                 lea     eax, [ebp+var_2]
.text$mn:00009397                 push    eax
.text$mn:00009398                 mov     ecx, [ebp+var_8]
.text$mn:0000939B                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:000093A0                 mov     ecx, [ebp+arg_0]
.text$mn:000093A3                 lea     edx, [eax+ecx*2]
.text$mn:000093A6                 push    edx
.text$mn:000093A7                 call    ?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z ; std::char_traits<wchar_t>::assign(wchar_t &,wchar_t const &)
.text$mn:000093AC                 add     esp, 8
.text$mn:000093AF                 mov     esp, ebp
.text$mn:000093B1                 pop     ebp
.text$mn:000093B2                 retn    4
.text$mn:000093B2 ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z endp
.text$mn:000093B2
.text$mn:000093B2 ; ---------------------------------------------------------------------------
.text$mn:000093B5                 align 4
.text$mn:000093B5 _text$mn        ends
.text$mn:000093B5
.text$mn:000093B8 ; ===========================================================================
.text$mn:000093B8
.text$mn:000093B8 ; Segment type: Pure code
.text$mn:000093B8 ; Segment permissions: Read/Execute
.text$mn:000093B8 _text$mn        segment para public 'CODE' use32
.text$mn:000093B8                 assume cs:_text$mn
.text$mn:000093B8                 ;org 93B8h
.text$mn:000093B8 ; COMDAT (pick any)
.text$mn:000093B8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000093B8
.text$mn:000093B8 ; =============== S U B R O U T I N E =======================================
.text$mn:000093B8
.text$mn:000093B8 ; Attributes: bp-based frame
.text$mn:000093B8
.text$mn:000093B8 ; public: int * __thiscall std::_Temp_iterator<int>::_First(void)const
.text$mn:000093B8                 public ?_First@?$_Temp_iterator@H@std@@QBEPAHXZ
.text$mn:000093B8 ?_First@?$_Temp_iterator@H@std@@QBEPAHXZ proc near
.text$mn:000093B8                                         ; CODE XREF: std::_Buffered_merge<int *,int,int,BufferEquivalent>(int *,int *,int *,int,int,std::_Temp_iterator<int> &,BufferEquivalent)+130p
.text$mn:000093B8                                         ; std::_Buffered_merge<int *,int,int,BufferEquivalent>(int *,int *,int *,int,int,std::_Temp_iterator<int> &,BufferEquivalent)+1CCp ...
.text$mn:000093B8
.text$mn:000093B8 var_4           = dword ptr -4
.text$mn:000093B8
.text$mn:000093B8                 push    ebp
.text$mn:000093B9                 mov     ebp, esp
.text$mn:000093BB                 push    ecx
.text$mn:000093BC                 mov     [ebp+var_4], ecx
.text$mn:000093BF                 mov     eax, [ebp+var_4]
.text$mn:000093C2                 mov     ecx, [eax+10h]
.text$mn:000093C5                 mov     eax, [ecx]
.text$mn:000093C7                 mov     esp, ebp
.text$mn:000093C9                 pop     ebp
.text$mn:000093CA                 retn
.text$mn:000093CA ?_First@?$_Temp_iterator@H@std@@QBEPAHXZ endp
.text$mn:000093CA
.text$mn:000093CA ; ---------------------------------------------------------------------------
.text$mn:000093CB                 align 4
.text$mn:000093CB _text$mn        ends
.text$mn:000093CB
.text$mn:000093CC ; ===========================================================================
.text$mn:000093CC
.text$mn:000093CC ; Segment type: Pure code
.text$mn:000093CC ; Segment permissions: Read/Execute
.text$mn:000093CC _text$mn        segment para public 'CODE' use32
.text$mn:000093CC                 assume cs:_text$mn
.text$mn:000093CC                 ;org 93CCh
.text$mn:000093CC ; COMDAT (pick any)
.text$mn:000093CC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000093CC
.text$mn:000093CC ; =============== S U B R O U T I N E =======================================
.text$mn:000093CC
.text$mn:000093CC ; Attributes: bp-based frame
.text$mn:000093CC
.text$mn:000093CC ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Free_proxy(void)
.text$mn:000093CC                 public ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
.text$mn:000093CC ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
.text$mn:000093CC                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+30p
.text$mn:000093CC
.text$mn:000093CC var_8           = dword ptr -8
.text$mn:000093CC var_1           = byte ptr -1
.text$mn:000093CC
.text$mn:000093CC                 push    ebp
.text$mn:000093CD                 mov     ebp, esp
.text$mn:000093CF                 sub     esp, 8
.text$mn:000093D2                 mov     [ebp+var_8], ecx
.text$mn:000093D5                 lea     ecx, [ebp+var_1]
.text$mn:000093D8                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:000093DD                 mov     ecx, [ebp+var_8] ; this
.text$mn:000093E0                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:000093E5                 mov     eax, [ebp+var_8]
.text$mn:000093E8                 mov     ecx, [eax]
.text$mn:000093EA                 push    ecx
.text$mn:000093EB                 lea     ecx, [ebp+var_1]
.text$mn:000093EE                 call    ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:000093F3                 push    1               ; int
.text$mn:000093F5                 mov     edx, [ebp+var_8]
.text$mn:000093F8                 mov     eax, [edx]
.text$mn:000093FA                 push    eax             ; void *
.text$mn:000093FB                 lea     ecx, [ebp+var_1]
.text$mn:000093FE                 call    ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate(std::_Container_proxy *,uint)
.text$mn:00009403                 mov     ecx, [ebp+var_8]
.text$mn:00009406                 mov     dword ptr [ecx], 0
.text$mn:0000940C                 mov     esp, ebp
.text$mn:0000940E                 pop     ebp
.text$mn:0000940F                 retn
.text$mn:0000940F ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp
.text$mn:0000940F
.text$mn:0000940F _text$mn        ends
.text$mn:0000940F
.text$mn:00009410 ; ===========================================================================
.text$mn:00009410
.text$mn:00009410 ; Segment type: Pure code
.text$mn:00009410 ; Segment permissions: Read/Execute
.text$mn:00009410 _text$mn        segment para public 'CODE' use32
.text$mn:00009410                 assume cs:_text$mn
.text$mn:00009410                 ;org 9410h
.text$mn:00009410 ; COMDAT (pick any)
.text$mn:00009410                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009410
.text$mn:00009410 ; =============== S U B R O U T I N E =======================================
.text$mn:00009410
.text$mn:00009410 ; Attributes: bp-based frame
.text$mn:00009410
.text$mn:00009410 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>::_Free_proxy(void)
.text$mn:00009410                 public ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ
.text$mn:00009410 ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00009410                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)+30p
.text$mn:00009410
.text$mn:00009410 var_8           = dword ptr -8
.text$mn:00009410 var_1           = byte ptr -1
.text$mn:00009410
.text$mn:00009410                 push    ebp
.text$mn:00009411                 mov     ebp, esp
.text$mn:00009413                 sub     esp, 8
.text$mn:00009416                 mov     [ebp+var_8], ecx
.text$mn:00009419                 lea     ecx, [ebp+var_1]
.text$mn:0000941C                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:00009421                 mov     ecx, [ebp+var_8] ; this
.text$mn:00009424                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00009429                 mov     eax, [ebp+var_8]
.text$mn:0000942C                 mov     ecx, [eax]
.text$mn:0000942E                 push    ecx
.text$mn:0000942F                 lea     ecx, [ebp+var_1]
.text$mn:00009432                 call    ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:00009437                 push    1               ; int
.text$mn:00009439                 mov     edx, [ebp+var_8]
.text$mn:0000943C                 mov     eax, [edx]
.text$mn:0000943E                 push    eax             ; void *
.text$mn:0000943F                 lea     ecx, [ebp+var_1]
.text$mn:00009442                 call    ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate(std::_Container_proxy *,uint)
.text$mn:00009447                 mov     ecx, [ebp+var_8]
.text$mn:0000944A                 mov     dword ptr [ecx], 0
.text$mn:00009450                 mov     esp, ebp
.text$mn:00009452                 pop     ebp
.text$mn:00009453                 retn
.text$mn:00009453 ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ endp
.text$mn:00009453
.text$mn:00009453 _text$mn        ends
.text$mn:00009453
.text$mn:00009454 ; ===========================================================================
.text$mn:00009454
.text$mn:00009454 ; Segment type: Pure code
.text$mn:00009454 ; Segment permissions: Read/Execute
.text$mn:00009454 _text$mn        segment para public 'CODE' use32
.text$mn:00009454                 assume cs:_text$mn
.text$mn:00009454                 ;org 9454h
.text$mn:00009454 ; COMDAT (pick any)
.text$mn:00009454                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009454
.text$mn:00009454 ; =============== S U B R O U T I N E =======================================
.text$mn:00009454
.text$mn:00009454 ; Attributes: bp-based frame
.text$mn:00009454
.text$mn:00009454 ; public: void __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<int, class std::allocator<int>>>::_Free_proxy(void)
.text$mn:00009454                 public ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEXXZ
.text$mn:00009454 ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00009454                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>::~_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>(void)+30p
.text$mn:00009454
.text$mn:00009454 var_8           = dword ptr -8
.text$mn:00009454 var_1           = byte ptr -1
.text$mn:00009454
.text$mn:00009454                 push    ebp
.text$mn:00009455                 mov     ebp, esp
.text$mn:00009457                 sub     esp, 8
.text$mn:0000945A                 mov     [ebp+var_8], ecx
.text$mn:0000945D                 lea     ecx, [ebp+var_1]
.text$mn:00009460                 call    ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::_Wrap_alloc<std::allocator<std::_Container_proxy>>(void)
.text$mn:00009465                 mov     ecx, [ebp+var_8] ; this
.text$mn:00009468                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:0000946D                 mov     eax, [ebp+var_8]
.text$mn:00009470                 mov     ecx, [eax]
.text$mn:00009472                 push    ecx
.text$mn:00009473                 lea     ecx, [ebp+var_1]
.text$mn:00009476                 call    ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:0000947B                 push    1               ; int
.text$mn:0000947D                 mov     edx, [ebp+var_8]
.text$mn:00009480                 mov     eax, [edx]
.text$mn:00009482                 push    eax             ; void *
.text$mn:00009483                 lea     ecx, [ebp+var_1]
.text$mn:00009486                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::deallocate(std::_Container_proxy *,uint)
.text$mn:0000948B                 mov     ecx, [ebp+var_8]
.text$mn:0000948E                 mov     dword ptr [ecx], 0
.text$mn:00009494                 mov     esp, ebp
.text$mn:00009496                 pop     ebp
.text$mn:00009497                 retn
.text$mn:00009497 ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEXXZ endp
.text$mn:00009497
.text$mn:00009497 _text$mn        ends
.text$mn:00009497
.text$mn:00009498 ; ===========================================================================
.text$mn:00009498
.text$mn:00009498 ; Segment type: Pure code
.text$mn:00009498 ; Segment permissions: Read/Execute
.text$mn:00009498 _text$mn        segment para public 'CODE' use32
.text$mn:00009498                 assume cs:_text$mn
.text$mn:00009498                 ;org 9498h
.text$mn:00009498 ; COMDAT (pick any)
.text$mn:00009498                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009498
.text$mn:00009498 ; =============== S U B R O U T I N E =======================================
.text$mn:00009498
.text$mn:00009498 ; Attributes: bp-based frame
.text$mn:00009498
.text$mn:00009498 ; public: void __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<wchar_t, class std::allocator<wchar_t>>>::_Free_proxy(void)
.text$mn:00009498                 public ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ
.text$mn:00009498 ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00009498                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<wchar_t,std::allocator<wchar_t>>>::~_Vector_alloc<0,std::_Vec_base_types<wchar_t,std::allocator<wchar_t>>>(void)+30p
.text$mn:00009498
.text$mn:00009498 var_8           = dword ptr -8
.text$mn:00009498 var_1           = byte ptr -1
.text$mn:00009498
.text$mn:00009498                 push    ebp
.text$mn:00009499                 mov     ebp, esp
.text$mn:0000949B                 sub     esp, 8
.text$mn:0000949E                 mov     [ebp+var_8], ecx
.text$mn:000094A1                 lea     ecx, [ebp+var_1]
.text$mn:000094A4                 call    ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::_Wrap_alloc<std::allocator<std::_Container_proxy>>(void)
.text$mn:000094A9                 mov     ecx, [ebp+var_8] ; this
.text$mn:000094AC                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:000094B1                 mov     eax, [ebp+var_8]
.text$mn:000094B4                 mov     ecx, [eax]
.text$mn:000094B6                 push    ecx
.text$mn:000094B7                 lea     ecx, [ebp+var_1]
.text$mn:000094BA                 call    ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:000094BF                 push    1               ; int
.text$mn:000094C1                 mov     edx, [ebp+var_8]
.text$mn:000094C4                 mov     eax, [edx]
.text$mn:000094C6                 push    eax             ; void *
.text$mn:000094C7                 lea     ecx, [ebp+var_1]
.text$mn:000094CA                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::deallocate(std::_Container_proxy *,uint)
.text$mn:000094CF                 mov     ecx, [ebp+var_8]
.text$mn:000094D2                 mov     dword ptr [ecx], 0
.text$mn:000094D8                 mov     esp, ebp
.text$mn:000094DA                 pop     ebp
.text$mn:000094DB                 retn
.text$mn:000094DB ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ endp
.text$mn:000094DB
.text$mn:000094DB _text$mn        ends
.text$mn:000094DB
.text$mn:000094DC ; ===========================================================================
.text$mn:000094DC
.text$mn:000094DC ; Segment type: Pure code
.text$mn:000094DC ; Segment permissions: Read/Execute
.text$mn:000094DC _text$mn        segment para public 'CODE' use32
.text$mn:000094DC                 assume cs:_text$mn
.text$mn:000094DC                 ;org 94DCh
.text$mn:000094DC ; COMDAT (pick any)
.text$mn:000094DC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000094DC
.text$mn:000094DC ; =============== S U B R O U T I N E =======================================
.text$mn:000094DC
.text$mn:000094DC ; Attributes: bp-based frame
.text$mn:000094DC
.text$mn:000094DC ; public: struct std::_Wrap_alloc<class std::allocator<char>> __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Getal(void)const
.text$mn:000094DC                 public ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
.text$mn:000094DC ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ proc near
.text$mn:000094DC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+B4p
.text$mn:000094DC                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+1Bp ...
.text$mn:000094DC
.text$mn:000094DC var_4           = dword ptr -4
.text$mn:000094DC arg_0           = dword ptr  8
.text$mn:000094DC
.text$mn:000094DC                 push    ebp
.text$mn:000094DD                 mov     ebp, esp
.text$mn:000094DF                 push    ecx
.text$mn:000094E0                 mov     [ebp+var_4], ecx
.text$mn:000094E3                 mov     ecx, [ebp+arg_0]
.text$mn:000094E6                 call    ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)
.text$mn:000094EB                 mov     eax, [ebp+arg_0]
.text$mn:000094EE                 mov     esp, ebp
.text$mn:000094F0                 pop     ebp
.text$mn:000094F1                 retn    4
.text$mn:000094F1 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ endp
.text$mn:000094F1
.text$mn:000094F1 _text$mn        ends
.text$mn:000094F1
.text$mn:000094F4 ; ===========================================================================
.text$mn:000094F4
.text$mn:000094F4 ; Segment type: Pure code
.text$mn:000094F4 ; Segment permissions: Read/Execute
.text$mn:000094F4 _text$mn        segment para public 'CODE' use32
.text$mn:000094F4                 assume cs:_text$mn
.text$mn:000094F4                 ;org 94F4h
.text$mn:000094F4 ; COMDAT (pick any)
.text$mn:000094F4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000094F4
.text$mn:000094F4 ; =============== S U B R O U T I N E =======================================
.text$mn:000094F4
.text$mn:000094F4 ; Attributes: bp-based frame
.text$mn:000094F4
.text$mn:000094F4 ; public: struct std::_Wrap_alloc<class std::allocator<wchar_t>> __thiscall std::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>::_Getal(void)const
.text$mn:000094F4                 public ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ
.text$mn:000094F4 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ proc near
.text$mn:000094F4                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+B4p
.text$mn:000094F4                                         ; __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0+1Bp ...
.text$mn:000094F4
.text$mn:000094F4 var_4           = dword ptr -4
.text$mn:000094F4 arg_0           = dword ptr  8
.text$mn:000094F4
.text$mn:000094F4                 push    ebp
.text$mn:000094F5                 mov     ebp, esp
.text$mn:000094F7                 push    ecx
.text$mn:000094F8                 mov     [ebp+var_4], ecx
.text$mn:000094FB                 mov     ecx, [ebp+arg_0]
.text$mn:000094FE                 call    ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<wchar_t>>::_Wrap_alloc<std::allocator<wchar_t>>(void)
.text$mn:00009503                 mov     eax, [ebp+arg_0]
.text$mn:00009506                 mov     esp, ebp
.text$mn:00009508                 pop     ebp
.text$mn:00009509                 retn    4
.text$mn:00009509 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ endp
.text$mn:00009509
.text$mn:00009509 _text$mn        ends
.text$mn:00009509
.text$mn:0000950C ; ===========================================================================
.text$mn:0000950C
.text$mn:0000950C ; Segment type: Pure code
.text$mn:0000950C ; Segment permissions: Read/Execute
.text$mn:0000950C _text$mn        segment para public 'CODE' use32
.text$mn:0000950C                 assume cs:_text$mn
.text$mn:0000950C                 ;org 950Ch
.text$mn:0000950C ; COMDAT (pick any)
.text$mn:0000950C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000950C
.text$mn:0000950C ; =============== S U B R O U T I N E =======================================
.text$mn:0000950C
.text$mn:0000950C ; Attributes: bp-based frame
.text$mn:0000950C
.text$mn:0000950C ; public: struct std::_Wrap_alloc<class std::allocator<int>> __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<int, class std::allocator<int>>>::_Getal(void)const
.text$mn:0000950C                 public ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@H@std@@@2@XZ
.text$mn:0000950C ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@H@std@@@2@XZ proc near
.text$mn:0000950C                                         ; CODE XREF: std::vector<int,std::allocator<int>>::_Umove<int *>(int *,int *,int *)+10p
.text$mn:0000950C                                         ; std::vector<int,std::allocator<int>>::_Destroy(int *,int *)+10p ...
.text$mn:0000950C
.text$mn:0000950C var_4           = dword ptr -4
.text$mn:0000950C arg_0           = dword ptr  8
.text$mn:0000950C
.text$mn:0000950C                 push    ebp
.text$mn:0000950D                 mov     ebp, esp
.text$mn:0000950F                 push    ecx
.text$mn:00009510                 mov     [ebp+var_4], ecx
.text$mn:00009513                 mov     ecx, [ebp+arg_0]
.text$mn:00009516                 call    ??0?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<int>>::_Wrap_alloc<std::allocator<int>>(void)
.text$mn:0000951B                 mov     eax, [ebp+arg_0]
.text$mn:0000951E                 mov     esp, ebp
.text$mn:00009520                 pop     ebp
.text$mn:00009521                 retn    4
.text$mn:00009521 ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@H@std@@@2@XZ endp
.text$mn:00009521
.text$mn:00009521 _text$mn        ends
.text$mn:00009521
.text$mn:00009524 ; ===========================================================================
.text$mn:00009524
.text$mn:00009524 ; Segment type: Pure code
.text$mn:00009524 ; Segment permissions: Read/Execute
.text$mn:00009524 _text$mn        segment para public 'CODE' use32
.text$mn:00009524                 assume cs:_text$mn
.text$mn:00009524                 ;org 9524h
.text$mn:00009524 ; COMDAT (pick any)
.text$mn:00009524                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009524
.text$mn:00009524 ; =============== S U B R O U T I N E =======================================
.text$mn:00009524
.text$mn:00009524 ; Attributes: bp-based frame
.text$mn:00009524
.text$mn:00009524 ; public: struct std::_Wrap_alloc<class std::allocator<wchar_t>> __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<wchar_t, class std::allocator<wchar_t>>>::_Getal(void)const
.text$mn:00009524                 public ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ
.text$mn:00009524 ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ proc near
.text$mn:00009524                                         ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::_Ucopy<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,wchar_t *)+36p
.text$mn:00009524                                         ; std::vector<wchar_t,std::allocator<wchar_t>>::_Umove<wchar_t *>(wchar_t *,wchar_t *,wchar_t *)+10p ...
.text$mn:00009524
.text$mn:00009524 var_4           = dword ptr -4
.text$mn:00009524 arg_0           = dword ptr  8
.text$mn:00009524
.text$mn:00009524                 push    ebp
.text$mn:00009525                 mov     ebp, esp
.text$mn:00009527                 push    ecx
.text$mn:00009528                 mov     [ebp+var_4], ecx
.text$mn:0000952B                 mov     ecx, [ebp+arg_0]
.text$mn:0000952E                 call    ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<wchar_t>>::_Wrap_alloc<std::allocator<wchar_t>>(void)
.text$mn:00009533                 mov     eax, [ebp+arg_0]
.text$mn:00009536                 mov     esp, ebp
.text$mn:00009538                 pop     ebp
.text$mn:00009539                 retn    4
.text$mn:00009539 ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ endp
.text$mn:00009539
.text$mn:00009539 _text$mn        ends
.text$mn:00009539
.text$mn:0000953C ; ===========================================================================
.text$mn:0000953C
.text$mn:0000953C ; Segment type: Pure code
.text$mn:0000953C ; Segment permissions: Read/Execute
.text$mn:0000953C _text$mn        segment para public 'CODE' use32
.text$mn:0000953C                 assume cs:_text$mn
.text$mn:0000953C                 ;org 953Ch
.text$mn:0000953C ; COMDAT (pick any)
.text$mn:0000953C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000953C
.text$mn:0000953C ; =============== S U B R O U T I N E =======================================
.text$mn:0000953C
.text$mn:0000953C ; Attributes: bp-based frame
.text$mn:0000953C
.text$mn:0000953C ; const struct std::_Container_base12 *__thiscall std::_Iterator_base12::_Getcont(std::_Iterator_base12 *__hidden this)
.text$mn:0000953C                 public ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ
.text$mn:0000953C ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ proc near
.text$mn:0000953C                                         ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator*(void)+Ap
.text$mn:0000953C                                         ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator*(void)+1Fp ...
.text$mn:0000953C
.text$mn:0000953C var_8           = dword ptr -8
.text$mn:0000953C var_4           = dword ptr -4
.text$mn:0000953C
.text$mn:0000953C                 push    ebp
.text$mn:0000953D                 mov     ebp, esp
.text$mn:0000953F                 sub     esp, 8
.text$mn:00009542                 mov     [ebp+var_4], ecx
.text$mn:00009545                 mov     eax, [ebp+var_4]
.text$mn:00009548                 cmp     dword ptr [eax], 0
.text$mn:0000954B                 jnz     short loc_9556
.text$mn:0000954D                 mov     [ebp+var_8], 0
.text$mn:00009554                 jmp     short loc_9560
.text$mn:00009556 ; ---------------------------------------------------------------------------
.text$mn:00009556
.text$mn:00009556 loc_9556:                               ; CODE XREF: std::_Iterator_base12::_Getcont(void)+Fj
.text$mn:00009556                 mov     ecx, [ebp+var_4]
.text$mn:00009559                 mov     edx, [ecx]
.text$mn:0000955B                 mov     eax, [edx]
.text$mn:0000955D                 mov     [ebp+var_8], eax
.text$mn:00009560
.text$mn:00009560 loc_9560:                               ; CODE XREF: std::_Iterator_base12::_Getcont(void)+18j
.text$mn:00009560                 mov     eax, [ebp+var_8]
.text$mn:00009563                 mov     esp, ebp
.text$mn:00009565                 pop     ebp
.text$mn:00009566                 retn
.text$mn:00009566 ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ endp
.text$mn:00009566
.text$mn:00009566 ; ---------------------------------------------------------------------------
.text$mn:00009567                 align 4
.text$mn:00009567 _text$mn        ends
.text$mn:00009567
.text$mn:00009568 ; ===========================================================================
.text$mn:00009568
.text$mn:00009568 ; Segment type: Pure code
.text$mn:00009568 ; Segment permissions: Read/Execute
.text$mn:00009568 _text$mn        segment para public 'CODE' use32
.text$mn:00009568                 assume cs:_text$mn
.text$mn:00009568                 ;org 9568h
.text$mn:00009568 ; COMDAT (pick any)
.text$mn:00009568                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009568
.text$mn:00009568 ; =============== S U B R O U T I N E =======================================
.text$mn:00009568
.text$mn:00009568 ; Attributes: bp-based frame
.text$mn:00009568
.text$mn:00009568 ; struct std::_Iterator_base12 **__thiscall std::_Container_base12::_Getpfirst(std::_Container_base12 *__hidden this)
.text$mn:00009568                 public ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ
.text$mn:00009568 ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ proc near
.text$mn:00009568                                         ; CODE XREF: std::vector<int,std::allocator<int>>::_Orphan_range(int *,int *)+3Cp
.text$mn:00009568                                         ; std::vector<wchar_t,std::allocator<wchar_t>>::_Orphan_range(wchar_t *,wchar_t *)+3Cp
.text$mn:00009568
.text$mn:00009568 var_8           = dword ptr -8
.text$mn:00009568 var_4           = dword ptr -4
.text$mn:00009568
.text$mn:00009568                 push    ebp
.text$mn:00009569                 mov     ebp, esp
.text$mn:0000956B                 sub     esp, 8
.text$mn:0000956E                 mov     [ebp+var_4], ecx
.text$mn:00009571                 mov     eax, [ebp+var_4]
.text$mn:00009574                 cmp     dword ptr [eax], 0
.text$mn:00009577                 jnz     short loc_9582
.text$mn:00009579                 mov     [ebp+var_8], 0
.text$mn:00009580                 jmp     short loc_958D
.text$mn:00009582 ; ---------------------------------------------------------------------------
.text$mn:00009582
.text$mn:00009582 loc_9582:                               ; CODE XREF: std::_Container_base12::_Getpfirst(void)+Fj
.text$mn:00009582                 mov     ecx, [ebp+var_4]
.text$mn:00009585                 mov     edx, [ecx]
.text$mn:00009587                 add     edx, 4
.text$mn:0000958A                 mov     [ebp+var_8], edx
.text$mn:0000958D
.text$mn:0000958D loc_958D:                               ; CODE XREF: std::_Container_base12::_Getpfirst(void)+18j
.text$mn:0000958D                 mov     eax, [ebp+var_8]
.text$mn:00009590                 mov     esp, ebp
.text$mn:00009592                 pop     ebp
.text$mn:00009593                 retn
.text$mn:00009593 ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ endp
.text$mn:00009593
.text$mn:00009593 _text$mn        ends
.text$mn:00009593
.text$mn:00009594 ; ===========================================================================
.text$mn:00009594
.text$mn:00009594 ; Segment type: Pure code
.text$mn:00009594 ; Segment permissions: Read/Execute
.text$mn:00009594 _text$mn        segment para public 'CODE' use32
.text$mn:00009594                 assume cs:_text$mn
.text$mn:00009594                 ;org 9594h
.text$mn:00009594 ; COMDAT (pick any)
.text$mn:00009594                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009594
.text$mn:00009594 ; =============== S U B R O U T I N E =======================================
.text$mn:00009594
.text$mn:00009594 ; Attributes: bp-based frame
.text$mn:00009594
.text$mn:00009594 ; struct std::_Iterator_base12 **__thiscall std::_Iterator_base12::_Getpnext(std::_Iterator_base12 *__hidden this)
.text$mn:00009594                 public ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ
.text$mn:00009594 ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ proc near
.text$mn:00009594                                         ; CODE XREF: std::vector<int,std::allocator<int>>::_Orphan_range(int *,int *)+71p
.text$mn:00009594                                         ; std::vector<int,std::allocator<int>>::_Orphan_range(int *,int *)+8Ap ...
.text$mn:00009594
.text$mn:00009594 var_4           = dword ptr -4
.text$mn:00009594
.text$mn:00009594                 push    ebp
.text$mn:00009595                 mov     ebp, esp
.text$mn:00009597                 push    ecx
.text$mn:00009598                 mov     [ebp+var_4], ecx
.text$mn:0000959B                 mov     eax, [ebp+var_4]
.text$mn:0000959E                 add     eax, 4
.text$mn:000095A1                 mov     esp, ebp
.text$mn:000095A3                 pop     ebp
.text$mn:000095A4                 retn
.text$mn:000095A4 ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ endp
.text$mn:000095A4
.text$mn:000095A4 ; ---------------------------------------------------------------------------
.text$mn:000095A5                 align 4
.text$mn:000095A5 _text$mn        ends
.text$mn:000095A5
.text$mn:000095A8 ; ===========================================================================
.text$mn:000095A8
.text$mn:000095A8 ; Segment type: Pure code
.text$mn:000095A8 ; Segment permissions: Read/Execute
.text$mn:000095A8 _text$mn        segment para public 'CODE' use32
.text$mn:000095A8                 assume cs:_text$mn
.text$mn:000095A8                 ;org 95A8h
.text$mn:000095A8 ; COMDAT (pick any)
.text$mn:000095A8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000095A8
.text$mn:000095A8 ; =============== S U B R O U T I N E =======================================
.text$mn:000095A8
.text$mn:000095A8 ; Attributes: bp-based frame
.text$mn:000095A8
.text$mn:000095A8 ; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Grow(unsigned int, bool)
.text$mn:000095A8                 public ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
.text$mn:000095A8 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z proc near
.text$mn:000095A8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+6Ap
.text$mn:000095A8                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+5Fp
.text$mn:000095A8
.text$mn:000095A8 var_C           = dword ptr -0Ch
.text$mn:000095A8 Size            = dword ptr -8
.text$mn:000095A8 var_4           = dword ptr -4
.text$mn:000095A8 arg_0           = dword ptr  8
.text$mn:000095A8 arg_4           = byte ptr  0Ch
.text$mn:000095A8
.text$mn:000095A8                 push    ebp
.text$mn:000095A9                 mov     ebp, esp
.text$mn:000095AB                 sub     esp, 0Ch
.text$mn:000095AE                 mov     [ebp+var_4], ecx
.text$mn:000095B1                 mov     ecx, [ebp+var_4]
.text$mn:000095B4                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:000095B9                 cmp     eax, [ebp+arg_0]
.text$mn:000095BC                 jnb     short loc_95C6
.text$mn:000095BE                 mov     ecx, [ebp+var_4]
.text$mn:000095C1                 call    ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)
.text$mn:000095C6
.text$mn:000095C6 loc_95C6:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+14j
.text$mn:000095C6                 mov     eax, [ebp+var_4]
.text$mn:000095C9                 mov     ecx, [eax+18h]
.text$mn:000095CC                 cmp     ecx, [ebp+arg_0]
.text$mn:000095CF                 jnb     short loc_95E6
.text$mn:000095D1                 mov     edx, [ebp+var_4]
.text$mn:000095D4                 mov     eax, [edx+14h]
.text$mn:000095D7                 push    eax
.text$mn:000095D8                 mov     ecx, [ebp+arg_0]
.text$mn:000095DB                 push    ecx
.text$mn:000095DC                 mov     ecx, [ebp+var_4]
.text$mn:000095DF                 call    ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)
.text$mn:000095E4                 jmp     short loc_9630
.text$mn:000095E6 ; ---------------------------------------------------------------------------
.text$mn:000095E6
.text$mn:000095E6 loc_95E6:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+27j
.text$mn:000095E6                 movzx   edx, [ebp+arg_4]
.text$mn:000095EA                 test    edx, edx
.text$mn:000095EC                 jz      short loc_9620
.text$mn:000095EE                 cmp     [ebp+arg_0], 10h
.text$mn:000095F2                 jnb     short loc_9620
.text$mn:000095F4                 mov     eax, [ebp+var_4]
.text$mn:000095F7                 mov     ecx, [ebp+arg_0]
.text$mn:000095FA                 cmp     ecx, [eax+14h]
.text$mn:000095FD                 jnb     short loc_9607
.text$mn:000095FF                 mov     edx, [ebp+arg_0]
.text$mn:00009602                 mov     [ebp+Size], edx
.text$mn:00009605                 jmp     short loc_9610
.text$mn:00009607 ; ---------------------------------------------------------------------------
.text$mn:00009607
.text$mn:00009607 loc_9607:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+55j
.text$mn:00009607                 mov     eax, [ebp+var_4]
.text$mn:0000960A                 mov     ecx, [eax+14h]
.text$mn:0000960D                 mov     [ebp+Size], ecx
.text$mn:00009610
.text$mn:00009610 loc_9610:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+5Dj
.text$mn:00009610                 mov     edx, [ebp+Size]
.text$mn:00009613                 push    edx             ; Size
.text$mn:00009614                 push    1               ; char
.text$mn:00009616                 mov     ecx, [ebp+var_4]
.text$mn:00009619                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:0000961E                 jmp     short loc_9630
.text$mn:00009620 ; ---------------------------------------------------------------------------
.text$mn:00009620
.text$mn:00009620 loc_9620:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+44j
.text$mn:00009620                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+4Aj
.text$mn:00009620                 cmp     [ebp+arg_0], 0
.text$mn:00009624                 jnz     short loc_9630
.text$mn:00009626                 push    0
.text$mn:00009628                 mov     ecx, [ebp+var_4]
.text$mn:0000962B                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00009630
.text$mn:00009630 loc_9630:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+3Cj
.text$mn:00009630                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+76j ...
.text$mn:00009630                 cmp     [ebp+arg_0], 0
.text$mn:00009634                 jbe     short loc_963F
.text$mn:00009636                 mov     [ebp+var_C], 1
.text$mn:0000963D                 jmp     short loc_9646
.text$mn:0000963F ; ---------------------------------------------------------------------------
.text$mn:0000963F
.text$mn:0000963F loc_963F:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+8Cj
.text$mn:0000963F                 mov     [ebp+var_C], 0
.text$mn:00009646
.text$mn:00009646 loc_9646:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+95j
.text$mn:00009646                 mov     al, byte ptr [ebp+var_C]
.text$mn:00009649                 mov     esp, ebp
.text$mn:0000964B                 pop     ebp
.text$mn:0000964C                 retn    8
.text$mn:0000964C ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z endp
.text$mn:0000964C
.text$mn:0000964C ; ---------------------------------------------------------------------------
.text$mn:0000964F                 align 10h
.text$mn:0000964F _text$mn        ends
.text$mn:0000964F
.text$mn:00009650 ; ===========================================================================
.text$mn:00009650
.text$mn:00009650 ; Segment type: Pure code
.text$mn:00009650 ; Segment permissions: Read/Execute
.text$mn:00009650 _text$mn        segment para public 'CODE' use32
.text$mn:00009650                 assume cs:_text$mn
.text$mn:00009650                 ;org 9650h
.text$mn:00009650 ; COMDAT (pick any)
.text$mn:00009650                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009650
.text$mn:00009650 ; =============== S U B R O U T I N E =======================================
.text$mn:00009650
.text$mn:00009650 ; Attributes: bp-based frame
.text$mn:00009650
.text$mn:00009650 ; public: bool __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Grow(unsigned int, bool)
.text$mn:00009650                 public ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z
.text$mn:00009650 ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z proc near
.text$mn:00009650                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+6Dp
.text$mn:00009650                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)+8Ep ...
.text$mn:00009650
.text$mn:00009650 var_C           = dword ptr -0Ch
.text$mn:00009650 var_8           = dword ptr -8
.text$mn:00009650 var_4           = dword ptr -4
.text$mn:00009650 arg_0           = dword ptr  8
.text$mn:00009650 arg_4           = byte ptr  0Ch
.text$mn:00009650
.text$mn:00009650                 push    ebp
.text$mn:00009651                 mov     ebp, esp
.text$mn:00009653                 sub     esp, 0Ch
.text$mn:00009656                 mov     [ebp+var_4], ecx
.text$mn:00009659                 mov     ecx, [ebp+var_4]
.text$mn:0000965C                 call    ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)
.text$mn:00009661                 cmp     eax, [ebp+arg_0]
.text$mn:00009664                 jnb     short loc_966E
.text$mn:00009666                 mov     ecx, [ebp+var_4]
.text$mn:00009669                 call    ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xlen(void)
.text$mn:0000966E
.text$mn:0000966E loc_966E:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+14j
.text$mn:0000966E                 mov     eax, [ebp+var_4]
.text$mn:00009671                 mov     ecx, [eax+18h]
.text$mn:00009674                 cmp     ecx, [ebp+arg_0]
.text$mn:00009677                 jnb     short loc_968E
.text$mn:00009679                 mov     edx, [ebp+var_4]
.text$mn:0000967C                 mov     eax, [edx+14h]
.text$mn:0000967F                 push    eax
.text$mn:00009680                 mov     ecx, [ebp+arg_0]
.text$mn:00009683                 push    ecx
.text$mn:00009684                 mov     ecx, [ebp+var_4]
.text$mn:00009687                 call    ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)
.text$mn:0000968C                 jmp     short loc_96D8
.text$mn:0000968E ; ---------------------------------------------------------------------------
.text$mn:0000968E
.text$mn:0000968E loc_968E:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+27j
.text$mn:0000968E                 movzx   edx, [ebp+arg_4]
.text$mn:00009692                 test    edx, edx
.text$mn:00009694                 jz      short loc_96C8
.text$mn:00009696                 cmp     [ebp+arg_0], 8
.text$mn:0000969A                 jnb     short loc_96C8
.text$mn:0000969C                 mov     eax, [ebp+var_4]
.text$mn:0000969F                 mov     ecx, [ebp+arg_0]
.text$mn:000096A2                 cmp     ecx, [eax+14h]
.text$mn:000096A5                 jnb     short loc_96AF
.text$mn:000096A7                 mov     edx, [ebp+arg_0]
.text$mn:000096AA                 mov     [ebp+var_8], edx
.text$mn:000096AD                 jmp     short loc_96B8
.text$mn:000096AF ; ---------------------------------------------------------------------------
.text$mn:000096AF
.text$mn:000096AF loc_96AF:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+55j
.text$mn:000096AF                 mov     eax, [ebp+var_4]
.text$mn:000096B2                 mov     ecx, [eax+14h]
.text$mn:000096B5                 mov     [ebp+var_8], ecx
.text$mn:000096B8
.text$mn:000096B8 loc_96B8:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+5Dj
.text$mn:000096B8                 mov     edx, [ebp+var_8]
.text$mn:000096BB                 push    edx
.text$mn:000096BC                 push    1
.text$mn:000096BE                 mov     ecx, [ebp+var_4]
.text$mn:000096C1                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:000096C6                 jmp     short loc_96D8
.text$mn:000096C8 ; ---------------------------------------------------------------------------
.text$mn:000096C8
.text$mn:000096C8 loc_96C8:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+44j
.text$mn:000096C8                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+4Aj
.text$mn:000096C8                 cmp     [ebp+arg_0], 0
.text$mn:000096CC                 jnz     short loc_96D8
.text$mn:000096CE                 push    0
.text$mn:000096D0                 mov     ecx, [ebp+var_4]
.text$mn:000096D3                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:000096D8
.text$mn:000096D8 loc_96D8:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+3Cj
.text$mn:000096D8                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+76j ...
.text$mn:000096D8                 cmp     [ebp+arg_0], 0
.text$mn:000096DC                 jbe     short loc_96E7
.text$mn:000096DE                 mov     [ebp+var_C], 1
.text$mn:000096E5                 jmp     short loc_96EE
.text$mn:000096E7 ; ---------------------------------------------------------------------------
.text$mn:000096E7
.text$mn:000096E7 loc_96E7:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+8Cj
.text$mn:000096E7                 mov     [ebp+var_C], 0
.text$mn:000096EE
.text$mn:000096EE loc_96EE:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+95j
.text$mn:000096EE                 mov     al, byte ptr [ebp+var_C]
.text$mn:000096F1                 mov     esp, ebp
.text$mn:000096F3                 pop     ebp
.text$mn:000096F4                 retn    8
.text$mn:000096F4 ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z endp
.text$mn:000096F4
.text$mn:000096F4 ; ---------------------------------------------------------------------------
.text$mn:000096F7                 align 4
.text$mn:000096F7 _text$mn        ends
.text$mn:000096F7
.text$mn:000096F8 ; ===========================================================================
.text$mn:000096F8
.text$mn:000096F8 ; Segment type: Pure code
.text$mn:000096F8 ; Segment permissions: Read/Execute
.text$mn:000096F8 _text$mn        segment para public 'CODE' use32
.text$mn:000096F8                 assume cs:_text$mn
.text$mn:000096F8                 ;org 96F8h
.text$mn:000096F8 ; COMDAT (pick any)
.text$mn:000096F8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000096F8
.text$mn:000096F8 ; =============== S U B R O U T I N E =======================================
.text$mn:000096F8
.text$mn:000096F8 ; Attributes: bp-based frame
.text$mn:000096F8
.text$mn:000096F8 ; protected: unsigned int __thiscall std::vector<int, class std::allocator<int>>::_Grow_to(unsigned int)const
.text$mn:000096F8                 public ?_Grow_to@?$vector@HV?$allocator@H@std@@@std@@IBEII@Z
.text$mn:000096F8 ?_Grow_to@?$vector@HV?$allocator@H@std@@@std@@IBEII@Z proc near
.text$mn:000096F8                                         ; CODE XREF: std::vector<int,std::allocator<int>>::_Reserve(uint)+45p
.text$mn:000096F8
.text$mn:000096F8 var_C           = dword ptr -0Ch
.text$mn:000096F8 var_8           = dword ptr -8
.text$mn:000096F8 var_4           = dword ptr -4
.text$mn:000096F8 arg_0           = dword ptr  8
.text$mn:000096F8
.text$mn:000096F8                 push    ebp
.text$mn:000096F9                 mov     ebp, esp
.text$mn:000096FB                 sub     esp, 0Ch
.text$mn:000096FE                 mov     [ebp+var_8], ecx
.text$mn:00009701                 mov     ecx, [ebp+var_8]
.text$mn:00009704                 call    ?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int>>::capacity(void)
.text$mn:00009709                 mov     [ebp+var_4], eax
.text$mn:0000970C                 mov     ecx, [ebp+var_8]
.text$mn:0000970F                 call    ?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int>>::max_size(void)
.text$mn:00009714                 mov     ecx, [ebp+var_4]
.text$mn:00009717                 shr     ecx, 1
.text$mn:00009719                 sub     eax, ecx
.text$mn:0000971B                 cmp     eax, [ebp+var_4]
.text$mn:0000971E                 jnb     short loc_9729
.text$mn:00009720                 mov     [ebp+var_C], 0
.text$mn:00009727                 jmp     short loc_9734
.text$mn:00009729 ; ---------------------------------------------------------------------------
.text$mn:00009729
.text$mn:00009729 loc_9729:                               ; CODE XREF: std::vector<int,std::allocator<int>>::_Grow_to(uint)+26j
.text$mn:00009729                 mov     edx, [ebp+var_4]
.text$mn:0000972C                 shr     edx, 1
.text$mn:0000972E                 add     edx, [ebp+var_4]
.text$mn:00009731                 mov     [ebp+var_C], edx
.text$mn:00009734
.text$mn:00009734 loc_9734:                               ; CODE XREF: std::vector<int,std::allocator<int>>::_Grow_to(uint)+2Fj
.text$mn:00009734                 mov     eax, [ebp+var_C]
.text$mn:00009737                 mov     [ebp+var_4], eax
.text$mn:0000973A                 mov     ecx, [ebp+var_4]
.text$mn:0000973D                 cmp     ecx, [ebp+arg_0]
.text$mn:00009740                 jnb     short loc_9748
.text$mn:00009742                 mov     edx, [ebp+arg_0]
.text$mn:00009745                 mov     [ebp+var_4], edx
.text$mn:00009748
.text$mn:00009748 loc_9748:                               ; CODE XREF: std::vector<int,std::allocator<int>>::_Grow_to(uint)+48j
.text$mn:00009748                 mov     eax, [ebp+var_4]
.text$mn:0000974B                 mov     esp, ebp
.text$mn:0000974D                 pop     ebp
.text$mn:0000974E                 retn    4
.text$mn:0000974E ?_Grow_to@?$vector@HV?$allocator@H@std@@@std@@IBEII@Z endp
.text$mn:0000974E
.text$mn:0000974E ; ---------------------------------------------------------------------------
.text$mn:00009751                 align 4
.text$mn:00009751 _text$mn        ends
.text$mn:00009751
.text$mn:00009754 ; ===========================================================================
.text$mn:00009754
.text$mn:00009754 ; Segment type: Pure code
.text$mn:00009754 ; Segment permissions: Read/Execute
.text$mn:00009754 _text$mn        segment para public 'CODE' use32
.text$mn:00009754                 assume cs:_text$mn
.text$mn:00009754                 ;org 9754h
.text$mn:00009754 ; COMDAT (pick any)
.text$mn:00009754                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009754
.text$mn:00009754 ; =============== S U B R O U T I N E =======================================
.text$mn:00009754
.text$mn:00009754 ; Attributes: bp-based frame
.text$mn:00009754
.text$mn:00009754 ; protected: unsigned int __thiscall std::vector<wchar_t, class std::allocator<wchar_t>>::_Grow_to(unsigned int)const
.text$mn:00009754                 public ?_Grow_to@?$vector@_WV?$allocator@_W@std@@@std@@IBEII@Z
.text$mn:00009754 ?_Grow_to@?$vector@_WV?$allocator@_W@std@@@std@@IBEII@Z proc near
.text$mn:00009754                                         ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::_Reserve(uint)+45p
.text$mn:00009754
.text$mn:00009754 var_C           = dword ptr -0Ch
.text$mn:00009754 var_8           = dword ptr -8
.text$mn:00009754 var_4           = dword ptr -4
.text$mn:00009754 arg_0           = dword ptr  8
.text$mn:00009754
.text$mn:00009754                 push    ebp
.text$mn:00009755                 mov     ebp, esp
.text$mn:00009757                 sub     esp, 0Ch
.text$mn:0000975A                 mov     [ebp+var_8], ecx
.text$mn:0000975D                 mov     ecx, [ebp+var_8]
.text$mn:00009760                 call    ?capacity@?$vector@_WV?$allocator@_W@std@@@std@@QBEIXZ ; std::vector<wchar_t,std::allocator<wchar_t>>::capacity(void)
.text$mn:00009765                 mov     [ebp+var_4], eax
.text$mn:00009768                 mov     ecx, [ebp+var_8]
.text$mn:0000976B                 call    ?max_size@?$vector@_WV?$allocator@_W@std@@@std@@QBEIXZ ; std::vector<wchar_t,std::allocator<wchar_t>>::max_size(void)
.text$mn:00009770                 mov     ecx, [ebp+var_4]
.text$mn:00009773                 shr     ecx, 1
.text$mn:00009775                 sub     eax, ecx
.text$mn:00009777                 cmp     eax, [ebp+var_4]
.text$mn:0000977A                 jnb     short loc_9785
.text$mn:0000977C                 mov     [ebp+var_C], 0
.text$mn:00009783                 jmp     short loc_9790
.text$mn:00009785 ; ---------------------------------------------------------------------------
.text$mn:00009785
.text$mn:00009785 loc_9785:                               ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::_Grow_to(uint)+26j
.text$mn:00009785                 mov     edx, [ebp+var_4]
.text$mn:00009788                 shr     edx, 1
.text$mn:0000978A                 add     edx, [ebp+var_4]
.text$mn:0000978D                 mov     [ebp+var_C], edx
.text$mn:00009790
.text$mn:00009790 loc_9790:                               ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::_Grow_to(uint)+2Fj
.text$mn:00009790                 mov     eax, [ebp+var_C]
.text$mn:00009793                 mov     [ebp+var_4], eax
.text$mn:00009796                 mov     ecx, [ebp+var_4]
.text$mn:00009799                 cmp     ecx, [ebp+arg_0]
.text$mn:0000979C                 jnb     short loc_97A4
.text$mn:0000979E                 mov     edx, [ebp+arg_0]
.text$mn:000097A1                 mov     [ebp+var_4], edx
.text$mn:000097A4
.text$mn:000097A4 loc_97A4:                               ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::_Grow_to(uint)+48j
.text$mn:000097A4                 mov     eax, [ebp+var_4]
.text$mn:000097A7                 mov     esp, ebp
.text$mn:000097A9                 pop     ebp
.text$mn:000097AA                 retn    4
.text$mn:000097AA ?_Grow_to@?$vector@_WV?$allocator@_W@std@@@std@@IBEII@Z endp
.text$mn:000097AA
.text$mn:000097AA ; ---------------------------------------------------------------------------
.text$mn:000097AD                 align 10h
.text$mn:000097AD _text$mn        ends
.text$mn:000097AD
.text$mn:000097B0 ; ===========================================================================
.text$mn:000097B0
.text$mn:000097B0 ; Segment type: Pure code
.text$mn:000097B0 ; Segment permissions: Read/Execute
.text$mn:000097B0 _text$mn        segment para public 'CODE' use32
.text$mn:000097B0                 assume cs:_text$mn
.text$mn:000097B0                 ;org 97B0h
.text$mn:000097B0 ; COMDAT (pick any)
.text$mn:000097B0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000097B0
.text$mn:000097B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000097B0
.text$mn:000097B0 ; Attributes: bp-based frame
.text$mn:000097B0
.text$mn:000097B0 ; public: class std::_Temp_iterator<int> & __thiscall std::_Temp_iterator<int>::_Init(void)
.text$mn:000097B0                 public ?_Init@?$_Temp_iterator@H@std@@QAEAAV12@XZ
.text$mn:000097B0 ?_Init@?$_Temp_iterator@H@std@@QAEAAV12@XZ proc near
.text$mn:000097B0                                         ; CODE XREF: std::_Buffered_merge<int *,int,int,BufferEquivalent>(int *,int *,int *,int,int,std::_Temp_iterator<int> &,BufferEquivalent)+B3p
.text$mn:000097B0                                         ; std::_Buffered_merge<int *,int,int,BufferEquivalent>(int *,int *,int *,int,int,std::_Temp_iterator<int> &,BufferEquivalent)+157p ...
.text$mn:000097B0
.text$mn:000097B0 var_4           = dword ptr -4
.text$mn:000097B0
.text$mn:000097B0                 push    ebp
.text$mn:000097B1                 mov     ebp, esp
.text$mn:000097B3                 push    ecx
.text$mn:000097B4                 mov     [ebp+var_4], ecx
.text$mn:000097B7                 mov     eax, [ebp+var_4]
.text$mn:000097BA                 mov     ecx, [eax+10h]
.text$mn:000097BD                 mov     edx, [ebp+var_4]
.text$mn:000097C0                 mov     eax, [edx+10h]
.text$mn:000097C3                 mov     ecx, [ecx]
.text$mn:000097C5                 mov     [eax+4], ecx
.text$mn:000097C8                 mov     eax, [ebp+var_4]
.text$mn:000097CB                 mov     esp, ebp
.text$mn:000097CD                 pop     ebp
.text$mn:000097CE                 retn
.text$mn:000097CE ?_Init@?$_Temp_iterator@H@std@@QAEAAV12@XZ endp
.text$mn:000097CE
.text$mn:000097CE ; ---------------------------------------------------------------------------
.text$mn:000097CF                 align 10h
.text$mn:000097CF _text$mn        ends
.text$mn:000097CF
.text$mn:000097D0 ; ===========================================================================
.text$mn:000097D0
.text$mn:000097D0 ; Segment type: Pure code
.text$mn:000097D0 ; Segment permissions: Read/Execute
.text$mn:000097D0 _text$mn        segment para public 'CODE' use32
.text$mn:000097D0                 assume cs:_text$mn
.text$mn:000097D0                 ;org 97D0h
.text$mn:000097D0 ; COMDAT (pick any)
.text$mn:000097D0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000097D0
.text$mn:000097D0 ; =============== S U B R O U T I N E =======================================
.text$mn:000097D0
.text$mn:000097D0 ; Attributes: bp-based frame
.text$mn:000097D0
.text$mn:000097D0 ; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Inside(char const *)
.text$mn:000097D0                 public ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
.text$mn:000097D0 ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z proc near
.text$mn:000097D0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+2Ap
.text$mn:000097D0
.text$mn:000097D0 var_4           = dword ptr -4
.text$mn:000097D0 arg_0           = dword ptr  8
.text$mn:000097D0
.text$mn:000097D0                 push    ebp
.text$mn:000097D1                 mov     ebp, esp
.text$mn:000097D3                 push    ecx
.text$mn:000097D4                 mov     [ebp+var_4], ecx
.text$mn:000097D7                 cmp     [ebp+arg_0], 0
.text$mn:000097DB                 jz      short loc_97FD
.text$mn:000097DD                 mov     ecx, [ebp+var_4]
.text$mn:000097E0                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000097E5                 cmp     [ebp+arg_0], eax
.text$mn:000097E8                 jb      short loc_97FD
.text$mn:000097EA                 mov     ecx, [ebp+var_4]
.text$mn:000097ED                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000097F2                 mov     ecx, [ebp+var_4]
.text$mn:000097F5                 add     eax, [ecx+14h]
.text$mn:000097F8                 cmp     eax, [ebp+arg_0]
.text$mn:000097FB                 ja      short loc_9803
.text$mn:000097FD
.text$mn:000097FD loc_97FD:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+Bj
.text$mn:000097FD                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+18j
.text$mn:000097FD                 xor     al, al
.text$mn:000097FF                 jmp     short loc_9805
.text$mn:00009801 ; ---------------------------------------------------------------------------
.text$mn:00009801                 jmp     short loc_9805
.text$mn:00009803 ; ---------------------------------------------------------------------------
.text$mn:00009803
.text$mn:00009803 loc_9803:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+2Bj
.text$mn:00009803                 mov     al, 1
.text$mn:00009805
.text$mn:00009805 loc_9805:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+2Fj
.text$mn:00009805                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+31j
.text$mn:00009805                 mov     esp, ebp
.text$mn:00009807                 pop     ebp
.text$mn:00009808                 retn    4
.text$mn:00009808 ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z endp
.text$mn:00009808
.text$mn:00009808 ; ---------------------------------------------------------------------------
.text$mn:0000980B                 align 4
.text$mn:0000980B _text$mn        ends
.text$mn:0000980B
.text$mn:0000980C ; ===========================================================================
.text$mn:0000980C
.text$mn:0000980C ; Segment type: Pure code
.text$mn:0000980C ; Segment permissions: Read/Execute
.text$mn:0000980C _text$mn        segment para public 'CODE' use32
.text$mn:0000980C                 assume cs:_text$mn
.text$mn:0000980C                 ;org 980Ch
.text$mn:0000980C ; COMDAT (pick any)
.text$mn:0000980C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000980C
.text$mn:0000980C ; =============== S U B R O U T I N E =======================================
.text$mn:0000980C
.text$mn:0000980C ; Attributes: bp-based frame
.text$mn:0000980C
.text$mn:0000980C ; public: bool __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Inside(wchar_t const *)
.text$mn:0000980C                 public ?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z
.text$mn:0000980C ?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z proc near
.text$mn:0000980C                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)+2Cp
.text$mn:0000980C                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+2Ap
.text$mn:0000980C
.text$mn:0000980C var_4           = dword ptr -4
.text$mn:0000980C arg_0           = dword ptr  8
.text$mn:0000980C
.text$mn:0000980C                 push    ebp
.text$mn:0000980D                 mov     ebp, esp
.text$mn:0000980F                 push    ecx
.text$mn:00009810                 mov     [ebp+var_4], ecx
.text$mn:00009813                 cmp     [ebp+arg_0], 0
.text$mn:00009817                 jz      short loc_983C
.text$mn:00009819                 mov     ecx, [ebp+var_4]
.text$mn:0000981C                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00009821                 cmp     [ebp+arg_0], eax
.text$mn:00009824                 jb      short loc_983C
.text$mn:00009826                 mov     ecx, [ebp+var_4]
.text$mn:00009829                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000982E                 mov     ecx, [ebp+var_4]
.text$mn:00009831                 mov     edx, [ecx+14h]
.text$mn:00009834                 lea     eax, [eax+edx*2]
.text$mn:00009837                 cmp     eax, [ebp+arg_0]
.text$mn:0000983A                 ja      short loc_9842
.text$mn:0000983C
.text$mn:0000983C loc_983C:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)+Bj
.text$mn:0000983C                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)+18j
.text$mn:0000983C                 xor     al, al
.text$mn:0000983E                 jmp     short loc_9844
.text$mn:00009840 ; ---------------------------------------------------------------------------
.text$mn:00009840                 jmp     short loc_9844
.text$mn:00009842 ; ---------------------------------------------------------------------------
.text$mn:00009842
.text$mn:00009842 loc_9842:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)+2Ej
.text$mn:00009842                 mov     al, 1
.text$mn:00009844
.text$mn:00009844 loc_9844:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)+32j
.text$mn:00009844                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)+34j
.text$mn:00009844                 mov     esp, ebp
.text$mn:00009846                 pop     ebp
.text$mn:00009847                 retn    4
.text$mn:00009847 ?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z endp
.text$mn:00009847
.text$mn:00009847 ; ---------------------------------------------------------------------------
.text$mn:0000984A                 align 4
.text$mn:0000984A _text$mn        ends
.text$mn:0000984A
.text$mn:0000984C ; ===========================================================================
.text$mn:0000984C
.text$mn:0000984C ; Segment type: Pure code
.text$mn:0000984C ; Segment permissions: Read/Execute
.text$mn:0000984C _text$mn        segment para public 'CODE' use32
.text$mn:0000984C                 assume cs:_text$mn
.text$mn:0000984C                 ;org 984Ch
.text$mn:0000984C ; COMDAT (pick any)
.text$mn:0000984C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000984C
.text$mn:0000984C ; =============== S U B R O U T I N E =======================================
.text$mn:0000984C
.text$mn:0000984C ; Attributes: bp-based frame
.text$mn:0000984C
.text$mn:0000984C ; protected: bool __thiscall std::vector<int, class std::allocator<int>>::_Inside(int const *)const
.text$mn:0000984C                 public ?_Inside@?$vector@HV?$allocator@H@std@@@std@@IBE_NPBH@Z
.text$mn:0000984C ?_Inside@?$vector@HV?$allocator@H@std@@@std@@IBE_NPBH@Z proc near
.text$mn:0000984C                                         ; CODE XREF: std::vector<int,std::allocator<int>>::resize(uint,int const &)+7Cp
.text$mn:0000984C
.text$mn:0000984C var_8           = dword ptr -8
.text$mn:0000984C var_4           = dword ptr -4
.text$mn:0000984C arg_0           = dword ptr  8
.text$mn:0000984C
.text$mn:0000984C                 push    ebp
.text$mn:0000984D                 mov     ebp, esp
.text$mn:0000984F                 sub     esp, 8
.text$mn:00009852                 mov     [ebp+var_4], ecx
.text$mn:00009855                 mov     eax, [ebp+var_4]
.text$mn:00009858                 mov     ecx, [ebp+arg_0]
.text$mn:0000985B                 cmp     ecx, [eax+8]
.text$mn:0000985E                 jnb     short loc_9874
.text$mn:00009860                 mov     edx, [ebp+var_4]
.text$mn:00009863                 mov     eax, [edx+4]
.text$mn:00009866                 cmp     eax, [ebp+arg_0]
.text$mn:00009869                 ja      short loc_9874
.text$mn:0000986B                 mov     [ebp+var_8], 1
.text$mn:00009872                 jmp     short loc_987B
.text$mn:00009874 ; ---------------------------------------------------------------------------
.text$mn:00009874
.text$mn:00009874 loc_9874:                               ; CODE XREF: std::vector<int,std::allocator<int>>::_Inside(int const *)+12j
.text$mn:00009874                                         ; std::vector<int,std::allocator<int>>::_Inside(int const *)+1Dj
.text$mn:00009874                 mov     [ebp+var_8], 0
.text$mn:0000987B
.text$mn:0000987B loc_987B:                               ; CODE XREF: std::vector<int,std::allocator<int>>::_Inside(int const *)+26j
.text$mn:0000987B                 mov     al, byte ptr [ebp+var_8]
.text$mn:0000987E                 mov     esp, ebp
.text$mn:00009880                 pop     ebp
.text$mn:00009881                 retn    4
.text$mn:00009881 ?_Inside@?$vector@HV?$allocator@H@std@@@std@@IBE_NPBH@Z endp
.text$mn:00009881
.text$mn:00009881 _text$mn        ends
.text$mn:00009881
.text$mn:00009884 ; ===========================================================================
.text$mn:00009884
.text$mn:00009884 ; Segment type: Pure code
.text$mn:00009884 ; Segment permissions: Read/Execute
.text$mn:00009884 _text$mn        segment para public 'CODE' use32
.text$mn:00009884                 assume cs:_text$mn
.text$mn:00009884                 ;org 9884h
.text$mn:00009884 ; COMDAT (pick any)
.text$mn:00009884                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009884
.text$mn:00009884 ; =============== S U B R O U T I N E =======================================
.text$mn:00009884
.text$mn:00009884 ; Attributes: bp-based frame
.text$mn:00009884
.text$mn:00009884 ; protected: bool __thiscall std::vector<wchar_t, class std::allocator<wchar_t>>::_Inside(wchar_t const *)const
.text$mn:00009884                 public ?_Inside@?$vector@_WV?$allocator@_W@std@@@std@@IBE_NPB_W@Z
.text$mn:00009884 ?_Inside@?$vector@_WV?$allocator@_W@std@@@std@@IBE_NPB_W@Z proc near
.text$mn:00009884                                         ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::push_back(wchar_t &&)+19p
.text$mn:00009884
.text$mn:00009884 var_8           = dword ptr -8
.text$mn:00009884 var_4           = dword ptr -4
.text$mn:00009884 arg_0           = dword ptr  8
.text$mn:00009884
.text$mn:00009884                 push    ebp
.text$mn:00009885                 mov     ebp, esp
.text$mn:00009887                 sub     esp, 8
.text$mn:0000988A                 mov     [ebp+var_4], ecx
.text$mn:0000988D                 mov     eax, [ebp+var_4]
.text$mn:00009890                 mov     ecx, [ebp+arg_0]
.text$mn:00009893                 cmp     ecx, [eax+8]
.text$mn:00009896                 jnb     short loc_98AC
.text$mn:00009898                 mov     edx, [ebp+var_4]
.text$mn:0000989B                 mov     eax, [edx+4]
.text$mn:0000989E                 cmp     eax, [ebp+arg_0]
.text$mn:000098A1                 ja      short loc_98AC
.text$mn:000098A3                 mov     [ebp+var_8], 1
.text$mn:000098AA                 jmp     short loc_98B3
.text$mn:000098AC ; ---------------------------------------------------------------------------
.text$mn:000098AC
.text$mn:000098AC loc_98AC:                               ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::_Inside(wchar_t const *)+12j
.text$mn:000098AC                                         ; std::vector<wchar_t,std::allocator<wchar_t>>::_Inside(wchar_t const *)+1Dj
.text$mn:000098AC                 mov     [ebp+var_8], 0
.text$mn:000098B3
.text$mn:000098B3 loc_98B3:                               ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::_Inside(wchar_t const *)+26j
.text$mn:000098B3                 mov     al, byte ptr [ebp+var_8]
.text$mn:000098B6                 mov     esp, ebp
.text$mn:000098B8                 pop     ebp
.text$mn:000098B9                 retn    4
.text$mn:000098B9 ?_Inside@?$vector@_WV?$allocator@_W@std@@@std@@IBE_NPB_W@Z endp
.text$mn:000098B9
.text$mn:000098B9 _text$mn        ends
.text$mn:000098B9
.text$mn:000098BC ; ===========================================================================
.text$mn:000098BC
.text$mn:000098BC ; Segment type: Pure code
.text$mn:000098BC ; Segment permissions: Read/Execute
.text$mn:000098BC _text$mn        segment para public 'CODE' use32
.text$mn:000098BC                 assume cs:_text$mn
.text$mn:000098BC                 ;org 98BCh
.text$mn:000098BC ; COMDAT (pick any)
.text$mn:000098BC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000098BC
.text$mn:000098BC ; =============== S U B R O U T I N E =======================================
.text$mn:000098BC
.text$mn:000098BC ; Attributes: bp-based frame
.text$mn:000098BC
.text$mn:000098BC ; public: int * __thiscall std::_Temp_iterator<int>::_Last(void)const
.text$mn:000098BC                 public ?_Last@?$_Temp_iterator@H@std@@QBEPAHXZ
.text$mn:000098BC ?_Last@?$_Temp_iterator@H@std@@QBEPAHXZ proc near
.text$mn:000098BC                                         ; CODE XREF: std::_Buffered_merge<int *,int,int,BufferEquivalent>(int *,int *,int *,int,int,std::_Temp_iterator<int> &,BufferEquivalent)+127p
.text$mn:000098BC                                         ; std::_Buffered_merge<int *,int,int,BufferEquivalent>(int *,int *,int *,int,int,std::_Temp_iterator<int> &,BufferEquivalent)+1C3p ...
.text$mn:000098BC
.text$mn:000098BC var_4           = dword ptr -4
.text$mn:000098BC
.text$mn:000098BC                 push    ebp
.text$mn:000098BD                 mov     ebp, esp
.text$mn:000098BF                 push    ecx
.text$mn:000098C0                 mov     [ebp+var_4], ecx
.text$mn:000098C3                 mov     eax, [ebp+var_4]
.text$mn:000098C6                 mov     ecx, [eax+10h]
.text$mn:000098C9                 mov     eax, [ecx+4]
.text$mn:000098CC                 mov     esp, ebp
.text$mn:000098CE                 pop     ebp
.text$mn:000098CF                 retn
.text$mn:000098CF ?_Last@?$_Temp_iterator@H@std@@QBEPAHXZ endp
.text$mn:000098CF
.text$mn:000098CF _text$mn        ends
.text$mn:000098CF
.text$mn:000098D0 ; ===========================================================================
.text$mn:000098D0
.text$mn:000098D0 ; Segment type: Pure code
.text$mn:000098D0 ; Segment permissions: Read/Execute
.text$mn:000098D0 _text$mn        segment para public 'CODE' use32
.text$mn:000098D0                 assume cs:_text$mn
.text$mn:000098D0                 ;org 98D0h
.text$mn:000098D0 ; COMDAT (pick any)
.text$mn:000098D0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000098D0
.text$mn:000098D0 ; =============== S U B R O U T I N E =======================================
.text$mn:000098D0
.text$mn:000098D0 ; Attributes: bp-based frame
.text$mn:000098D0
.text$mn:000098D0 ; public: class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<int>>> __thiscall std::vector<int, class std::allocator<int>>::_Make_iter(class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<int>>>)const
.text$mn:000098D0                 public ?_Make_iter@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@@Z
.text$mn:000098D0 ?_Make_iter@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@@Z proc near
.text$mn:000098D0                                         ; CODE XREF: std::vector<int,std::allocator<int>>::erase(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>)+153p
.text$mn:000098D0                                         ; std::vector<int,std::allocator<int>>::erase(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>)+188p ...
.text$mn:000098D0
.text$mn:000098D0 var_14          = dword ptr -14h
.text$mn:000098D0 var_10          = dword ptr -10h
.text$mn:000098D0 var_C           = dword ptr -0Ch
.text$mn:000098D0 var_4           = dword ptr -4
.text$mn:000098D0 arg_0           = dword ptr  8
.text$mn:000098D0 arg_4           = byte ptr  0Ch
.text$mn:000098D0 arg_C           = dword ptr  14h
.text$mn:000098D0
.text$mn:000098D0                 push    ebp
.text$mn:000098D1                 mov     ebp, esp
.text$mn:000098D3                 push    0FFFFFFFFh
.text$mn:000098D5                 push    offset __ehhandler$?_Make_iter@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@@Z
.text$mn:000098DA                 mov     eax, large fs:0
.text$mn:000098E0                 push    eax
.text$mn:000098E1                 sub     esp, 8
.text$mn:000098E4                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000098E9                 xor     eax, ebp
.text$mn:000098EB                 push    eax
.text$mn:000098EC                 lea     eax, [ebp+var_C]
.text$mn:000098EF                 mov     large fs:0, eax
.text$mn:000098F5                 mov     [ebp+var_14], ecx
.text$mn:000098F8                 mov     [ebp+var_10], 0
.text$mn:000098FF                 mov     [ebp+var_4], 1
.text$mn:00009906                 mov     eax, [ebp+var_14]
.text$mn:00009909                 push    eax             ; struct std::_Container_base12 *
.text$mn:0000990A                 mov     ecx, [ebp+arg_C]
.text$mn:0000990D                 push    ecx             ; int
.text$mn:0000990E                 mov     ecx, [ebp+arg_0]
.text$mn:00009911                 call    ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(int *,std::_Container_base12 const *)
.text$mn:00009916                 mov     edx, [ebp+var_10]
.text$mn:00009919                 or      edx, 1
.text$mn:0000991C                 mov     [ebp+var_10], edx
.text$mn:0000991F                 mov     byte ptr [ebp+var_4], 0
.text$mn:00009923                 lea     ecx, [ebp+arg_4]
.text$mn:00009926                 call    ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$mn:0000992B                 mov     eax, [ebp+arg_0]
.text$mn:0000992E                 mov     ecx, [ebp+var_C]
.text$mn:00009931                 mov     large fs:0, ecx
.text$mn:00009938                 pop     ecx
.text$mn:00009939                 mov     esp, ebp
.text$mn:0000993B                 pop     ebp
.text$mn:0000993C                 retn    10h
.text$mn:0000993C ?_Make_iter@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@@Z endp
.text$mn:0000993C
.text$mn:0000993C ; ---------------------------------------------------------------------------
.text$mn:0000993F                 align 10h
.text$mn:0000993F _text$mn        ends
.text$mn:0000993F
.text$x:00009940 ; ===========================================================================
.text$x:00009940
.text$x:00009940 ; Segment type: Pure code
.text$x:00009940 ; Segment permissions: Read/Execute
.text$x:00009940 _text$x         segment para public 'CODE' use32
.text$x:00009940                 assume cs:_text$x
.text$x:00009940                 ;org 9940h
.text$x:00009940 ; COMDAT (pick associative to section at 98D0)
.text$x:00009940                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00009940
.text$x:00009940 ; =============== S U B R O U T I N E =======================================
.text$x:00009940
.text$x:00009940
.text$x:00009940 __unwindfunclet$?_Make_iter@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@@Z$0 proc near
.text$x:00009940                                         ; DATA XREF: .xdata$x:0000CE90o
.text$x:00009940                 lea     ecx, [ebp+0Ch]
.text$x:00009943                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$x:00009943 __unwindfunclet$?_Make_iter@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@@Z$0 endp
.text$x:00009943
.text$x:00009948
.text$x:00009948 ; =============== S U B R O U T I N E =======================================
.text$x:00009948
.text$x:00009948
.text$x:00009948 __unwindfunclet$?_Make_iter@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@@Z$1 proc near
.text$x:00009948                                         ; DATA XREF: .xdata$x:0000CE88o
.text$x:00009948                 mov     eax, [ebp-10h]
.text$x:0000994B                 and     eax, 1
.text$x:0000994E                 jz      $LN5
.text$x:00009954                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:00009958                 mov     ecx, [ebp+8]
.text$x:0000995B                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$x:00009960 ; ---------------------------------------------------------------------------
.text$x:00009960
.text$x:00009960 $LN5:                                   ; CODE XREF: __unwindfunclet$?_Make_iter@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@@Z$1+6j
.text$x:00009960                 retn
.text$x:00009960 __unwindfunclet$?_Make_iter@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@@Z$1 endp
.text$x:00009960
.text$x:00009961
.text$x:00009961 ; =============== S U B R O U T I N E =======================================
.text$x:00009961
.text$x:00009961
.text$x:00009961 __ehhandler$?_Make_iter@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@@Z proc near
.text$x:00009961                                         ; DATA XREF: std::vector<int,std::allocator<int>>::_Make_iter(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>)+5o
.text$x:00009961
.text$x:00009961 arg_4           = dword ptr  8
.text$x:00009961
.text$x:00009961                 mov     edx, [esp+arg_4]
.text$x:00009965                 lea     eax, [edx+0Ch]
.text$x:00009968                 mov     ecx, [edx-0Ch]
.text$x:0000996B                 xor     ecx, eax
.text$x:0000996D                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00009972                 mov     eax, offset __ehfuncinfo$?_Make_iter@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@@Z
.text$x:00009977                 jmp     ___CxxFrameHandler3
.text$x:00009977 __ehhandler$?_Make_iter@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@@Z endp
.text$x:00009977
.text$x:00009977 _text$x         ends
.text$x:00009977
.text$mn:0000997C ; ===========================================================================
.text$mn:0000997C
.text$mn:0000997C ; Segment type: Pure code
.text$mn:0000997C ; Segment permissions: Read/Execute
.text$mn:0000997C _text$mn        segment para public 'CODE' use32
.text$mn:0000997C                 assume cs:_text$mn
.text$mn:0000997C                 ;org 997Ch
.text$mn:0000997C ; COMDAT (pick any)
.text$mn:0000997C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000997C
.text$mn:0000997C ; =============== S U B R O U T I N E =======================================
.text$mn:0000997C
.text$mn:0000997C ; Attributes: bp-based frame
.text$mn:0000997C
.text$mn:0000997C ; public: int __thiscall std::_Temp_iterator<int>::_Maxlen(void)
.text$mn:0000997C                 public ?_Maxlen@?$_Temp_iterator@H@std@@QAEHXZ
.text$mn:0000997C ?_Maxlen@?$_Temp_iterator@H@std@@QAEHXZ proc near
.text$mn:0000997C                                         ; CODE XREF: std::_Buffered_merge<int *,int,int,BufferEquivalent>(int *,int *,int *,int,int,std::_Temp_iterator<int> &,BufferEquivalent)+A2p
.text$mn:0000997C                                         ; std::_Buffered_merge<int *,int,int,BufferEquivalent>(int *,int *,int *,int,int,std::_Temp_iterator<int> &,BufferEquivalent)+146p ...
.text$mn:0000997C
.text$mn:0000997C var_C           = dword ptr -0Ch
.text$mn:0000997C var_8           = dword ptr -8
.text$mn:0000997C var_4           = dword ptr -4
.text$mn:0000997C
.text$mn:0000997C                 push    ebp
.text$mn:0000997D                 mov     ebp, esp
.text$mn:0000997F                 sub     esp, 0Ch
.text$mn:00009982                 mov     [ebp+var_4], ecx
.text$mn:00009985                 mov     eax, [ebp+var_4]
.text$mn:00009988                 mov     ecx, [eax+10h]
.text$mn:0000998B                 cmp     dword ptr [ecx], 0
.text$mn:0000998E                 jnz     short loc_99E1
.text$mn:00009990                 mov     edx, [ebp+var_4]
.text$mn:00009993                 mov     eax, [edx+10h]
.text$mn:00009996                 cmp     dword ptr [eax+0Ch], 0
.text$mn:0000999A                 jle     short loc_99E1
.text$mn:0000999C                 mov     ecx, [ebp+var_4]
.text$mn:0000999F                 mov     edx, [ecx+10h]
.text$mn:000099A2                 mov     eax, [edx+0Ch]
.text$mn:000099A5                 push    eax
.text$mn:000099A6                 lea     ecx, [ebp+var_C]
.text$mn:000099A9                 push    ecx
.text$mn:000099AA                 call    ??$get_temporary_buffer@H@std@@YA?AU?$pair@PAHH@0@H@Z ; std::get_temporary_buffer<int>(int)
.text$mn:000099AF                 add     esp, 8
.text$mn:000099B2                 mov     edx, [ebp+var_4]
.text$mn:000099B5                 mov     eax, [edx+10h]
.text$mn:000099B8                 mov     ecx, [ebp+var_C]
.text$mn:000099BB                 mov     [eax], ecx
.text$mn:000099BD                 mov     edx, [ebp+var_4]
.text$mn:000099C0                 mov     eax, [edx+10h]
.text$mn:000099C3                 mov     ecx, [ebp+var_C]
.text$mn:000099C6                 mov     [eax+4], ecx
.text$mn:000099C9                 mov     edx, [ebp+var_4]
.text$mn:000099CC                 mov     eax, [edx+10h]
.text$mn:000099CF                 mov     ecx, [ebp+var_C]
.text$mn:000099D2                 mov     [eax+8], ecx
.text$mn:000099D5                 mov     edx, [ebp+var_4]
.text$mn:000099D8                 mov     eax, [edx+10h]
.text$mn:000099DB                 mov     ecx, [ebp+var_8]
.text$mn:000099DE                 mov     [eax+0Ch], ecx
.text$mn:000099E1
.text$mn:000099E1 loc_99E1:                               ; CODE XREF: std::_Temp_iterator<int>::_Maxlen(void)+12j
.text$mn:000099E1                                         ; std::_Temp_iterator<int>::_Maxlen(void)+1Ej
.text$mn:000099E1                 mov     edx, [ebp+var_4]
.text$mn:000099E4                 mov     eax, [edx+10h]
.text$mn:000099E7                 mov     eax, [eax+0Ch]
.text$mn:000099EA                 mov     esp, ebp
.text$mn:000099EC                 pop     ebp
.text$mn:000099ED                 retn
.text$mn:000099ED ?_Maxlen@?$_Temp_iterator@H@std@@QAEHXZ endp
.text$mn:000099ED
.text$mn:000099ED ; ---------------------------------------------------------------------------
.text$mn:000099EE                 align 10h
.text$mn:000099EE _text$mn        ends
.text$mn:000099EE
.text$mn:000099F0 ; ===========================================================================
.text$mn:000099F0
.text$mn:000099F0 ; Segment type: Pure code
.text$mn:000099F0 ; Segment permissions: Read/Execute
.text$mn:000099F0 _text$mn        segment para public 'CODE' use32
.text$mn:000099F0                 assume cs:_text$mn
.text$mn:000099F0                 ;org 99F0h
.text$mn:000099F0 ; COMDAT (pick any)
.text$mn:000099F0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000099F0
.text$mn:000099F0 ; =============== S U B R O U T I N E =======================================
.text$mn:000099F0
.text$mn:000099F0 ; Attributes: bp-based frame
.text$mn:000099F0
.text$mn:000099F0 ; public: char * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)
.text$mn:000099F0                 public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
.text$mn:000099F0 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ proc near
.text$mn:000099F0                                         ; CODE XREF: $LN19+14p
.text$mn:000099F0                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+1Dp ...
.text$mn:000099F0
.text$mn:000099F0 var_8           = dword ptr -8
.text$mn:000099F0 var_4           = dword ptr -4
.text$mn:000099F0
.text$mn:000099F0                 push    ebp
.text$mn:000099F1                 mov     ebp, esp
.text$mn:000099F3                 sub     esp, 8
.text$mn:000099F6                 mov     [ebp+var_4], ecx
.text$mn:000099F9                 mov     eax, [ebp+var_4]
.text$mn:000099FC                 cmp     dword ptr [eax+18h], 10h
.text$mn:00009A00                 jb      short loc_9A16
.text$mn:00009A02                 mov     ecx, [ebp+var_4]
.text$mn:00009A05                 mov     edx, [ecx+4]
.text$mn:00009A08                 push    edx
.text$mn:00009A09                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:00009A0E                 add     esp, 4
.text$mn:00009A11                 mov     [ebp+var_8], eax
.text$mn:00009A14                 jmp     short loc_9A1F
.text$mn:00009A16 ; ---------------------------------------------------------------------------
.text$mn:00009A16
.text$mn:00009A16 loc_9A16:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+10j
.text$mn:00009A16                 mov     eax, [ebp+var_4]
.text$mn:00009A19                 add     eax, 4
.text$mn:00009A1C                 mov     [ebp+var_8], eax
.text$mn:00009A1F
.text$mn:00009A1F loc_9A1F:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+24j
.text$mn:00009A1F                 mov     eax, [ebp+var_8]
.text$mn:00009A22                 mov     esp, ebp
.text$mn:00009A24                 pop     ebp
.text$mn:00009A25                 retn
.text$mn:00009A25 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ endp
.text$mn:00009A25
.text$mn:00009A25 ; ---------------------------------------------------------------------------
.text$mn:00009A26                 align 4
.text$mn:00009A26 _text$mn        ends
.text$mn:00009A26
.text$mn:00009A28 ; ===========================================================================
.text$mn:00009A28
.text$mn:00009A28 ; Segment type: Pure code
.text$mn:00009A28 ; Segment permissions: Read/Execute
.text$mn:00009A28 _text$mn        segment para public 'CODE' use32
.text$mn:00009A28                 assume cs:_text$mn
.text$mn:00009A28                 ;org 9A28h
.text$mn:00009A28 ; COMDAT (pick any)
.text$mn:00009A28                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009A28
.text$mn:00009A28 ; =============== S U B R O U T I N E =======================================
.text$mn:00009A28
.text$mn:00009A28 ; Attributes: bp-based frame
.text$mn:00009A28
.text$mn:00009A28 ; public: char const * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)const
.text$mn:00009A28                 public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
.text$mn:00009A28 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ proc near
.text$mn:00009A28                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+7Dp
.text$mn:00009A28                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::c_str(void)+Ap
.text$mn:00009A28
.text$mn:00009A28 var_8           = dword ptr -8
.text$mn:00009A28 var_4           = dword ptr -4
.text$mn:00009A28
.text$mn:00009A28                 push    ebp
.text$mn:00009A29                 mov     ebp, esp
.text$mn:00009A2B                 sub     esp, 8
.text$mn:00009A2E                 mov     [ebp+var_4], ecx
.text$mn:00009A31                 mov     eax, [ebp+var_4]
.text$mn:00009A34                 cmp     dword ptr [eax+18h], 10h
.text$mn:00009A38                 jb      short loc_9A4E
.text$mn:00009A3A                 mov     ecx, [ebp+var_4]
.text$mn:00009A3D                 mov     edx, [ecx+4]
.text$mn:00009A40                 push    edx
.text$mn:00009A41                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:00009A46                 add     esp, 4
.text$mn:00009A49                 mov     [ebp+var_8], eax
.text$mn:00009A4C                 jmp     short loc_9A57
.text$mn:00009A4E ; ---------------------------------------------------------------------------
.text$mn:00009A4E
.text$mn:00009A4E loc_9A4E:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+10j
.text$mn:00009A4E                 mov     eax, [ebp+var_4]
.text$mn:00009A51                 add     eax, 4
.text$mn:00009A54                 mov     [ebp+var_8], eax
.text$mn:00009A57
.text$mn:00009A57 loc_9A57:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+24j
.text$mn:00009A57                 mov     eax, [ebp+var_8]
.text$mn:00009A5A                 mov     esp, ebp
.text$mn:00009A5C                 pop     ebp
.text$mn:00009A5D                 retn
.text$mn:00009A5D ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ endp
.text$mn:00009A5D
.text$mn:00009A5D ; ---------------------------------------------------------------------------
.text$mn:00009A5E                 align 10h
.text$mn:00009A5E _text$mn        ends
.text$mn:00009A5E
.text$mn:00009A60 ; ===========================================================================
.text$mn:00009A60
.text$mn:00009A60 ; Segment type: Pure code
.text$mn:00009A60 ; Segment permissions: Read/Execute
.text$mn:00009A60 _text$mn        segment para public 'CODE' use32
.text$mn:00009A60                 assume cs:_text$mn
.text$mn:00009A60                 ;org 9A60h
.text$mn:00009A60 ; COMDAT (pick any)
.text$mn:00009A60                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009A60
.text$mn:00009A60 ; =============== S U B R O U T I N E =======================================
.text$mn:00009A60
.text$mn:00009A60 ; Attributes: bp-based frame
.text$mn:00009A60
.text$mn:00009A60 ; public: wchar_t * __thiscall std::_String_val<struct std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00009A60                 public ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ
.text$mn:00009A60 ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ proc near
.text$mn:00009A60                                         ; CODE XREF: $LN19_0+14p
.text$mn:00009A60                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)+1Fp ...
.text$mn:00009A60
.text$mn:00009A60 var_8           = dword ptr -8
.text$mn:00009A60 var_4           = dword ptr -4
.text$mn:00009A60
.text$mn:00009A60                 push    ebp
.text$mn:00009A61                 mov     ebp, esp
.text$mn:00009A63                 sub     esp, 8
.text$mn:00009A66                 mov     [ebp+var_4], ecx
.text$mn:00009A69                 mov     eax, [ebp+var_4]
.text$mn:00009A6C                 cmp     dword ptr [eax+18h], 8
.text$mn:00009A70                 jb      short loc_9A86
.text$mn:00009A72                 mov     ecx, [ebp+var_4]
.text$mn:00009A75                 mov     edx, [ecx+4]
.text$mn:00009A78                 push    edx
.text$mn:00009A79                 call    ??$addressof@_W@std@@YAPA_WAA_W@Z ; std::addressof<wchar_t>(wchar_t &)
.text$mn:00009A7E                 add     esp, 4
.text$mn:00009A81                 mov     [ebp+var_8], eax
.text$mn:00009A84                 jmp     short loc_9A8F
.text$mn:00009A86 ; ---------------------------------------------------------------------------
.text$mn:00009A86
.text$mn:00009A86 loc_9A86:                               ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+10j
.text$mn:00009A86                 mov     eax, [ebp+var_4]
.text$mn:00009A89                 add     eax, 4
.text$mn:00009A8C                 mov     [ebp+var_8], eax
.text$mn:00009A8F
.text$mn:00009A8F loc_9A8F:                               ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+24j
.text$mn:00009A8F                 mov     eax, [ebp+var_8]
.text$mn:00009A92                 mov     esp, ebp
.text$mn:00009A94                 pop     ebp
.text$mn:00009A95                 retn
.text$mn:00009A95 ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ endp
.text$mn:00009A95
.text$mn:00009A95 ; ---------------------------------------------------------------------------
.text$mn:00009A96                 align 4
.text$mn:00009A96 _text$mn        ends
.text$mn:00009A96
.text$mn:00009A98 ; ===========================================================================
.text$mn:00009A98
.text$mn:00009A98 ; Segment type: Pure code
.text$mn:00009A98 ; Segment permissions: Read/Execute
.text$mn:00009A98 _text$mn        segment para public 'CODE' use32
.text$mn:00009A98                 assume cs:_text$mn
.text$mn:00009A98                 ;org 9A98h
.text$mn:00009A98 ; COMDAT (pick any)
.text$mn:00009A98                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009A98
.text$mn:00009A98 ; =============== S U B R O U T I N E =======================================
.text$mn:00009A98
.text$mn:00009A98 ; Attributes: bp-based frame
.text$mn:00009A98
.text$mn:00009A98 ; public: wchar_t const * __thiscall std::_String_val<struct std::_Simple_types<wchar_t>>::_Myptr(void)const
.text$mn:00009A98                 public ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ
.text$mn:00009A98 ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ proc near
.text$mn:00009A98                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+80p
.text$mn:00009A98                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+7Dp ...
.text$mn:00009A98
.text$mn:00009A98 var_8           = dword ptr -8
.text$mn:00009A98 var_4           = dword ptr -4
.text$mn:00009A98
.text$mn:00009A98                 push    ebp
.text$mn:00009A99                 mov     ebp, esp
.text$mn:00009A9B                 sub     esp, 8
.text$mn:00009A9E                 mov     [ebp+var_4], ecx
.text$mn:00009AA1                 mov     eax, [ebp+var_4]
.text$mn:00009AA4                 cmp     dword ptr [eax+18h], 8
.text$mn:00009AA8                 jb      short loc_9ABE
.text$mn:00009AAA                 mov     ecx, [ebp+var_4]
.text$mn:00009AAD                 mov     edx, [ecx+4]
.text$mn:00009AB0                 push    edx
.text$mn:00009AB1                 call    ??$addressof@_W@std@@YAPA_WAA_W@Z ; std::addressof<wchar_t>(wchar_t &)
.text$mn:00009AB6                 add     esp, 4
.text$mn:00009AB9                 mov     [ebp+var_8], eax
.text$mn:00009ABC                 jmp     short loc_9AC7
.text$mn:00009ABE ; ---------------------------------------------------------------------------
.text$mn:00009ABE
.text$mn:00009ABE loc_9ABE:                               ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+10j
.text$mn:00009ABE                 mov     eax, [ebp+var_4]
.text$mn:00009AC1                 add     eax, 4
.text$mn:00009AC4                 mov     [ebp+var_8], eax
.text$mn:00009AC7
.text$mn:00009AC7 loc_9AC7:                               ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+24j
.text$mn:00009AC7                 mov     eax, [ebp+var_8]
.text$mn:00009ACA                 mov     esp, ebp
.text$mn:00009ACC                 pop     ebp
.text$mn:00009ACD                 retn
.text$mn:00009ACD ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ endp
.text$mn:00009ACD
.text$mn:00009ACD ; ---------------------------------------------------------------------------
.text$mn:00009ACE                 align 10h
.text$mn:00009ACE _text$mn        ends
.text$mn:00009ACE
.text$mn:00009AD0 ; ===========================================================================
.text$mn:00009AD0
.text$mn:00009AD0 ; Segment type: Pure code
.text$mn:00009AD0 ; Segment permissions: Read/Execute
.text$mn:00009AD0 _text$mn        segment para public 'CODE' use32
.text$mn:00009AD0                 assume cs:_text$mn
.text$mn:00009AD0                 ;org 9AD0h
.text$mn:00009AD0 ; COMDAT (pick any)
.text$mn:00009AD0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009AD0
.text$mn:00009AD0 ; =============== S U B R O U T I N E =======================================
.text$mn:00009AD0
.text$mn:00009AD0 ; Attributes: bp-based frame
.text$mn:00009AD0
.text$mn:00009AD0 ; void __thiscall std::_Container_base12::_Orphan_all(std::_Container_base12 *__hidden this)
.text$mn:00009AD0                 public ?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$mn:00009AD0 ?_Orphan_all@_Container_base12@std@@QAEXXZ proc near
.text$mn:00009AD0                                         ; CODE XREF: std::_Container_base12::~_Container_base12(void)+Ap
.text$mn:00009AD0                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+14p ...
.text$mn:00009AD0
.text$mn:00009AD0 var_18          = byte ptr -18h
.text$mn:00009AD0 var_14          = dword ptr -14h
.text$mn:00009AD0 var_10          = dword ptr -10h
.text$mn:00009AD0 var_C           = dword ptr -0Ch
.text$mn:00009AD0 var_4           = dword ptr -4
.text$mn:00009AD0
.text$mn:00009AD0                 push    ebp
.text$mn:00009AD1                 mov     ebp, esp
.text$mn:00009AD3                 push    0FFFFFFFFh
.text$mn:00009AD5                 push    offset __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$mn:00009ADA                 mov     eax, large fs:0
.text$mn:00009AE0                 push    eax
.text$mn:00009AE1                 sub     esp, 0Ch
.text$mn:00009AE4                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00009AE9                 xor     eax, ebp
.text$mn:00009AEB                 push    eax
.text$mn:00009AEC                 lea     eax, [ebp+var_C]
.text$mn:00009AEF                 mov     large fs:0, eax
.text$mn:00009AF5                 mov     [ebp+var_14], ecx
.text$mn:00009AF8                 mov     eax, [ebp+var_14]
.text$mn:00009AFB                 cmp     dword ptr [eax], 0
.text$mn:00009AFE                 jz      short loc_9B5B
.text$mn:00009B00                 push    3               ; int
.text$mn:00009B02                 lea     ecx, [ebp+var_18] ; this
.text$mn:00009B05                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:00009B0A                 mov     [ebp+var_4], 0
.text$mn:00009B11                 mov     ecx, [ebp+var_14]
.text$mn:00009B14                 mov     edx, [ecx]
.text$mn:00009B16                 add     edx, 4
.text$mn:00009B19                 mov     [ebp+var_10], edx
.text$mn:00009B1C                 jmp     short loc_9B2B
.text$mn:00009B1E ; ---------------------------------------------------------------------------
.text$mn:00009B1E
.text$mn:00009B1E loc_9B1E:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+6Ej
.text$mn:00009B1E                 mov     eax, [ebp+var_10]
.text$mn:00009B21                 mov     ecx, [eax]
.text$mn:00009B23                 mov     edx, [ebp+var_10]
.text$mn:00009B26                 mov     eax, [ecx+4]
.text$mn:00009B29                 mov     [edx], eax
.text$mn:00009B2B
.text$mn:00009B2B loc_9B2B:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+4Cj
.text$mn:00009B2B                 mov     ecx, [ebp+var_10]
.text$mn:00009B2E                 cmp     dword ptr [ecx], 0
.text$mn:00009B31                 jz      short loc_9B40
.text$mn:00009B33                 mov     edx, [ebp+var_10]
.text$mn:00009B36                 mov     eax, [edx]
.text$mn:00009B38                 mov     dword ptr [eax], 0
.text$mn:00009B3E                 jmp     short loc_9B1E
.text$mn:00009B40 ; ---------------------------------------------------------------------------
.text$mn:00009B40
.text$mn:00009B40 loc_9B40:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+61j
.text$mn:00009B40                 mov     ecx, [ebp+var_14]
.text$mn:00009B43                 mov     edx, [ecx]
.text$mn:00009B45                 mov     dword ptr [edx+4], 0
.text$mn:00009B4C                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00009B53                 lea     ecx, [ebp+var_18] ; this
.text$mn:00009B56                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:00009B5B
.text$mn:00009B5B loc_9B5B:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+2Ej
.text$mn:00009B5B                 mov     ecx, [ebp+var_C]
.text$mn:00009B5E                 mov     large fs:0, ecx
.text$mn:00009B65                 pop     ecx
.text$mn:00009B66                 mov     esp, ebp
.text$mn:00009B68                 pop     ebp
.text$mn:00009B69                 retn
.text$mn:00009B69 ?_Orphan_all@_Container_base12@std@@QAEXXZ endp
.text$mn:00009B69
.text$mn:00009B69 ; ---------------------------------------------------------------------------
.text$mn:00009B6A                 align 4
.text$mn:00009B6A _text$mn        ends
.text$mn:00009B6A
.text$x:00009B6C ; ===========================================================================
.text$x:00009B6C
.text$x:00009B6C ; Segment type: Pure code
.text$x:00009B6C ; Segment permissions: Read/Execute
.text$x:00009B6C _text$x         segment para public 'CODE' use32
.text$x:00009B6C                 assume cs:_text$x
.text$x:00009B6C                 ;org 9B6Ch
.text$x:00009B6C ; COMDAT (pick associative to section at 9AD0)
.text$x:00009B6C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00009B6C
.text$x:00009B6C ; =============== S U B R O U T I N E =======================================
.text$x:00009B6C
.text$x:00009B6C
.text$x:00009B6C __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0 proc near
.text$x:00009B6C                                         ; DATA XREF: .xdata$x:0000C538o
.text$x:00009B6C                 lea     ecx, [ebp-18h]  ; this
.text$x:00009B6F                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:00009B6F __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0 endp
.text$x:00009B6F
.text$x:00009B74
.text$x:00009B74 ; =============== S U B R O U T I N E =======================================
.text$x:00009B74
.text$x:00009B74
.text$x:00009B74 __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ proc near
.text$x:00009B74                                         ; DATA XREF: std::_Container_base12::_Orphan_all(void)+5o
.text$x:00009B74
.text$x:00009B74 arg_4           = dword ptr  8
.text$x:00009B74
.text$x:00009B74                 mov     edx, [esp+arg_4]
.text$x:00009B78                 lea     eax, [edx+0Ch]
.text$x:00009B7B                 mov     ecx, [edx-10h]
.text$x:00009B7E                 xor     ecx, eax
.text$x:00009B80                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00009B85                 mov     eax, offset __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$x:00009B8A                 jmp     ___CxxFrameHandler3
.text$x:00009B8A __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ endp
.text$x:00009B8A
.text$x:00009B8A ; ---------------------------------------------------------------------------
.text$x:00009B8F                 align 10h
.text$x:00009B8F _text$x         ends
.text$x:00009B8F
.text$mn:00009B90 ; ===========================================================================
.text$mn:00009B90
.text$mn:00009B90 ; Segment type: Pure code
.text$mn:00009B90 ; Segment permissions: Read/Execute
.text$mn:00009B90 _text$mn        segment para public 'CODE' use32
.text$mn:00009B90                 assume cs:_text$mn
.text$mn:00009B90                 ;org 9B90h
.text$mn:00009B90 ; COMDAT (pick any)
.text$mn:00009B90                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009B90
.text$mn:00009B90 ; =============== S U B R O U T I N E =======================================
.text$mn:00009B90
.text$mn:00009B90 ; Attributes: bp-based frame
.text$mn:00009B90
.text$mn:00009B90 ; void __thiscall std::_Iterator_base12::_Orphan_me(std::_Iterator_base12 *__hidden this)
.text$mn:00009B90                 public ?_Orphan_me@_Iterator_base12@std@@QAEXXZ
.text$mn:00009B90 ?_Orphan_me@_Iterator_base12@std@@QAEXXZ proc near
.text$mn:00009B90                                         ; CODE XREF: std::_Iterator_base12::~_Iterator_base12(void)+3Cp
.text$mn:00009B90                                         ; std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+64p ...
.text$mn:00009B90
.text$mn:00009B90 var_8           = dword ptr -8
.text$mn:00009B90 var_4           = dword ptr -4
.text$mn:00009B90
.text$mn:00009B90                 push    ebp
.text$mn:00009B91                 mov     ebp, esp
.text$mn:00009B93                 sub     esp, 8
.text$mn:00009B96                 mov     [ebp+var_8], ecx
.text$mn:00009B99                 mov     eax, [ebp+var_8]
.text$mn:00009B9C                 cmp     dword ptr [eax], 0
.text$mn:00009B9F                 jz      short loc_9BFE
.text$mn:00009BA1                 mov     ecx, [ebp+var_8]
.text$mn:00009BA4                 mov     edx, [ecx]
.text$mn:00009BA6                 add     edx, 4
.text$mn:00009BA9                 mov     [ebp+var_4], edx
.text$mn:00009BAC
.text$mn:00009BAC loc_9BAC:                               ; CODE XREF: std::_Iterator_base12::_Orphan_me(void)+39j
.text$mn:00009BAC                 mov     eax, [ebp+var_4]
.text$mn:00009BAF                 cmp     dword ptr [eax], 0
.text$mn:00009BB2                 jz      short loc_9BCB
.text$mn:00009BB4                 mov     ecx, [ebp+var_4]
.text$mn:00009BB7                 mov     edx, [ecx]
.text$mn:00009BB9                 cmp     edx, [ebp+var_8]
.text$mn:00009BBC                 jz      short loc_9BCB
.text$mn:00009BBE                 mov     eax, [ebp+var_4]
.text$mn:00009BC1                 mov     ecx, [eax]
.text$mn:00009BC3                 add     ecx, 4
.text$mn:00009BC6                 mov     [ebp+var_4], ecx
.text$mn:00009BC9                 jmp     short loc_9BAC
.text$mn:00009BCB ; ---------------------------------------------------------------------------
.text$mn:00009BCB
.text$mn:00009BCB loc_9BCB:                               ; CODE XREF: std::_Iterator_base12::_Orphan_me(void)+22j
.text$mn:00009BCB                                         ; std::_Iterator_base12::_Orphan_me(void)+2Cj
.text$mn:00009BCB                 mov     edx, [ebp+var_4]
.text$mn:00009BCE                 cmp     dword ptr [edx], 0
.text$mn:00009BD1                 jnz     short loc_9BEA
.text$mn:00009BD3                 push    0C9h ; '+'      ; unsigned int
.text$mn:00009BD8                 push    offset ??_C@_1JA@EADLBAJ@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00009BDD                 push    offset ??_C@_1DC@POOIKBAO@?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5?$AAC?$AAO?$AAR?$AAR?$AAU?$AAP?$AAT?$AAE?$AAD?$AA?$CB?$AA?$AA@ ; "ITERATOR LIST CORRUPTED!"
.text$mn:00009BE2                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00009BE7                 add     esp, 0Ch
.text$mn:00009BEA
.text$mn:00009BEA loc_9BEA:                               ; CODE XREF: std::_Iterator_base12::_Orphan_me(void)+41j
.text$mn:00009BEA                 mov     eax, [ebp+var_4]
.text$mn:00009BED                 mov     ecx, [ebp+var_8]
.text$mn:00009BF0                 mov     edx, [ecx+4]
.text$mn:00009BF3                 mov     [eax], edx
.text$mn:00009BF5                 mov     eax, [ebp+var_8]
.text$mn:00009BF8                 mov     dword ptr [eax], 0
.text$mn:00009BFE
.text$mn:00009BFE loc_9BFE:                               ; CODE XREF: std::_Iterator_base12::_Orphan_me(void)+Fj
.text$mn:00009BFE                 mov     esp, ebp
.text$mn:00009C00                 pop     ebp
.text$mn:00009C01                 retn
.text$mn:00009C01 ?_Orphan_me@_Iterator_base12@std@@QAEXXZ endp
.text$mn:00009C01
.text$mn:00009C01 ; ---------------------------------------------------------------------------
.text$mn:00009C02                 align 4
.text$mn:00009C02 _text$mn        ends
.text$mn:00009C02
.text$mn:00009C04 ; ===========================================================================
.text$mn:00009C04
.text$mn:00009C04 ; Segment type: Pure code
.text$mn:00009C04 ; Segment permissions: Read/Execute
.text$mn:00009C04 _text$mn        segment para public 'CODE' use32
.text$mn:00009C04                 assume cs:_text$mn
.text$mn:00009C04                 ;org 9C04h
.text$mn:00009C04 ; COMDAT (pick any)
.text$mn:00009C04                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009C04
.text$mn:00009C04 ; =============== S U B R O U T I N E =======================================
.text$mn:00009C04
.text$mn:00009C04 ; Attributes: bp-based frame
.text$mn:00009C04
.text$mn:00009C04 ; protected: void __thiscall std::vector<int, class std::allocator<int>>::_Orphan_range(int *, int *)const
.text$mn:00009C04                 public ?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@IBEXPAH0@Z
.text$mn:00009C04 ?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@IBEXPAH0@Z proc near
.text$mn:00009C04                                         ; CODE XREF: std::vector<int,std::allocator<int>>::_Pop_back_n(uint)+28p
.text$mn:00009C04                                         ; std::vector<int,std::allocator<int>>::erase(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>)+220p
.text$mn:00009C04
.text$mn:00009C04 var_18          = byte ptr -18h
.text$mn:00009C04 var_14          = dword ptr -14h
.text$mn:00009C04 var_10          = dword ptr -10h
.text$mn:00009C04 var_C           = dword ptr -0Ch
.text$mn:00009C04 var_4           = dword ptr -4
.text$mn:00009C04 arg_0           = dword ptr  8
.text$mn:00009C04 arg_4           = dword ptr  0Ch
.text$mn:00009C04
.text$mn:00009C04                 push    ebp
.text$mn:00009C05                 mov     ebp, esp
.text$mn:00009C07                 push    0FFFFFFFFh
.text$mn:00009C09                 push    offset __ehhandler$?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@IBEXPAH0@Z
.text$mn:00009C0E                 mov     eax, large fs:0
.text$mn:00009C14                 push    eax
.text$mn:00009C15                 sub     esp, 0Ch
.text$mn:00009C18                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00009C1D                 xor     eax, ebp
.text$mn:00009C1F                 push    eax
.text$mn:00009C20                 lea     eax, [ebp+var_C]
.text$mn:00009C23                 mov     large fs:0, eax
.text$mn:00009C29                 mov     [ebp+var_14], ecx
.text$mn:00009C2C                 push    3               ; int
.text$mn:00009C2E                 lea     ecx, [ebp+var_18] ; this
.text$mn:00009C31                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:00009C36                 mov     [ebp+var_4], 0
.text$mn:00009C3D                 mov     ecx, [ebp+var_14] ; this
.text$mn:00009C40                 call    ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ ; std::_Container_base12::_Getpfirst(void)
.text$mn:00009C45                 mov     [ebp+var_10], eax
.text$mn:00009C48                 cmp     [ebp+var_10], 0
.text$mn:00009C4C                 jz      short loc_9C9C
.text$mn:00009C4E
.text$mn:00009C4E loc_9C4E:                               ; CODE XREF: std::vector<int,std::allocator<int>>::_Orphan_range(int *,int *):loc_9C9Aj
.text$mn:00009C4E                 mov     eax, [ebp+var_10]
.text$mn:00009C51                 cmp     dword ptr [eax], 0
.text$mn:00009C54                 jz      short loc_9C9C
.text$mn:00009C56                 mov     ecx, [ebp+var_10]
.text$mn:00009C59                 mov     edx, [ecx]
.text$mn:00009C5B                 mov     eax, [edx+8]
.text$mn:00009C5E                 cmp     eax, [ebp+arg_0]
.text$mn:00009C61                 jb      short loc_9C70
.text$mn:00009C63                 mov     ecx, [ebp+var_10]
.text$mn:00009C66                 mov     edx, [ecx]
.text$mn:00009C68                 mov     eax, [ebp+arg_4]
.text$mn:00009C6B                 cmp     eax, [edx+8]
.text$mn:00009C6E                 jnb     short loc_9C7F
.text$mn:00009C70
.text$mn:00009C70 loc_9C70:                               ; CODE XREF: std::vector<int,std::allocator<int>>::_Orphan_range(int *,int *)+5Dj
.text$mn:00009C70                 mov     ecx, [ebp+var_10]
.text$mn:00009C73                 mov     ecx, [ecx]      ; this
.text$mn:00009C75                 call    ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext(void)
.text$mn:00009C7A                 mov     [ebp+var_10], eax
.text$mn:00009C7D                 jmp     short loc_9C9A
.text$mn:00009C7F ; ---------------------------------------------------------------------------
.text$mn:00009C7F
.text$mn:00009C7F loc_9C7F:                               ; CODE XREF: std::vector<int,std::allocator<int>>::_Orphan_range(int *,int *)+6Aj
.text$mn:00009C7F                 mov     edx, [ebp+var_10]
.text$mn:00009C82                 mov     ecx, [edx]      ; this
.text$mn:00009C84                 call    ?_Clrcont@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Clrcont(void)
.text$mn:00009C89                 mov     eax, [ebp+var_10]
.text$mn:00009C8C                 mov     ecx, [eax]      ; this
.text$mn:00009C8E                 call    ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext(void)
.text$mn:00009C93                 mov     ecx, [ebp+var_10]
.text$mn:00009C96                 mov     edx, [eax]
.text$mn:00009C98                 mov     [ecx], edx
.text$mn:00009C9A
.text$mn:00009C9A loc_9C9A:                               ; CODE XREF: std::vector<int,std::allocator<int>>::_Orphan_range(int *,int *)+79j
.text$mn:00009C9A                 jmp     short loc_9C4E
.text$mn:00009C9C ; ---------------------------------------------------------------------------
.text$mn:00009C9C
.text$mn:00009C9C loc_9C9C:                               ; CODE XREF: std::vector<int,std::allocator<int>>::_Orphan_range(int *,int *)+48j
.text$mn:00009C9C                                         ; std::vector<int,std::allocator<int>>::_Orphan_range(int *,int *)+50j
.text$mn:00009C9C                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00009CA3                 lea     ecx, [ebp+var_18] ; this
.text$mn:00009CA6                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:00009CAB                 mov     ecx, [ebp+var_C]
.text$mn:00009CAE                 mov     large fs:0, ecx
.text$mn:00009CB5                 pop     ecx
.text$mn:00009CB6                 mov     esp, ebp
.text$mn:00009CB8                 pop     ebp
.text$mn:00009CB9                 retn    8
.text$mn:00009CB9 ?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@IBEXPAH0@Z endp
.text$mn:00009CB9
.text$mn:00009CB9 _text$mn        ends
.text$mn:00009CB9
.text$x:00009CBC ; ===========================================================================
.text$x:00009CBC
.text$x:00009CBC ; Segment type: Pure code
.text$x:00009CBC ; Segment permissions: Read/Execute
.text$x:00009CBC _text$x         segment para public 'CODE' use32
.text$x:00009CBC                 assume cs:_text$x
.text$x:00009CBC                 ;org 9CBCh
.text$x:00009CBC ; COMDAT (pick associative to section at 9C04)
.text$x:00009CBC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00009CBC
.text$x:00009CBC ; =============== S U B R O U T I N E =======================================
.text$x:00009CBC
.text$x:00009CBC
.text$x:00009CBC __unwindfunclet$?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@IBEXPAH0@Z$0 proc near
.text$x:00009CBC                                         ; DATA XREF: .xdata$x:0000D038o
.text$x:00009CBC                 lea     ecx, [ebp-18h]  ; this
.text$x:00009CBF                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:00009CBF __unwindfunclet$?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@IBEXPAH0@Z$0 endp
.text$x:00009CBF
.text$x:00009CC4
.text$x:00009CC4 ; =============== S U B R O U T I N E =======================================
.text$x:00009CC4
.text$x:00009CC4
.text$x:00009CC4 __ehhandler$?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@IBEXPAH0@Z proc near
.text$x:00009CC4                                         ; DATA XREF: std::vector<int,std::allocator<int>>::_Orphan_range(int *,int *)+5o
.text$x:00009CC4
.text$x:00009CC4 arg_4           = dword ptr  8
.text$x:00009CC4
.text$x:00009CC4                 mov     edx, [esp+arg_4]
.text$x:00009CC8                 lea     eax, [edx+0Ch]
.text$x:00009CCB                 mov     ecx, [edx-10h]
.text$x:00009CCE                 xor     ecx, eax
.text$x:00009CD0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00009CD5                 mov     eax, offset __ehfuncinfo$?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@IBEXPAH0@Z
.text$x:00009CDA                 jmp     ___CxxFrameHandler3
.text$x:00009CDA __ehhandler$?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@IBEXPAH0@Z endp
.text$x:00009CDA
.text$x:00009CDA ; ---------------------------------------------------------------------------
.text$x:00009CDF                 align 10h
.text$x:00009CDF _text$x         ends
.text$x:00009CDF
.text$mn:00009CE0 ; ===========================================================================
.text$mn:00009CE0
.text$mn:00009CE0 ; Segment type: Pure code
.text$mn:00009CE0 ; Segment permissions: Read/Execute
.text$mn:00009CE0 _text$mn        segment para public 'CODE' use32
.text$mn:00009CE0                 assume cs:_text$mn
.text$mn:00009CE0                 ;org 9CE0h
.text$mn:00009CE0 ; COMDAT (pick any)
.text$mn:00009CE0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009CE0
.text$mn:00009CE0 ; =============== S U B R O U T I N E =======================================
.text$mn:00009CE0
.text$mn:00009CE0 ; Attributes: bp-based frame
.text$mn:00009CE0
.text$mn:00009CE0 ; protected: void __thiscall std::vector<wchar_t, class std::allocator<wchar_t>>::_Orphan_range(wchar_t *, wchar_t *)const
.text$mn:00009CE0                 public ?_Orphan_range@?$vector@_WV?$allocator@_W@std@@@std@@IBEXPA_W0@Z
.text$mn:00009CE0 ?_Orphan_range@?$vector@_WV?$allocator@_W@std@@@std@@IBEXPA_W0@Z proc near
.text$mn:00009CE0                                         ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::push_back(wchar_t &&)+69p
.text$mn:00009CE0                                         ; std::vector<wchar_t,std::allocator<wchar_t>>::push_back(wchar_t &&)+D8p
.text$mn:00009CE0
.text$mn:00009CE0 var_18          = byte ptr -18h
.text$mn:00009CE0 var_14          = dword ptr -14h
.text$mn:00009CE0 var_10          = dword ptr -10h
.text$mn:00009CE0 var_C           = dword ptr -0Ch
.text$mn:00009CE0 var_4           = dword ptr -4
.text$mn:00009CE0 arg_0           = dword ptr  8
.text$mn:00009CE0 arg_4           = dword ptr  0Ch
.text$mn:00009CE0
.text$mn:00009CE0                 push    ebp
.text$mn:00009CE1                 mov     ebp, esp
.text$mn:00009CE3                 push    0FFFFFFFFh
.text$mn:00009CE5                 push    offset __ehhandler$?_Orphan_range@?$vector@_WV?$allocator@_W@std@@@std@@IBEXPA_W0@Z
.text$mn:00009CEA                 mov     eax, large fs:0
.text$mn:00009CF0                 push    eax
.text$mn:00009CF1                 sub     esp, 0Ch
.text$mn:00009CF4                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00009CF9                 xor     eax, ebp
.text$mn:00009CFB                 push    eax
.text$mn:00009CFC                 lea     eax, [ebp+var_C]
.text$mn:00009CFF                 mov     large fs:0, eax
.text$mn:00009D05                 mov     [ebp+var_14], ecx
.text$mn:00009D08                 push    3               ; int
.text$mn:00009D0A                 lea     ecx, [ebp+var_18] ; this
.text$mn:00009D0D                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:00009D12                 mov     [ebp+var_4], 0
.text$mn:00009D19                 mov     ecx, [ebp+var_14] ; this
.text$mn:00009D1C                 call    ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ ; std::_Container_base12::_Getpfirst(void)
.text$mn:00009D21                 mov     [ebp+var_10], eax
.text$mn:00009D24                 cmp     [ebp+var_10], 0
.text$mn:00009D28                 jz      short loc_9D78
.text$mn:00009D2A
.text$mn:00009D2A loc_9D2A:                               ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::_Orphan_range(wchar_t *,wchar_t *):loc_9D76j
.text$mn:00009D2A                 mov     eax, [ebp+var_10]
.text$mn:00009D2D                 cmp     dword ptr [eax], 0
.text$mn:00009D30                 jz      short loc_9D78
.text$mn:00009D32                 mov     ecx, [ebp+var_10]
.text$mn:00009D35                 mov     edx, [ecx]
.text$mn:00009D37                 mov     eax, [edx+8]
.text$mn:00009D3A                 cmp     eax, [ebp+arg_0]
.text$mn:00009D3D                 jb      short loc_9D4C
.text$mn:00009D3F                 mov     ecx, [ebp+var_10]
.text$mn:00009D42                 mov     edx, [ecx]
.text$mn:00009D44                 mov     eax, [ebp+arg_4]
.text$mn:00009D47                 cmp     eax, [edx+8]
.text$mn:00009D4A                 jnb     short loc_9D5B
.text$mn:00009D4C
.text$mn:00009D4C loc_9D4C:                               ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::_Orphan_range(wchar_t *,wchar_t *)+5Dj
.text$mn:00009D4C                 mov     ecx, [ebp+var_10]
.text$mn:00009D4F                 mov     ecx, [ecx]      ; this
.text$mn:00009D51                 call    ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext(void)
.text$mn:00009D56                 mov     [ebp+var_10], eax
.text$mn:00009D59                 jmp     short loc_9D76
.text$mn:00009D5B ; ---------------------------------------------------------------------------
.text$mn:00009D5B
.text$mn:00009D5B loc_9D5B:                               ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::_Orphan_range(wchar_t *,wchar_t *)+6Aj
.text$mn:00009D5B                 mov     edx, [ebp+var_10]
.text$mn:00009D5E                 mov     ecx, [edx]      ; this
.text$mn:00009D60                 call    ?_Clrcont@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Clrcont(void)
.text$mn:00009D65                 mov     eax, [ebp+var_10]
.text$mn:00009D68                 mov     ecx, [eax]      ; this
.text$mn:00009D6A                 call    ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext(void)
.text$mn:00009D6F                 mov     ecx, [ebp+var_10]
.text$mn:00009D72                 mov     edx, [eax]
.text$mn:00009D74                 mov     [ecx], edx
.text$mn:00009D76
.text$mn:00009D76 loc_9D76:                               ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::_Orphan_range(wchar_t *,wchar_t *)+79j
.text$mn:00009D76                 jmp     short loc_9D2A
.text$mn:00009D78 ; ---------------------------------------------------------------------------
.text$mn:00009D78
.text$mn:00009D78 loc_9D78:                               ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::_Orphan_range(wchar_t *,wchar_t *)+48j
.text$mn:00009D78                                         ; std::vector<wchar_t,std::allocator<wchar_t>>::_Orphan_range(wchar_t *,wchar_t *)+50j
.text$mn:00009D78                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00009D7F                 lea     ecx, [ebp+var_18] ; this
.text$mn:00009D82                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:00009D87                 mov     ecx, [ebp+var_C]
.text$mn:00009D8A                 mov     large fs:0, ecx
.text$mn:00009D91                 pop     ecx
.text$mn:00009D92                 mov     esp, ebp
.text$mn:00009D94                 pop     ebp
.text$mn:00009D95                 retn    8
.text$mn:00009D95 ?_Orphan_range@?$vector@_WV?$allocator@_W@std@@@std@@IBEXPA_W0@Z endp
.text$mn:00009D95
.text$mn:00009D95 _text$mn        ends
.text$mn:00009D95
.text$x:00009D98 ; ===========================================================================
.text$x:00009D98
.text$x:00009D98 ; Segment type: Pure code
.text$x:00009D98 ; Segment permissions: Read/Execute
.text$x:00009D98 _text$x         segment para public 'CODE' use32
.text$x:00009D98                 assume cs:_text$x
.text$x:00009D98                 ;org 9D98h
.text$x:00009D98 ; COMDAT (pick associative to section at 9CE0)
.text$x:00009D98                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00009D98
.text$x:00009D98 ; =============== S U B R O U T I N E =======================================
.text$x:00009D98
.text$x:00009D98
.text$x:00009D98 __unwindfunclet$?_Orphan_range@?$vector@_WV?$allocator@_W@std@@@std@@IBEXPA_W0@Z$0 proc near
.text$x:00009D98                                         ; DATA XREF: .xdata$x:0000D5D8o
.text$x:00009D98                 lea     ecx, [ebp-18h]  ; this
.text$x:00009D9B                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:00009D9B __unwindfunclet$?_Orphan_range@?$vector@_WV?$allocator@_W@std@@@std@@IBEXPA_W0@Z$0 endp
.text$x:00009D9B
.text$x:00009DA0
.text$x:00009DA0 ; =============== S U B R O U T I N E =======================================
.text$x:00009DA0
.text$x:00009DA0
.text$x:00009DA0 __ehhandler$?_Orphan_range@?$vector@_WV?$allocator@_W@std@@@std@@IBEXPA_W0@Z proc near
.text$x:00009DA0                                         ; DATA XREF: std::vector<wchar_t,std::allocator<wchar_t>>::_Orphan_range(wchar_t *,wchar_t *)+5o
.text$x:00009DA0
.text$x:00009DA0 arg_4           = dword ptr  8
.text$x:00009DA0
.text$x:00009DA0                 mov     edx, [esp+arg_4]
.text$x:00009DA4                 lea     eax, [edx+0Ch]
.text$x:00009DA7                 mov     ecx, [edx-10h]
.text$x:00009DAA                 xor     ecx, eax
.text$x:00009DAC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00009DB1                 mov     eax, offset __ehfuncinfo$?_Orphan_range@?$vector@_WV?$allocator@_W@std@@@std@@IBEXPA_W0@Z
.text$x:00009DB6                 jmp     ___CxxFrameHandler3
.text$x:00009DB6 __ehhandler$?_Orphan_range@?$vector@_WV?$allocator@_W@std@@@std@@IBEXPA_W0@Z endp
.text$x:00009DB6
.text$x:00009DB6 ; ---------------------------------------------------------------------------
.text$x:00009DBB                 align 4
.text$x:00009DBB _text$x         ends
.text$x:00009DBB
.text$mn:00009DBC ; ===========================================================================
.text$mn:00009DBC
.text$mn:00009DBC ; Segment type: Pure code
.text$mn:00009DBC ; Segment permissions: Read/Execute
.text$mn:00009DBC _text$mn        segment para public 'CODE' use32
.text$mn:00009DBC                 assume cs:_text$mn
.text$mn:00009DBC                 ;org 9DBCh
.text$mn:00009DBC ; COMDAT (pick any)
.text$mn:00009DBC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009DBC
.text$mn:00009DBC ; =============== S U B R O U T I N E =======================================
.text$mn:00009DBC
.text$mn:00009DBC ; Attributes: bp-based frame
.text$mn:00009DBC
.text$mn:00009DBC ; public: void __thiscall std::vector<int, class std::allocator<int>>::_Pop_back_n(unsigned int)
.text$mn:00009DBC                 public ?_Pop_back_n@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z
.text$mn:00009DBC ?_Pop_back_n@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z proc near
.text$mn:00009DBC                                         ; CODE XREF: std::vector<int,std::allocator<int>>::resize(uint)+4Bp
.text$mn:00009DBC                                         ; std::vector<int,std::allocator<int>>::resize(uint,int const &)+4Bp
.text$mn:00009DBC
.text$mn:00009DBC var_8           = dword ptr -8
.text$mn:00009DBC var_4           = dword ptr -4
.text$mn:00009DBC arg_0           = dword ptr  8
.text$mn:00009DBC
.text$mn:00009DBC                 push    ebp
.text$mn:00009DBD                 mov     ebp, esp
.text$mn:00009DBF                 sub     esp, 8
.text$mn:00009DC2                 mov     [ebp+var_4], ecx
.text$mn:00009DC5                 mov     eax, [ebp+arg_0]
.text$mn:00009DC8                 shl     eax, 2
.text$mn:00009DCB                 mov     ecx, [ebp+var_4]
.text$mn:00009DCE                 mov     edx, [ecx+8]
.text$mn:00009DD1                 sub     edx, eax
.text$mn:00009DD3                 mov     [ebp+var_8], edx
.text$mn:00009DD6                 mov     eax, [ebp+var_4]
.text$mn:00009DD9                 mov     ecx, [eax+8]
.text$mn:00009DDC                 push    ecx
.text$mn:00009DDD                 mov     edx, [ebp+var_8]
.text$mn:00009DE0                 push    edx
.text$mn:00009DE1                 mov     ecx, [ebp+var_4]
.text$mn:00009DE4                 call    ?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@IBEXPAH0@Z ; std::vector<int,std::allocator<int>>::_Orphan_range(int *,int *)
.text$mn:00009DE9                 mov     eax, [ebp+var_4]
.text$mn:00009DEC                 mov     ecx, [eax+8]
.text$mn:00009DEF                 push    ecx
.text$mn:00009DF0                 mov     edx, [ebp+var_8]
.text$mn:00009DF3                 push    edx
.text$mn:00009DF4                 mov     ecx, [ebp+var_4]
.text$mn:00009DF7                 call    ?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z ; std::vector<int,std::allocator<int>>::_Destroy(int *,int *)
.text$mn:00009DFC                 mov     eax, [ebp+var_4]
.text$mn:00009DFF                 mov     ecx, [ebp+var_8]
.text$mn:00009E02                 mov     [eax+8], ecx
.text$mn:00009E05                 mov     esp, ebp
.text$mn:00009E07                 pop     ebp
.text$mn:00009E08                 retn    4
.text$mn:00009E08 ?_Pop_back_n@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z endp
.text$mn:00009E08
.text$mn:00009E08 ; ---------------------------------------------------------------------------
.text$mn:00009E0B                 align 4
.text$mn:00009E0B _text$mn        ends
.text$mn:00009E0B
.text$mn:00009E0C ; ===========================================================================
.text$mn:00009E0C
.text$mn:00009E0C ; Segment type: Pure code
.text$mn:00009E0C ; Segment permissions: Read/Execute
.text$mn:00009E0C _text$mn        segment para public 'CODE' use32
.text$mn:00009E0C                 assume cs:_text$mn
.text$mn:00009E0C                 ;org 9E0Ch
.text$mn:00009E0C ; COMDAT (pick any)
.text$mn:00009E0C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009E0C
.text$mn:00009E0C ; =============== S U B R O U T I N E =======================================
.text$mn:00009E0C
.text$mn:00009E0C ; Attributes: bp-based frame
.text$mn:00009E0C
.text$mn:00009E0C ; protected: void __thiscall std::vector<int, class std::allocator<int>>::_Reallocate(unsigned int)
.text$mn:00009E0C                 public ?_Reallocate@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z
.text$mn:00009E0C ?_Reallocate@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z proc near
.text$mn:00009E0C                                         ; CODE XREF: std::vector<int,std::allocator<int>>::_Reserve(uint)+4Ep
.text$mn:00009E0C
.text$mn:00009E0C var_20          = dword ptr -20h
.text$mn:00009E0C var_1C          = dword ptr -1Ch
.text$mn:00009E0C var_18          = dword ptr -18h
.text$mn:00009E0C var_13          = byte ptr -13h
.text$mn:00009E0C var_11          = byte ptr -11h
.text$mn:00009E0C var_10          = dword ptr -10h
.text$mn:00009E0C var_C           = dword ptr -0Ch
.text$mn:00009E0C var_4           = dword ptr -4
.text$mn:00009E0C arg_0           = dword ptr  8
.text$mn:00009E0C
.text$mn:00009E0C ; FUNCTION CHUNK AT .text$mn:00009EA2 SIZE 00000009 BYTES
.text$mn:00009E0C ; FUNCTION CHUNK AT .text$mn:00009EB2 SIZE 00000097 BYTES
.text$mn:00009E0C
.text$mn:00009E0C                 push    ebp
.text$mn:00009E0D                 mov     ebp, esp
.text$mn:00009E0F                 push    0FFFFFFFFh
.text$mn:00009E11                 push    offset __ehhandler$?_Reallocate@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z
.text$mn:00009E16                 mov     eax, large fs:0
.text$mn:00009E1C                 push    eax
.text$mn:00009E1D                 push    ecx
.text$mn:00009E1E                 sub     esp, 10h
.text$mn:00009E21                 push    ebx
.text$mn:00009E22                 push    esi
.text$mn:00009E23                 push    edi
.text$mn:00009E24                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00009E29                 xor     eax, ebp
.text$mn:00009E2B                 push    eax
.text$mn:00009E2C                 lea     eax, [ebp+var_C]
.text$mn:00009E2F                 mov     large fs:0, eax
.text$mn:00009E35                 mov     [ebp+var_10], esp
.text$mn:00009E38                 mov     [ebp+var_18], ecx
.text$mn:00009E3B                 mov     eax, [ebp+arg_0]
.text$mn:00009E3E                 push    eax
.text$mn:00009E3F                 lea     ecx, [ebp+var_11]
.text$mn:00009E42                 push    ecx
.text$mn:00009E43                 mov     ecx, [ebp+var_18]
.text$mn:00009E46                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@H@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>::_Getal(void)
.text$mn:00009E4B                 mov     ecx, eax
.text$mn:00009E4D                 call    ?allocate@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAEPAHI@Z ; std::_Wrap_alloc<std::allocator<int>>::allocate(uint)
.text$mn:00009E52                 mov     [ebp+var_1C], eax
.text$mn:00009E55                 mov     [ebp+var_4], 0
.text$mn:00009E5C                 mov     edx, [ebp+var_1C]
.text$mn:00009E5F                 push    edx
.text$mn:00009E60                 mov     eax, [ebp+var_18]
.text$mn:00009E63                 mov     ecx, [eax+8]
.text$mn:00009E66                 push    ecx
.text$mn:00009E67                 mov     edx, [ebp+var_18]
.text$mn:00009E6A                 mov     eax, [edx+4]
.text$mn:00009E6D                 push    eax
.text$mn:00009E6E                 mov     ecx, [ebp+var_18]
.text$mn:00009E71                 call    ??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int>>::_Umove<int *>(int *,int *,int *)
.text$mn:00009E76                 jmp     short loc_9EA2
.text$mn:00009E76 ?_Reallocate@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z endp
.text$mn:00009E76
.text$mn:00009E78
.text$mn:00009E78 ; =============== S U B R O U T I N E =======================================
.text$mn:00009E78
.text$mn:00009E78 ; Attributes: noreturn
.text$mn:00009E78
.text$mn:00009E78 __catch$?_Reallocate@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z$0 proc near
.text$mn:00009E78                                         ; DATA XREF: .xdata$x:0000CFE8o
.text$mn:00009E78                 mov     ecx, [ebp+8]
.text$mn:00009E7B                 push    ecx             ; int
.text$mn:00009E7C                 mov     edx, [ebp-1Ch]
.text$mn:00009E7F                 push    edx             ; void *
.text$mn:00009E80                 lea     eax, [ebp-12h]
.text$mn:00009E83                 push    eax
.text$mn:00009E84                 mov     ecx, [ebp-18h]
.text$mn:00009E87                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@H@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>::_Getal(void)
.text$mn:00009E8C                 mov     ecx, eax
.text$mn:00009E8E                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAEXPAHI@Z ; std::_Wrap_alloc<std::allocator<int>>::deallocate(int *,uint)
.text$mn:00009E93                 push    0
.text$mn:00009E95                 push    0
.text$mn:00009E97                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00009E97 __catch$?_Reallocate@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z$0 endp
.text$mn:00009E97
.text$mn:00009E9C ; ---------------------------------------------------------------------------
.text$mn:00009E9C                 mov     eax, offset $LN8
.text$mn:00009EA1                 retn
.text$mn:00009EA2 ; ---------------------------------------------------------------------------
.text$mn:00009EA2 ; START OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z
.text$mn:00009EA2
.text$mn:00009EA2 loc_9EA2:                               ; CODE XREF: std::vector<int,std::allocator<int>>::_Reallocate(uint)+6Aj
.text$mn:00009EA2                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00009EA9                 jmp     short loc_9EB2
.text$mn:00009EA9 ; END OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z
.text$mn:00009EAB
.text$mn:00009EAB ; =============== S U B R O U T I N E =======================================
.text$mn:00009EAB
.text$mn:00009EAB
.text$mn:00009EAB $LN8            proc near               ; DATA XREF: .text$mn:00009E9Co
.text$mn:00009EAB                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:00009EAB $LN8            endp ; sp-analysis failed
.text$mn:00009EAB
.text$mn:00009EB2 ; START OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z
.text$mn:00009EB2
.text$mn:00009EB2 loc_9EB2:                               ; CODE XREF: std::vector<int,std::allocator<int>>::_Reallocate(uint)+9Dj
.text$mn:00009EB2                 mov     ecx, [ebp+var_18]
.text$mn:00009EB5                 call    ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int>>::size(void)
.text$mn:00009EBA                 mov     [ebp+var_20], eax
.text$mn:00009EBD                 mov     ecx, [ebp+var_18]
.text$mn:00009EC0                 cmp     dword ptr [ecx+4], 0
.text$mn:00009EC4                 jz      short loc_9F06
.text$mn:00009EC6                 mov     edx, [ebp+var_18]
.text$mn:00009EC9                 mov     eax, [edx+8]
.text$mn:00009ECC                 push    eax
.text$mn:00009ECD                 mov     ecx, [ebp+var_18]
.text$mn:00009ED0                 mov     edx, [ecx+4]
.text$mn:00009ED3                 push    edx
.text$mn:00009ED4                 mov     ecx, [ebp+var_18]
.text$mn:00009ED7                 call    ?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z ; std::vector<int,std::allocator<int>>::_Destroy(int *,int *)
.text$mn:00009EDC                 mov     eax, [ebp+var_18]
.text$mn:00009EDF                 mov     ecx, [ebp+var_18]
.text$mn:00009EE2                 mov     edx, [eax+0Ch]
.text$mn:00009EE5                 sub     edx, [ecx+4]
.text$mn:00009EE8                 sar     edx, 2
.text$mn:00009EEB                 push    edx             ; int
.text$mn:00009EEC                 mov     eax, [ebp+var_18]
.text$mn:00009EEF                 mov     ecx, [eax+4]
.text$mn:00009EF2                 push    ecx             ; void *
.text$mn:00009EF3                 lea     edx, [ebp+var_13]
.text$mn:00009EF6                 push    edx
.text$mn:00009EF7                 mov     ecx, [ebp+var_18]
.text$mn:00009EFA                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@H@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>::_Getal(void)
.text$mn:00009EFF                 mov     ecx, eax
.text$mn:00009F01                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAEXPAHI@Z ; std::_Wrap_alloc<std::allocator<int>>::deallocate(int *,uint)
.text$mn:00009F06
.text$mn:00009F06 loc_9F06:                               ; CODE XREF: std::vector<int,std::allocator<int>>::_Reallocate(uint)+B8j
.text$mn:00009F06                 mov     ecx, [ebp+var_18] ; this
.text$mn:00009F09                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00009F0E                 mov     eax, [ebp+arg_0]
.text$mn:00009F11                 mov     ecx, [ebp+var_1C]
.text$mn:00009F14                 lea     edx, [ecx+eax*4]
.text$mn:00009F17                 mov     eax, [ebp+var_18]
.text$mn:00009F1A                 mov     [eax+0Ch], edx
.text$mn:00009F1D                 mov     ecx, [ebp+var_20]
.text$mn:00009F20                 mov     edx, [ebp+var_1C]
.text$mn:00009F23                 lea     eax, [edx+ecx*4]
.text$mn:00009F26                 mov     ecx, [ebp+var_18]
.text$mn:00009F29                 mov     [ecx+8], eax
.text$mn:00009F2C                 mov     edx, [ebp+var_18]
.text$mn:00009F2F                 mov     eax, [ebp+var_1C]
.text$mn:00009F32                 mov     [edx+4], eax
.text$mn:00009F35                 mov     ecx, [ebp+var_C]
.text$mn:00009F38                 mov     large fs:0, ecx
.text$mn:00009F3F                 pop     ecx
.text$mn:00009F40                 pop     edi
.text$mn:00009F41                 pop     esi
.text$mn:00009F42                 pop     ebx
.text$mn:00009F43                 mov     esp, ebp
.text$mn:00009F45                 pop     ebp
.text$mn:00009F46                 retn    4
.text$mn:00009F46 ; END OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z
.text$mn:00009F46 ; ---------------------------------------------------------------------------
.text$mn:00009F49                 align 4
.text$mn:00009F49 _text$mn        ends
.text$mn:00009F49
.text$x:00009F4C ; ===========================================================================
.text$x:00009F4C
.text$x:00009F4C ; Segment type: Pure code
.text$x:00009F4C ; Segment permissions: Read/Execute
.text$x:00009F4C _text$x         segment para public 'CODE' use32
.text$x:00009F4C                 assume cs:_text$x
.text$x:00009F4C                 ;org 9F4Ch
.text$x:00009F4C ; COMDAT (pick associative to section at 9E0C)
.text$x:00009F4C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00009F4C
.text$x:00009F4C ; =============== S U B R O U T I N E =======================================
.text$x:00009F4C
.text$x:00009F4C
.text$x:00009F4C __ehhandler$?_Reallocate@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z proc near
.text$x:00009F4C                                         ; DATA XREF: std::vector<int,std::allocator<int>>::_Reallocate(uint)+5o
.text$x:00009F4C
.text$x:00009F4C arg_4           = dword ptr  8
.text$x:00009F4C
.text$x:00009F4C                 mov     edx, [esp+arg_4]
.text$x:00009F50                 lea     eax, [edx+0Ch]
.text$x:00009F53                 mov     ecx, [edx-24h]
.text$x:00009F56                 xor     ecx, eax
.text$x:00009F58                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00009F5D                 mov     eax, offset __ehfuncinfo$?_Reallocate@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z
.text$x:00009F62                 jmp     ___CxxFrameHandler3
.text$x:00009F62 __ehhandler$?_Reallocate@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z endp
.text$x:00009F62
.text$x:00009F62 ; ---------------------------------------------------------------------------
.text$x:00009F67                 align 4
.text$x:00009F67 _text$x         ends
.text$x:00009F67
.text$mn:00009F68 ; ===========================================================================
.text$mn:00009F68
.text$mn:00009F68 ; Segment type: Pure code
.text$mn:00009F68 ; Segment permissions: Read/Execute
.text$mn:00009F68 _text$mn        segment para public 'CODE' use32
.text$mn:00009F68                 assume cs:_text$mn
.text$mn:00009F68                 ;org 9F68h
.text$mn:00009F68 ; COMDAT (pick any)
.text$mn:00009F68                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009F68
.text$mn:00009F68 ; =============== S U B R O U T I N E =======================================
.text$mn:00009F68
.text$mn:00009F68 ; Attributes: bp-based frame
.text$mn:00009F68
.text$mn:00009F68 ; protected: void __thiscall std::vector<wchar_t, class std::allocator<wchar_t>>::_Reallocate(unsigned int)
.text$mn:00009F68                 public ?_Reallocate@?$vector@_WV?$allocator@_W@std@@@std@@IAEXI@Z
.text$mn:00009F68 ?_Reallocate@?$vector@_WV?$allocator@_W@std@@@std@@IAEXI@Z proc near
.text$mn:00009F68                                         ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::_Reserve(uint)+4Ep
.text$mn:00009F68
.text$mn:00009F68 var_20          = dword ptr -20h
.text$mn:00009F68 var_1C          = dword ptr -1Ch
.text$mn:00009F68 var_18          = dword ptr -18h
.text$mn:00009F68 var_13          = byte ptr -13h
.text$mn:00009F68 var_11          = byte ptr -11h
.text$mn:00009F68 var_10          = dword ptr -10h
.text$mn:00009F68 var_C           = dword ptr -0Ch
.text$mn:00009F68 var_4           = dword ptr -4
.text$mn:00009F68 arg_0           = dword ptr  8
.text$mn:00009F68
.text$mn:00009F68 ; FUNCTION CHUNK AT .text$mn:00009FFE SIZE 00000009 BYTES
.text$mn:00009F68 ; FUNCTION CHUNK AT .text$mn:0000A00E SIZE 00000096 BYTES
.text$mn:00009F68
.text$mn:00009F68                 push    ebp
.text$mn:00009F69                 mov     ebp, esp
.text$mn:00009F6B                 push    0FFFFFFFFh
.text$mn:00009F6D                 push    offset __ehhandler$?_Reallocate@?$vector@_WV?$allocator@_W@std@@@std@@IAEXI@Z
.text$mn:00009F72                 mov     eax, large fs:0
.text$mn:00009F78                 push    eax
.text$mn:00009F79                 push    ecx
.text$mn:00009F7A                 sub     esp, 10h
.text$mn:00009F7D                 push    ebx
.text$mn:00009F7E                 push    esi
.text$mn:00009F7F                 push    edi
.text$mn:00009F80                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00009F85                 xor     eax, ebp
.text$mn:00009F87                 push    eax
.text$mn:00009F88                 lea     eax, [ebp+var_C]
.text$mn:00009F8B                 mov     large fs:0, eax
.text$mn:00009F91                 mov     [ebp+var_10], esp
.text$mn:00009F94                 mov     [ebp+var_18], ecx
.text$mn:00009F97                 mov     eax, [ebp+arg_0]
.text$mn:00009F9A                 push    eax
.text$mn:00009F9B                 lea     ecx, [ebp+var_11]
.text$mn:00009F9E                 push    ecx
.text$mn:00009F9F                 mov     ecx, [ebp+var_18]
.text$mn:00009FA2                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:00009FA7                 mov     ecx, eax
.text$mn:00009FA9                 call    ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::allocate(uint)
.text$mn:00009FAE                 mov     [ebp+var_1C], eax
.text$mn:00009FB1                 mov     [ebp+var_4], 0
.text$mn:00009FB8                 mov     edx, [ebp+var_1C]
.text$mn:00009FBB                 push    edx
.text$mn:00009FBC                 mov     eax, [ebp+var_18]
.text$mn:00009FBF                 mov     ecx, [eax+8]
.text$mn:00009FC2                 push    ecx
.text$mn:00009FC3                 mov     edx, [ebp+var_18]
.text$mn:00009FC6                 mov     eax, [edx+4]
.text$mn:00009FC9                 push    eax
.text$mn:00009FCA                 mov     ecx, [ebp+var_18]
.text$mn:00009FCD                 call    ??$_Umove@PA_W@?$vector@_WV?$allocator@_W@std@@@std@@IAEPA_WPA_W00@Z ; std::vector<wchar_t,std::allocator<wchar_t>>::_Umove<wchar_t *>(wchar_t *,wchar_t *,wchar_t *)
.text$mn:00009FD2                 jmp     short loc_9FFE
.text$mn:00009FD2 ?_Reallocate@?$vector@_WV?$allocator@_W@std@@@std@@IAEXI@Z endp
.text$mn:00009FD2
.text$mn:00009FD4
.text$mn:00009FD4 ; =============== S U B R O U T I N E =======================================
.text$mn:00009FD4
.text$mn:00009FD4 ; Attributes: noreturn
.text$mn:00009FD4
.text$mn:00009FD4 __catch$?_Reallocate@?$vector@_WV?$allocator@_W@std@@@std@@IAEXI@Z$0 proc near
.text$mn:00009FD4                                         ; DATA XREF: .xdata$x:0000D588o
.text$mn:00009FD4                 mov     ecx, [ebp+8]
.text$mn:00009FD7                 push    ecx             ; int
.text$mn:00009FD8                 mov     edx, [ebp-1Ch]
.text$mn:00009FDB                 push    edx             ; void *
.text$mn:00009FDC                 lea     eax, [ebp-12h]
.text$mn:00009FDF                 push    eax
.text$mn:00009FE0                 mov     ecx, [ebp-18h]
.text$mn:00009FE3                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:00009FE8                 mov     ecx, eax
.text$mn:00009FEA                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::deallocate(wchar_t *,uint)
.text$mn:00009FEF                 push    0
.text$mn:00009FF1                 push    0
.text$mn:00009FF3                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00009FF3 __catch$?_Reallocate@?$vector@_WV?$allocator@_W@std@@@std@@IAEXI@Z$0 endp
.text$mn:00009FF3
.text$mn:00009FF8 ; ---------------------------------------------------------------------------
.text$mn:00009FF8                 mov     eax, offset $LN8_0
.text$mn:00009FFD                 retn
.text$mn:00009FFE ; ---------------------------------------------------------------------------
.text$mn:00009FFE ; START OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@_WV?$allocator@_W@std@@@std@@IAEXI@Z
.text$mn:00009FFE
.text$mn:00009FFE loc_9FFE:                               ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::_Reallocate(uint)+6Aj
.text$mn:00009FFE                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000A005                 jmp     short loc_A00E
.text$mn:0000A005 ; END OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@_WV?$allocator@_W@std@@@std@@IAEXI@Z
.text$mn:0000A007
.text$mn:0000A007 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A007
.text$mn:0000A007
.text$mn:0000A007 $LN8_0          proc near               ; DATA XREF: .text$mn:00009FF8o
.text$mn:0000A007                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:0000A007 $LN8_0          endp ; sp-analysis failed
.text$mn:0000A007
.text$mn:0000A00E ; START OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@_WV?$allocator@_W@std@@@std@@IAEXI@Z
.text$mn:0000A00E
.text$mn:0000A00E loc_A00E:                               ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::_Reallocate(uint)+9Dj
.text$mn:0000A00E                 mov     ecx, [ebp+var_18]
.text$mn:0000A011                 call    ?size@?$vector@_WV?$allocator@_W@std@@@std@@QBEIXZ ; std::vector<wchar_t,std::allocator<wchar_t>>::size(void)
.text$mn:0000A016                 mov     [ebp+var_20], eax
.text$mn:0000A019                 mov     ecx, [ebp+var_18]
.text$mn:0000A01C                 cmp     dword ptr [ecx+4], 0
.text$mn:0000A020                 jz      short loc_A061
.text$mn:0000A022                 mov     edx, [ebp+var_18]
.text$mn:0000A025                 mov     eax, [edx+8]
.text$mn:0000A028                 push    eax
.text$mn:0000A029                 mov     ecx, [ebp+var_18]
.text$mn:0000A02C                 mov     edx, [ecx+4]
.text$mn:0000A02F                 push    edx
.text$mn:0000A030                 mov     ecx, [ebp+var_18]
.text$mn:0000A033                 call    ?_Destroy@?$vector@_WV?$allocator@_W@std@@@std@@IAEXPA_W0@Z ; std::vector<wchar_t,std::allocator<wchar_t>>::_Destroy(wchar_t *,wchar_t *)
.text$mn:0000A038                 mov     eax, [ebp+var_18]
.text$mn:0000A03B                 mov     ecx, [ebp+var_18]
.text$mn:0000A03E                 mov     edx, [eax+0Ch]
.text$mn:0000A041                 sub     edx, [ecx+4]
.text$mn:0000A044                 sar     edx, 1
.text$mn:0000A046                 push    edx             ; int
.text$mn:0000A047                 mov     eax, [ebp+var_18]
.text$mn:0000A04A                 mov     ecx, [eax+4]
.text$mn:0000A04D                 push    ecx             ; void *
.text$mn:0000A04E                 lea     edx, [ebp+var_13]
.text$mn:0000A051                 push    edx
.text$mn:0000A052                 mov     ecx, [ebp+var_18]
.text$mn:0000A055                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:0000A05A                 mov     ecx, eax
.text$mn:0000A05C                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::deallocate(wchar_t *,uint)
.text$mn:0000A061
.text$mn:0000A061 loc_A061:                               ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::_Reallocate(uint)+B8j
.text$mn:0000A061                 mov     ecx, [ebp+var_18] ; this
.text$mn:0000A064                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:0000A069                 mov     eax, [ebp+arg_0]
.text$mn:0000A06C                 mov     ecx, [ebp+var_1C]
.text$mn:0000A06F                 lea     edx, [ecx+eax*2]
.text$mn:0000A072                 mov     eax, [ebp+var_18]
.text$mn:0000A075                 mov     [eax+0Ch], edx
.text$mn:0000A078                 mov     ecx, [ebp+var_20]
.text$mn:0000A07B                 mov     edx, [ebp+var_1C]
.text$mn:0000A07E                 lea     eax, [edx+ecx*2]
.text$mn:0000A081                 mov     ecx, [ebp+var_18]
.text$mn:0000A084                 mov     [ecx+8], eax
.text$mn:0000A087                 mov     edx, [ebp+var_18]
.text$mn:0000A08A                 mov     eax, [ebp+var_1C]
.text$mn:0000A08D                 mov     [edx+4], eax
.text$mn:0000A090                 mov     ecx, [ebp+var_C]
.text$mn:0000A093                 mov     large fs:0, ecx
.text$mn:0000A09A                 pop     ecx
.text$mn:0000A09B                 pop     edi
.text$mn:0000A09C                 pop     esi
.text$mn:0000A09D                 pop     ebx
.text$mn:0000A09E                 mov     esp, ebp
.text$mn:0000A0A0                 pop     ebp
.text$mn:0000A0A1                 retn    4
.text$mn:0000A0A1 ; END OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@_WV?$allocator@_W@std@@@std@@IAEXI@Z
.text$mn:0000A0A1 _text$mn        ends
.text$mn:0000A0A1
.text$x:0000A0A4 ; ===========================================================================
.text$x:0000A0A4
.text$x:0000A0A4 ; Segment type: Pure code
.text$x:0000A0A4 ; Segment permissions: Read/Execute
.text$x:0000A0A4 _text$x         segment para public 'CODE' use32
.text$x:0000A0A4                 assume cs:_text$x
.text$x:0000A0A4                 ;org 0A0A4h
.text$x:0000A0A4 ; COMDAT (pick associative to section at 9F68)
.text$x:0000A0A4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000A0A4
.text$x:0000A0A4 ; =============== S U B R O U T I N E =======================================
.text$x:0000A0A4
.text$x:0000A0A4
.text$x:0000A0A4 __ehhandler$?_Reallocate@?$vector@_WV?$allocator@_W@std@@@std@@IAEXI@Z proc near
.text$x:0000A0A4                                         ; DATA XREF: std::vector<wchar_t,std::allocator<wchar_t>>::_Reallocate(uint)+5o
.text$x:0000A0A4
.text$x:0000A0A4 arg_4           = dword ptr  8
.text$x:0000A0A4
.text$x:0000A0A4                 mov     edx, [esp+arg_4]
.text$x:0000A0A8                 lea     eax, [edx+0Ch]
.text$x:0000A0AB                 mov     ecx, [edx-24h]
.text$x:0000A0AE                 xor     ecx, eax
.text$x:0000A0B0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000A0B5                 mov     eax, offset __ehfuncinfo$?_Reallocate@?$vector@_WV?$allocator@_W@std@@@std@@IAEXI@Z
.text$x:0000A0BA                 jmp     ___CxxFrameHandler3
.text$x:0000A0BA __ehhandler$?_Reallocate@?$vector@_WV?$allocator@_W@std@@@std@@IAEXI@Z endp
.text$x:0000A0BA
.text$x:0000A0BA ; ---------------------------------------------------------------------------
.text$x:0000A0BF                 align 10h
.text$x:0000A0BF _text$x         ends
.text$x:0000A0BF
.text$mn:0000A0C0 ; ===========================================================================
.text$mn:0000A0C0
.text$mn:0000A0C0 ; Segment type: Pure code
.text$mn:0000A0C0 ; Segment permissions: Read/Execute
.text$mn:0000A0C0 _text$mn        segment para public 'CODE' use32
.text$mn:0000A0C0                 assume cs:_text$mn
.text$mn:0000A0C0                 ;org 0A0C0h
.text$mn:0000A0C0 ; COMDAT (pick any)
.text$mn:0000A0C0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A0C0
.text$mn:0000A0C0 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A0C0
.text$mn:0000A0C0 ; Attributes: bp-based frame
.text$mn:0000A0C0
.text$mn:0000A0C0 ; public: class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<int>>> & __thiscall std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<int>>>::_Rechecked(int *)
.text$mn:0000A0C0                 public ?_Rechecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAEAAV12@PAH@Z
.text$mn:0000A0C0 ?_Rechecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAEAAV12@PAH@Z proc near
.text$mn:0000A0C0                                         ; CODE XREF: std::_Rechecked<std::_Vector_val<std::_Simple_types<int>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>> &,int *)+Ap
.text$mn:0000A0C0
.text$mn:0000A0C0 var_4           = dword ptr -4
.text$mn:0000A0C0 arg_0           = dword ptr  8
.text$mn:0000A0C0
.text$mn:0000A0C0                 push    ebp
.text$mn:0000A0C1                 mov     ebp, esp
.text$mn:0000A0C3                 push    ecx
.text$mn:0000A0C4                 mov     [ebp+var_4], ecx
.text$mn:0000A0C7                 mov     eax, [ebp+var_4]
.text$mn:0000A0CA                 mov     ecx, [ebp+arg_0]
.text$mn:0000A0CD                 mov     [eax+8], ecx
.text$mn:0000A0D0                 mov     eax, [ebp+var_4]
.text$mn:0000A0D3                 mov     esp, ebp
.text$mn:0000A0D5                 pop     ebp
.text$mn:0000A0D6                 retn    4
.text$mn:0000A0D6 ?_Rechecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAEAAV12@PAH@Z endp
.text$mn:0000A0D6
.text$mn:0000A0D6 ; ---------------------------------------------------------------------------
.text$mn:0000A0D9                 align 4
.text$mn:0000A0D9 _text$mn        ends
.text$mn:0000A0D9
.text$mn:0000A0DC ; ===========================================================================
.text$mn:0000A0DC
.text$mn:0000A0DC ; Segment type: Pure code
.text$mn:0000A0DC ; Segment permissions: Read/Execute
.text$mn:0000A0DC _text$mn        segment para public 'CODE' use32
.text$mn:0000A0DC                 assume cs:_text$mn
.text$mn:0000A0DC                 ;org 0A0DCh
.text$mn:0000A0DC ; COMDAT (pick any)
.text$mn:0000A0DC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A0DC
.text$mn:0000A0DC ; =============== S U B R O U T I N E =======================================
.text$mn:0000A0DC
.text$mn:0000A0DC ; Attributes: bp-based frame
.text$mn:0000A0DC
.text$mn:0000A0DC ; protected: void __thiscall std::vector<int, class std::allocator<int>>::_Reserve(unsigned int)
.text$mn:0000A0DC                 public ?_Reserve@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z
.text$mn:0000A0DC ?_Reserve@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z proc near
.text$mn:0000A0DC                                         ; CODE XREF: std::vector<int,std::allocator<int>>::resize(uint)+83p
.text$mn:0000A0DC                                         ; std::vector<int,std::allocator<int>>::resize(uint,int const &)+B3p ...
.text$mn:0000A0DC
.text$mn:0000A0DC var_4           = dword ptr -4
.text$mn:0000A0DC arg_0           = dword ptr  8
.text$mn:0000A0DC
.text$mn:0000A0DC                 push    ebp
.text$mn:0000A0DD                 mov     ebp, esp
.text$mn:0000A0DF                 push    ecx
.text$mn:0000A0E0                 push    esi
.text$mn:0000A0E1                 mov     [ebp+var_4], ecx
.text$mn:0000A0E4                 mov     ecx, [ebp+var_4]
.text$mn:0000A0E7                 call    ?_Unused_capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int>>::_Unused_capacity(void)
.text$mn:0000A0EC                 cmp     eax, [ebp+arg_0]
.text$mn:0000A0EF                 jnb     short loc_A12F
.text$mn:0000A0F1                 mov     ecx, [ebp+var_4]
.text$mn:0000A0F4                 call    ?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int>>::max_size(void)
.text$mn:0000A0F9                 mov     esi, eax
.text$mn:0000A0FB                 mov     ecx, [ebp+var_4]
.text$mn:0000A0FE                 call    ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int>>::size(void)
.text$mn:0000A103                 sub     esi, eax
.text$mn:0000A105                 cmp     esi, [ebp+arg_0]
.text$mn:0000A108                 jnb     short loc_A112
.text$mn:0000A10A                 mov     ecx, [ebp+var_4]
.text$mn:0000A10D                 call    ?_Xlen@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ ; std::vector<int,std::allocator<int>>::_Xlen(void)
.text$mn:0000A112
.text$mn:0000A112 loc_A112:                               ; CODE XREF: std::vector<int,std::allocator<int>>::_Reserve(uint)+2Cj
.text$mn:0000A112                 mov     ecx, [ebp+var_4]
.text$mn:0000A115                 call    ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int>>::size(void)
.text$mn:0000A11A                 add     eax, [ebp+arg_0]
.text$mn:0000A11D                 push    eax
.text$mn:0000A11E                 mov     ecx, [ebp+var_4]
.text$mn:0000A121                 call    ?_Grow_to@?$vector@HV?$allocator@H@std@@@std@@IBEII@Z ; std::vector<int,std::allocator<int>>::_Grow_to(uint)
.text$mn:0000A126                 push    eax
.text$mn:0000A127                 mov     ecx, [ebp+var_4]
.text$mn:0000A12A                 call    ?_Reallocate@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z ; std::vector<int,std::allocator<int>>::_Reallocate(uint)
.text$mn:0000A12F
.text$mn:0000A12F loc_A12F:                               ; CODE XREF: std::vector<int,std::allocator<int>>::_Reserve(uint)+13j
.text$mn:0000A12F                 pop     esi
.text$mn:0000A130                 mov     esp, ebp
.text$mn:0000A132                 pop     ebp
.text$mn:0000A133                 retn    4
.text$mn:0000A133 ?_Reserve@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z endp
.text$mn:0000A133
.text$mn:0000A133 ; ---------------------------------------------------------------------------
.text$mn:0000A136                 align 4
.text$mn:0000A136 _text$mn        ends
.text$mn:0000A136
.text$mn:0000A138 ; ===========================================================================
.text$mn:0000A138
.text$mn:0000A138 ; Segment type: Pure code
.text$mn:0000A138 ; Segment permissions: Read/Execute
.text$mn:0000A138 _text$mn        segment para public 'CODE' use32
.text$mn:0000A138                 assume cs:_text$mn
.text$mn:0000A138                 ;org 0A138h
.text$mn:0000A138 ; COMDAT (pick any)
.text$mn:0000A138                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A138
.text$mn:0000A138 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A138
.text$mn:0000A138 ; Attributes: bp-based frame
.text$mn:0000A138
.text$mn:0000A138 ; protected: void __thiscall std::vector<wchar_t, class std::allocator<wchar_t>>::_Reserve(unsigned int)
.text$mn:0000A138                 public ?_Reserve@?$vector@_WV?$allocator@_W@std@@@std@@IAEXI@Z
.text$mn:0000A138 ?_Reserve@?$vector@_WV?$allocator@_W@std@@@std@@IAEXI@Z proc near
.text$mn:0000A138                                         ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::push_back(wchar_t &&)+53p
.text$mn:0000A138                                         ; std::vector<wchar_t,std::allocator<wchar_t>>::push_back(wchar_t &&)+C2p
.text$mn:0000A138
.text$mn:0000A138 var_4           = dword ptr -4
.text$mn:0000A138 arg_0           = dword ptr  8
.text$mn:0000A138
.text$mn:0000A138                 push    ebp
.text$mn:0000A139                 mov     ebp, esp
.text$mn:0000A13B                 push    ecx
.text$mn:0000A13C                 push    esi
.text$mn:0000A13D                 mov     [ebp+var_4], ecx
.text$mn:0000A140                 mov     ecx, [ebp+var_4]
.text$mn:0000A143                 call    ?_Unused_capacity@?$vector@_WV?$allocator@_W@std@@@std@@QBEIXZ ; std::vector<wchar_t,std::allocator<wchar_t>>::_Unused_capacity(void)
.text$mn:0000A148                 cmp     eax, [ebp+arg_0]
.text$mn:0000A14B                 jnb     short loc_A18B
.text$mn:0000A14D                 mov     ecx, [ebp+var_4]
.text$mn:0000A150                 call    ?max_size@?$vector@_WV?$allocator@_W@std@@@std@@QBEIXZ ; std::vector<wchar_t,std::allocator<wchar_t>>::max_size(void)
.text$mn:0000A155                 mov     esi, eax
.text$mn:0000A157                 mov     ecx, [ebp+var_4]
.text$mn:0000A15A                 call    ?size@?$vector@_WV?$allocator@_W@std@@@std@@QBEIXZ ; std::vector<wchar_t,std::allocator<wchar_t>>::size(void)
.text$mn:0000A15F                 sub     esi, eax
.text$mn:0000A161                 cmp     esi, [ebp+arg_0]
.text$mn:0000A164                 jnb     short loc_A16E
.text$mn:0000A166                 mov     ecx, [ebp+var_4]
.text$mn:0000A169                 call    ?_Xlen@?$vector@_WV?$allocator@_W@std@@@std@@IBEXXZ ; std::vector<wchar_t,std::allocator<wchar_t>>::_Xlen(void)
.text$mn:0000A16E
.text$mn:0000A16E loc_A16E:                               ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::_Reserve(uint)+2Cj
.text$mn:0000A16E                 mov     ecx, [ebp+var_4]
.text$mn:0000A171                 call    ?size@?$vector@_WV?$allocator@_W@std@@@std@@QBEIXZ ; std::vector<wchar_t,std::allocator<wchar_t>>::size(void)
.text$mn:0000A176                 add     eax, [ebp+arg_0]
.text$mn:0000A179                 push    eax
.text$mn:0000A17A                 mov     ecx, [ebp+var_4]
.text$mn:0000A17D                 call    ?_Grow_to@?$vector@_WV?$allocator@_W@std@@@std@@IBEII@Z ; std::vector<wchar_t,std::allocator<wchar_t>>::_Grow_to(uint)
.text$mn:0000A182                 push    eax
.text$mn:0000A183                 mov     ecx, [ebp+var_4]
.text$mn:0000A186                 call    ?_Reallocate@?$vector@_WV?$allocator@_W@std@@@std@@IAEXI@Z ; std::vector<wchar_t,std::allocator<wchar_t>>::_Reallocate(uint)
.text$mn:0000A18B
.text$mn:0000A18B loc_A18B:                               ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::_Reserve(uint)+13j
.text$mn:0000A18B                 pop     esi
.text$mn:0000A18C                 mov     esp, ebp
.text$mn:0000A18E                 pop     ebp
.text$mn:0000A18F                 retn    4
.text$mn:0000A18F ?_Reserve@?$vector@_WV?$allocator@_W@std@@@std@@IAEXI@Z endp
.text$mn:0000A18F
.text$mn:0000A18F ; ---------------------------------------------------------------------------
.text$mn:0000A192                 align 4
.text$mn:0000A192 _text$mn        ends
.text$mn:0000A192
.text$mn:0000A194 ; ===========================================================================
.text$mn:0000A194
.text$mn:0000A194 ; Segment type: Pure code
.text$mn:0000A194 ; Segment permissions: Read/Execute
.text$mn:0000A194 _text$mn        segment para public 'CODE' use32
.text$mn:0000A194                 assume cs:_text$mn
.text$mn:0000A194                 ;org 0A194h
.text$mn:0000A194 ; COMDAT (pick any)
.text$mn:0000A194                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A194
.text$mn:0000A194 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A194
.text$mn:0000A194 ; Attributes: bp-based frame
.text$mn:0000A194
.text$mn:0000A194 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(char, size_t Size)
.text$mn:0000A194                 public ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
.text$mn:0000A194 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z proc near
.text$mn:0000A194                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+47p
.text$mn:0000A194                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+34p ...
.text$mn:0000A194
.text$mn:0000A194 var_C           = dword ptr -0Ch
.text$mn:0000A194 var_8           = dword ptr -8
.text$mn:0000A194 var_2           = byte ptr -2
.text$mn:0000A194 var_1           = byte ptr -1
.text$mn:0000A194 arg_0           = byte ptr  8
.text$mn:0000A194 Size            = dword ptr  0Ch
.text$mn:0000A194
.text$mn:0000A194                 push    ebp
.text$mn:0000A195                 mov     ebp, esp
.text$mn:0000A197                 sub     esp, 0Ch
.text$mn:0000A19A                 mov     [ebp+var_8], ecx
.text$mn:0000A19D                 movzx   eax, [ebp+arg_0]
.text$mn:0000A1A1                 test    eax, eax
.text$mn:0000A1A3                 jnz     short loc_A1A7
.text$mn:0000A1A5                 jmp     short loc_A21A
.text$mn:0000A1A7 ; ---------------------------------------------------------------------------
.text$mn:0000A1A7
.text$mn:0000A1A7 loc_A1A7:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+Fj
.text$mn:0000A1A7                 mov     ecx, [ebp+var_8]
.text$mn:0000A1AA                 cmp     dword ptr [ecx+18h], 10h
.text$mn:0000A1AE                 jb      short loc_A21A
.text$mn:0000A1B0                 mov     edx, [ebp+var_8]
.text$mn:0000A1B3                 mov     eax, [edx+4]
.text$mn:0000A1B6                 mov     [ebp+var_C], eax
.text$mn:0000A1B9                 mov     ecx, [ebp+var_8]
.text$mn:0000A1BC                 add     ecx, 4
.text$mn:0000A1BF                 push    ecx
.text$mn:0000A1C0                 lea     edx, [ebp+var_1]
.text$mn:0000A1C3                 push    edx
.text$mn:0000A1C4                 mov     ecx, [ebp+var_8]
.text$mn:0000A1C7                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:0000A1CC                 mov     ecx, eax
.text$mn:0000A1CE                 call    ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)
.text$mn:0000A1D3                 cmp     [ebp+Size], 0
.text$mn:0000A1D7                 jbe     short loc_A1F9
.text$mn:0000A1D9                 mov     eax, [ebp+Size]
.text$mn:0000A1DC                 push    eax             ; Size
.text$mn:0000A1DD                 mov     ecx, [ebp+var_C]
.text$mn:0000A1E0                 push    ecx
.text$mn:0000A1E1                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:0000A1E6                 add     esp, 4
.text$mn:0000A1E9                 push    eax             ; Src
.text$mn:0000A1EA                 mov     edx, [ebp+var_8]
.text$mn:0000A1ED                 add     edx, 4
.text$mn:0000A1F0                 push    edx             ; Dst
.text$mn:0000A1F1                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:0000A1F6                 add     esp, 0Ch
.text$mn:0000A1F9
.text$mn:0000A1F9 loc_A1F9:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+43j
.text$mn:0000A1F9                 mov     eax, [ebp+var_8]
.text$mn:0000A1FC                 mov     ecx, [eax+18h]
.text$mn:0000A1FF                 add     ecx, 1
.text$mn:0000A202                 push    ecx             ; int
.text$mn:0000A203                 mov     edx, [ebp+var_C]
.text$mn:0000A206                 push    edx             ; void *
.text$mn:0000A207                 lea     eax, [ebp+var_2]
.text$mn:0000A20A                 push    eax
.text$mn:0000A20B                 mov     ecx, [ebp+var_8]
.text$mn:0000A20E                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:0000A213                 mov     ecx, eax
.text$mn:0000A215                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)
.text$mn:0000A21A
.text$mn:0000A21A loc_A21A:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+11j
.text$mn:0000A21A                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+1Aj
.text$mn:0000A21A                 mov     ecx, [ebp+var_8]
.text$mn:0000A21D                 mov     dword ptr [ecx+18h], 0Fh
.text$mn:0000A224                 mov     edx, [ebp+Size]
.text$mn:0000A227                 push    edx
.text$mn:0000A228                 mov     ecx, [ebp+var_8]
.text$mn:0000A22B                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:0000A230                 mov     esp, ebp
.text$mn:0000A232                 pop     ebp
.text$mn:0000A233                 retn    8
.text$mn:0000A233 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z endp
.text$mn:0000A233
.text$mn:0000A233 ; ---------------------------------------------------------------------------
.text$mn:0000A236                 align 4
.text$mn:0000A236 _text$mn        ends
.text$mn:0000A236
.text$mn:0000A238 ; ===========================================================================
.text$mn:0000A238
.text$mn:0000A238 ; Segment type: Pure code
.text$mn:0000A238 ; Segment permissions: Read/Execute
.text$mn:0000A238 _text$mn        segment para public 'CODE' use32
.text$mn:0000A238                 assume cs:_text$mn
.text$mn:0000A238                 ;org 0A238h
.text$mn:0000A238 ; COMDAT (pick any)
.text$mn:0000A238                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A238
.text$mn:0000A238 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A238
.text$mn:0000A238 ; Attributes: bp-based frame
.text$mn:0000A238
.text$mn:0000A238 ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Tidy(bool, unsigned int)
.text$mn:0000A238                 public ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z
.text$mn:0000A238 ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z proc near
.text$mn:0000A238                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)+47p
.text$mn:0000A238                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)+34p ...
.text$mn:0000A238
.text$mn:0000A238 var_C           = dword ptr -0Ch
.text$mn:0000A238 var_8           = dword ptr -8
.text$mn:0000A238 var_2           = byte ptr -2
.text$mn:0000A238 var_1           = byte ptr -1
.text$mn:0000A238 arg_0           = byte ptr  8
.text$mn:0000A238 arg_4           = dword ptr  0Ch
.text$mn:0000A238
.text$mn:0000A238                 push    ebp
.text$mn:0000A239                 mov     ebp, esp
.text$mn:0000A23B                 sub     esp, 0Ch
.text$mn:0000A23E                 mov     [ebp+var_8], ecx
.text$mn:0000A241                 movzx   eax, [ebp+arg_0]
.text$mn:0000A245                 test    eax, eax
.text$mn:0000A247                 jnz     short loc_A24B
.text$mn:0000A249                 jmp     short loc_A2BE
.text$mn:0000A24B ; ---------------------------------------------------------------------------
.text$mn:0000A24B
.text$mn:0000A24B loc_A24B:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+Fj
.text$mn:0000A24B                 mov     ecx, [ebp+var_8]
.text$mn:0000A24E                 cmp     dword ptr [ecx+18h], 8
.text$mn:0000A252                 jb      short loc_A2BE
.text$mn:0000A254                 mov     edx, [ebp+var_8]
.text$mn:0000A257                 mov     eax, [edx+4]
.text$mn:0000A25A                 mov     [ebp+var_C], eax
.text$mn:0000A25D                 mov     ecx, [ebp+var_8]
.text$mn:0000A260                 add     ecx, 4
.text$mn:0000A263                 push    ecx
.text$mn:0000A264                 lea     edx, [ebp+var_1]
.text$mn:0000A267                 push    edx
.text$mn:0000A268                 mov     ecx, [ebp+var_8]
.text$mn:0000A26B                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:0000A270                 mov     ecx, eax
.text$mn:0000A272                 call    ??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::destroy<wchar_t *>(wchar_t * *)
.text$mn:0000A277                 cmp     [ebp+arg_4], 0
.text$mn:0000A27B                 jbe     short loc_A29D
.text$mn:0000A27D                 mov     eax, [ebp+arg_4]
.text$mn:0000A280                 push    eax             ; int
.text$mn:0000A281                 mov     ecx, [ebp+var_C]
.text$mn:0000A284                 push    ecx
.text$mn:0000A285                 call    ??$addressof@_W@std@@YAPA_WAA_W@Z ; std::addressof<wchar_t>(wchar_t &)
.text$mn:0000A28A                 add     esp, 4
.text$mn:0000A28D                 push    eax             ; Src
.text$mn:0000A28E                 mov     edx, [ebp+var_8]
.text$mn:0000A291                 add     edx, 4
.text$mn:0000A294                 push    edx             ; Dst
.text$mn:0000A295                 call    ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)
.text$mn:0000A29A                 add     esp, 0Ch
.text$mn:0000A29D
.text$mn:0000A29D loc_A29D:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+43j
.text$mn:0000A29D                 mov     eax, [ebp+var_8]
.text$mn:0000A2A0                 mov     ecx, [eax+18h]
.text$mn:0000A2A3                 add     ecx, 1
.text$mn:0000A2A6                 push    ecx             ; int
.text$mn:0000A2A7                 mov     edx, [ebp+var_C]
.text$mn:0000A2AA                 push    edx             ; void *
.text$mn:0000A2AB                 lea     eax, [ebp+var_2]
.text$mn:0000A2AE                 push    eax
.text$mn:0000A2AF                 mov     ecx, [ebp+var_8]
.text$mn:0000A2B2                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:0000A2B7                 mov     ecx, eax
.text$mn:0000A2B9                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::deallocate(wchar_t *,uint)
.text$mn:0000A2BE
.text$mn:0000A2BE loc_A2BE:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+11j
.text$mn:0000A2BE                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+1Aj
.text$mn:0000A2BE                 mov     ecx, [ebp+var_8]
.text$mn:0000A2C1                 mov     dword ptr [ecx+18h], 7
.text$mn:0000A2C8                 mov     edx, [ebp+arg_4]
.text$mn:0000A2CB                 push    edx
.text$mn:0000A2CC                 mov     ecx, [ebp+var_8]
.text$mn:0000A2CF                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:0000A2D4                 mov     esp, ebp
.text$mn:0000A2D6                 pop     ebp
.text$mn:0000A2D7                 retn    8
.text$mn:0000A2D7 ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z endp
.text$mn:0000A2D7
.text$mn:0000A2D7 ; ---------------------------------------------------------------------------
.text$mn:0000A2DA                 align 4
.text$mn:0000A2DA _text$mn        ends
.text$mn:0000A2DA
.text$mn:0000A2DC ; ===========================================================================
.text$mn:0000A2DC
.text$mn:0000A2DC ; Segment type: Pure code
.text$mn:0000A2DC ; Segment permissions: Read/Execute
.text$mn:0000A2DC _text$mn        segment para public 'CODE' use32
.text$mn:0000A2DC                 assume cs:_text$mn
.text$mn:0000A2DC                 ;org 0A2DCh
.text$mn:0000A2DC ; COMDAT (pick any)
.text$mn:0000A2DC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A2DC
.text$mn:0000A2DC ; =============== S U B R O U T I N E =======================================
.text$mn:0000A2DC
.text$mn:0000A2DC ; Attributes: bp-based frame
.text$mn:0000A2DC
.text$mn:0000A2DC ; protected: void __thiscall std::vector<int, class std::allocator<int>>::_Tidy(void)
.text$mn:0000A2DC                 public ?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ
.text$mn:0000A2DC ?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ proc near
.text$mn:0000A2DC                                         ; CODE XREF: std::vector<int,std::allocator<int>>::~vector<int,std::allocator<int>>(void)+30p
.text$mn:0000A2DC                                         ; __catch$?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z$0+3p ...
.text$mn:0000A2DC
.text$mn:0000A2DC var_8           = dword ptr -8
.text$mn:0000A2DC var_1           = byte ptr -1
.text$mn:0000A2DC
.text$mn:0000A2DC                 push    ebp
.text$mn:0000A2DD                 mov     ebp, esp
.text$mn:0000A2DF                 sub     esp, 8
.text$mn:0000A2E2                 mov     [ebp+var_8], ecx
.text$mn:0000A2E5                 mov     eax, [ebp+var_8]
.text$mn:0000A2E8                 cmp     dword ptr [eax+4], 0
.text$mn:0000A2EC                 jz      short loc_A354
.text$mn:0000A2EE                 mov     ecx, [ebp+var_8] ; this
.text$mn:0000A2F1                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:0000A2F6                 mov     ecx, [ebp+var_8]
.text$mn:0000A2F9                 mov     edx, [ecx+8]
.text$mn:0000A2FC                 push    edx
.text$mn:0000A2FD                 mov     eax, [ebp+var_8]
.text$mn:0000A300                 mov     ecx, [eax+4]
.text$mn:0000A303                 push    ecx
.text$mn:0000A304                 mov     ecx, [ebp+var_8]
.text$mn:0000A307                 call    ?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z ; std::vector<int,std::allocator<int>>::_Destroy(int *,int *)
.text$mn:0000A30C                 mov     edx, [ebp+var_8]
.text$mn:0000A30F                 mov     eax, [ebp+var_8]
.text$mn:0000A312                 mov     ecx, [edx+0Ch]
.text$mn:0000A315                 sub     ecx, [eax+4]
.text$mn:0000A318                 sar     ecx, 2
.text$mn:0000A31B                 push    ecx             ; int
.text$mn:0000A31C                 mov     edx, [ebp+var_8]
.text$mn:0000A31F                 mov     eax, [edx+4]
.text$mn:0000A322                 push    eax             ; void *
.text$mn:0000A323                 lea     ecx, [ebp+var_1]
.text$mn:0000A326                 push    ecx
.text$mn:0000A327                 mov     ecx, [ebp+var_8]
.text$mn:0000A32A                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@H@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>::_Getal(void)
.text$mn:0000A32F                 mov     ecx, eax
.text$mn:0000A331                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAEXPAHI@Z ; std::_Wrap_alloc<std::allocator<int>>::deallocate(int *,uint)
.text$mn:0000A336                 mov     edx, [ebp+var_8]
.text$mn:0000A339                 mov     dword ptr [edx+4], 0
.text$mn:0000A340                 mov     eax, [ebp+var_8]
.text$mn:0000A343                 mov     dword ptr [eax+8], 0
.text$mn:0000A34A                 mov     ecx, [ebp+var_8]
.text$mn:0000A34D                 mov     dword ptr [ecx+0Ch], 0
.text$mn:0000A354
.text$mn:0000A354 loc_A354:                               ; CODE XREF: std::vector<int,std::allocator<int>>::_Tidy(void)+10j
.text$mn:0000A354                 mov     esp, ebp
.text$mn:0000A356                 pop     ebp
.text$mn:0000A357                 retn
.text$mn:0000A357 ?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ endp
.text$mn:0000A357
.text$mn:0000A357 _text$mn        ends
.text$mn:0000A357
.text$mn:0000A358 ; ===========================================================================
.text$mn:0000A358
.text$mn:0000A358 ; Segment type: Pure code
.text$mn:0000A358 ; Segment permissions: Read/Execute
.text$mn:0000A358 _text$mn        segment para public 'CODE' use32
.text$mn:0000A358                 assume cs:_text$mn
.text$mn:0000A358                 ;org 0A358h
.text$mn:0000A358 ; COMDAT (pick any)
.text$mn:0000A358                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A358
.text$mn:0000A358 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A358
.text$mn:0000A358 ; Attributes: bp-based frame
.text$mn:0000A358
.text$mn:0000A358 ; protected: void __thiscall std::vector<wchar_t, class std::allocator<wchar_t>>::_Tidy(void)
.text$mn:0000A358                 public ?_Tidy@?$vector@_WV?$allocator@_W@std@@@std@@IAEXXZ
.text$mn:0000A358 ?_Tidy@?$vector@_WV?$allocator@_W@std@@@std@@IAEXXZ proc near
.text$mn:0000A358                                         ; CODE XREF: __catch$??$_Construct@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$vector@_WV?$allocator@_W@std@@@std@@QAEXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0Uforward_iterator_tag@1@@Z$0+3p
.text$mn:0000A358                                         ; std::vector<wchar_t,std::allocator<wchar_t>>::~vector<wchar_t,std::allocator<wchar_t>>(void)+30p
.text$mn:0000A358
.text$mn:0000A358 var_8           = dword ptr -8
.text$mn:0000A358 var_1           = byte ptr -1
.text$mn:0000A358
.text$mn:0000A358                 push    ebp
.text$mn:0000A359                 mov     ebp, esp
.text$mn:0000A35B                 sub     esp, 8
.text$mn:0000A35E                 mov     [ebp+var_8], ecx
.text$mn:0000A361                 mov     eax, [ebp+var_8]
.text$mn:0000A364                 cmp     dword ptr [eax+4], 0
.text$mn:0000A368                 jz      short loc_A3CF
.text$mn:0000A36A                 mov     ecx, [ebp+var_8] ; this
.text$mn:0000A36D                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:0000A372                 mov     ecx, [ebp+var_8]
.text$mn:0000A375                 mov     edx, [ecx+8]
.text$mn:0000A378                 push    edx
.text$mn:0000A379                 mov     eax, [ebp+var_8]
.text$mn:0000A37C                 mov     ecx, [eax+4]
.text$mn:0000A37F                 push    ecx
.text$mn:0000A380                 mov     ecx, [ebp+var_8]
.text$mn:0000A383                 call    ?_Destroy@?$vector@_WV?$allocator@_W@std@@@std@@IAEXPA_W0@Z ; std::vector<wchar_t,std::allocator<wchar_t>>::_Destroy(wchar_t *,wchar_t *)
.text$mn:0000A388                 mov     edx, [ebp+var_8]
.text$mn:0000A38B                 mov     eax, [ebp+var_8]
.text$mn:0000A38E                 mov     ecx, [edx+0Ch]
.text$mn:0000A391                 sub     ecx, [eax+4]
.text$mn:0000A394                 sar     ecx, 1
.text$mn:0000A396                 push    ecx             ; int
.text$mn:0000A397                 mov     edx, [ebp+var_8]
.text$mn:0000A39A                 mov     eax, [edx+4]
.text$mn:0000A39D                 push    eax             ; void *
.text$mn:0000A39E                 lea     ecx, [ebp+var_1]
.text$mn:0000A3A1                 push    ecx
.text$mn:0000A3A2                 mov     ecx, [ebp+var_8]
.text$mn:0000A3A5                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:0000A3AA                 mov     ecx, eax
.text$mn:0000A3AC                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::deallocate(wchar_t *,uint)
.text$mn:0000A3B1                 mov     edx, [ebp+var_8]
.text$mn:0000A3B4                 mov     dword ptr [edx+4], 0
.text$mn:0000A3BB                 mov     eax, [ebp+var_8]
.text$mn:0000A3BE                 mov     dword ptr [eax+8], 0
.text$mn:0000A3C5                 mov     ecx, [ebp+var_8]
.text$mn:0000A3C8                 mov     dword ptr [ecx+0Ch], 0
.text$mn:0000A3CF
.text$mn:0000A3CF loc_A3CF:                               ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::_Tidy(void)+10j
.text$mn:0000A3CF                 mov     esp, ebp
.text$mn:0000A3D1                 pop     ebp
.text$mn:0000A3D2                 retn
.text$mn:0000A3D2 ?_Tidy@?$vector@_WV?$allocator@_W@std@@@std@@IAEXXZ endp
.text$mn:0000A3D2
.text$mn:0000A3D2 ; ---------------------------------------------------------------------------
.text$mn:0000A3D3                 align 4
.text$mn:0000A3D3 _text$mn        ends
.text$mn:0000A3D3
.text$mn:0000A3D4 ; ===========================================================================
.text$mn:0000A3D4
.text$mn:0000A3D4 ; Segment type: Pure code
.text$mn:0000A3D4 ; Segment permissions: Read/Execute
.text$mn:0000A3D4 _text$mn        segment para public 'CODE' use32
.text$mn:0000A3D4                 assume cs:_text$mn
.text$mn:0000A3D4                 ;org 0A3D4h
.text$mn:0000A3D4 ; COMDAT (pick any)
.text$mn:0000A3D4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A3D4
.text$mn:0000A3D4 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A3D4
.text$mn:0000A3D4 ; Attributes: bp-based frame
.text$mn:0000A3D4
.text$mn:0000A3D4 ; protected: int * __thiscall std::vector<int, class std::allocator<int>>::_Ufill(int *, unsigned int, int const *)
.text$mn:0000A3D4                 public ?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIPBH@Z
.text$mn:0000A3D4 ?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIPBH@Z proc near
.text$mn:0000A3D4                                         ; CODE XREF: std::vector<int,std::allocator<int>>::resize(uint,int const &)+10Bp
.text$mn:0000A3D4
.text$mn:0000A3D4 var_8           = dword ptr -8
.text$mn:0000A3D4 var_1           = byte ptr -1
.text$mn:0000A3D4 arg_0           = dword ptr  8
.text$mn:0000A3D4 arg_4           = dword ptr  0Ch
.text$mn:0000A3D4 arg_8           = dword ptr  10h
.text$mn:0000A3D4
.text$mn:0000A3D4                 push    ebp
.text$mn:0000A3D5                 mov     ebp, esp
.text$mn:0000A3D7                 sub     esp, 8
.text$mn:0000A3DA                 mov     [ebp+var_8], ecx
.text$mn:0000A3DD                 lea     eax, [ebp+var_1]
.text$mn:0000A3E0                 push    eax
.text$mn:0000A3E1                 mov     ecx, [ebp+var_8]
.text$mn:0000A3E4                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@H@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>::_Getal(void)
.text$mn:0000A3E9                 lea     ecx, [ebp+var_1]
.text$mn:0000A3EC                 push    ecx
.text$mn:0000A3ED                 mov     edx, [ebp+arg_8]
.text$mn:0000A3F0                 push    edx
.text$mn:0000A3F1                 mov     eax, [ebp+arg_4]
.text$mn:0000A3F4                 push    eax
.text$mn:0000A3F5                 mov     ecx, [ebp+arg_0]
.text$mn:0000A3F8                 push    ecx
.text$mn:0000A3F9                 call    ??$_Uninitialized_fill_n@PAHIHU?$_Wrap_alloc@V?$allocator@H@std@@@std@@@std@@YAXPAHIPBHAAU?$_Wrap_alloc@V?$allocator@H@std@@@0@@Z ; std::_Uninitialized_fill_n<int *,uint,int,std::_Wrap_alloc<std::allocator<int>>>(int *,uint,int const *,std::_Wrap_alloc<std::allocator<int>> &)
.text$mn:0000A3FE                 add     esp, 10h
.text$mn:0000A401                 mov     edx, [ebp+arg_4]
.text$mn:0000A404                 mov     eax, [ebp+arg_0]
.text$mn:0000A407                 lea     eax, [eax+edx*4]
.text$mn:0000A40A                 mov     esp, ebp
.text$mn:0000A40C                 pop     ebp
.text$mn:0000A40D                 retn    0Ch
.text$mn:0000A40D ?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIPBH@Z endp
.text$mn:0000A40D
.text$mn:0000A40D _text$mn        ends
.text$mn:0000A40D
.text$mn:0000A410 ; ===========================================================================
.text$mn:0000A410
.text$mn:0000A410 ; Segment type: Pure code
.text$mn:0000A410 ; Segment permissions: Read/Execute
.text$mn:0000A410 _text$mn        segment para public 'CODE' use32
.text$mn:0000A410                 assume cs:_text$mn
.text$mn:0000A410                 ;org 0A410h
.text$mn:0000A410 ; COMDAT (pick any)
.text$mn:0000A410                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A410
.text$mn:0000A410 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A410
.text$mn:0000A410 ; Attributes: bp-based frame
.text$mn:0000A410
.text$mn:0000A410 ; public: wchar_t * __thiscall std::_String_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>>::_Unchecked(void)const
.text$mn:0000A410                 public ?_Unchecked@?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEPA_WXZ
.text$mn:0000A410 ?_Unchecked@?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEPA_WXZ proc near
.text$mn:0000A410                                         ; CODE XREF: std::_Unchecked<std::_String_val<std::_Simple_types<wchar_t>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)+2Dp
.text$mn:0000A410
.text$mn:0000A410 var_4           = dword ptr -4
.text$mn:0000A410
.text$mn:0000A410                 push    ebp
.text$mn:0000A411                 mov     ebp, esp
.text$mn:0000A413                 push    ecx
.text$mn:0000A414                 mov     [ebp+var_4], ecx
.text$mn:0000A417                 mov     eax, [ebp+var_4]
.text$mn:0000A41A                 mov     eax, [eax+8]
.text$mn:0000A41D                 mov     esp, ebp
.text$mn:0000A41F                 pop     ebp
.text$mn:0000A420                 retn
.text$mn:0000A420 ?_Unchecked@?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEPA_WXZ endp
.text$mn:0000A420
.text$mn:0000A420 ; ---------------------------------------------------------------------------
.text$mn:0000A421                 align 4
.text$mn:0000A421 _text$mn        ends
.text$mn:0000A421
.text$mn:0000A424 ; ===========================================================================
.text$mn:0000A424
.text$mn:0000A424 ; Segment type: Pure code
.text$mn:0000A424 ; Segment permissions: Read/Execute
.text$mn:0000A424 _text$mn        segment para public 'CODE' use32
.text$mn:0000A424                 assume cs:_text$mn
.text$mn:0000A424                 ;org 0A424h
.text$mn:0000A424 ; COMDAT (pick any)
.text$mn:0000A424                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A424
.text$mn:0000A424 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A424
.text$mn:0000A424 ; Attributes: bp-based frame
.text$mn:0000A424
.text$mn:0000A424 ; public: int * __thiscall std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<int>>>::_Unchecked(void)const
.text$mn:0000A424                 public ?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBEPAHXZ
.text$mn:0000A424 ?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBEPAHXZ proc near
.text$mn:0000A424                                         ; CODE XREF: std::_Unchecked<std::_Vector_val<std::_Simple_types<int>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>)+2Dp
.text$mn:0000A424
.text$mn:0000A424 var_4           = dword ptr -4
.text$mn:0000A424
.text$mn:0000A424                 push    ebp
.text$mn:0000A425                 mov     ebp, esp
.text$mn:0000A427                 push    ecx
.text$mn:0000A428                 mov     [ebp+var_4], ecx
.text$mn:0000A42B                 mov     eax, [ebp+var_4]
.text$mn:0000A42E                 mov     eax, [eax+8]
.text$mn:0000A431                 mov     esp, ebp
.text$mn:0000A433                 pop     ebp
.text$mn:0000A434                 retn
.text$mn:0000A434 ?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBEPAHXZ endp
.text$mn:0000A434
.text$mn:0000A434 ; ---------------------------------------------------------------------------
.text$mn:0000A435                 align 4
.text$mn:0000A435 _text$mn        ends
.text$mn:0000A435
.text$mn:0000A438 ; ===========================================================================
.text$mn:0000A438
.text$mn:0000A438 ; Segment type: Pure code
.text$mn:0000A438 ; Segment permissions: Read/Execute
.text$mn:0000A438 _text$mn        segment para public 'CODE' use32
.text$mn:0000A438                 assume cs:_text$mn
.text$mn:0000A438                 ;org 0A438h
.text$mn:0000A438 ; COMDAT (pick any)
.text$mn:0000A438                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A438
.text$mn:0000A438 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A438
.text$mn:0000A438 ; Attributes: bp-based frame
.text$mn:0000A438
.text$mn:0000A438 ; public: unsigned int __thiscall std::vector<int, class std::allocator<int>>::_Unused_capacity(void)const
.text$mn:0000A438                 public ?_Unused_capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
.text$mn:0000A438 ?_Unused_capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ proc near
.text$mn:0000A438                                         ; CODE XREF: std::vector<int,std::allocator<int>>::_Reserve(uint)+Bp
.text$mn:0000A438
.text$mn:0000A438 var_4           = dword ptr -4
.text$mn:0000A438
.text$mn:0000A438                 push    ebp
.text$mn:0000A439                 mov     ebp, esp
.text$mn:0000A43B                 push    ecx
.text$mn:0000A43C                 mov     [ebp+var_4], ecx
.text$mn:0000A43F                 mov     eax, [ebp+var_4]
.text$mn:0000A442                 mov     ecx, [ebp+var_4]
.text$mn:0000A445                 mov     eax, [eax+0Ch]
.text$mn:0000A448                 sub     eax, [ecx+8]
.text$mn:0000A44B                 sar     eax, 2
.text$mn:0000A44E                 mov     esp, ebp
.text$mn:0000A450                 pop     ebp
.text$mn:0000A451                 retn
.text$mn:0000A451 ?_Unused_capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ endp
.text$mn:0000A451
.text$mn:0000A451 ; ---------------------------------------------------------------------------
.text$mn:0000A452                 align 4
.text$mn:0000A452 _text$mn        ends
.text$mn:0000A452
.text$mn:0000A454 ; ===========================================================================
.text$mn:0000A454
.text$mn:0000A454 ; Segment type: Pure code
.text$mn:0000A454 ; Segment permissions: Read/Execute
.text$mn:0000A454 _text$mn        segment para public 'CODE' use32
.text$mn:0000A454                 assume cs:_text$mn
.text$mn:0000A454                 ;org 0A454h
.text$mn:0000A454 ; COMDAT (pick any)
.text$mn:0000A454                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A454
.text$mn:0000A454 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A454
.text$mn:0000A454 ; Attributes: bp-based frame
.text$mn:0000A454
.text$mn:0000A454 ; public: unsigned int __thiscall std::vector<wchar_t, class std::allocator<wchar_t>>::_Unused_capacity(void)const
.text$mn:0000A454                 public ?_Unused_capacity@?$vector@_WV?$allocator@_W@std@@@std@@QBEIXZ
.text$mn:0000A454 ?_Unused_capacity@?$vector@_WV?$allocator@_W@std@@@std@@QBEIXZ proc near
.text$mn:0000A454                                         ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::_Reserve(uint)+Bp
.text$mn:0000A454
.text$mn:0000A454 var_4           = dword ptr -4
.text$mn:0000A454
.text$mn:0000A454                 push    ebp
.text$mn:0000A455                 mov     ebp, esp
.text$mn:0000A457                 push    ecx
.text$mn:0000A458                 mov     [ebp+var_4], ecx
.text$mn:0000A45B                 mov     eax, [ebp+var_4]
.text$mn:0000A45E                 mov     ecx, [ebp+var_4]
.text$mn:0000A461                 mov     eax, [eax+0Ch]
.text$mn:0000A464                 sub     eax, [ecx+8]
.text$mn:0000A467                 sar     eax, 1
.text$mn:0000A469                 mov     esp, ebp
.text$mn:0000A46B                 pop     ebp
.text$mn:0000A46C                 retn
.text$mn:0000A46C ?_Unused_capacity@?$vector@_WV?$allocator@_W@std@@@std@@QBEIXZ endp
.text$mn:0000A46C
.text$mn:0000A46C ; ---------------------------------------------------------------------------
.text$mn:0000A46D                 align 10h
.text$mn:0000A46D _text$mn        ends
.text$mn:0000A46D
.text$mn:0000A470 ; ===========================================================================
.text$mn:0000A470
.text$mn:0000A470 ; Segment type: Pure code
.text$mn:0000A470 ; Segment permissions: Read/Execute
.text$mn:0000A470 _text$mn        segment para public 'CODE' use32
.text$mn:0000A470                 assume cs:_text$mn
.text$mn:0000A470                 ;org 0A470h
.text$mn:0000A470 ; COMDAT (pick any)
.text$mn:0000A470                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A470
.text$mn:0000A470 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A470
.text$mn:0000A470 ; Attributes: bp-based frame
.text$mn:0000A470
.text$mn:0000A470 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xlen(void)const
.text$mn:0000A470                 public ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
.text$mn:0000A470 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc near
.text$mn:0000A470                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+19p
.text$mn:0000A470
.text$mn:0000A470 var_4           = dword ptr -4
.text$mn:0000A470
.text$mn:0000A470                 push    ebp
.text$mn:0000A471                 mov     ebp, esp
.text$mn:0000A473                 push    ecx
.text$mn:0000A474                 mov     [ebp+var_4], ecx
.text$mn:0000A477                 push    offset ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ ; "string too long"
.text$mn:0000A47C                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:0000A481                 mov     esp, ebp
.text$mn:0000A483                 pop     ebp
.text$mn:0000A484                 retn
.text$mn:0000A484 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp
.text$mn:0000A484
.text$mn:0000A484 ; ---------------------------------------------------------------------------
.text$mn:0000A485                 align 4
.text$mn:0000A485 _text$mn        ends
.text$mn:0000A485
.text$mn:0000A488 ; ===========================================================================
.text$mn:0000A488
.text$mn:0000A488 ; Segment type: Pure code
.text$mn:0000A488 ; Segment permissions: Read/Execute
.text$mn:0000A488 _text$mn        segment para public 'CODE' use32
.text$mn:0000A488                 assume cs:_text$mn
.text$mn:0000A488                 ;org 0A488h
.text$mn:0000A488 ; COMDAT (pick any)
.text$mn:0000A488                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A488
.text$mn:0000A488 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A488
.text$mn:0000A488 ; Attributes: bp-based frame
.text$mn:0000A488
.text$mn:0000A488 ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Xlen(void)const
.text$mn:0000A488                 public ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ
.text$mn:0000A488 ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ proc near
.text$mn:0000A488                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+19p
.text$mn:0000A488                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+4Dp ...
.text$mn:0000A488
.text$mn:0000A488 var_4           = dword ptr -4
.text$mn:0000A488
.text$mn:0000A488                 push    ebp
.text$mn:0000A489                 mov     ebp, esp
.text$mn:0000A48B                 push    ecx
.text$mn:0000A48C                 mov     [ebp+var_4], ecx
.text$mn:0000A48F                 push    offset ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ ; "string too long"
.text$mn:0000A494                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:0000A499                 mov     esp, ebp
.text$mn:0000A49B                 pop     ebp
.text$mn:0000A49C                 retn
.text$mn:0000A49C ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ endp
.text$mn:0000A49C
.text$mn:0000A49C ; ---------------------------------------------------------------------------
.text$mn:0000A49D                 align 10h
.text$mn:0000A49D _text$mn        ends
.text$mn:0000A49D
.text$mn:0000A4A0 ; ===========================================================================
.text$mn:0000A4A0
.text$mn:0000A4A0 ; Segment type: Pure code
.text$mn:0000A4A0 ; Segment permissions: Read/Execute
.text$mn:0000A4A0 _text$mn        segment para public 'CODE' use32
.text$mn:0000A4A0                 assume cs:_text$mn
.text$mn:0000A4A0                 ;org 0A4A0h
.text$mn:0000A4A0 ; COMDAT (pick any)
.text$mn:0000A4A0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A4A0
.text$mn:0000A4A0 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A4A0
.text$mn:0000A4A0 ; Attributes: bp-based frame
.text$mn:0000A4A0
.text$mn:0000A4A0 ; protected: void __thiscall std::vector<int, class std::allocator<int>>::_Xlen(void)const
.text$mn:0000A4A0                 public ?_Xlen@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ
.text$mn:0000A4A0 ?_Xlen@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ proc near
.text$mn:0000A4A0                                         ; CODE XREF: std::vector<int,std::allocator<int>>::_Reserve(uint)+31p
.text$mn:0000A4A0
.text$mn:0000A4A0 var_4           = dword ptr -4
.text$mn:0000A4A0
.text$mn:0000A4A0                 push    ebp
.text$mn:0000A4A1                 mov     ebp, esp
.text$mn:0000A4A3                 push    ecx
.text$mn:0000A4A4                 mov     [ebp+var_4], ecx
.text$mn:0000A4A7                 push    offset ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; "vector<T> too long"
.text$mn:0000A4AC                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:0000A4B1                 mov     esp, ebp
.text$mn:0000A4B3                 pop     ebp
.text$mn:0000A4B4                 retn
.text$mn:0000A4B4 ?_Xlen@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ endp
.text$mn:0000A4B4
.text$mn:0000A4B4 ; ---------------------------------------------------------------------------
.text$mn:0000A4B5                 align 4
.text$mn:0000A4B5 _text$mn        ends
.text$mn:0000A4B5
.text$mn:0000A4B8 ; ===========================================================================
.text$mn:0000A4B8
.text$mn:0000A4B8 ; Segment type: Pure code
.text$mn:0000A4B8 ; Segment permissions: Read/Execute
.text$mn:0000A4B8 _text$mn        segment para public 'CODE' use32
.text$mn:0000A4B8                 assume cs:_text$mn
.text$mn:0000A4B8                 ;org 0A4B8h
.text$mn:0000A4B8 ; COMDAT (pick any)
.text$mn:0000A4B8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A4B8
.text$mn:0000A4B8 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A4B8
.text$mn:0000A4B8 ; Attributes: bp-based frame
.text$mn:0000A4B8
.text$mn:0000A4B8 ; protected: void __thiscall std::vector<wchar_t, class std::allocator<wchar_t>>::_Xlen(void)const
.text$mn:0000A4B8                 public ?_Xlen@?$vector@_WV?$allocator@_W@std@@@std@@IBEXXZ
.text$mn:0000A4B8 ?_Xlen@?$vector@_WV?$allocator@_W@std@@@std@@IBEXXZ proc near
.text$mn:0000A4B8                                         ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::_Buy(uint)+43p
.text$mn:0000A4B8                                         ; std::vector<wchar_t,std::allocator<wchar_t>>::_Reserve(uint)+31p
.text$mn:0000A4B8
.text$mn:0000A4B8 var_4           = dword ptr -4
.text$mn:0000A4B8
.text$mn:0000A4B8                 push    ebp
.text$mn:0000A4B9                 mov     ebp, esp
.text$mn:0000A4BB                 push    ecx
.text$mn:0000A4BC                 mov     [ebp+var_4], ecx
.text$mn:0000A4BF                 push    offset ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; "vector<T> too long"
.text$mn:0000A4C4                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:0000A4C9                 mov     esp, ebp
.text$mn:0000A4CB                 pop     ebp
.text$mn:0000A4CC                 retn
.text$mn:0000A4CC ?_Xlen@?$vector@_WV?$allocator@_W@std@@@std@@IBEXXZ endp
.text$mn:0000A4CC
.text$mn:0000A4CC ; ---------------------------------------------------------------------------
.text$mn:0000A4CD                 align 10h
.text$mn:0000A4CD _text$mn        ends
.text$mn:0000A4CD
.text$mn:0000A4D0 ; ===========================================================================
.text$mn:0000A4D0
.text$mn:0000A4D0 ; Segment type: Pure code
.text$mn:0000A4D0 ; Segment permissions: Read/Execute
.text$mn:0000A4D0 _text$mn        segment para public 'CODE' use32
.text$mn:0000A4D0                 assume cs:_text$mn
.text$mn:0000A4D0                 ;org 0A4D0h
.text$mn:0000A4D0 ; COMDAT (pick any)
.text$mn:0000A4D0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A4D0
.text$mn:0000A4D0 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A4D0
.text$mn:0000A4D0 ; Attributes: bp-based frame
.text$mn:0000A4D0
.text$mn:0000A4D0 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xran(void)const
.text$mn:0000A4D0                 public ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
.text$mn:0000A4D0 ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc near
.text$mn:0000A4D0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+19p
.text$mn:0000A4D0                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)+15p ...
.text$mn:0000A4D0
.text$mn:0000A4D0 var_4           = dword ptr -4
.text$mn:0000A4D0
.text$mn:0000A4D0                 push    ebp
.text$mn:0000A4D1                 mov     ebp, esp
.text$mn:0000A4D3                 push    ecx
.text$mn:0000A4D4                 mov     [ebp+var_4], ecx
.text$mn:0000A4D7                 push    offset ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; "invalid string position"
.text$mn:0000A4DC                 call    ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range(char const *)
.text$mn:0000A4E1                 mov     esp, ebp
.text$mn:0000A4E3                 pop     ebp
.text$mn:0000A4E4                 retn
.text$mn:0000A4E4 ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp
.text$mn:0000A4E4
.text$mn:0000A4E4 ; ---------------------------------------------------------------------------
.text$mn:0000A4E5                 align 4
.text$mn:0000A4E5 _text$mn        ends
.text$mn:0000A4E5
.text$mn:0000A4E8 ; ===========================================================================
.text$mn:0000A4E8
.text$mn:0000A4E8 ; Segment type: Pure code
.text$mn:0000A4E8 ; Segment permissions: Read/Execute
.text$mn:0000A4E8 _text$mn        segment para public 'CODE' use32
.text$mn:0000A4E8                 assume cs:_text$mn
.text$mn:0000A4E8                 ;org 0A4E8h
.text$mn:0000A4E8 ; COMDAT (pick any)
.text$mn:0000A4E8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A4E8
.text$mn:0000A4E8 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A4E8
.text$mn:0000A4E8 ; Attributes: bp-based frame
.text$mn:0000A4E8
.text$mn:0000A4E8 ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Xran(void)const
.text$mn:0000A4E8                 public ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ
.text$mn:0000A4E8 ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ proc near
.text$mn:0000A4E8                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+19p
.text$mn:0000A4E8                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+19p ...
.text$mn:0000A4E8
.text$mn:0000A4E8 var_4           = dword ptr -4
.text$mn:0000A4E8
.text$mn:0000A4E8                 push    ebp
.text$mn:0000A4E9                 mov     ebp, esp
.text$mn:0000A4EB                 push    ecx
.text$mn:0000A4EC                 mov     [ebp+var_4], ecx
.text$mn:0000A4EF                 push    offset ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; "invalid string position"
.text$mn:0000A4F4                 call    ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range(char const *)
.text$mn:0000A4F9                 mov     esp, ebp
.text$mn:0000A4FB                 pop     ebp
.text$mn:0000A4FC                 retn
.text$mn:0000A4FC ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ endp
.text$mn:0000A4FC
.text$mn:0000A4FC ; ---------------------------------------------------------------------------
.text$mn:0000A4FD                 align 10h
.text$mn:0000A4FD _text$mn        ends
.text$mn:0000A4FD
.text$mn:0000A500 ; ===========================================================================
.text$mn:0000A500
.text$mn:0000A500 ; Segment type: Pure code
.text$mn:0000A500 ; Segment permissions: Read/Execute
.text$mn:0000A500 _text$mn        segment para public 'CODE' use32
.text$mn:0000A500                 assume cs:_text$mn
.text$mn:0000A500                 ;org 0A500h
.text$mn:0000A500 ; COMDAT (pick any)
.text$mn:0000A500                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A500
.text$mn:0000A500 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A500
.text$mn:0000A500 ; Attributes: bp-based frame
.text$mn:0000A500
.text$mn:0000A500 ; public: char * __thiscall std::_Wrap_alloc<class std::allocator<char>>::allocate(unsigned int)
.text$mn:0000A500                 public ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
.text$mn:0000A500 ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z proc near
.text$mn:0000A500                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+BBp
.text$mn:0000A500                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+22p
.text$mn:0000A500
.text$mn:0000A500 var_4           = dword ptr -4
.text$mn:0000A500 arg_0           = dword ptr  8
.text$mn:0000A500
.text$mn:0000A500                 push    ebp
.text$mn:0000A501                 mov     ebp, esp
.text$mn:0000A503                 push    ecx
.text$mn:0000A504                 mov     [ebp+var_4], ecx
.text$mn:0000A507                 mov     eax, [ebp+arg_0]
.text$mn:0000A50A                 push    eax
.text$mn:0000A50B                 mov     ecx, [ebp+var_4]
.text$mn:0000A50E                 call    ?allocate@?$allocator@D@std@@QAEPADI@Z ; std::allocator<char>::allocate(uint)
.text$mn:0000A513                 mov     esp, ebp
.text$mn:0000A515                 pop     ebp
.text$mn:0000A516                 retn    4
.text$mn:0000A516 ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z endp
.text$mn:0000A516
.text$mn:0000A516 ; ---------------------------------------------------------------------------
.text$mn:0000A519                 align 4
.text$mn:0000A519 _text$mn        ends
.text$mn:0000A519
.text$mn:0000A51C ; ===========================================================================
.text$mn:0000A51C
.text$mn:0000A51C ; Segment type: Pure code
.text$mn:0000A51C ; Segment permissions: Read/Execute
.text$mn:0000A51C _text$mn        segment para public 'CODE' use32
.text$mn:0000A51C                 assume cs:_text$mn
.text$mn:0000A51C                 ;org 0A51Ch
.text$mn:0000A51C ; COMDAT (pick any)
.text$mn:0000A51C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A51C
.text$mn:0000A51C ; =============== S U B R O U T I N E =======================================
.text$mn:0000A51C
.text$mn:0000A51C ; Attributes: bp-based frame
.text$mn:0000A51C
.text$mn:0000A51C ; public: int * __thiscall std::_Wrap_alloc<class std::allocator<int>>::allocate(unsigned int)
.text$mn:0000A51C                 public ?allocate@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAEPAHI@Z
.text$mn:0000A51C ?allocate@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAEPAHI@Z proc near
.text$mn:0000A51C                                         ; CODE XREF: std::vector<int,std::allocator<int>>::_Reallocate(uint)+41p
.text$mn:0000A51C
.text$mn:0000A51C var_4           = dword ptr -4
.text$mn:0000A51C arg_0           = dword ptr  8
.text$mn:0000A51C
.text$mn:0000A51C                 push    ebp
.text$mn:0000A51D                 mov     ebp, esp
.text$mn:0000A51F                 push    ecx
.text$mn:0000A520                 mov     [ebp+var_4], ecx
.text$mn:0000A523                 mov     eax, [ebp+arg_0]
.text$mn:0000A526                 push    eax
.text$mn:0000A527                 mov     ecx, [ebp+var_4]
.text$mn:0000A52A                 call    ?allocate@?$allocator@H@std@@QAEPAHI@Z ; std::allocator<int>::allocate(uint)
.text$mn:0000A52F                 mov     esp, ebp
.text$mn:0000A531                 pop     ebp
.text$mn:0000A532                 retn    4
.text$mn:0000A532 ?allocate@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAEPAHI@Z endp
.text$mn:0000A532
.text$mn:0000A532 ; ---------------------------------------------------------------------------
.text$mn:0000A535                 align 4
.text$mn:0000A535 _text$mn        ends
.text$mn:0000A535
.text$mn:0000A538 ; ===========================================================================
.text$mn:0000A538
.text$mn:0000A538 ; Segment type: Pure code
.text$mn:0000A538 ; Segment permissions: Read/Execute
.text$mn:0000A538 _text$mn        segment para public 'CODE' use32
.text$mn:0000A538                 assume cs:_text$mn
.text$mn:0000A538                 ;org 0A538h
.text$mn:0000A538 ; COMDAT (pick any)
.text$mn:0000A538                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A538
.text$mn:0000A538 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A538
.text$mn:0000A538 ; Attributes: bp-based frame
.text$mn:0000A538
.text$mn:0000A538 ; public: struct std::_Container_proxy * __thiscall std::_Wrap_alloc<class std::allocator<struct std::_Container_proxy>>::allocate(unsigned int)
.text$mn:0000A538                 public ?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z
.text$mn:0000A538 ?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z proc near
.text$mn:0000A538                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>::_Alloc_proxy(void)+16p
.text$mn:0000A538                                         ; std::_Vector_alloc<0,std::_Vec_base_types<wchar_t,std::allocator<wchar_t>>>::_Alloc_proxy(void)+16p
.text$mn:0000A538
.text$mn:0000A538 var_4           = dword ptr -4
.text$mn:0000A538 arg_0           = dword ptr  8
.text$mn:0000A538
.text$mn:0000A538                 push    ebp
.text$mn:0000A539                 mov     ebp, esp
.text$mn:0000A53B                 push    ecx
.text$mn:0000A53C                 mov     [ebp+var_4], ecx
.text$mn:0000A53F                 mov     eax, [ebp+arg_0]
.text$mn:0000A542                 push    eax
.text$mn:0000A543                 mov     ecx, [ebp+var_4]
.text$mn:0000A546                 call    ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate(uint)
.text$mn:0000A54B                 mov     esp, ebp
.text$mn:0000A54D                 pop     ebp
.text$mn:0000A54E                 retn    4
.text$mn:0000A54E ?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z endp
.text$mn:0000A54E
.text$mn:0000A54E ; ---------------------------------------------------------------------------
.text$mn:0000A551                 align 4
.text$mn:0000A551 _text$mn        ends
.text$mn:0000A551
.text$mn:0000A554 ; ===========================================================================
.text$mn:0000A554
.text$mn:0000A554 ; Segment type: Pure code
.text$mn:0000A554 ; Segment permissions: Read/Execute
.text$mn:0000A554 _text$mn        segment para public 'CODE' use32
.text$mn:0000A554                 assume cs:_text$mn
.text$mn:0000A554                 ;org 0A554h
.text$mn:0000A554 ; COMDAT (pick any)
.text$mn:0000A554                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A554
.text$mn:0000A554 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A554
.text$mn:0000A554 ; Attributes: bp-based frame
.text$mn:0000A554
.text$mn:0000A554 ; public: wchar_t * __thiscall std::_Wrap_alloc<class std::allocator<wchar_t>>::allocate(unsigned int)
.text$mn:0000A554                 public ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z
.text$mn:0000A554 ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z proc near
.text$mn:0000A554                                         ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::_Buy(uint)+5Cp
.text$mn:0000A554                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+BBp ...
.text$mn:0000A554
.text$mn:0000A554 var_4           = dword ptr -4
.text$mn:0000A554 arg_0           = dword ptr  8
.text$mn:0000A554
.text$mn:0000A554                 push    ebp
.text$mn:0000A555                 mov     ebp, esp
.text$mn:0000A557                 push    ecx
.text$mn:0000A558                 mov     [ebp+var_4], ecx
.text$mn:0000A55B                 mov     eax, [ebp+arg_0]
.text$mn:0000A55E                 push    eax
.text$mn:0000A55F                 mov     ecx, [ebp+var_4]
.text$mn:0000A562                 call    ?allocate@?$allocator@_W@std@@QAEPA_WI@Z ; std::allocator<wchar_t>::allocate(uint)
.text$mn:0000A567                 mov     esp, ebp
.text$mn:0000A569                 pop     ebp
.text$mn:0000A56A                 retn    4
.text$mn:0000A56A ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z endp
.text$mn:0000A56A
.text$mn:0000A56A ; ---------------------------------------------------------------------------
.text$mn:0000A56D                 align 10h
.text$mn:0000A56D _text$mn        ends
.text$mn:0000A56D
.text$mn:0000A570 ; ===========================================================================
.text$mn:0000A570
.text$mn:0000A570 ; Segment type: Pure code
.text$mn:0000A570 ; Segment permissions: Read/Execute
.text$mn:0000A570 _text$mn        segment para public 'CODE' use32
.text$mn:0000A570                 assume cs:_text$mn
.text$mn:0000A570                 ;org 0A570h
.text$mn:0000A570 ; COMDAT (pick any)
.text$mn:0000A570                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A570
.text$mn:0000A570 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A570
.text$mn:0000A570 ; Attributes: bp-based frame
.text$mn:0000A570
.text$mn:0000A570 ; public: char * __thiscall std::allocator<char>::allocate(unsigned int)
.text$mn:0000A570                 public ?allocate@?$allocator@D@std@@QAEPADI@Z
.text$mn:0000A570 ?allocate@?$allocator@D@std@@QAEPADI@Z proc near
.text$mn:0000A570                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::allocate(uint)+Ep
.text$mn:0000A570
.text$mn:0000A570 var_4           = dword ptr -4
.text$mn:0000A570 arg_0           = dword ptr  8
.text$mn:0000A570
.text$mn:0000A570                 push    ebp
.text$mn:0000A571                 mov     ebp, esp
.text$mn:0000A573                 push    ecx
.text$mn:0000A574                 mov     [ebp+var_4], ecx
.text$mn:0000A577                 push    0
.text$mn:0000A579                 mov     eax, [ebp+arg_0]
.text$mn:0000A57C                 push    eax
.text$mn:0000A57D                 call    ??$_Allocate@D@std@@YAPADIPAD@Z ; std::_Allocate<char>(uint,char *)
.text$mn:0000A582                 add     esp, 8
.text$mn:0000A585                 mov     esp, ebp
.text$mn:0000A587                 pop     ebp
.text$mn:0000A588                 retn    4
.text$mn:0000A588 ?allocate@?$allocator@D@std@@QAEPADI@Z endp
.text$mn:0000A588
.text$mn:0000A588 ; ---------------------------------------------------------------------------
.text$mn:0000A58B                 align 4
.text$mn:0000A58B _text$mn        ends
.text$mn:0000A58B
.text$mn:0000A58C ; ===========================================================================
.text$mn:0000A58C
.text$mn:0000A58C ; Segment type: Pure code
.text$mn:0000A58C ; Segment permissions: Read/Execute
.text$mn:0000A58C _text$mn        segment para public 'CODE' use32
.text$mn:0000A58C                 assume cs:_text$mn
.text$mn:0000A58C                 ;org 0A58Ch
.text$mn:0000A58C ; COMDAT (pick any)
.text$mn:0000A58C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A58C
.text$mn:0000A58C ; =============== S U B R O U T I N E =======================================
.text$mn:0000A58C
.text$mn:0000A58C ; Attributes: bp-based frame
.text$mn:0000A58C
.text$mn:0000A58C ; public: int * __thiscall std::allocator<int>::allocate(unsigned int)
.text$mn:0000A58C                 public ?allocate@?$allocator@H@std@@QAEPAHI@Z
.text$mn:0000A58C ?allocate@?$allocator@H@std@@QAEPAHI@Z proc near
.text$mn:0000A58C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<int>>::allocate(uint)+Ep
.text$mn:0000A58C
.text$mn:0000A58C var_4           = dword ptr -4
.text$mn:0000A58C arg_0           = dword ptr  8
.text$mn:0000A58C
.text$mn:0000A58C                 push    ebp
.text$mn:0000A58D                 mov     ebp, esp
.text$mn:0000A58F                 push    ecx
.text$mn:0000A590                 mov     [ebp+var_4], ecx
.text$mn:0000A593                 push    0
.text$mn:0000A595                 mov     eax, [ebp+arg_0]
.text$mn:0000A598                 push    eax
.text$mn:0000A599                 call    ??$_Allocate@H@std@@YAPAHIPAH@Z ; std::_Allocate<int>(uint,int *)
.text$mn:0000A59E                 add     esp, 8
.text$mn:0000A5A1                 mov     esp, ebp
.text$mn:0000A5A3                 pop     ebp
.text$mn:0000A5A4                 retn    4
.text$mn:0000A5A4 ?allocate@?$allocator@H@std@@QAEPAHI@Z endp
.text$mn:0000A5A4
.text$mn:0000A5A4 ; ---------------------------------------------------------------------------
.text$mn:0000A5A7                 align 4
.text$mn:0000A5A7 _text$mn        ends
.text$mn:0000A5A7
.text$mn:0000A5A8 ; ===========================================================================
.text$mn:0000A5A8
.text$mn:0000A5A8 ; Segment type: Pure code
.text$mn:0000A5A8 ; Segment permissions: Read/Execute
.text$mn:0000A5A8 _text$mn        segment para public 'CODE' use32
.text$mn:0000A5A8                 assume cs:_text$mn
.text$mn:0000A5A8                 ;org 0A5A8h
.text$mn:0000A5A8 ; COMDAT (pick any)
.text$mn:0000A5A8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A5A8
.text$mn:0000A5A8 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A5A8
.text$mn:0000A5A8 ; Attributes: bp-based frame
.text$mn:0000A5A8
.text$mn:0000A5A8 ; public: struct std::_Container_proxy * __thiscall std::allocator<struct std::_Container_proxy>::allocate(unsigned int)
.text$mn:0000A5A8                 public ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z
.text$mn:0000A5A8 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z proc near
.text$mn:0000A5A8                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+16p
.text$mn:0000A5A8                                         ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Alloc_proxy(void)+16p ...
.text$mn:0000A5A8
.text$mn:0000A5A8 var_4           = dword ptr -4
.text$mn:0000A5A8 arg_0           = dword ptr  8
.text$mn:0000A5A8
.text$mn:0000A5A8                 push    ebp
.text$mn:0000A5A9                 mov     ebp, esp
.text$mn:0000A5AB                 push    ecx
.text$mn:0000A5AC                 mov     [ebp+var_4], ecx
.text$mn:0000A5AF                 push    0
.text$mn:0000A5B1                 mov     eax, [ebp+arg_0]
.text$mn:0000A5B4                 push    eax
.text$mn:0000A5B5                 call    ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)
.text$mn:0000A5BA                 add     esp, 8
.text$mn:0000A5BD                 mov     esp, ebp
.text$mn:0000A5BF                 pop     ebp
.text$mn:0000A5C0                 retn    4
.text$mn:0000A5C0 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z endp
.text$mn:0000A5C0
.text$mn:0000A5C0 ; ---------------------------------------------------------------------------
.text$mn:0000A5C3                 align 4
.text$mn:0000A5C3 _text$mn        ends
.text$mn:0000A5C3
.text$mn:0000A5C4 ; ===========================================================================
.text$mn:0000A5C4
.text$mn:0000A5C4 ; Segment type: Pure code
.text$mn:0000A5C4 ; Segment permissions: Read/Execute
.text$mn:0000A5C4 _text$mn        segment para public 'CODE' use32
.text$mn:0000A5C4                 assume cs:_text$mn
.text$mn:0000A5C4                 ;org 0A5C4h
.text$mn:0000A5C4 ; COMDAT (pick any)
.text$mn:0000A5C4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A5C4
.text$mn:0000A5C4 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A5C4
.text$mn:0000A5C4 ; Attributes: bp-based frame
.text$mn:0000A5C4
.text$mn:0000A5C4 ; public: wchar_t * __thiscall std::allocator<wchar_t>::allocate(unsigned int)
.text$mn:0000A5C4                 public ?allocate@?$allocator@_W@std@@QAEPA_WI@Z
.text$mn:0000A5C4 ?allocate@?$allocator@_W@std@@QAEPA_WI@Z proc near
.text$mn:0000A5C4                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::allocate(uint)+Ep
.text$mn:0000A5C4
.text$mn:0000A5C4 var_4           = dword ptr -4
.text$mn:0000A5C4 arg_0           = dword ptr  8
.text$mn:0000A5C4
.text$mn:0000A5C4                 push    ebp
.text$mn:0000A5C5                 mov     ebp, esp
.text$mn:0000A5C7                 push    ecx
.text$mn:0000A5C8                 mov     [ebp+var_4], ecx
.text$mn:0000A5CB                 push    0
.text$mn:0000A5CD                 mov     eax, [ebp+arg_0]
.text$mn:0000A5D0                 push    eax
.text$mn:0000A5D1                 call    ??$_Allocate@_W@std@@YAPA_WIPA_W@Z ; std::_Allocate<wchar_t>(uint,wchar_t *)
.text$mn:0000A5D6                 add     esp, 8
.text$mn:0000A5D9                 mov     esp, ebp
.text$mn:0000A5DB                 pop     ebp
.text$mn:0000A5DC                 retn    4
.text$mn:0000A5DC ?allocate@?$allocator@_W@std@@QAEPA_WI@Z endp
.text$mn:0000A5DC
.text$mn:0000A5DC ; ---------------------------------------------------------------------------
.text$mn:0000A5DF                 align 10h
.text$mn:0000A5DF _text$mn        ends
.text$mn:0000A5DF
.text$mn:0000A5E0 ; ===========================================================================
.text$mn:0000A5E0
.text$mn:0000A5E0 ; Segment type: Pure code
.text$mn:0000A5E0 ; Segment permissions: Read/Execute
.text$mn:0000A5E0 _text$mn        segment para public 'CODE' use32
.text$mn:0000A5E0                 assume cs:_text$mn
.text$mn:0000A5E0                 ;org 0A5E0h
.text$mn:0000A5E0 ; COMDAT (pick any)
.text$mn:0000A5E0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A5E0
.text$mn:0000A5E0 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A5E0
.text$mn:0000A5E0 ; Attributes: bp-based frame
.text$mn:0000A5E0
.text$mn:0000A5E0 ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::append(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const &, unsigned int, unsigned int)
.text$mn:0000A5E0                 public ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z
.text$mn:0000A5E0 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z proc near
.text$mn:0000A5E0                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)+53p
.text$mn:0000A5E0
.text$mn:0000A5E0 var_8           = dword ptr -8
.text$mn:0000A5E0 var_4           = dword ptr -4
.text$mn:0000A5E0 arg_0           = dword ptr  8
.text$mn:0000A5E0 arg_4           = dword ptr  0Ch
.text$mn:0000A5E0 arg_8           = dword ptr  10h
.text$mn:0000A5E0
.text$mn:0000A5E0                 push    ebp
.text$mn:0000A5E1                 mov     ebp, esp
.text$mn:0000A5E3                 sub     esp, 8
.text$mn:0000A5E6                 mov     [ebp+var_4], ecx
.text$mn:0000A5E9                 mov     ecx, [ebp+arg_0]
.text$mn:0000A5EC                 call    ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::size(void)
.text$mn:0000A5F1                 cmp     eax, [ebp+arg_4]
.text$mn:0000A5F4                 jnb     short loc_A5FE
.text$mn:0000A5F6                 mov     ecx, [ebp+var_4]
.text$mn:0000A5F9                 call    ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)
.text$mn:0000A5FE
.text$mn:0000A5FE loc_A5FE:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+14j
.text$mn:0000A5FE                 mov     ecx, [ebp+arg_0]
.text$mn:0000A601                 call    ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::size(void)
.text$mn:0000A606                 sub     eax, [ebp+arg_4]
.text$mn:0000A609                 mov     [ebp+var_8], eax
.text$mn:0000A60C                 mov     eax, [ebp+var_8]
.text$mn:0000A60F                 cmp     eax, [ebp+arg_8]
.text$mn:0000A612                 jnb     short loc_A61A
.text$mn:0000A614                 mov     ecx, [ebp+var_8]
.text$mn:0000A617                 mov     [ebp+arg_8], ecx
.text$mn:0000A61A
.text$mn:0000A61A loc_A61A:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+32j
.text$mn:0000A61A                 mov     edx, [ebp+var_4]
.text$mn:0000A61D                 mov     eax, ds:?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB ; uint const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::npos
.text$mn:0000A622                 sub     eax, [edx+14h]
.text$mn:0000A625                 cmp     eax, [ebp+arg_8]
.text$mn:0000A628                 ja      short loc_A632
.text$mn:0000A62A                 mov     ecx, [ebp+var_4]
.text$mn:0000A62D                 call    ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xlen(void)
.text$mn:0000A632
.text$mn:0000A632 loc_A632:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+48j
.text$mn:0000A632                 cmp     [ebp+arg_8], 0
.text$mn:0000A636                 jbe     short loc_A692
.text$mn:0000A638                 mov     ecx, [ebp+var_4]
.text$mn:0000A63B                 mov     edx, [ecx+14h]
.text$mn:0000A63E                 add     edx, [ebp+arg_8]
.text$mn:0000A641                 mov     [ebp+var_8], edx
.text$mn:0000A644                 push    0
.text$mn:0000A646                 mov     eax, [ebp+var_8]
.text$mn:0000A649                 push    eax
.text$mn:0000A64A                 mov     ecx, [ebp+var_4]
.text$mn:0000A64D                 call    ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)
.text$mn:0000A652                 movzx   ecx, al
.text$mn:0000A655                 test    ecx, ecx
.text$mn:0000A657                 jz      short loc_A692
.text$mn:0000A659                 mov     edx, [ebp+arg_8]
.text$mn:0000A65C                 push    edx             ; int
.text$mn:0000A65D                 mov     ecx, [ebp+arg_0]
.text$mn:0000A660                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000A665                 mov     ecx, [ebp+arg_4]
.text$mn:0000A668                 lea     edx, [eax+ecx*2]
.text$mn:0000A66B                 push    edx             ; Src
.text$mn:0000A66C                 mov     ecx, [ebp+var_4]
.text$mn:0000A66F                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000A674                 mov     ecx, [ebp+var_4]
.text$mn:0000A677                 mov     edx, [ecx+14h]
.text$mn:0000A67A                 lea     eax, [eax+edx*2]
.text$mn:0000A67D                 push    eax             ; Dst
.text$mn:0000A67E                 call    ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)
.text$mn:0000A683                 add     esp, 0Ch
.text$mn:0000A686                 mov     ecx, [ebp+var_8]
.text$mn:0000A689                 push    ecx
.text$mn:0000A68A                 mov     ecx, [ebp+var_4]
.text$mn:0000A68D                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:0000A692
.text$mn:0000A692 loc_A692:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+56j
.text$mn:0000A692                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+77j
.text$mn:0000A692                 mov     eax, [ebp+var_4]
.text$mn:0000A695                 mov     esp, ebp
.text$mn:0000A697                 pop     ebp
.text$mn:0000A698                 retn    0Ch
.text$mn:0000A698 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z endp
.text$mn:0000A698
.text$mn:0000A698 ; ---------------------------------------------------------------------------
.text$mn:0000A69B                 align 4
.text$mn:0000A69B _text$mn        ends
.text$mn:0000A69B
.text$mn:0000A69C ; ===========================================================================
.text$mn:0000A69C
.text$mn:0000A69C ; Segment type: Pure code
.text$mn:0000A69C ; Segment permissions: Read/Execute
.text$mn:0000A69C _text$mn        segment para public 'CODE' use32
.text$mn:0000A69C                 assume cs:_text$mn
.text$mn:0000A69C                 ;org 0A69Ch
.text$mn:0000A69C ; COMDAT (pick any)
.text$mn:0000A69C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A69C
.text$mn:0000A69C ; =============== S U B R O U T I N E =======================================
.text$mn:0000A69C
.text$mn:0000A69C ; Attributes: bp-based frame
.text$mn:0000A69C
.text$mn:0000A69C ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t *Str)
.text$mn:0000A69C                 public ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z
.text$mn:0000A69C ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z proc near
.text$mn:0000A69C                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator+=(wchar_t const *)+Ep
.text$mn:0000A69C
.text$mn:0000A69C var_4           = dword ptr -4
.text$mn:0000A69C Str             = dword ptr  8
.text$mn:0000A69C
.text$mn:0000A69C                 push    ebp
.text$mn:0000A69D                 mov     ebp, esp
.text$mn:0000A69F                 push    ecx
.text$mn:0000A6A0                 mov     [ebp+var_4], ecx
.text$mn:0000A6A3                 push    43Eh            ; unsigned int
.text$mn:0000A6A8                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000A6AD                 mov     eax, [ebp+Str]
.text$mn:0000A6B0                 push    eax             ; int
.text$mn:0000A6B1                 call    ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z ; std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)
.text$mn:0000A6B6                 add     esp, 0Ch
.text$mn:0000A6B9                 mov     ecx, [ebp+Str]
.text$mn:0000A6BC                 push    ecx             ; Str
.text$mn:0000A6BD                 call    ?length@?$char_traits@_W@std@@SAIPB_W@Z ; std::char_traits<wchar_t>::length(wchar_t const *)
.text$mn:0000A6C2                 add     esp, 4
.text$mn:0000A6C5                 push    eax             ; int
.text$mn:0000A6C6                 mov     edx, [ebp+Str]
.text$mn:0000A6C9                 push    edx             ; Src
.text$mn:0000A6CA                 mov     ecx, [ebp+var_4]
.text$mn:0000A6CD                 call    ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)
.text$mn:0000A6D2                 mov     esp, ebp
.text$mn:0000A6D4                 pop     ebp
.text$mn:0000A6D5                 retn    4
.text$mn:0000A6D5 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z endp
.text$mn:0000A6D5
.text$mn:0000A6D5 _text$mn        ends
.text$mn:0000A6D5
.text$mn:0000A6D8 ; ===========================================================================
.text$mn:0000A6D8
.text$mn:0000A6D8 ; Segment type: Pure code
.text$mn:0000A6D8 ; Segment permissions: Read/Execute
.text$mn:0000A6D8 _text$mn        segment para public 'CODE' use32
.text$mn:0000A6D8                 assume cs:_text$mn
.text$mn:0000A6D8                 ;org 0A6D8h
.text$mn:0000A6D8 ; COMDAT (pick any)
.text$mn:0000A6D8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A6D8
.text$mn:0000A6D8 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A6D8
.text$mn:0000A6D8 ; Attributes: bp-based frame
.text$mn:0000A6D8
.text$mn:0000A6D8 ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(void *Src, int)
.text$mn:0000A6D8                 public ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z
.text$mn:0000A6D8 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z proc near
.text$mn:0000A6D8                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *)+31p
.text$mn:0000A6D8
.text$mn:0000A6D8 var_8           = dword ptr -8
.text$mn:0000A6D8 var_4           = dword ptr -4
.text$mn:0000A6D8 Src             = dword ptr  8
.text$mn:0000A6D8 arg_4           = dword ptr  0Ch
.text$mn:0000A6D8
.text$mn:0000A6D8                 push    ebp
.text$mn:0000A6D9                 mov     ebp, esp
.text$mn:0000A6DB                 sub     esp, 8
.text$mn:0000A6DE                 mov     [ebp+var_4], ecx
.text$mn:0000A6E1                 cmp     [ebp+arg_4], 0
.text$mn:0000A6E5                 jz      short loc_A6FD
.text$mn:0000A6E7                 push    42Ah            ; unsigned int
.text$mn:0000A6EC                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000A6F1                 mov     eax, [ebp+Src]
.text$mn:0000A6F4                 push    eax             ; int
.text$mn:0000A6F5                 call    ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z ; std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)
.text$mn:0000A6FA                 add     esp, 0Ch
.text$mn:0000A6FD
.text$mn:0000A6FD loc_A6FD:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)+Dj
.text$mn:0000A6FD                 mov     ecx, [ebp+Src]
.text$mn:0000A700                 push    ecx
.text$mn:0000A701                 mov     ecx, [ebp+var_4]
.text$mn:0000A704                 call    ?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)
.text$mn:0000A709                 movzx   edx, al
.text$mn:0000A70C                 test    edx, edx
.text$mn:0000A70E                 jz      short loc_A732
.text$mn:0000A710                 mov     eax, [ebp+arg_4]
.text$mn:0000A713                 push    eax
.text$mn:0000A714                 mov     ecx, [ebp+var_4]
.text$mn:0000A717                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000A71C                 mov     ecx, [ebp+Src]
.text$mn:0000A71F                 sub     ecx, eax
.text$mn:0000A721                 sar     ecx, 1
.text$mn:0000A723                 push    ecx
.text$mn:0000A724                 mov     edx, [ebp+var_4]
.text$mn:0000A727                 push    edx
.text$mn:0000A728                 mov     ecx, [ebp+var_4]
.text$mn:0000A72B                 call    ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)
.text$mn:0000A730                 jmp     short loc_A7A3
.text$mn:0000A732 ; ---------------------------------------------------------------------------
.text$mn:0000A732
.text$mn:0000A732 loc_A732:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)+36j
.text$mn:0000A732                 mov     eax, [ebp+var_4]
.text$mn:0000A735                 mov     ecx, ds:?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB ; uint const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::npos
.text$mn:0000A73B                 sub     ecx, [eax+14h]
.text$mn:0000A73E                 cmp     ecx, [ebp+arg_4]
.text$mn:0000A741                 ja      short loc_A74B
.text$mn:0000A743                 mov     ecx, [ebp+var_4]
.text$mn:0000A746                 call    ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xlen(void)
.text$mn:0000A74B
.text$mn:0000A74B loc_A74B:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)+69j
.text$mn:0000A74B                 cmp     [ebp+arg_4], 0
.text$mn:0000A74F                 jbe     short loc_A7A0
.text$mn:0000A751                 mov     edx, [ebp+var_4]
.text$mn:0000A754                 mov     eax, [edx+14h]
.text$mn:0000A757                 add     eax, [ebp+arg_4]
.text$mn:0000A75A                 mov     [ebp+var_8], eax
.text$mn:0000A75D                 push    0
.text$mn:0000A75F                 mov     ecx, [ebp+var_8]
.text$mn:0000A762                 push    ecx
.text$mn:0000A763                 mov     ecx, [ebp+var_4]
.text$mn:0000A766                 call    ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)
.text$mn:0000A76B                 movzx   edx, al
.text$mn:0000A76E                 test    edx, edx
.text$mn:0000A770                 jz      short loc_A7A0
.text$mn:0000A772                 mov     eax, [ebp+arg_4]
.text$mn:0000A775                 push    eax             ; int
.text$mn:0000A776                 mov     ecx, [ebp+Src]
.text$mn:0000A779                 push    ecx             ; Src
.text$mn:0000A77A                 mov     ecx, [ebp+var_4]
.text$mn:0000A77D                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000A782                 mov     edx, [ebp+var_4]
.text$mn:0000A785                 mov     ecx, [edx+14h]
.text$mn:0000A788                 lea     edx, [eax+ecx*2]
.text$mn:0000A78B                 push    edx             ; Dst
.text$mn:0000A78C                 call    ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)
.text$mn:0000A791                 add     esp, 0Ch
.text$mn:0000A794                 mov     eax, [ebp+var_8]
.text$mn:0000A797                 push    eax
.text$mn:0000A798                 mov     ecx, [ebp+var_4]
.text$mn:0000A79B                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:0000A7A0
.text$mn:0000A7A0 loc_A7A0:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)+77j
.text$mn:0000A7A0                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)+98j
.text$mn:0000A7A0                 mov     eax, [ebp+var_4]
.text$mn:0000A7A3
.text$mn:0000A7A3 loc_A7A3:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)+58j
.text$mn:0000A7A3                 mov     esp, ebp
.text$mn:0000A7A5                 pop     ebp
.text$mn:0000A7A6                 retn    8
.text$mn:0000A7A6 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z endp
.text$mn:0000A7A6
.text$mn:0000A7A6 ; ---------------------------------------------------------------------------
.text$mn:0000A7A9                 align 4
.text$mn:0000A7A9 _text$mn        ends
.text$mn:0000A7A9
.text$mn:0000A7AC ; ===========================================================================
.text$mn:0000A7AC
.text$mn:0000A7AC ; Segment type: Pure code
.text$mn:0000A7AC ; Segment permissions: Read/Execute
.text$mn:0000A7AC _text$mn        segment para public 'CODE' use32
.text$mn:0000A7AC                 assume cs:_text$mn
.text$mn:0000A7AC                 ;org 0A7ACh
.text$mn:0000A7AC ; COMDAT (pick any)
.text$mn:0000A7AC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A7AC
.text$mn:0000A7AC ; =============== S U B R O U T I N E =======================================
.text$mn:0000A7AC
.text$mn:0000A7AC ; Attributes: bp-based frame
.text$mn:0000A7AC
.text$mn:0000A7AC ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::assign(class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> const &, unsigned int, unsigned int)
.text$mn:0000A7AC                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
.text$mn:0000A7AC ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z proc near
.text$mn:0000A7AC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+4Fp
.text$mn:0000A7AC
.text$mn:0000A7AC Size            = dword ptr -8
.text$mn:0000A7AC var_4           = dword ptr -4
.text$mn:0000A7AC arg_0           = dword ptr  8
.text$mn:0000A7AC arg_4           = dword ptr  0Ch
.text$mn:0000A7AC arg_8           = dword ptr  10h
.text$mn:0000A7AC
.text$mn:0000A7AC                 push    ebp
.text$mn:0000A7AD                 mov     ebp, esp
.text$mn:0000A7AF                 sub     esp, 8
.text$mn:0000A7B2                 mov     [ebp+var_4], ecx
.text$mn:0000A7B5                 mov     ecx, [ebp+arg_0]
.text$mn:0000A7B8                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:0000A7BD                 cmp     eax, [ebp+arg_4]
.text$mn:0000A7C0                 jnb     short loc_A7CA
.text$mn:0000A7C2                 mov     ecx, [ebp+var_4]
.text$mn:0000A7C5                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:0000A7CA
.text$mn:0000A7CA loc_A7CA:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+14j
.text$mn:0000A7CA                 mov     ecx, [ebp+arg_0]
.text$mn:0000A7CD                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:0000A7D2                 sub     eax, [ebp+arg_4]
.text$mn:0000A7D5                 mov     [ebp+Size], eax
.text$mn:0000A7D8                 mov     eax, [ebp+arg_8]
.text$mn:0000A7DB                 cmp     eax, [ebp+Size]
.text$mn:0000A7DE                 jnb     short loc_A7E6
.text$mn:0000A7E0                 mov     ecx, [ebp+arg_8]
.text$mn:0000A7E3                 mov     [ebp+Size], ecx
.text$mn:0000A7E6
.text$mn:0000A7E6 loc_A7E6:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+32j
.text$mn:0000A7E6                 mov     edx, [ebp+var_4]
.text$mn:0000A7E9                 cmp     edx, [ebp+arg_0]
.text$mn:0000A7EC                 jnz     short loc_A80D
.text$mn:0000A7EE                 mov     eax, [ebp+arg_4]
.text$mn:0000A7F1                 add     eax, [ebp+Size]
.text$mn:0000A7F4                 push    eax
.text$mn:0000A7F5                 mov     ecx, [ebp+var_4]
.text$mn:0000A7F8                 call    ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)
.text$mn:0000A7FD                 mov     ecx, [ebp+arg_4]
.text$mn:0000A800                 push    ecx
.text$mn:0000A801                 push    0
.text$mn:0000A803                 mov     ecx, [ebp+var_4]
.text$mn:0000A806                 call    ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)
.text$mn:0000A80B                 jmp     short loc_A84F
.text$mn:0000A80D ; ---------------------------------------------------------------------------
.text$mn:0000A80D
.text$mn:0000A80D loc_A80D:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+40j
.text$mn:0000A80D                 push    0
.text$mn:0000A80F                 mov     edx, [ebp+Size]
.text$mn:0000A812                 push    edx
.text$mn:0000A813                 mov     ecx, [ebp+var_4]
.text$mn:0000A816                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:0000A81B                 movzx   eax, al
.text$mn:0000A81E                 test    eax, eax
.text$mn:0000A820                 jz      short loc_A84F
.text$mn:0000A822                 mov     ecx, [ebp+Size]
.text$mn:0000A825                 push    ecx             ; Size
.text$mn:0000A826                 mov     ecx, [ebp+arg_0]
.text$mn:0000A829                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000A82E                 add     eax, [ebp+arg_4]
.text$mn:0000A831                 push    eax             ; Src
.text$mn:0000A832                 mov     ecx, [ebp+var_4]
.text$mn:0000A835                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000A83A                 push    eax             ; Dst
.text$mn:0000A83B                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:0000A840                 add     esp, 0Ch
.text$mn:0000A843                 mov     edx, [ebp+Size]
.text$mn:0000A846                 push    edx
.text$mn:0000A847                 mov     ecx, [ebp+var_4]
.text$mn:0000A84A                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:0000A84F
.text$mn:0000A84F loc_A84F:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+5Fj
.text$mn:0000A84F                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+74j
.text$mn:0000A84F                 mov     eax, [ebp+var_4]
.text$mn:0000A852                 mov     esp, ebp
.text$mn:0000A854                 pop     ebp
.text$mn:0000A855                 retn    0Ch
.text$mn:0000A855 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z endp
.text$mn:0000A855
.text$mn:0000A855 _text$mn        ends
.text$mn:0000A855
.text$mn:0000A858 ; ===========================================================================
.text$mn:0000A858
.text$mn:0000A858 ; Segment type: Pure code
.text$mn:0000A858 ; Segment permissions: Read/Execute
.text$mn:0000A858 _text$mn        segment para public 'CODE' use32
.text$mn:0000A858                 assume cs:_text$mn
.text$mn:0000A858                 ;org 0A858h
.text$mn:0000A858 ; COMDAT (pick any)
.text$mn:0000A858                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A858
.text$mn:0000A858 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A858
.text$mn:0000A858 ; Attributes: bp-based frame
.text$mn:0000A858
.text$mn:0000A858 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char *Str)
.text$mn:0000A858                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
.text$mn:0000A858 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z proc near
.text$mn:0000A858                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+53p
.text$mn:0000A858
.text$mn:0000A858 var_4           = dword ptr -4
.text$mn:0000A858 Str             = dword ptr  8
.text$mn:0000A858
.text$mn:0000A858                 push    ebp
.text$mn:0000A859                 mov     ebp, esp
.text$mn:0000A85B                 push    ecx
.text$mn:0000A85C                 mov     [ebp+var_4], ecx
.text$mn:0000A85F                 push    490h            ; unsigned int
.text$mn:0000A864                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000A869                 mov     eax, [ebp+Str]
.text$mn:0000A86C                 push    eax             ; int
.text$mn:0000A86D                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:0000A872                 add     esp, 0Ch
.text$mn:0000A875                 mov     ecx, [ebp+Str]
.text$mn:0000A878                 push    ecx             ; Str
.text$mn:0000A879                 call    ?length@?$char_traits@D@std@@SAIPBD@Z ; std::char_traits<char>::length(char const *)
.text$mn:0000A87E                 add     esp, 4
.text$mn:0000A881                 push    eax             ; Size
.text$mn:0000A882                 mov     edx, [ebp+Str]
.text$mn:0000A885                 push    edx             ; Src
.text$mn:0000A886                 mov     ecx, [ebp+var_4]
.text$mn:0000A889                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)
.text$mn:0000A88E                 mov     esp, ebp
.text$mn:0000A890                 pop     ebp
.text$mn:0000A891                 retn    4
.text$mn:0000A891 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z endp
.text$mn:0000A891
.text$mn:0000A891 _text$mn        ends
.text$mn:0000A891
.text$mn:0000A894 ; ===========================================================================
.text$mn:0000A894
.text$mn:0000A894 ; Segment type: Pure code
.text$mn:0000A894 ; Segment permissions: Read/Execute
.text$mn:0000A894 _text$mn        segment para public 'CODE' use32
.text$mn:0000A894                 assume cs:_text$mn
.text$mn:0000A894                 ;org 0A894h
.text$mn:0000A894 ; COMDAT (pick any)
.text$mn:0000A894                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A894
.text$mn:0000A894 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A894
.text$mn:0000A894 ; Attributes: bp-based frame
.text$mn:0000A894
.text$mn:0000A894 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(void *Src, size_t Size)
.text$mn:0000A894                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
.text$mn:0000A894 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z proc near
.text$mn:0000A894                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+31p
.text$mn:0000A894
.text$mn:0000A894 var_4           = dword ptr -4
.text$mn:0000A894 Src             = dword ptr  8
.text$mn:0000A894 Size            = dword ptr  0Ch
.text$mn:0000A894
.text$mn:0000A894                 push    ebp
.text$mn:0000A895                 mov     ebp, esp
.text$mn:0000A897                 push    ecx
.text$mn:0000A898                 mov     [ebp+var_4], ecx
.text$mn:0000A89B                 cmp     [ebp+Size], 0
.text$mn:0000A89F                 jz      short loc_A8B7
.text$mn:0000A8A1                 push    47Fh            ; unsigned int
.text$mn:0000A8A6                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000A8AB                 mov     eax, [ebp+Src]
.text$mn:0000A8AE                 push    eax             ; int
.text$mn:0000A8AF                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:0000A8B4                 add     esp, 0Ch
.text$mn:0000A8B7
.text$mn:0000A8B7 loc_A8B7:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+Bj
.text$mn:0000A8B7                 mov     ecx, [ebp+Src]
.text$mn:0000A8BA                 push    ecx
.text$mn:0000A8BB                 mov     ecx, [ebp+var_4]
.text$mn:0000A8BE                 call    ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)
.text$mn:0000A8C3                 movzx   edx, al
.text$mn:0000A8C6                 test    edx, edx
.text$mn:0000A8C8                 jz      short loc_A8EA
.text$mn:0000A8CA                 mov     eax, [ebp+Size]
.text$mn:0000A8CD                 push    eax
.text$mn:0000A8CE                 mov     ecx, [ebp+var_4]
.text$mn:0000A8D1                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000A8D6                 mov     ecx, [ebp+Src]
.text$mn:0000A8D9                 sub     ecx, eax
.text$mn:0000A8DB                 push    ecx
.text$mn:0000A8DC                 mov     edx, [ebp+var_4]
.text$mn:0000A8DF                 push    edx
.text$mn:0000A8E0                 mov     ecx, [ebp+var_4]
.text$mn:0000A8E3                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)
.text$mn:0000A8E8                 jmp     short loc_A927
.text$mn:0000A8EA ; ---------------------------------------------------------------------------
.text$mn:0000A8EA
.text$mn:0000A8EA loc_A8EA:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+34j
.text$mn:0000A8EA                 push    0
.text$mn:0000A8EC                 mov     eax, [ebp+Size]
.text$mn:0000A8EF                 push    eax
.text$mn:0000A8F0                 mov     ecx, [ebp+var_4]
.text$mn:0000A8F3                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:0000A8F8                 movzx   ecx, al
.text$mn:0000A8FB                 test    ecx, ecx
.text$mn:0000A8FD                 jz      short loc_A924
.text$mn:0000A8FF                 mov     edx, [ebp+Size]
.text$mn:0000A902                 push    edx             ; Size
.text$mn:0000A903                 mov     eax, [ebp+Src]
.text$mn:0000A906                 push    eax             ; Src
.text$mn:0000A907                 mov     ecx, [ebp+var_4]
.text$mn:0000A90A                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000A90F                 push    eax             ; Dst
.text$mn:0000A910                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:0000A915                 add     esp, 0Ch
.text$mn:0000A918                 mov     ecx, [ebp+Size]
.text$mn:0000A91B                 push    ecx
.text$mn:0000A91C                 mov     ecx, [ebp+var_4]
.text$mn:0000A91F                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:0000A924
.text$mn:0000A924 loc_A924:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+69j
.text$mn:0000A924                 mov     eax, [ebp+var_4]
.text$mn:0000A927
.text$mn:0000A927 loc_A927:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+54j
.text$mn:0000A927                 mov     esp, ebp
.text$mn:0000A929                 pop     ebp
.text$mn:0000A92A                 retn    8
.text$mn:0000A92A ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z endp
.text$mn:0000A92A
.text$mn:0000A92A ; ---------------------------------------------------------------------------
.text$mn:0000A92D                 align 10h
.text$mn:0000A92D _text$mn        ends
.text$mn:0000A92D
.text$mn:0000A930 ; ===========================================================================
.text$mn:0000A930
.text$mn:0000A930 ; Segment type: Pure code
.text$mn:0000A930 ; Segment permissions: Read/Execute
.text$mn:0000A930 _text$mn        segment para public 'CODE' use32
.text$mn:0000A930                 assume cs:_text$mn
.text$mn:0000A930                 ;org 0A930h
.text$mn:0000A930 ; COMDAT (pick any)
.text$mn:0000A930                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A930
.text$mn:0000A930 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A930
.text$mn:0000A930 ; Attributes: bp-based frame
.text$mn:0000A930
.text$mn:0000A930 ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::assign(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const &, unsigned int, unsigned int)
.text$mn:0000A930                 public ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z
.text$mn:0000A930 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z proc near
.text$mn:0000A930                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+51p
.text$mn:0000A930
.text$mn:0000A930 var_8           = dword ptr -8
.text$mn:0000A930 var_4           = dword ptr -4
.text$mn:0000A930 arg_0           = dword ptr  8
.text$mn:0000A930 arg_4           = dword ptr  0Ch
.text$mn:0000A930 arg_8           = dword ptr  10h
.text$mn:0000A930
.text$mn:0000A930                 push    ebp
.text$mn:0000A931                 mov     ebp, esp
.text$mn:0000A933                 sub     esp, 8
.text$mn:0000A936                 mov     [ebp+var_4], ecx
.text$mn:0000A939                 mov     ecx, [ebp+arg_0]
.text$mn:0000A93C                 call    ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::size(void)
.text$mn:0000A941                 cmp     eax, [ebp+arg_4]
.text$mn:0000A944                 jnb     short loc_A94E
.text$mn:0000A946                 mov     ecx, [ebp+var_4]
.text$mn:0000A949                 call    ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)
.text$mn:0000A94E
.text$mn:0000A94E loc_A94E:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+14j
.text$mn:0000A94E                 mov     ecx, [ebp+arg_0]
.text$mn:0000A951                 call    ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::size(void)
.text$mn:0000A956                 sub     eax, [ebp+arg_4]
.text$mn:0000A959                 mov     [ebp+var_8], eax
.text$mn:0000A95C                 mov     eax, [ebp+arg_8]
.text$mn:0000A95F                 cmp     eax, [ebp+var_8]
.text$mn:0000A962                 jnb     short loc_A96A
.text$mn:0000A964                 mov     ecx, [ebp+arg_8]
.text$mn:0000A967                 mov     [ebp+var_8], ecx
.text$mn:0000A96A
.text$mn:0000A96A loc_A96A:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+32j
.text$mn:0000A96A                 mov     edx, [ebp+var_4]
.text$mn:0000A96D                 cmp     edx, [ebp+arg_0]
.text$mn:0000A970                 jnz     short loc_A991
.text$mn:0000A972                 mov     eax, [ebp+arg_4]
.text$mn:0000A975                 add     eax, [ebp+var_8]
.text$mn:0000A978                 push    eax
.text$mn:0000A979                 mov     ecx, [ebp+var_4]
.text$mn:0000A97C                 call    ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint)
.text$mn:0000A981                 mov     ecx, [ebp+arg_4]
.text$mn:0000A984                 push    ecx
.text$mn:0000A985                 push    0
.text$mn:0000A987                 mov     ecx, [ebp+var_4]
.text$mn:0000A98A                 call    ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)
.text$mn:0000A98F                 jmp     short loc_A9D6
.text$mn:0000A991 ; ---------------------------------------------------------------------------
.text$mn:0000A991
.text$mn:0000A991 loc_A991:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+40j
.text$mn:0000A991                 push    0
.text$mn:0000A993                 mov     edx, [ebp+var_8]
.text$mn:0000A996                 push    edx
.text$mn:0000A997                 mov     ecx, [ebp+var_4]
.text$mn:0000A99A                 call    ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)
.text$mn:0000A99F                 movzx   eax, al
.text$mn:0000A9A2                 test    eax, eax
.text$mn:0000A9A4                 jz      short loc_A9D6
.text$mn:0000A9A6                 mov     ecx, [ebp+var_8]
.text$mn:0000A9A9                 push    ecx             ; int
.text$mn:0000A9AA                 mov     ecx, [ebp+arg_0]
.text$mn:0000A9AD                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000A9B2                 mov     edx, [ebp+arg_4]
.text$mn:0000A9B5                 lea     eax, [eax+edx*2]
.text$mn:0000A9B8                 push    eax             ; Src
.text$mn:0000A9B9                 mov     ecx, [ebp+var_4]
.text$mn:0000A9BC                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000A9C1                 push    eax             ; Dst
.text$mn:0000A9C2                 call    ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)
.text$mn:0000A9C7                 add     esp, 0Ch
.text$mn:0000A9CA                 mov     ecx, [ebp+var_8]
.text$mn:0000A9CD                 push    ecx
.text$mn:0000A9CE                 mov     ecx, [ebp+var_4]
.text$mn:0000A9D1                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:0000A9D6
.text$mn:0000A9D6 loc_A9D6:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+5Fj
.text$mn:0000A9D6                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+74j
.text$mn:0000A9D6                 mov     eax, [ebp+var_4]
.text$mn:0000A9D9                 mov     esp, ebp
.text$mn:0000A9DB                 pop     ebp
.text$mn:0000A9DC                 retn    0Ch
.text$mn:0000A9DC ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z endp
.text$mn:0000A9DC
.text$mn:0000A9DC ; ---------------------------------------------------------------------------
.text$mn:0000A9DF                 align 10h
.text$mn:0000A9DF _text$mn        ends
.text$mn:0000A9DF
.text$mn:0000A9E0 ; ===========================================================================
.text$mn:0000A9E0
.text$mn:0000A9E0 ; Segment type: Pure code
.text$mn:0000A9E0 ; Segment permissions: Read/Execute
.text$mn:0000A9E0 _text$mn        segment para public 'CODE' use32
.text$mn:0000A9E0                 assume cs:_text$mn
.text$mn:0000A9E0                 ;org 0A9E0h
.text$mn:0000A9E0 ; COMDAT (pick any)
.text$mn:0000A9E0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A9E0
.text$mn:0000A9E0 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A9E0
.text$mn:0000A9E0 ; Attributes: bp-based frame
.text$mn:0000A9E0
.text$mn:0000A9E0 ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t *Str)
.text$mn:0000A9E0                 public ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z
.text$mn:0000A9E0 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z proc near
.text$mn:0000A9E0                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)+53p
.text$mn:0000A9E0
.text$mn:0000A9E0 var_4           = dword ptr -4
.text$mn:0000A9E0 Str             = dword ptr  8
.text$mn:0000A9E0
.text$mn:0000A9E0                 push    ebp
.text$mn:0000A9E1                 mov     ebp, esp
.text$mn:0000A9E3                 push    ecx
.text$mn:0000A9E4                 mov     [ebp+var_4], ecx
.text$mn:0000A9E7                 push    490h            ; unsigned int
.text$mn:0000A9EC                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000A9F1                 mov     eax, [ebp+Str]
.text$mn:0000A9F4                 push    eax             ; int
.text$mn:0000A9F5                 call    ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z ; std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)
.text$mn:0000A9FA                 add     esp, 0Ch
.text$mn:0000A9FD                 mov     ecx, [ebp+Str]
.text$mn:0000AA00                 push    ecx             ; Str
.text$mn:0000AA01                 call    ?length@?$char_traits@_W@std@@SAIPB_W@Z ; std::char_traits<wchar_t>::length(wchar_t const *)
.text$mn:0000AA06                 add     esp, 4
.text$mn:0000AA09                 push    eax             ; int
.text$mn:0000AA0A                 mov     edx, [ebp+Str]
.text$mn:0000AA0D                 push    edx             ; Src
.text$mn:0000AA0E                 mov     ecx, [ebp+var_4]
.text$mn:0000AA11                 call    ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)
.text$mn:0000AA16                 mov     esp, ebp
.text$mn:0000AA18                 pop     ebp
.text$mn:0000AA19                 retn    4
.text$mn:0000AA19 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z endp
.text$mn:0000AA19
.text$mn:0000AA19 _text$mn        ends
.text$mn:0000AA19
.text$mn:0000AA1C ; ===========================================================================
.text$mn:0000AA1C
.text$mn:0000AA1C ; Segment type: Pure code
.text$mn:0000AA1C ; Segment permissions: Read/Execute
.text$mn:0000AA1C _text$mn        segment para public 'CODE' use32
.text$mn:0000AA1C                 assume cs:_text$mn
.text$mn:0000AA1C                 ;org 0AA1Ch
.text$mn:0000AA1C ; COMDAT (pick any)
.text$mn:0000AA1C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000AA1C
.text$mn:0000AA1C ; =============== S U B R O U T I N E =======================================
.text$mn:0000AA1C
.text$mn:0000AA1C ; Attributes: bp-based frame
.text$mn:0000AA1C
.text$mn:0000AA1C ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(void *Src, int)
.text$mn:0000AA1C                 public ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z
.text$mn:0000AA1C ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z proc near
.text$mn:0000AA1C                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *)+31p
.text$mn:0000AA1C
.text$mn:0000AA1C var_4           = dword ptr -4
.text$mn:0000AA1C Src             = dword ptr  8
.text$mn:0000AA1C arg_4           = dword ptr  0Ch
.text$mn:0000AA1C
.text$mn:0000AA1C                 push    ebp
.text$mn:0000AA1D                 mov     ebp, esp
.text$mn:0000AA1F                 push    ecx
.text$mn:0000AA20                 mov     [ebp+var_4], ecx
.text$mn:0000AA23                 cmp     [ebp+arg_4], 0
.text$mn:0000AA27                 jz      short loc_AA3F
.text$mn:0000AA29                 push    47Fh            ; unsigned int
.text$mn:0000AA2E                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000AA33                 mov     eax, [ebp+Src]
.text$mn:0000AA36                 push    eax             ; int
.text$mn:0000AA37                 call    ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z ; std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)
.text$mn:0000AA3C                 add     esp, 0Ch
.text$mn:0000AA3F
.text$mn:0000AA3F loc_AA3F:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+Bj
.text$mn:0000AA3F                 mov     ecx, [ebp+Src]
.text$mn:0000AA42                 push    ecx
.text$mn:0000AA43                 mov     ecx, [ebp+var_4]
.text$mn:0000AA46                 call    ?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)
.text$mn:0000AA4B                 movzx   edx, al
.text$mn:0000AA4E                 test    edx, edx
.text$mn:0000AA50                 jz      short loc_AA74
.text$mn:0000AA52                 mov     eax, [ebp+arg_4]
.text$mn:0000AA55                 push    eax
.text$mn:0000AA56                 mov     ecx, [ebp+var_4]
.text$mn:0000AA59                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000AA5E                 mov     ecx, [ebp+Src]
.text$mn:0000AA61                 sub     ecx, eax
.text$mn:0000AA63                 sar     ecx, 1
.text$mn:0000AA65                 push    ecx
.text$mn:0000AA66                 mov     edx, [ebp+var_4]
.text$mn:0000AA69                 push    edx
.text$mn:0000AA6A                 mov     ecx, [ebp+var_4]
.text$mn:0000AA6D                 call    ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)
.text$mn:0000AA72                 jmp     short loc_AAB1
.text$mn:0000AA74 ; ---------------------------------------------------------------------------
.text$mn:0000AA74
.text$mn:0000AA74 loc_AA74:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+34j
.text$mn:0000AA74                 push    0
.text$mn:0000AA76                 mov     eax, [ebp+arg_4]
.text$mn:0000AA79                 push    eax
.text$mn:0000AA7A                 mov     ecx, [ebp+var_4]
.text$mn:0000AA7D                 call    ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)
.text$mn:0000AA82                 movzx   ecx, al
.text$mn:0000AA85                 test    ecx, ecx
.text$mn:0000AA87                 jz      short loc_AAAE
.text$mn:0000AA89                 mov     edx, [ebp+arg_4]
.text$mn:0000AA8C                 push    edx             ; int
.text$mn:0000AA8D                 mov     eax, [ebp+Src]
.text$mn:0000AA90                 push    eax             ; Src
.text$mn:0000AA91                 mov     ecx, [ebp+var_4]
.text$mn:0000AA94                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000AA99                 push    eax             ; Dst
.text$mn:0000AA9A                 call    ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)
.text$mn:0000AA9F                 add     esp, 0Ch
.text$mn:0000AAA2                 mov     ecx, [ebp+arg_4]
.text$mn:0000AAA5                 push    ecx
.text$mn:0000AAA6                 mov     ecx, [ebp+var_4]
.text$mn:0000AAA9                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:0000AAAE
.text$mn:0000AAAE loc_AAAE:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+6Bj
.text$mn:0000AAAE                 mov     eax, [ebp+var_4]
.text$mn:0000AAB1
.text$mn:0000AAB1 loc_AAB1:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+56j
.text$mn:0000AAB1                 mov     esp, ebp
.text$mn:0000AAB3                 pop     ebp
.text$mn:0000AAB4                 retn    8
.text$mn:0000AAB4 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z endp
.text$mn:0000AAB4
.text$mn:0000AAB4 ; ---------------------------------------------------------------------------
.text$mn:0000AAB7                 align 4
.text$mn:0000AAB7 _text$mn        ends
.text$mn:0000AAB7
.text$mn:0000AAB8 ; ===========================================================================
.text$mn:0000AAB8
.text$mn:0000AAB8 ; Segment type: Pure code
.text$mn:0000AAB8 ; Segment permissions: Read/Execute
.text$mn:0000AAB8 _text$mn        segment para public 'CODE' use32
.text$mn:0000AAB8                 assume cs:_text$mn
.text$mn:0000AAB8                 ;org 0AAB8h
.text$mn:0000AAB8 ; COMDAT (pick any)
.text$mn:0000AAB8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000AAB8
.text$mn:0000AAB8 ; =============== S U B R O U T I N E =======================================
.text$mn:0000AAB8
.text$mn:0000AAB8 ; Attributes: bp-based frame
.text$mn:0000AAB8
.text$mn:0000AAB8 ; public: static void __cdecl std::char_traits<char>::assign(char &, char const &)
.text$mn:0000AAB8                 public ?assign@?$char_traits@D@std@@SAXAADABD@Z
.text$mn:0000AAB8 ?assign@?$char_traits@D@std@@SAXAADABD@Z proc near
.text$mn:0000AAB8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+26p
.text$mn:0000AAB8
.text$mn:0000AAB8 arg_0           = dword ptr  8
.text$mn:0000AAB8 arg_4           = dword ptr  0Ch
.text$mn:0000AAB8
.text$mn:0000AAB8                 push    ebp
.text$mn:0000AAB9                 mov     ebp, esp
.text$mn:0000AABB                 mov     eax, [ebp+arg_0]
.text$mn:0000AABE                 mov     ecx, [ebp+arg_4]
.text$mn:0000AAC1                 mov     dl, [ecx]
.text$mn:0000AAC3                 mov     [eax], dl
.text$mn:0000AAC5                 pop     ebp
.text$mn:0000AAC6                 retn
.text$mn:0000AAC6 ?assign@?$char_traits@D@std@@SAXAADABD@Z endp
.text$mn:0000AAC6
.text$mn:0000AAC6 ; ---------------------------------------------------------------------------
.text$mn:0000AAC7                 align 4
.text$mn:0000AAC7 _text$mn        ends
.text$mn:0000AAC7
.text$mn:0000AAC8 ; ===========================================================================
.text$mn:0000AAC8
.text$mn:0000AAC8 ; Segment type: Pure code
.text$mn:0000AAC8 ; Segment permissions: Read/Execute
.text$mn:0000AAC8 _text$mn        segment para public 'CODE' use32
.text$mn:0000AAC8                 assume cs:_text$mn
.text$mn:0000AAC8                 ;org 0AAC8h
.text$mn:0000AAC8 ; COMDAT (pick any)
.text$mn:0000AAC8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000AAC8
.text$mn:0000AAC8 ; =============== S U B R O U T I N E =======================================
.text$mn:0000AAC8
.text$mn:0000AAC8 ; Attributes: bp-based frame
.text$mn:0000AAC8
.text$mn:0000AAC8 ; public: static void __cdecl std::char_traits<wchar_t>::assign(wchar_t &, wchar_t const &)
.text$mn:0000AAC8                 public ?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z
.text$mn:0000AAC8 ?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z proc near
.text$mn:0000AAC8                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)+2Bp
.text$mn:0000AAC8
.text$mn:0000AAC8 arg_0           = dword ptr  8
.text$mn:0000AAC8 arg_4           = dword ptr  0Ch
.text$mn:0000AAC8
.text$mn:0000AAC8                 push    ebp
.text$mn:0000AAC9                 mov     ebp, esp
.text$mn:0000AACB                 mov     eax, [ebp+arg_0]
.text$mn:0000AACE                 mov     ecx, [ebp+arg_4]
.text$mn:0000AAD1                 mov     dx, [ecx]
.text$mn:0000AAD4                 mov     [eax], dx
.text$mn:0000AAD7                 pop     ebp
.text$mn:0000AAD8                 retn
.text$mn:0000AAD8 ?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z endp
.text$mn:0000AAD8
.text$mn:0000AAD8 ; ---------------------------------------------------------------------------
.text$mn:0000AAD9                 align 4
.text$mn:0000AAD9 _text$mn        ends
.text$mn:0000AAD9
.text$mn:0000AADC ; ===========================================================================
.text$mn:0000AADC
.text$mn:0000AADC ; Segment type: Pure code
.text$mn:0000AADC ; Segment permissions: Read/Execute
.text$mn:0000AADC _text$mn        segment para public 'CODE' use32
.text$mn:0000AADC                 assume cs:_text$mn
.text$mn:0000AADC                 ;org 0AADCh
.text$mn:0000AADC ; COMDAT (pick any)
.text$mn:0000AADC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000AADC
.text$mn:0000AADC ; =============== S U B R O U T I N E =======================================
.text$mn:0000AADC
.text$mn:0000AADC ; Attributes: bp-based frame
.text$mn:0000AADC
.text$mn:0000AADC ; public: class std::_String_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>> __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::begin(void)
.text$mn:0000AADC                 public ?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ
.text$mn:0000AADC ?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ proc near
.text$mn:0000AADC                                         ; CODE XREF: WindowsMenu::initPopupMenu(HMENU__ *,DocTabView *)+15Cp
.text$mn:0000AADC
.text$mn:0000AADC var_14          = dword ptr -14h
.text$mn:0000AADC var_10          = dword ptr -10h
.text$mn:0000AADC var_C           = dword ptr -0Ch
.text$mn:0000AADC var_4           = dword ptr -4
.text$mn:0000AADC arg_0           = dword ptr  8
.text$mn:0000AADC
.text$mn:0000AADC                 push    ebp
.text$mn:0000AADD                 mov     ebp, esp
.text$mn:0000AADF                 push    0FFFFFFFFh
.text$mn:0000AAE1                 push    offset __ehhandler$?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ
.text$mn:0000AAE6                 mov     eax, large fs:0
.text$mn:0000AAEC                 push    eax
.text$mn:0000AAED                 sub     esp, 8
.text$mn:0000AAF0                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000AAF5                 xor     eax, ebp
.text$mn:0000AAF7                 push    eax
.text$mn:0000AAF8                 lea     eax, [ebp+var_C]
.text$mn:0000AAFB                 mov     large fs:0, eax
.text$mn:0000AB01                 mov     [ebp+var_10], ecx
.text$mn:0000AB04                 mov     [ebp+var_14], 0
.text$mn:0000AB0B                 mov     eax, [ebp+var_10]
.text$mn:0000AB0E                 push    eax             ; struct std::_Container_base12 *
.text$mn:0000AB0F                 mov     ecx, [ebp+var_10]
.text$mn:0000AB12                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000AB17                 push    eax             ; int
.text$mn:0000AB18                 mov     ecx, [ebp+arg_0]
.text$mn:0000AB1B                 call    ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base12@1@@Z ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(wchar_t *,std::_Container_base12 const *)
.text$mn:0000AB20                 mov     [ebp+var_4], 0
.text$mn:0000AB27                 mov     ecx, [ebp+var_14]
.text$mn:0000AB2A                 or      ecx, 1
.text$mn:0000AB2D                 mov     [ebp+var_14], ecx
.text$mn:0000AB30                 mov     eax, [ebp+arg_0]
.text$mn:0000AB33                 mov     ecx, [ebp+var_C]
.text$mn:0000AB36                 mov     large fs:0, ecx
.text$mn:0000AB3D                 pop     ecx
.text$mn:0000AB3E                 mov     esp, ebp
.text$mn:0000AB40                 pop     ebp
.text$mn:0000AB41                 retn    4
.text$mn:0000AB41 ?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ endp
.text$mn:0000AB41
.text$mn:0000AB41 _text$mn        ends
.text$mn:0000AB41
.text$x:0000AB44 ; ===========================================================================
.text$x:0000AB44
.text$x:0000AB44 ; Segment type: Pure code
.text$x:0000AB44 ; Segment permissions: Read/Execute
.text$x:0000AB44 _text$x         segment para public 'CODE' use32
.text$x:0000AB44                 assume cs:_text$x
.text$x:0000AB44                 ;org 0AB44h
.text$x:0000AB44 ; COMDAT (pick associative to section at AADC)
.text$x:0000AB44                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000AB44
.text$x:0000AB44 ; =============== S U B R O U T I N E =======================================
.text$x:0000AB44
.text$x:0000AB44
.text$x:0000AB44 __unwindfunclet$?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ$0 proc near
.text$x:0000AB44                                         ; DATA XREF: .xdata$x:0000CA78o
.text$x:0000AB44                 mov     eax, [ebp-14h]
.text$x:0000AB47                 and     eax, 1
.text$x:0000AB4A                 jz      $LN4
.text$x:0000AB50                 and     dword ptr [ebp-14h], 0FFFFFFFEh
.text$x:0000AB54                 mov     ecx, [ebp+8]
.text$x:0000AB57                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:0000AB5C ; ---------------------------------------------------------------------------
.text$x:0000AB5C
.text$x:0000AB5C $LN4:                                   ; CODE XREF: __unwindfunclet$?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ$0+6j
.text$x:0000AB5C                 retn
.text$x:0000AB5C __unwindfunclet$?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ$0 endp
.text$x:0000AB5C
.text$x:0000AB5D
.text$x:0000AB5D ; =============== S U B R O U T I N E =======================================
.text$x:0000AB5D
.text$x:0000AB5D
.text$x:0000AB5D __ehhandler$?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ proc near
.text$x:0000AB5D                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::begin(void)+5o
.text$x:0000AB5D
.text$x:0000AB5D arg_4           = dword ptr  8
.text$x:0000AB5D
.text$x:0000AB5D                 mov     edx, [esp+arg_4]
.text$x:0000AB61                 lea     eax, [edx+0Ch]
.text$x:0000AB64                 mov     ecx, [edx-0Ch]
.text$x:0000AB67                 xor     ecx, eax
.text$x:0000AB69                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000AB6E                 mov     eax, offset __ehfuncinfo$?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ
.text$x:0000AB73                 jmp     ___CxxFrameHandler3
.text$x:0000AB73 __ehhandler$?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ endp
.text$x:0000AB73
.text$x:0000AB73 _text$x         ends
.text$x:0000AB73
.text$mn:0000AB78 ; ===========================================================================
.text$mn:0000AB78
.text$mn:0000AB78 ; Segment type: Pure code
.text$mn:0000AB78 ; Segment permissions: Read/Execute
.text$mn:0000AB78 _text$mn        segment para public 'CODE' use32
.text$mn:0000AB78                 assume cs:_text$mn
.text$mn:0000AB78                 ;org 0AB78h
.text$mn:0000AB78 ; COMDAT (pick any)
.text$mn:0000AB78                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000AB78
.text$mn:0000AB78 ; =============== S U B R O U T I N E =======================================
.text$mn:0000AB78
.text$mn:0000AB78 ; Attributes: bp-based frame
.text$mn:0000AB78
.text$mn:0000AB78 ; public: class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<int>>> __thiscall std::vector<int, class std::allocator<int>>::begin(void)
.text$mn:0000AB78                 public ?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ
.text$mn:0000AB78 ?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ proc near
.text$mn:0000AB78                                         ; CODE XREF: WindowsDlg::run_dlgProc(uint,uint,long)+519p
.text$mn:0000AB78                                         ; WindowsDlg::resetSelection(void)+4Ap ...
.text$mn:0000AB78
.text$mn:0000AB78 var_14          = dword ptr -14h
.text$mn:0000AB78 var_10          = dword ptr -10h
.text$mn:0000AB78 var_C           = dword ptr -0Ch
.text$mn:0000AB78 var_4           = dword ptr -4
.text$mn:0000AB78 arg_0           = dword ptr  8
.text$mn:0000AB78
.text$mn:0000AB78                 push    ebp
.text$mn:0000AB79                 mov     ebp, esp
.text$mn:0000AB7B                 push    0FFFFFFFFh
.text$mn:0000AB7D                 push    offset __ehhandler$?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ
.text$mn:0000AB82                 mov     eax, large fs:0
.text$mn:0000AB88                 push    eax
.text$mn:0000AB89                 sub     esp, 8
.text$mn:0000AB8C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000AB91                 xor     eax, ebp
.text$mn:0000AB93                 push    eax
.text$mn:0000AB94                 lea     eax, [ebp+var_C]
.text$mn:0000AB97                 mov     large fs:0, eax
.text$mn:0000AB9D                 mov     [ebp+var_10], ecx
.text$mn:0000ABA0                 mov     [ebp+var_14], 0
.text$mn:0000ABA7                 mov     eax, [ebp+var_10]
.text$mn:0000ABAA                 push    eax             ; struct std::_Container_base12 *
.text$mn:0000ABAB                 mov     ecx, [ebp+var_10]
.text$mn:0000ABAE                 mov     edx, [ecx+4]
.text$mn:0000ABB1                 push    edx             ; int
.text$mn:0000ABB2                 mov     ecx, [ebp+arg_0]
.text$mn:0000ABB5                 call    ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(int *,std::_Container_base12 const *)
.text$mn:0000ABBA                 mov     [ebp+var_4], 0
.text$mn:0000ABC1                 mov     eax, [ebp+var_14]
.text$mn:0000ABC4                 or      eax, 1
.text$mn:0000ABC7                 mov     [ebp+var_14], eax
.text$mn:0000ABCA                 mov     eax, [ebp+arg_0]
.text$mn:0000ABCD                 mov     ecx, [ebp+var_C]
.text$mn:0000ABD0                 mov     large fs:0, ecx
.text$mn:0000ABD7                 pop     ecx
.text$mn:0000ABD8                 mov     esp, ebp
.text$mn:0000ABDA                 pop     ebp
.text$mn:0000ABDB                 retn    4
.text$mn:0000ABDB ?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ endp
.text$mn:0000ABDB
.text$mn:0000ABDB ; ---------------------------------------------------------------------------
.text$mn:0000ABDE                 align 10h
.text$mn:0000ABDE _text$mn        ends
.text$mn:0000ABDE
.text$x:0000ABE0 ; ===========================================================================
.text$x:0000ABE0
.text$x:0000ABE0 ; Segment type: Pure code
.text$x:0000ABE0 ; Segment permissions: Read/Execute
.text$x:0000ABE0 _text$x         segment para public 'CODE' use32
.text$x:0000ABE0                 assume cs:_text$x
.text$x:0000ABE0                 ;org 0ABE0h
.text$x:0000ABE0 ; COMDAT (pick associative to section at AB78)
.text$x:0000ABE0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000ABE0
.text$x:0000ABE0 ; =============== S U B R O U T I N E =======================================
.text$x:0000ABE0
.text$x:0000ABE0
.text$x:0000ABE0 __unwindfunclet$?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ$0 proc near
.text$x:0000ABE0                                         ; DATA XREF: .xdata$x:0000CE30o
.text$x:0000ABE0                 mov     eax, [ebp-14h]
.text$x:0000ABE3                 and     eax, 1
.text$x:0000ABE6                 jz      $LN4_1
.text$x:0000ABEC                 and     dword ptr [ebp-14h], 0FFFFFFFEh
.text$x:0000ABF0                 mov     ecx, [ebp+8]
.text$x:0000ABF3                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$x:0000ABF8 ; ---------------------------------------------------------------------------
.text$x:0000ABF8
.text$x:0000ABF8 $LN4_1:                                 ; CODE XREF: __unwindfunclet$?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ$0+6j
.text$x:0000ABF8                 retn
.text$x:0000ABF8 __unwindfunclet$?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ$0 endp
.text$x:0000ABF8
.text$x:0000ABF9
.text$x:0000ABF9 ; =============== S U B R O U T I N E =======================================
.text$x:0000ABF9
.text$x:0000ABF9
.text$x:0000ABF9 __ehhandler$?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ proc near
.text$x:0000ABF9                                         ; DATA XREF: std::vector<int,std::allocator<int>>::begin(void)+5o
.text$x:0000ABF9
.text$x:0000ABF9 arg_4           = dword ptr  8
.text$x:0000ABF9
.text$x:0000ABF9                 mov     edx, [esp+arg_4]
.text$x:0000ABFD                 lea     eax, [edx+0Ch]
.text$x:0000AC00                 mov     ecx, [edx-0Ch]
.text$x:0000AC03                 xor     ecx, eax
.text$x:0000AC05                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000AC0A                 mov     eax, offset __ehfuncinfo$?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ
.text$x:0000AC0F                 jmp     ___CxxFrameHandler3
.text$x:0000AC0F __ehhandler$?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ endp
.text$x:0000AC0F
.text$x:0000AC0F _text$x         ends
.text$x:0000AC0F
.text$mn:0000AC14 ; ===========================================================================
.text$mn:0000AC14
.text$mn:0000AC14 ; Segment type: Pure code
.text$mn:0000AC14 ; Segment permissions: Read/Execute
.text$mn:0000AC14 _text$mn        segment para public 'CODE' use32
.text$mn:0000AC14                 assume cs:_text$mn
.text$mn:0000AC14                 ;org 0AC14h
.text$mn:0000AC14 ; COMDAT (pick any)
.text$mn:0000AC14                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000AC14
.text$mn:0000AC14 ; =============== S U B R O U T I N E =======================================
.text$mn:0000AC14
.text$mn:0000AC14 ; Attributes: bp-based frame
.text$mn:0000AC14
.text$mn:0000AC14 ; public: char const * __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::c_str(void)const
.text$mn:0000AC14                 public ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
.text$mn:0000AC14 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ proc near
.text$mn:0000AC14                                         ; CODE XREF: TiXmlDeclarationA::Encoding(void)+Dp
.text$mn:0000AC14
.text$mn:0000AC14 var_4           = dword ptr -4
.text$mn:0000AC14
.text$mn:0000AC14                 push    ebp
.text$mn:0000AC15                 mov     ebp, esp
.text$mn:0000AC17                 push    ecx
.text$mn:0000AC18                 mov     [ebp+var_4], ecx
.text$mn:0000AC1B                 mov     ecx, [ebp+var_4]
.text$mn:0000AC1E                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000AC23                 mov     esp, ebp
.text$mn:0000AC25                 pop     ebp
.text$mn:0000AC26                 retn
.text$mn:0000AC26 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ endp
.text$mn:0000AC26
.text$mn:0000AC26 ; ---------------------------------------------------------------------------
.text$mn:0000AC27                 align 4
.text$mn:0000AC27 _text$mn        ends
.text$mn:0000AC27
.text$mn:0000AC28 ; ===========================================================================
.text$mn:0000AC28
.text$mn:0000AC28 ; Segment type: Pure code
.text$mn:0000AC28 ; Segment permissions: Read/Execute
.text$mn:0000AC28 _text$mn        segment para public 'CODE' use32
.text$mn:0000AC28                 assume cs:_text$mn
.text$mn:0000AC28                 ;org 0AC28h
.text$mn:0000AC28 ; COMDAT (pick any)
.text$mn:0000AC28                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000AC28
.text$mn:0000AC28 ; =============== S U B R O U T I N E =======================================
.text$mn:0000AC28
.text$mn:0000AC28 ; Attributes: bp-based frame
.text$mn:0000AC28
.text$mn:0000AC28 ; public: wchar_t const * __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::c_str(void)const
.text$mn:0000AC28                 public ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ
.text$mn:0000AC28 ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ proc near
.text$mn:0000AC28                                         ; CODE XREF: WindowsMenu::init(HINSTANCE__ *,HMENU__ *,wchar_t const *)+7Ep
.text$mn:0000AC28                                         ; Buffer::getFullPathName(void)+10p ...
.text$mn:0000AC28
.text$mn:0000AC28 var_4           = dword ptr -4
.text$mn:0000AC28
.text$mn:0000AC28                 push    ebp
.text$mn:0000AC29                 mov     ebp, esp
.text$mn:0000AC2B                 push    ecx
.text$mn:0000AC2C                 mov     [ebp+var_4], ecx
.text$mn:0000AC2F                 mov     ecx, [ebp+var_4]
.text$mn:0000AC32                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000AC37                 mov     esp, ebp
.text$mn:0000AC39                 pop     ebp
.text$mn:0000AC3A                 retn
.text$mn:0000AC3A ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ endp
.text$mn:0000AC3A
.text$mn:0000AC3A ; ---------------------------------------------------------------------------
.text$mn:0000AC3B                 align 4
.text$mn:0000AC3B _text$mn        ends
.text$mn:0000AC3B
.text$mn:0000AC3C ; ===========================================================================
.text$mn:0000AC3C
.text$mn:0000AC3C ; Segment type: Pure code
.text$mn:0000AC3C ; Segment permissions: Read/Execute
.text$mn:0000AC3C _text$mn        segment para public 'CODE' use32
.text$mn:0000AC3C                 assume cs:_text$mn
.text$mn:0000AC3C                 ;org 0AC3Ch
.text$mn:0000AC3C ; COMDAT (pick any)
.text$mn:0000AC3C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000AC3C
.text$mn:0000AC3C ; =============== S U B R O U T I N E =======================================
.text$mn:0000AC3C
.text$mn:0000AC3C ; Attributes: bp-based frame
.text$mn:0000AC3C
.text$mn:0000AC3C ; public: unsigned int __thiscall std::vector<int, class std::allocator<int>>::capacity(void)const
.text$mn:0000AC3C                 public ?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
.text$mn:0000AC3C ?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ proc near
.text$mn:0000AC3C                                         ; CODE XREF: std::vector<int,std::allocator<int>>::_Grow_to(uint)+Cp
.text$mn:0000AC3C
.text$mn:0000AC3C var_4           = dword ptr -4
.text$mn:0000AC3C
.text$mn:0000AC3C                 push    ebp
.text$mn:0000AC3D                 mov     ebp, esp
.text$mn:0000AC3F                 push    ecx
.text$mn:0000AC40                 mov     [ebp+var_4], ecx
.text$mn:0000AC43                 mov     eax, [ebp+var_4]
.text$mn:0000AC46                 mov     ecx, [ebp+var_4]
.text$mn:0000AC49                 mov     eax, [eax+0Ch]
.text$mn:0000AC4C                 sub     eax, [ecx+4]
.text$mn:0000AC4F                 sar     eax, 2
.text$mn:0000AC52                 mov     esp, ebp
.text$mn:0000AC54                 pop     ebp
.text$mn:0000AC55                 retn
.text$mn:0000AC55 ?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ endp
.text$mn:0000AC55
.text$mn:0000AC55 ; ---------------------------------------------------------------------------
.text$mn:0000AC56                 align 4
.text$mn:0000AC56 _text$mn        ends
.text$mn:0000AC56
.text$mn:0000AC58 ; ===========================================================================
.text$mn:0000AC58
.text$mn:0000AC58 ; Segment type: Pure code
.text$mn:0000AC58 ; Segment permissions: Read/Execute
.text$mn:0000AC58 _text$mn        segment para public 'CODE' use32
.text$mn:0000AC58                 assume cs:_text$mn
.text$mn:0000AC58                 ;org 0AC58h
.text$mn:0000AC58 ; COMDAT (pick any)
.text$mn:0000AC58                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000AC58
.text$mn:0000AC58 ; =============== S U B R O U T I N E =======================================
.text$mn:0000AC58
.text$mn:0000AC58 ; Attributes: bp-based frame
.text$mn:0000AC58
.text$mn:0000AC58 ; public: unsigned int __thiscall std::vector<wchar_t, class std::allocator<wchar_t>>::capacity(void)const
.text$mn:0000AC58                 public ?capacity@?$vector@_WV?$allocator@_W@std@@@std@@QBEIXZ
.text$mn:0000AC58 ?capacity@?$vector@_WV?$allocator@_W@std@@@std@@QBEIXZ proc near
.text$mn:0000AC58                                         ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::_Grow_to(uint)+Cp
.text$mn:0000AC58
.text$mn:0000AC58 var_4           = dword ptr -4
.text$mn:0000AC58
.text$mn:0000AC58                 push    ebp
.text$mn:0000AC59                 mov     ebp, esp
.text$mn:0000AC5B                 push    ecx
.text$mn:0000AC5C                 mov     [ebp+var_4], ecx
.text$mn:0000AC5F                 mov     eax, [ebp+var_4]
.text$mn:0000AC62                 mov     ecx, [ebp+var_4]
.text$mn:0000AC65                 mov     eax, [eax+0Ch]
.text$mn:0000AC68                 sub     eax, [ecx+4]
.text$mn:0000AC6B                 sar     eax, 1
.text$mn:0000AC6D                 mov     esp, ebp
.text$mn:0000AC6F                 pop     ebp
.text$mn:0000AC70                 retn
.text$mn:0000AC70 ?capacity@?$vector@_WV?$allocator@_W@std@@@std@@QBEIXZ endp
.text$mn:0000AC70
.text$mn:0000AC70 ; ---------------------------------------------------------------------------
.text$mn:0000AC71                 align 4
.text$mn:0000AC71 _text$mn        ends
.text$mn:0000AC71
.text$mn:0000AC74 ; ===========================================================================
.text$mn:0000AC74
.text$mn:0000AC74 ; Segment type: Pure code
.text$mn:0000AC74 ; Segment permissions: Read/Execute
.text$mn:0000AC74 _text$mn        segment para public 'CODE' use32
.text$mn:0000AC74                 assume cs:_text$mn
.text$mn:0000AC74                 ;org 0AC74h
.text$mn:0000AC74 ; COMDAT (pick any)
.text$mn:0000AC74                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000AC74
.text$mn:0000AC74 ; =============== S U B R O U T I N E =======================================
.text$mn:0000AC74
.text$mn:0000AC74 ; Attributes: bp-based frame
.text$mn:0000AC74
.text$mn:0000AC74 ; const struct std::error_category *__thiscall std::error_code::category(std::error_code *__hidden this)
.text$mn:0000AC74                 public ?category@error_code@std@@QBEABVerror_category@2@XZ
.text$mn:0000AC74 ?category@error_code@std@@QBEABVerror_category@2@XZ proc near
.text$mn:0000AC74                                         ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+Cp
.text$mn:0000AC74
.text$mn:0000AC74 var_4           = dword ptr -4
.text$mn:0000AC74
.text$mn:0000AC74                 push    ebp
.text$mn:0000AC75                 mov     ebp, esp
.text$mn:0000AC77                 push    ecx
.text$mn:0000AC78                 mov     [ebp+var_4], ecx
.text$mn:0000AC7B                 mov     eax, [ebp+var_4]
.text$mn:0000AC7E                 mov     eax, [eax+4]
.text$mn:0000AC81                 mov     esp, ebp
.text$mn:0000AC83                 pop     ebp
.text$mn:0000AC84                 retn
.text$mn:0000AC84 ?category@error_code@std@@QBEABVerror_category@2@XZ endp
.text$mn:0000AC84
.text$mn:0000AC84 ; ---------------------------------------------------------------------------
.text$mn:0000AC85                 align 4
.text$mn:0000AC85 _text$mn        ends
.text$mn:0000AC85
.text$mn:0000AC88 ; ===========================================================================
.text$mn:0000AC88
.text$mn:0000AC88 ; Segment type: Pure code
.text$mn:0000AC88 ; Segment permissions: Read/Execute
.text$mn:0000AC88 _text$mn        segment para public 'CODE' use32
.text$mn:0000AC88                 assume cs:_text$mn
.text$mn:0000AC88                 ;org 0AC88h
.text$mn:0000AC88 ; COMDAT (pick any)
.text$mn:0000AC88                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000AC88
.text$mn:0000AC88 ; =============== S U B R O U T I N E =======================================
.text$mn:0000AC88
.text$mn:0000AC88 ; Attributes: bp-based frame
.text$mn:0000AC88
.text$mn:0000AC88 ; const struct std::error_category *__thiscall std::error_condition::category(std::error_condition *__hidden this)
.text$mn:0000AC88                 public ?category@error_condition@std@@QBEABVerror_category@2@XZ
.text$mn:0000AC88 ?category@error_condition@std@@QBEABVerror_category@2@XZ proc near
.text$mn:0000AC88                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+Dp
.text$mn:0000AC88                                         ; std::error_condition::operator==(std::error_condition const &)+16p
.text$mn:0000AC88
.text$mn:0000AC88 var_4           = dword ptr -4
.text$mn:0000AC88
.text$mn:0000AC88                 push    ebp
.text$mn:0000AC89                 mov     ebp, esp
.text$mn:0000AC8B                 push    ecx
.text$mn:0000AC8C                 mov     [ebp+var_4], ecx
.text$mn:0000AC8F                 mov     eax, [ebp+var_4]
.text$mn:0000AC92                 mov     eax, [eax+4]
.text$mn:0000AC95                 mov     esp, ebp
.text$mn:0000AC97                 pop     ebp
.text$mn:0000AC98                 retn
.text$mn:0000AC98 ?category@error_condition@std@@QBEABVerror_category@2@XZ endp
.text$mn:0000AC98
.text$mn:0000AC98 ; ---------------------------------------------------------------------------
.text$mn:0000AC99                 align 4
.text$mn:0000AC99 _text$mn        ends
.text$mn:0000AC99
.text$mn:0000AC9C ; ===========================================================================
.text$mn:0000AC9C
.text$mn:0000AC9C ; Segment type: Pure code
.text$mn:0000AC9C ; Segment permissions: Read/Execute
.text$mn:0000AC9C _text$mn        segment para public 'CODE' use32
.text$mn:0000AC9C                 assume cs:_text$mn
.text$mn:0000AC9C                 ;org 0AC9Ch
.text$mn:0000AC9C ; COMDAT (pick any)
.text$mn:0000AC9C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000AC9C
.text$mn:0000AC9C ; =============== S U B R O U T I N E =======================================
.text$mn:0000AC9C
.text$mn:0000AC9C ; Attributes: bp-based frame
.text$mn:0000AC9C
.text$mn:0000AC9C ; public: void __thiscall std::vector<int, class std::allocator<int>>::clear(void)
.text$mn:0000AC9C                 public ?clear@?$vector@HV?$allocator@H@std@@@std@@QAEXXZ
.text$mn:0000AC9C ?clear@?$vector@HV?$allocator@H@std@@@std@@QAEXXZ proc near
.text$mn:0000AC9C                                         ; CODE XREF: WindowsDlg::doSortToTabs(void)+188p
.text$mn:0000AC9C                                         ; std::vector<int,std::allocator<int>>::erase(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>)+109p
.text$mn:0000AC9C
.text$mn:0000AC9C var_4           = dword ptr -4
.text$mn:0000AC9C
.text$mn:0000AC9C                 push    ebp
.text$mn:0000AC9D                 mov     ebp, esp
.text$mn:0000AC9F                 push    ecx
.text$mn:0000ACA0                 mov     [ebp+var_4], ecx
.text$mn:0000ACA3                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000ACA6                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:0000ACAB                 mov     eax, [ebp+var_4]
.text$mn:0000ACAE                 mov     ecx, [eax+8]
.text$mn:0000ACB1                 push    ecx
.text$mn:0000ACB2                 mov     edx, [ebp+var_4]
.text$mn:0000ACB5                 mov     eax, [edx+4]
.text$mn:0000ACB8                 push    eax
.text$mn:0000ACB9                 mov     ecx, [ebp+var_4]
.text$mn:0000ACBC                 call    ?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z ; std::vector<int,std::allocator<int>>::_Destroy(int *,int *)
.text$mn:0000ACC1                 mov     ecx, [ebp+var_4]
.text$mn:0000ACC4                 mov     edx, [ebp+var_4]
.text$mn:0000ACC7                 mov     eax, [edx+4]
.text$mn:0000ACCA                 mov     [ecx+8], eax
.text$mn:0000ACCD                 mov     esp, ebp
.text$mn:0000ACCF                 pop     ebp
.text$mn:0000ACD0                 retn
.text$mn:0000ACD0 ?clear@?$vector@HV?$allocator@H@std@@@std@@QAEXXZ endp
.text$mn:0000ACD0
.text$mn:0000ACD0 ; ---------------------------------------------------------------------------
.text$mn:0000ACD1                 align 4
.text$mn:0000ACD1 _text$mn        ends
.text$mn:0000ACD1
.text$mn:0000ACD4 ; ===========================================================================
.text$mn:0000ACD4
.text$mn:0000ACD4 ; Segment type: Pure code
.text$mn:0000ACD4 ; Segment permissions: Read/Execute
.text$mn:0000ACD4 _text$mn        segment para public 'CODE' use32
.text$mn:0000ACD4                 assume cs:_text$mn
.text$mn:0000ACD4                 ;org 0ACD4h
.text$mn:0000ACD4 ; COMDAT (pick any)
.text$mn:0000ACD4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000ACD4
.text$mn:0000ACD4 ; =============== S U B R O U T I N E =======================================
.text$mn:0000ACD4
.text$mn:0000ACD4 ; Attributes: bp-based frame
.text$mn:0000ACD4
.text$mn:0000ACD4 ; bool __thiscall BufferEquivalent::compare(BufferEquivalent *this, int, int)
.text$mn:0000ACD4                 public ?compare@BufferEquivalent@@QBE_NHH@Z
.text$mn:0000ACD4 ?compare@BufferEquivalent@@QBE_NHH@Z proc near
.text$mn:0000ACD4                                         ; CODE XREF: BufferEquivalent::operator()(int,int)+39p
.text$mn:0000ACD4
.text$mn:0000ACD4 var_30          = dword ptr -30h
.text$mn:0000ACD4 var_2C          = dword ptr -2Ch
.text$mn:0000ACD4 var_28          = dword ptr -28h
.text$mn:0000ACD4 var_24          = dword ptr -24h
.text$mn:0000ACD4 Str             = dword ptr -20h
.text$mn:0000ACD4 var_1C          = dword ptr -1Ch
.text$mn:0000ACD4 var_18          = dword ptr -18h
.text$mn:0000ACD4 var_14          = dword ptr -14h
.text$mn:0000ACD4 var_10          = dword ptr -10h
.text$mn:0000ACD4 var_C           = dword ptr -0Ch
.text$mn:0000ACD4 var_8           = dword ptr -8
.text$mn:0000ACD4 var_4           = dword ptr -4
.text$mn:0000ACD4 arg_0           = dword ptr  8
.text$mn:0000ACD4 arg_4           = dword ptr  0Ch
.text$mn:0000ACD4
.text$mn:0000ACD4                 push    ebp
.text$mn:0000ACD5                 mov     ebp, esp
.text$mn:0000ACD7                 sub     esp, 30h
.text$mn:0000ACDA                 mov     [ebp+var_4], ecx
.text$mn:0000ACDD                 mov     eax, [ebp+arg_0]
.text$mn:0000ACE0                 push    eax             ; int
.text$mn:0000ACE1                 mov     ecx, [ebp+var_4]
.text$mn:0000ACE4                 mov     ecx, [ecx+4]    ; this
.text$mn:0000ACE7                 call    ?getBufferByIndex@DocTabView@@QAEPAVBuffer@@H@Z ; DocTabView::getBufferByIndex(int)
.text$mn:0000ACEC                 mov     [ebp+var_14], eax
.text$mn:0000ACEF                 mov     edx, [ebp+arg_4]
.text$mn:0000ACF2                 push    edx             ; int
.text$mn:0000ACF3                 mov     eax, [ebp+var_4]
.text$mn:0000ACF6                 mov     ecx, [eax+4]    ; this
.text$mn:0000ACF9                 call    ?getBufferByIndex@DocTabView@@QAEPAVBuffer@@H@Z ; DocTabView::getBufferByIndex(int)
.text$mn:0000ACFE                 mov     [ebp+var_18], eax
.text$mn:0000AD01                 mov     ecx, [ebp+var_14]
.text$mn:0000AD04                 push    ecx             ; struct Buffer *
.text$mn:0000AD05                 call    ?getInstance@FileManager@@SAPAV1@XZ ; FileManager::getInstance(void)
.text$mn:0000AD0A                 mov     ecx, eax        ; this
.text$mn:0000AD0C                 call    ?getBufferByID@FileManager@@QAEPAVBuffer@@PAV2@@Z ; FileManager::getBufferByID(Buffer *)
.text$mn:0000AD11                 mov     [ebp+var_8], eax
.text$mn:0000AD14                 mov     edx, [ebp+var_18]
.text$mn:0000AD17                 push    edx             ; struct Buffer *
.text$mn:0000AD18                 call    ?getInstance@FileManager@@SAPAV1@XZ ; FileManager::getInstance(void)
.text$mn:0000AD1D                 mov     ecx, eax        ; this
.text$mn:0000AD1F                 call    ?getBufferByID@FileManager@@QAEPAVBuffer@@PAV2@@Z ; FileManager::getBufferByID(Buffer *)
.text$mn:0000AD24                 mov     [ebp+var_C], eax
.text$mn:0000AD27                 mov     eax, [ebp+var_4]
.text$mn:0000AD2A                 cmp     dword ptr [eax+8], 0
.text$mn:0000AD2E                 jnz     short loc_AD5A
.text$mn:0000AD30                 mov     ecx, [ebp+var_8] ; this
.text$mn:0000AD33                 call    ?getFileName@Buffer@@QBEPB_WXZ ; Buffer::getFileName(void)
.text$mn:0000AD38                 mov     [ebp+Str], eax
.text$mn:0000AD3B                 mov     ecx, [ebp+var_C] ; this
.text$mn:0000AD3E                 call    ?getFileName@Buffer@@QBEPB_WXZ ; Buffer::getFileName(void)
.text$mn:0000AD43                 mov     [ebp+var_1C], eax
.text$mn:0000AD46                 mov     ecx, [ebp+var_1C]
.text$mn:0000AD49                 push    ecx             ; wchar_t *
.text$mn:0000AD4A                 mov     edx, [ebp+Str]
.text$mn:0000AD4D                 push    edx             ; Str
.text$mn:0000AD4E                 mov     ecx, [ebp+var_4]
.text$mn:0000AD51                 call    ??RNumericStringEquivalence@@QBE_NPB_W0@Z ; NumericStringEquivalence::operator()(wchar_t const *,wchar_t const *)
.text$mn:0000AD56                 jmp     short loc_ADCB
.text$mn:0000AD58 ; ---------------------------------------------------------------------------
.text$mn:0000AD58                 jmp     short loc_ADC9
.text$mn:0000AD5A ; ---------------------------------------------------------------------------
.text$mn:0000AD5A
.text$mn:0000AD5A loc_AD5A:                               ; CODE XREF: BufferEquivalent::compare(int,int)+5Aj
.text$mn:0000AD5A                 mov     eax, [ebp+var_4]
.text$mn:0000AD5D                 cmp     dword ptr [eax+8], 1
.text$mn:0000AD61                 jnz     short loc_AD8D
.text$mn:0000AD63                 mov     ecx, [ebp+var_8] ; this
.text$mn:0000AD66                 call    ?getFullPathName@Buffer@@QBEPB_WXZ ; Buffer::getFullPathName(void)
.text$mn:0000AD6B                 mov     [ebp+var_28], eax
.text$mn:0000AD6E                 mov     ecx, [ebp+var_C] ; this
.text$mn:0000AD71                 call    ?getFullPathName@Buffer@@QBEPB_WXZ ; Buffer::getFullPathName(void)
.text$mn:0000AD76                 mov     [ebp+var_24], eax
.text$mn:0000AD79                 mov     ecx, [ebp+var_24]
.text$mn:0000AD7C                 push    ecx             ; wchar_t *
.text$mn:0000AD7D                 mov     edx, [ebp+var_28]
.text$mn:0000AD80                 push    edx             ; Str
.text$mn:0000AD81                 mov     ecx, [ebp+var_4]
.text$mn:0000AD84                 call    ??RNumericStringEquivalence@@QBE_NPB_W0@Z ; NumericStringEquivalence::operator()(wchar_t const *,wchar_t const *)
.text$mn:0000AD89                 jmp     short loc_ADCB
.text$mn:0000AD8B ; ---------------------------------------------------------------------------
.text$mn:0000AD8B                 jmp     short loc_ADC9
.text$mn:0000AD8D ; ---------------------------------------------------------------------------
.text$mn:0000AD8D
.text$mn:0000AD8D loc_AD8D:                               ; CODE XREF: BufferEquivalent::compare(int,int)+8Dj
.text$mn:0000AD8D                 mov     eax, [ebp+var_4]
.text$mn:0000AD90                 cmp     dword ptr [eax+8], 2
.text$mn:0000AD94                 jnz     short loc_ADC9
.text$mn:0000AD96                 mov     ecx, [ebp+var_8]
.text$mn:0000AD99                 call    ?getLangType@Buffer@@QBE?AW4LangType@@XZ ; Buffer::getLangType(void)
.text$mn:0000AD9E                 mov     [ebp+var_2C], eax
.text$mn:0000ADA1                 mov     ecx, [ebp+var_C]
.text$mn:0000ADA4                 call    ?getLangType@Buffer@@QBE?AW4LangType@@XZ ; Buffer::getLangType(void)
.text$mn:0000ADA9                 mov     [ebp+var_30], eax
.text$mn:0000ADAC                 mov     ecx, [ebp+var_2C]
.text$mn:0000ADAF                 cmp     ecx, [ebp+var_30]
.text$mn:0000ADB2                 jge     short loc_ADBD
.text$mn:0000ADB4                 mov     [ebp+var_10], 1
.text$mn:0000ADBB                 jmp     short loc_ADC4
.text$mn:0000ADBD ; ---------------------------------------------------------------------------
.text$mn:0000ADBD
.text$mn:0000ADBD loc_ADBD:                               ; CODE XREF: BufferEquivalent::compare(int,int)+DEj
.text$mn:0000ADBD                 mov     [ebp+var_10], 0
.text$mn:0000ADC4
.text$mn:0000ADC4 loc_ADC4:                               ; CODE XREF: BufferEquivalent::compare(int,int)+E7j
.text$mn:0000ADC4                 mov     al, byte ptr [ebp+var_10]
.text$mn:0000ADC7                 jmp     short loc_ADCB
.text$mn:0000ADC9 ; ---------------------------------------------------------------------------
.text$mn:0000ADC9
.text$mn:0000ADC9 loc_ADC9:                               ; CODE XREF: BufferEquivalent::compare(int,int)+84j
.text$mn:0000ADC9                                         ; BufferEquivalent::compare(int,int)+B7j ...
.text$mn:0000ADC9                 xor     al, al
.text$mn:0000ADCB
.text$mn:0000ADCB loc_ADCB:                               ; CODE XREF: BufferEquivalent::compare(int,int)+82j
.text$mn:0000ADCB                                         ; BufferEquivalent::compare(int,int)+B5j ...
.text$mn:0000ADCB                 mov     esp, ebp
.text$mn:0000ADCD                 pop     ebp
.text$mn:0000ADCE                 retn    8
.text$mn:0000ADCE ?compare@BufferEquivalent@@QBE_NHH@Z endp
.text$mn:0000ADCE
.text$mn:0000ADCE ; ---------------------------------------------------------------------------
.text$mn:0000ADD1                 align 4
.text$mn:0000ADD1 _text$mn        ends
.text$mn:0000ADD1
.text$mn:0000ADD4 ; ===========================================================================
.text$mn:0000ADD4
.text$mn:0000ADD4 ; Segment type: Pure code
.text$mn:0000ADD4 ; Segment permissions: Read/Execute
.text$mn:0000ADD4 _text$mn        segment para public 'CODE' use32
.text$mn:0000ADD4                 assume cs:_text$mn
.text$mn:0000ADD4                 ;org 0ADD4h
.text$mn:0000ADD4 ; COMDAT (pick any)
.text$mn:0000ADD4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000ADD4
.text$mn:0000ADD4 ; =============== S U B R O U T I N E =======================================
.text$mn:0000ADD4
.text$mn:0000ADD4 ; Attributes: bp-based frame
.text$mn:0000ADD4
.text$mn:0000ADD4 ; int __cdecl std::char_traits<char>::copy(void *Dst, void *Src, size_t Size)
.text$mn:0000ADD4                 public ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
.text$mn:0000ADD4 ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z proc near ; CODE XREF: $LN19+1Ep
.text$mn:0000ADD4                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+5Dp ...
.text$mn:0000ADD4
.text$mn:0000ADD4 var_4           = dword ptr -4
.text$mn:0000ADD4 Dst             = dword ptr  8
.text$mn:0000ADD4 Src             = dword ptr  0Ch
.text$mn:0000ADD4 Size            = dword ptr  10h
.text$mn:0000ADD4
.text$mn:0000ADD4                 push    ebp
.text$mn:0000ADD5                 mov     ebp, esp
.text$mn:0000ADD7                 push    ecx
.text$mn:0000ADD8                 cmp     [ebp+Size], 0
.text$mn:0000ADDC                 jnz     short loc_ADE6
.text$mn:0000ADDE                 mov     eax, [ebp+Dst]
.text$mn:0000ADE1                 mov     [ebp+var_4], eax
.text$mn:0000ADE4                 jmp     short loc_ADFD
.text$mn:0000ADE6 ; ---------------------------------------------------------------------------
.text$mn:0000ADE6
.text$mn:0000ADE6 loc_ADE6:                               ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+8j
.text$mn:0000ADE6                 mov     ecx, [ebp+Size]
.text$mn:0000ADE9                 push    ecx             ; Size
.text$mn:0000ADEA                 mov     edx, [ebp+Src]
.text$mn:0000ADED                 push    edx             ; Src
.text$mn:0000ADEE                 mov     eax, [ebp+Dst]
.text$mn:0000ADF1                 push    eax             ; Dst
.text$mn:0000ADF2                 call    _memcpy
.text$mn:0000ADF7                 add     esp, 0Ch
.text$mn:0000ADFA                 mov     [ebp+var_4], eax
.text$mn:0000ADFD
.text$mn:0000ADFD loc_ADFD:                               ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+10j
.text$mn:0000ADFD                 mov     eax, [ebp+var_4]
.text$mn:0000AE00                 mov     esp, ebp
.text$mn:0000AE02                 pop     ebp
.text$mn:0000AE03                 retn
.text$mn:0000AE03 ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z endp
.text$mn:0000AE03
.text$mn:0000AE03 _text$mn        ends
.text$mn:0000AE03
.text$mn:0000AE04 ; ===========================================================================
.text$mn:0000AE04
.text$mn:0000AE04 ; Segment type: Pure code
.text$mn:0000AE04 ; Segment permissions: Read/Execute
.text$mn:0000AE04 _text$mn        segment para public 'CODE' use32
.text$mn:0000AE04                 assume cs:_text$mn
.text$mn:0000AE04                 ;org 0AE04h
.text$mn:0000AE04 ; COMDAT (pick any)
.text$mn:0000AE04                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000AE04
.text$mn:0000AE04 ; =============== S U B R O U T I N E =======================================
.text$mn:0000AE04
.text$mn:0000AE04 ; Attributes: bp-based frame
.text$mn:0000AE04
.text$mn:0000AE04 ; int __cdecl std::char_traits<wchar_t>::copy(void *Dst, void *Src, int)
.text$mn:0000AE04                 public ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z
.text$mn:0000AE04 ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z proc near
.text$mn:0000AE04                                         ; CODE XREF: $LN19_0+1Ep
.text$mn:0000AE04                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+5Dp ...
.text$mn:0000AE04
.text$mn:0000AE04 var_4           = dword ptr -4
.text$mn:0000AE04 Dst             = dword ptr  8
.text$mn:0000AE04 Src             = dword ptr  0Ch
.text$mn:0000AE04 arg_8           = dword ptr  10h
.text$mn:0000AE04
.text$mn:0000AE04                 push    ebp
.text$mn:0000AE05                 mov     ebp, esp
.text$mn:0000AE07                 push    ecx
.text$mn:0000AE08                 cmp     [ebp+arg_8], 0
.text$mn:0000AE0C                 jnz     short loc_AE16
.text$mn:0000AE0E                 mov     eax, [ebp+Dst]
.text$mn:0000AE11                 mov     [ebp+var_4], eax
.text$mn:0000AE14                 jmp     short loc_AE2D
.text$mn:0000AE16 ; ---------------------------------------------------------------------------
.text$mn:0000AE16
.text$mn:0000AE16 loc_AE16:                               ; CODE XREF: std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)+8j
.text$mn:0000AE16                 mov     ecx, [ebp+arg_8]
.text$mn:0000AE19                 push    ecx             ; int
.text$mn:0000AE1A                 mov     edx, [ebp+Src]
.text$mn:0000AE1D                 push    edx             ; Src
.text$mn:0000AE1E                 mov     eax, [ebp+Dst]
.text$mn:0000AE21                 push    eax             ; Dst
.text$mn:0000AE22                 call    _wmemcpy
.text$mn:0000AE27                 add     esp, 0Ch
.text$mn:0000AE2A                 mov     [ebp+var_4], eax
.text$mn:0000AE2D
.text$mn:0000AE2D loc_AE2D:                               ; CODE XREF: std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)+10j
.text$mn:0000AE2D                 mov     eax, [ebp+var_4]
.text$mn:0000AE30                 mov     esp, ebp
.text$mn:0000AE32                 pop     ebp
.text$mn:0000AE33                 retn
.text$mn:0000AE33 ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z endp
.text$mn:0000AE33
.text$mn:0000AE33 _text$mn        ends
.text$mn:0000AE33
.text$mn:0000AE34 ; ===========================================================================
.text$mn:0000AE34
.text$mn:0000AE34 ; Segment type: Pure code
.text$mn:0000AE34 ; Segment permissions: Read/Execute
.text$mn:0000AE34 _text$mn        segment para public 'CODE' use32
.text$mn:0000AE34                 assume cs:_text$mn
.text$mn:0000AE34                 ;org 0AE34h
.text$mn:0000AE34 ; COMDAT (pick any)
.text$mn:0000AE34                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000AE34
.text$mn:0000AE34 ; =============== S U B R O U T I N E =======================================
.text$mn:0000AE34
.text$mn:0000AE34 ; Attributes: bp-based frame
.text$mn:0000AE34
.text$mn:0000AE34 ; int __stdcall std::_Wrap_alloc<std::allocator<char>>::deallocate(void *, int)
.text$mn:0000AE34                 public ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
.text$mn:0000AE34 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z proc near
.text$mn:0000AE34                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+81p
.text$mn:0000AE34
.text$mn:0000AE34 var_4           = dword ptr -4
.text$mn:0000AE34 arg_0           = dword ptr  8
.text$mn:0000AE34 arg_4           = dword ptr  0Ch
.text$mn:0000AE34
.text$mn:0000AE34                 push    ebp
.text$mn:0000AE35                 mov     ebp, esp
.text$mn:0000AE37                 push    ecx
.text$mn:0000AE38                 mov     [ebp+var_4], ecx
.text$mn:0000AE3B                 mov     eax, [ebp+arg_4]
.text$mn:0000AE3E                 push    eax             ; int
.text$mn:0000AE3F                 mov     ecx, [ebp+arg_0]
.text$mn:0000AE42                 push    ecx             ; void *
.text$mn:0000AE43                 mov     ecx, [ebp+var_4]
.text$mn:0000AE46                 call    ?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate(char *,uint)
.text$mn:0000AE4B                 mov     esp, ebp
.text$mn:0000AE4D                 pop     ebp
.text$mn:0000AE4E                 retn    8
.text$mn:0000AE4E ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z endp
.text$mn:0000AE4E
.text$mn:0000AE4E ; ---------------------------------------------------------------------------
.text$mn:0000AE51                 align 4
.text$mn:0000AE51 _text$mn        ends
.text$mn:0000AE51
.text$mn:0000AE54 ; ===========================================================================
.text$mn:0000AE54
.text$mn:0000AE54 ; Segment type: Pure code
.text$mn:0000AE54 ; Segment permissions: Read/Execute
.text$mn:0000AE54 _text$mn        segment para public 'CODE' use32
.text$mn:0000AE54                 assume cs:_text$mn
.text$mn:0000AE54                 ;org 0AE54h
.text$mn:0000AE54 ; COMDAT (pick any)
.text$mn:0000AE54                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000AE54
.text$mn:0000AE54 ; =============== S U B R O U T I N E =======================================
.text$mn:0000AE54
.text$mn:0000AE54 ; Attributes: bp-based frame
.text$mn:0000AE54
.text$mn:0000AE54 ; int __stdcall std::_Wrap_alloc<std::allocator<int>>::deallocate(void *, int)
.text$mn:0000AE54                 public ?deallocate@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAEXPAHI@Z
.text$mn:0000AE54 ?deallocate@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAEXPAHI@Z proc near
.text$mn:0000AE54                                         ; CODE XREF: __catch$?_Reallocate@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z$0+16p
.text$mn:0000AE54                                         ; std::vector<int,std::allocator<int>>::_Reallocate(uint)+F5p ...
.text$mn:0000AE54
.text$mn:0000AE54 var_4           = dword ptr -4
.text$mn:0000AE54 arg_0           = dword ptr  8
.text$mn:0000AE54 arg_4           = dword ptr  0Ch
.text$mn:0000AE54
.text$mn:0000AE54                 push    ebp
.text$mn:0000AE55                 mov     ebp, esp
.text$mn:0000AE57                 push    ecx
.text$mn:0000AE58                 mov     [ebp+var_4], ecx
.text$mn:0000AE5B                 mov     eax, [ebp+arg_4]
.text$mn:0000AE5E                 push    eax             ; int
.text$mn:0000AE5F                 mov     ecx, [ebp+arg_0]
.text$mn:0000AE62                 push    ecx             ; void *
.text$mn:0000AE63                 mov     ecx, [ebp+var_4]
.text$mn:0000AE66                 call    ?deallocate@?$allocator@H@std@@QAEXPAHI@Z ; std::allocator<int>::deallocate(int *,uint)
.text$mn:0000AE6B                 mov     esp, ebp
.text$mn:0000AE6D                 pop     ebp
.text$mn:0000AE6E                 retn    8
.text$mn:0000AE6E ?deallocate@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAEXPAHI@Z endp
.text$mn:0000AE6E
.text$mn:0000AE6E ; ---------------------------------------------------------------------------
.text$mn:0000AE71                 align 4
.text$mn:0000AE71 _text$mn        ends
.text$mn:0000AE71
.text$mn:0000AE74 ; ===========================================================================
.text$mn:0000AE74
.text$mn:0000AE74 ; Segment type: Pure code
.text$mn:0000AE74 ; Segment permissions: Read/Execute
.text$mn:0000AE74 _text$mn        segment para public 'CODE' use32
.text$mn:0000AE74                 assume cs:_text$mn
.text$mn:0000AE74                 ;org 0AE74h
.text$mn:0000AE74 ; COMDAT (pick any)
.text$mn:0000AE74                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000AE74
.text$mn:0000AE74 ; =============== S U B R O U T I N E =======================================
.text$mn:0000AE74
.text$mn:0000AE74 ; Attributes: bp-based frame
.text$mn:0000AE74
.text$mn:0000AE74 ; int __stdcall std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::deallocate(void *, int)
.text$mn:0000AE74                 public ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z
.text$mn:0000AE74 ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z proc near
.text$mn:0000AE74                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>::_Free_proxy(void)+32p
.text$mn:0000AE74                                         ; std::_Vector_alloc<0,std::_Vec_base_types<wchar_t,std::allocator<wchar_t>>>::_Free_proxy(void)+32p
.text$mn:0000AE74
.text$mn:0000AE74 var_4           = dword ptr -4
.text$mn:0000AE74 arg_0           = dword ptr  8
.text$mn:0000AE74 arg_4           = dword ptr  0Ch
.text$mn:0000AE74
.text$mn:0000AE74                 push    ebp
.text$mn:0000AE75                 mov     ebp, esp
.text$mn:0000AE77                 push    ecx
.text$mn:0000AE78                 mov     [ebp+var_4], ecx
.text$mn:0000AE7B                 mov     eax, [ebp+arg_4]
.text$mn:0000AE7E                 push    eax             ; int
.text$mn:0000AE7F                 mov     ecx, [ebp+arg_0]
.text$mn:0000AE82                 push    ecx             ; void *
.text$mn:0000AE83                 mov     ecx, [ebp+var_4]
.text$mn:0000AE86                 call    ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate(std::_Container_proxy *,uint)
.text$mn:0000AE8B                 mov     esp, ebp
.text$mn:0000AE8D                 pop     ebp
.text$mn:0000AE8E                 retn    8
.text$mn:0000AE8E ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z endp
.text$mn:0000AE8E
.text$mn:0000AE8E ; ---------------------------------------------------------------------------
.text$mn:0000AE91                 align 4
.text$mn:0000AE91 _text$mn        ends
.text$mn:0000AE91
.text$mn:0000AE94 ; ===========================================================================
.text$mn:0000AE94
.text$mn:0000AE94 ; Segment type: Pure code
.text$mn:0000AE94 ; Segment permissions: Read/Execute
.text$mn:0000AE94 _text$mn        segment para public 'CODE' use32
.text$mn:0000AE94                 assume cs:_text$mn
.text$mn:0000AE94                 ;org 0AE94h
.text$mn:0000AE94 ; COMDAT (pick any)
.text$mn:0000AE94                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000AE94
.text$mn:0000AE94 ; =============== S U B R O U T I N E =======================================
.text$mn:0000AE94
.text$mn:0000AE94 ; Attributes: bp-based frame
.text$mn:0000AE94
.text$mn:0000AE94 ; int __stdcall std::_Wrap_alloc<std::allocator<wchar_t>>::deallocate(void *, int)
.text$mn:0000AE94                 public ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z
.text$mn:0000AE94 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z proc near
.text$mn:0000AE94                                         ; CODE XREF: __catch$?_Reallocate@?$vector@_WV?$allocator@_W@std@@@std@@IAEXI@Z$0+16p
.text$mn:0000AE94                                         ; std::vector<wchar_t,std::allocator<wchar_t>>::_Reallocate(uint)+F4p ...
.text$mn:0000AE94
.text$mn:0000AE94 var_4           = dword ptr -4
.text$mn:0000AE94 arg_0           = dword ptr  8
.text$mn:0000AE94 arg_4           = dword ptr  0Ch
.text$mn:0000AE94
.text$mn:0000AE94                 push    ebp
.text$mn:0000AE95                 mov     ebp, esp
.text$mn:0000AE97                 push    ecx
.text$mn:0000AE98                 mov     [ebp+var_4], ecx
.text$mn:0000AE9B                 mov     eax, [ebp+arg_4]
.text$mn:0000AE9E                 push    eax             ; int
.text$mn:0000AE9F                 mov     ecx, [ebp+arg_0]
.text$mn:0000AEA2                 push    ecx             ; void *
.text$mn:0000AEA3                 mov     ecx, [ebp+var_4]
.text$mn:0000AEA6                 call    ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z ; std::allocator<wchar_t>::deallocate(wchar_t *,uint)
.text$mn:0000AEAB                 mov     esp, ebp
.text$mn:0000AEAD                 pop     ebp
.text$mn:0000AEAE                 retn    8
.text$mn:0000AEAE ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z endp
.text$mn:0000AEAE
.text$mn:0000AEAE ; ---------------------------------------------------------------------------
.text$mn:0000AEB1                 align 4
.text$mn:0000AEB1 _text$mn        ends
.text$mn:0000AEB1
.text$mn:0000AEB4 ; ===========================================================================
.text$mn:0000AEB4
.text$mn:0000AEB4 ; Segment type: Pure code
.text$mn:0000AEB4 ; Segment permissions: Read/Execute
.text$mn:0000AEB4 _text$mn        segment para public 'CODE' use32
.text$mn:0000AEB4                 assume cs:_text$mn
.text$mn:0000AEB4                 ;org 0AEB4h
.text$mn:0000AEB4 ; COMDAT (pick any)
.text$mn:0000AEB4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000AEB4
.text$mn:0000AEB4 ; =============== S U B R O U T I N E =======================================
.text$mn:0000AEB4
.text$mn:0000AEB4 ; Attributes: bp-based frame
.text$mn:0000AEB4
.text$mn:0000AEB4 ; int __stdcall std::allocator<char>::deallocate(void *, int)
.text$mn:0000AEB4                 public ?deallocate@?$allocator@D@std@@QAEXPADI@Z
.text$mn:0000AEB4 ?deallocate@?$allocator@D@std@@QAEXPADI@Z proc near
.text$mn:0000AEB4                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)+12p
.text$mn:0000AEB4
.text$mn:0000AEB4 var_4           = dword ptr -4
.text$mn:0000AEB4 arg_0           = dword ptr  8
.text$mn:0000AEB4
.text$mn:0000AEB4                 push    ebp
.text$mn:0000AEB5                 mov     ebp, esp
.text$mn:0000AEB7                 push    ecx
.text$mn:0000AEB8                 mov     [ebp+var_4], ecx
.text$mn:0000AEBB                 mov     eax, [ebp+arg_0]
.text$mn:0000AEBE                 push    eax             ; void *
.text$mn:0000AEBF                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:0000AEC4                 add     esp, 4
.text$mn:0000AEC7                 mov     esp, ebp
.text$mn:0000AEC9                 pop     ebp
.text$mn:0000AECA                 retn    8
.text$mn:0000AECA ?deallocate@?$allocator@D@std@@QAEXPADI@Z endp
.text$mn:0000AECA
.text$mn:0000AECA ; ---------------------------------------------------------------------------
.text$mn:0000AECD                 align 10h
.text$mn:0000AECD _text$mn        ends
.text$mn:0000AECD
.text$mn:0000AED0 ; ===========================================================================
.text$mn:0000AED0
.text$mn:0000AED0 ; Segment type: Pure code
.text$mn:0000AED0 ; Segment permissions: Read/Execute
.text$mn:0000AED0 _text$mn        segment para public 'CODE' use32
.text$mn:0000AED0                 assume cs:_text$mn
.text$mn:0000AED0                 ;org 0AED0h
.text$mn:0000AED0 ; COMDAT (pick any)
.text$mn:0000AED0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000AED0
.text$mn:0000AED0 ; =============== S U B R O U T I N E =======================================
.text$mn:0000AED0
.text$mn:0000AED0 ; Attributes: bp-based frame
.text$mn:0000AED0
.text$mn:0000AED0 ; int __stdcall std::allocator<int>::deallocate(void *, int)
.text$mn:0000AED0                 public ?deallocate@?$allocator@H@std@@QAEXPAHI@Z
.text$mn:0000AED0 ?deallocate@?$allocator@H@std@@QAEXPAHI@Z proc near
.text$mn:0000AED0                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<int>>::deallocate(int *,uint)+12p
.text$mn:0000AED0
.text$mn:0000AED0 var_4           = dword ptr -4
.text$mn:0000AED0 arg_0           = dword ptr  8
.text$mn:0000AED0
.text$mn:0000AED0                 push    ebp
.text$mn:0000AED1                 mov     ebp, esp
.text$mn:0000AED3                 push    ecx
.text$mn:0000AED4                 mov     [ebp+var_4], ecx
.text$mn:0000AED7                 mov     eax, [ebp+arg_0]
.text$mn:0000AEDA                 push    eax             ; void *
.text$mn:0000AEDB                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:0000AEE0                 add     esp, 4
.text$mn:0000AEE3                 mov     esp, ebp
.text$mn:0000AEE5                 pop     ebp
.text$mn:0000AEE6                 retn    8
.text$mn:0000AEE6 ?deallocate@?$allocator@H@std@@QAEXPAHI@Z endp
.text$mn:0000AEE6
.text$mn:0000AEE6 ; ---------------------------------------------------------------------------
.text$mn:0000AEE9                 align 4
.text$mn:0000AEE9 _text$mn        ends
.text$mn:0000AEE9
.text$mn:0000AEEC ; ===========================================================================
.text$mn:0000AEEC
.text$mn:0000AEEC ; Segment type: Pure code
.text$mn:0000AEEC ; Segment permissions: Read/Execute
.text$mn:0000AEEC _text$mn        segment para public 'CODE' use32
.text$mn:0000AEEC                 assume cs:_text$mn
.text$mn:0000AEEC                 ;org 0AEECh
.text$mn:0000AEEC ; COMDAT (pick any)
.text$mn:0000AEEC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000AEEC
.text$mn:0000AEEC ; =============== S U B R O U T I N E =======================================
.text$mn:0000AEEC
.text$mn:0000AEEC ; Attributes: bp-based frame
.text$mn:0000AEEC
.text$mn:0000AEEC ; int __stdcall std::allocator<std::_Container_proxy>::deallocate(void *, int)
.text$mn:0000AEEC                 public ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z
.text$mn:0000AEEC ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z proc near
.text$mn:0000AEEC                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+32p
.text$mn:0000AEEC                                         ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Free_proxy(void)+32p ...
.text$mn:0000AEEC
.text$mn:0000AEEC var_4           = dword ptr -4
.text$mn:0000AEEC arg_0           = dword ptr  8
.text$mn:0000AEEC
.text$mn:0000AEEC                 push    ebp
.text$mn:0000AEED                 mov     ebp, esp
.text$mn:0000AEEF                 push    ecx
.text$mn:0000AEF0                 mov     [ebp+var_4], ecx
.text$mn:0000AEF3                 mov     eax, [ebp+arg_0]
.text$mn:0000AEF6                 push    eax             ; void *
.text$mn:0000AEF7                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:0000AEFC                 add     esp, 4
.text$mn:0000AEFF                 mov     esp, ebp
.text$mn:0000AF01                 pop     ebp
.text$mn:0000AF02                 retn    8
.text$mn:0000AF02 ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z endp
.text$mn:0000AF02
.text$mn:0000AF02 ; ---------------------------------------------------------------------------
.text$mn:0000AF05                 align 4
.text$mn:0000AF05 _text$mn        ends
.text$mn:0000AF05
.text$mn:0000AF08 ; ===========================================================================
.text$mn:0000AF08
.text$mn:0000AF08 ; Segment type: Pure code
.text$mn:0000AF08 ; Segment permissions: Read/Execute
.text$mn:0000AF08 _text$mn        segment para public 'CODE' use32
.text$mn:0000AF08                 assume cs:_text$mn
.text$mn:0000AF08                 ;org 0AF08h
.text$mn:0000AF08 ; COMDAT (pick any)
.text$mn:0000AF08                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000AF08
.text$mn:0000AF08 ; =============== S U B R O U T I N E =======================================
.text$mn:0000AF08
.text$mn:0000AF08 ; Attributes: bp-based frame
.text$mn:0000AF08
.text$mn:0000AF08 ; int __stdcall std::allocator<wchar_t>::deallocate(void *, int)
.text$mn:0000AF08                 public ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z
.text$mn:0000AF08 ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z proc near
.text$mn:0000AF08                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::deallocate(wchar_t *,uint)+12p
.text$mn:0000AF08
.text$mn:0000AF08 var_4           = dword ptr -4
.text$mn:0000AF08 arg_0           = dword ptr  8
.text$mn:0000AF08
.text$mn:0000AF08                 push    ebp
.text$mn:0000AF09                 mov     ebp, esp
.text$mn:0000AF0B                 push    ecx
.text$mn:0000AF0C                 mov     [ebp+var_4], ecx
.text$mn:0000AF0F                 mov     eax, [ebp+arg_0]
.text$mn:0000AF12                 push    eax             ; void *
.text$mn:0000AF13                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:0000AF18                 add     esp, 4
.text$mn:0000AF1B                 mov     esp, ebp
.text$mn:0000AF1D                 pop     ebp
.text$mn:0000AF1E                 retn    8
.text$mn:0000AF1E ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z endp
.text$mn:0000AF1E
.text$mn:0000AF1E ; ---------------------------------------------------------------------------
.text$mn:0000AF21                 align 4
.text$mn:0000AF21 _text$mn        ends
.text$mn:0000AF21
.text$mn:0000AF24 ; ===========================================================================
.text$mn:0000AF24
.text$mn:0000AF24 ; Segment type: Pure code
.text$mn:0000AF24 ; Segment permissions: Read/Execute
.text$mn:0000AF24 _text$mn        segment para public 'CODE' use32
.text$mn:0000AF24                 assume cs:_text$mn
.text$mn:0000AF24                 ;org 0AF24h
.text$mn:0000AF24 ; COMDAT (pick any)
.text$mn:0000AF24                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000AF24
.text$mn:0000AF24 ; =============== S U B R O U T I N E =======================================
.text$mn:0000AF24
.text$mn:0000AF24 ; Attributes: bp-based frame
.text$mn:0000AF24
.text$mn:0000AF24 ; public: virtual class std::error_condition __thiscall std::_System_error_category::default_error_condition(int)const
.text$mn:0000AF24                 public ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
.text$mn:0000AF24 ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z proc near
.text$mn:0000AF24                                         ; DATA XREF: .rdata:0000DEE0o
.text$mn:0000AF24
.text$mn:0000AF24 var_4           = dword ptr -4
.text$mn:0000AF24 arg_0           = dword ptr  8
.text$mn:0000AF24 arg_4           = dword ptr  0Ch
.text$mn:0000AF24
.text$mn:0000AF24                 push    ebp
.text$mn:0000AF25                 mov     ebp, esp
.text$mn:0000AF27                 push    ecx
.text$mn:0000AF28                 mov     [ebp+var_4], ecx
.text$mn:0000AF2B                 mov     eax, [ebp+arg_4]
.text$mn:0000AF2E                 push    eax             ; int
.text$mn:0000AF2F                 call    ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map(int)
.text$mn:0000AF34                 add     esp, 4
.text$mn:0000AF37                 test    eax, eax
.text$mn:0000AF39                 jz      short loc_AF54
.text$mn:0000AF3B                 call    ?generic_category@std@@YAABVerror_category@1@XZ ; std::generic_category(void)
.text$mn:0000AF40                 push    eax             ; struct std::error_category *
.text$mn:0000AF41                 mov     ecx, [ebp+arg_4]
.text$mn:0000AF44                 push    ecx             ; int
.text$mn:0000AF45                 mov     ecx, [ebp+arg_0] ; this
.text$mn:0000AF48                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:0000AF4D                 mov     eax, [ebp+arg_0]
.text$mn:0000AF50                 jmp     short loc_AF69
.text$mn:0000AF52 ; ---------------------------------------------------------------------------
.text$mn:0000AF52                 jmp     short loc_AF69
.text$mn:0000AF54 ; ---------------------------------------------------------------------------
.text$mn:0000AF54
.text$mn:0000AF54 loc_AF54:                               ; CODE XREF: std::_System_error_category::default_error_condition(int)+15j
.text$mn:0000AF54                 call    ?system_category@std@@YAABVerror_category@1@XZ ; std::system_category(void)
.text$mn:0000AF59                 push    eax             ; struct std::error_category *
.text$mn:0000AF5A                 mov     edx, [ebp+arg_4]
.text$mn:0000AF5D                 push    edx             ; int
.text$mn:0000AF5E                 mov     ecx, [ebp+arg_0] ; this
.text$mn:0000AF61                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:0000AF66                 mov     eax, [ebp+arg_0]
.text$mn:0000AF69
.text$mn:0000AF69 loc_AF69:                               ; CODE XREF: std::_System_error_category::default_error_condition(int)+2Cj
.text$mn:0000AF69                                         ; std::_System_error_category::default_error_condition(int)+2Ej
.text$mn:0000AF69                 mov     esp, ebp
.text$mn:0000AF6B                 pop     ebp
.text$mn:0000AF6C                 retn    8
.text$mn:0000AF6C ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z endp
.text$mn:0000AF6C
.text$mn:0000AF6C ; ---------------------------------------------------------------------------
.text$mn:0000AF6F                 align 10h
.text$mn:0000AF6F _text$mn        ends
.text$mn:0000AF6F
.text$mn:0000AF70 ; ===========================================================================
.text$mn:0000AF70
.text$mn:0000AF70 ; Segment type: Pure code
.text$mn:0000AF70 ; Segment permissions: Read/Execute
.text$mn:0000AF70 _text$mn        segment para public 'CODE' use32
.text$mn:0000AF70                 assume cs:_text$mn
.text$mn:0000AF70                 ;org 0AF70h
.text$mn:0000AF70 ; COMDAT (pick any)
.text$mn:0000AF70                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000AF70
.text$mn:0000AF70 ; =============== S U B R O U T I N E =======================================
.text$mn:0000AF70
.text$mn:0000AF70 ; Attributes: bp-based frame
.text$mn:0000AF70
.text$mn:0000AF70 ; public: virtual class std::error_condition __thiscall std::error_category::default_error_condition(int)const
.text$mn:0000AF70                 public ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
.text$mn:0000AF70 ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z proc near
.text$mn:0000AF70                                         ; DATA XREF: .rdata:0000DE50o
.text$mn:0000AF70                                         ; .rdata:0000DE6Co ...
.text$mn:0000AF70
.text$mn:0000AF70 var_4           = dword ptr -4
.text$mn:0000AF70 arg_0           = dword ptr  8
.text$mn:0000AF70 arg_4           = dword ptr  0Ch
.text$mn:0000AF70
.text$mn:0000AF70                 push    ebp
.text$mn:0000AF71                 mov     ebp, esp
.text$mn:0000AF73                 push    ecx
.text$mn:0000AF74                 mov     [ebp+var_4], ecx
.text$mn:0000AF77                 mov     eax, [ebp+var_4]
.text$mn:0000AF7A                 push    eax             ; struct std::error_category *
.text$mn:0000AF7B                 mov     ecx, [ebp+arg_4]
.text$mn:0000AF7E                 push    ecx             ; int
.text$mn:0000AF7F                 mov     ecx, [ebp+arg_0] ; this
.text$mn:0000AF82                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:0000AF87                 mov     eax, [ebp+arg_0]
.text$mn:0000AF8A                 mov     esp, ebp
.text$mn:0000AF8C                 pop     ebp
.text$mn:0000AF8D                 retn    8
.text$mn:0000AF8D ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z endp
.text$mn:0000AF8D
.text$mn:0000AF8D _text$mn        ends
.text$mn:0000AF8D
.text$mn:0000AF90 ; ===========================================================================
.text$mn:0000AF90
.text$mn:0000AF90 ; Segment type: Pure code
.text$mn:0000AF90 ; Segment permissions: Read/Execute
.text$mn:0000AF90 _text$mn        segment para public 'CODE' use32
.text$mn:0000AF90                 assume cs:_text$mn
.text$mn:0000AF90                 ;org 0AF90h
.text$mn:0000AF90 ; COMDAT (pick any)
.text$mn:0000AF90                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000AF90
.text$mn:0000AF90 ; =============== S U B R O U T I N E =======================================
.text$mn:0000AF90
.text$mn:0000AF90 ; Attributes: bp-based frame
.text$mn:0000AF90
.text$mn:0000AF90 ; void __thiscall StaticDialog::destroy(StaticDialog *__hidden this)
.text$mn:0000AF90                 public ?destroy@StaticDialog@@UAEXXZ
.text$mn:0000AF90 ?destroy@StaticDialog@@UAEXXZ proc near ; CODE XREF: StaticDialog::~StaticDialog(void)+59p
.text$mn:0000AF90                                         ; DATA XREF: .rdata:0000DE0Co
.text$mn:0000AF90
.text$mn:0000AF90 var_4           = dword ptr -4
.text$mn:0000AF90
.text$mn:0000AF90                 push    ebp
.text$mn:0000AF91                 mov     ebp, esp
.text$mn:0000AF93                 push    ecx
.text$mn:0000AF94                 mov     [ebp+var_4], ecx
.text$mn:0000AF97                 mov     eax, [ebp+var_4]
.text$mn:0000AF9A                 mov     ecx, [eax+0Ch]
.text$mn:0000AF9D                 push    ecx             ; lParam
.text$mn:0000AF9E                 push    1               ; wParam
.text$mn:0000AFA0                 push    7F4h            ; Msg
.text$mn:0000AFA5                 mov     edx, [ebp+var_4]
.text$mn:0000AFA8                 mov     eax, [edx+8]
.text$mn:0000AFAB                 push    eax             ; hWnd
.text$mn:0000AFAC                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:0000AFB2                 mov     ecx, [ebp+var_4]
.text$mn:0000AFB5                 mov     edx, [ecx+0Ch]
.text$mn:0000AFB8                 push    edx             ; hWnd
.text$mn:0000AFB9                 call    dword ptr ds:__imp__DestroyWindow@4 ; DestroyWindow(x)
.text$mn:0000AFBF                 mov     esp, ebp
.text$mn:0000AFC1                 pop     ebp
.text$mn:0000AFC2                 retn
.text$mn:0000AFC2 ?destroy@StaticDialog@@UAEXXZ endp
.text$mn:0000AFC2
.text$mn:0000AFC2 ; ---------------------------------------------------------------------------
.text$mn:0000AFC3                 align 4
.text$mn:0000AFC3 _text$mn        ends
.text$mn:0000AFC3
.text$mn:0000AFC4 ; ===========================================================================
.text$mn:0000AFC4
.text$mn:0000AFC4 ; Segment type: Pure code
.text$mn:0000AFC4 ; Segment permissions: Read/Execute
.text$mn:0000AFC4 _text$mn        segment para public 'CODE' use32
.text$mn:0000AFC4                 assume cs:_text$mn
.text$mn:0000AFC4                 ;org 0AFC4h
.text$mn:0000AFC4 ; COMDAT (pick any)
.text$mn:0000AFC4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000AFC4
.text$mn:0000AFC4 ; =============== S U B R O U T I N E =======================================
.text$mn:0000AFC4
.text$mn:0000AFC4 ; Attributes: bp-based frame
.text$mn:0000AFC4
.text$mn:0000AFC4 ; void __thiscall Window::display(Window *this, bool)
.text$mn:0000AFC4                 public ?display@Window@@UBEX_N@Z
.text$mn:0000AFC4 ?display@Window@@UBEX_N@Z proc near     ; DATA XREF: .rdata:0000DDDCo
.text$mn:0000AFC4
.text$mn:0000AFC4 var_8           = dword ptr -8
.text$mn:0000AFC4 nCmdShow        = dword ptr -4
.text$mn:0000AFC4 arg_0           = byte ptr  8
.text$mn:0000AFC4
.text$mn:0000AFC4                 push    ebp
.text$mn:0000AFC5                 mov     ebp, esp
.text$mn:0000AFC7                 sub     esp, 8
.text$mn:0000AFCA                 mov     [ebp+var_8], ecx
.text$mn:0000AFCD                 movzx   eax, [ebp+arg_0]
.text$mn:0000AFD1                 test    eax, eax
.text$mn:0000AFD3                 jz      short loc_AFDE
.text$mn:0000AFD5                 mov     [ebp+nCmdShow], 5
.text$mn:0000AFDC                 jmp     short loc_AFE5
.text$mn:0000AFDE ; ---------------------------------------------------------------------------
.text$mn:0000AFDE
.text$mn:0000AFDE loc_AFDE:                               ; CODE XREF: Window::display(bool)+Fj
.text$mn:0000AFDE                 mov     [ebp+nCmdShow], 0
.text$mn:0000AFE5
.text$mn:0000AFE5 loc_AFE5:                               ; CODE XREF: Window::display(bool)+18j
.text$mn:0000AFE5                 mov     ecx, [ebp+nCmdShow]
.text$mn:0000AFE8                 push    ecx             ; nCmdShow
.text$mn:0000AFE9                 mov     edx, [ebp+var_8]
.text$mn:0000AFEC                 mov     eax, [edx+0Ch]
.text$mn:0000AFEF                 push    eax             ; hWnd
.text$mn:0000AFF0                 call    dword ptr ds:__imp__ShowWindow@8 ; ShowWindow(x,x)
.text$mn:0000AFF6                 mov     esp, ebp
.text$mn:0000AFF8                 pop     ebp
.text$mn:0000AFF9                 retn    4
.text$mn:0000AFF9 ?display@Window@@UBEX_N@Z endp
.text$mn:0000AFF9
.text$mn:0000AFF9 _text$mn        ends
.text$mn:0000AFF9
.text$mn:0000AFFC ; ===========================================================================
.text$mn:0000AFFC
.text$mn:0000AFFC ; Segment type: Pure code
.text$mn:0000AFFC ; Segment permissions: Read/Execute
.text$mn:0000AFFC _text$mn        segment para public 'CODE' use32
.text$mn:0000AFFC                 assume cs:_text$mn
.text$mn:0000AFFC                 ;org 0AFFCh
.text$mn:0000AFFC ; COMDAT (pick any)
.text$mn:0000AFFC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000AFFC
.text$mn:0000AFFC ; =============== S U B R O U T I N E =======================================
.text$mn:0000AFFC
.text$mn:0000AFFC ; Attributes: bp-based frame
.text$mn:0000AFFC
.text$mn:0000AFFC ; public: class std::_String_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>> __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::end(void)
.text$mn:0000AFFC                 public ?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ
.text$mn:0000AFFC ?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ proc near
.text$mn:0000AFFC                                         ; CODE XREF: WindowsMenu::initPopupMenu(HMENU__ *,DocTabView *)+13Bp
.text$mn:0000AFFC
.text$mn:0000AFFC var_14          = dword ptr -14h
.text$mn:0000AFFC var_10          = dword ptr -10h
.text$mn:0000AFFC var_C           = dword ptr -0Ch
.text$mn:0000AFFC var_4           = dword ptr -4
.text$mn:0000AFFC arg_0           = dword ptr  8
.text$mn:0000AFFC
.text$mn:0000AFFC                 push    ebp
.text$mn:0000AFFD                 mov     ebp, esp
.text$mn:0000AFFF                 push    0FFFFFFFFh
.text$mn:0000B001                 push    offset __ehhandler$?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ
.text$mn:0000B006                 mov     eax, large fs:0
.text$mn:0000B00C                 push    eax
.text$mn:0000B00D                 sub     esp, 8
.text$mn:0000B010                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000B015                 xor     eax, ebp
.text$mn:0000B017                 push    eax
.text$mn:0000B018                 lea     eax, [ebp+var_C]
.text$mn:0000B01B                 mov     large fs:0, eax
.text$mn:0000B021                 mov     [ebp+var_10], ecx
.text$mn:0000B024                 mov     [ebp+var_14], 0
.text$mn:0000B02B                 mov     eax, [ebp+var_10]
.text$mn:0000B02E                 push    eax             ; struct std::_Container_base12 *
.text$mn:0000B02F                 mov     ecx, [ebp+var_10]
.text$mn:0000B032                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000B037                 mov     ecx, [ebp+var_10]
.text$mn:0000B03A                 mov     edx, [ecx+14h]
.text$mn:0000B03D                 lea     eax, [eax+edx*2]
.text$mn:0000B040                 push    eax             ; int
.text$mn:0000B041                 mov     ecx, [ebp+arg_0]
.text$mn:0000B044                 call    ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base12@1@@Z ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(wchar_t *,std::_Container_base12 const *)
.text$mn:0000B049                 mov     [ebp+var_4], 0
.text$mn:0000B050                 mov     ecx, [ebp+var_14]
.text$mn:0000B053                 or      ecx, 1
.text$mn:0000B056                 mov     [ebp+var_14], ecx
.text$mn:0000B059                 mov     eax, [ebp+arg_0]
.text$mn:0000B05C                 mov     ecx, [ebp+var_C]
.text$mn:0000B05F                 mov     large fs:0, ecx
.text$mn:0000B066                 pop     ecx
.text$mn:0000B067                 mov     esp, ebp
.text$mn:0000B069                 pop     ebp
.text$mn:0000B06A                 retn    4
.text$mn:0000B06A ?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ endp
.text$mn:0000B06A
.text$mn:0000B06A ; ---------------------------------------------------------------------------
.text$mn:0000B06D                 align 10h
.text$mn:0000B06D _text$mn        ends
.text$mn:0000B06D
.text$x:0000B070 ; ===========================================================================
.text$x:0000B070
.text$x:0000B070 ; Segment type: Pure code
.text$x:0000B070 ; Segment permissions: Read/Execute
.text$x:0000B070 _text$x         segment para public 'CODE' use32
.text$x:0000B070                 assume cs:_text$x
.text$x:0000B070                 ;org 0B070h
.text$x:0000B070 ; COMDAT (pick associative to section at AFFC)
.text$x:0000B070                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000B070
.text$x:0000B070 ; =============== S U B R O U T I N E =======================================
.text$x:0000B070
.text$x:0000B070
.text$x:0000B070 __unwindfunclet$?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ$0 proc near
.text$x:0000B070                                         ; DATA XREF: .xdata$x:0000CAA4o
.text$x:0000B070                 mov     eax, [ebp-14h]
.text$x:0000B073                 and     eax, 1
.text$x:0000B076                 jz      $LN4_0
.text$x:0000B07C                 and     dword ptr [ebp-14h], 0FFFFFFFEh
.text$x:0000B080                 mov     ecx, [ebp+8]
.text$x:0000B083                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:0000B088 ; ---------------------------------------------------------------------------
.text$x:0000B088
.text$x:0000B088 $LN4_0:                                 ; CODE XREF: __unwindfunclet$?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ$0+6j
.text$x:0000B088                 retn
.text$x:0000B088 __unwindfunclet$?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ$0 endp
.text$x:0000B088
.text$x:0000B089
.text$x:0000B089 ; =============== S U B R O U T I N E =======================================
.text$x:0000B089
.text$x:0000B089
.text$x:0000B089 __ehhandler$?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ proc near
.text$x:0000B089                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::end(void)+5o
.text$x:0000B089
.text$x:0000B089 arg_4           = dword ptr  8
.text$x:0000B089
.text$x:0000B089                 mov     edx, [esp+arg_4]
.text$x:0000B08D                 lea     eax, [edx+0Ch]
.text$x:0000B090                 mov     ecx, [edx-0Ch]
.text$x:0000B093                 xor     ecx, eax
.text$x:0000B095                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000B09A                 mov     eax, offset __ehfuncinfo$?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ
.text$x:0000B09F                 jmp     ___CxxFrameHandler3
.text$x:0000B09F __ehhandler$?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ endp
.text$x:0000B09F
.text$x:0000B09F _text$x         ends
.text$x:0000B09F
.text$mn:0000B0A4 ; ===========================================================================
.text$mn:0000B0A4
.text$mn:0000B0A4 ; Segment type: Pure code
.text$mn:0000B0A4 ; Segment permissions: Read/Execute
.text$mn:0000B0A4 _text$mn        segment para public 'CODE' use32
.text$mn:0000B0A4                 assume cs:_text$mn
.text$mn:0000B0A4                 ;org 0B0A4h
.text$mn:0000B0A4 ; COMDAT (pick any)
.text$mn:0000B0A4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B0A4
.text$mn:0000B0A4 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B0A4
.text$mn:0000B0A4 ; Attributes: bp-based frame
.text$mn:0000B0A4
.text$mn:0000B0A4 ; public: class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<int>>> __thiscall std::vector<int, class std::allocator<int>>::end(void)
.text$mn:0000B0A4                 public ?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ
.text$mn:0000B0A4 ?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ proc near
.text$mn:0000B0A4                                         ; CODE XREF: WindowsDlg::run_dlgProc(uint,uint,long)+4F2p
.text$mn:0000B0A4                                         ; WindowsDlg::resetSelection(void)+60p ...
.text$mn:0000B0A4
.text$mn:0000B0A4 var_14          = dword ptr -14h
.text$mn:0000B0A4 var_10          = dword ptr -10h
.text$mn:0000B0A4 var_C           = dword ptr -0Ch
.text$mn:0000B0A4 var_4           = dword ptr -4
.text$mn:0000B0A4 arg_0           = dword ptr  8
.text$mn:0000B0A4
.text$mn:0000B0A4                 push    ebp
.text$mn:0000B0A5                 mov     ebp, esp
.text$mn:0000B0A7                 push    0FFFFFFFFh
.text$mn:0000B0A9                 push    offset __ehhandler$?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ
.text$mn:0000B0AE                 mov     eax, large fs:0
.text$mn:0000B0B4                 push    eax
.text$mn:0000B0B5                 sub     esp, 8
.text$mn:0000B0B8                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000B0BD                 xor     eax, ebp
.text$mn:0000B0BF                 push    eax
.text$mn:0000B0C0                 lea     eax, [ebp+var_C]
.text$mn:0000B0C3                 mov     large fs:0, eax
.text$mn:0000B0C9                 mov     [ebp+var_10], ecx
.text$mn:0000B0CC                 mov     [ebp+var_14], 0
.text$mn:0000B0D3                 mov     eax, [ebp+var_10]
.text$mn:0000B0D6                 push    eax             ; struct std::_Container_base12 *
.text$mn:0000B0D7                 mov     ecx, [ebp+var_10]
.text$mn:0000B0DA                 mov     edx, [ecx+8]
.text$mn:0000B0DD                 push    edx             ; int
.text$mn:0000B0DE                 mov     ecx, [ebp+arg_0]
.text$mn:0000B0E1                 call    ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(int *,std::_Container_base12 const *)
.text$mn:0000B0E6                 mov     [ebp+var_4], 0
.text$mn:0000B0ED                 mov     eax, [ebp+var_14]
.text$mn:0000B0F0                 or      eax, 1
.text$mn:0000B0F3                 mov     [ebp+var_14], eax
.text$mn:0000B0F6                 mov     eax, [ebp+arg_0]
.text$mn:0000B0F9                 mov     ecx, [ebp+var_C]
.text$mn:0000B0FC                 mov     large fs:0, ecx
.text$mn:0000B103                 pop     ecx
.text$mn:0000B104                 mov     esp, ebp
.text$mn:0000B106                 pop     ebp
.text$mn:0000B107                 retn    4
.text$mn:0000B107 ?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ endp
.text$mn:0000B107
.text$mn:0000B107 ; ---------------------------------------------------------------------------
.text$mn:0000B10A                 align 4
.text$mn:0000B10A _text$mn        ends
.text$mn:0000B10A
.text$x:0000B10C ; ===========================================================================
.text$x:0000B10C
.text$x:0000B10C ; Segment type: Pure code
.text$x:0000B10C ; Segment permissions: Read/Execute
.text$x:0000B10C _text$x         segment para public 'CODE' use32
.text$x:0000B10C                 assume cs:_text$x
.text$x:0000B10C                 ;org 0B10Ch
.text$x:0000B10C ; COMDAT (pick associative to section at B0A4)
.text$x:0000B10C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000B10C
.text$x:0000B10C ; =============== S U B R O U T I N E =======================================
.text$x:0000B10C
.text$x:0000B10C
.text$x:0000B10C __unwindfunclet$?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ$0 proc near
.text$x:0000B10C                                         ; DATA XREF: .xdata$x:0000CE5Co
.text$x:0000B10C                 mov     eax, [ebp-14h]
.text$x:0000B10F                 and     eax, 1
.text$x:0000B112                 jz      $LN4_2
.text$x:0000B118                 and     dword ptr [ebp-14h], 0FFFFFFFEh
.text$x:0000B11C                 mov     ecx, [ebp+8]
.text$x:0000B11F                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$x:0000B124 ; ---------------------------------------------------------------------------
.text$x:0000B124
.text$x:0000B124 $LN4_2:                                 ; CODE XREF: __unwindfunclet$?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ$0+6j
.text$x:0000B124                 retn
.text$x:0000B124 __unwindfunclet$?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ$0 endp
.text$x:0000B124
.text$x:0000B125
.text$x:0000B125 ; =============== S U B R O U T I N E =======================================
.text$x:0000B125
.text$x:0000B125
.text$x:0000B125 __ehhandler$?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ proc near
.text$x:0000B125                                         ; DATA XREF: std::vector<int,std::allocator<int>>::end(void)+5o
.text$x:0000B125
.text$x:0000B125 arg_4           = dword ptr  8
.text$x:0000B125
.text$x:0000B125                 mov     edx, [esp+arg_4]
.text$x:0000B129                 lea     eax, [edx+0Ch]
.text$x:0000B12C                 mov     ecx, [edx-0Ch]
.text$x:0000B12F                 xor     ecx, eax
.text$x:0000B131                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000B136                 mov     eax, offset __ehfuncinfo$?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ
.text$x:0000B13B                 jmp     ___CxxFrameHandler3
.text$x:0000B13B __ehhandler$?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ endp
.text$x:0000B13B
.text$x:0000B13B _text$x         ends
.text$x:0000B13B
.text$mn:0000B140 ; ===========================================================================
.text$mn:0000B140
.text$mn:0000B140 ; Segment type: Pure code
.text$mn:0000B140 ; Segment permissions: Read/Execute
.text$mn:0000B140 _text$mn        segment para public 'CODE' use32
.text$mn:0000B140                 assume cs:_text$mn
.text$mn:0000B140                 ;org 0B140h
.text$mn:0000B140 ; COMDAT (pick any)
.text$mn:0000B140                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B140
.text$mn:0000B140 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B140
.text$mn:0000B140 ; Attributes: bp-based frame
.text$mn:0000B140
.text$mn:0000B140 ; bool __thiscall std::error_category::equivalent(std::error_category *this, const struct std::error_code *, int)
.text$mn:0000B140                 public ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
.text$mn:0000B140 ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z proc near
.text$mn:0000B140                                         ; DATA XREF: .rdata:0000DE54o
.text$mn:0000B140                                         ; .rdata:0000DE70o ...
.text$mn:0000B140
.text$mn:0000B140 var_8           = dword ptr -8
.text$mn:0000B140 var_4           = dword ptr -4
.text$mn:0000B140 arg_0           = dword ptr  8
.text$mn:0000B140 arg_4           = dword ptr  0Ch
.text$mn:0000B140
.text$mn:0000B140                 push    ebp
.text$mn:0000B141                 mov     ebp, esp
.text$mn:0000B143                 sub     esp, 8
.text$mn:0000B146                 mov     [ebp+var_8], ecx
.text$mn:0000B149                 mov     ecx, [ebp+arg_0] ; this
.text$mn:0000B14C                 call    ?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category(void)
.text$mn:0000B151                 push    eax
.text$mn:0000B152                 mov     ecx, [ebp+var_8]
.text$mn:0000B155                 call    ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
.text$mn:0000B15A                 movzx   eax, al
.text$mn:0000B15D                 test    eax, eax
.text$mn:0000B15F                 jz      short loc_B177
.text$mn:0000B161                 mov     ecx, [ebp+arg_0] ; this
.text$mn:0000B164                 call    ?value@error_code@std@@QBEHXZ ; std::error_code::value(void)
.text$mn:0000B169                 cmp     eax, [ebp+arg_4]
.text$mn:0000B16C                 jnz     short loc_B177
.text$mn:0000B16E                 mov     [ebp+var_4], 1
.text$mn:0000B175                 jmp     short loc_B17E
.text$mn:0000B177 ; ---------------------------------------------------------------------------
.text$mn:0000B177
.text$mn:0000B177 loc_B177:                               ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+1Fj
.text$mn:0000B177                                         ; std::error_category::equivalent(std::error_code const &,int)+2Cj
.text$mn:0000B177                 mov     [ebp+var_4], 0
.text$mn:0000B17E
.text$mn:0000B17E loc_B17E:                               ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+35j
.text$mn:0000B17E                 mov     al, byte ptr [ebp+var_4]
.text$mn:0000B181                 mov     esp, ebp
.text$mn:0000B183                 pop     ebp
.text$mn:0000B184                 retn    8
.text$mn:0000B184 ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z endp
.text$mn:0000B184
.text$mn:0000B184 ; ---------------------------------------------------------------------------
.text$mn:0000B187                 align 4
.text$mn:0000B187 _text$mn        ends
.text$mn:0000B187
.text$mn:0000B188 ; ===========================================================================
.text$mn:0000B188
.text$mn:0000B188 ; Segment type: Pure code
.text$mn:0000B188 ; Segment permissions: Read/Execute
.text$mn:0000B188 _text$mn        segment para public 'CODE' use32
.text$mn:0000B188                 assume cs:_text$mn
.text$mn:0000B188                 ;org 0B188h
.text$mn:0000B188 ; COMDAT (pick any)
.text$mn:0000B188                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B188
.text$mn:0000B188 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B188
.text$mn:0000B188 ; Attributes: bp-based frame
.text$mn:0000B188
.text$mn:0000B188 ; bool __thiscall std::error_category::equivalent(std::error_category *this, int, const struct std::error_condition *)
.text$mn:0000B188                 public ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
.text$mn:0000B188 ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z proc near
.text$mn:0000B188                                         ; DATA XREF: .rdata:0000DE58o
.text$mn:0000B188                                         ; .rdata:0000DE74o ...
.text$mn:0000B188
.text$mn:0000B188 var_C           = byte ptr -0Ch
.text$mn:0000B188 var_4           = dword ptr -4
.text$mn:0000B188 arg_0           = dword ptr  8
.text$mn:0000B188 arg_4           = dword ptr  0Ch
.text$mn:0000B188
.text$mn:0000B188                 push    ebp
.text$mn:0000B189                 mov     ebp, esp
.text$mn:0000B18B                 sub     esp, 0Ch
.text$mn:0000B18E                 mov     [ebp+var_4], ecx
.text$mn:0000B191                 mov     eax, [ebp+arg_4]
.text$mn:0000B194                 push    eax             ; std::error_condition *
.text$mn:0000B195                 mov     ecx, [ebp+arg_0]
.text$mn:0000B198                 push    ecx
.text$mn:0000B199                 lea     edx, [ebp+var_C]
.text$mn:0000B19C                 push    edx
.text$mn:0000B19D                 mov     eax, [ebp+var_4]
.text$mn:0000B1A0                 mov     edx, [eax]
.text$mn:0000B1A2                 mov     ecx, [ebp+var_4]
.text$mn:0000B1A5                 mov     eax, [edx+0Ch]
.text$mn:0000B1A8                 call    eax
.text$mn:0000B1AA                 mov     ecx, eax
.text$mn:0000B1AC                 call    ??8error_condition@std@@QBE_NABV01@@Z ; std::error_condition::operator==(std::error_condition const &)
.text$mn:0000B1B1                 mov     esp, ebp
.text$mn:0000B1B3                 pop     ebp
.text$mn:0000B1B4                 retn    8
.text$mn:0000B1B4 ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z endp
.text$mn:0000B1B4
.text$mn:0000B1B4 ; ---------------------------------------------------------------------------
.text$mn:0000B1B7                 align 4
.text$mn:0000B1B7 _text$mn        ends
.text$mn:0000B1B7
.text$mn:0000B1B8 ; ===========================================================================
.text$mn:0000B1B8
.text$mn:0000B1B8 ; Segment type: Pure code
.text$mn:0000B1B8 ; Segment permissions: Read/Execute
.text$mn:0000B1B8 _text$mn        segment para public 'CODE' use32
.text$mn:0000B1B8                 assume cs:_text$mn
.text$mn:0000B1B8                 ;org 0B1B8h
.text$mn:0000B1B8 ; COMDAT (pick any)
.text$mn:0000B1B8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B1B8
.text$mn:0000B1B8 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B1B8
.text$mn:0000B1B8 ; Attributes: bp-based frame
.text$mn:0000B1B8
.text$mn:0000B1B8 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int)
.text$mn:0000B1B8                 public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
.text$mn:0000B1B8 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z proc near
.text$mn:0000B1B8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+4Cp
.text$mn:0000B1B8
.text$mn:0000B1B8 var_4           = dword ptr -4
.text$mn:0000B1B8 arg_0           = dword ptr  8
.text$mn:0000B1B8
.text$mn:0000B1B8                 push    ebp
.text$mn:0000B1B9                 mov     ebp, esp
.text$mn:0000B1BB                 push    ecx
.text$mn:0000B1BC                 mov     [ebp+var_4], ecx
.text$mn:0000B1BF                 mov     eax, [ebp+var_4]
.text$mn:0000B1C2                 mov     ecx, [eax+14h]
.text$mn:0000B1C5                 cmp     ecx, [ebp+arg_0]
.text$mn:0000B1C8                 jnb     short loc_B1D2
.text$mn:0000B1CA                 mov     ecx, [ebp+var_4]
.text$mn:0000B1CD                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:0000B1D2
.text$mn:0000B1D2 loc_B1D2:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)+10j
.text$mn:0000B1D2                 mov     edx, [ebp+arg_0]
.text$mn:0000B1D5                 push    edx
.text$mn:0000B1D6                 mov     ecx, [ebp+var_4]
.text$mn:0000B1D9                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:0000B1DE                 mov     eax, [ebp+var_4]
.text$mn:0000B1E1                 mov     esp, ebp
.text$mn:0000B1E3                 pop     ebp
.text$mn:0000B1E4                 retn    4
.text$mn:0000B1E4 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z endp
.text$mn:0000B1E4
.text$mn:0000B1E4 ; ---------------------------------------------------------------------------
.text$mn:0000B1E7                 align 4
.text$mn:0000B1E7 _text$mn        ends
.text$mn:0000B1E7
.text$mn:0000B1E8 ; ===========================================================================
.text$mn:0000B1E8
.text$mn:0000B1E8 ; Segment type: Pure code
.text$mn:0000B1E8 ; Segment permissions: Read/Execute
.text$mn:0000B1E8 _text$mn        segment para public 'CODE' use32
.text$mn:0000B1E8                 assume cs:_text$mn
.text$mn:0000B1E8                 ;org 0B1E8h
.text$mn:0000B1E8 ; COMDAT (pick any)
.text$mn:0000B1E8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B1E8
.text$mn:0000B1E8 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B1E8
.text$mn:0000B1E8 ; Attributes: bp-based frame
.text$mn:0000B1E8
.text$mn:0000B1E8 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int, unsigned int)
.text$mn:0000B1E8                 public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
.text$mn:0000B1E8 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z proc near
.text$mn:0000B1E8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+5Ap
.text$mn:0000B1E8
.text$mn:0000B1E8 var_C           = dword ptr -0Ch
.text$mn:0000B1E8 Dst             = dword ptr -8
.text$mn:0000B1E8 var_4           = dword ptr -4
.text$mn:0000B1E8 arg_0           = dword ptr  8
.text$mn:0000B1E8 arg_4           = dword ptr  0Ch
.text$mn:0000B1E8
.text$mn:0000B1E8                 push    ebp
.text$mn:0000B1E9                 mov     ebp, esp
.text$mn:0000B1EB                 sub     esp, 0Ch
.text$mn:0000B1EE                 mov     [ebp+var_4], ecx
.text$mn:0000B1F1                 mov     eax, [ebp+var_4]
.text$mn:0000B1F4                 mov     ecx, [eax+14h]
.text$mn:0000B1F7                 cmp     ecx, [ebp+arg_0]
.text$mn:0000B1FA                 jnb     short loc_B204
.text$mn:0000B1FC                 mov     ecx, [ebp+var_4]
.text$mn:0000B1FF                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:0000B204
.text$mn:0000B204 loc_B204:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+12j
.text$mn:0000B204                 mov     edx, [ebp+var_4]
.text$mn:0000B207                 mov     eax, [edx+14h]
.text$mn:0000B20A                 sub     eax, [ebp+arg_0]
.text$mn:0000B20D                 cmp     eax, [ebp+arg_4]
.text$mn:0000B210                 ja      short loc_B220
.text$mn:0000B212                 mov     ecx, [ebp+arg_0]
.text$mn:0000B215                 push    ecx
.text$mn:0000B216                 mov     ecx, [ebp+var_4]
.text$mn:0000B219                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:0000B21E                 jmp     short loc_B266
.text$mn:0000B220 ; ---------------------------------------------------------------------------
.text$mn:0000B220
.text$mn:0000B220 loc_B220:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+28j
.text$mn:0000B220                 cmp     [ebp+arg_4], 0
.text$mn:0000B224                 jbe     short loc_B266
.text$mn:0000B226                 mov     ecx, [ebp+var_4]
.text$mn:0000B229                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000B22E                 add     eax, [ebp+arg_0]
.text$mn:0000B231                 mov     [ebp+Dst], eax
.text$mn:0000B234                 mov     edx, [ebp+var_4]
.text$mn:0000B237                 mov     eax, [edx+14h]
.text$mn:0000B23A                 sub     eax, [ebp+arg_4]
.text$mn:0000B23D                 mov     [ebp+var_C], eax
.text$mn:0000B240                 mov     ecx, [ebp+var_C]
.text$mn:0000B243                 sub     ecx, [ebp+arg_0]
.text$mn:0000B246                 push    ecx             ; Size
.text$mn:0000B247                 mov     edx, [ebp+Dst]
.text$mn:0000B24A                 add     edx, [ebp+arg_4]
.text$mn:0000B24D                 push    edx             ; Src
.text$mn:0000B24E                 mov     eax, [ebp+Dst]
.text$mn:0000B251                 push    eax             ; Dst
.text$mn:0000B252                 call    ?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move(char *,char const *,uint)
.text$mn:0000B257                 add     esp, 0Ch
.text$mn:0000B25A                 mov     ecx, [ebp+var_C]
.text$mn:0000B25D                 push    ecx
.text$mn:0000B25E                 mov     ecx, [ebp+var_4]
.text$mn:0000B261                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:0000B266
.text$mn:0000B266 loc_B266:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+36j
.text$mn:0000B266                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+3Cj
.text$mn:0000B266                 mov     eax, [ebp+var_4]
.text$mn:0000B269                 mov     esp, ebp
.text$mn:0000B26B                 pop     ebp
.text$mn:0000B26C                 retn    8
.text$mn:0000B26C ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z endp
.text$mn:0000B26C
.text$mn:0000B26C ; ---------------------------------------------------------------------------
.text$mn:0000B26F                 align 10h
.text$mn:0000B26F _text$mn        ends
.text$mn:0000B26F
.text$mn:0000B270 ; ===========================================================================
.text$mn:0000B270
.text$mn:0000B270 ; Segment type: Pure code
.text$mn:0000B270 ; Segment permissions: Read/Execute
.text$mn:0000B270 _text$mn        segment para public 'CODE' use32
.text$mn:0000B270                 assume cs:_text$mn
.text$mn:0000B270                 ;org 0B270h
.text$mn:0000B270 ; COMDAT (pick any)
.text$mn:0000B270                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B270
.text$mn:0000B270 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B270
.text$mn:0000B270 ; Attributes: bp-based frame
.text$mn:0000B270
.text$mn:0000B270 ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::erase(unsigned int)
.text$mn:0000B270                 public ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z
.text$mn:0000B270 ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z proc near
.text$mn:0000B270                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+4Cp
.text$mn:0000B270
.text$mn:0000B270 var_4           = dword ptr -4
.text$mn:0000B270 arg_0           = dword ptr  8
.text$mn:0000B270
.text$mn:0000B270                 push    ebp
.text$mn:0000B271                 mov     ebp, esp
.text$mn:0000B273                 push    ecx
.text$mn:0000B274                 mov     [ebp+var_4], ecx
.text$mn:0000B277                 mov     eax, [ebp+var_4]
.text$mn:0000B27A                 mov     ecx, [eax+14h]
.text$mn:0000B27D                 cmp     ecx, [ebp+arg_0]
.text$mn:0000B280                 jnb     short loc_B28A
.text$mn:0000B282                 mov     ecx, [ebp+var_4]
.text$mn:0000B285                 call    ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)
.text$mn:0000B28A
.text$mn:0000B28A loc_B28A:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint)+10j
.text$mn:0000B28A                 mov     edx, [ebp+arg_0]
.text$mn:0000B28D                 push    edx
.text$mn:0000B28E                 mov     ecx, [ebp+var_4]
.text$mn:0000B291                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:0000B296                 mov     eax, [ebp+var_4]
.text$mn:0000B299                 mov     esp, ebp
.text$mn:0000B29B                 pop     ebp
.text$mn:0000B29C                 retn    4
.text$mn:0000B29C ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z endp
.text$mn:0000B29C
.text$mn:0000B29C ; ---------------------------------------------------------------------------
.text$mn:0000B29F                 align 10h
.text$mn:0000B29F _text$mn        ends
.text$mn:0000B29F
.text$mn:0000B2A0 ; ===========================================================================
.text$mn:0000B2A0
.text$mn:0000B2A0 ; Segment type: Pure code
.text$mn:0000B2A0 ; Segment permissions: Read/Execute
.text$mn:0000B2A0 _text$mn        segment para public 'CODE' use32
.text$mn:0000B2A0                 assume cs:_text$mn
.text$mn:0000B2A0                 ;org 0B2A0h
.text$mn:0000B2A0 ; COMDAT (pick any)
.text$mn:0000B2A0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B2A0
.text$mn:0000B2A0 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B2A0
.text$mn:0000B2A0 ; Attributes: bp-based frame
.text$mn:0000B2A0
.text$mn:0000B2A0 ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::erase(unsigned int, unsigned int)
.text$mn:0000B2A0                 public ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z
.text$mn:0000B2A0 ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z proc near
.text$mn:0000B2A0                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+5Ap
.text$mn:0000B2A0
.text$mn:0000B2A0 var_C           = dword ptr -0Ch
.text$mn:0000B2A0 Dst             = dword ptr -8
.text$mn:0000B2A0 var_4           = dword ptr -4
.text$mn:0000B2A0 arg_0           = dword ptr  8
.text$mn:0000B2A0 arg_4           = dword ptr  0Ch
.text$mn:0000B2A0
.text$mn:0000B2A0                 push    ebp
.text$mn:0000B2A1                 mov     ebp, esp
.text$mn:0000B2A3                 sub     esp, 0Ch
.text$mn:0000B2A6                 mov     [ebp+var_4], ecx
.text$mn:0000B2A9                 mov     eax, [ebp+var_4]
.text$mn:0000B2AC                 mov     ecx, [eax+14h]
.text$mn:0000B2AF                 cmp     ecx, [ebp+arg_0]
.text$mn:0000B2B2                 jnb     short loc_B2BC
.text$mn:0000B2B4                 mov     ecx, [ebp+var_4]
.text$mn:0000B2B7                 call    ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)
.text$mn:0000B2BC
.text$mn:0000B2BC loc_B2BC:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)+12j
.text$mn:0000B2BC                 mov     edx, [ebp+var_4]
.text$mn:0000B2BF                 mov     eax, [edx+14h]
.text$mn:0000B2C2                 sub     eax, [ebp+arg_0]
.text$mn:0000B2C5                 cmp     eax, [ebp+arg_4]
.text$mn:0000B2C8                 ja      short loc_B2D8
.text$mn:0000B2CA                 mov     ecx, [ebp+arg_0]
.text$mn:0000B2CD                 push    ecx
.text$mn:0000B2CE                 mov     ecx, [ebp+var_4]
.text$mn:0000B2D1                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:0000B2D6                 jmp     short loc_B324
.text$mn:0000B2D8 ; ---------------------------------------------------------------------------
.text$mn:0000B2D8
.text$mn:0000B2D8 loc_B2D8:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)+28j
.text$mn:0000B2D8                 cmp     [ebp+arg_4], 0
.text$mn:0000B2DC                 jbe     short loc_B324
.text$mn:0000B2DE                 mov     ecx, [ebp+var_4]
.text$mn:0000B2E1                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000B2E6                 mov     edx, [ebp+arg_0]
.text$mn:0000B2E9                 lea     eax, [eax+edx*2]
.text$mn:0000B2EC                 mov     [ebp+Dst], eax
.text$mn:0000B2EF                 mov     ecx, [ebp+var_4]
.text$mn:0000B2F2                 mov     edx, [ecx+14h]
.text$mn:0000B2F5                 sub     edx, [ebp+arg_4]
.text$mn:0000B2F8                 mov     [ebp+var_C], edx
.text$mn:0000B2FB                 mov     eax, [ebp+var_C]
.text$mn:0000B2FE                 sub     eax, [ebp+arg_0]
.text$mn:0000B301                 push    eax             ; int
.text$mn:0000B302                 mov     ecx, [ebp+arg_4]
.text$mn:0000B305                 mov     edx, [ebp+Dst]
.text$mn:0000B308                 lea     eax, [edx+ecx*2]
.text$mn:0000B30B                 push    eax             ; Src
.text$mn:0000B30C                 mov     ecx, [ebp+Dst]
.text$mn:0000B30F                 push    ecx             ; Dst
.text$mn:0000B310                 call    ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)
.text$mn:0000B315                 add     esp, 0Ch
.text$mn:0000B318                 mov     edx, [ebp+var_C]
.text$mn:0000B31B                 push    edx
.text$mn:0000B31C                 mov     ecx, [ebp+var_4]
.text$mn:0000B31F                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:0000B324
.text$mn:0000B324 loc_B324:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)+36j
.text$mn:0000B324                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)+3Cj
.text$mn:0000B324                 mov     eax, [ebp+var_4]
.text$mn:0000B327                 mov     esp, ebp
.text$mn:0000B329                 pop     ebp
.text$mn:0000B32A                 retn    8
.text$mn:0000B32A ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z endp
.text$mn:0000B32A
.text$mn:0000B32A ; ---------------------------------------------------------------------------
.text$mn:0000B32D                 align 10h
.text$mn:0000B32D _text$mn        ends
.text$mn:0000B32D
.text$mn:0000B330 ; ===========================================================================
.text$mn:0000B330
.text$mn:0000B330 ; Segment type: Pure code
.text$mn:0000B330 ; Segment permissions: Read/Execute
.text$mn:0000B330 _text$mn        segment para public 'CODE' use32
.text$mn:0000B330                 assume cs:_text$mn
.text$mn:0000B330                 ;org 0B330h
.text$mn:0000B330 ; COMDAT (pick any)
.text$mn:0000B330                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B330
.text$mn:0000B330 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B330
.text$mn:0000B330 ; Attributes: bp-based frame
.text$mn:0000B330
.text$mn:0000B330 ; public: class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<int>>> __thiscall std::vector<int, class std::allocator<int>>::erase(class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<int>>>, class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<int>>>)
.text$mn:0000B330                 public ?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@0@Z
.text$mn:0000B330 ?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@0@Z proc near
.text$mn:0000B330                                         ; CODE XREF: WindowsDlg::doClose(void)+3EDp
.text$mn:0000B330
.text$mn:0000B330 var_90          = byte ptr -90h
.text$mn:0000B330 var_84          = byte ptr -84h
.text$mn:0000B330 var_78          = dword ptr -78h
.text$mn:0000B330 var_74          = dword ptr -74h
.text$mn:0000B330 var_70          = dword ptr -70h
.text$mn:0000B330 var_6C          = dword ptr -6Ch
.text$mn:0000B330 var_68          = dword ptr -68h
.text$mn:0000B330 var_64          = dword ptr -64h
.text$mn:0000B330 var_60          = dword ptr -60h
.text$mn:0000B330 var_5C          = dword ptr -5Ch
.text$mn:0000B330 var_58          = dword ptr -58h
.text$mn:0000B330 var_54          = byte ptr -54h
.text$mn:0000B330 Src             = dword ptr -4Ch
.text$mn:0000B330 var_48          = dword ptr -48h
.text$mn:0000B330 var_44          = dword ptr -44h
.text$mn:0000B330 var_40          = dword ptr -40h
.text$mn:0000B330 var_3C          = dword ptr -3Ch
.text$mn:0000B330 var_38          = dword ptr -38h
.text$mn:0000B330 var_34          = dword ptr -34h
.text$mn:0000B330 var_30          = dword ptr -30h
.text$mn:0000B330 var_2C          = byte ptr -2Ch
.text$mn:0000B330 Dst             = dword ptr -24h
.text$mn:0000B330 var_20          = dword ptr -20h
.text$mn:0000B330 var_1C          = dword ptr -1Ch
.text$mn:0000B330 var_15          = byte ptr -15h
.text$mn:0000B330 var_14          = dword ptr -14h
.text$mn:0000B330 var_10          = dword ptr -10h
.text$mn:0000B330 var_C           = dword ptr -0Ch
.text$mn:0000B330 var_4           = dword ptr -4
.text$mn:0000B330 arg_0           = dword ptr  8
.text$mn:0000B330 arg_4           = byte ptr  0Ch
.text$mn:0000B330 arg_10          = byte ptr  18h
.text$mn:0000B330
.text$mn:0000B330                 push    ebp
.text$mn:0000B331                 mov     ebp, esp
.text$mn:0000B333                 push    0FFFFFFFFh
.text$mn:0000B335                 push    offset __ehhandler$?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@0@Z
.text$mn:0000B33A                 mov     eax, large fs:0
.text$mn:0000B340                 push    eax
.text$mn:0000B341                 sub     esp, 84h
.text$mn:0000B347                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000B34C                 xor     eax, ebp
.text$mn:0000B34E                 push    eax
.text$mn:0000B34F                 lea     eax, [ebp+var_C]
.text$mn:0000B352                 mov     large fs:0, eax
.text$mn:0000B358                 mov     [ebp+var_10], ecx
.text$mn:0000B35B                 mov     [ebp+var_14], 0
.text$mn:0000B362                 mov     [ebp+var_4], 2
.text$mn:0000B369                 lea     eax, [ebp+var_90]
.text$mn:0000B36F                 push    eax
.text$mn:0000B370                 mov     ecx, [ebp+var_10]
.text$mn:0000B373                 call    ?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ ; std::vector<int,std::allocator<int>>::begin(void)
.text$mn:0000B378                 mov     [ebp+var_44], eax
.text$mn:0000B37B                 mov     ecx, [ebp+var_44]
.text$mn:0000B37E                 mov     [ebp+var_30], ecx
.text$mn:0000B381                 mov     byte ptr [ebp+var_4], 3
.text$mn:0000B385                 mov     edx, [ebp+var_14]
.text$mn:0000B388                 or      edx, 1
.text$mn:0000B38B                 mov     [ebp+var_14], edx
.text$mn:0000B38E                 mov     eax, [ebp+var_30]
.text$mn:0000B391                 push    eax             ; std::_Iterator_base12 *
.text$mn:0000B392                 lea     ecx, [ebp+arg_4]
.text$mn:0000B395                 call    ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator==(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>> const &)
.text$mn:0000B39A                 movzx   ecx, al
.text$mn:0000B39D                 test    ecx, ecx
.text$mn:0000B39F                 jz      short loc_B3E5
.text$mn:0000B3A1                 lea     edx, [ebp+var_84]
.text$mn:0000B3A7                 push    edx
.text$mn:0000B3A8                 mov     ecx, [ebp+var_10]
.text$mn:0000B3AB                 call    ?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ ; std::vector<int,std::allocator<int>>::end(void)
.text$mn:0000B3B0                 mov     [ebp+var_38], eax
.text$mn:0000B3B3                 mov     eax, [ebp+var_38]
.text$mn:0000B3B6                 mov     [ebp+var_48], eax
.text$mn:0000B3B9                 mov     [ebp+var_4], 4
.text$mn:0000B3C0                 mov     ecx, [ebp+var_14]
.text$mn:0000B3C3                 or      ecx, 2
.text$mn:0000B3C6                 mov     [ebp+var_14], ecx
.text$mn:0000B3C9                 mov     edx, [ebp+var_48]
.text$mn:0000B3CC                 push    edx             ; std::_Iterator_base12 *
.text$mn:0000B3CD                 lea     ecx, [ebp+arg_10]
.text$mn:0000B3D0                 call    ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator==(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>> const &)
.text$mn:0000B3D5                 movzx   eax, al
.text$mn:0000B3D8                 test    eax, eax
.text$mn:0000B3DA                 jz      short loc_B3E5
.text$mn:0000B3DC                 mov     [ebp+var_1C], 1
.text$mn:0000B3E3                 jmp     short loc_B3EC
.text$mn:0000B3E5 ; ---------------------------------------------------------------------------
.text$mn:0000B3E5
.text$mn:0000B3E5 loc_B3E5:                               ; CODE XREF: std::vector<int,std::allocator<int>>::erase(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>)+6Fj
.text$mn:0000B3E5                                         ; std::vector<int,std::allocator<int>>::erase(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>)+AAj
.text$mn:0000B3E5                 mov     [ebp+var_1C], 0
.text$mn:0000B3EC
.text$mn:0000B3EC loc_B3EC:                               ; CODE XREF: std::vector<int,std::allocator<int>>::erase(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>)+B3j
.text$mn:0000B3EC                 mov     cl, byte ptr [ebp+var_1C]
.text$mn:0000B3EF                 mov     [ebp+var_15], cl
.text$mn:0000B3F2                 mov     [ebp+var_4], 3
.text$mn:0000B3F9                 mov     edx, [ebp+var_14]
.text$mn:0000B3FC                 and     edx, 2
.text$mn:0000B3FF                 jz      short loc_B410
.text$mn:0000B401                 and     [ebp+var_14], 0FFFFFFFDh
.text$mn:0000B405                 lea     ecx, [ebp+var_84]
.text$mn:0000B40B                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$mn:0000B410
.text$mn:0000B410 loc_B410:                               ; CODE XREF: std::vector<int,std::allocator<int>>::erase(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>)+CFj
.text$mn:0000B410                 mov     [ebp+var_4], 2
.text$mn:0000B417                 mov     eax, [ebp+var_14]
.text$mn:0000B41A                 and     eax, 1
.text$mn:0000B41D                 jz      short loc_B42E
.text$mn:0000B41F                 and     [ebp+var_14], 0FFFFFFFEh
.text$mn:0000B423                 lea     ecx, [ebp+var_90]
.text$mn:0000B429                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$mn:0000B42E
.text$mn:0000B42E loc_B42E:                               ; CODE XREF: std::vector<int,std::allocator<int>>::erase(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>)+EDj
.text$mn:0000B42E                 movzx   ecx, [ebp+var_15]
.text$mn:0000B432                 test    ecx, ecx
.text$mn:0000B434                 jz      short loc_B443
.text$mn:0000B436                 mov     ecx, [ebp+var_10]
.text$mn:0000B439                 call    ?clear@?$vector@HV?$allocator@H@std@@@std@@QAEXXZ ; std::vector<int,std::allocator<int>>::clear(void)
.text$mn:0000B43E                 jmp     loc_B589
.text$mn:0000B443 ; ---------------------------------------------------------------------------
.text$mn:0000B443
.text$mn:0000B443 loc_B443:                               ; CODE XREF: std::vector<int,std::allocator<int>>::erase(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>)+104j
.text$mn:0000B443                 lea     edx, [ebp+arg_10]
.text$mn:0000B446                 push    edx             ; std::_Iterator_base12 *
.text$mn:0000B447                 lea     ecx, [ebp+arg_4]
.text$mn:0000B44A                 call    ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator!=(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>> const &)
.text$mn:0000B44F                 movzx   eax, al
.text$mn:0000B452                 test    eax, eax
.text$mn:0000B454                 jz      loc_B589
.text$mn:0000B45A                 sub     esp, 0Ch
.text$mn:0000B45D                 mov     ecx, esp
.text$mn:0000B45F                 mov     [ebp+var_58], esp
.text$mn:0000B462                 lea     edx, [ebp+arg_4]
.text$mn:0000B465                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:0000B466                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>> const &)
.text$mn:0000B46B                 mov     [ebp+var_40], eax
.text$mn:0000B46E                 mov     eax, [ebp+var_40]
.text$mn:0000B471                 mov     [ebp+var_68], eax
.text$mn:0000B474                 mov     byte ptr [ebp+var_4], 5
.text$mn:0000B478                 lea     ecx, [ebp+var_2C]
.text$mn:0000B47B                 push    ecx
.text$mn:0000B47C                 mov     byte ptr [ebp+var_4], 2
.text$mn:0000B480                 mov     ecx, [ebp+var_10]
.text$mn:0000B483                 call    ?_Make_iter@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@@Z ; std::vector<int,std::allocator<int>>::_Make_iter(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>)
.text$mn:0000B488                 mov     [ebp+var_70], eax
.text$mn:0000B48B                 mov     byte ptr [ebp+var_4], 6
.text$mn:0000B48F                 sub     esp, 0Ch
.text$mn:0000B492                 mov     ecx, esp
.text$mn:0000B494                 mov     [ebp+var_78], esp
.text$mn:0000B497                 lea     edx, [ebp+arg_10]
.text$mn:0000B49A                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:0000B49B                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>> const &)
.text$mn:0000B4A0                 mov     [ebp+var_34], eax
.text$mn:0000B4A3                 mov     eax, [ebp+var_34]
.text$mn:0000B4A6                 mov     [ebp+var_64], eax
.text$mn:0000B4A9                 mov     byte ptr [ebp+var_4], 7
.text$mn:0000B4AD                 lea     ecx, [ebp+var_54]
.text$mn:0000B4B0                 push    ecx
.text$mn:0000B4B1                 mov     byte ptr [ebp+var_4], 6
.text$mn:0000B4B5                 mov     ecx, [ebp+var_10]
.text$mn:0000B4B8                 call    ?_Make_iter@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@@Z ; std::vector<int,std::allocator<int>>::_Make_iter(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>)
.text$mn:0000B4BD                 mov     [ebp+var_74], eax
.text$mn:0000B4C0                 mov     byte ptr [ebp+var_4], 8
.text$mn:0000B4C4                 lea     edx, [ebp+var_54]
.text$mn:0000B4C7                 push    edx             ; std::_Iterator_base12 *
.text$mn:0000B4C8                 lea     ecx, [ebp+var_2C]
.text$mn:0000B4CB                 call    ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator!=(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>> const &)
.text$mn:0000B4D0                 movzx   eax, al
.text$mn:0000B4D3                 test    eax, eax
.text$mn:0000B4D5                 jz      loc_B571
.text$mn:0000B4DB                 lea     ecx, [ebp+var_2C]
.text$mn:0000B4DE                 push    ecx             ; std::_Iterator_base12 *
.text$mn:0000B4DF                 lea     ecx, [ebp+var_54]
.text$mn:0000B4E2                 call    ??M?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator<(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>> const &)
.text$mn:0000B4E7                 movzx   edx, al
.text$mn:0000B4EA                 test    edx, edx
.text$mn:0000B4EC                 jnz     short loc_B511
.text$mn:0000B4EE                 lea     ecx, [ebp+var_2C] ; this
.text$mn:0000B4F1                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:0000B4F6                 cmp     eax, [ebp+var_10]
.text$mn:0000B4F9                 jnz     short loc_B511
.text$mn:0000B4FB                 mov     eax, [ebp+var_10]
.text$mn:0000B4FE                 mov     ecx, [ebp+Dst]
.text$mn:0000B501                 cmp     ecx, [eax+4]
.text$mn:0000B504                 jb      short loc_B511
.text$mn:0000B506                 mov     edx, [ebp+var_10]
.text$mn:0000B509                 mov     eax, [edx+8]
.text$mn:0000B50C                 cmp     eax, [ebp+Src]
.text$mn:0000B50F                 jnb     short loc_B528
.text$mn:0000B511
.text$mn:0000B511 loc_B511:                               ; CODE XREF: std::vector<int,std::allocator<int>>::erase(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>)+1BCj
.text$mn:0000B511                                         ; std::vector<int,std::allocator<int>>::erase(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>)+1C9j ...
.text$mn:0000B511                 push    5C5h            ; unsigned int
.text$mn:0000B516                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000B51B                 push    offset ??_C@_1EI@HGIDLLCM@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAe?$AAr?$AAa?$AAs?$AAe?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAo?$AAu?$AAt?$AAs?$AAi?$AAd?$AAe?$AA?5?$AAr?$AAa@ ; "vector erase iterator outside range"
.text$mn:0000B520                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:0000B525                 add     esp, 0Ch
.text$mn:0000B528
.text$mn:0000B528 loc_B528:                               ; CODE XREF: std::vector<int,std::allocator<int>>::erase(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>)+1DFj
.text$mn:0000B528                 mov     ecx, [ebp+Dst]
.text$mn:0000B52B                 push    ecx             ; Dst
.text$mn:0000B52C                 mov     edx, [ebp+var_10]
.text$mn:0000B52F                 mov     eax, [edx+8]
.text$mn:0000B532                 push    eax             ; int
.text$mn:0000B533                 mov     ecx, [ebp+Src]
.text$mn:0000B536                 push    ecx             ; Src
.text$mn:0000B537                 call    ??$_Move@PAHPAH@std@@YAPAHPAH00@Z ; std::_Move<int *,int *>(int *,int *,int *)
.text$mn:0000B53C                 add     esp, 0Ch
.text$mn:0000B53F                 mov     [ebp+var_20], eax
.text$mn:0000B542                 mov     edx, [ebp+var_10]
.text$mn:0000B545                 mov     eax, [edx+8]
.text$mn:0000B548                 push    eax
.text$mn:0000B549                 mov     ecx, [ebp+Dst]
.text$mn:0000B54C                 push    ecx
.text$mn:0000B54D                 mov     ecx, [ebp+var_10]
.text$mn:0000B550                 call    ?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@IBEXPAH0@Z ; std::vector<int,std::allocator<int>>::_Orphan_range(int *,int *)
.text$mn:0000B555                 mov     edx, [ebp+var_10]
.text$mn:0000B558                 mov     eax, [edx+8]
.text$mn:0000B55B                 push    eax
.text$mn:0000B55C                 mov     ecx, [ebp+var_20]
.text$mn:0000B55F                 push    ecx
.text$mn:0000B560                 mov     ecx, [ebp+var_10]
.text$mn:0000B563                 call    ?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z ; std::vector<int,std::allocator<int>>::_Destroy(int *,int *)
.text$mn:0000B568                 mov     edx, [ebp+var_10]
.text$mn:0000B56B                 mov     eax, [ebp+var_20]
.text$mn:0000B56E                 mov     [edx+8], eax
.text$mn:0000B571
.text$mn:0000B571 loc_B571:                               ; CODE XREF: std::vector<int,std::allocator<int>>::erase(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>)+1A5j
.text$mn:0000B571                 mov     byte ptr [ebp+var_4], 6
.text$mn:0000B575                 lea     ecx, [ebp+var_54]
.text$mn:0000B578                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$mn:0000B57D                 mov     byte ptr [ebp+var_4], 2
.text$mn:0000B581                 lea     ecx, [ebp+var_2C]
.text$mn:0000B584                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$mn:0000B589
.text$mn:0000B589 loc_B589:                               ; CODE XREF: std::vector<int,std::allocator<int>>::erase(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>)+10Ej
.text$mn:0000B589                                         ; std::vector<int,std::allocator<int>>::erase(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>)+124j
.text$mn:0000B589                 sub     esp, 0Ch
.text$mn:0000B58C                 mov     ecx, esp
.text$mn:0000B58E                 mov     [ebp+var_6C], esp
.text$mn:0000B591                 lea     edx, [ebp+arg_4]
.text$mn:0000B594                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:0000B595                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>> const &)
.text$mn:0000B59A                 mov     [ebp+var_3C], eax
.text$mn:0000B59D                 mov     eax, [ebp+var_3C]
.text$mn:0000B5A0                 mov     [ebp+var_5C], eax
.text$mn:0000B5A3                 mov     byte ptr [ebp+var_4], 9
.text$mn:0000B5A7                 mov     ecx, [ebp+arg_0]
.text$mn:0000B5AA                 push    ecx
.text$mn:0000B5AB                 mov     byte ptr [ebp+var_4], 2
.text$mn:0000B5AF                 mov     ecx, [ebp+var_10]
.text$mn:0000B5B2                 call    ?_Make_iter@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@@Z ; std::vector<int,std::allocator<int>>::_Make_iter(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>)
.text$mn:0000B5B7                 mov     [ebp+var_60], eax
.text$mn:0000B5BA                 mov     edx, [ebp+var_14]
.text$mn:0000B5BD                 or      edx, 4
.text$mn:0000B5C0                 mov     [ebp+var_14], edx
.text$mn:0000B5C3                 mov     byte ptr [ebp+var_4], 1
.text$mn:0000B5C7                 lea     ecx, [ebp+arg_4]
.text$mn:0000B5CA                 call    ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$mn:0000B5CF                 mov     byte ptr [ebp+var_4], 0
.text$mn:0000B5D3                 lea     ecx, [ebp+arg_10]
.text$mn:0000B5D6                 call    ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$mn:0000B5DB                 mov     eax, [ebp+arg_0]
.text$mn:0000B5DE                 mov     ecx, [ebp+var_C]
.text$mn:0000B5E1                 mov     large fs:0, ecx
.text$mn:0000B5E8                 pop     ecx
.text$mn:0000B5E9                 mov     esp, ebp
.text$mn:0000B5EB                 pop     ebp
.text$mn:0000B5EC                 retn    1Ch
.text$mn:0000B5EC ?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@0@Z endp
.text$mn:0000B5EC
.text$mn:0000B5EC ; ---------------------------------------------------------------------------
.text$mn:0000B5EF                 align 10h
.text$mn:0000B5EF _text$mn        ends
.text$mn:0000B5EF
.text$x:0000B5F0 ; ===========================================================================
.text$x:0000B5F0
.text$x:0000B5F0 ; Segment type: Pure code
.text$x:0000B5F0 ; Segment permissions: Read/Execute
.text$x:0000B5F0 _text$x         segment para public 'CODE' use32
.text$x:0000B5F0                 assume cs:_text$x
.text$x:0000B5F0                 ;org 0B5F0h
.text$x:0000B5F0 ; COMDAT (pick associative to section at B330)
.text$x:0000B5F0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000B5F0
.text$x:0000B5F0 ; =============== S U B R O U T I N E =======================================
.text$x:0000B5F0
.text$x:0000B5F0
.text$x:0000B5F0 __unwindfunclet$?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@0@Z$0 proc near
.text$x:0000B5F0                                         ; DATA XREF: .xdata$x:0000CF98o
.text$x:0000B5F0                 lea     ecx, [ebp+18h]
.text$x:0000B5F3                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$x:0000B5F3 __unwindfunclet$?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@0@Z$0 endp
.text$x:0000B5F3
.text$x:0000B5F8
.text$x:0000B5F8 ; =============== S U B R O U T I N E =======================================
.text$x:0000B5F8
.text$x:0000B5F8
.text$x:0000B5F8 __unwindfunclet$?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@0@Z$1 proc near
.text$x:0000B5F8                                         ; DATA XREF: .xdata$x:0000CFA0o
.text$x:0000B5F8                 lea     ecx, [ebp+0Ch]
.text$x:0000B5FB                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$x:0000B5FB __unwindfunclet$?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@0@Z$1 endp
.text$x:0000B5FB
.text$x:0000B600
.text$x:0000B600 ; =============== S U B R O U T I N E =======================================
.text$x:0000B600
.text$x:0000B600
.text$x:0000B600 __unwindfunclet$?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@0@Z$2 proc near
.text$x:0000B600                                         ; DATA XREF: .xdata$x:0000CFA8o
.text$x:0000B600                 mov     eax, [ebp-14h]
.text$x:0000B603                 and     eax, 1
.text$x:0000B606                 jz      $LN14
.text$x:0000B60C                 and     dword ptr [ebp-14h], 0FFFFFFFEh
.text$x:0000B610                 lea     ecx, [ebp-90h]
.text$x:0000B616                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$x:0000B61B ; ---------------------------------------------------------------------------
.text$x:0000B61B
.text$x:0000B61B $LN14:                                  ; CODE XREF: __unwindfunclet$?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@0@Z$2+6j
.text$x:0000B61B                 retn
.text$x:0000B61B __unwindfunclet$?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@0@Z$2 endp
.text$x:0000B61B
.text$x:0000B61C
.text$x:0000B61C ; =============== S U B R O U T I N E =======================================
.text$x:0000B61C
.text$x:0000B61C
.text$x:0000B61C __unwindfunclet$?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@0@Z$3 proc near
.text$x:0000B61C                                         ; DATA XREF: .xdata$x:0000CFB0o
.text$x:0000B61C                 mov     eax, [ebp-14h]
.text$x:0000B61F                 and     eax, 2
.text$x:0000B622                 jz      $LN16
.text$x:0000B628                 and     dword ptr [ebp-14h], 0FFFFFFFDh
.text$x:0000B62C                 lea     ecx, [ebp-84h]
.text$x:0000B632                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$x:0000B637 ; ---------------------------------------------------------------------------
.text$x:0000B637
.text$x:0000B637 $LN16:                                  ; CODE XREF: __unwindfunclet$?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@0@Z$3+6j
.text$x:0000B637                 retn
.text$x:0000B637 __unwindfunclet$?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@0@Z$3 endp
.text$x:0000B637
.text$x:0000B638
.text$x:0000B638 ; =============== S U B R O U T I N E =======================================
.text$x:0000B638
.text$x:0000B638
.text$x:0000B638 __unwindfunclet$?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@0@Z$4 proc near
.text$x:0000B638                                         ; DATA XREF: .xdata$x:0000CFB8o
.text$x:0000B638                 mov     ecx, [ebp-58h]
.text$x:0000B63B                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$x:0000B63B __unwindfunclet$?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@0@Z$4 endp
.text$x:0000B63B
.text$x:0000B640
.text$x:0000B640 ; =============== S U B R O U T I N E =======================================
.text$x:0000B640
.text$x:0000B640
.text$x:0000B640 __unwindfunclet$?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@0@Z$5 proc near
.text$x:0000B640                                         ; DATA XREF: .xdata$x:0000CFC0o
.text$x:0000B640                 lea     ecx, [ebp-2Ch]
.text$x:0000B643                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$x:0000B643 __unwindfunclet$?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@0@Z$5 endp
.text$x:0000B643
.text$x:0000B648
.text$x:0000B648 ; =============== S U B R O U T I N E =======================================
.text$x:0000B648
.text$x:0000B648
.text$x:0000B648 __unwindfunclet$?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@0@Z$6 proc near
.text$x:0000B648                                         ; DATA XREF: .xdata$x:0000CFC8o
.text$x:0000B648                 mov     ecx, [ebp-78h]
.text$x:0000B64B                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$x:0000B64B __unwindfunclet$?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@0@Z$6 endp
.text$x:0000B64B
.text$x:0000B650
.text$x:0000B650 ; =============== S U B R O U T I N E =======================================
.text$x:0000B650
.text$x:0000B650
.text$x:0000B650 __unwindfunclet$?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@0@Z$7 proc near
.text$x:0000B650                                         ; DATA XREF: .xdata$x:0000CFD0o
.text$x:0000B650                 lea     ecx, [ebp-54h]
.text$x:0000B653                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$x:0000B653 __unwindfunclet$?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@0@Z$7 endp
.text$x:0000B653
.text$x:0000B658
.text$x:0000B658 ; =============== S U B R O U T I N E =======================================
.text$x:0000B658
.text$x:0000B658
.text$x:0000B658 __unwindfunclet$?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@0@Z$8 proc near
.text$x:0000B658                                         ; DATA XREF: .xdata$x:0000CFD8o
.text$x:0000B658                 mov     ecx, [ebp-6Ch]
.text$x:0000B65B                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$x:0000B65B __unwindfunclet$?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@0@Z$8 endp
.text$x:0000B65B
.text$x:0000B660
.text$x:0000B660 ; =============== S U B R O U T I N E =======================================
.text$x:0000B660
.text$x:0000B660
.text$x:0000B660 __unwindfunclet$?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@0@Z$9 proc near
.text$x:0000B660                                         ; DATA XREF: .xdata$x:0000CF90o
.text$x:0000B660                 mov     eax, [ebp-14h]
.text$x:0000B663                 and     eax, 4
.text$x:0000B666                 jz      $LN25
.text$x:0000B66C                 and     dword ptr [ebp-14h], 0FFFFFFFBh
.text$x:0000B670                 mov     ecx, [ebp+8]
.text$x:0000B673                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$x:0000B678 ; ---------------------------------------------------------------------------
.text$x:0000B678
.text$x:0000B678 $LN25:                                  ; CODE XREF: __unwindfunclet$?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@0@Z$9+6j
.text$x:0000B678                 retn
.text$x:0000B678 __unwindfunclet$?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@0@Z$9 endp
.text$x:0000B678
.text$x:0000B679
.text$x:0000B679 ; =============== S U B R O U T I N E =======================================
.text$x:0000B679
.text$x:0000B679
.text$x:0000B679 __ehhandler$?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@0@Z proc near
.text$x:0000B679                                         ; DATA XREF: std::vector<int,std::allocator<int>>::erase(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>)+5o
.text$x:0000B679
.text$x:0000B679 arg_4           = dword ptr  8
.text$x:0000B679
.text$x:0000B679                 mov     edx, [esp+arg_4]
.text$x:0000B67D                 lea     eax, [edx+0Ch]
.text$x:0000B680                 mov     ecx, [edx-88h]
.text$x:0000B686                 xor     ecx, eax
.text$x:0000B688                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000B68D                 mov     eax, offset __ehfuncinfo$?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@0@Z
.text$x:0000B692                 jmp     ___CxxFrameHandler3
.text$x:0000B692 __ehhandler$?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@0@Z endp
.text$x:0000B692
.text$x:0000B692 ; ---------------------------------------------------------------------------
.text$x:0000B697                 align 4
.text$x:0000B697 _text$x         ends
.text$x:0000B697
.text$mn:0000B698 ; ===========================================================================
.text$mn:0000B698
.text$mn:0000B698 ; Segment type: Pure code
.text$mn:0000B698 ; Segment permissions: Read/Execute
.text$mn:0000B698 _text$mn        segment para public 'CODE' use32
.text$mn:0000B698                 assume cs:_text$mn
.text$mn:0000B698                 ;org 0B698h
.text$mn:0000B698 ; COMDAT (pick any)
.text$mn:0000B698                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B698
.text$mn:0000B698 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B698
.text$mn:0000B698 ; Attributes: bp-based frame
.text$mn:0000B698
.text$mn:0000B698 ; const struct std::error_category *__cdecl std::generic_category()
.text$mn:0000B698                 public ?generic_category@std@@YAABVerror_category@1@XZ
.text$mn:0000B698 ?generic_category@std@@YAABVerror_category@1@XZ proc near
.text$mn:0000B698                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+17p
.text$mn:0000B698                 push    ebp
.text$mn:0000B699                 mov     ebp, esp
.text$mn:0000B69B                 mov     eax, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
.text$mn:0000B6A0                 pop     ebp
.text$mn:0000B6A1                 retn
.text$mn:0000B6A1 ?generic_category@std@@YAABVerror_category@1@XZ endp
.text$mn:0000B6A1
.text$mn:0000B6A1 ; ---------------------------------------------------------------------------
.text$mn:0000B6A2                 align 4
.text$mn:0000B6A2 _text$mn        ends
.text$mn:0000B6A2
.text$mn:0000B6A4 ; ===========================================================================
.text$mn:0000B6A4
.text$mn:0000B6A4 ; Segment type: Pure code
.text$mn:0000B6A4 ; Segment permissions: Read/Execute
.text$mn:0000B6A4 _text$mn        segment para public 'CODE' use32
.text$mn:0000B6A4                 assume cs:_text$mn
.text$mn:0000B6A4                 ;org 0B6A4h
.text$mn:0000B6A4 ; COMDAT (pick any)
.text$mn:0000B6A4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B6A4
.text$mn:0000B6A4 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B6A4
.text$mn:0000B6A4 ; Attributes: bp-based frame
.text$mn:0000B6A4
.text$mn:0000B6A4 ; struct Buffer *__thiscall FileManager::getBufferByID(FileManager *this, struct Buffer *)
.text$mn:0000B6A4                 public ?getBufferByID@FileManager@@QAEPAVBuffer@@PAV2@@Z
.text$mn:0000B6A4 ?getBufferByID@FileManager@@QAEPAVBuffer@@PAV2@@Z proc near
.text$mn:0000B6A4                                         ; CODE XREF: WindowsDlg::run_dlgProc(uint,uint,long)+1F6p
.text$mn:0000B6A4                                         ; WindowsMenu::initPopupMenu(HMENU__ *,DocTabView *)+C3p ...
.text$mn:0000B6A4
.text$mn:0000B6A4 var_4           = dword ptr -4
.text$mn:0000B6A4 arg_0           = dword ptr  8
.text$mn:0000B6A4
.text$mn:0000B6A4                 push    ebp
.text$mn:0000B6A5                 mov     ebp, esp
.text$mn:0000B6A7                 push    ecx
.text$mn:0000B6A8                 mov     [ebp+var_4], ecx
.text$mn:0000B6AB                 mov     eax, [ebp+arg_0]
.text$mn:0000B6AE                 mov     esp, ebp
.text$mn:0000B6B0                 pop     ebp
.text$mn:0000B6B1                 retn    4
.text$mn:0000B6B1 ?getBufferByID@FileManager@@QAEPAVBuffer@@PAV2@@Z endp
.text$mn:0000B6B1
.text$mn:0000B6B1 _text$mn        ends
.text$mn:0000B6B1
.text$mn:0000B6B4 ; ===========================================================================
.text$mn:0000B6B4
.text$mn:0000B6B4 ; Segment type: Pure code
.text$mn:0000B6B4 ; Segment permissions: Read/Execute
.text$mn:0000B6B4 _text$mn        segment para public 'CODE' use32
.text$mn:0000B6B4                 assume cs:_text$mn
.text$mn:0000B6B4                 ;org 0B6B4h
.text$mn:0000B6B4 ; COMDAT (pick any)
.text$mn:0000B6B4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B6B4
.text$mn:0000B6B4 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B6B4
.text$mn:0000B6B4 ; Attributes: bp-based frame
.text$mn:0000B6B4
.text$mn:0000B6B4 ; void __thiscall Window::getClientRect(Window *this, struct tagRECT *)
.text$mn:0000B6B4                 public ?getClientRect@Window@@UBEXAAUtagRECT@@@Z
.text$mn:0000B6B4 ?getClientRect@Window@@UBEXAAUtagRECT@@@Z proc near
.text$mn:0000B6B4                                         ; DATA XREF: .rdata:0000DDECo
.text$mn:0000B6B4                                         ; .rdata:0000DE20o ...
.text$mn:0000B6B4
.text$mn:0000B6B4 var_4           = dword ptr -4
.text$mn:0000B6B4 lpRect          = dword ptr  8
.text$mn:0000B6B4
.text$mn:0000B6B4                 push    ebp
.text$mn:0000B6B5                 mov     ebp, esp
.text$mn:0000B6B7                 push    ecx
.text$mn:0000B6B8                 mov     [ebp+var_4], ecx
.text$mn:0000B6BB                 mov     eax, [ebp+lpRect]
.text$mn:0000B6BE                 push    eax             ; lpRect
.text$mn:0000B6BF                 mov     ecx, [ebp+var_4]
.text$mn:0000B6C2                 mov     edx, [ecx+0Ch]
.text$mn:0000B6C5                 push    edx             ; hWnd
.text$mn:0000B6C6                 call    dword ptr ds:__imp__GetClientRect@8 ; GetClientRect(x,x)
.text$mn:0000B6CC                 mov     esp, ebp
.text$mn:0000B6CE                 pop     ebp
.text$mn:0000B6CF                 retn    4
.text$mn:0000B6CF ?getClientRect@Window@@UBEXAAUtagRECT@@@Z endp
.text$mn:0000B6CF
.text$mn:0000B6CF ; ---------------------------------------------------------------------------
.text$mn:0000B6D2                 align 4
.text$mn:0000B6D2 _text$mn        ends
.text$mn:0000B6D2
.text$mn:0000B6D4 ; ===========================================================================
.text$mn:0000B6D4
.text$mn:0000B6D4 ; Segment type: Pure code
.text$mn:0000B6D4 ; Segment permissions: Read/Execute
.text$mn:0000B6D4 _text$mn        segment para public 'CODE' use32
.text$mn:0000B6D4                 assume cs:_text$mn
.text$mn:0000B6D4                 ;org 0B6D4h
.text$mn:0000B6D4 ; COMDAT (pick any)
.text$mn:0000B6D4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B6D4
.text$mn:0000B6D4 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B6D4
.text$mn:0000B6D4 ; Attributes: bp-based frame
.text$mn:0000B6D4
.text$mn:0000B6D4 ; int __thiscall TabBar::getCurrentTabIndex(TabBar *__hidden this)
.text$mn:0000B6D4                 public ?getCurrentTabIndex@TabBar@@QBEHXZ
.text$mn:0000B6D4 ?getCurrentTabIndex@TabBar@@QBEHXZ proc near
.text$mn:0000B6D4                                         ; CODE XREF: WindowsDlg::resetSelection(void)+31p
.text$mn:0000B6D4                                         ; WindowsMenu::initPopupMenu(HMENU__ *,DocTabView *)+3Fp
.text$mn:0000B6D4
.text$mn:0000B6D4 var_4           = dword ptr -4
.text$mn:0000B6D4
.text$mn:0000B6D4                 push    ebp
.text$mn:0000B6D5                 mov     ebp, esp
.text$mn:0000B6D7                 push    ecx
.text$mn:0000B6D8                 mov     [ebp+var_4], ecx
.text$mn:0000B6DB                 push    0               ; lParam
.text$mn:0000B6DD                 push    0               ; wParam
.text$mn:0000B6DF                 push    130Bh           ; Msg
.text$mn:0000B6E4                 mov     eax, [ebp+var_4]
.text$mn:0000B6E7                 mov     ecx, [eax+0Ch]
.text$mn:0000B6EA                 push    ecx             ; hWnd
.text$mn:0000B6EB                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:0000B6F1                 mov     esp, ebp
.text$mn:0000B6F3                 pop     ebp
.text$mn:0000B6F4                 retn
.text$mn:0000B6F4 ?getCurrentTabIndex@TabBar@@QBEHXZ endp
.text$mn:0000B6F4
.text$mn:0000B6F4 ; ---------------------------------------------------------------------------
.text$mn:0000B6F5                 align 4
.text$mn:0000B6F5 _text$mn        ends
.text$mn:0000B6F5
.text$mn:0000B6F8 ; ===========================================================================
.text$mn:0000B6F8
.text$mn:0000B6F8 ; Segment type: Pure code
.text$mn:0000B6F8 ; Segment permissions: Read/Execute
.text$mn:0000B6F8 _text$mn        segment para public 'CODE' use32
.text$mn:0000B6F8                 assume cs:_text$mn
.text$mn:0000B6F8                 ;org 0B6F8h
.text$mn:0000B6F8 ; COMDAT (pick any)
.text$mn:0000B6F8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B6F8
.text$mn:0000B6F8 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B6F8
.text$mn:0000B6F8 ; Attributes: bp-based frame
.text$mn:0000B6F8
.text$mn:0000B6F8 ; const wchar_t *__thiscall Buffer::getFileName(Buffer *__hidden this)
.text$mn:0000B6F8                 public ?getFileName@Buffer@@QBEPB_WXZ
.text$mn:0000B6F8 ?getFileName@Buffer@@QBEPB_WXZ proc near
.text$mn:0000B6F8                                         ; CODE XREF: WindowsDlg::run_dlgProc(uint,uint,long)+217p
.text$mn:0000B6F8                                         ; WindowsDlg::run_dlgProc(uint,uint,long)+300p ...
.text$mn:0000B6F8
.text$mn:0000B6F8 var_4           = dword ptr -4
.text$mn:0000B6F8
.text$mn:0000B6F8                 push    ebp
.text$mn:0000B6F9                 mov     ebp, esp
.text$mn:0000B6FB                 push    ecx
.text$mn:0000B6FC                 mov     [ebp+var_4], ecx
.text$mn:0000B6FF                 mov     eax, [ebp+var_4]
.text$mn:0000B702                 mov     eax, [eax+0A8h]
.text$mn:0000B708                 mov     esp, ebp
.text$mn:0000B70A                 pop     ebp
.text$mn:0000B70B                 retn
.text$mn:0000B70B ?getFileName@Buffer@@QBEPB_WXZ endp
.text$mn:0000B70B
.text$mn:0000B70B _text$mn        ends
.text$mn:0000B70B
.text$mn:0000B70C ; ===========================================================================
.text$mn:0000B70C
.text$mn:0000B70C ; Segment type: Pure code
.text$mn:0000B70C ; Segment permissions: Read/Execute
.text$mn:0000B70C _text$mn        segment para public 'CODE' use32
.text$mn:0000B70C                 assume cs:_text$mn
.text$mn:0000B70C                 ;org 0B70Ch
.text$mn:0000B70C ; COMDAT (pick any)
.text$mn:0000B70C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B70C
.text$mn:0000B70C ; =============== S U B R O U T I N E =======================================
.text$mn:0000B70C
.text$mn:0000B70C ; Attributes: bp-based frame
.text$mn:0000B70C
.text$mn:0000B70C ; const wchar_t *__thiscall Buffer::getFullPathName(Buffer *__hidden this)
.text$mn:0000B70C                 public ?getFullPathName@Buffer@@QBEPB_WXZ
.text$mn:0000B70C ?getFullPathName@Buffer@@QBEPB_WXZ proc near
.text$mn:0000B70C                                         ; CODE XREF: WindowsDlg::run_dlgProc(uint,uint,long)+2F5p
.text$mn:0000B70C                                         ; BufferEquivalent::compare(int,int)+92p ...
.text$mn:0000B70C
.text$mn:0000B70C var_4           = dword ptr -4
.text$mn:0000B70C
.text$mn:0000B70C                 push    ebp
.text$mn:0000B70D                 mov     ebp, esp
.text$mn:0000B70F                 push    ecx
.text$mn:0000B710                 mov     [ebp+var_4], ecx
.text$mn:0000B713                 mov     ecx, [ebp+var_4]
.text$mn:0000B716                 add     ecx, 8Ch ; ''
.text$mn:0000B71C                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:0000B721                 mov     esp, ebp
.text$mn:0000B723                 pop     ebp
.text$mn:0000B724                 retn
.text$mn:0000B724 ?getFullPathName@Buffer@@QBEPB_WXZ endp
.text$mn:0000B724
.text$mn:0000B724 ; ---------------------------------------------------------------------------
.text$mn:0000B725                 align 4
.text$mn:0000B725 _text$mn        ends
.text$mn:0000B725
.text$mn:0000B728 ; ===========================================================================
.text$mn:0000B728
.text$mn:0000B728 ; Segment type: Pure code
.text$mn:0000B728 ; Segment permissions: Read/Execute
.text$mn:0000B728 _text$mn        segment para public 'CODE' use32
.text$mn:0000B728                 assume cs:_text$mn
.text$mn:0000B728                 ;org 0B728h
.text$mn:0000B728 ; COMDAT (pick any)
.text$mn:0000B728                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B728
.text$mn:0000B728 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B728
.text$mn:0000B728 ; Attributes: bp-based frame
.text$mn:0000B728
.text$mn:0000B728 ; int __thiscall Window::getHeight(Window *__hidden this)
.text$mn:0000B728                 public ?getHeight@Window@@UBEHXZ
.text$mn:0000B728 ?getHeight@Window@@UBEHXZ proc near     ; DATA XREF: .rdata:0000DDF8o
.text$mn:0000B728                                         ; .rdata:0000DE2Co ...
.text$mn:0000B728
.text$mn:0000B728 var_18          = dword ptr -18h
.text$mn:0000B728 Rect            = tagRECT ptr -14h
.text$mn:0000B728 var_4           = dword ptr -4
.text$mn:0000B728
.text$mn:0000B728                 push    ebp
.text$mn:0000B729                 mov     ebp, esp
.text$mn:0000B72B                 sub     esp, 18h
.text$mn:0000B72E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000B733                 xor     eax, ebp
.text$mn:0000B735                 mov     [ebp+var_4], eax
.text$mn:0000B738                 mov     [ebp+var_18], ecx
.text$mn:0000B73B                 lea     eax, [ebp+Rect]
.text$mn:0000B73E                 push    eax             ; lpRect
.text$mn:0000B73F                 mov     ecx, [ebp+var_18]
.text$mn:0000B742                 mov     edx, [ecx+0Ch]
.text$mn:0000B745                 push    edx             ; hWnd
.text$mn:0000B746                 call    dword ptr ds:__imp__GetClientRect@8 ; GetClientRect(x,x)
.text$mn:0000B74C                 mov     eax, [ebp+var_18]
.text$mn:0000B74F                 mov     ecx, [eax+0Ch]
.text$mn:0000B752                 push    ecx             ; hWnd
.text$mn:0000B753                 call    dword ptr ds:__imp__IsWindowVisible@4 ; IsWindowVisible(x)
.text$mn:0000B759                 cmp     eax, 1
.text$mn:0000B75C                 jnz     short loc_B766
.text$mn:0000B75E                 mov     eax, [ebp+Rect.bottom]
.text$mn:0000B761                 sub     eax, [ebp+Rect.top]
.text$mn:0000B764                 jmp     short loc_B768
.text$mn:0000B766 ; ---------------------------------------------------------------------------
.text$mn:0000B766
.text$mn:0000B766 loc_B766:                               ; CODE XREF: Window::getHeight(void)+34j
.text$mn:0000B766                 xor     eax, eax
.text$mn:0000B768
.text$mn:0000B768 loc_B768:                               ; CODE XREF: Window::getHeight(void)+3Cj
.text$mn:0000B768                 mov     ecx, [ebp+var_4]
.text$mn:0000B76B                 xor     ecx, ebp
.text$mn:0000B76D                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:0000B772                 mov     esp, ebp
.text$mn:0000B774                 pop     ebp
.text$mn:0000B775                 retn
.text$mn:0000B775 ?getHeight@Window@@UBEHXZ endp
.text$mn:0000B775
.text$mn:0000B775 ; ---------------------------------------------------------------------------
.text$mn:0000B776                 align 4
.text$mn:0000B776 _text$mn        ends
.text$mn:0000B776
.text$mn:0000B778 ; ===========================================================================
.text$mn:0000B778
.text$mn:0000B778 ; Segment type: Pure code
.text$mn:0000B778 ; Segment permissions: Read/Execute
.text$mn:0000B778 _text$mn        segment para public 'CODE' use32
.text$mn:0000B778                 assume cs:_text$mn
.text$mn:0000B778                 ;org 0B778h
.text$mn:0000B778 ; COMDAT (pick any)
.text$mn:0000B778                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B778
.text$mn:0000B778 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B778
.text$mn:0000B778 ; Attributes: bp-based frame
.text$mn:0000B778
.text$mn:0000B778 ; struct EncodingMapper *__cdecl EncodingMapper::getInstance()
.text$mn:0000B778                 public ?getInstance@EncodingMapper@@SAPAV1@XZ
.text$mn:0000B778 ?getInstance@EncodingMapper@@SAPAV1@XZ proc near
.text$mn:0000B778                                         ; CODE XREF: WindowsDlg::changeDlgLang(void)+55p
.text$mn:0000B778                 push    ebp
.text$mn:0000B779                 mov     ebp, esp
.text$mn:0000B77B                 mov     eax, dword ptr ds:?_pSelf@EncodingMapper@@0PAV1@A ; EncodingMapper * EncodingMapper::_pSelf
.text$mn:0000B780                 pop     ebp
.text$mn:0000B781                 retn
.text$mn:0000B781 ?getInstance@EncodingMapper@@SAPAV1@XZ endp
.text$mn:0000B781
.text$mn:0000B781 ; ---------------------------------------------------------------------------
.text$mn:0000B782                 align 4
.text$mn:0000B782 _text$mn        ends
.text$mn:0000B782
.text$mn:0000B784 ; ===========================================================================
.text$mn:0000B784
.text$mn:0000B784 ; Segment type: Pure code
.text$mn:0000B784 ; Segment permissions: Read/Execute
.text$mn:0000B784 _text$mn        segment para public 'CODE' use32
.text$mn:0000B784                 assume cs:_text$mn
.text$mn:0000B784                 ;org 0B784h
.text$mn:0000B784 ; COMDAT (pick any)
.text$mn:0000B784                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B784
.text$mn:0000B784 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B784
.text$mn:0000B784 ; Attributes: bp-based frame
.text$mn:0000B784
.text$mn:0000B784 ; struct FileManager *__cdecl FileManager::getInstance()
.text$mn:0000B784                 public ?getInstance@FileManager@@SAPAV1@XZ
.text$mn:0000B784 ?getInstance@FileManager@@SAPAV1@XZ proc near
.text$mn:0000B784                                         ; CODE XREF: WindowsDlg::run_dlgProc(uint,uint,long)+1EFp
.text$mn:0000B784                                         ; WindowsMenu::initPopupMenu(HMENU__ *,DocTabView *)+BCp ...
.text$mn:0000B784                 push    ebp
.text$mn:0000B785                 mov     ebp, esp
.text$mn:0000B787                 mov     eax, dword ptr ds:?_pSelf@FileManager@@0PAV1@A ; FileManager * FileManager::_pSelf
.text$mn:0000B78C                 pop     ebp
.text$mn:0000B78D                 retn
.text$mn:0000B78D ?getInstance@FileManager@@SAPAV1@XZ endp
.text$mn:0000B78D
.text$mn:0000B78D ; ---------------------------------------------------------------------------
.text$mn:0000B78E                 align 10h
.text$mn:0000B78E _text$mn        ends
.text$mn:0000B78E
.text$mn:0000B790 ; ===========================================================================
.text$mn:0000B790
.text$mn:0000B790 ; Segment type: Pure code
.text$mn:0000B790 ; Segment permissions: Read/Execute
.text$mn:0000B790 _text$mn        segment para public 'CODE' use32
.text$mn:0000B790                 assume cs:_text$mn
.text$mn:0000B790                 ;org 0B790h
.text$mn:0000B790 ; COMDAT (pick any)
.text$mn:0000B790                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B790
.text$mn:0000B790 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B790
.text$mn:0000B790 ; Attributes: bp-based frame
.text$mn:0000B790
.text$mn:0000B790 ; struct NppParameters *__cdecl NppParameters::getInstance()
.text$mn:0000B790                 public ?getInstance@NppParameters@@SAPAV1@XZ
.text$mn:0000B790 ?getInstance@NppParameters@@SAPAV1@XZ proc near
.text$mn:0000B790                                         ; CODE XREF: WindowsDlg::run_dlgProc(uint,uint,long)+385p
.text$mn:0000B790                 push    ebp
.text$mn:0000B791                 mov     ebp, esp
.text$mn:0000B793                 mov     eax, dword ptr ds:?_pSelf@NppParameters@@0PAV1@A ; NppParameters * NppParameters::_pSelf
.text$mn:0000B798                 pop     ebp
.text$mn:0000B799                 retn
.text$mn:0000B799 ?getInstance@NppParameters@@SAPAV1@XZ endp
.text$mn:0000B799
.text$mn:0000B799 ; ---------------------------------------------------------------------------
.text$mn:0000B79A                 align 4
.text$mn:0000B79A _text$mn        ends
.text$mn:0000B79A
.text$mn:0000B79C ; ===========================================================================
.text$mn:0000B79C
.text$mn:0000B79C ; Segment type: Pure code
.text$mn:0000B79C ; Segment permissions: Read/Execute
.text$mn:0000B79C _text$mn        segment para public 'CODE' use32
.text$mn:0000B79C                 assume cs:_text$mn
.text$mn:0000B79C                 ;org 0B79Ch
.text$mn:0000B79C ; COMDAT (pick any)
.text$mn:0000B79C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B79C
.text$mn:0000B79C ; =============== S U B R O U T I N E =======================================
.text$mn:0000B79C
.text$mn:0000B79C ; Attributes: bp-based frame
.text$mn:0000B79C
.text$mn:0000B79C ; struct WcharMbcsConvertor *__cdecl WcharMbcsConvertor::getInstance()
.text$mn:0000B79C                 public ?getInstance@WcharMbcsConvertor@@SAPAV1@XZ
.text$mn:0000B79C ?getInstance@WcharMbcsConvertor@@SAPAV1@XZ proc near
.text$mn:0000B79C                                         ; CODE XREF: WindowsDlg::changeDlgLang(void):loc_6F9p
.text$mn:0000B79C                 push    ebp
.text$mn:0000B79D                 mov     ebp, esp
.text$mn:0000B79F                 mov     eax, dword ptr ds:?_pSelf@WcharMbcsConvertor@@1PAV1@A ; WcharMbcsConvertor * WcharMbcsConvertor::_pSelf
.text$mn:0000B7A4                 pop     ebp
.text$mn:0000B7A5                 retn
.text$mn:0000B7A5 ?getInstance@WcharMbcsConvertor@@SAPAV1@XZ endp
.text$mn:0000B7A5
.text$mn:0000B7A5 ; ---------------------------------------------------------------------------
.text$mn:0000B7A6                 align 4
.text$mn:0000B7A6 _text$mn        ends
.text$mn:0000B7A6
.text$mn:0000B7A8 ; ===========================================================================
.text$mn:0000B7A8
.text$mn:0000B7A8 ; Segment type: Pure code
.text$mn:0000B7A8 ; Segment permissions: Read/Execute
.text$mn:0000B7A8 _text$mn        segment para public 'CODE' use32
.text$mn:0000B7A8                 assume cs:_text$mn
.text$mn:0000B7A8                 ;org 0B7A8h
.text$mn:0000B7A8 ; COMDAT (pick any)
.text$mn:0000B7A8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B7A8
.text$mn:0000B7A8 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B7A8
.text$mn:0000B7A8 ; Attributes: bp-based frame
.text$mn:0000B7A8
.text$mn:0000B7A8 ; public: struct Lang * __thiscall NppParameters::getLangFromID(enum  LangType)const
.text$mn:0000B7A8                 public ?getLangFromID@NppParameters@@QBEPAULang@@W4LangType@@@Z
.text$mn:0000B7A8 ?getLangFromID@NppParameters@@QBEPAULang@@W4LangType@@@Z proc near
.text$mn:0000B7A8                                         ; CODE XREF: WindowsDlg::run_dlgProc(uint,uint,long)+399p
.text$mn:0000B7A8
.text$mn:0000B7A8 var_8           = dword ptr -8
.text$mn:0000B7A8 var_4           = dword ptr -4
.text$mn:0000B7A8 arg_0           = dword ptr  8
.text$mn:0000B7A8
.text$mn:0000B7A8                 push    ebp
.text$mn:0000B7A9                 mov     ebp, esp
.text$mn:0000B7AB                 sub     esp, 8
.text$mn:0000B7AE                 mov     [ebp+var_8], ecx
.text$mn:0000B7B1                 mov     [ebp+var_4], 0
.text$mn:0000B7B8                 jmp     short loc_B7C3
.text$mn:0000B7BA ; ---------------------------------------------------------------------------
.text$mn:0000B7BA
.text$mn:0000B7BA loc_B7BA:                               ; CODE XREF: NppParameters::getLangFromID(LangType):loc_B804j
.text$mn:0000B7BA                 mov     eax, [ebp+var_4]
.text$mn:0000B7BD                 add     eax, 1
.text$mn:0000B7C0                 mov     [ebp+var_4], eax
.text$mn:0000B7C3
.text$mn:0000B7C3 loc_B7C3:                               ; CODE XREF: NppParameters::getLangFromID(LangType)+10j
.text$mn:0000B7C3                 mov     ecx, [ebp+var_8]
.text$mn:0000B7C6                 mov     edx, [ebp+var_4]
.text$mn:0000B7C9                 cmp     edx, [ecx+92Ch]
.text$mn:0000B7CF                 jge     short loc_B806
.text$mn:0000B7D1                 mov     eax, [ebp+var_4]
.text$mn:0000B7D4                 mov     ecx, [ebp+var_8]
.text$mn:0000B7D7                 mov     edx, [ecx+eax*4+7ECh]
.text$mn:0000B7DE                 mov     eax, [edx]
.text$mn:0000B7E0                 cmp     eax, [ebp+arg_0]
.text$mn:0000B7E3                 jz      short loc_B7F5
.text$mn:0000B7E5                 mov     ecx, [ebp+var_4]
.text$mn:0000B7E8                 mov     edx, [ebp+var_8]
.text$mn:0000B7EB                 cmp     dword ptr [edx+ecx*4+7ECh], 0
.text$mn:0000B7F3                 jnz     short loc_B804
.text$mn:0000B7F5
.text$mn:0000B7F5 loc_B7F5:                               ; CODE XREF: NppParameters::getLangFromID(LangType)+3Bj
.text$mn:0000B7F5                 mov     eax, [ebp+var_4]
.text$mn:0000B7F8                 mov     ecx, [ebp+var_8]
.text$mn:0000B7FB                 mov     eax, [ecx+eax*4+7ECh]
.text$mn:0000B802                 jmp     short loc_B808
.text$mn:0000B804 ; ---------------------------------------------------------------------------
.text$mn:0000B804
.text$mn:0000B804 loc_B804:                               ; CODE XREF: NppParameters::getLangFromID(LangType)+4Bj
.text$mn:0000B804                 jmp     short loc_B7BA
.text$mn:0000B806 ; ---------------------------------------------------------------------------
.text$mn:0000B806
.text$mn:0000B806 loc_B806:                               ; CODE XREF: NppParameters::getLangFromID(LangType)+27j
.text$mn:0000B806                 xor     eax, eax
.text$mn:0000B808
.text$mn:0000B808 loc_B808:                               ; CODE XREF: NppParameters::getLangFromID(LangType)+5Aj
.text$mn:0000B808                 mov     esp, ebp
.text$mn:0000B80A                 pop     ebp
.text$mn:0000B80B                 retn    4
.text$mn:0000B80B ?getLangFromID@NppParameters@@QBEPAULang@@W4LangType@@@Z endp
.text$mn:0000B80B
.text$mn:0000B80B ; ---------------------------------------------------------------------------
.text$mn:0000B80E                 align 10h
.text$mn:0000B80E _text$mn        ends
.text$mn:0000B80E
.text$mn:0000B810 ; ===========================================================================
.text$mn:0000B810
.text$mn:0000B810 ; Segment type: Pure code
.text$mn:0000B810 ; Segment permissions: Read/Execute
.text$mn:0000B810 _text$mn        segment para public 'CODE' use32
.text$mn:0000B810                 assume cs:_text$mn
.text$mn:0000B810                 ;org 0B810h
.text$mn:0000B810 ; COMDAT (pick any)
.text$mn:0000B810                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B810
.text$mn:0000B810 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B810
.text$mn:0000B810 ; Attributes: bp-based frame
.text$mn:0000B810
.text$mn:0000B810 ; const wchar_t *__thiscall Lang::getLangName(Lang *__hidden this)
.text$mn:0000B810                 public ?getLangName@Lang@@QBEPB_WXZ
.text$mn:0000B810 ?getLangName@Lang@@QBEPB_WXZ proc near  ; CODE XREF: WindowsDlg::run_dlgProc(uint,uint,long)+3B1p
.text$mn:0000B810
.text$mn:0000B810 var_4           = dword ptr -4
.text$mn:0000B810
.text$mn:0000B810                 push    ebp
.text$mn:0000B811                 mov     ebp, esp
.text$mn:0000B813                 push    ecx
.text$mn:0000B814                 mov     [ebp+var_4], ecx
.text$mn:0000B817                 mov     ecx, [ebp+var_4]
.text$mn:0000B81A                 add     ecx, 4
.text$mn:0000B81D                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:0000B822                 mov     esp, ebp
.text$mn:0000B824                 pop     ebp
.text$mn:0000B825                 retn
.text$mn:0000B825 ?getLangName@Lang@@QBEPB_WXZ endp
.text$mn:0000B825
.text$mn:0000B825 ; ---------------------------------------------------------------------------
.text$mn:0000B826                 align 4
.text$mn:0000B826 _text$mn        ends
.text$mn:0000B826
.text$mn:0000B828 ; ===========================================================================
.text$mn:0000B828
.text$mn:0000B828 ; Segment type: Pure code
.text$mn:0000B828 ; Segment permissions: Read/Execute
.text$mn:0000B828 _text$mn        segment para public 'CODE' use32
.text$mn:0000B828                 assume cs:_text$mn
.text$mn:0000B828                 ;org 0B828h
.text$mn:0000B828 ; COMDAT (pick any)
.text$mn:0000B828                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B828
.text$mn:0000B828 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B828
.text$mn:0000B828 ; Attributes: bp-based frame
.text$mn:0000B828
.text$mn:0000B828 ; public: enum  LangType __thiscall Buffer::getLangType(void)const
.text$mn:0000B828                 public ?getLangType@Buffer@@QBE?AW4LangType@@XZ
.text$mn:0000B828 ?getLangType@Buffer@@QBE?AW4LangType@@XZ proc near
.text$mn:0000B828                                         ; CODE XREF: WindowsDlg::run_dlgProc(uint,uint,long)+390p
.text$mn:0000B828                                         ; BufferEquivalent::compare(int,int)+C5p ...
.text$mn:0000B828
.text$mn:0000B828 var_4           = dword ptr -4
.text$mn:0000B828
.text$mn:0000B828                 push    ebp
.text$mn:0000B829                 mov     ebp, esp
.text$mn:0000B82B                 push    ecx
.text$mn:0000B82C                 mov     [ebp+var_4], ecx
.text$mn:0000B82F                 mov     eax, [ebp+var_4]
.text$mn:0000B832                 mov     eax, [eax+14h]
.text$mn:0000B835                 mov     esp, ebp
.text$mn:0000B837                 pop     ebp
.text$mn:0000B838                 retn
.text$mn:0000B838 ?getLangType@Buffer@@QBE?AW4LangType@@XZ endp
.text$mn:0000B838
.text$mn:0000B838 ; ---------------------------------------------------------------------------
.text$mn:0000B839                 align 4
.text$mn:0000B839 _text$mn        ends
.text$mn:0000B839
.text$mn:0000B83C ; ===========================================================================
.text$mn:0000B83C
.text$mn:0000B83C ; Segment type: Pure code
.text$mn:0000B83C ; Segment permissions: Read/Execute
.text$mn:0000B83C _text$mn        segment para public 'CODE' use32
.text$mn:0000B83C                 assume cs:_text$mn
.text$mn:0000B83C                 ;org 0B83Ch
.text$mn:0000B83C ; COMDAT (pick any)
.text$mn:0000B83C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B83C
.text$mn:0000B83C ; =============== S U B R O U T I N E =======================================
.text$mn:0000B83C
.text$mn:0000B83C ; Attributes: bp-based frame
.text$mn:0000B83C
.text$mn:0000B83C ; int __thiscall Window::getWidth(Window *__hidden this)
.text$mn:0000B83C                 public ?getWidth@Window@@UBEHXZ
.text$mn:0000B83C ?getWidth@Window@@UBEHXZ proc near      ; DATA XREF: .rdata:0000DDF4o
.text$mn:0000B83C                                         ; .rdata:0000DE28o ...
.text$mn:0000B83C
.text$mn:0000B83C var_18          = dword ptr -18h
.text$mn:0000B83C Rect            = tagRECT ptr -14h
.text$mn:0000B83C var_4           = dword ptr -4
.text$mn:0000B83C
.text$mn:0000B83C                 push    ebp
.text$mn:0000B83D                 mov     ebp, esp
.text$mn:0000B83F                 sub     esp, 18h
.text$mn:0000B842                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000B847                 xor     eax, ebp
.text$mn:0000B849                 mov     [ebp+var_4], eax
.text$mn:0000B84C                 mov     [ebp+var_18], ecx
.text$mn:0000B84F                 lea     eax, [ebp+Rect]
.text$mn:0000B852                 push    eax             ; lpRect
.text$mn:0000B853                 mov     ecx, [ebp+var_18]
.text$mn:0000B856                 mov     edx, [ecx+0Ch]
.text$mn:0000B859                 push    edx             ; hWnd
.text$mn:0000B85A                 call    dword ptr ds:__imp__GetClientRect@8 ; GetClientRect(x,x)
.text$mn:0000B860                 mov     eax, [ebp+Rect.right]
.text$mn:0000B863                 sub     eax, [ebp+Rect.left]
.text$mn:0000B866                 mov     ecx, [ebp+var_4]
.text$mn:0000B869                 xor     ecx, ebp
.text$mn:0000B86B                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:0000B870                 mov     esp, ebp
.text$mn:0000B872                 pop     ebp
.text$mn:0000B873                 retn
.text$mn:0000B873 ?getWidth@Window@@UBEHXZ endp
.text$mn:0000B873
.text$mn:0000B873 _text$mn        ends
.text$mn:0000B873
.text$mn:0000B874 ; ===========================================================================
.text$mn:0000B874
.text$mn:0000B874 ; Segment type: Pure code
.text$mn:0000B874 ; Segment permissions: Read/Execute
.text$mn:0000B874 _text$mn        segment para public 'CODE' use32
.text$mn:0000B874                 assume cs:_text$mn
.text$mn:0000B874                 ;org 0B874h
.text$mn:0000B874 ; COMDAT (pick any)
.text$mn:0000B874                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B874
.text$mn:0000B874 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B874
.text$mn:0000B874 ; Attributes: bp-based frame
.text$mn:0000B874
.text$mn:0000B874 ; void __thiscall Window::getWindowRect(Window *this, struct tagRECT *)
.text$mn:0000B874                 public ?getWindowRect@Window@@UBEXAAUtagRECT@@@Z
.text$mn:0000B874 ?getWindowRect@Window@@UBEXAAUtagRECT@@@Z proc near
.text$mn:0000B874                                         ; DATA XREF: .rdata:0000DDF0o
.text$mn:0000B874                                         ; .rdata:0000DE24o ...
.text$mn:0000B874
.text$mn:0000B874 var_4           = dword ptr -4
.text$mn:0000B874 lpRect          = dword ptr  8
.text$mn:0000B874
.text$mn:0000B874                 push    ebp
.text$mn:0000B875                 mov     ebp, esp
.text$mn:0000B877                 push    ecx
.text$mn:0000B878                 mov     [ebp+var_4], ecx
.text$mn:0000B87B                 mov     eax, [ebp+lpRect]
.text$mn:0000B87E                 push    eax             ; lpRect
.text$mn:0000B87F                 mov     ecx, [ebp+var_4]
.text$mn:0000B882                 mov     edx, [ecx+0Ch]
.text$mn:0000B885                 push    edx             ; hWnd
.text$mn:0000B886                 call    dword ptr ds:__imp__GetWindowRect@8 ; GetWindowRect(x,x)
.text$mn:0000B88C                 mov     esp, ebp
.text$mn:0000B88E                 pop     ebp
.text$mn:0000B88F                 retn    4
.text$mn:0000B88F ?getWindowRect@Window@@UBEXAAUtagRECT@@@Z endp
.text$mn:0000B88F
.text$mn:0000B88F ; ---------------------------------------------------------------------------
.text$mn:0000B892                 align 4
.text$mn:0000B892 _text$mn        ends
.text$mn:0000B892
.text$mn:0000B894 ; ===========================================================================
.text$mn:0000B894
.text$mn:0000B894 ; Segment type: Pure code
.text$mn:0000B894 ; Segment permissions: Read/Execute
.text$mn:0000B894 _text$mn        segment para public 'CODE' use32
.text$mn:0000B894                 assume cs:_text$mn
.text$mn:0000B894                 ;org 0B894h
.text$mn:0000B894 ; COMDAT (pick any)
.text$mn:0000B894                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B894
.text$mn:0000B894 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B894
.text$mn:0000B894 ; Attributes: bp-based frame
.text$mn:0000B894
.text$mn:0000B894 ; void __thiscall Window::init(Window *this, HINSTANCE, HWND)
.text$mn:0000B894                 public ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z
.text$mn:0000B894 ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z proc near
.text$mn:0000B894                                         ; CODE XREF: WindowsDlg::init(HINSTANCE__ *,HWND__ *,DocTabView *)+12p
.text$mn:0000B894                                         ; WindowsDlg::init(HINSTANCE__ *,HWND__ *)+32p
.text$mn:0000B894                                         ; DATA XREF: ...
.text$mn:0000B894
.text$mn:0000B894 var_4           = dword ptr -4
.text$mn:0000B894 arg_0           = dword ptr  8
.text$mn:0000B894 arg_4           = dword ptr  0Ch
.text$mn:0000B894
.text$mn:0000B894                 push    ebp
.text$mn:0000B895                 mov     ebp, esp
.text$mn:0000B897                 push    ecx
.text$mn:0000B898                 mov     [ebp+var_4], ecx
.text$mn:0000B89B                 mov     eax, [ebp+var_4]
.text$mn:0000B89E                 mov     ecx, [ebp+arg_0]
.text$mn:0000B8A1                 mov     [eax+4], ecx
.text$mn:0000B8A4                 mov     edx, [ebp+var_4]
.text$mn:0000B8A7                 mov     eax, [ebp+arg_4]
.text$mn:0000B8AA                 mov     [edx+8], eax
.text$mn:0000B8AD                 mov     esp, ebp
.text$mn:0000B8AF                 pop     ebp
.text$mn:0000B8B0                 retn    8
.text$mn:0000B8B0 ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z endp
.text$mn:0000B8B0
.text$mn:0000B8B0 ; ---------------------------------------------------------------------------
.text$mn:0000B8B3                 align 4
.text$mn:0000B8B3 _text$mn        ends
.text$mn:0000B8B3
.text$mn:0000B8B4 ; ===========================================================================
.text$mn:0000B8B4
.text$mn:0000B8B4 ; Segment type: Pure code
.text$mn:0000B8B4 ; Segment permissions: Read/Execute
.text$mn:0000B8B4 _text$mn        segment para public 'CODE' use32
.text$mn:0000B8B4                 assume cs:_text$mn
.text$mn:0000B8B4                 ;org 0B8B4h
.text$mn:0000B8B4 ; COMDAT (pick any)
.text$mn:0000B8B4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B8B4
.text$mn:0000B8B4 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B8B4
.text$mn:0000B8B4 ; Attributes: bp-based frame
.text$mn:0000B8B4
.text$mn:0000B8B4 ; bool __thiscall StaticDialog::isCreated(StaticDialog *__hidden this)
.text$mn:0000B8B4                 public ?isCreated@StaticDialog@@UBE_NXZ
.text$mn:0000B8B4 ?isCreated@StaticDialog@@UBE_NXZ proc near
.text$mn:0000B8B4                                         ; CODE XREF: StaticDialog::~StaticDialog(void)+39p
.text$mn:0000B8B4                                         ; DATA XREF: .rdata:0000DE38o ...
.text$mn:0000B8B4
.text$mn:0000B8B4 var_8           = dword ptr -8
.text$mn:0000B8B4 var_4           = dword ptr -4
.text$mn:0000B8B4
.text$mn:0000B8B4                 push    ebp
.text$mn:0000B8B5                 mov     ebp, esp
.text$mn:0000B8B7                 sub     esp, 8
.text$mn:0000B8BA                 mov     [ebp+var_8], ecx
.text$mn:0000B8BD                 mov     eax, [ebp+var_8]
.text$mn:0000B8C0                 cmp     dword ptr [eax+0Ch], 0
.text$mn:0000B8C4                 jz      short loc_B8CF
.text$mn:0000B8C6                 mov     [ebp+var_4], 1
.text$mn:0000B8CD                 jmp     short loc_B8D6
.text$mn:0000B8CF ; ---------------------------------------------------------------------------
.text$mn:0000B8CF
.text$mn:0000B8CF loc_B8CF:                               ; CODE XREF: StaticDialog::isCreated(void)+10j
.text$mn:0000B8CF                 mov     [ebp+var_4], 0
.text$mn:0000B8D6
.text$mn:0000B8D6 loc_B8D6:                               ; CODE XREF: StaticDialog::isCreated(void)+19j
.text$mn:0000B8D6                 mov     al, byte ptr [ebp+var_4]
.text$mn:0000B8D9                 mov     esp, ebp
.text$mn:0000B8DB                 pop     ebp
.text$mn:0000B8DC                 retn
.text$mn:0000B8DC ?isCreated@StaticDialog@@UBE_NXZ endp
.text$mn:0000B8DC
.text$mn:0000B8DC ; ---------------------------------------------------------------------------
.text$mn:0000B8DD                 align 10h
.text$mn:0000B8DD _text$mn        ends
.text$mn:0000B8DD
.text$mn:0000B8E0 ; ===========================================================================
.text$mn:0000B8E0
.text$mn:0000B8E0 ; Segment type: Pure code
.text$mn:0000B8E0 ; Segment permissions: Read/Execute
.text$mn:0000B8E0 _text$mn        segment para public 'CODE' use32
.text$mn:0000B8E0                 assume cs:_text$mn
.text$mn:0000B8E0                 ;org 0B8E0h
.text$mn:0000B8E0 ; COMDAT (pick any)
.text$mn:0000B8E0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B8E0
.text$mn:0000B8E0 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B8E0
.text$mn:0000B8E0 ; Attributes: bp-based frame
.text$mn:0000B8E0
.text$mn:0000B8E0 ; bool __thiscall Buffer::isDirty(Buffer *__hidden this)
.text$mn:0000B8E0                 public ?isDirty@Buffer@@QBE_NXZ
.text$mn:0000B8E0 ?isDirty@Buffer@@QBE_NXZ proc near      ; CODE XREF: WindowsDlg::run_dlgProc(uint,uint,long)+25Cp
.text$mn:0000B8E0
.text$mn:0000B8E0 var_4           = dword ptr -4
.text$mn:0000B8E0
.text$mn:0000B8E0                 push    ebp
.text$mn:0000B8E1                 mov     ebp, esp
.text$mn:0000B8E3                 push    ecx
.text$mn:0000B8E4                 mov     [ebp+var_4], ecx
.text$mn:0000B8E7                 mov     eax, [ebp+var_4]
.text$mn:0000B8EA                 mov     al, [eax+34h]
.text$mn:0000B8ED                 mov     esp, ebp
.text$mn:0000B8EF                 pop     ebp
.text$mn:0000B8F0                 retn
.text$mn:0000B8F0 ?isDirty@Buffer@@QBE_NXZ endp
.text$mn:0000B8F0
.text$mn:0000B8F0 ; ---------------------------------------------------------------------------
.text$mn:0000B8F1                 align 4
.text$mn:0000B8F1 _text$mn        ends
.text$mn:0000B8F1
.text$mn:0000B8F4 ; ===========================================================================
.text$mn:0000B8F4
.text$mn:0000B8F4 ; Segment type: Pure code
.text$mn:0000B8F4 ; Segment permissions: Read/Execute
.text$mn:0000B8F4 _text$mn        segment para public 'CODE' use32
.text$mn:0000B8F4                 assume cs:_text$mn
.text$mn:0000B8F4                 ;org 0B8F4h
.text$mn:0000B8F4 ; COMDAT (pick any)
.text$mn:0000B8F4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B8F4
.text$mn:0000B8F4 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B8F4
.text$mn:0000B8F4 ; Attributes: bp-based frame
.text$mn:0000B8F4
.text$mn:0000B8F4 ; bool __thiscall Buffer::isReadOnly(Buffer *__hidden this)
.text$mn:0000B8F4                 public ?isReadOnly@Buffer@@QBE_NXZ
.text$mn:0000B8F4 ?isReadOnly@Buffer@@QBE_NXZ proc near   ; CODE XREF: WindowsDlg::run_dlgProc(uint,uint,long)+2A2p
.text$mn:0000B8F4
.text$mn:0000B8F4 var_8           = dword ptr -8
.text$mn:0000B8F4 var_4           = dword ptr -4
.text$mn:0000B8F4
.text$mn:0000B8F4                 push    ebp
.text$mn:0000B8F5                 mov     ebp, esp
.text$mn:0000B8F7                 sub     esp, 8
.text$mn:0000B8FA                 mov     [ebp+var_4], ecx
.text$mn:0000B8FD                 mov     eax, [ebp+var_4]
.text$mn:0000B900                 movzx   ecx, byte ptr [eax+44h]
.text$mn:0000B904                 test    ecx, ecx
.text$mn:0000B906                 jnz     short loc_B91F
.text$mn:0000B908                 mov     edx, [ebp+var_4]
.text$mn:0000B90B                 movzx   eax, byte ptr [edx+88h]
.text$mn:0000B912                 test    eax, eax
.text$mn:0000B914                 jnz     short loc_B91F
.text$mn:0000B916                 mov     [ebp+var_8], 0
.text$mn:0000B91D                 jmp     short loc_B926
.text$mn:0000B91F ; ---------------------------------------------------------------------------
.text$mn:0000B91F
.text$mn:0000B91F loc_B91F:                               ; CODE XREF: Buffer::isReadOnly(void)+12j
.text$mn:0000B91F                                         ; Buffer::isReadOnly(void)+20j
.text$mn:0000B91F                 mov     [ebp+var_8], 1
.text$mn:0000B926
.text$mn:0000B926 loc_B926:                               ; CODE XREF: Buffer::isReadOnly(void)+29j
.text$mn:0000B926                 mov     al, byte ptr [ebp+var_8]
.text$mn:0000B929                 mov     esp, ebp
.text$mn:0000B92B                 pop     ebp
.text$mn:0000B92C                 retn
.text$mn:0000B92C ?isReadOnly@Buffer@@QBE_NXZ endp
.text$mn:0000B92C
.text$mn:0000B92C ; ---------------------------------------------------------------------------
.text$mn:0000B92D                 align 10h
.text$mn:0000B92D _text$mn        ends
.text$mn:0000B92D
.text$mn:0000B930 ; ===========================================================================
.text$mn:0000B930
.text$mn:0000B930 ; Segment type: Pure code
.text$mn:0000B930 ; Segment permissions: Read/Execute
.text$mn:0000B930 _text$mn        segment para public 'CODE' use32
.text$mn:0000B930                 assume cs:_text$mn
.text$mn:0000B930                 ;org 0B930h
.text$mn:0000B930 ; COMDAT (pick any)
.text$mn:0000B930                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B930
.text$mn:0000B930 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B930
.text$mn:0000B930 ; Attributes: bp-based frame
.text$mn:0000B930
.text$mn:0000B930 ; bool __thiscall Window::isVisible(Window *__hidden this)
.text$mn:0000B930                 public ?isVisible@Window@@UBE_NXZ
.text$mn:0000B930 ?isVisible@Window@@UBE_NXZ proc near    ; DATA XREF: .rdata:0000DDFCo
.text$mn:0000B930                                         ; .rdata:0000DE30o ...
.text$mn:0000B930
.text$mn:0000B930 var_8           = dword ptr -8
.text$mn:0000B930 var_1           = byte ptr -1
.text$mn:0000B930
.text$mn:0000B930                 push    ebp
.text$mn:0000B931                 mov     ebp, esp
.text$mn:0000B933                 sub     esp, 8
.text$mn:0000B936                 mov     [ebp+var_8], ecx
.text$mn:0000B939                 mov     eax, [ebp+var_8]
.text$mn:0000B93C                 mov     ecx, [eax+0Ch]
.text$mn:0000B93F                 push    ecx             ; hWnd
.text$mn:0000B940                 call    dword ptr ds:__imp__IsWindowVisible@4 ; IsWindowVisible(x)
.text$mn:0000B946                 test    eax, eax
.text$mn:0000B948                 jz      short loc_B950
.text$mn:0000B94A                 mov     [ebp+var_1], 1
.text$mn:0000B94E                 jmp     short loc_B954
.text$mn:0000B950 ; ---------------------------------------------------------------------------
.text$mn:0000B950
.text$mn:0000B950 loc_B950:                               ; CODE XREF: Window::isVisible(void)+18j
.text$mn:0000B950                 mov     [ebp+var_1], 0
.text$mn:0000B954
.text$mn:0000B954 loc_B954:                               ; CODE XREF: Window::isVisible(void)+1Ej
.text$mn:0000B954                 mov     al, [ebp+var_1]
.text$mn:0000B957                 mov     esp, ebp
.text$mn:0000B959                 pop     ebp
.text$mn:0000B95A                 retn
.text$mn:0000B95A ?isVisible@Window@@UBE_NXZ endp
.text$mn:0000B95A
.text$mn:0000B95A ; ---------------------------------------------------------------------------
.text$mn:0000B95B                 align 4
.text$mn:0000B95B _text$mn        ends
.text$mn:0000B95B
.text$mn:0000B95C ; ===========================================================================
.text$mn:0000B95C
.text$mn:0000B95C ; Segment type: Pure code
.text$mn:0000B95C ; Segment permissions: Read/Execute
.text$mn:0000B95C _text$mn        segment para public 'CODE' use32
.text$mn:0000B95C                 assume cs:_text$mn
.text$mn:0000B95C                 ;org 0B95Ch
.text$mn:0000B95C ; COMDAT (pick any)
.text$mn:0000B95C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B95C
.text$mn:0000B95C ; =============== S U B R O U T I N E =======================================
.text$mn:0000B95C
.text$mn:0000B95C ; Attributes: bp-based frame
.text$mn:0000B95C
.text$mn:0000B95C ; int __cdecl std::char_traits<char>::length(char *Str)
.text$mn:0000B95C                 public ?length@?$char_traits@D@std@@SAIPBD@Z
.text$mn:0000B95C ?length@?$char_traits@D@std@@SAIPBD@Z proc near
.text$mn:0000B95C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+21p
.text$mn:0000B95C
.text$mn:0000B95C var_4           = dword ptr -4
.text$mn:0000B95C Str             = dword ptr  8
.text$mn:0000B95C
.text$mn:0000B95C                 push    ebp
.text$mn:0000B95D                 mov     ebp, esp
.text$mn:0000B95F                 push    ecx
.text$mn:0000B960                 mov     eax, [ebp+Str]
.text$mn:0000B963                 movsx   ecx, byte ptr [eax]
.text$mn:0000B966                 test    ecx, ecx
.text$mn:0000B968                 jnz     short loc_B973
.text$mn:0000B96A                 mov     [ebp+var_4], 0
.text$mn:0000B971                 jmp     short loc_B982
.text$mn:0000B973 ; ---------------------------------------------------------------------------
.text$mn:0000B973
.text$mn:0000B973 loc_B973:                               ; CODE XREF: std::char_traits<char>::length(char const *)+Cj
.text$mn:0000B973                 mov     edx, [ebp+Str]
.text$mn:0000B976                 push    edx             ; Str
.text$mn:0000B977                 call    _strlen
.text$mn:0000B97C                 add     esp, 4
.text$mn:0000B97F                 mov     [ebp+var_4], eax
.text$mn:0000B982
.text$mn:0000B982 loc_B982:                               ; CODE XREF: std::char_traits<char>::length(char const *)+15j
.text$mn:0000B982                 mov     eax, [ebp+var_4]
.text$mn:0000B985                 mov     esp, ebp
.text$mn:0000B987                 pop     ebp
.text$mn:0000B988                 retn
.text$mn:0000B988 ?length@?$char_traits@D@std@@SAIPBD@Z endp
.text$mn:0000B988
.text$mn:0000B988 ; ---------------------------------------------------------------------------
.text$mn:0000B989                 align 4
.text$mn:0000B989 _text$mn        ends
.text$mn:0000B989
.text$mn:0000B98C ; ===========================================================================
.text$mn:0000B98C
.text$mn:0000B98C ; Segment type: Pure code
.text$mn:0000B98C ; Segment permissions: Read/Execute
.text$mn:0000B98C _text$mn        segment para public 'CODE' use32
.text$mn:0000B98C                 assume cs:_text$mn
.text$mn:0000B98C                 ;org 0B98Ch
.text$mn:0000B98C ; COMDAT (pick any)
.text$mn:0000B98C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B98C
.text$mn:0000B98C ; =============== S U B R O U T I N E =======================================
.text$mn:0000B98C
.text$mn:0000B98C ; Attributes: bp-based frame
.text$mn:0000B98C
.text$mn:0000B98C ; int __cdecl std::char_traits<wchar_t>::length(wchar_t *Str)
.text$mn:0000B98C                 public ?length@?$char_traits@_W@std@@SAIPB_W@Z
.text$mn:0000B98C ?length@?$char_traits@_W@std@@SAIPB_W@Z proc near
.text$mn:0000B98C                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *)+21p
.text$mn:0000B98C                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *)+21p
.text$mn:0000B98C
.text$mn:0000B98C var_4           = dword ptr -4
.text$mn:0000B98C Str             = dword ptr  8
.text$mn:0000B98C
.text$mn:0000B98C                 push    ebp
.text$mn:0000B98D                 mov     ebp, esp
.text$mn:0000B98F                 push    ecx
.text$mn:0000B990                 mov     eax, [ebp+Str]
.text$mn:0000B993                 movzx   ecx, word ptr [eax]
.text$mn:0000B996                 test    ecx, ecx
.text$mn:0000B998                 jnz     short loc_B9A3
.text$mn:0000B99A                 mov     [ebp+var_4], 0
.text$mn:0000B9A1                 jmp     short loc_B9B2
.text$mn:0000B9A3 ; ---------------------------------------------------------------------------
.text$mn:0000B9A3
.text$mn:0000B9A3 loc_B9A3:                               ; CODE XREF: std::char_traits<wchar_t>::length(wchar_t const *)+Cj
.text$mn:0000B9A3                 mov     edx, [ebp+Str]
.text$mn:0000B9A6                 push    edx             ; Str
.text$mn:0000B9A7                 call    _wcslen
.text$mn:0000B9AC                 add     esp, 4
.text$mn:0000B9AF                 mov     [ebp+var_4], eax
.text$mn:0000B9B2
.text$mn:0000B9B2 loc_B9B2:                               ; CODE XREF: std::char_traits<wchar_t>::length(wchar_t const *)+15j
.text$mn:0000B9B2                 mov     eax, [ebp+var_4]
.text$mn:0000B9B5                 mov     esp, ebp
.text$mn:0000B9B7                 pop     ebp
.text$mn:0000B9B8                 retn
.text$mn:0000B9B8 ?length@?$char_traits@_W@std@@SAIPB_W@Z endp
.text$mn:0000B9B8
.text$mn:0000B9B8 ; ---------------------------------------------------------------------------
.text$mn:0000B9B9                 align 4
.text$mn:0000B9B9 _text$mn        ends
.text$mn:0000B9B9
.text$mn:0000B9BC ; ===========================================================================
.text$mn:0000B9BC
.text$mn:0000B9BC ; Segment type: Pure code
.text$mn:0000B9BC ; Segment permissions: Read/Execute
.text$mn:0000B9BC _text$mn        segment para public 'CODE' use32
.text$mn:0000B9BC                 assume cs:_text$mn
.text$mn:0000B9BC                 ;org 0B9BCh
.text$mn:0000B9BC ; COMDAT (pick any)
.text$mn:0000B9BC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B9BC
.text$mn:0000B9BC ; =============== S U B R O U T I N E =======================================
.text$mn:0000B9BC
.text$mn:0000B9BC ; Attributes: bp-based frame
.text$mn:0000B9BC
.text$mn:0000B9BC ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<char>>::max_size(void)const
.text$mn:0000B9BC                 public ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
.text$mn:0000B9BC ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ proc near
.text$mn:0000B9BC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+17p
.text$mn:0000B9BC
.text$mn:0000B9BC var_4           = dword ptr -4
.text$mn:0000B9BC
.text$mn:0000B9BC                 push    ebp
.text$mn:0000B9BD                 mov     ebp, esp
.text$mn:0000B9BF                 push    ecx
.text$mn:0000B9C0                 mov     [ebp+var_4], ecx
.text$mn:0000B9C3                 mov     eax, [ebp+var_4]
.text$mn:0000B9C6                 push    eax
.text$mn:0000B9C7                 call    ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char> const &)
.text$mn:0000B9CC                 add     esp, 4
.text$mn:0000B9CF                 mov     esp, ebp
.text$mn:0000B9D1                 pop     ebp
.text$mn:0000B9D2                 retn
.text$mn:0000B9D2 ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ endp
.text$mn:0000B9D2
.text$mn:0000B9D2 ; ---------------------------------------------------------------------------
.text$mn:0000B9D3                 align 4
.text$mn:0000B9D3 _text$mn        ends
.text$mn:0000B9D3
.text$mn:0000B9D4 ; ===========================================================================
.text$mn:0000B9D4
.text$mn:0000B9D4 ; Segment type: Pure code
.text$mn:0000B9D4 ; Segment permissions: Read/Execute
.text$mn:0000B9D4 _text$mn        segment para public 'CODE' use32
.text$mn:0000B9D4                 assume cs:_text$mn
.text$mn:0000B9D4                 ;org 0B9D4h
.text$mn:0000B9D4 ; COMDAT (pick any)
.text$mn:0000B9D4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B9D4
.text$mn:0000B9D4 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B9D4
.text$mn:0000B9D4 ; Attributes: bp-based frame
.text$mn:0000B9D4
.text$mn:0000B9D4 ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<int>>::max_size(void)const
.text$mn:0000B9D4                 public ?max_size@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QBEIXZ
.text$mn:0000B9D4 ?max_size@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QBEIXZ proc near
.text$mn:0000B9D4                                         ; CODE XREF: std::vector<int,std::allocator<int>>::max_size(void)+17p
.text$mn:0000B9D4
.text$mn:0000B9D4 var_4           = dword ptr -4
.text$mn:0000B9D4
.text$mn:0000B9D4                 push    ebp
.text$mn:0000B9D5                 mov     ebp, esp
.text$mn:0000B9D7                 push    ecx
.text$mn:0000B9D8                 mov     [ebp+var_4], ecx
.text$mn:0000B9DB                 mov     eax, [ebp+var_4]
.text$mn:0000B9DE                 push    eax
.text$mn:0000B9DF                 call    ?max_size@?$allocator_traits@V?$allocator@H@std@@@std@@SAIABV?$allocator@H@2@@Z ; std::allocator_traits<std::allocator<int>>::max_size(std::allocator<int> const &)
.text$mn:0000B9E4                 add     esp, 4
.text$mn:0000B9E7                 mov     esp, ebp
.text$mn:0000B9E9                 pop     ebp
.text$mn:0000B9EA                 retn
.text$mn:0000B9EA ?max_size@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QBEIXZ endp
.text$mn:0000B9EA
.text$mn:0000B9EA ; ---------------------------------------------------------------------------
.text$mn:0000B9EB                 align 4
.text$mn:0000B9EB _text$mn        ends
.text$mn:0000B9EB
.text$mn:0000B9EC ; ===========================================================================
.text$mn:0000B9EC
.text$mn:0000B9EC ; Segment type: Pure code
.text$mn:0000B9EC ; Segment permissions: Read/Execute
.text$mn:0000B9EC _text$mn        segment para public 'CODE' use32
.text$mn:0000B9EC                 assume cs:_text$mn
.text$mn:0000B9EC                 ;org 0B9ECh
.text$mn:0000B9EC ; COMDAT (pick any)
.text$mn:0000B9EC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B9EC
.text$mn:0000B9EC ; =============== S U B R O U T I N E =======================================
.text$mn:0000B9EC
.text$mn:0000B9EC ; Attributes: bp-based frame
.text$mn:0000B9EC
.text$mn:0000B9EC ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<wchar_t>>::max_size(void)const
.text$mn:0000B9EC                 public ?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIXZ
.text$mn:0000B9EC ?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIXZ proc near
.text$mn:0000B9EC                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)+17p
.text$mn:0000B9EC                                         ; std::vector<wchar_t,std::allocator<wchar_t>>::max_size(void)+17p
.text$mn:0000B9EC
.text$mn:0000B9EC var_4           = dword ptr -4
.text$mn:0000B9EC
.text$mn:0000B9EC                 push    ebp
.text$mn:0000B9ED                 mov     ebp, esp
.text$mn:0000B9EF                 push    ecx
.text$mn:0000B9F0                 mov     [ebp+var_4], ecx
.text$mn:0000B9F3                 mov     eax, [ebp+var_4]
.text$mn:0000B9F6                 push    eax
.text$mn:0000B9F7                 call    ?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z ; std::allocator_traits<std::allocator<wchar_t>>::max_size(std::allocator<wchar_t> const &)
.text$mn:0000B9FC                 add     esp, 4
.text$mn:0000B9FF                 mov     esp, ebp
.text$mn:0000BA01                 pop     ebp
.text$mn:0000BA02                 retn
.text$mn:0000BA02 ?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIXZ endp
.text$mn:0000BA02
.text$mn:0000BA02 ; ---------------------------------------------------------------------------
.text$mn:0000BA03                 align 4
.text$mn:0000BA03 _text$mn        ends
.text$mn:0000BA03
.text$mn:0000BA04 ; ===========================================================================
.text$mn:0000BA04
.text$mn:0000BA04 ; Segment type: Pure code
.text$mn:0000BA04 ; Segment permissions: Read/Execute
.text$mn:0000BA04 _text$mn        segment para public 'CODE' use32
.text$mn:0000BA04                 assume cs:_text$mn
.text$mn:0000BA04                 ;org 0BA04h
.text$mn:0000BA04 ; COMDAT (pick any)
.text$mn:0000BA04                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000BA04
.text$mn:0000BA04 ; =============== S U B R O U T I N E =======================================
.text$mn:0000BA04
.text$mn:0000BA04 ; Attributes: bp-based frame
.text$mn:0000BA04
.text$mn:0000BA04 ; public: unsigned int __thiscall std::allocator<char>::max_size(void)const
.text$mn:0000BA04                 public ?max_size@?$allocator@D@std@@QBEIXZ
.text$mn:0000BA04 ?max_size@?$allocator@D@std@@QBEIXZ proc near
.text$mn:0000BA04                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char> const &)+6p
.text$mn:0000BA04
.text$mn:0000BA04 var_4           = dword ptr -4
.text$mn:0000BA04
.text$mn:0000BA04                 push    ebp
.text$mn:0000BA05                 mov     ebp, esp
.text$mn:0000BA07                 push    ecx
.text$mn:0000BA08                 mov     [ebp+var_4], ecx
.text$mn:0000BA0B                 or      eax, 0FFFFFFFFh
.text$mn:0000BA0E                 mov     esp, ebp
.text$mn:0000BA10                 pop     ebp
.text$mn:0000BA11                 retn
.text$mn:0000BA11 ?max_size@?$allocator@D@std@@QBEIXZ endp
.text$mn:0000BA11
.text$mn:0000BA11 ; ---------------------------------------------------------------------------
.text$mn:0000BA12                 align 4
.text$mn:0000BA12 _text$mn        ends
.text$mn:0000BA12
.text$mn:0000BA14 ; ===========================================================================
.text$mn:0000BA14
.text$mn:0000BA14 ; Segment type: Pure code
.text$mn:0000BA14 ; Segment permissions: Read/Execute
.text$mn:0000BA14 _text$mn        segment para public 'CODE' use32
.text$mn:0000BA14                 assume cs:_text$mn
.text$mn:0000BA14                 ;org 0BA14h
.text$mn:0000BA14 ; COMDAT (pick any)
.text$mn:0000BA14                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000BA14
.text$mn:0000BA14 ; =============== S U B R O U T I N E =======================================
.text$mn:0000BA14
.text$mn:0000BA14 ; Attributes: bp-based frame
.text$mn:0000BA14
.text$mn:0000BA14 ; public: unsigned int __thiscall std::allocator<int>::max_size(void)const
.text$mn:0000BA14                 public ?max_size@?$allocator@H@std@@QBEIXZ
.text$mn:0000BA14 ?max_size@?$allocator@H@std@@QBEIXZ proc near
.text$mn:0000BA14                                         ; CODE XREF: std::allocator_traits<std::allocator<int>>::max_size(std::allocator<int> const &)+6p
.text$mn:0000BA14
.text$mn:0000BA14 var_4           = dword ptr -4
.text$mn:0000BA14
.text$mn:0000BA14                 push    ebp
.text$mn:0000BA15                 mov     ebp, esp
.text$mn:0000BA17                 push    ecx
.text$mn:0000BA18                 mov     [ebp+var_4], ecx
.text$mn:0000BA1B                 mov     eax, 3FFFFFFFh
.text$mn:0000BA20                 mov     esp, ebp
.text$mn:0000BA22                 pop     ebp
.text$mn:0000BA23                 retn
.text$mn:0000BA23 ?max_size@?$allocator@H@std@@QBEIXZ endp
.text$mn:0000BA23
.text$mn:0000BA23 _text$mn        ends
.text$mn:0000BA23
.text$mn:0000BA24 ; ===========================================================================
.text$mn:0000BA24
.text$mn:0000BA24 ; Segment type: Pure code
.text$mn:0000BA24 ; Segment permissions: Read/Execute
.text$mn:0000BA24 _text$mn        segment para public 'CODE' use32
.text$mn:0000BA24                 assume cs:_text$mn
.text$mn:0000BA24                 ;org 0BA24h
.text$mn:0000BA24 ; COMDAT (pick any)
.text$mn:0000BA24                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000BA24
.text$mn:0000BA24 ; =============== S U B R O U T I N E =======================================
.text$mn:0000BA24
.text$mn:0000BA24 ; Attributes: bp-based frame
.text$mn:0000BA24
.text$mn:0000BA24 ; public: unsigned int __thiscall std::allocator<wchar_t>::max_size(void)const
.text$mn:0000BA24                 public ?max_size@?$allocator@_W@std@@QBEIXZ
.text$mn:0000BA24 ?max_size@?$allocator@_W@std@@QBEIXZ proc near
.text$mn:0000BA24                                         ; CODE XREF: std::allocator_traits<std::allocator<wchar_t>>::max_size(std::allocator<wchar_t> const &)+6p
.text$mn:0000BA24
.text$mn:0000BA24 var_4           = dword ptr -4
.text$mn:0000BA24
.text$mn:0000BA24                 push    ebp
.text$mn:0000BA25                 mov     ebp, esp
.text$mn:0000BA27                 push    ecx
.text$mn:0000BA28                 mov     [ebp+var_4], ecx
.text$mn:0000BA2B                 mov     eax, 7FFFFFFFh
.text$mn:0000BA30                 mov     esp, ebp
.text$mn:0000BA32                 pop     ebp
.text$mn:0000BA33                 retn
.text$mn:0000BA33 ?max_size@?$allocator@_W@std@@QBEIXZ endp
.text$mn:0000BA33
.text$mn:0000BA33 _text$mn        ends
.text$mn:0000BA33
.text$mn:0000BA34 ; ===========================================================================
.text$mn:0000BA34
.text$mn:0000BA34 ; Segment type: Pure code
.text$mn:0000BA34 ; Segment permissions: Read/Execute
.text$mn:0000BA34 _text$mn        segment para public 'CODE' use32
.text$mn:0000BA34                 assume cs:_text$mn
.text$mn:0000BA34                 ;org 0BA34h
.text$mn:0000BA34 ; COMDAT (pick any)
.text$mn:0000BA34                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000BA34
.text$mn:0000BA34 ; =============== S U B R O U T I N E =======================================
.text$mn:0000BA34
.text$mn:0000BA34 ; Attributes: bp-based frame
.text$mn:0000BA34
.text$mn:0000BA34 ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<char>>::max_size(class std::allocator<char> const &)
.text$mn:0000BA34                 public ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
.text$mn:0000BA34 ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z proc near
.text$mn:0000BA34                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::max_size(void)+Bp
.text$mn:0000BA34
.text$mn:0000BA34 arg_0           = dword ptr  8
.text$mn:0000BA34
.text$mn:0000BA34                 push    ebp
.text$mn:0000BA35                 mov     ebp, esp
.text$mn:0000BA37                 mov     ecx, [ebp+arg_0]
.text$mn:0000BA3A                 call    ?max_size@?$allocator@D@std@@QBEIXZ ; std::allocator<char>::max_size(void)
.text$mn:0000BA3F                 pop     ebp
.text$mn:0000BA40                 retn
.text$mn:0000BA40 ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z endp
.text$mn:0000BA40
.text$mn:0000BA40 ; ---------------------------------------------------------------------------
.text$mn:0000BA41                 align 4
.text$mn:0000BA41 _text$mn        ends
.text$mn:0000BA41
.text$mn:0000BA44 ; ===========================================================================
.text$mn:0000BA44
.text$mn:0000BA44 ; Segment type: Pure code
.text$mn:0000BA44 ; Segment permissions: Read/Execute
.text$mn:0000BA44 _text$mn        segment para public 'CODE' use32
.text$mn:0000BA44                 assume cs:_text$mn
.text$mn:0000BA44                 ;org 0BA44h
.text$mn:0000BA44 ; COMDAT (pick any)
.text$mn:0000BA44                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000BA44
.text$mn:0000BA44 ; =============== S U B R O U T I N E =======================================
.text$mn:0000BA44
.text$mn:0000BA44 ; Attributes: bp-based frame
.text$mn:0000BA44
.text$mn:0000BA44 ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<int>>::max_size(class std::allocator<int> const &)
.text$mn:0000BA44                 public ?max_size@?$allocator_traits@V?$allocator@H@std@@@std@@SAIABV?$allocator@H@2@@Z
.text$mn:0000BA44 ?max_size@?$allocator_traits@V?$allocator@H@std@@@std@@SAIABV?$allocator@H@2@@Z proc near
.text$mn:0000BA44                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<int>>::max_size(void)+Bp
.text$mn:0000BA44
.text$mn:0000BA44 arg_0           = dword ptr  8
.text$mn:0000BA44
.text$mn:0000BA44                 push    ebp
.text$mn:0000BA45                 mov     ebp, esp
.text$mn:0000BA47                 mov     ecx, [ebp+arg_0]
.text$mn:0000BA4A                 call    ?max_size@?$allocator@H@std@@QBEIXZ ; std::allocator<int>::max_size(void)
.text$mn:0000BA4F                 pop     ebp
.text$mn:0000BA50                 retn
.text$mn:0000BA50 ?max_size@?$allocator_traits@V?$allocator@H@std@@@std@@SAIABV?$allocator@H@2@@Z endp
.text$mn:0000BA50
.text$mn:0000BA50 ; ---------------------------------------------------------------------------
.text$mn:0000BA51                 align 4
.text$mn:0000BA51 _text$mn        ends
.text$mn:0000BA51
.text$mn:0000BA54 ; ===========================================================================
.text$mn:0000BA54
.text$mn:0000BA54 ; Segment type: Pure code
.text$mn:0000BA54 ; Segment permissions: Read/Execute
.text$mn:0000BA54 _text$mn        segment para public 'CODE' use32
.text$mn:0000BA54                 assume cs:_text$mn
.text$mn:0000BA54                 ;org 0BA54h
.text$mn:0000BA54 ; COMDAT (pick any)
.text$mn:0000BA54                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000BA54
.text$mn:0000BA54 ; =============== S U B R O U T I N E =======================================
.text$mn:0000BA54
.text$mn:0000BA54 ; Attributes: bp-based frame
.text$mn:0000BA54
.text$mn:0000BA54 ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<wchar_t>>::max_size(class std::allocator<wchar_t> const &)
.text$mn:0000BA54                 public ?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z
.text$mn:0000BA54 ?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z proc near
.text$mn:0000BA54                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::max_size(void)+Bp
.text$mn:0000BA54
.text$mn:0000BA54 arg_0           = dword ptr  8
.text$mn:0000BA54
.text$mn:0000BA54                 push    ebp
.text$mn:0000BA55                 mov     ebp, esp
.text$mn:0000BA57                 mov     ecx, [ebp+arg_0]
.text$mn:0000BA5A                 call    ?max_size@?$allocator@_W@std@@QBEIXZ ; std::allocator<wchar_t>::max_size(void)
.text$mn:0000BA5F                 pop     ebp
.text$mn:0000BA60                 retn
.text$mn:0000BA60 ?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z endp
.text$mn:0000BA60
.text$mn:0000BA60 ; ---------------------------------------------------------------------------
.text$mn:0000BA61                 align 4
.text$mn:0000BA61 _text$mn        ends
.text$mn:0000BA61
.text$mn:0000BA64 ; ===========================================================================
.text$mn:0000BA64
.text$mn:0000BA64 ; Segment type: Pure code
.text$mn:0000BA64 ; Segment permissions: Read/Execute
.text$mn:0000BA64 _text$mn        segment para public 'CODE' use32
.text$mn:0000BA64                 assume cs:_text$mn
.text$mn:0000BA64                 ;org 0BA64h
.text$mn:0000BA64 ; COMDAT (pick any)
.text$mn:0000BA64                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000BA64
.text$mn:0000BA64 ; =============== S U B R O U T I N E =======================================
.text$mn:0000BA64
.text$mn:0000BA64 ; Attributes: bp-based frame
.text$mn:0000BA64
.text$mn:0000BA64 ; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::max_size(void)const
.text$mn:0000BA64                 public ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
.text$mn:0000BA64 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
.text$mn:0000BA64                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+3Bp
.text$mn:0000BA64                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+6Ap ...
.text$mn:0000BA64
.text$mn:0000BA64 var_10          = dword ptr -10h
.text$mn:0000BA64 var_C           = dword ptr -0Ch
.text$mn:0000BA64 var_8           = dword ptr -8
.text$mn:0000BA64 var_1           = byte ptr -1
.text$mn:0000BA64
.text$mn:0000BA64                 push    ebp
.text$mn:0000BA65                 mov     ebp, esp
.text$mn:0000BA67                 sub     esp, 10h
.text$mn:0000BA6A                 mov     [ebp+var_10], ecx
.text$mn:0000BA6D                 lea     eax, [ebp+var_1]
.text$mn:0000BA70                 push    eax
.text$mn:0000BA71                 mov     ecx, [ebp+var_10]
.text$mn:0000BA74                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:0000BA79                 mov     ecx, eax
.text$mn:0000BA7B                 call    ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char>>::max_size(void)
.text$mn:0000BA80                 mov     [ebp+var_8], eax
.text$mn:0000BA83                 cmp     [ebp+var_8], 1
.text$mn:0000BA87                 ja      short loc_BA92
.text$mn:0000BA89                 mov     [ebp+var_C], 1
.text$mn:0000BA90                 jmp     short loc_BA9B
.text$mn:0000BA92 ; ---------------------------------------------------------------------------
.text$mn:0000BA92
.text$mn:0000BA92 loc_BA92:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+23j
.text$mn:0000BA92                 mov     ecx, [ebp+var_8]
.text$mn:0000BA95                 sub     ecx, 1
.text$mn:0000BA98                 mov     [ebp+var_C], ecx
.text$mn:0000BA9B
.text$mn:0000BA9B loc_BA9B:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+2Cj
.text$mn:0000BA9B                 mov     eax, [ebp+var_C]
.text$mn:0000BA9E                 mov     esp, ebp
.text$mn:0000BAA0                 pop     ebp
.text$mn:0000BAA1                 retn
.text$mn:0000BAA1 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp
.text$mn:0000BAA1
.text$mn:0000BAA1 ; ---------------------------------------------------------------------------
.text$mn:0000BAA2                 align 4
.text$mn:0000BAA2 _text$mn        ends
.text$mn:0000BAA2
.text$mn:0000BAA4 ; ===========================================================================
.text$mn:0000BAA4
.text$mn:0000BAA4 ; Segment type: Pure code
.text$mn:0000BAA4 ; Segment permissions: Read/Execute
.text$mn:0000BAA4 _text$mn        segment para public 'CODE' use32
.text$mn:0000BAA4                 assume cs:_text$mn
.text$mn:0000BAA4                 ;org 0BAA4h
.text$mn:0000BAA4 ; COMDAT (pick any)
.text$mn:0000BAA4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000BAA4
.text$mn:0000BAA4 ; =============== S U B R O U T I N E =======================================
.text$mn:0000BAA4
.text$mn:0000BAA4 ; Attributes: bp-based frame
.text$mn:0000BAA4
.text$mn:0000BAA4 ; public: unsigned int __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::max_size(void)const
.text$mn:0000BAA4                 public ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
.text$mn:0000BAA4 ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ proc near
.text$mn:0000BAA4                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+3Bp
.text$mn:0000BAA4                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+6Ap ...
.text$mn:0000BAA4
.text$mn:0000BAA4 var_10          = dword ptr -10h
.text$mn:0000BAA4 var_C           = dword ptr -0Ch
.text$mn:0000BAA4 var_8           = dword ptr -8
.text$mn:0000BAA4 var_1           = byte ptr -1
.text$mn:0000BAA4
.text$mn:0000BAA4                 push    ebp
.text$mn:0000BAA5                 mov     ebp, esp
.text$mn:0000BAA7                 sub     esp, 10h
.text$mn:0000BAAA                 mov     [ebp+var_10], ecx
.text$mn:0000BAAD                 lea     eax, [ebp+var_1]
.text$mn:0000BAB0                 push    eax
.text$mn:0000BAB1                 mov     ecx, [ebp+var_10]
.text$mn:0000BAB4                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:0000BAB9                 mov     ecx, eax
.text$mn:0000BABB                 call    ?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<wchar_t>>::max_size(void)
.text$mn:0000BAC0                 mov     [ebp+var_8], eax
.text$mn:0000BAC3                 cmp     [ebp+var_8], 1
.text$mn:0000BAC7                 ja      short loc_BAD2
.text$mn:0000BAC9                 mov     [ebp+var_C], 1
.text$mn:0000BAD0                 jmp     short loc_BADB
.text$mn:0000BAD2 ; ---------------------------------------------------------------------------
.text$mn:0000BAD2
.text$mn:0000BAD2 loc_BAD2:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)+23j
.text$mn:0000BAD2                 mov     ecx, [ebp+var_8]
.text$mn:0000BAD5                 sub     ecx, 1
.text$mn:0000BAD8                 mov     [ebp+var_C], ecx
.text$mn:0000BADB
.text$mn:0000BADB loc_BADB:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)+2Cj
.text$mn:0000BADB                 mov     eax, [ebp+var_C]
.text$mn:0000BADE                 mov     esp, ebp
.text$mn:0000BAE0                 pop     ebp
.text$mn:0000BAE1                 retn
.text$mn:0000BAE1 ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ endp
.text$mn:0000BAE1
.text$mn:0000BAE1 ; ---------------------------------------------------------------------------
.text$mn:0000BAE2                 align 4
.text$mn:0000BAE2 _text$mn        ends
.text$mn:0000BAE2
.text$mn:0000BAE4 ; ===========================================================================
.text$mn:0000BAE4
.text$mn:0000BAE4 ; Segment type: Pure code
.text$mn:0000BAE4 ; Segment permissions: Read/Execute
.text$mn:0000BAE4 _text$mn        segment para public 'CODE' use32
.text$mn:0000BAE4                 assume cs:_text$mn
.text$mn:0000BAE4                 ;org 0BAE4h
.text$mn:0000BAE4 ; COMDAT (pick any)
.text$mn:0000BAE4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000BAE4
.text$mn:0000BAE4 ; =============== S U B R O U T I N E =======================================
.text$mn:0000BAE4
.text$mn:0000BAE4 ; Attributes: bp-based frame
.text$mn:0000BAE4
.text$mn:0000BAE4 ; public: unsigned int __thiscall std::vector<int, class std::allocator<int>>::max_size(void)const
.text$mn:0000BAE4                 public ?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
.text$mn:0000BAE4 ?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ proc near
.text$mn:0000BAE4                                         ; CODE XREF: std::vector<int,std::allocator<int>>::_Grow_to(uint)+17p
.text$mn:0000BAE4                                         ; std::vector<int,std::allocator<int>>::_Reserve(uint)+18p
.text$mn:0000BAE4
.text$mn:0000BAE4 var_8           = dword ptr -8
.text$mn:0000BAE4 var_1           = byte ptr -1
.text$mn:0000BAE4
.text$mn:0000BAE4                 push    ebp
.text$mn:0000BAE5                 mov     ebp, esp
.text$mn:0000BAE7                 sub     esp, 8
.text$mn:0000BAEA                 mov     [ebp+var_8], ecx
.text$mn:0000BAED                 lea     eax, [ebp+var_1]
.text$mn:0000BAF0                 push    eax
.text$mn:0000BAF1                 mov     ecx, [ebp+var_8]
.text$mn:0000BAF4                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@H@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>::_Getal(void)
.text$mn:0000BAF9                 mov     ecx, eax
.text$mn:0000BAFB                 call    ?max_size@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<int>>::max_size(void)
.text$mn:0000BB00                 mov     esp, ebp
.text$mn:0000BB02                 pop     ebp
.text$mn:0000BB03                 retn
.text$mn:0000BB03 ?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ endp
.text$mn:0000BB03
.text$mn:0000BB03 _text$mn        ends
.text$mn:0000BB03
.text$mn:0000BB04 ; ===========================================================================
.text$mn:0000BB04
.text$mn:0000BB04 ; Segment type: Pure code
.text$mn:0000BB04 ; Segment permissions: Read/Execute
.text$mn:0000BB04 _text$mn        segment para public 'CODE' use32
.text$mn:0000BB04                 assume cs:_text$mn
.text$mn:0000BB04                 ;org 0BB04h
.text$mn:0000BB04 ; COMDAT (pick any)
.text$mn:0000BB04                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000BB04
.text$mn:0000BB04 ; =============== S U B R O U T I N E =======================================
.text$mn:0000BB04
.text$mn:0000BB04 ; Attributes: bp-based frame
.text$mn:0000BB04
.text$mn:0000BB04 ; public: unsigned int __thiscall std::vector<wchar_t, class std::allocator<wchar_t>>::max_size(void)const
.text$mn:0000BB04                 public ?max_size@?$vector@_WV?$allocator@_W@std@@@std@@QBEIXZ
.text$mn:0000BB04 ?max_size@?$vector@_WV?$allocator@_W@std@@@std@@QBEIXZ proc near
.text$mn:0000BB04                                         ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::_Buy(uint)+36p
.text$mn:0000BB04                                         ; std::vector<wchar_t,std::allocator<wchar_t>>::_Grow_to(uint)+17p ...
.text$mn:0000BB04
.text$mn:0000BB04 var_8           = dword ptr -8
.text$mn:0000BB04 var_1           = byte ptr -1
.text$mn:0000BB04
.text$mn:0000BB04                 push    ebp
.text$mn:0000BB05                 mov     ebp, esp
.text$mn:0000BB07                 sub     esp, 8
.text$mn:0000BB0A                 mov     [ebp+var_8], ecx
.text$mn:0000BB0D                 lea     eax, [ebp+var_1]
.text$mn:0000BB10                 push    eax
.text$mn:0000BB11                 mov     ecx, [ebp+var_8]
.text$mn:0000BB14                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:0000BB19                 mov     ecx, eax
.text$mn:0000BB1B                 call    ?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<wchar_t>>::max_size(void)
.text$mn:0000BB20                 mov     esp, ebp
.text$mn:0000BB22                 pop     ebp
.text$mn:0000BB23                 retn
.text$mn:0000BB23 ?max_size@?$vector@_WV?$allocator@_W@std@@@std@@QBEIXZ endp
.text$mn:0000BB23
.text$mn:0000BB23 _text$mn        ends
.text$mn:0000BB23
.text$mn:0000BB24 ; ===========================================================================
.text$mn:0000BB24
.text$mn:0000BB24 ; Segment type: Pure code
.text$mn:0000BB24 ; Segment permissions: Read/Execute
.text$mn:0000BB24 _text$mn        segment para public 'CODE' use32
.text$mn:0000BB24                 assume cs:_text$mn
.text$mn:0000BB24                 ;org 0BB24h
.text$mn:0000BB24 ; COMDAT (pick any)
.text$mn:0000BB24                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000BB24
.text$mn:0000BB24 ; =============== S U B R O U T I N E =======================================
.text$mn:0000BB24
.text$mn:0000BB24 ; Attributes: bp-based frame
.text$mn:0000BB24
.text$mn:0000BB24 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Generic_error_category::message(int)const
.text$mn:0000BB24                 public ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:0000BB24 ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:0000BB24                                         ; CODE XREF: std::_Iostream_error_category::message(int)+64p
.text$mn:0000BB24                                         ; DATA XREF: .rdata:0000DE68o
.text$mn:0000BB24
.text$mn:0000BB24 var_1C          = dword ptr -1Ch
.text$mn:0000BB24 var_18          = dword ptr -18h
.text$mn:0000BB24 Str             = dword ptr -14h
.text$mn:0000BB24 var_10          = dword ptr -10h
.text$mn:0000BB24 var_C           = dword ptr -0Ch
.text$mn:0000BB24 var_4           = dword ptr -4
.text$mn:0000BB24 arg_0           = dword ptr  8
.text$mn:0000BB24 arg_4           = dword ptr  0Ch
.text$mn:0000BB24
.text$mn:0000BB24                 push    ebp
.text$mn:0000BB25                 mov     ebp, esp
.text$mn:0000BB27                 push    0FFFFFFFFh
.text$mn:0000BB29                 push    offset __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:0000BB2E                 mov     eax, large fs:0
.text$mn:0000BB34                 push    eax
.text$mn:0000BB35                 sub     esp, 10h
.text$mn:0000BB38                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000BB3D                 xor     eax, ebp
.text$mn:0000BB3F                 push    eax
.text$mn:0000BB40                 lea     eax, [ebp+var_C]
.text$mn:0000BB43                 mov     large fs:0, eax
.text$mn:0000BB49                 mov     [ebp+var_1C], ecx
.text$mn:0000BB4C                 mov     [ebp+var_18], 0
.text$mn:0000BB53                 mov     eax, [ebp+arg_4]
.text$mn:0000BB56                 push    eax             ; int
.text$mn:0000BB57                 call    ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map(int)
.text$mn:0000BB5C                 add     esp, 4
.text$mn:0000BB5F                 mov     [ebp+var_10], eax
.text$mn:0000BB62                 cmp     [ebp+var_10], 0
.text$mn:0000BB66                 jz      short loc_BB70
.text$mn:0000BB68                 mov     ecx, [ebp+var_10]
.text$mn:0000BB6B                 mov     [ebp+Str], ecx
.text$mn:0000BB6E                 jmp     short loc_BB77
.text$mn:0000BB70 ; ---------------------------------------------------------------------------
.text$mn:0000BB70
.text$mn:0000BB70 loc_BB70:                               ; CODE XREF: std::_Generic_error_category::message(int)+42j
.text$mn:0000BB70                 mov     [ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ ; "unknown error"
.text$mn:0000BB77
.text$mn:0000BB77 loc_BB77:                               ; CODE XREF: std::_Generic_error_category::message(int)+4Aj
.text$mn:0000BB77                 mov     edx, [ebp+Str]
.text$mn:0000BB7A                 push    edx             ; Str
.text$mn:0000BB7B                 mov     ecx, [ebp+arg_0]
.text$mn:0000BB7E                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:0000BB83                 mov     [ebp+var_4], 0
.text$mn:0000BB8A                 mov     eax, [ebp+var_18]
.text$mn:0000BB8D                 or      eax, 1
.text$mn:0000BB90                 mov     [ebp+var_18], eax
.text$mn:0000BB93                 mov     eax, [ebp+arg_0]
.text$mn:0000BB96                 mov     ecx, [ebp+var_C]
.text$mn:0000BB99                 mov     large fs:0, ecx
.text$mn:0000BBA0                 pop     ecx
.text$mn:0000BBA1                 mov     esp, ebp
.text$mn:0000BBA3                 pop     ebp
.text$mn:0000BBA4                 retn    8
.text$mn:0000BBA4 ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:0000BBA4
.text$mn:0000BBA4 ; ---------------------------------------------------------------------------
.text$mn:0000BBA7                 align 4
.text$mn:0000BBA7 _text$mn        ends
.text$mn:0000BBA7
.text$x:0000BBA8 ; ===========================================================================
.text$x:0000BBA8
.text$x:0000BBA8 ; Segment type: Pure code
.text$x:0000BBA8 ; Segment permissions: Read/Execute
.text$x:0000BBA8 _text$x         segment para public 'CODE' use32
.text$x:0000BBA8                 assume cs:_text$x
.text$x:0000BBA8                 ;org 0BBA8h
.text$x:0000BBA8 ; COMDAT (pick associative to section at BB24)
.text$x:0000BBA8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000BBA8
.text$x:0000BBA8 ; =============== S U B R O U T I N E =======================================
.text$x:0000BBA8
.text$x:0000BBA8
.text$x:0000BBA8 __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:0000BBA8                                         ; DATA XREF: .xdata$x:0000C810o
.text$x:0000BBA8                 mov     eax, [ebp-18h]
.text$x:0000BBAB                 and     eax, 1
.text$x:0000BBAE                 jz      $LN6
.text$x:0000BBB4                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:0000BBB8                 mov     ecx, [ebp+8]
.text$x:0000BBBB                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:0000BBC0 ; ---------------------------------------------------------------------------
.text$x:0000BBC0
.text$x:0000BBC0 $LN6:                                   ; CODE XREF: __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:0000BBC0                 retn
.text$x:0000BBC0 __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:0000BBC0
.text$x:0000BBC1
.text$x:0000BBC1 ; =============== S U B R O U T I N E =======================================
.text$x:0000BBC1
.text$x:0000BBC1
.text$x:0000BBC1 __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:0000BBC1                                         ; DATA XREF: std::_Generic_error_category::message(int)+5o
.text$x:0000BBC1
.text$x:0000BBC1 arg_4           = dword ptr  8
.text$x:0000BBC1
.text$x:0000BBC1                 mov     edx, [esp+arg_4]
.text$x:0000BBC5                 lea     eax, [edx+0Ch]
.text$x:0000BBC8                 mov     ecx, [edx-14h]
.text$x:0000BBCB                 xor     ecx, eax
.text$x:0000BBCD                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000BBD2                 mov     eax, offset __ehfuncinfo$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:0000BBD7                 jmp     ___CxxFrameHandler3
.text$x:0000BBD7 __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:0000BBD7
.text$x:0000BBD7 _text$x         ends
.text$x:0000BBD7
.text$mn:0000BBDC ; ===========================================================================
.text$mn:0000BBDC
.text$mn:0000BBDC ; Segment type: Pure code
.text$mn:0000BBDC ; Segment permissions: Read/Execute
.text$mn:0000BBDC _text$mn        segment para public 'CODE' use32
.text$mn:0000BBDC                 assume cs:_text$mn
.text$mn:0000BBDC                 ;org 0BBDCh
.text$mn:0000BBDC ; COMDAT (pick any)
.text$mn:0000BBDC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000BBDC
.text$mn:0000BBDC ; =============== S U B R O U T I N E =======================================
.text$mn:0000BBDC
.text$mn:0000BBDC ; Attributes: bp-based frame
.text$mn:0000BBDC
.text$mn:0000BBDC ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Iostream_error_category::message(int)const
.text$mn:0000BBDC                 public ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:0000BBDC ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:0000BBDC                                         ; DATA XREF: .rdata:0000DE9Co
.text$mn:0000BBDC
.text$mn:0000BBDC var_14          = dword ptr -14h
.text$mn:0000BBDC var_10          = dword ptr -10h
.text$mn:0000BBDC var_C           = dword ptr -0Ch
.text$mn:0000BBDC var_4           = dword ptr -4
.text$mn:0000BBDC arg_0           = dword ptr  8
.text$mn:0000BBDC arg_4           = dword ptr  0Ch
.text$mn:0000BBDC
.text$mn:0000BBDC                 push    ebp
.text$mn:0000BBDD                 mov     ebp, esp
.text$mn:0000BBDF                 push    0FFFFFFFFh
.text$mn:0000BBE1                 push    offset __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:0000BBE6                 mov     eax, large fs:0
.text$mn:0000BBEC                 push    eax
.text$mn:0000BBED                 sub     esp, 8
.text$mn:0000BBF0                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000BBF5                 xor     eax, ebp
.text$mn:0000BBF7                 push    eax
.text$mn:0000BBF8                 lea     eax, [ebp+var_C]
.text$mn:0000BBFB                 mov     large fs:0, eax
.text$mn:0000BC01                 mov     [ebp+var_14], ecx
.text$mn:0000BC04                 mov     [ebp+var_10], 0
.text$mn:0000BC0B                 cmp     [ebp+arg_4], 1
.text$mn:0000BC0F                 jnz     short loc_BC35
.text$mn:0000BC11                 push    offset ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ ; "iostream stream error"
.text$mn:0000BC16                 mov     ecx, [ebp+arg_0]
.text$mn:0000BC19                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:0000BC1E                 mov     [ebp+var_4], 0
.text$mn:0000BC25                 mov     eax, [ebp+var_10]
.text$mn:0000BC28                 or      eax, 1
.text$mn:0000BC2B                 mov     [ebp+var_10], eax
.text$mn:0000BC2E                 mov     eax, [ebp+arg_0]
.text$mn:0000BC31                 jmp     short loc_BC58
.text$mn:0000BC33 ; ---------------------------------------------------------------------------
.text$mn:0000BC33                 jmp     short loc_BC58
.text$mn:0000BC35 ; ---------------------------------------------------------------------------
.text$mn:0000BC35
.text$mn:0000BC35 loc_BC35:                               ; CODE XREF: std::_Iostream_error_category::message(int)+33j
.text$mn:0000BC35                 mov     ecx, [ebp+arg_4]
.text$mn:0000BC38                 push    ecx
.text$mn:0000BC39                 mov     edx, [ebp+arg_0]
.text$mn:0000BC3C                 push    edx
.text$mn:0000BC3D                 mov     ecx, [ebp+var_14]
.text$mn:0000BC40                 call    ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
.text$mn:0000BC45                 mov     [ebp+var_4], 0
.text$mn:0000BC4C                 mov     eax, [ebp+var_10]
.text$mn:0000BC4F                 or      eax, 1
.text$mn:0000BC52                 mov     [ebp+var_10], eax
.text$mn:0000BC55                 mov     eax, [ebp+arg_0]
.text$mn:0000BC58
.text$mn:0000BC58 loc_BC58:                               ; CODE XREF: std::_Iostream_error_category::message(int)+55j
.text$mn:0000BC58                                         ; std::_Iostream_error_category::message(int)+57j
.text$mn:0000BC58                 mov     ecx, [ebp+var_C]
.text$mn:0000BC5B                 mov     large fs:0, ecx
.text$mn:0000BC62                 pop     ecx
.text$mn:0000BC63                 mov     esp, ebp
.text$mn:0000BC65                 pop     ebp
.text$mn:0000BC66                 retn    8
.text$mn:0000BC66 ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:0000BC66
.text$mn:0000BC66 ; ---------------------------------------------------------------------------
.text$mn:0000BC69                 align 4
.text$mn:0000BC69 _text$mn        ends
.text$mn:0000BC69
.text$x:0000BC6C ; ===========================================================================
.text$x:0000BC6C
.text$x:0000BC6C ; Segment type: Pure code
.text$x:0000BC6C ; Segment permissions: Read/Execute
.text$x:0000BC6C _text$x         segment para public 'CODE' use32
.text$x:0000BC6C                 assume cs:_text$x
.text$x:0000BC6C                 ;org 0BC6Ch
.text$x:0000BC6C ; COMDAT (pick associative to section at BBDC)
.text$x:0000BC6C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000BC6C
.text$x:0000BC6C ; =============== S U B R O U T I N E =======================================
.text$x:0000BC6C
.text$x:0000BC6C
.text$x:0000BC6C __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:0000BC6C                                         ; DATA XREF: .xdata$x:0000C894o
.text$x:0000BC6C                 mov     eax, [ebp-10h]
.text$x:0000BC6F                 and     eax, 1
.text$x:0000BC72                 jz      $LN6_0
.text$x:0000BC78                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:0000BC7C                 mov     ecx, [ebp+8]
.text$x:0000BC7F                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:0000BC84 ; ---------------------------------------------------------------------------
.text$x:0000BC84
.text$x:0000BC84 $LN6_0:                                 ; CODE XREF: __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:0000BC84                 retn
.text$x:0000BC84 __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:0000BC84
.text$x:0000BC85
.text$x:0000BC85 ; =============== S U B R O U T I N E =======================================
.text$x:0000BC85
.text$x:0000BC85
.text$x:0000BC85 __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:0000BC85                                         ; DATA XREF: std::_Iostream_error_category::message(int)+5o
.text$x:0000BC85
.text$x:0000BC85 arg_4           = dword ptr  8
.text$x:0000BC85
.text$x:0000BC85                 mov     edx, [esp+arg_4]
.text$x:0000BC89                 lea     eax, [edx+0Ch]
.text$x:0000BC8C                 mov     ecx, [edx-0Ch]
.text$x:0000BC8F                 xor     ecx, eax
.text$x:0000BC91                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000BC96                 mov     eax, offset __ehfuncinfo$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:0000BC9B                 jmp     ___CxxFrameHandler3
.text$x:0000BC9B __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:0000BC9B
.text$x:0000BC9B _text$x         ends
.text$x:0000BC9B
.text$mn:0000BCA0 ; ===========================================================================
.text$mn:0000BCA0
.text$mn:0000BCA0 ; Segment type: Pure code
.text$mn:0000BCA0 ; Segment permissions: Read/Execute
.text$mn:0000BCA0 _text$mn        segment para public 'CODE' use32
.text$mn:0000BCA0                 assume cs:_text$mn
.text$mn:0000BCA0                 ;org 0BCA0h
.text$mn:0000BCA0 ; COMDAT (pick any)
.text$mn:0000BCA0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000BCA0
.text$mn:0000BCA0 ; =============== S U B R O U T I N E =======================================
.text$mn:0000BCA0
.text$mn:0000BCA0 ; Attributes: bp-based frame
.text$mn:0000BCA0
.text$mn:0000BCA0 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_System_error_category::message(int)const
.text$mn:0000BCA0                 public ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:0000BCA0 ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:0000BCA0                                         ; DATA XREF: .rdata:0000DEDCo
.text$mn:0000BCA0
.text$mn:0000BCA0 var_1C          = dword ptr -1Ch
.text$mn:0000BCA0 var_18          = dword ptr -18h
.text$mn:0000BCA0 Str             = dword ptr -14h
.text$mn:0000BCA0 var_10          = dword ptr -10h
.text$mn:0000BCA0 var_C           = dword ptr -0Ch
.text$mn:0000BCA0 var_4           = dword ptr -4
.text$mn:0000BCA0 arg_0           = dword ptr  8
.text$mn:0000BCA0 arg_4           = dword ptr  0Ch
.text$mn:0000BCA0
.text$mn:0000BCA0                 push    ebp
.text$mn:0000BCA1                 mov     ebp, esp
.text$mn:0000BCA3                 push    0FFFFFFFFh
.text$mn:0000BCA5                 push    offset __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:0000BCAA                 mov     eax, large fs:0
.text$mn:0000BCB0                 push    eax
.text$mn:0000BCB1                 sub     esp, 10h
.text$mn:0000BCB4                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000BCB9                 xor     eax, ebp
.text$mn:0000BCBB                 push    eax
.text$mn:0000BCBC                 lea     eax, [ebp+var_C]
.text$mn:0000BCBF                 mov     large fs:0, eax
.text$mn:0000BCC5                 mov     [ebp+var_1C], ecx
.text$mn:0000BCC8                 mov     [ebp+var_18], 0
.text$mn:0000BCCF                 mov     eax, [ebp+arg_4]
.text$mn:0000BCD2                 push    eax             ; int
.text$mn:0000BCD3                 call    ?_Winerror_map@std@@YAPBDH@Z ; std::_Winerror_map(int)
.text$mn:0000BCD8                 add     esp, 4
.text$mn:0000BCDB                 mov     [ebp+var_10], eax
.text$mn:0000BCDE                 cmp     [ebp+var_10], 0
.text$mn:0000BCE2                 jz      short loc_BCEC
.text$mn:0000BCE4                 mov     ecx, [ebp+var_10]
.text$mn:0000BCE7                 mov     [ebp+Str], ecx
.text$mn:0000BCEA                 jmp     short loc_BCF3
.text$mn:0000BCEC ; ---------------------------------------------------------------------------
.text$mn:0000BCEC
.text$mn:0000BCEC loc_BCEC:                               ; CODE XREF: std::_System_error_category::message(int)+42j
.text$mn:0000BCEC                 mov     [ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ ; "unknown error"
.text$mn:0000BCF3
.text$mn:0000BCF3 loc_BCF3:                               ; CODE XREF: std::_System_error_category::message(int)+4Aj
.text$mn:0000BCF3                 mov     edx, [ebp+Str]
.text$mn:0000BCF6                 push    edx             ; Str
.text$mn:0000BCF7                 mov     ecx, [ebp+arg_0]
.text$mn:0000BCFA                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:0000BCFF                 mov     [ebp+var_4], 0
.text$mn:0000BD06                 mov     eax, [ebp+var_18]
.text$mn:0000BD09                 or      eax, 1
.text$mn:0000BD0C                 mov     [ebp+var_18], eax
.text$mn:0000BD0F                 mov     eax, [ebp+arg_0]
.text$mn:0000BD12                 mov     ecx, [ebp+var_C]
.text$mn:0000BD15                 mov     large fs:0, ecx
.text$mn:0000BD1C                 pop     ecx
.text$mn:0000BD1D                 mov     esp, ebp
.text$mn:0000BD1F                 pop     ebp
.text$mn:0000BD20                 retn    8
.text$mn:0000BD20 ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:0000BD20
.text$mn:0000BD20 ; ---------------------------------------------------------------------------
.text$mn:0000BD23                 align 4
.text$mn:0000BD23 _text$mn        ends
.text$mn:0000BD23
.text$x:0000BD24 ; ===========================================================================
.text$x:0000BD24
.text$x:0000BD24 ; Segment type: Pure code
.text$x:0000BD24 ; Segment permissions: Read/Execute
.text$x:0000BD24 _text$x         segment para public 'CODE' use32
.text$x:0000BD24                 assume cs:_text$x
.text$x:0000BD24                 ;org 0BD24h
.text$x:0000BD24 ; COMDAT (pick associative to section at BCA0)
.text$x:0000BD24                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000BD24
.text$x:0000BD24 ; =============== S U B R O U T I N E =======================================
.text$x:0000BD24
.text$x:0000BD24
.text$x:0000BD24 __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:0000BD24                                         ; DATA XREF: .xdata$x:0000C918o
.text$x:0000BD24                 mov     eax, [ebp-18h]
.text$x:0000BD27                 and     eax, 1
.text$x:0000BD2A                 jz      $LN6_1
.text$x:0000BD30                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:0000BD34                 mov     ecx, [ebp+8]
.text$x:0000BD37                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:0000BD3C ; ---------------------------------------------------------------------------
.text$x:0000BD3C
.text$x:0000BD3C $LN6_1:                                 ; CODE XREF: __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:0000BD3C                 retn
.text$x:0000BD3C __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:0000BD3C
.text$x:0000BD3D
.text$x:0000BD3D ; =============== S U B R O U T I N E =======================================
.text$x:0000BD3D
.text$x:0000BD3D
.text$x:0000BD3D __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:0000BD3D                                         ; DATA XREF: std::_System_error_category::message(int)+5o
.text$x:0000BD3D
.text$x:0000BD3D arg_4           = dword ptr  8
.text$x:0000BD3D
.text$x:0000BD3D                 mov     edx, [esp+arg_4]
.text$x:0000BD41                 lea     eax, [edx+0Ch]
.text$x:0000BD44                 mov     ecx, [edx-14h]
.text$x:0000BD47                 xor     ecx, eax
.text$x:0000BD49                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000BD4E                 mov     eax, offset __ehfuncinfo$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:0000BD53                 jmp     ___CxxFrameHandler3
.text$x:0000BD53 __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:0000BD53
.text$x:0000BD53 _text$x         ends
.text$x:0000BD53
.text$mn:0000BD58 ; ===========================================================================
.text$mn:0000BD58
.text$mn:0000BD58 ; Segment type: Pure code
.text$mn:0000BD58 ; Segment permissions: Read/Execute
.text$mn:0000BD58 _text$mn        segment para public 'CODE' use32
.text$mn:0000BD58                 assume cs:_text$mn
.text$mn:0000BD58                 ;org 0BD58h
.text$mn:0000BD58 ; COMDAT (pick any)
.text$mn:0000BD58                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000BD58
.text$mn:0000BD58 ; =============== S U B R O U T I N E =======================================
.text$mn:0000BD58
.text$mn:0000BD58 ; Attributes: bp-based frame
.text$mn:0000BD58
.text$mn:0000BD58 ; int __cdecl std::char_traits<char>::move(void *Dst, void *Src, size_t Size)
.text$mn:0000BD58                 public ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
.text$mn:0000BD58 ?move@?$char_traits@D@std@@SAPADPADPBDI@Z proc near
.text$mn:0000BD58                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+6Ap
.text$mn:0000BD58
.text$mn:0000BD58 var_4           = dword ptr -4
.text$mn:0000BD58 Dst             = dword ptr  8
.text$mn:0000BD58 Src             = dword ptr  0Ch
.text$mn:0000BD58 Size            = dword ptr  10h
.text$mn:0000BD58
.text$mn:0000BD58                 push    ebp
.text$mn:0000BD59                 mov     ebp, esp
.text$mn:0000BD5B                 push    ecx
.text$mn:0000BD5C                 cmp     [ebp+Size], 0
.text$mn:0000BD60                 jnz     short loc_BD6A
.text$mn:0000BD62                 mov     eax, [ebp+Dst]
.text$mn:0000BD65                 mov     [ebp+var_4], eax
.text$mn:0000BD68                 jmp     short loc_BD81
.text$mn:0000BD6A ; ---------------------------------------------------------------------------
.text$mn:0000BD6A
.text$mn:0000BD6A loc_BD6A:                               ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+8j
.text$mn:0000BD6A                 mov     ecx, [ebp+Size]
.text$mn:0000BD6D                 push    ecx             ; Size
.text$mn:0000BD6E                 mov     edx, [ebp+Src]
.text$mn:0000BD71                 push    edx             ; Src
.text$mn:0000BD72                 mov     eax, [ebp+Dst]
.text$mn:0000BD75                 push    eax             ; Dst
.text$mn:0000BD76                 call    _memmove
.text$mn:0000BD7B                 add     esp, 0Ch
.text$mn:0000BD7E                 mov     [ebp+var_4], eax
.text$mn:0000BD81
.text$mn:0000BD81 loc_BD81:                               ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+10j
.text$mn:0000BD81                 mov     eax, [ebp+var_4]
.text$mn:0000BD84                 mov     esp, ebp
.text$mn:0000BD86                 pop     ebp
.text$mn:0000BD87                 retn
.text$mn:0000BD87 ?move@?$char_traits@D@std@@SAPADPADPBDI@Z endp
.text$mn:0000BD87
.text$mn:0000BD87 _text$mn        ends
.text$mn:0000BD87
.text$mn:0000BD88 ; ===========================================================================
.text$mn:0000BD88
.text$mn:0000BD88 ; Segment type: Pure code
.text$mn:0000BD88 ; Segment permissions: Read/Execute
.text$mn:0000BD88 _text$mn        segment para public 'CODE' use32
.text$mn:0000BD88                 assume cs:_text$mn
.text$mn:0000BD88                 ;org 0BD88h
.text$mn:0000BD88 ; COMDAT (pick any)
.text$mn:0000BD88                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000BD88
.text$mn:0000BD88 ; =============== S U B R O U T I N E =======================================
.text$mn:0000BD88
.text$mn:0000BD88 ; Attributes: bp-based frame
.text$mn:0000BD88
.text$mn:0000BD88 ; int __cdecl std::char_traits<wchar_t>::move(void *Dst, void *Src, int)
.text$mn:0000BD88                 public ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z
.text$mn:0000BD88 ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z proc near
.text$mn:0000BD88                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)+70p
.text$mn:0000BD88
.text$mn:0000BD88 var_4           = dword ptr -4
.text$mn:0000BD88 Dst             = dword ptr  8
.text$mn:0000BD88 Src             = dword ptr  0Ch
.text$mn:0000BD88 arg_8           = dword ptr  10h
.text$mn:0000BD88
.text$mn:0000BD88                 push    ebp
.text$mn:0000BD89                 mov     ebp, esp
.text$mn:0000BD8B                 push    ecx
.text$mn:0000BD8C                 cmp     [ebp+arg_8], 0
.text$mn:0000BD90                 jnz     short loc_BD9A
.text$mn:0000BD92                 mov     eax, [ebp+Dst]
.text$mn:0000BD95                 mov     [ebp+var_4], eax
.text$mn:0000BD98                 jmp     short loc_BDB1
.text$mn:0000BD9A ; ---------------------------------------------------------------------------
.text$mn:0000BD9A
.text$mn:0000BD9A loc_BD9A:                               ; CODE XREF: std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)+8j
.text$mn:0000BD9A                 mov     ecx, [ebp+arg_8]
.text$mn:0000BD9D                 push    ecx             ; int
.text$mn:0000BD9E                 mov     edx, [ebp+Src]
.text$mn:0000BDA1                 push    edx             ; Src
.text$mn:0000BDA2                 mov     eax, [ebp+Dst]
.text$mn:0000BDA5                 push    eax             ; Dst
.text$mn:0000BDA6                 call    _wmemmove
.text$mn:0000BDAB                 add     esp, 0Ch
.text$mn:0000BDAE                 mov     [ebp+var_4], eax
.text$mn:0000BDB1
.text$mn:0000BDB1 loc_BDB1:                               ; CODE XREF: std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)+10j
.text$mn:0000BDB1                 mov     eax, [ebp+var_4]
.text$mn:0000BDB4                 mov     esp, ebp
.text$mn:0000BDB6                 pop     ebp
.text$mn:0000BDB7                 retn
.text$mn:0000BDB7 ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z endp
.text$mn:0000BDB7
.text$mn:0000BDB7 _text$mn        ends
.text$mn:0000BDB7
.text$mn:0000BDB8 ; ===========================================================================
.text$mn:0000BDB8
.text$mn:0000BDB8 ; Segment type: Pure code
.text$mn:0000BDB8 ; Segment permissions: Read/Execute
.text$mn:0000BDB8 _text$mn        segment para public 'CODE' use32
.text$mn:0000BDB8                 assume cs:_text$mn
.text$mn:0000BDB8                 ;org 0BDB8h
.text$mn:0000BDB8 ; COMDAT (pick any)
.text$mn:0000BDB8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000BDB8
.text$mn:0000BDB8 ; =============== S U B R O U T I N E =======================================
.text$mn:0000BDB8
.text$mn:0000BDB8 ; Attributes: bp-based frame
.text$mn:0000BDB8
.text$mn:0000BDB8 ; const char *__thiscall std::_Generic_error_category::name(std::_Generic_error_category *__hidden this)
.text$mn:0000BDB8                 public ?name@_Generic_error_category@std@@UBEPBDXZ
.text$mn:0000BDB8 ?name@_Generic_error_category@std@@UBEPBDXZ proc near
.text$mn:0000BDB8                                         ; DATA XREF: .rdata:0000DE64o
.text$mn:0000BDB8
.text$mn:0000BDB8 var_4           = dword ptr -4
.text$mn:0000BDB8
.text$mn:0000BDB8                 push    ebp
.text$mn:0000BDB9                 mov     ebp, esp
.text$mn:0000BDBB                 push    ecx
.text$mn:0000BDBC                 mov     [ebp+var_4], ecx
.text$mn:0000BDBF                 mov     eax, offset ??_C@_07DCLBNMLN@generic?$AA@ ; "generic"
.text$mn:0000BDC4                 mov     esp, ebp
.text$mn:0000BDC6                 pop     ebp
.text$mn:0000BDC7                 retn
.text$mn:0000BDC7 ?name@_Generic_error_category@std@@UBEPBDXZ endp
.text$mn:0000BDC7
.text$mn:0000BDC7 _text$mn        ends
.text$mn:0000BDC7
.text$mn:0000BDC8 ; ===========================================================================
.text$mn:0000BDC8
.text$mn:0000BDC8 ; Segment type: Pure code
.text$mn:0000BDC8 ; Segment permissions: Read/Execute
.text$mn:0000BDC8 _text$mn        segment para public 'CODE' use32
.text$mn:0000BDC8                 assume cs:_text$mn
.text$mn:0000BDC8                 ;org 0BDC8h
.text$mn:0000BDC8 ; COMDAT (pick any)
.text$mn:0000BDC8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000BDC8
.text$mn:0000BDC8 ; =============== S U B R O U T I N E =======================================
.text$mn:0000BDC8
.text$mn:0000BDC8 ; Attributes: bp-based frame
.text$mn:0000BDC8
.text$mn:0000BDC8 ; const char *__thiscall std::_Iostream_error_category::name(std::_Iostream_error_category *__hidden this)
.text$mn:0000BDC8                 public ?name@_Iostream_error_category@std@@UBEPBDXZ
.text$mn:0000BDC8 ?name@_Iostream_error_category@std@@UBEPBDXZ proc near
.text$mn:0000BDC8                                         ; DATA XREF: .rdata:0000DE98o
.text$mn:0000BDC8
.text$mn:0000BDC8 var_4           = dword ptr -4
.text$mn:0000BDC8
.text$mn:0000BDC8                 push    ebp
.text$mn:0000BDC9                 mov     ebp, esp
.text$mn:0000BDCB                 push    ecx
.text$mn:0000BDCC                 mov     [ebp+var_4], ecx
.text$mn:0000BDCF                 mov     eax, offset ??_C@_08LLGCOLLL@iostream?$AA@ ; "iostream"
.text$mn:0000BDD4                 mov     esp, ebp
.text$mn:0000BDD6                 pop     ebp
.text$mn:0000BDD7                 retn
.text$mn:0000BDD7 ?name@_Iostream_error_category@std@@UBEPBDXZ endp
.text$mn:0000BDD7
.text$mn:0000BDD7 _text$mn        ends
.text$mn:0000BDD7
.text$mn:0000BDD8 ; ===========================================================================
.text$mn:0000BDD8
.text$mn:0000BDD8 ; Segment type: Pure code
.text$mn:0000BDD8 ; Segment permissions: Read/Execute
.text$mn:0000BDD8 _text$mn        segment para public 'CODE' use32
.text$mn:0000BDD8                 assume cs:_text$mn
.text$mn:0000BDD8                 ;org 0BDD8h
.text$mn:0000BDD8 ; COMDAT (pick any)
.text$mn:0000BDD8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000BDD8
.text$mn:0000BDD8 ; =============== S U B R O U T I N E =======================================
.text$mn:0000BDD8
.text$mn:0000BDD8 ; Attributes: bp-based frame
.text$mn:0000BDD8
.text$mn:0000BDD8 ; const char *__thiscall std::_System_error_category::name(std::_System_error_category *__hidden this)
.text$mn:0000BDD8                 public ?name@_System_error_category@std@@UBEPBDXZ
.text$mn:0000BDD8 ?name@_System_error_category@std@@UBEPBDXZ proc near
.text$mn:0000BDD8                                         ; DATA XREF: .rdata:0000DED8o
.text$mn:0000BDD8
.text$mn:0000BDD8 var_4           = dword ptr -4
.text$mn:0000BDD8
.text$mn:0000BDD8                 push    ebp
.text$mn:0000BDD9                 mov     ebp, esp
.text$mn:0000BDDB                 push    ecx
.text$mn:0000BDDC                 mov     [ebp+var_4], ecx
.text$mn:0000BDDF                 mov     eax, offset ??_C@_06FHFOAHML@system?$AA@ ; "system"
.text$mn:0000BDE4                 mov     esp, ebp
.text$mn:0000BDE6                 pop     ebp
.text$mn:0000BDE7                 retn
.text$mn:0000BDE7 ?name@_System_error_category@std@@UBEPBDXZ endp
.text$mn:0000BDE7
.text$mn:0000BDE7 _text$mn        ends
.text$mn:0000BDE7
.text$mn:0000BDE8 ; ===========================================================================
.text$mn:0000BDE8
.text$mn:0000BDE8 ; Segment type: Pure code
.text$mn:0000BDE8 ; Segment permissions: Read/Execute
.text$mn:0000BDE8 _text$mn        segment para public 'CODE' use32
.text$mn:0000BDE8                 assume cs:_text$mn
.text$mn:0000BDE8                 ;org 0BDE8h
.text$mn:0000BDE8 ; COMDAT (pick any)
.text$mn:0000BDE8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000BDE8
.text$mn:0000BDE8 ; =============== S U B R O U T I N E =======================================
.text$mn:0000BDE8
.text$mn:0000BDE8 ; Attributes: bp-based frame
.text$mn:0000BDE8
.text$mn:0000BDE8 ; int __thiscall TabBar::nbItem(TabBar *__hidden this)
.text$mn:0000BDE8                 public ?nbItem@TabBar@@QBEHXZ
.text$mn:0000BDE8 ?nbItem@TabBar@@QBEHXZ proc near        ; CODE XREF: WindowsDlg::doRefresh(bool)+4Ap
.text$mn:0000BDE8                                         ; WindowsDlg::run_dlgProc(uint,uint,long)+1A4p ...
.text$mn:0000BDE8
.text$mn:0000BDE8 var_4           = dword ptr -4
.text$mn:0000BDE8
.text$mn:0000BDE8                 push    ebp
.text$mn:0000BDE9                 mov     ebp, esp
.text$mn:0000BDEB                 push    ecx
.text$mn:0000BDEC                 mov     [ebp+var_4], ecx
.text$mn:0000BDEF                 mov     eax, [ebp+var_4]
.text$mn:0000BDF2                 mov     eax, [eax+10h]
.text$mn:0000BDF5                 mov     esp, ebp
.text$mn:0000BDF7                 pop     ebp
.text$mn:0000BDF8                 retn
.text$mn:0000BDF8 ?nbItem@TabBar@@QBEHXZ endp
.text$mn:0000BDF8
.text$mn:0000BDF8 ; ---------------------------------------------------------------------------
.text$mn:0000BDF9                 align 4
.text$mn:0000BDF9 _text$mn        ends
.text$mn:0000BDF9
.text$mn:0000BDFC ; ===========================================================================
.text$mn:0000BDFC
.text$mn:0000BDFC ; Segment type: Pure code
.text$mn:0000BDFC ; Segment permissions: Read/Execute
.text$mn:0000BDFC _text$mn        segment para public 'CODE' use32
.text$mn:0000BDFC                 assume cs:_text$mn
.text$mn:0000BDFC                 ;org 0BDFCh
.text$mn:0000BDFC ; COMDAT (pick any)
.text$mn:0000BDFC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000BDFC
.text$mn:0000BDFC ; =============== S U B R O U T I N E =======================================
.text$mn:0000BDFC
.text$mn:0000BDFC ; Attributes: bp-based frame
.text$mn:0000BDFC
.text$mn:0000BDFC ; int __cdecl NumericStringEquivalence::numstrcmp(const wchar_t *Str, const wchar_t *)
.text$mn:0000BDFC                 public ?numstrcmp@NumericStringEquivalence@@SAHPB_W0@Z
.text$mn:0000BDFC ?numstrcmp@NumericStringEquivalence@@SAHPB_W0@Z proc near
.text$mn:0000BDFC                                         ; CODE XREF: NumericStringEquivalence::operator()(wchar_t const *,wchar_t const *)+11p
.text$mn:0000BDFC
.text$mn:0000BDFC var_1C          = dword ptr -1Ch
.text$mn:0000BDFC var_18          = dword ptr -18h
.text$mn:0000BDFC var_14          = dword ptr -14h
.text$mn:0000BDFC var_10          = dword ptr -10h
.text$mn:0000BDFC var_C           = dword ptr -0Ch
.text$mn:0000BDFC EndPtr          = dword ptr -8
.text$mn:0000BDFC var_4           = dword ptr -4
.text$mn:0000BDFC Str             = dword ptr  8
.text$mn:0000BDFC arg_4           = dword ptr  0Ch
.text$mn:0000BDFC
.text$mn:0000BDFC                 push    ebp
.text$mn:0000BDFD                 mov     ebp, esp
.text$mn:0000BDFF                 sub     esp, 1Ch
.text$mn:0000BE02                 push    esi
.text$mn:0000BE03                 mov     [ebp+var_4], 0
.text$mn:0000BE0A
.text$mn:0000BE0A loc_BE0A:                               ; CODE XREF: NumericStringEquivalence::numstrcmp(wchar_t const *,wchar_t const *):loc_BF73j
.text$mn:0000BE0A                 mov     eax, [ebp+Str]
.text$mn:0000BE0D                 movzx   ecx, word ptr [eax]
.text$mn:0000BE10                 test    ecx, ecx
.text$mn:0000BE12                 jz      short loc_BE1E
.text$mn:0000BE14                 mov     edx, [ebp+arg_4]
.text$mn:0000BE17                 movzx   eax, word ptr [edx]
.text$mn:0000BE1A                 test    eax, eax
.text$mn:0000BE1C                 jnz     short loc_BE44
.text$mn:0000BE1E
.text$mn:0000BE1E loc_BE1E:                               ; CODE XREF: NumericStringEquivalence::numstrcmp(wchar_t const *,wchar_t const *)+16j
.text$mn:0000BE1E                 mov     ecx, [ebp+Str]
.text$mn:0000BE21                 movzx   edx, word ptr [ecx]
.text$mn:0000BE24                 mov     eax, [ebp+arg_4]
.text$mn:0000BE27                 movzx   ecx, word ptr [eax]
.text$mn:0000BE2A                 cmp     edx, ecx
.text$mn:0000BE2C                 jz      short loc_BE3F
.text$mn:0000BE2E                 mov     edx, [ebp+Str]
.text$mn:0000BE31                 movzx   eax, word ptr [edx]
.text$mn:0000BE34                 mov     ecx, [ebp+arg_4]
.text$mn:0000BE37                 movzx   edx, word ptr [ecx]
.text$mn:0000BE3A                 sub     eax, edx
.text$mn:0000BE3C                 mov     [ebp+var_4], eax
.text$mn:0000BE3F
.text$mn:0000BE3F loc_BE3F:                               ; CODE XREF: NumericStringEquivalence::numstrcmp(wchar_t const *,wchar_t const *)+30j
.text$mn:0000BE3F                 jmp     loc_BF78
.text$mn:0000BE44 ; ---------------------------------------------------------------------------
.text$mn:0000BE44
.text$mn:0000BE44 loc_BE44:                               ; CODE XREF: NumericStringEquivalence::numstrcmp(wchar_t const *,wchar_t const *)+20j
.text$mn:0000BE44                 mov     eax, [ebp+Str]
.text$mn:0000BE47                 movzx   ecx, word ptr [eax]
.text$mn:0000BE4A                 push    ecx             ; C
.text$mn:0000BE4B                 call    _iswdigit
.text$mn:0000BE50                 add     esp, 4
.text$mn:0000BE53                 test    eax, eax
.text$mn:0000BE55                 jz      short loc_BEC8
.text$mn:0000BE57                 mov     edx, [ebp+arg_4]
.text$mn:0000BE5A                 movzx   eax, word ptr [edx]
.text$mn:0000BE5D                 push    eax             ; C
.text$mn:0000BE5E                 call    _iswdigit
.text$mn:0000BE63                 add     esp, 4
.text$mn:0000BE66                 test    eax, eax
.text$mn:0000BE68                 jz      short loc_BEC8
.text$mn:0000BE6A                 push    0Ah             ; Radix
.text$mn:0000BE6C                 lea     ecx, [ebp+EndPtr]
.text$mn:0000BE6F                 push    ecx             ; EndPtr
.text$mn:0000BE70                 mov     edx, [ebp+Str]
.text$mn:0000BE73                 push    edx             ; Str
.text$mn:0000BE74                 call    _wcstol
.text$mn:0000BE79                 add     esp, 0Ch
.text$mn:0000BE7C                 mov     esi, eax
.text$mn:0000BE7E                 push    0Ah             ; Radix
.text$mn:0000BE80                 lea     eax, [ebp+var_C]
.text$mn:0000BE83                 push    eax             ; EndPtr
.text$mn:0000BE84                 mov     ecx, [ebp+arg_4]
.text$mn:0000BE87                 push    ecx             ; Str
.text$mn:0000BE88                 call    _wcstol
.text$mn:0000BE8D                 add     esp, 0Ch
.text$mn:0000BE90                 sub     esi, eax
.text$mn:0000BE92                 mov     [ebp+var_4], esi
.text$mn:0000BE95                 jnz     short loc_BEAC
.text$mn:0000BE97                 mov     edx, [ebp+var_C]
.text$mn:0000BE9A                 sub     edx, [ebp+arg_4]
.text$mn:0000BE9D                 sar     edx, 1
.text$mn:0000BE9F                 mov     eax, [ebp+EndPtr]
.text$mn:0000BEA2                 sub     eax, [ebp+Str]
.text$mn:0000BEA5                 sar     eax, 1
.text$mn:0000BEA7                 sub     edx, eax
.text$mn:0000BEA9                 mov     [ebp+var_4], edx
.text$mn:0000BEAC
.text$mn:0000BEAC loc_BEAC:                               ; CODE XREF: NumericStringEquivalence::numstrcmp(wchar_t const *,wchar_t const *)+99j
.text$mn:0000BEAC                 cmp     [ebp+var_4], 0
.text$mn:0000BEB0                 jz      short loc_BEB7
.text$mn:0000BEB2                 jmp     loc_BF78
.text$mn:0000BEB7 ; ---------------------------------------------------------------------------
.text$mn:0000BEB7
.text$mn:0000BEB7 loc_BEB7:                               ; CODE XREF: NumericStringEquivalence::numstrcmp(wchar_t const *,wchar_t const *)+B4j
.text$mn:0000BEB7                 mov     ecx, [ebp+EndPtr]
.text$mn:0000BEBA                 mov     [ebp+Str], ecx
.text$mn:0000BEBD                 mov     edx, [ebp+var_C]
.text$mn:0000BEC0                 mov     [ebp+arg_4], edx
.text$mn:0000BEC3                 jmp     loc_BF73
.text$mn:0000BEC8 ; ---------------------------------------------------------------------------
.text$mn:0000BEC8
.text$mn:0000BEC8 loc_BEC8:                               ; CODE XREF: NumericStringEquivalence::numstrcmp(wchar_t const *,wchar_t const *)+59j
.text$mn:0000BEC8                                         ; NumericStringEquivalence::numstrcmp(wchar_t const *,wchar_t const *)+6Cj
.text$mn:0000BEC8                 mov     eax, [ebp+Str]
.text$mn:0000BECB                 movzx   ecx, word ptr [eax]
.text$mn:0000BECE                 push    ecx             ; C
.text$mn:0000BECF                 call    _iswascii
.text$mn:0000BED4                 add     esp, 4
.text$mn:0000BED7                 test    eax, eax
.text$mn:0000BED9                 jz      short loc_BF05
.text$mn:0000BEDB                 mov     edx, [ebp+Str]
.text$mn:0000BEDE                 movzx   eax, word ptr [edx]
.text$mn:0000BEE1                 push    eax             ; C
.text$mn:0000BEE2                 call    _iswupper
.text$mn:0000BEE7                 add     esp, 4
.text$mn:0000BEEA                 test    eax, eax
.text$mn:0000BEEC                 jz      short loc_BF05
.text$mn:0000BEEE                 mov     ecx, [ebp+Str]
.text$mn:0000BEF1                 movzx   edx, word ptr [ecx]
.text$mn:0000BEF4                 push    edx             ; C
.text$mn:0000BEF5                 call    _towlower
.text$mn:0000BEFA                 add     esp, 4
.text$mn:0000BEFD                 movzx   eax, ax
.text$mn:0000BF00                 mov     [ebp+var_10], eax
.text$mn:0000BF03                 jmp     short loc_BF0E
.text$mn:0000BF05 ; ---------------------------------------------------------------------------
.text$mn:0000BF05
.text$mn:0000BF05 loc_BF05:                               ; CODE XREF: NumericStringEquivalence::numstrcmp(wchar_t const *,wchar_t const *)+DDj
.text$mn:0000BF05                                         ; NumericStringEquivalence::numstrcmp(wchar_t const *,wchar_t const *)+F0j
.text$mn:0000BF05                 mov     ecx, [ebp+Str]
.text$mn:0000BF08                 movzx   edx, word ptr [ecx]
.text$mn:0000BF0B                 mov     [ebp+var_10], edx
.text$mn:0000BF0E
.text$mn:0000BF0E loc_BF0E:                               ; CODE XREF: NumericStringEquivalence::numstrcmp(wchar_t const *,wchar_t const *)+107j
.text$mn:0000BF0E                 mov     eax, [ebp+arg_4]
.text$mn:0000BF11                 movzx   ecx, word ptr [eax]
.text$mn:0000BF14                 push    ecx             ; C
.text$mn:0000BF15                 call    _iswascii
.text$mn:0000BF1A                 add     esp, 4
.text$mn:0000BF1D                 test    eax, eax
.text$mn:0000BF1F                 jz      short loc_BF4B
.text$mn:0000BF21                 mov     edx, [ebp+arg_4]
.text$mn:0000BF24                 movzx   eax, word ptr [edx]
.text$mn:0000BF27                 push    eax             ; C
.text$mn:0000BF28                 call    _iswupper
.text$mn:0000BF2D                 add     esp, 4
.text$mn:0000BF30                 test    eax, eax
.text$mn:0000BF32                 jz      short loc_BF4B
.text$mn:0000BF34                 mov     ecx, [ebp+arg_4]
.text$mn:0000BF37                 movzx   edx, word ptr [ecx]
.text$mn:0000BF3A                 push    edx             ; C
.text$mn:0000BF3B                 call    _towlower
.text$mn:0000BF40                 add     esp, 4
.text$mn:0000BF43                 movzx   eax, ax
.text$mn:0000BF46                 mov     [ebp+var_14], eax
.text$mn:0000BF49                 jmp     short loc_BF54
.text$mn:0000BF4B ; ---------------------------------------------------------------------------
.text$mn:0000BF4B
.text$mn:0000BF4B loc_BF4B:                               ; CODE XREF: NumericStringEquivalence::numstrcmp(wchar_t const *,wchar_t const *)+123j
.text$mn:0000BF4B                                         ; NumericStringEquivalence::numstrcmp(wchar_t const *,wchar_t const *)+136j
.text$mn:0000BF4B                 mov     ecx, [ebp+arg_4]
.text$mn:0000BF4E                 movzx   edx, word ptr [ecx]
.text$mn:0000BF51                 mov     [ebp+var_14], edx
.text$mn:0000BF54
.text$mn:0000BF54 loc_BF54:                               ; CODE XREF: NumericStringEquivalence::numstrcmp(wchar_t const *,wchar_t const *)+14Dj
.text$mn:0000BF54                 mov     eax, [ebp+var_10]
.text$mn:0000BF57                 sub     eax, [ebp+var_14]
.text$mn:0000BF5A                 mov     [ebp+var_4], eax
.text$mn:0000BF5D                 jz      short loc_BF61
.text$mn:0000BF5F                 jmp     short loc_BF78
.text$mn:0000BF61 ; ---------------------------------------------------------------------------
.text$mn:0000BF61
.text$mn:0000BF61 loc_BF61:                               ; CODE XREF: NumericStringEquivalence::numstrcmp(wchar_t const *,wchar_t const *)+161j
.text$mn:0000BF61                 mov     ecx, [ebp+Str]
.text$mn:0000BF64                 add     ecx, 2
.text$mn:0000BF67                 mov     [ebp+Str], ecx
.text$mn:0000BF6A                 mov     edx, [ebp+arg_4]
.text$mn:0000BF6D                 add     edx, 2
.text$mn:0000BF70                 mov     [ebp+arg_4], edx
.text$mn:0000BF73
.text$mn:0000BF73 loc_BF73:                               ; CODE XREF: NumericStringEquivalence::numstrcmp(wchar_t const *,wchar_t const *)+C7j
.text$mn:0000BF73                 jmp     loc_BE0A
.text$mn:0000BF78 ; ---------------------------------------------------------------------------
.text$mn:0000BF78
.text$mn:0000BF78 loc_BF78:                               ; CODE XREF: NumericStringEquivalence::numstrcmp(wchar_t const *,wchar_t const *):loc_BE3Fj
.text$mn:0000BF78                                         ; NumericStringEquivalence::numstrcmp(wchar_t const *,wchar_t const *)+B6j ...
.text$mn:0000BF78                 cmp     [ebp+var_4], 0
.text$mn:0000BF7C                 jge     short loc_BF87
.text$mn:0000BF7E                 mov     [ebp+var_1C], 0FFFFFFFFh
.text$mn:0000BF85                 jmp     short loc_BFA3
.text$mn:0000BF87 ; ---------------------------------------------------------------------------
.text$mn:0000BF87
.text$mn:0000BF87 loc_BF87:                               ; CODE XREF: NumericStringEquivalence::numstrcmp(wchar_t const *,wchar_t const *)+180j
.text$mn:0000BF87                 cmp     [ebp+var_4], 0
.text$mn:0000BF8B                 jle     short loc_BF96
.text$mn:0000BF8D                 mov     [ebp+var_18], 1
.text$mn:0000BF94                 jmp     short loc_BF9D
.text$mn:0000BF96 ; ---------------------------------------------------------------------------
.text$mn:0000BF96
.text$mn:0000BF96 loc_BF96:                               ; CODE XREF: NumericStringEquivalence::numstrcmp(wchar_t const *,wchar_t const *)+18Fj
.text$mn:0000BF96                 mov     [ebp+var_18], 0
.text$mn:0000BF9D
.text$mn:0000BF9D loc_BF9D:                               ; CODE XREF: NumericStringEquivalence::numstrcmp(wchar_t const *,wchar_t const *)+198j
.text$mn:0000BF9D                 mov     eax, [ebp+var_18]
.text$mn:0000BFA0                 mov     [ebp+var_1C], eax
.text$mn:0000BFA3
.text$mn:0000BFA3 loc_BFA3:                               ; CODE XREF: NumericStringEquivalence::numstrcmp(wchar_t const *,wchar_t const *)+189j
.text$mn:0000BFA3                 mov     eax, [ebp+var_1C]
.text$mn:0000BFA6                 pop     esi
.text$mn:0000BFA7                 mov     esp, ebp
.text$mn:0000BFA9                 pop     ebp
.text$mn:0000BFAA                 retn
.text$mn:0000BFAA ?numstrcmp@NumericStringEquivalence@@SAHPB_W0@Z endp
.text$mn:0000BFAA
.text$mn:0000BFAA ; ---------------------------------------------------------------------------
.text$mn:0000BFAB                 align 4
.text$mn:0000BFAB _text$mn        ends
.text$mn:0000BFAB
.text$mn:0000BFAC ; ===========================================================================
.text$mn:0000BFAC
.text$mn:0000BFAC ; Segment type: Pure code
.text$mn:0000BFAC ; Segment permissions: Read/Execute
.text$mn:0000BFAC _text$mn        segment para public 'CODE' use32
.text$mn:0000BFAC                 assume cs:_text$mn
.text$mn:0000BFAC                 ;org 0BFACh
.text$mn:0000BFAC ; COMDAT (pick any)
.text$mn:0000BFAC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000BFAC
.text$mn:0000BFAC ; =============== S U B R O U T I N E =======================================
.text$mn:0000BFAC
.text$mn:0000BFAC ; Attributes: bp-based frame
.text$mn:0000BFAC
.text$mn:0000BFAC ; public: void __thiscall std::vector<wchar_t, class std::allocator<wchar_t>>::push_back(wchar_t &&)
.text$mn:0000BFAC                 public ?push_back@?$vector@_WV?$allocator@_W@std@@@std@@QAEX$$QA_W@Z
.text$mn:0000BFAC ?push_back@?$vector@_WV?$allocator@_W@std@@@std@@QAEX$$QA_W@Z proc near
.text$mn:0000BFAC                                         ; CODE XREF: WindowsMenu::initPopupMenu(HMENU__ *,DocTabView *)+19Ap
.text$mn:0000BFAC
.text$mn:0000BFAC var_C           = dword ptr -0Ch
.text$mn:0000BFAC var_8           = dword ptr -8
.text$mn:0000BFAC var_2           = byte ptr -2
.text$mn:0000BFAC var_1           = byte ptr -1
.text$mn:0000BFAC arg_0           = dword ptr  8
.text$mn:0000BFAC
.text$mn:0000BFAC                 push    ebp
.text$mn:0000BFAD                 mov     ebp, esp
.text$mn:0000BFAF                 sub     esp, 0Ch
.text$mn:0000BFB2                 mov     [ebp+var_8], ecx
.text$mn:0000BFB5                 mov     eax, [ebp+arg_0]
.text$mn:0000BFB8                 push    eax
.text$mn:0000BFB9                 call    ??$addressof@_W@std@@YAPA_WAA_W@Z ; std::addressof<wchar_t>(wchar_t &)
.text$mn:0000BFBE                 add     esp, 4
.text$mn:0000BFC1                 push    eax
.text$mn:0000BFC2                 mov     ecx, [ebp+var_8]
.text$mn:0000BFC5                 call    ?_Inside@?$vector@_WV?$allocator@_W@std@@@std@@IBE_NPB_W@Z ; std::vector<wchar_t,std::allocator<wchar_t>>::_Inside(wchar_t const *)
.text$mn:0000BFCA                 movzx   ecx, al
.text$mn:0000BFCD                 test    ecx, ecx
.text$mn:0000BFCF                 jz      loc_C05B
.text$mn:0000BFD5                 mov     edx, [ebp+arg_0]
.text$mn:0000BFD8                 push    edx
.text$mn:0000BFD9                 call    ??$addressof@_W@std@@YAPA_WAA_W@Z ; std::addressof<wchar_t>(wchar_t &)
.text$mn:0000BFDE                 add     esp, 4
.text$mn:0000BFE1                 mov     ecx, [ebp+var_8]
.text$mn:0000BFE4                 sub     eax, [ecx+4]
.text$mn:0000BFE7                 sar     eax, 1
.text$mn:0000BFE9                 mov     [ebp+var_C], eax
.text$mn:0000BFEC                 mov     edx, [ebp+var_8]
.text$mn:0000BFEF                 mov     eax, [ebp+var_8]
.text$mn:0000BFF2                 mov     ecx, [edx+8]
.text$mn:0000BFF5                 cmp     ecx, [eax+0Ch]
.text$mn:0000BFF8                 jnz     short loc_C004
.text$mn:0000BFFA                 push    1
.text$mn:0000BFFC                 mov     ecx, [ebp+var_8]
.text$mn:0000BFFF                 call    ?_Reserve@?$vector@_WV?$allocator@_W@std@@@std@@IAEXI@Z ; std::vector<wchar_t,std::allocator<wchar_t>>::_Reserve(uint)
.text$mn:0000C004
.text$mn:0000C004 loc_C004:                               ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::push_back(wchar_t &&)+4Cj
.text$mn:0000C004                 mov     edx, [ebp+var_8]
.text$mn:0000C007                 mov     eax, [edx+8]
.text$mn:0000C00A                 push    eax
.text$mn:0000C00B                 mov     ecx, [ebp+var_8]
.text$mn:0000C00E                 mov     edx, [ecx+8]
.text$mn:0000C011                 push    edx
.text$mn:0000C012                 mov     ecx, [ebp+var_8]
.text$mn:0000C015                 call    ?_Orphan_range@?$vector@_WV?$allocator@_W@std@@@std@@IBEXPA_W0@Z ; std::vector<wchar_t,std::allocator<wchar_t>>::_Orphan_range(wchar_t *,wchar_t *)
.text$mn:0000C01A                 mov     eax, [ebp+var_8]
.text$mn:0000C01D                 mov     ecx, [eax+4]
.text$mn:0000C020                 mov     edx, [ebp+var_C]
.text$mn:0000C023                 lea     eax, [ecx+edx*2]
.text$mn:0000C026                 push    eax
.text$mn:0000C027                 call    ??$forward@_W@std@@YA$$QA_WAA_W@Z ; std::forward<wchar_t>(wchar_t &)
.text$mn:0000C02C                 add     esp, 4
.text$mn:0000C02F                 push    eax             ; int
.text$mn:0000C030                 mov     ecx, [ebp+var_8]
.text$mn:0000C033                 mov     edx, [ecx+8]
.text$mn:0000C036                 push    edx             ; void *
.text$mn:0000C037                 lea     eax, [ebp+var_1]
.text$mn:0000C03A                 push    eax
.text$mn:0000C03B                 mov     ecx, [ebp+var_8]
.text$mn:0000C03E                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:0000C043                 mov     ecx, eax
.text$mn:0000C045                 call    ??$construct@_W_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_W$$QA_W@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::construct<wchar_t,wchar_t>(wchar_t *,wchar_t &&)
.text$mn:0000C04A                 mov     ecx, [ebp+var_8]
.text$mn:0000C04D                 mov     edx, [ecx+8]
.text$mn:0000C050                 add     edx, 2
.text$mn:0000C053                 mov     eax, [ebp+var_8]
.text$mn:0000C056                 mov     [eax+8], edx
.text$mn:0000C059                 jmp     short loc_C0BF
.text$mn:0000C05B ; ---------------------------------------------------------------------------
.text$mn:0000C05B
.text$mn:0000C05B loc_C05B:                               ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::push_back(wchar_t &&)+23j
.text$mn:0000C05B                 mov     ecx, [ebp+var_8]
.text$mn:0000C05E                 mov     edx, [ebp+var_8]
.text$mn:0000C061                 mov     eax, [ecx+8]
.text$mn:0000C064                 cmp     eax, [edx+0Ch]
.text$mn:0000C067                 jnz     short loc_C073
.text$mn:0000C069                 push    1
.text$mn:0000C06B                 mov     ecx, [ebp+var_8]
.text$mn:0000C06E                 call    ?_Reserve@?$vector@_WV?$allocator@_W@std@@@std@@IAEXI@Z ; std::vector<wchar_t,std::allocator<wchar_t>>::_Reserve(uint)
.text$mn:0000C073
.text$mn:0000C073 loc_C073:                               ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::push_back(wchar_t &&)+BBj
.text$mn:0000C073                 mov     ecx, [ebp+var_8]
.text$mn:0000C076                 mov     edx, [ecx+8]
.text$mn:0000C079                 push    edx
.text$mn:0000C07A                 mov     eax, [ebp+var_8]
.text$mn:0000C07D                 mov     ecx, [eax+8]
.text$mn:0000C080                 push    ecx
.text$mn:0000C081                 mov     ecx, [ebp+var_8]
.text$mn:0000C084                 call    ?_Orphan_range@?$vector@_WV?$allocator@_W@std@@@std@@IBEXPA_W0@Z ; std::vector<wchar_t,std::allocator<wchar_t>>::_Orphan_range(wchar_t *,wchar_t *)
.text$mn:0000C089                 mov     edx, [ebp+arg_0]
.text$mn:0000C08C                 push    edx
.text$mn:0000C08D                 call    ??$forward@_W@std@@YA$$QA_WAA_W@Z ; std::forward<wchar_t>(wchar_t &)
.text$mn:0000C092                 add     esp, 4
.text$mn:0000C095                 push    eax             ; int
.text$mn:0000C096                 mov     eax, [ebp+var_8]
.text$mn:0000C099                 mov     ecx, [eax+8]
.text$mn:0000C09C                 push    ecx             ; void *
.text$mn:0000C09D                 lea     edx, [ebp+var_2]
.text$mn:0000C0A0                 push    edx
.text$mn:0000C0A1                 mov     ecx, [ebp+var_8]
.text$mn:0000C0A4                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:0000C0A9                 mov     ecx, eax
.text$mn:0000C0AB                 call    ??$construct@_W_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_W$$QA_W@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::construct<wchar_t,wchar_t>(wchar_t *,wchar_t &&)
.text$mn:0000C0B0                 mov     eax, [ebp+var_8]
.text$mn:0000C0B3                 mov     ecx, [eax+8]
.text$mn:0000C0B6                 add     ecx, 2
.text$mn:0000C0B9                 mov     edx, [ebp+var_8]
.text$mn:0000C0BC                 mov     [edx+8], ecx
.text$mn:0000C0BF
.text$mn:0000C0BF loc_C0BF:                               ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::push_back(wchar_t &&)+ADj
.text$mn:0000C0BF                 mov     esp, ebp
.text$mn:0000C0C1                 pop     ebp
.text$mn:0000C0C2                 retn    4
.text$mn:0000C0C2 ?push_back@?$vector@_WV?$allocator@_W@std@@@std@@QAEX$$QA_W@Z endp
.text$mn:0000C0C2
.text$mn:0000C0C2 ; ---------------------------------------------------------------------------
.text$mn:0000C0C5                 align 4
.text$mn:0000C0C5 _text$mn        ends
.text$mn:0000C0C5
.text$mn:0000C0C8 ; ===========================================================================
.text$mn:0000C0C8
.text$mn:0000C0C8 ; Segment type: Pure code
.text$mn:0000C0C8 ; Segment permissions: Read/Execute
.text$mn:0000C0C8 _text$mn        segment para public 'CODE' use32
.text$mn:0000C0C8                 assume cs:_text$mn
.text$mn:0000C0C8                 ;org 0C0C8h
.text$mn:0000C0C8 ; COMDAT (pick any)
.text$mn:0000C0C8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000C0C8
.text$mn:0000C0C8 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C0C8
.text$mn:0000C0C8 ; Attributes: bp-based frame
.text$mn:0000C0C8
.text$mn:0000C0C8 ; void __thiscall Window::reSizeTo(Window *this, struct tagRECT *)
.text$mn:0000C0C8                 public ?reSizeTo@Window@@UAEXAAUtagRECT@@@Z
.text$mn:0000C0C8 ?reSizeTo@Window@@UAEXAAUtagRECT@@@Z proc near
.text$mn:0000C0C8                                         ; DATA XREF: .rdata:0000DDE0o
.text$mn:0000C0C8                                         ; .rdata:0000DE14o ...
.text$mn:0000C0C8
.text$mn:0000C0C8 var_4           = dword ptr -4
.text$mn:0000C0C8 arg_0           = dword ptr  8
.text$mn:0000C0C8
.text$mn:0000C0C8                 push    ebp
.text$mn:0000C0C9                 mov     ebp, esp
.text$mn:0000C0CB                 push    ecx
.text$mn:0000C0CC                 mov     [ebp+var_4], ecx
.text$mn:0000C0CF                 push    1               ; bRepaint
.text$mn:0000C0D1                 mov     eax, [ebp+arg_0]
.text$mn:0000C0D4                 mov     ecx, [eax+0Ch]
.text$mn:0000C0D7                 push    ecx             ; nHeight
.text$mn:0000C0D8                 mov     edx, [ebp+arg_0]
.text$mn:0000C0DB                 mov     eax, [edx+8]
.text$mn:0000C0DE                 push    eax             ; nWidth
.text$mn:0000C0DF                 mov     ecx, [ebp+arg_0]
.text$mn:0000C0E2                 mov     edx, [ecx+4]
.text$mn:0000C0E5                 push    edx             ; Y
.text$mn:0000C0E6                 mov     eax, [ebp+arg_0]
.text$mn:0000C0E9                 mov     ecx, [eax]
.text$mn:0000C0EB                 push    ecx             ; X
.text$mn:0000C0EC                 mov     edx, [ebp+var_4]
.text$mn:0000C0EF                 mov     eax, [edx+0Ch]
.text$mn:0000C0F2                 push    eax             ; hWnd
.text$mn:0000C0F3                 call    dword ptr ds:__imp__MoveWindow@24 ; MoveWindow(x,x,x,x,x,x)
.text$mn:0000C0F9                 push    0
.text$mn:0000C0FB                 mov     ecx, [ebp+var_4]
.text$mn:0000C0FE                 mov     edx, [ecx]
.text$mn:0000C100                 mov     ecx, [ebp+var_4]
.text$mn:0000C103                 mov     eax, [edx+18h]
.text$mn:0000C106                 call    eax
.text$mn:0000C108                 mov     esp, ebp
.text$mn:0000C10A                 pop     ebp
.text$mn:0000C10B                 retn    4
.text$mn:0000C10B ?reSizeTo@Window@@UAEXAAUtagRECT@@@Z endp
.text$mn:0000C10B
.text$mn:0000C10B ; ---------------------------------------------------------------------------
.text$mn:0000C10E                 align 10h
.text$mn:0000C10E _text$mn        ends
.text$mn:0000C10E
.text$mn:0000C110 ; ===========================================================================
.text$mn:0000C110
.text$mn:0000C110 ; Segment type: Pure code
.text$mn:0000C110 ; Segment permissions: Read/Execute
.text$mn:0000C110 _text$mn        segment para public 'CODE' use32
.text$mn:0000C110                 assume cs:_text$mn
.text$mn:0000C110                 ;org 0C110h
.text$mn:0000C110 ; COMDAT (pick any)
.text$mn:0000C110                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000C110
.text$mn:0000C110 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C110
.text$mn:0000C110 ; Attributes: bp-based frame
.text$mn:0000C110
.text$mn:0000C110 ; void __thiscall Window::reSizeToWH(Window *this, struct tagRECT *)
.text$mn:0000C110                 public ?reSizeToWH@Window@@UAEXAAUtagRECT@@@Z
.text$mn:0000C110 ?reSizeToWH@Window@@UAEXAAUtagRECT@@@Z proc near
.text$mn:0000C110                                         ; DATA XREF: .rdata:0000DDE4o
.text$mn:0000C110                                         ; .rdata:0000DE18o ...
.text$mn:0000C110
.text$mn:0000C110 var_4           = dword ptr -4
.text$mn:0000C110 arg_0           = dword ptr  8
.text$mn:0000C110
.text$mn:0000C110                 push    ebp
.text$mn:0000C111                 mov     ebp, esp
.text$mn:0000C113                 push    ecx
.text$mn:0000C114                 mov     [ebp+var_4], ecx
.text$mn:0000C117                 push    1               ; bRepaint
.text$mn:0000C119                 mov     eax, [ebp+arg_0]
.text$mn:0000C11C                 mov     ecx, [ebp+arg_0]
.text$mn:0000C11F                 mov     edx, [eax+0Ch]
.text$mn:0000C122                 sub     edx, [ecx+4]
.text$mn:0000C125                 push    edx             ; nHeight
.text$mn:0000C126                 mov     eax, [ebp+arg_0]
.text$mn:0000C129                 mov     ecx, [ebp+arg_0]
.text$mn:0000C12C                 mov     edx, [eax+8]
.text$mn:0000C12F                 sub     edx, [ecx]
.text$mn:0000C131                 push    edx             ; nWidth
.text$mn:0000C132                 mov     eax, [ebp+arg_0]
.text$mn:0000C135                 mov     ecx, [eax+4]
.text$mn:0000C138                 push    ecx             ; Y
.text$mn:0000C139                 mov     edx, [ebp+arg_0]
.text$mn:0000C13C                 mov     eax, [edx]
.text$mn:0000C13E                 push    eax             ; X
.text$mn:0000C13F                 mov     ecx, [ebp+var_4]
.text$mn:0000C142                 mov     edx, [ecx+0Ch]
.text$mn:0000C145                 push    edx             ; hWnd
.text$mn:0000C146                 call    dword ptr ds:__imp__MoveWindow@24 ; MoveWindow(x,x,x,x,x,x)
.text$mn:0000C14C                 push    0
.text$mn:0000C14E                 mov     eax, [ebp+var_4]
.text$mn:0000C151                 mov     edx, [eax]
.text$mn:0000C153                 mov     ecx, [ebp+var_4]
.text$mn:0000C156                 mov     eax, [edx+18h]
.text$mn:0000C159                 call    eax
.text$mn:0000C15B                 mov     esp, ebp
.text$mn:0000C15D                 pop     ebp
.text$mn:0000C15E                 retn    4
.text$mn:0000C15E ?reSizeToWH@Window@@UAEXAAUtagRECT@@@Z endp
.text$mn:0000C15E
.text$mn:0000C15E ; ---------------------------------------------------------------------------
.text$mn:0000C161                 align 4
.text$mn:0000C161 _text$mn        ends
.text$mn:0000C161
.text$mn:0000C164 ; ===========================================================================
.text$mn:0000C164
.text$mn:0000C164 ; Segment type: Pure code
.text$mn:0000C164 ; Segment permissions: Read/Execute
.text$mn:0000C164 _text$mn        segment para public 'CODE' use32
.text$mn:0000C164                 assume cs:_text$mn
.text$mn:0000C164                 ;org 0C164h
.text$mn:0000C164 ; COMDAT (pick any)
.text$mn:0000C164                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000C164
.text$mn:0000C164 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C164
.text$mn:0000C164 ; Attributes: bp-based frame
.text$mn:0000C164
.text$mn:0000C164 ; void __thiscall Window::redraw(Window *this, bool)
.text$mn:0000C164                 public ?redraw@Window@@UBEX_N@Z
.text$mn:0000C164 ?redraw@Window@@UBEX_N@Z proc near      ; DATA XREF: .rdata:0000DDE8o
.text$mn:0000C164                                         ; .rdata:0000DE1Co ...
.text$mn:0000C164
.text$mn:0000C164 var_4           = dword ptr -4
.text$mn:0000C164 arg_0           = byte ptr  8
.text$mn:0000C164
.text$mn:0000C164                 push    ebp
.text$mn:0000C165                 mov     ebp, esp
.text$mn:0000C167                 push    ecx
.text$mn:0000C168                 mov     [ebp+var_4], ecx
.text$mn:0000C16B                 push    1               ; bErase
.text$mn:0000C16D                 push    0               ; lpRect
.text$mn:0000C16F                 mov     eax, [ebp+var_4]
.text$mn:0000C172                 mov     ecx, [eax+0Ch]
.text$mn:0000C175                 push    ecx             ; hWnd
.text$mn:0000C176                 call    dword ptr ds:__imp__InvalidateRect@12 ; InvalidateRect(x,x,x)
.text$mn:0000C17C                 movzx   edx, [ebp+arg_0]
.text$mn:0000C180                 test    edx, edx
.text$mn:0000C182                 jz      short loc_C191
.text$mn:0000C184                 mov     eax, [ebp+var_4]
.text$mn:0000C187                 mov     ecx, [eax+0Ch]
.text$mn:0000C18A                 push    ecx             ; hWnd
.text$mn:0000C18B                 call    dword ptr ds:__imp__UpdateWindow@4 ; UpdateWindow(x)
.text$mn:0000C191
.text$mn:0000C191 loc_C191:                               ; CODE XREF: Window::redraw(bool)+1Ej
.text$mn:0000C191                 mov     esp, ebp
.text$mn:0000C193                 pop     ebp
.text$mn:0000C194                 retn    4
.text$mn:0000C194 ?redraw@Window@@UBEX_N@Z endp
.text$mn:0000C194
.text$mn:0000C194 ; ---------------------------------------------------------------------------
.text$mn:0000C197                 align 4
.text$mn:0000C197 _text$mn        ends
.text$mn:0000C197
.text$mn:0000C198 ; ===========================================================================
.text$mn:0000C198
.text$mn:0000C198 ; Segment type: Pure code
.text$mn:0000C198 ; Segment permissions: Read/Execute
.text$mn:0000C198 _text$mn        segment para public 'CODE' use32
.text$mn:0000C198                 assume cs:_text$mn
.text$mn:0000C198                 ;org 0C198h
.text$mn:0000C198 ; COMDAT (pick any)
.text$mn:0000C198                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000C198
.text$mn:0000C198 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C198
.text$mn:0000C198 ; Attributes: bp-based frame
.text$mn:0000C198
.text$mn:0000C198 ; public: void __thiscall std::vector<int, class std::allocator<int>>::resize(unsigned int)
.text$mn:0000C198                 public ?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z
.text$mn:0000C198 ?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z proc near
.text$mn:0000C198                                         ; CODE XREF: WindowsDlg::doRefresh(bool)+9Dp
.text$mn:0000C198                                         ; WindowsDlg::run_dlgProc(uint,uint,long)+450p
.text$mn:0000C198
.text$mn:0000C198 var_18          = dword ptr -18h
.text$mn:0000C198 var_11          = byte ptr -11h
.text$mn:0000C198 var_10          = dword ptr -10h
.text$mn:0000C198 var_C           = dword ptr -0Ch
.text$mn:0000C198 var_4           = dword ptr -4
.text$mn:0000C198 arg_0           = dword ptr  8
.text$mn:0000C198
.text$mn:0000C198 ; FUNCTION CHUNK AT .text$mn:0000C261 SIZE 00000009 BYTES
.text$mn:0000C198 ; FUNCTION CHUNK AT .text$mn:0000C271 SIZE 00000030 BYTES
.text$mn:0000C198
.text$mn:0000C198                 push    ebp
.text$mn:0000C199                 mov     ebp, esp
.text$mn:0000C19B                 push    0FFFFFFFFh
.text$mn:0000C19D                 push    offset __ehhandler$?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z
.text$mn:0000C1A2                 mov     eax, large fs:0
.text$mn:0000C1A8                 push    eax
.text$mn:0000C1A9                 push    ecx
.text$mn:0000C1AA                 sub     esp, 8
.text$mn:0000C1AD                 push    ebx
.text$mn:0000C1AE                 push    esi
.text$mn:0000C1AF                 push    edi
.text$mn:0000C1B0                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000C1B5                 xor     eax, ebp
.text$mn:0000C1B7                 push    eax
.text$mn:0000C1B8                 lea     eax, [ebp+var_C]
.text$mn:0000C1BB                 mov     large fs:0, eax
.text$mn:0000C1C1                 mov     [ebp+var_10], esp
.text$mn:0000C1C4                 mov     [ebp+var_18], ecx
.text$mn:0000C1C7                 mov     ecx, [ebp+var_18]
.text$mn:0000C1CA                 call    ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int>>::size(void)
.text$mn:0000C1CF                 cmp     [ebp+arg_0], eax
.text$mn:0000C1D2                 jnb     short loc_C1ED
.text$mn:0000C1D4                 mov     ecx, [ebp+var_18]
.text$mn:0000C1D7                 call    ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int>>::size(void)
.text$mn:0000C1DC                 sub     eax, [ebp+arg_0]
.text$mn:0000C1DF                 push    eax
.text$mn:0000C1E0                 mov     ecx, [ebp+var_18]
.text$mn:0000C1E3                 call    ?_Pop_back_n@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z ; std::vector<int,std::allocator<int>>::_Pop_back_n(uint)
.text$mn:0000C1E8                 jmp     loc_C28D
.text$mn:0000C1ED ; ---------------------------------------------------------------------------
.text$mn:0000C1ED
.text$mn:0000C1ED loc_C1ED:                               ; CODE XREF: std::vector<int,std::allocator<int>>::resize(uint)+3Aj
.text$mn:0000C1ED                 mov     ecx, [ebp+var_18]
.text$mn:0000C1F0                 call    ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int>>::size(void)
.text$mn:0000C1F5                 cmp     eax, [ebp+arg_0]
.text$mn:0000C1F8                 jnb     loc_C28D
.text$mn:0000C1FE                 lea     eax, [ebp+var_11]
.text$mn:0000C201                 push    eax
.text$mn:0000C202                 mov     ecx, [ebp+var_18]
.text$mn:0000C205                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@H@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>::_Getal(void)
.text$mn:0000C20A                 mov     ecx, [ebp+var_18]
.text$mn:0000C20D                 call    ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int>>::size(void)
.text$mn:0000C212                 mov     ecx, [ebp+arg_0]
.text$mn:0000C215                 sub     ecx, eax
.text$mn:0000C217                 push    ecx
.text$mn:0000C218                 mov     ecx, [ebp+var_18]
.text$mn:0000C21B                 call    ?_Reserve@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z ; std::vector<int,std::allocator<int>>::_Reserve(uint)
.text$mn:0000C220                 mov     [ebp+var_4], 0
.text$mn:0000C227                 lea     edx, [ebp+var_11]
.text$mn:0000C22A                 push    edx
.text$mn:0000C22B                 mov     ecx, [ebp+var_18]
.text$mn:0000C22E                 call    ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int>>::size(void)
.text$mn:0000C233                 mov     ecx, [ebp+arg_0]
.text$mn:0000C236                 sub     ecx, eax
.text$mn:0000C238                 push    ecx
.text$mn:0000C239                 mov     edx, [ebp+var_18]
.text$mn:0000C23C                 mov     eax, [edx+8]
.text$mn:0000C23F                 push    eax
.text$mn:0000C240                 call    ??$_Uninitialized_default_fill_n@PAHIU?$_Wrap_alloc@V?$allocator@H@std@@@std@@@std@@YAXPAHIAAU?$_Wrap_alloc@V?$allocator@H@std@@@0@@Z ; std::_Uninitialized_default_fill_n<int *,uint,std::_Wrap_alloc<std::allocator<int>>>(int *,uint,std::_Wrap_alloc<std::allocator<int>> &)
.text$mn:0000C245                 add     esp, 0Ch
.text$mn:0000C248                 jmp     short loc_C261
.text$mn:0000C248 ?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z endp
.text$mn:0000C248
.text$mn:0000C24A
.text$mn:0000C24A ; =============== S U B R O U T I N E =======================================
.text$mn:0000C24A
.text$mn:0000C24A ; Attributes: noreturn
.text$mn:0000C24A
.text$mn:0000C24A __catch$?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z$0 proc near
.text$mn:0000C24A                                         ; DATA XREF: .xdata$x:0000CEC4o
.text$mn:0000C24A                 mov     ecx, [ebp-18h]
.text$mn:0000C24D                 call    ?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ; std::vector<int,std::allocator<int>>::_Tidy(void)
.text$mn:0000C252                 push    0
.text$mn:0000C254                 push    0
.text$mn:0000C256                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:0000C256 __catch$?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z$0 endp
.text$mn:0000C256
.text$mn:0000C25B ; ---------------------------------------------------------------------------
.text$mn:0000C25B                 mov     eax, offset $LN10
.text$mn:0000C260                 retn
.text$mn:0000C261 ; ---------------------------------------------------------------------------
.text$mn:0000C261 ; START OF FUNCTION CHUNK FOR ?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z
.text$mn:0000C261
.text$mn:0000C261 loc_C261:                               ; CODE XREF: std::vector<int,std::allocator<int>>::resize(uint)+B0j
.text$mn:0000C261                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000C268                 jmp     short loc_C271
.text$mn:0000C268 ; END OF FUNCTION CHUNK FOR ?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z
.text$mn:0000C26A
.text$mn:0000C26A ; =============== S U B R O U T I N E =======================================
.text$mn:0000C26A
.text$mn:0000C26A
.text$mn:0000C26A $LN10           proc near               ; DATA XREF: .text$mn:0000C25Bo
.text$mn:0000C26A                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:0000C26A $LN10           endp ; sp-analysis failed
.text$mn:0000C26A
.text$mn:0000C271 ; START OF FUNCTION CHUNK FOR ?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z
.text$mn:0000C271
.text$mn:0000C271 loc_C271:                               ; CODE XREF: std::vector<int,std::allocator<int>>::resize(uint)+D0j
.text$mn:0000C271                 mov     ecx, [ebp+var_18]
.text$mn:0000C274                 call    ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int>>::size(void)
.text$mn:0000C279                 mov     ecx, [ebp+arg_0]
.text$mn:0000C27C                 sub     ecx, eax
.text$mn:0000C27E                 mov     edx, [ebp+var_18]
.text$mn:0000C281                 mov     eax, [edx+8]
.text$mn:0000C284                 lea     ecx, [eax+ecx*4]
.text$mn:0000C287                 mov     edx, [ebp+var_18]
.text$mn:0000C28A                 mov     [edx+8], ecx
.text$mn:0000C28D
.text$mn:0000C28D loc_C28D:                               ; CODE XREF: std::vector<int,std::allocator<int>>::resize(uint)+50j
.text$mn:0000C28D                                         ; std::vector<int,std::allocator<int>>::resize(uint)+60j
.text$mn:0000C28D                 mov     ecx, [ebp+var_C]
.text$mn:0000C290                 mov     large fs:0, ecx
.text$mn:0000C297                 pop     ecx
.text$mn:0000C298                 pop     edi
.text$mn:0000C299                 pop     esi
.text$mn:0000C29A                 pop     ebx
.text$mn:0000C29B                 mov     esp, ebp
.text$mn:0000C29D                 pop     ebp
.text$mn:0000C29E                 retn    4
.text$mn:0000C29E ; END OF FUNCTION CHUNK FOR ?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z
.text$mn:0000C29E ; ---------------------------------------------------------------------------
.text$mn:0000C2A1                 align 4
.text$mn:0000C2A1 _text$mn        ends
.text$mn:0000C2A1
.text$x:0000C2A4 ; ===========================================================================
.text$x:0000C2A4
.text$x:0000C2A4 ; Segment type: Pure code
.text$x:0000C2A4 ; Segment permissions: Read/Execute
.text$x:0000C2A4 _text$x         segment para public 'CODE' use32
.text$x:0000C2A4                 assume cs:_text$x
.text$x:0000C2A4                 ;org 0C2A4h
.text$x:0000C2A4 ; COMDAT (pick associative to section at C198)
.text$x:0000C2A4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000C2A4
.text$x:0000C2A4 ; =============== S U B R O U T I N E =======================================
.text$x:0000C2A4
.text$x:0000C2A4
.text$x:0000C2A4 __ehhandler$?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z proc near
.text$x:0000C2A4                                         ; DATA XREF: std::vector<int,std::allocator<int>>::resize(uint)+5o
.text$x:0000C2A4
.text$x:0000C2A4 arg_4           = dword ptr  8
.text$x:0000C2A4
.text$x:0000C2A4                 mov     edx, [esp+arg_4]
.text$x:0000C2A8                 lea     eax, [edx+0Ch]
.text$x:0000C2AB                 mov     ecx, [edx-1Ch]
.text$x:0000C2AE                 xor     ecx, eax
.text$x:0000C2B0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000C2B5                 mov     eax, offset __ehfuncinfo$?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z
.text$x:0000C2BA                 jmp     ___CxxFrameHandler3
.text$x:0000C2BA __ehhandler$?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z endp
.text$x:0000C2BA
.text$x:0000C2BA ; ---------------------------------------------------------------------------
.text$x:0000C2BF                 align 10h
.text$x:0000C2BF _text$x         ends
.text$x:0000C2BF
.text$mn:0000C2C0 ; ===========================================================================
.text$mn:0000C2C0
.text$mn:0000C2C0 ; Segment type: Pure code
.text$mn:0000C2C0 ; Segment permissions: Read/Execute
.text$mn:0000C2C0 _text$mn        segment para public 'CODE' use32
.text$mn:0000C2C0                 assume cs:_text$mn
.text$mn:0000C2C0                 ;org 0C2C0h
.text$mn:0000C2C0 ; COMDAT (pick any)
.text$mn:0000C2C0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000C2C0
.text$mn:0000C2C0 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C2C0
.text$mn:0000C2C0 ; Attributes: bp-based frame
.text$mn:0000C2C0
.text$mn:0000C2C0 ; public: void __thiscall std::vector<int, class std::allocator<int>>::resize(unsigned int, int const &)
.text$mn:0000C2C0                 public ?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXIABH@Z
.text$mn:0000C2C0 ?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXIABH@Z proc near
.text$mn:0000C2C0                                         ; CODE XREF: WindowsDlg::doClose(void)+F8p
.text$mn:0000C2C0                                         ; WindowsDlg::doSortToTabs(void)+E7p
.text$mn:0000C2C0
.text$mn:0000C2C0 var_1C          = dword ptr -1Ch
.text$mn:0000C2C0 var_18          = dword ptr -18h
.text$mn:0000C2C0 var_14          = dword ptr -14h
.text$mn:0000C2C0 var_10          = dword ptr -10h
.text$mn:0000C2C0 var_C           = dword ptr -0Ch
.text$mn:0000C2C0 var_4           = dword ptr -4
.text$mn:0000C2C0 arg_0           = dword ptr  8
.text$mn:0000C2C0 arg_4           = dword ptr  0Ch
.text$mn:0000C2C0
.text$mn:0000C2C0 ; FUNCTION CHUNK AT .text$mn:0000C3E9 SIZE 00000009 BYTES
.text$mn:0000C2C0 ; FUNCTION CHUNK AT .text$mn:0000C3F9 SIZE 00000030 BYTES
.text$mn:0000C2C0
.text$mn:0000C2C0                 push    ebp
.text$mn:0000C2C1                 mov     ebp, esp
.text$mn:0000C2C3                 push    0FFFFFFFFh
.text$mn:0000C2C5                 push    offset __ehhandler$?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXIABH@Z
.text$mn:0000C2CA                 mov     eax, large fs:0
.text$mn:0000C2D0                 push    eax
.text$mn:0000C2D1                 push    ecx
.text$mn:0000C2D2                 sub     esp, 0Ch
.text$mn:0000C2D5                 push    ebx
.text$mn:0000C2D6                 push    esi
.text$mn:0000C2D7                 push    edi
.text$mn:0000C2D8                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000C2DD                 xor     eax, ebp
.text$mn:0000C2DF                 push    eax
.text$mn:0000C2E0                 lea     eax, [ebp+var_C]
.text$mn:0000C2E3                 mov     large fs:0, eax
.text$mn:0000C2E9                 mov     [ebp+var_10], esp
.text$mn:0000C2EC                 mov     [ebp+var_14], ecx
.text$mn:0000C2EF                 mov     ecx, [ebp+var_14]
.text$mn:0000C2F2                 call    ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int>>::size(void)
.text$mn:0000C2F7                 cmp     [ebp+arg_0], eax
.text$mn:0000C2FA                 jnb     short loc_C315
.text$mn:0000C2FC                 mov     ecx, [ebp+var_14]
.text$mn:0000C2FF                 call    ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int>>::size(void)
.text$mn:0000C304                 sub     eax, [ebp+arg_0]
.text$mn:0000C307                 push    eax
.text$mn:0000C308                 mov     ecx, [ebp+var_14]
.text$mn:0000C30B                 call    ?_Pop_back_n@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z ; std::vector<int,std::allocator<int>>::_Pop_back_n(uint)
.text$mn:0000C310                 jmp     loc_C415
.text$mn:0000C315 ; ---------------------------------------------------------------------------
.text$mn:0000C315
.text$mn:0000C315 loc_C315:                               ; CODE XREF: std::vector<int,std::allocator<int>>::resize(uint,int const &)+3Aj
.text$mn:0000C315                 mov     ecx, [ebp+var_14]
.text$mn:0000C318                 call    ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int>>::size(void)
.text$mn:0000C31D                 cmp     eax, [ebp+arg_0]
.text$mn:0000C320                 jnb     loc_C415
.text$mn:0000C326                 mov     eax, [ebp+arg_4]
.text$mn:0000C329                 push    eax
.text$mn:0000C32A                 call    ??$addressof@$$CBH@std@@YAPBHABH@Z ; std::addressof<int const>(int const &)
.text$mn:0000C32F                 add     esp, 4
.text$mn:0000C332                 mov     [ebp+var_18], eax
.text$mn:0000C335                 mov     ecx, [ebp+var_18]
.text$mn:0000C338                 push    ecx
.text$mn:0000C339                 mov     ecx, [ebp+var_14]
.text$mn:0000C33C                 call    ?_Inside@?$vector@HV?$allocator@H@std@@@std@@IBE_NPBH@Z ; std::vector<int,std::allocator<int>>::_Inside(int const *)
.text$mn:0000C341                 movzx   edx, al
.text$mn:0000C344                 test    edx, edx
.text$mn:0000C346                 jz      short loc_C392
.text$mn:0000C348                 mov     eax, [ebp+var_14]
.text$mn:0000C34B                 mov     ecx, [eax+4]
.text$mn:0000C34E                 push    ecx
.text$mn:0000C34F                 call    ??$addressof@H@std@@YAPAHAAH@Z ; std::addressof<int>(int &)
.text$mn:0000C354                 add     esp, 4
.text$mn:0000C357                 mov     edx, [ebp+var_18]
.text$mn:0000C35A                 sub     edx, eax
.text$mn:0000C35C                 sar     edx, 2
.text$mn:0000C35F                 mov     [ebp+var_1C], edx
.text$mn:0000C362                 mov     ecx, [ebp+var_14]
.text$mn:0000C365                 call    ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int>>::size(void)
.text$mn:0000C36A                 mov     ecx, [ebp+arg_0]
.text$mn:0000C36D                 sub     ecx, eax
.text$mn:0000C36F                 push    ecx
.text$mn:0000C370                 mov     ecx, [ebp+var_14]
.text$mn:0000C373                 call    ?_Reserve@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z ; std::vector<int,std::allocator<int>>::_Reserve(uint)
.text$mn:0000C378                 mov     edx, [ebp+var_14]
.text$mn:0000C37B                 mov     eax, [edx+4]
.text$mn:0000C37E                 push    eax
.text$mn:0000C37F                 call    ??$addressof@H@std@@YAPAHAAH@Z ; std::addressof<int>(int &)
.text$mn:0000C384                 add     esp, 4
.text$mn:0000C387                 mov     ecx, [ebp+var_1C]
.text$mn:0000C38A                 lea     edx, [eax+ecx*4]
.text$mn:0000C38D                 mov     [ebp+var_18], edx
.text$mn:0000C390                 jmp     short loc_C3A8
.text$mn:0000C392 ; ---------------------------------------------------------------------------
.text$mn:0000C392
.text$mn:0000C392 loc_C392:                               ; CODE XREF: std::vector<int,std::allocator<int>>::resize(uint,int const &)+86j
.text$mn:0000C392                 mov     ecx, [ebp+var_14]
.text$mn:0000C395                 call    ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int>>::size(void)
.text$mn:0000C39A                 mov     ecx, [ebp+arg_0]
.text$mn:0000C39D                 sub     ecx, eax
.text$mn:0000C39F                 push    ecx
.text$mn:0000C3A0                 mov     ecx, [ebp+var_14]
.text$mn:0000C3A3                 call    ?_Reserve@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z ; std::vector<int,std::allocator<int>>::_Reserve(uint)
.text$mn:0000C3A8
.text$mn:0000C3A8 loc_C3A8:                               ; CODE XREF: std::vector<int,std::allocator<int>>::resize(uint,int const &)+D0j
.text$mn:0000C3A8                 mov     [ebp+var_4], 0
.text$mn:0000C3AF                 mov     edx, [ebp+var_18]
.text$mn:0000C3B2                 push    edx
.text$mn:0000C3B3                 mov     ecx, [ebp+var_14]
.text$mn:0000C3B6                 call    ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int>>::size(void)
.text$mn:0000C3BB                 mov     ecx, [ebp+arg_0]
.text$mn:0000C3BE                 sub     ecx, eax
.text$mn:0000C3C0                 push    ecx
.text$mn:0000C3C1                 mov     edx, [ebp+var_14]
.text$mn:0000C3C4                 mov     eax, [edx+8]
.text$mn:0000C3C7                 push    eax
.text$mn:0000C3C8                 mov     ecx, [ebp+var_14]
.text$mn:0000C3CB                 call    ?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIPBH@Z ; std::vector<int,std::allocator<int>>::_Ufill(int *,uint,int const *)
.text$mn:0000C3D0                 jmp     short loc_C3E9
.text$mn:0000C3D0 ?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXIABH@Z endp
.text$mn:0000C3D0
.text$mn:0000C3D2
.text$mn:0000C3D2 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C3D2
.text$mn:0000C3D2 ; Attributes: noreturn
.text$mn:0000C3D2
.text$mn:0000C3D2 __catch$?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXIABH@Z$0 proc near
.text$mn:0000C3D2                                         ; DATA XREF: .xdata$x:0000CF1Co
.text$mn:0000C3D2                 mov     ecx, [ebp-14h]
.text$mn:0000C3D5                 call    ?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ; std::vector<int,std::allocator<int>>::_Tidy(void)
.text$mn:0000C3DA                 push    0
.text$mn:0000C3DC                 push    0
.text$mn:0000C3DE                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:0000C3DE __catch$?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXIABH@Z$0 endp
.text$mn:0000C3DE
.text$mn:0000C3E3 ; ---------------------------------------------------------------------------
.text$mn:0000C3E3                 mov     eax, offset $LN12
.text$mn:0000C3E8                 retn
.text$mn:0000C3E9 ; ---------------------------------------------------------------------------
.text$mn:0000C3E9 ; START OF FUNCTION CHUNK FOR ?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXIABH@Z
.text$mn:0000C3E9
.text$mn:0000C3E9 loc_C3E9:                               ; CODE XREF: std::vector<int,std::allocator<int>>::resize(uint,int const &)+110j
.text$mn:0000C3E9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000C3F0                 jmp     short loc_C3F9
.text$mn:0000C3F0 ; END OF FUNCTION CHUNK FOR ?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXIABH@Z
.text$mn:0000C3F2
.text$mn:0000C3F2 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C3F2
.text$mn:0000C3F2
.text$mn:0000C3F2 $LN12           proc near               ; DATA XREF: .text$mn:0000C3E3o
.text$mn:0000C3F2                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:0000C3F2 $LN12           endp ; sp-analysis failed
.text$mn:0000C3F2
.text$mn:0000C3F9 ; START OF FUNCTION CHUNK FOR ?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXIABH@Z
.text$mn:0000C3F9
.text$mn:0000C3F9 loc_C3F9:                               ; CODE XREF: std::vector<int,std::allocator<int>>::resize(uint,int const &)+130j
.text$mn:0000C3F9                 mov     ecx, [ebp+var_14]
.text$mn:0000C3FC                 call    ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int>>::size(void)
.text$mn:0000C401                 mov     ecx, [ebp+arg_0]
.text$mn:0000C404                 sub     ecx, eax
.text$mn:0000C406                 mov     edx, [ebp+var_14]
.text$mn:0000C409                 mov     eax, [edx+8]
.text$mn:0000C40C                 lea     ecx, [eax+ecx*4]
.text$mn:0000C40F                 mov     edx, [ebp+var_14]
.text$mn:0000C412                 mov     [edx+8], ecx
.text$mn:0000C415
.text$mn:0000C415 loc_C415:                               ; CODE XREF: std::vector<int,std::allocator<int>>::resize(uint,int const &)+50j
.text$mn:0000C415                                         ; std::vector<int,std::allocator<int>>::resize(uint,int const &)+60j
.text$mn:0000C415                 mov     ecx, [ebp+var_C]
.text$mn:0000C418                 mov     large fs:0, ecx
.text$mn:0000C41F                 pop     ecx
.text$mn:0000C420                 pop     edi
.text$mn:0000C421                 pop     esi
.text$mn:0000C422                 pop     ebx
.text$mn:0000C423                 mov     esp, ebp
.text$mn:0000C425                 pop     ebp
.text$mn:0000C426                 retn    8
.text$mn:0000C426 ; END OF FUNCTION CHUNK FOR ?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXIABH@Z
.text$mn:0000C426 ; ---------------------------------------------------------------------------
.text$mn:0000C429                 align 4
.text$mn:0000C429 _text$mn        ends
.text$mn:0000C429
.text$x:0000C42C ; ===========================================================================
.text$x:0000C42C
.text$x:0000C42C ; Segment type: Pure code
.text$x:0000C42C ; Segment permissions: Read/Execute
.text$x:0000C42C _text$x         segment para public 'CODE' use32
.text$x:0000C42C                 assume cs:_text$x
.text$x:0000C42C                 ;org 0C42Ch
.text$x:0000C42C ; COMDAT (pick associative to section at C2C0)
.text$x:0000C42C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000C42C
.text$x:0000C42C ; =============== S U B R O U T I N E =======================================
.text$x:0000C42C
.text$x:0000C42C
.text$x:0000C42C __ehhandler$?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXIABH@Z proc near
.text$x:0000C42C                                         ; DATA XREF: std::vector<int,std::allocator<int>>::resize(uint,int const &)+5o
.text$x:0000C42C
.text$x:0000C42C arg_4           = dword ptr  8
.text$x:0000C42C
.text$x:0000C42C                 mov     edx, [esp+arg_4]
.text$x:0000C430                 lea     eax, [edx+0Ch]
.text$x:0000C433                 mov     ecx, [edx-20h]
.text$x:0000C436                 xor     ecx, eax
.text$x:0000C438                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000C43D                 mov     eax, offset __ehfuncinfo$?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXIABH@Z
.text$x:0000C442                 jmp     ___CxxFrameHandler3
.text$x:0000C442 __ehhandler$?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXIABH@Z endp
.text$x:0000C442
.text$x:0000C442 ; ---------------------------------------------------------------------------
.text$x:0000C447                 align 4
.text$x:0000C447 _text$x         ends
.text$x:0000C447
.text$mn:0000C448 ; ===========================================================================
.text$mn:0000C448
.text$mn:0000C448 ; Segment type: Pure code
.text$mn:0000C448 ; Segment permissions: Read/Execute
.text$mn:0000C448 _text$mn        segment para public 'CODE' use32
.text$mn:0000C448                 assume cs:_text$mn
.text$mn:0000C448                 ;org 0C448h
.text$mn:0000C448 ; COMDAT (pick any)
.text$mn:0000C448                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000C448
.text$mn:0000C448 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C448
.text$mn:0000C448 ; Attributes: bp-based frame
.text$mn:0000C448
.text$mn:0000C448 ; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::size(void)const
.text$mn:0000C448                 public ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
.text$mn:0000C448 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
.text$mn:0000C448                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+Cp
.text$mn:0000C448                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+21p
.text$mn:0000C448
.text$mn:0000C448 var_4           = dword ptr -4
.text$mn:0000C448
.text$mn:0000C448                 push    ebp
.text$mn:0000C449                 mov     ebp, esp
.text$mn:0000C44B                 push    ecx
.text$mn:0000C44C                 mov     [ebp+var_4], ecx
.text$mn:0000C44F                 mov     eax, [ebp+var_4]
.text$mn:0000C452                 mov     eax, [eax+14h]
.text$mn:0000C455                 mov     esp, ebp
.text$mn:0000C457                 pop     ebp
.text$mn:0000C458                 retn
.text$mn:0000C458 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp
.text$mn:0000C458
.text$mn:0000C458 ; ---------------------------------------------------------------------------
.text$mn:0000C459                 align 4
.text$mn:0000C459 _text$mn        ends
.text$mn:0000C459
.text$mn:0000C45C ; ===========================================================================
.text$mn:0000C45C
.text$mn:0000C45C ; Segment type: Pure code
.text$mn:0000C45C ; Segment permissions: Read/Execute
.text$mn:0000C45C _text$mn        segment para public 'CODE' use32
.text$mn:0000C45C                 assume cs:_text$mn
.text$mn:0000C45C                 ;org 0C45Ch
.text$mn:0000C45C ; COMDAT (pick any)
.text$mn:0000C45C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000C45C
.text$mn:0000C45C ; =============== S U B R O U T I N E =======================================
.text$mn:0000C45C
.text$mn:0000C45C ; Attributes: bp-based frame
.text$mn:0000C45C
.text$mn:0000C45C ; public: unsigned int __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::size(void)const
.text$mn:0000C45C                 public ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
.text$mn:0000C45C ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ proc near
.text$mn:0000C45C                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+Cp
.text$mn:0000C45C                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+21p ...
.text$mn:0000C45C
.text$mn:0000C45C var_4           = dword ptr -4
.text$mn:0000C45C
.text$mn:0000C45C                 push    ebp
.text$mn:0000C45D                 mov     ebp, esp
.text$mn:0000C45F                 push    ecx
.text$mn:0000C460                 mov     [ebp+var_4], ecx
.text$mn:0000C463                 mov     eax, [ebp+var_4]
.text$mn:0000C466                 mov     eax, [eax+14h]
.text$mn:0000C469                 mov     esp, ebp
.text$mn:0000C46B                 pop     ebp
.text$mn:0000C46C                 retn
.text$mn:0000C46C ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ endp
.text$mn:0000C46C
.text$mn:0000C46C ; ---------------------------------------------------------------------------
.text$mn:0000C46D                 align 10h
.text$mn:0000C46D _text$mn        ends
.text$mn:0000C46D
.text$mn:0000C470 ; ===========================================================================
.text$mn:0000C470
.text$mn:0000C470 ; Segment type: Pure code
.text$mn:0000C470 ; Segment permissions: Read/Execute
.text$mn:0000C470 _text$mn        segment para public 'CODE' use32
.text$mn:0000C470                 assume cs:_text$mn
.text$mn:0000C470                 ;org 0C470h
.text$mn:0000C470 ; COMDAT (pick any)
.text$mn:0000C470                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000C470
.text$mn:0000C470 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C470
.text$mn:0000C470 ; Attributes: bp-based frame
.text$mn:0000C470
.text$mn:0000C470 ; public: unsigned int __thiscall std::vector<int, class std::allocator<int>>::size(void)const
.text$mn:0000C470                 public ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
.text$mn:0000C470 ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ proc near
.text$mn:0000C470                                         ; CODE XREF: WindowsDlg::doRefresh(bool)+67p
.text$mn:0000C470                                         ; WindowsDlg::run_dlgProc(uint,uint,long)+1B4p ...
.text$mn:0000C470
.text$mn:0000C470 var_4           = dword ptr -4
.text$mn:0000C470
.text$mn:0000C470                 push    ebp
.text$mn:0000C471                 mov     ebp, esp
.text$mn:0000C473                 push    ecx
.text$mn:0000C474                 mov     [ebp+var_4], ecx
.text$mn:0000C477                 mov     eax, [ebp+var_4]
.text$mn:0000C47A                 mov     ecx, [ebp+var_4]
.text$mn:0000C47D                 mov     eax, [eax+8]
.text$mn:0000C480                 sub     eax, [ecx+4]
.text$mn:0000C483                 sar     eax, 2
.text$mn:0000C486                 mov     esp, ebp
.text$mn:0000C488                 pop     ebp
.text$mn:0000C489                 retn
.text$mn:0000C489 ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ endp
.text$mn:0000C489
.text$mn:0000C489 ; ---------------------------------------------------------------------------
.text$mn:0000C48A                 align 4
.text$mn:0000C48A _text$mn        ends
.text$mn:0000C48A
.text$mn:0000C48C ; ===========================================================================
.text$mn:0000C48C
.text$mn:0000C48C ; Segment type: Pure code
.text$mn:0000C48C ; Segment permissions: Read/Execute
.text$mn:0000C48C _text$mn        segment para public 'CODE' use32
.text$mn:0000C48C                 assume cs:_text$mn
.text$mn:0000C48C                 ;org 0C48Ch
.text$mn:0000C48C ; COMDAT (pick any)
.text$mn:0000C48C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000C48C
.text$mn:0000C48C ; =============== S U B R O U T I N E =======================================
.text$mn:0000C48C
.text$mn:0000C48C ; Attributes: bp-based frame
.text$mn:0000C48C
.text$mn:0000C48C ; public: unsigned int __thiscall std::vector<wchar_t, class std::allocator<wchar_t>>::size(void)const
.text$mn:0000C48C                 public ?size@?$vector@_WV?$allocator@_W@std@@@std@@QBEIXZ
.text$mn:0000C48C ?size@?$vector@_WV?$allocator@_W@std@@@std@@QBEIXZ proc near
.text$mn:0000C48C                                         ; CODE XREF: std::vector<wchar_t,std::allocator<wchar_t>>::operator[](uint)+Ap
.text$mn:0000C48C                                         ; std::vector<wchar_t,std::allocator<wchar_t>>::_Reallocate(uint)+A9p ...
.text$mn:0000C48C
.text$mn:0000C48C var_4           = dword ptr -4
.text$mn:0000C48C
.text$mn:0000C48C                 push    ebp
.text$mn:0000C48D                 mov     ebp, esp
.text$mn:0000C48F                 push    ecx
.text$mn:0000C490                 mov     [ebp+var_4], ecx
.text$mn:0000C493                 mov     eax, [ebp+var_4]
.text$mn:0000C496                 mov     ecx, [ebp+var_4]
.text$mn:0000C499                 mov     eax, [eax+8]
.text$mn:0000C49C                 sub     eax, [ecx+4]
.text$mn:0000C49F                 sar     eax, 1
.text$mn:0000C4A1                 mov     esp, ebp
.text$mn:0000C4A3                 pop     ebp
.text$mn:0000C4A4                 retn
.text$mn:0000C4A4 ?size@?$vector@_WV?$allocator@_W@std@@@std@@QBEIXZ endp
.text$mn:0000C4A4
.text$mn:0000C4A4 ; ---------------------------------------------------------------------------
.text$mn:0000C4A5                 align 4
.text$mn:0000C4A5 _text$mn        ends
.text$mn:0000C4A5
.text$mn:0000C4A8 ; ===========================================================================
.text$mn:0000C4A8
.text$mn:0000C4A8 ; Segment type: Pure code
.text$mn:0000C4A8 ; Segment permissions: Read/Execute
.text$mn:0000C4A8 _text$mn        segment para public 'CODE' use32
.text$mn:0000C4A8                 assume cs:_text$mn
.text$mn:0000C4A8                 ;org 0C4A8h
.text$mn:0000C4A8 ; COMDAT (pick any)
.text$mn:0000C4A8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000C4A8
.text$mn:0000C4A8 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C4A8
.text$mn:0000C4A8 ; Attributes: bp-based frame
.text$mn:0000C4A8
.text$mn:0000C4A8 ; const struct std::error_category *__cdecl std::system_category()
.text$mn:0000C4A8                 public ?system_category@std@@YAABVerror_category@1@XZ
.text$mn:0000C4A8 ?system_category@std@@YAABVerror_category@1@XZ proc near
.text$mn:0000C4A8                                         ; CODE XREF: std::_System_error_category::default_error_condition(int):loc_AF54p
.text$mn:0000C4A8                 push    ebp
.text$mn:0000C4A9                 mov     ebp, esp
.text$mn:0000C4AB                 mov     eax, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_System_error_category std::_Error_objects<int>::_System_object
.text$mn:0000C4B0                 pop     ebp
.text$mn:0000C4B1                 retn
.text$mn:0000C4B1 ?system_category@std@@YAABVerror_category@1@XZ endp
.text$mn:0000C4B1
.text$mn:0000C4B1 ; ---------------------------------------------------------------------------
.text$mn:0000C4B2                 align 4
.text$mn:0000C4B2 _text$mn        ends
.text$mn:0000C4B2
.text$mn:0000C4B4 ; ===========================================================================
.text$mn:0000C4B4
.text$mn:0000C4B4 ; Segment type: Pure code
.text$mn:0000C4B4 ; Segment permissions: Read/Execute
.text$mn:0000C4B4 _text$mn        segment para public 'CODE' use32
.text$mn:0000C4B4                 assume cs:_text$mn
.text$mn:0000C4B4                 ;org 0C4B4h
.text$mn:0000C4B4 ; COMDAT (pick any)
.text$mn:0000C4B4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000C4B4
.text$mn:0000C4B4 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C4B4
.text$mn:0000C4B4 ; Attributes: bp-based frame
.text$mn:0000C4B4
.text$mn:0000C4B4 ; int __thiscall std::error_code::value(std::error_code *__hidden this)
.text$mn:0000C4B4                 public ?value@error_code@std@@QBEHXZ
.text$mn:0000C4B4 ?value@error_code@std@@QBEHXZ proc near ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+24p
.text$mn:0000C4B4
.text$mn:0000C4B4 var_4           = dword ptr -4
.text$mn:0000C4B4
.text$mn:0000C4B4                 push    ebp
.text$mn:0000C4B5                 mov     ebp, esp
.text$mn:0000C4B7                 push    ecx
.text$mn:0000C4B8                 mov     [ebp+var_4], ecx
.text$mn:0000C4BB                 mov     eax, [ebp+var_4]
.text$mn:0000C4BE                 mov     eax, [eax]
.text$mn:0000C4C0                 mov     esp, ebp
.text$mn:0000C4C2                 pop     ebp
.text$mn:0000C4C3                 retn
.text$mn:0000C4C3 ?value@error_code@std@@QBEHXZ endp
.text$mn:0000C4C3
.text$mn:0000C4C3 _text$mn        ends
.text$mn:0000C4C3
.text$mn:0000C4C4 ; ===========================================================================
.text$mn:0000C4C4
.text$mn:0000C4C4 ; Segment type: Pure code
.text$mn:0000C4C4 ; Segment permissions: Read/Execute
.text$mn:0000C4C4 _text$mn        segment para public 'CODE' use32
.text$mn:0000C4C4                 assume cs:_text$mn
.text$mn:0000C4C4                 ;org 0C4C4h
.text$mn:0000C4C4 ; COMDAT (pick any)
.text$mn:0000C4C4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000C4C4
.text$mn:0000C4C4 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C4C4
.text$mn:0000C4C4 ; Attributes: bp-based frame
.text$mn:0000C4C4
.text$mn:0000C4C4 ; int __thiscall std::error_condition::value(std::error_condition *__hidden this)
.text$mn:0000C4C4                 public ?value@error_condition@std@@QBEHXZ
.text$mn:0000C4C4 ?value@error_condition@std@@QBEHXZ proc near
.text$mn:0000C4C4                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+2Cp
.text$mn:0000C4C4                                         ; std::error_condition::operator==(std::error_condition const &)+36p
.text$mn:0000C4C4
.text$mn:0000C4C4 var_4           = dword ptr -4
.text$mn:0000C4C4
.text$mn:0000C4C4                 push    ebp
.text$mn:0000C4C5                 mov     ebp, esp
.text$mn:0000C4C7                 push    ecx
.text$mn:0000C4C8                 mov     [ebp+var_4], ecx
.text$mn:0000C4CB                 mov     eax, [ebp+var_4]
.text$mn:0000C4CE                 mov     eax, [eax]
.text$mn:0000C4D0                 mov     esp, ebp
.text$mn:0000C4D2                 pop     ebp
.text$mn:0000C4D3                 retn
.text$mn:0000C4D3 ?value@error_condition@std@@QBEHXZ endp
.text$mn:0000C4D3
.text$mn:0000C4D3 _text$mn        ends
.text$mn:0000C4D3
.text$mn:0000C4D4 ; ===========================================================================
.text$mn:0000C4D4
.text$mn:0000C4D4 ; Segment type: Pure code
.text$mn:0000C4D4 ; Segment permissions: Read/Execute
.text$mn:0000C4D4 _text$mn        segment para public 'CODE' use32
.text$mn:0000C4D4                 assume cs:_text$mn
.text$mn:0000C4D4                 ;org 0C4D4h
.text$mn:0000C4D4 ; COMDAT (pick any)
.text$mn:0000C4D4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000C4D4
.text$mn:0000C4D4 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C4D4
.text$mn:0000C4D4 ; Attributes: bp-based frame
.text$mn:0000C4D4
.text$mn:0000C4D4                 public _hypot
.text$mn:0000C4D4 _hypot          proc near
.text$mn:0000C4D4
.text$mn:0000C4D4 var_10          = qword ptr -10h
.text$mn:0000C4D4 var_8           = qword ptr -8
.text$mn:0000C4D4 arg_0           = qword ptr  8
.text$mn:0000C4D4 arg_8           = qword ptr  10h
.text$mn:0000C4D4
.text$mn:0000C4D4                 push    ebp
.text$mn:0000C4D5                 mov     ebp, esp
.text$mn:0000C4D7                 sub     esp, 8
.text$mn:0000C4DA                 movsd   xmm0, [ebp+arg_8]
.text$mn:0000C4DF                 movsd   [esp+8+var_8], xmm0
.text$mn:0000C4E4                 sub     esp, 8
.text$mn:0000C4E7                 movsd   xmm0, [ebp+arg_0]
.text$mn:0000C4EC                 movsd   [esp+10h+var_10], xmm0
.text$mn:0000C4F1                 call    __hypot
.text$mn:0000C4F6                 add     esp, 10h
.text$mn:0000C4F9                 pop     ebp
.text$mn:0000C4FA                 retn
.text$mn:0000C4FA _hypot          endp
.text$mn:0000C4FA
.text$mn:0000C4FA ; ---------------------------------------------------------------------------
.text$mn:0000C4FB                 align 4
.text$mn:0000C4FB _text$mn        ends
.text$mn:0000C4FB
.text$mn:0000C4FC ; ===========================================================================
.text$mn:0000C4FC
.text$mn:0000C4FC ; Segment type: Pure code
.text$mn:0000C4FC ; Segment permissions: Read/Execute
.text$mn:0000C4FC _text$mn        segment para public 'CODE' use32
.text$mn:0000C4FC                 assume cs:_text$mn
.text$mn:0000C4FC                 ;org 0C4FCh
.text$mn:0000C4FC ; COMDAT (pick any)
.text$mn:0000C4FC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000C4FC
.text$mn:0000C4FC ; =============== S U B R O U T I N E =======================================
.text$mn:0000C4FC
.text$mn:0000C4FC ; Attributes: bp-based frame
.text$mn:0000C4FC
.text$mn:0000C4FC ; int __cdecl wmemcpy(void *Dst, void *Src, int)
.text$mn:0000C4FC                 public _wmemcpy
.text$mn:0000C4FC _wmemcpy        proc near               ; CODE XREF: std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)+1Ep
.text$mn:0000C4FC
.text$mn:0000C4FC Dst             = dword ptr  8
.text$mn:0000C4FC Src             = dword ptr  0Ch
.text$mn:0000C4FC arg_8           = dword ptr  10h
.text$mn:0000C4FC
.text$mn:0000C4FC                 push    ebp
.text$mn:0000C4FD                 mov     ebp, esp
.text$mn:0000C4FF                 mov     eax, [ebp+arg_8]
.text$mn:0000C502                 shl     eax, 1
.text$mn:0000C504                 push    eax             ; Size
.text$mn:0000C505                 mov     ecx, [ebp+Src]
.text$mn:0000C508                 push    ecx             ; Src
.text$mn:0000C509                 mov     edx, [ebp+Dst]
.text$mn:0000C50C                 push    edx             ; Dst
.text$mn:0000C50D                 call    _memcpy
.text$mn:0000C512                 add     esp, 0Ch
.text$mn:0000C515                 pop     ebp
.text$mn:0000C516                 retn
.text$mn:0000C516 _wmemcpy        endp
.text$mn:0000C516
.text$mn:0000C516 ; ---------------------------------------------------------------------------
.text$mn:0000C517                 align 4
.text$mn:0000C517 _text$mn        ends
.text$mn:0000C517
.text$mn:0000C518 ; ===========================================================================
.text$mn:0000C518
.text$mn:0000C518 ; Segment type: Pure code
.text$mn:0000C518 ; Segment permissions: Read/Execute
.text$mn:0000C518 _text$mn        segment para public 'CODE' use32
.text$mn:0000C518                 assume cs:_text$mn
.text$mn:0000C518                 ;org 0C518h
.text$mn:0000C518 ; COMDAT (pick any)
.text$mn:0000C518                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000C518
.text$mn:0000C518 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C518
.text$mn:0000C518 ; Attributes: bp-based frame
.text$mn:0000C518
.text$mn:0000C518 ; int __cdecl wmemmove(void *Dst, void *Src, int)
.text$mn:0000C518                 public _wmemmove
.text$mn:0000C518 _wmemmove       proc near               ; CODE XREF: std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)+1Ep
.text$mn:0000C518
.text$mn:0000C518 Dst             = dword ptr  8
.text$mn:0000C518 Src             = dword ptr  0Ch
.text$mn:0000C518 arg_8           = dword ptr  10h
.text$mn:0000C518
.text$mn:0000C518                 push    ebp
.text$mn:0000C519                 mov     ebp, esp
.text$mn:0000C51B                 mov     eax, [ebp+arg_8]
.text$mn:0000C51E                 shl     eax, 1
.text$mn:0000C520                 push    eax             ; Size
.text$mn:0000C521                 mov     ecx, [ebp+Src]
.text$mn:0000C524                 push    ecx             ; Src
.text$mn:0000C525                 mov     edx, [ebp+Dst]
.text$mn:0000C528                 push    edx             ; Dst
.text$mn:0000C529                 call    _memmove
.text$mn:0000C52E                 add     esp, 0Ch
.text$mn:0000C531                 pop     ebp
.text$mn:0000C532                 retn
.text$mn:0000C532 _wmemmove       endp
.text$mn:0000C532
.text$mn:0000C532 ; ---------------------------------------------------------------------------
.text$mn:0000C533                 align 4
.text$mn:0000C533 _text$mn        ends
.text$mn:0000C533
.xdata$x:0000C534 ; ===========================================================================
.xdata$x:0000C534
.xdata$x:0000C534 ; Segment type: Pure data
.xdata$x:0000C534 ; Segment permissions: Read
.xdata$x:0000C534 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000C534                 assume cs:_xdata$x
.xdata$x:0000C534                 ;org 0C534h
.xdata$x:0000C534 ; COMDAT (pick associative to section at 9AD0)
.xdata$x:0000C534 __unwindtable$?_Orphan_all@_Container_base12@std@@QAEXXZ db 0FFh
.xdata$x:0000C534                                         ; DATA XREF: .xdata$x:0000C544o
.xdata$x:0000C535                 db 0FFh
.xdata$x:0000C536                 db 0FFh
.xdata$x:0000C537                 db 0FFh
.xdata$x:0000C538                 dd offset __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0
.xdata$x:0000C53C __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ db  22h ; "
.xdata$x:0000C53C                                         ; DATA XREF: __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ+11o
.xdata$x:0000C53D                 db    5
.xdata$x:0000C53E                 db  93h ; 
.xdata$x:0000C53F                 db  19h
.xdata$x:0000C540                 db    1
.xdata$x:0000C541                 db    0
.xdata$x:0000C542                 db    0
.xdata$x:0000C543                 db    0
.xdata$x:0000C544                 dd offset __unwindtable$?_Orphan_all@_Container_base12@std@@QAEXXZ
.xdata$x:0000C548                 align 20h
.xdata$x:0000C548 _xdata$x        ends
.xdata$x:0000C548
.xdata$x:0000C560 ; ===========================================================================
.xdata$x:0000C560
.xdata$x:0000C560 ; Segment type: Pure data
.xdata$x:0000C560 ; Segment permissions: Read
.xdata$x:0000C560 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000C560                 assume cs:_xdata$x
.xdata$x:0000C560                 ;org 0C560h
.xdata$x:0000C560 ; COMDAT (pick associative to section at 7E80)
.xdata$x:0000C560 __unwindtable$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z db 0FFh
.xdata$x:0000C560                                         ; DATA XREF: .xdata$x:0000C570o
.xdata$x:0000C561                 db 0FFh
.xdata$x:0000C562                 db 0FFh
.xdata$x:0000C563                 db 0FFh
.xdata$x:0000C564                 dd offset __unwindfunclet$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z$0
.xdata$x:0000C568 __ehfuncinfo$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z db  22h ; "
.xdata$x:0000C568                                         ; DATA XREF: __ehhandler$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z+11o
.xdata$x:0000C569                 db    5
.xdata$x:0000C56A                 db  93h ; 
.xdata$x:0000C56B                 db  19h
.xdata$x:0000C56C                 db    1
.xdata$x:0000C56D                 db    0
.xdata$x:0000C56E                 db    0
.xdata$x:0000C56F                 db    0
.xdata$x:0000C570                 dd offset __unwindtable$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z
.xdata$x:0000C574                 db    0
.xdata$x:0000C575                 db    0
.xdata$x:0000C576                 db    0
.xdata$x:0000C577                 db    0
.xdata$x:0000C578                 db    0
.xdata$x:0000C579                 db    0
.xdata$x:0000C57A                 db    0
.xdata$x:0000C57B                 db    0
.xdata$x:0000C57C                 db    0
.xdata$x:0000C57D                 db    0
.xdata$x:0000C57E                 db    0
.xdata$x:0000C57F                 db    0
.xdata$x:0000C580                 db    0
.xdata$x:0000C581                 db    0
.xdata$x:0000C582                 db    0
.xdata$x:0000C583                 db    0
.xdata$x:0000C584                 db    0
.xdata$x:0000C585                 db    0
.xdata$x:0000C586                 db    0
.xdata$x:0000C587                 db    0
.xdata$x:0000C588                 db    0
.xdata$x:0000C589                 db    0
.xdata$x:0000C58A                 db    0
.xdata$x:0000C58B                 db    0
.xdata$x:0000C58B _xdata$x        ends
.xdata$x:0000C58B
.xdata$x:0000C58C ; ===========================================================================
.xdata$x:0000C58C
.xdata$x:0000C58C ; Segment type: Pure data
.xdata$x:0000C58C ; Segment permissions: Read
.xdata$x:0000C58C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000C58C                 assume cs:_xdata$x
.xdata$x:0000C58C                 ;org 0C58Ch
.xdata$x:0000C58C ; COMDAT (pick associative to section at 7C48)
.xdata$x:0000C58C __unwindtable$??1_Iterator_base12@std@@QAE@XZ db 0FFh
.xdata$x:0000C58C                                         ; DATA XREF: .xdata$x:0000C59Co
.xdata$x:0000C58D                 db 0FFh
.xdata$x:0000C58E                 db 0FFh
.xdata$x:0000C58F                 db 0FFh
.xdata$x:0000C590                 dd offset __unwindfunclet$??1_Iterator_base12@std@@QAE@XZ$0
.xdata$x:0000C594 __ehfuncinfo$??1_Iterator_base12@std@@QAE@XZ db  22h ; "
.xdata$x:0000C594                                         ; DATA XREF: __ehhandler$??1_Iterator_base12@std@@QAE@XZ+11o
.xdata$x:0000C595                 db    5
.xdata$x:0000C596                 db  93h ; 
.xdata$x:0000C597                 db  19h
.xdata$x:0000C598                 db    1
.xdata$x:0000C599                 db    0
.xdata$x:0000C59A                 db    0
.xdata$x:0000C59B                 db    0
.xdata$x:0000C59C                 dd offset __unwindtable$??1_Iterator_base12@std@@QAE@XZ
.xdata$x:0000C5A0                 db    0
.xdata$x:0000C5A1                 db    0
.xdata$x:0000C5A2                 db    0
.xdata$x:0000C5A3                 db    0
.xdata$x:0000C5A4                 db    0
.xdata$x:0000C5A5                 db    0
.xdata$x:0000C5A6                 db    0
.xdata$x:0000C5A7                 db    0
.xdata$x:0000C5A8                 db    0
.xdata$x:0000C5A9                 db    0
.xdata$x:0000C5AA                 db    0
.xdata$x:0000C5AB                 db    0
.xdata$x:0000C5AC                 db    0
.xdata$x:0000C5AD                 db    0
.xdata$x:0000C5AE                 db    0
.xdata$x:0000C5AF                 db    0
.xdata$x:0000C5B0                 db    0
.xdata$x:0000C5B1                 db    0
.xdata$x:0000C5B2                 db    0
.xdata$x:0000C5B3                 db    0
.xdata$x:0000C5B4                 db    0
.xdata$x:0000C5B5                 db    0
.xdata$x:0000C5B6                 db    0
.xdata$x:0000C5B7                 db    0
.xdata$x:0000C5B7 _xdata$x        ends
.xdata$x:0000C5B7
.xdata$x:0000C5B8 ; ===========================================================================
.xdata$x:0000C5B8
.xdata$x:0000C5B8 ; Segment type: Pure data
.xdata$x:0000C5B8 ; Segment permissions: Read
.xdata$x:0000C5B8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000C5B8                 assume cs:_xdata$x
.xdata$x:0000C5B8                 ;org 0C5B8h
.xdata$x:0000C5B8 ; COMDAT (pick associative to section at 8B80)
.xdata$x:0000C5B8 __unwindtable$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z db 0FFh
.xdata$x:0000C5B8                                         ; DATA XREF: .xdata$x:0000C5D0o
.xdata$x:0000C5B9                 db 0FFh
.xdata$x:0000C5BA                 db 0FFh
.xdata$x:0000C5BB                 db 0FFh
.xdata$x:0000C5BC                 dd offset __unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$0
.xdata$x:0000C5C0                 db 0FFh
.xdata$x:0000C5C1                 db 0FFh
.xdata$x:0000C5C2                 db 0FFh
.xdata$x:0000C5C3                 db 0FFh
.xdata$x:0000C5C4                 dd offset __unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$1
.xdata$x:0000C5C8 __ehfuncinfo$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z db  22h ; "
.xdata$x:0000C5C8                                         ; DATA XREF: __ehhandler$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z+11o
.xdata$x:0000C5C9                 db    5
.xdata$x:0000C5CA                 db  93h ; 
.xdata$x:0000C5CB                 db  19h
.xdata$x:0000C5CC                 db    2
.xdata$x:0000C5CD                 db    0
.xdata$x:0000C5CE                 db    0
.xdata$x:0000C5CF                 db    0
.xdata$x:0000C5D0                 dd offset __unwindtable$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
.xdata$x:0000C5D4                 db    0
.xdata$x:0000C5D5                 db    0
.xdata$x:0000C5D6                 db    0
.xdata$x:0000C5D7                 db    0
.xdata$x:0000C5D8                 db    0
.xdata$x:0000C5D9                 db    0
.xdata$x:0000C5DA                 db    0
.xdata$x:0000C5DB                 db    0
.xdata$x:0000C5DC                 db    0
.xdata$x:0000C5DD                 db    0
.xdata$x:0000C5DE                 db    0
.xdata$x:0000C5DF                 db    0
.xdata$x:0000C5E0                 db    0
.xdata$x:0000C5E1                 db    0
.xdata$x:0000C5E2                 db    0
.xdata$x:0000C5E3                 db    0
.xdata$x:0000C5E4                 db    0
.xdata$x:0000C5E5                 db    0
.xdata$x:0000C5E6                 db    0
.xdata$x:0000C5E7                 db    0
.xdata$x:0000C5E8                 db    0
.xdata$x:0000C5E9                 db    0
.xdata$x:0000C5EA                 db    0
.xdata$x:0000C5EB                 db    0
.xdata$x:0000C5EB _xdata$x        ends
.xdata$x:0000C5EB
.xdata$x:0000C5EC ; ===========================================================================
.xdata$x:0000C5EC
.xdata$x:0000C5EC ; Segment type: Pure data
.xdata$x:0000C5EC ; Segment permissions: Read
.xdata$x:0000C5EC _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000C5EC                 assume cs:_xdata$x
.xdata$x:0000C5EC                 ;org 0C5ECh
.xdata$x:0000C5EC ; COMDAT (pick associative to section at 7A14)
.xdata$x:0000C5EC __unwindtable$??1StaticDialog@@UAE@XZ db 0FFh
.xdata$x:0000C5EC                                         ; DATA XREF: .xdata$x:0000C5FCo
.xdata$x:0000C5ED                 db 0FFh
.xdata$x:0000C5EE                 db 0FFh
.xdata$x:0000C5EF                 db 0FFh
.xdata$x:0000C5F0                 dd offset __unwindfunclet$??1StaticDialog@@UAE@XZ$0
.xdata$x:0000C5F4 __ehfuncinfo$??1StaticDialog@@UAE@XZ db  22h ; "
.xdata$x:0000C5F4                                         ; DATA XREF: __ehhandler$??1StaticDialog@@UAE@XZ+11o
.xdata$x:0000C5F5                 db    5
.xdata$x:0000C5F6                 db  93h ; 
.xdata$x:0000C5F7                 db  19h
.xdata$x:0000C5F8                 db    1
.xdata$x:0000C5F9                 db    0
.xdata$x:0000C5FA                 db    0
.xdata$x:0000C5FB                 db    0
.xdata$x:0000C5FC                 dd offset __unwindtable$??1StaticDialog@@UAE@XZ
.xdata$x:0000C600                 db    0
.xdata$x:0000C601                 db    0
.xdata$x:0000C602                 db    0
.xdata$x:0000C603                 db    0
.xdata$x:0000C604                 db    0
.xdata$x:0000C605                 db    0
.xdata$x:0000C606                 db    0
.xdata$x:0000C607                 db    0
.xdata$x:0000C608                 db    0
.xdata$x:0000C609                 db    0
.xdata$x:0000C60A                 db    0
.xdata$x:0000C60B                 db    0
.xdata$x:0000C60C                 db    0
.xdata$x:0000C60D                 db    0
.xdata$x:0000C60E                 db    0
.xdata$x:0000C60F                 db    0
.xdata$x:0000C610                 db    0
.xdata$x:0000C611                 db    0
.xdata$x:0000C612                 db    0
.xdata$x:0000C613                 db    0
.xdata$x:0000C614                 db    0
.xdata$x:0000C615                 db    0
.xdata$x:0000C616                 db    0
.xdata$x:0000C617                 db    0
.xdata$x:0000C617 _xdata$x        ends
.xdata$x:0000C617
.xdata$x:0000C618 ; ===========================================================================
.xdata$x:0000C618
.xdata$x:0000C618 ; Segment type: Pure data
.xdata$x:0000C618 ; Segment permissions: Read
.xdata$x:0000C618 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000C618                 assume cs:_xdata$x
.xdata$x:0000C618                 ;org 0C618h
.xdata$x:0000C618 ; COMDAT (pick associative to section at 7988)
.xdata$x:0000C618 __unwindtable$??1SizeableDlg@@UAE@XZ db 0FFh
.xdata$x:0000C618                                         ; DATA XREF: .xdata$x:0000C630o
.xdata$x:0000C619                 db 0FFh
.xdata$x:0000C61A                 db 0FFh
.xdata$x:0000C61B                 db 0FFh
.xdata$x:0000C61C                 dd offset __unwindfunclet$??1SizeableDlg@@UAE@XZ$0
.xdata$x:0000C620                 db    0
.xdata$x:0000C621                 db    0
.xdata$x:0000C622                 db    0
.xdata$x:0000C623                 db    0
.xdata$x:0000C624                 dd offset __unwindfunclet$??1SizeableDlg@@UAE@XZ$1
.xdata$x:0000C628 __ehfuncinfo$??1SizeableDlg@@UAE@XZ db  22h ; "
.xdata$x:0000C628                                         ; DATA XREF: __ehhandler$??1SizeableDlg@@UAE@XZ+11o
.xdata$x:0000C629                 db    5
.xdata$x:0000C62A                 db  93h ; 
.xdata$x:0000C62B                 db  19h
.xdata$x:0000C62C                 db    2
.xdata$x:0000C62D                 db    0
.xdata$x:0000C62E                 db    0
.xdata$x:0000C62F                 db    0
.xdata$x:0000C630                 dd offset __unwindtable$??1SizeableDlg@@UAE@XZ
.xdata$x:0000C634                 db    0
.xdata$x:0000C635                 db    0
.xdata$x:0000C636                 db    0
.xdata$x:0000C637                 db    0
.xdata$x:0000C638                 db    0
.xdata$x:0000C639                 db    0
.xdata$x:0000C63A                 db    0
.xdata$x:0000C63B                 db    0
.xdata$x:0000C63C                 db    0
.xdata$x:0000C63D                 db    0
.xdata$x:0000C63E                 db    0
.xdata$x:0000C63F                 db    0
.xdata$x:0000C640                 db    0
.xdata$x:0000C641                 db    0
.xdata$x:0000C642                 db    0
.xdata$x:0000C643                 db    0
.xdata$x:0000C644                 db    0
.xdata$x:0000C645                 db    0
.xdata$x:0000C646                 db    0
.xdata$x:0000C647                 db    0
.xdata$x:0000C648                 db    0
.xdata$x:0000C649                 db    0
.xdata$x:0000C64A                 db    0
.xdata$x:0000C64B                 db    0
.xdata$x:0000C64B _xdata$x        ends
.xdata$x:0000C64B
.xdata$x:0000C64C ; ===========================================================================
.xdata$x:0000C64C
.xdata$x:0000C64C ; Segment type: Pure data
.xdata$x:0000C64C ; Segment permissions: Read
.xdata$x:0000C64C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000C64C                 assume cs:_xdata$x
.xdata$x:0000C64C                 ;org 0C64Ch
.xdata$x:0000C64C ; COMDAT (pick associative to section at 6640)
.xdata$x:0000C64C __unwindtable$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000C64C                                         ; DATA XREF: .xdata$x:0000C65Co
.xdata$x:0000C64D                 db 0FFh
.xdata$x:0000C64E                 db 0FFh
.xdata$x:0000C64F                 db 0FFh
.xdata$x:0000C650                 dd offset __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
.xdata$x:0000C654 __ehfuncinfo$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000C654                                         ; DATA XREF: __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ+11o
.xdata$x:0000C655                 db    5
.xdata$x:0000C656                 db  93h ; 
.xdata$x:0000C657                 db  19h
.xdata$x:0000C658                 db    1
.xdata$x:0000C659                 db    0
.xdata$x:0000C65A                 db    0
.xdata$x:0000C65B                 db    0
.xdata$x:0000C65C                 dd offset __unwindtable$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.xdata$x:0000C660                 db    0
.xdata$x:0000C661                 db    0
.xdata$x:0000C662                 db    0
.xdata$x:0000C663                 db    0
.xdata$x:0000C664                 db    0
.xdata$x:0000C665                 db    0
.xdata$x:0000C666                 db    0
.xdata$x:0000C667                 db    0
.xdata$x:0000C668                 db    0
.xdata$x:0000C669                 db    0
.xdata$x:0000C66A                 db    0
.xdata$x:0000C66B                 db    0
.xdata$x:0000C66C                 db    0
.xdata$x:0000C66D                 db    0
.xdata$x:0000C66E                 db    0
.xdata$x:0000C66F                 db    0
.xdata$x:0000C670                 db    0
.xdata$x:0000C671                 db    0
.xdata$x:0000C672                 db    0
.xdata$x:0000C673                 db    0
.xdata$x:0000C674                 db    0
.xdata$x:0000C675                 db    0
.xdata$x:0000C676                 db    0
.xdata$x:0000C677                 db    0
.xdata$x:0000C677 _xdata$x        ends
.xdata$x:0000C677
.xdata$x:0000C678 ; ===========================================================================
.xdata$x:0000C678
.xdata$x:0000C678 ; Segment type: Pure data
.xdata$x:0000C678 ; Segment permissions: Read
.xdata$x:0000C678 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000C678                 assume cs:_xdata$x
.xdata$x:0000C678                 ;org 0C678h
.xdata$x:0000C678 ; COMDAT (pick associative to section at 73C0)
.xdata$x:0000C678 __unwindtable$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000C678                                         ; DATA XREF: .xdata$x:0000C688o
.xdata$x:0000C679                 db 0FFh
.xdata$x:0000C67A                 db 0FFh
.xdata$x:0000C67B                 db 0FFh
.xdata$x:0000C67C                 dd offset __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
.xdata$x:0000C680 __ehfuncinfo$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000C680                                         ; DATA XREF: __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ+11o
.xdata$x:0000C681                 db    5
.xdata$x:0000C682                 db  93h ; 
.xdata$x:0000C683                 db  19h
.xdata$x:0000C684                 db    1
.xdata$x:0000C685                 db    0
.xdata$x:0000C686                 db    0
.xdata$x:0000C687                 db    0
.xdata$x:0000C688                 dd offset __unwindtable$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.xdata$x:0000C68C                 db    0
.xdata$x:0000C68D                 db    0
.xdata$x:0000C68E                 db    0
.xdata$x:0000C68F                 db    0
.xdata$x:0000C690                 db    0
.xdata$x:0000C691                 db    0
.xdata$x:0000C692                 db    0
.xdata$x:0000C693                 db    0
.xdata$x:0000C694                 db    0
.xdata$x:0000C695                 db    0
.xdata$x:0000C696                 db    0
.xdata$x:0000C697                 db    0
.xdata$x:0000C698                 db    0
.xdata$x:0000C699                 db    0
.xdata$x:0000C69A                 db    0
.xdata$x:0000C69B                 db    0
.xdata$x:0000C69C                 db    0
.xdata$x:0000C69D                 db    0
.xdata$x:0000C69E                 db    0
.xdata$x:0000C69F                 db    0
.xdata$x:0000C6A0                 db    0
.xdata$x:0000C6A1                 db    0
.xdata$x:0000C6A2                 db    0
.xdata$x:0000C6A3                 db    0
.xdata$x:0000C6A3 _xdata$x        ends
.xdata$x:0000C6A3
.xdata$x:0000C6A4 ; ===========================================================================
.xdata$x:0000C6A4
.xdata$x:0000C6A4 ; Segment type: Pure data
.xdata$x:0000C6A4 ; Segment permissions: Read
.xdata$x:0000C6A4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000C6A4                 assume cs:_xdata$x
.xdata$x:0000C6A4                 ;org 0C6A4h
.xdata$x:0000C6A4 ; COMDAT (pick associative to section at 6344)
.xdata$x:0000C6A4 __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z db 0FFh
.xdata$x:0000C6A4                                         ; DATA XREF: .xdata$x:0000C6B4o
.xdata$x:0000C6A5                 db 0FFh
.xdata$x:0000C6A6                 db 0FFh
.xdata$x:0000C6A7                 db 0FFh
.xdata$x:0000C6A8                 dd offset __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0
.xdata$x:0000C6AC __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z db  22h ; "
.xdata$x:0000C6AC                                         ; DATA XREF: __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z+11o
.xdata$x:0000C6AD                 db    5
.xdata$x:0000C6AE                 db  93h ; 
.xdata$x:0000C6AF                 db  19h
.xdata$x:0000C6B0                 db    1
.xdata$x:0000C6B1                 db    0
.xdata$x:0000C6B2                 db    0
.xdata$x:0000C6B3                 db    0
.xdata$x:0000C6B4                 dd offset __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.xdata$x:0000C6B8                 db    0
.xdata$x:0000C6B9                 db    0
.xdata$x:0000C6BA                 db    0
.xdata$x:0000C6BB                 db    0
.xdata$x:0000C6BC                 db    0
.xdata$x:0000C6BD                 db    0
.xdata$x:0000C6BE                 db    0
.xdata$x:0000C6BF                 db    0
.xdata$x:0000C6C0                 db    0
.xdata$x:0000C6C1                 db    0
.xdata$x:0000C6C2                 db    0
.xdata$x:0000C6C3                 db    0
.xdata$x:0000C6C4                 db    0
.xdata$x:0000C6C5                 db    0
.xdata$x:0000C6C6                 db    0
.xdata$x:0000C6C7                 db    0
.xdata$x:0000C6C8                 db    0
.xdata$x:0000C6C9                 db    0
.xdata$x:0000C6CA                 db    0
.xdata$x:0000C6CB                 db    0
.xdata$x:0000C6CC                 db    0
.xdata$x:0000C6CD                 db    0
.xdata$x:0000C6CE                 db    0
.xdata$x:0000C6CF                 db    0
.xdata$x:0000C6CF _xdata$x        ends
.xdata$x:0000C6CF
.xdata$x:0000C6D0 ; ===========================================================================
.xdata$x:0000C6D0
.xdata$x:0000C6D0 ; Segment type: Pure data
.xdata$x:0000C6D0 ; Segment permissions: Read
.xdata$x:0000C6D0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000C6D0                 assume cs:_xdata$x
.xdata$x:0000C6D0                 ;org 0C6D0h
.xdata$x:0000C6D0 ; COMDAT (pick associative to section at 71F0)
.xdata$x:0000C6D0 __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000C6D0                                         ; DATA XREF: .xdata$x:0000C6E0o
.xdata$x:0000C6D1                 db 0FFh
.xdata$x:0000C6D2                 db 0FFh
.xdata$x:0000C6D3                 db 0FFh
.xdata$x:0000C6D4                 dd offset __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0
.xdata$x:0000C6D8 __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000C6D8                                         ; DATA XREF: __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:0000C6D9                 db    5
.xdata$x:0000C6DA                 db  93h ; 
.xdata$x:0000C6DB                 db  19h
.xdata$x:0000C6DC                 db    1
.xdata$x:0000C6DD                 db    0
.xdata$x:0000C6DE                 db    0
.xdata$x:0000C6DF                 db    0
.xdata$x:0000C6E0                 dd offset __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.xdata$x:0000C6E4                 db    0
.xdata$x:0000C6E5                 db    0
.xdata$x:0000C6E6                 db    0
.xdata$x:0000C6E7                 db    0
.xdata$x:0000C6E8                 db    0
.xdata$x:0000C6E9                 db    0
.xdata$x:0000C6EA                 db    0
.xdata$x:0000C6EB                 db    0
.xdata$x:0000C6EC                 db    0
.xdata$x:0000C6ED                 db    0
.xdata$x:0000C6EE                 db    0
.xdata$x:0000C6EF                 db    0
.xdata$x:0000C6F0                 db    0
.xdata$x:0000C6F1                 db    0
.xdata$x:0000C6F2                 db    0
.xdata$x:0000C6F3                 db    0
.xdata$x:0000C6F4                 db    0
.xdata$x:0000C6F5                 db    0
.xdata$x:0000C6F6                 db    0
.xdata$x:0000C6F7                 db    0
.xdata$x:0000C6F8                 db    0
.xdata$x:0000C6F9                 db    0
.xdata$x:0000C6FA                 db    0
.xdata$x:0000C6FB                 db    0
.xdata$x:0000C6FB _xdata$x        ends
.xdata$x:0000C6FB
.xdata$x:0000C6FC ; ===========================================================================
.xdata$x:0000C6FC
.xdata$x:0000C6FC ; Segment type: Pure data
.xdata$x:0000C6FC ; Segment permissions: Read
.xdata$x:0000C6FC _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000C6FC                 assume cs:_xdata$x
.xdata$x:0000C6FC                 ;org 0C6FCh
.xdata$x:0000C6FC ; COMDAT (pick associative to section at 6C90)
.xdata$x:0000C6FC __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z db 0FFh
.xdata$x:0000C6FC                                         ; DATA XREF: .xdata$x:0000C70Co
.xdata$x:0000C6FD                 db 0FFh
.xdata$x:0000C6FE                 db 0FFh
.xdata$x:0000C6FF                 db 0FFh
.xdata$x:0000C700                 dd offset __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0
.xdata$x:0000C704 __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z db  22h ; "
.xdata$x:0000C704                                         ; DATA XREF: __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z+11o
.xdata$x:0000C705                 db    5
.xdata$x:0000C706                 db  93h ; 
.xdata$x:0000C707                 db  19h
.xdata$x:0000C708                 db    1
.xdata$x:0000C709                 db    0
.xdata$x:0000C70A                 db    0
.xdata$x:0000C70B                 db    0
.xdata$x:0000C70C                 dd offset __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.xdata$x:0000C710                 db    0
.xdata$x:0000C711                 db    0
.xdata$x:0000C712                 db    0
.xdata$x:0000C713                 db    0
.xdata$x:0000C714                 db    0
.xdata$x:0000C715                 db    0
.xdata$x:0000C716                 db    0
.xdata$x:0000C717                 db    0
.xdata$x:0000C718                 db    0
.xdata$x:0000C719                 db    0
.xdata$x:0000C71A                 db    0
.xdata$x:0000C71B                 db    0
.xdata$x:0000C71C                 db    0
.xdata$x:0000C71D                 db    0
.xdata$x:0000C71E                 db    0
.xdata$x:0000C71F                 db    0
.xdata$x:0000C720                 db    0
.xdata$x:0000C721                 db    0
.xdata$x:0000C722                 db    0
.xdata$x:0000C723                 db    0
.xdata$x:0000C724                 db    0
.xdata$x:0000C725                 db    0
.xdata$x:0000C726                 db    0
.xdata$x:0000C727                 db    0
.xdata$x:0000C727 _xdata$x        ends
.xdata$x:0000C727
.xdata$x:0000C728 ; ===========================================================================
.xdata$x:0000C728
.xdata$x:0000C728 ; Segment type: Pure data
.xdata$x:0000C728 ; Segment permissions: Read
.xdata$x:0000C728 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000C728                 assume cs:_xdata$x
.xdata$x:0000C728                 ;org 0C728h
.xdata$x:0000C728 ; COMDAT (pick associative to section at 77A0)
.xdata$x:0000C728 __unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db 0FFh
.xdata$x:0000C728                                         ; DATA XREF: .xdata$x:0000C738o
.xdata$x:0000C729                 db 0FFh
.xdata$x:0000C72A                 db 0FFh
.xdata$x:0000C72B                 db 0FFh
.xdata$x:0000C72C                 dd offset __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0
.xdata$x:0000C730 __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db  22h ; "
.xdata$x:0000C730                                         ; DATA XREF: __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ+11o
.xdata$x:0000C731                 db    5
.xdata$x:0000C732                 db  93h ; 
.xdata$x:0000C733                 db  19h
.xdata$x:0000C734                 db    1
.xdata$x:0000C735                 db    0
.xdata$x:0000C736                 db    0
.xdata$x:0000C737                 db    0
.xdata$x:0000C738                 dd offset __unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.xdata$x:0000C73C                 db    0
.xdata$x:0000C73D                 db    0
.xdata$x:0000C73E                 db    0
.xdata$x:0000C73F                 db    0
.xdata$x:0000C740                 db    0
.xdata$x:0000C741                 db    0
.xdata$x:0000C742                 db    0
.xdata$x:0000C743                 db    0
.xdata$x:0000C744                 db    0
.xdata$x:0000C745                 db    0
.xdata$x:0000C746                 db    0
.xdata$x:0000C747                 db    0
.xdata$x:0000C748                 db    0
.xdata$x:0000C749                 db    0
.xdata$x:0000C74A                 db    0
.xdata$x:0000C74B                 db    0
.xdata$x:0000C74C                 db    0
.xdata$x:0000C74D                 db    0
.xdata$x:0000C74E                 db    0
.xdata$x:0000C74F                 db    0
.xdata$x:0000C750                 db    0
.xdata$x:0000C751                 db    0
.xdata$x:0000C752                 db    0
.xdata$x:0000C753                 db    0
.xdata$x:0000C753 _xdata$x        ends
.xdata$x:0000C753
.xdata$x:0000C754 ; ===========================================================================
.xdata$x:0000C754
.xdata$x:0000C754 ; Segment type: Pure data
.xdata$x:0000C754 ; Segment permissions: Read
.xdata$x:0000C754 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000C754                 assume cs:_xdata$x
.xdata$x:0000C754                 ;org 0C754h
.xdata$x:0000C754 ; COMDAT (pick associative to section at 8F68)
.xdata$x:0000C754 __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 db    0
.xdata$x:0000C754                                         ; DATA XREF: .xdata$x:0000C7DCo
.xdata$x:0000C755                 db    0
.xdata$x:0000C756                 db    0
.xdata$x:0000C757                 db    0
.xdata$x:0000C758                 db    0
.xdata$x:0000C759                 db    0
.xdata$x:0000C75A                 db    0
.xdata$x:0000C75B                 db    0
.xdata$x:0000C75C                 db    0
.xdata$x:0000C75D                 db    0
.xdata$x:0000C75E                 db    0
.xdata$x:0000C75F                 db    0
.xdata$x:0000C760                 dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.xdata$x:0000C764 __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 db    0
.xdata$x:0000C764                                         ; DATA XREF: .xdata$x:0000C7C8o
.xdata$x:0000C765                 db    0
.xdata$x:0000C766                 db    0
.xdata$x:0000C767                 db    0
.xdata$x:0000C768                 db    0
.xdata$x:0000C769                 db    0
.xdata$x:0000C76A                 db    0
.xdata$x:0000C76B                 db    0
.xdata$x:0000C76C                 db    0
.xdata$x:0000C76D                 db    0
.xdata$x:0000C76E                 db    0
.xdata$x:0000C76F                 db    0
.xdata$x:0000C770                 dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
.xdata$x:0000C774 __unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db 0FFh
.xdata$x:0000C774                                         ; DATA XREF: .xdata$x:0000C79Co
.xdata$x:0000C775                 db 0FFh
.xdata$x:0000C776                 db 0FFh
.xdata$x:0000C777                 db 0FFh
.xdata$x:0000C778                 db    0
.xdata$x:0000C779                 db    0
.xdata$x:0000C77A                 db    0
.xdata$x:0000C77B                 db    0
.xdata$x:0000C77C                 db 0FFh
.xdata$x:0000C77D                 db 0FFh
.xdata$x:0000C77E                 db 0FFh
.xdata$x:0000C77F                 db 0FFh
.xdata$x:0000C780                 db    0
.xdata$x:0000C781                 db    0
.xdata$x:0000C782                 db    0
.xdata$x:0000C783                 db    0
.xdata$x:0000C784                 db    1
.xdata$x:0000C785                 db    0
.xdata$x:0000C786                 db    0
.xdata$x:0000C787                 db    0
.xdata$x:0000C788                 db    0
.xdata$x:0000C789                 db    0
.xdata$x:0000C78A                 db    0
.xdata$x:0000C78B                 db    0
.xdata$x:0000C78C                 db    1
.xdata$x:0000C78D                 db    0
.xdata$x:0000C78E                 db    0
.xdata$x:0000C78F                 db    0
.xdata$x:0000C790                 db    0
.xdata$x:0000C791                 db    0
.xdata$x:0000C792                 db    0
.xdata$x:0000C793                 db    0
.xdata$x:0000C794 __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db  22h ; "
.xdata$x:0000C794                                         ; DATA XREF: __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z+11o
.xdata$x:0000C795                 db    5
.xdata$x:0000C796                 db  93h ; 
.xdata$x:0000C797                 db  19h
.xdata$x:0000C798                 db    4
.xdata$x:0000C799                 db    0
.xdata$x:0000C79A                 db    0
.xdata$x:0000C79B                 db    0
.xdata$x:0000C79C                 dd offset __unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.xdata$x:0000C7A0                 db    2
.xdata$x:0000C7A1                 db    0
.xdata$x:0000C7A2                 db    0
.xdata$x:0000C7A3                 db    0
.xdata$x:0000C7A4                 dd offset __tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.xdata$x:0000C7A8                 db    0
.xdata$x:0000C7A9                 db    0
.xdata$x:0000C7AA                 db    0
.xdata$x:0000C7AB                 db    0
.xdata$x:0000C7AC                 db    0
.xdata$x:0000C7AD                 db    0
.xdata$x:0000C7AE                 db    0
.xdata$x:0000C7AF                 db    0
.xdata$x:0000C7B0                 db    0
.xdata$x:0000C7B1                 db    0
.xdata$x:0000C7B2                 db    0
.xdata$x:0000C7B3                 db    0
.xdata$x:0000C7B4                 db    0
.xdata$x:0000C7B5                 db    0
.xdata$x:0000C7B6                 db    0
.xdata$x:0000C7B7                 db    0
.xdata$x:0000C7B8 __tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db    2
.xdata$x:0000C7B8                                         ; DATA XREF: .xdata$x:0000C7A4o
.xdata$x:0000C7B9                 db    0
.xdata$x:0000C7BA                 db    0
.xdata$x:0000C7BB                 db    0
.xdata$x:0000C7BC                 db    2
.xdata$x:0000C7BD                 db    0
.xdata$x:0000C7BE                 db    0
.xdata$x:0000C7BF                 db    0
.xdata$x:0000C7C0                 db    3
.xdata$x:0000C7C1                 db    0
.xdata$x:0000C7C2                 db    0
.xdata$x:0000C7C3                 db    0
.xdata$x:0000C7C4                 db    1
.xdata$x:0000C7C5                 db    0
.xdata$x:0000C7C6                 db    0
.xdata$x:0000C7C7                 db    0
.xdata$x:0000C7C8                 dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
.xdata$x:0000C7CC                 db    0
.xdata$x:0000C7CD                 db    0
.xdata$x:0000C7CE                 db    0
.xdata$x:0000C7CF                 db    0
.xdata$x:0000C7D0                 db    0
.xdata$x:0000C7D1                 db    0
.xdata$x:0000C7D2                 db    0
.xdata$x:0000C7D3                 db    0
.xdata$x:0000C7D4                 db    3
.xdata$x:0000C7D5                 db    0
.xdata$x:0000C7D6                 db    0
.xdata$x:0000C7D7                 db    0
.xdata$x:0000C7D8                 db    1
.xdata$x:0000C7D9                 db    0
.xdata$x:0000C7DA                 db    0
.xdata$x:0000C7DB                 db    0
.xdata$x:0000C7DC                 dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
.xdata$x:0000C7DC _xdata$x        ends
.xdata$x:0000C7DC
.xdata$x:0000C7E0 ; ===========================================================================
.xdata$x:0000C7E0
.xdata$x:0000C7E0 ; Segment type: Pure data
.xdata$x:0000C7E0 ; Segment permissions: Read
.xdata$x:0000C7E0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000C7E0                 assume cs:_xdata$x
.xdata$x:0000C7E0                 ;org 0C7E0h
.xdata$x:0000C7E0 ; COMDAT (pick associative to section at 6EE4)
.xdata$x:0000C7E0 __unwindtable$??0_Generic_error_category@std@@QAE@XZ db 0FFh
.xdata$x:0000C7E0                                         ; DATA XREF: .xdata$x:0000C7F0o
.xdata$x:0000C7E1                 db 0FFh
.xdata$x:0000C7E2                 db 0FFh
.xdata$x:0000C7E3                 db 0FFh
.xdata$x:0000C7E4                 dd offset __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0
.xdata$x:0000C7E8 __ehfuncinfo$??0_Generic_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:0000C7E8                                         ; DATA XREF: __ehhandler$??0_Generic_error_category@std@@QAE@XZ+11o
.xdata$x:0000C7E9                 db    5
.xdata$x:0000C7EA                 db  93h ; 
.xdata$x:0000C7EB                 db  19h
.xdata$x:0000C7EC                 db    1
.xdata$x:0000C7ED                 db    0
.xdata$x:0000C7EE                 db    0
.xdata$x:0000C7EF                 db    0
.xdata$x:0000C7F0                 dd offset __unwindtable$??0_Generic_error_category@std@@QAE@XZ
.xdata$x:0000C7F4                 db    0
.xdata$x:0000C7F5                 db    0
.xdata$x:0000C7F6                 db    0
.xdata$x:0000C7F7                 db    0
.xdata$x:0000C7F8                 db    0
.xdata$x:0000C7F9                 db    0
.xdata$x:0000C7FA                 db    0
.xdata$x:0000C7FB                 db    0
.xdata$x:0000C7FC                 db    0
.xdata$x:0000C7FD                 db    0
.xdata$x:0000C7FE                 db    0
.xdata$x:0000C7FF                 db    0
.xdata$x:0000C800                 db    0
.xdata$x:0000C801                 db    0
.xdata$x:0000C802                 db    0
.xdata$x:0000C803                 db    0
.xdata$x:0000C804                 db    0
.xdata$x:0000C805                 db    0
.xdata$x:0000C806                 db    0
.xdata$x:0000C807                 db    0
.xdata$x:0000C808                 db    0
.xdata$x:0000C809                 db    0
.xdata$x:0000C80A                 db    0
.xdata$x:0000C80B                 db    0
.xdata$x:0000C80B _xdata$x        ends
.xdata$x:0000C80B
.xdata$x:0000C80C ; ===========================================================================
.xdata$x:0000C80C
.xdata$x:0000C80C ; Segment type: Pure data
.xdata$x:0000C80C ; Segment permissions: Read
.xdata$x:0000C80C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000C80C                 assume cs:_xdata$x
.xdata$x:0000C80C                 ;org 0C80Ch
.xdata$x:0000C80C ; COMDAT (pick associative to section at BB24)
.xdata$x:0000C80C __unwindtable$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:0000C80C                                         ; DATA XREF: .xdata$x:0000C81Co
.xdata$x:0000C80D                 db 0FFh
.xdata$x:0000C80E                 db 0FFh
.xdata$x:0000C80F                 db 0FFh
.xdata$x:0000C810                 dd offset __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:0000C814 __ehfuncinfo$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:0000C814                                         ; DATA XREF: __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:0000C815                 db    5
.xdata$x:0000C816                 db  93h ; 
.xdata$x:0000C817                 db  19h
.xdata$x:0000C818                 db    1
.xdata$x:0000C819                 db    0
.xdata$x:0000C81A                 db    0
.xdata$x:0000C81B                 db    0
.xdata$x:0000C81C                 dd offset __unwindtable$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:0000C820                 db    0
.xdata$x:0000C821                 db    0
.xdata$x:0000C822                 db    0
.xdata$x:0000C823                 db    0
.xdata$x:0000C824                 db    0
.xdata$x:0000C825                 db    0
.xdata$x:0000C826                 db    0
.xdata$x:0000C827                 db    0
.xdata$x:0000C828                 db    0
.xdata$x:0000C829                 db    0
.xdata$x:0000C82A                 db    0
.xdata$x:0000C82B                 db    0
.xdata$x:0000C82C                 db    0
.xdata$x:0000C82D                 db    0
.xdata$x:0000C82E                 db    0
.xdata$x:0000C82F                 db    0
.xdata$x:0000C830                 db    0
.xdata$x:0000C831                 db    0
.xdata$x:0000C832                 db    0
.xdata$x:0000C833                 db    0
.xdata$x:0000C834                 db    0
.xdata$x:0000C835                 db    0
.xdata$x:0000C836                 db    0
.xdata$x:0000C837                 db    0
.xdata$x:0000C837 _xdata$x        ends
.xdata$x:0000C837
.xdata$x:0000C838 ; ===========================================================================
.xdata$x:0000C838
.xdata$x:0000C838 ; Segment type: Pure data
.xdata$x:0000C838 ; Segment permissions: Read
.xdata$x:0000C838 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000C838                 assume cs:_xdata$x
.xdata$x:0000C838                 ;org 0C838h
.xdata$x:0000C838 ; COMDAT (pick associative to section at 7B68)
.xdata$x:0000C838 __unwindtable$??1_Generic_error_category@std@@UAE@XZ db 0FFh
.xdata$x:0000C838                                         ; DATA XREF: .xdata$x:0000C848o
.xdata$x:0000C839                 db 0FFh
.xdata$x:0000C83A                 db 0FFh
.xdata$x:0000C83B                 db 0FFh
.xdata$x:0000C83C                 dd offset __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0
.xdata$x:0000C840 __ehfuncinfo$??1_Generic_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:0000C840                                         ; DATA XREF: __ehhandler$??1_Generic_error_category@std@@UAE@XZ+11o
.xdata$x:0000C841                 db    5
.xdata$x:0000C842                 db  93h ; 
.xdata$x:0000C843                 db  19h
.xdata$x:0000C844                 db    1
.xdata$x:0000C845                 db    0
.xdata$x:0000C846                 db    0
.xdata$x:0000C847                 db    0
.xdata$x:0000C848                 dd offset __unwindtable$??1_Generic_error_category@std@@UAE@XZ
.xdata$x:0000C84C                 db    0
.xdata$x:0000C84D                 db    0
.xdata$x:0000C84E                 db    0
.xdata$x:0000C84F                 db    0
.xdata$x:0000C850                 db    0
.xdata$x:0000C851                 db    0
.xdata$x:0000C852                 db    0
.xdata$x:0000C853                 db    0
.xdata$x:0000C854                 db    0
.xdata$x:0000C855                 db    0
.xdata$x:0000C856                 db    0
.xdata$x:0000C857                 db    0
.xdata$x:0000C858                 db    0
.xdata$x:0000C859                 db    0
.xdata$x:0000C85A                 db    0
.xdata$x:0000C85B                 db    0
.xdata$x:0000C85C                 db    0
.xdata$x:0000C85D                 db    0
.xdata$x:0000C85E                 db    0
.xdata$x:0000C85F                 db    0
.xdata$x:0000C860                 db    0
.xdata$x:0000C861                 db    0
.xdata$x:0000C862                 db    0
.xdata$x:0000C863                 db    0
.xdata$x:0000C863 _xdata$x        ends
.xdata$x:0000C863
.xdata$x:0000C864 ; ===========================================================================
.xdata$x:0000C864
.xdata$x:0000C864 ; Segment type: Pure data
.xdata$x:0000C864 ; Segment permissions: Read
.xdata$x:0000C864 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000C864                 assume cs:_xdata$x
.xdata$x:0000C864                 ;org 0C864h
.xdata$x:0000C864 ; COMDAT (pick associative to section at 6F70)
.xdata$x:0000C864 __unwindtable$??0_Iostream_error_category@std@@QAE@XZ db 0FFh
.xdata$x:0000C864                                         ; DATA XREF: .xdata$x:0000C874o
.xdata$x:0000C865                 db 0FFh
.xdata$x:0000C866                 db 0FFh
.xdata$x:0000C867                 db 0FFh
.xdata$x:0000C868                 dd offset __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0
.xdata$x:0000C86C __ehfuncinfo$??0_Iostream_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:0000C86C                                         ; DATA XREF: __ehhandler$??0_Iostream_error_category@std@@QAE@XZ+11o
.xdata$x:0000C86D                 db    5
.xdata$x:0000C86E                 db  93h ; 
.xdata$x:0000C86F                 db  19h
.xdata$x:0000C870                 db    1
.xdata$x:0000C871                 db    0
.xdata$x:0000C872                 db    0
.xdata$x:0000C873                 db    0
.xdata$x:0000C874                 dd offset __unwindtable$??0_Iostream_error_category@std@@QAE@XZ
.xdata$x:0000C878                 db    0
.xdata$x:0000C879                 db    0
.xdata$x:0000C87A                 db    0
.xdata$x:0000C87B                 db    0
.xdata$x:0000C87C                 db    0
.xdata$x:0000C87D                 db    0
.xdata$x:0000C87E                 db    0
.xdata$x:0000C87F                 db    0
.xdata$x:0000C880                 db    0
.xdata$x:0000C881                 db    0
.xdata$x:0000C882                 db    0
.xdata$x:0000C883                 db    0
.xdata$x:0000C884                 db    0
.xdata$x:0000C885                 db    0
.xdata$x:0000C886                 db    0
.xdata$x:0000C887                 db    0
.xdata$x:0000C888                 db    0
.xdata$x:0000C889                 db    0
.xdata$x:0000C88A                 db    0
.xdata$x:0000C88B                 db    0
.xdata$x:0000C88C                 db    0
.xdata$x:0000C88D                 db    0
.xdata$x:0000C88E                 db    0
.xdata$x:0000C88F                 db    0
.xdata$x:0000C88F _xdata$x        ends
.xdata$x:0000C88F
.xdata$x:0000C890 ; ===========================================================================
.xdata$x:0000C890
.xdata$x:0000C890 ; Segment type: Pure data
.xdata$x:0000C890 ; Segment permissions: Read
.xdata$x:0000C890 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000C890                 assume cs:_xdata$x
.xdata$x:0000C890                 ;org 0C890h
.xdata$x:0000C890 ; COMDAT (pick associative to section at BBDC)
.xdata$x:0000C890 __unwindtable$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:0000C890                                         ; DATA XREF: .xdata$x:0000C8A0o
.xdata$x:0000C891                 db 0FFh
.xdata$x:0000C892                 db 0FFh
.xdata$x:0000C893                 db 0FFh
.xdata$x:0000C894                 dd offset __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:0000C898 __ehfuncinfo$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:0000C898                                         ; DATA XREF: __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:0000C899                 db    5
.xdata$x:0000C89A                 db  93h ; 
.xdata$x:0000C89B                 db  19h
.xdata$x:0000C89C                 db    1
.xdata$x:0000C89D                 db    0
.xdata$x:0000C89E                 db    0
.xdata$x:0000C89F                 db    0
.xdata$x:0000C8A0                 dd offset __unwindtable$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:0000C8A4                 db    0
.xdata$x:0000C8A5                 db    0
.xdata$x:0000C8A6                 db    0
.xdata$x:0000C8A7                 db    0
.xdata$x:0000C8A8                 db    0
.xdata$x:0000C8A9                 db    0
.xdata$x:0000C8AA                 db    0
.xdata$x:0000C8AB                 db    0
.xdata$x:0000C8AC                 db    0
.xdata$x:0000C8AD                 db    0
.xdata$x:0000C8AE                 db    0
.xdata$x:0000C8AF                 db    0
.xdata$x:0000C8B0                 db    0
.xdata$x:0000C8B1                 db    0
.xdata$x:0000C8B2                 db    0
.xdata$x:0000C8B3                 db    0
.xdata$x:0000C8B4                 db    0
.xdata$x:0000C8B5                 db    0
.xdata$x:0000C8B6                 db    0
.xdata$x:0000C8B7                 db    0
.xdata$x:0000C8B8                 db    0
.xdata$x:0000C8B9                 db    0
.xdata$x:0000C8BA                 db    0
.xdata$x:0000C8BB                 db    0
.xdata$x:0000C8BB _xdata$x        ends
.xdata$x:0000C8BB
.xdata$x:0000C8BC ; ===========================================================================
.xdata$x:0000C8BC
.xdata$x:0000C8BC ; Segment type: Pure data
.xdata$x:0000C8BC ; Segment permissions: Read
.xdata$x:0000C8BC _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000C8BC                 assume cs:_xdata$x
.xdata$x:0000C8BC                 ;org 0C8BCh
.xdata$x:0000C8BC ; COMDAT (pick associative to section at 7BD8)
.xdata$x:0000C8BC __unwindtable$??1_Iostream_error_category@std@@UAE@XZ db 0FFh
.xdata$x:0000C8BC                                         ; DATA XREF: .xdata$x:0000C8CCo
.xdata$x:0000C8BD                 db 0FFh
.xdata$x:0000C8BE                 db 0FFh
.xdata$x:0000C8BF                 db 0FFh
.xdata$x:0000C8C0                 dd offset __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0
.xdata$x:0000C8C4 __ehfuncinfo$??1_Iostream_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:0000C8C4                                         ; DATA XREF: __ehhandler$??1_Iostream_error_category@std@@UAE@XZ+11o
.xdata$x:0000C8C5                 db    5
.xdata$x:0000C8C6                 db  93h ; 
.xdata$x:0000C8C7                 db  19h
.xdata$x:0000C8C8                 db    1
.xdata$x:0000C8C9                 db    0
.xdata$x:0000C8CA                 db    0
.xdata$x:0000C8CB                 db    0
.xdata$x:0000C8CC                 dd offset __unwindtable$??1_Iostream_error_category@std@@UAE@XZ
.xdata$x:0000C8D0                 db    0
.xdata$x:0000C8D1                 db    0
.xdata$x:0000C8D2                 db    0
.xdata$x:0000C8D3                 db    0
.xdata$x:0000C8D4                 db    0
.xdata$x:0000C8D5                 db    0
.xdata$x:0000C8D6                 db    0
.xdata$x:0000C8D7                 db    0
.xdata$x:0000C8D8                 db    0
.xdata$x:0000C8D9                 db    0
.xdata$x:0000C8DA                 db    0
.xdata$x:0000C8DB                 db    0
.xdata$x:0000C8DC                 db    0
.xdata$x:0000C8DD                 db    0
.xdata$x:0000C8DE                 db    0
.xdata$x:0000C8DF                 db    0
.xdata$x:0000C8E0                 db    0
.xdata$x:0000C8E1                 db    0
.xdata$x:0000C8E2                 db    0
.xdata$x:0000C8E3                 db    0
.xdata$x:0000C8E4                 db    0
.xdata$x:0000C8E5                 db    0
.xdata$x:0000C8E6                 db    0
.xdata$x:0000C8E7                 db    0
.xdata$x:0000C8E7 _xdata$x        ends
.xdata$x:0000C8E7
.xdata$x:0000C8E8 ; ===========================================================================
.xdata$x:0000C8E8
.xdata$x:0000C8E8 ; Segment type: Pure data
.xdata$x:0000C8E8 ; Segment permissions: Read
.xdata$x:0000C8E8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000C8E8                 assume cs:_xdata$x
.xdata$x:0000C8E8                 ;org 0C8E8h
.xdata$x:0000C8E8 ; COMDAT (pick associative to section at 7040)
.xdata$x:0000C8E8 __unwindtable$??0_System_error_category@std@@QAE@XZ db 0FFh
.xdata$x:0000C8E8                                         ; DATA XREF: .xdata$x:0000C8F8o
.xdata$x:0000C8E9                 db 0FFh
.xdata$x:0000C8EA                 db 0FFh
.xdata$x:0000C8EB                 db 0FFh
.xdata$x:0000C8EC                 dd offset __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0
.xdata$x:0000C8F0 __ehfuncinfo$??0_System_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:0000C8F0                                         ; DATA XREF: __ehhandler$??0_System_error_category@std@@QAE@XZ+11o
.xdata$x:0000C8F1                 db    5
.xdata$x:0000C8F2                 db  93h ; 
.xdata$x:0000C8F3                 db  19h
.xdata$x:0000C8F4                 db    1
.xdata$x:0000C8F5                 db    0
.xdata$x:0000C8F6                 db    0
.xdata$x:0000C8F7                 db    0
.xdata$x:0000C8F8                 dd offset __unwindtable$??0_System_error_category@std@@QAE@XZ
.xdata$x:0000C8FC                 db    0
.xdata$x:0000C8FD                 db    0
.xdata$x:0000C8FE                 db    0
.xdata$x:0000C8FF                 db    0
.xdata$x:0000C900                 db    0
.xdata$x:0000C901                 db    0
.xdata$x:0000C902                 db    0
.xdata$x:0000C903                 db    0
.xdata$x:0000C904                 db    0
.xdata$x:0000C905                 db    0
.xdata$x:0000C906                 db    0
.xdata$x:0000C907                 db    0
.xdata$x:0000C908                 db    0
.xdata$x:0000C909                 db    0
.xdata$x:0000C90A                 db    0
.xdata$x:0000C90B                 db    0
.xdata$x:0000C90C                 db    0
.xdata$x:0000C90D                 db    0
.xdata$x:0000C90E                 db    0
.xdata$x:0000C90F                 db    0
.xdata$x:0000C910                 db    0
.xdata$x:0000C911                 db    0
.xdata$x:0000C912                 db    0
.xdata$x:0000C913                 db    0
.xdata$x:0000C913 _xdata$x        ends
.xdata$x:0000C913
.xdata$x:0000C914 ; ===========================================================================
.xdata$x:0000C914
.xdata$x:0000C914 ; Segment type: Pure data
.xdata$x:0000C914 ; Segment permissions: Read
.xdata$x:0000C914 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000C914                 assume cs:_xdata$x
.xdata$x:0000C914                 ;org 0C914h
.xdata$x:0000C914 ; COMDAT (pick associative to section at BCA0)
.xdata$x:0000C914 __unwindtable$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:0000C914                                         ; DATA XREF: .xdata$x:0000C924o
.xdata$x:0000C915                 db 0FFh
.xdata$x:0000C916                 db 0FFh
.xdata$x:0000C917                 db 0FFh
.xdata$x:0000C918                 dd offset __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:0000C91C __ehfuncinfo$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:0000C91C                                         ; DATA XREF: __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:0000C91D                 db    5
.xdata$x:0000C91E                 db  93h ; 
.xdata$x:0000C91F                 db  19h
.xdata$x:0000C920                 db    1
.xdata$x:0000C921                 db    0
.xdata$x:0000C922                 db    0
.xdata$x:0000C923                 db    0
.xdata$x:0000C924                 dd offset __unwindtable$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:0000C928                 align 20h
.xdata$x:0000C928 _xdata$x        ends
.xdata$x:0000C928
.xdata$x:0000C940 ; ===========================================================================
.xdata$x:0000C940
.xdata$x:0000C940 ; Segment type: Pure data
.xdata$x:0000C940 ; Segment permissions: Read
.xdata$x:0000C940 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000C940                 assume cs:_xdata$x
.xdata$x:0000C940                 ;org 0C940h
.xdata$x:0000C940 ; COMDAT (pick associative to section at 7CCC)
.xdata$x:0000C940 __unwindtable$??1_System_error_category@std@@UAE@XZ db 0FFh
.xdata$x:0000C940                                         ; DATA XREF: .xdata$x:0000C950o
.xdata$x:0000C941                 db 0FFh
.xdata$x:0000C942                 db 0FFh
.xdata$x:0000C943                 db 0FFh
.xdata$x:0000C944                 dd offset __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0
.xdata$x:0000C948 __ehfuncinfo$??1_System_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:0000C948                                         ; DATA XREF: __ehhandler$??1_System_error_category@std@@UAE@XZ+11o
.xdata$x:0000C949                 db    5
.xdata$x:0000C94A                 db  93h ; 
.xdata$x:0000C94B                 db  19h
.xdata$x:0000C94C                 db    1
.xdata$x:0000C94D                 db    0
.xdata$x:0000C94E                 db    0
.xdata$x:0000C94F                 db    0
.xdata$x:0000C950                 dd offset __unwindtable$??1_System_error_category@std@@UAE@XZ
.xdata$x:0000C954                 db    0
.xdata$x:0000C955                 db    0
.xdata$x:0000C956                 db    0
.xdata$x:0000C957                 db    0
.xdata$x:0000C958                 db    0
.xdata$x:0000C959                 db    0
.xdata$x:0000C95A                 db    0
.xdata$x:0000C95B                 db    0
.xdata$x:0000C95C                 db    0
.xdata$x:0000C95D                 db    0
.xdata$x:0000C95E                 db    0
.xdata$x:0000C95F                 db    0
.xdata$x:0000C960                 db    0
.xdata$x:0000C961                 db    0
.xdata$x:0000C962                 db    0
.xdata$x:0000C963                 db    0
.xdata$x:0000C964                 db    0
.xdata$x:0000C965                 db    0
.xdata$x:0000C966                 db    0
.xdata$x:0000C967                 db    0
.xdata$x:0000C968                 db    0
.xdata$x:0000C969                 db    0
.xdata$x:0000C96A                 db    0
.xdata$x:0000C96B                 db    0
.xdata$x:0000C96B _xdata$x        ends
.xdata$x:0000C96B
.xdata$x:0000C96C ; ===========================================================================
.xdata$x:0000C96C
.xdata$x:0000C96C ; Segment type: Pure data
.xdata$x:0000C96C ; Segment permissions: Read
.xdata$x:0000C96C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000C96C                 assume cs:_xdata$x
.xdata$x:0000C96C                 ;org 0C96Ch
.xdata$x:0000C96C ; COMDAT (pick associative to section at 66C8)
.xdata$x:0000C96C __unwindtable$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000C96C                                         ; DATA XREF: .xdata$x:0000C97Co
.xdata$x:0000C96D                 db 0FFh
.xdata$x:0000C96E                 db 0FFh
.xdata$x:0000C96F                 db 0FFh
.xdata$x:0000C970                 dd offset __unwindfunclet$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0
.xdata$x:0000C974 __ehfuncinfo$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000C974                                         ; DATA XREF: __ehhandler$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ+11o
.xdata$x:0000C975                 db    5
.xdata$x:0000C976                 db  93h ; 
.xdata$x:0000C977                 db  19h
.xdata$x:0000C978                 db    1
.xdata$x:0000C979                 db    0
.xdata$x:0000C97A                 db    0
.xdata$x:0000C97B                 db    0
.xdata$x:0000C97C                 dd offset __unwindtable$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.xdata$x:0000C980                 db    0
.xdata$x:0000C981                 db    0
.xdata$x:0000C982                 db    0
.xdata$x:0000C983                 db    0
.xdata$x:0000C984                 db    0
.xdata$x:0000C985                 db    0
.xdata$x:0000C986                 db    0
.xdata$x:0000C987                 db    0
.xdata$x:0000C988                 db    0
.xdata$x:0000C989                 db    0
.xdata$x:0000C98A                 db    0
.xdata$x:0000C98B                 db    0
.xdata$x:0000C98C                 db    0
.xdata$x:0000C98D                 db    0
.xdata$x:0000C98E                 db    0
.xdata$x:0000C98F                 db    0
.xdata$x:0000C990                 db    0
.xdata$x:0000C991                 db    0
.xdata$x:0000C992                 db    0
.xdata$x:0000C993                 db    0
.xdata$x:0000C994                 db    0
.xdata$x:0000C995                 db    0
.xdata$x:0000C996                 db    0
.xdata$x:0000C997                 db    0
.xdata$x:0000C997 _xdata$x        ends
.xdata$x:0000C997
.xdata$x:0000C998 ; ===========================================================================
.xdata$x:0000C998
.xdata$x:0000C998 ; Segment type: Pure data
.xdata$x:0000C998 ; Segment permissions: Read
.xdata$x:0000C998 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000C998                 assume cs:_xdata$x
.xdata$x:0000C998                 ;org 0C998h
.xdata$x:0000C998 ; COMDAT (pick associative to section at 7430)
.xdata$x:0000C998 __unwindtable$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000C998                                         ; DATA XREF: .xdata$x:0000C9A8o
.xdata$x:0000C999                 db 0FFh
.xdata$x:0000C99A                 db 0FFh
.xdata$x:0000C99B                 db 0FFh
.xdata$x:0000C99C                 dd offset __unwindfunclet$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0
.xdata$x:0000C9A0 __ehfuncinfo$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000C9A0                                         ; DATA XREF: __ehhandler$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ+11o
.xdata$x:0000C9A1                 db    5
.xdata$x:0000C9A2                 db  93h ; 
.xdata$x:0000C9A3                 db  19h
.xdata$x:0000C9A4                 db    1
.xdata$x:0000C9A5                 db    0
.xdata$x:0000C9A6                 db    0
.xdata$x:0000C9A7                 db    0
.xdata$x:0000C9A8                 dd offset __unwindtable$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.xdata$x:0000C9AC                 db    0
.xdata$x:0000C9AD                 db    0
.xdata$x:0000C9AE                 db    0
.xdata$x:0000C9AF                 db    0
.xdata$x:0000C9B0                 db    0
.xdata$x:0000C9B1                 db    0
.xdata$x:0000C9B2                 db    0
.xdata$x:0000C9B3                 db    0
.xdata$x:0000C9B4                 db    0
.xdata$x:0000C9B5                 db    0
.xdata$x:0000C9B6                 db    0
.xdata$x:0000C9B7                 db    0
.xdata$x:0000C9B8                 db    0
.xdata$x:0000C9B9                 db    0
.xdata$x:0000C9BA                 db    0
.xdata$x:0000C9BB                 db    0
.xdata$x:0000C9BC                 db    0
.xdata$x:0000C9BD                 db    0
.xdata$x:0000C9BE                 db    0
.xdata$x:0000C9BF                 db    0
.xdata$x:0000C9C0                 db    0
.xdata$x:0000C9C1                 db    0
.xdata$x:0000C9C2                 db    0
.xdata$x:0000C9C3                 db    0
.xdata$x:0000C9C3 _xdata$x        ends
.xdata$x:0000C9C3
.xdata$x:0000C9C4 ; ===========================================================================
.xdata$x:0000C9C4
.xdata$x:0000C9C4 ; Segment type: Pure data
.xdata$x:0000C9C4 ; Segment permissions: Read
.xdata$x:0000C9C4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000C9C4                 assume cs:_xdata$x
.xdata$x:0000C9C4                 ;org 0C9C4h
.xdata$x:0000C9C4 ; COMDAT (pick associative to section at 63C0)
.xdata$x:0000C9C4 __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z db 0FFh
.xdata$x:0000C9C4                                         ; DATA XREF: .xdata$x:0000C9D4o
.xdata$x:0000C9C5                 db 0FFh
.xdata$x:0000C9C6                 db 0FFh
.xdata$x:0000C9C7                 db 0FFh
.xdata$x:0000C9C8                 dd offset __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z$0
.xdata$x:0000C9CC __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z db  22h ; "
.xdata$x:0000C9CC                                         ; DATA XREF: __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z+11o
.xdata$x:0000C9CD                 db    5
.xdata$x:0000C9CE                 db  93h ; 
.xdata$x:0000C9CF                 db  19h
.xdata$x:0000C9D0                 db    1
.xdata$x:0000C9D1                 db    0
.xdata$x:0000C9D2                 db    0
.xdata$x:0000C9D3                 db    0
.xdata$x:0000C9D4                 dd offset __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z
.xdata$x:0000C9D8                 db    0
.xdata$x:0000C9D9                 db    0
.xdata$x:0000C9DA                 db    0
.xdata$x:0000C9DB                 db    0
.xdata$x:0000C9DC                 db    0
.xdata$x:0000C9DD                 db    0
.xdata$x:0000C9DE                 db    0
.xdata$x:0000C9DF                 db    0
.xdata$x:0000C9E0                 db    0
.xdata$x:0000C9E1                 db    0
.xdata$x:0000C9E2                 db    0
.xdata$x:0000C9E3                 db    0
.xdata$x:0000C9E4                 db    0
.xdata$x:0000C9E5                 db    0
.xdata$x:0000C9E6                 db    0
.xdata$x:0000C9E7                 db    0
.xdata$x:0000C9E8                 db    0
.xdata$x:0000C9E9                 db    0
.xdata$x:0000C9EA                 db    0
.xdata$x:0000C9EB                 db    0
.xdata$x:0000C9EC                 db    0
.xdata$x:0000C9ED                 db    0
.xdata$x:0000C9EE                 db    0
.xdata$x:0000C9EF                 db    0
.xdata$x:0000C9EF _xdata$x        ends
.xdata$x:0000C9EF
.xdata$x:0000C9F0 ; ===========================================================================
.xdata$x:0000C9F0
.xdata$x:0000C9F0 ; Segment type: Pure data
.xdata$x:0000C9F0 ; Segment permissions: Read
.xdata$x:0000C9F0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000C9F0                 assume cs:_xdata$x
.xdata$x:0000C9F0                 ;org 0C9F0h
.xdata$x:0000C9F0 ; COMDAT (pick associative to section at 7268)
.xdata$x:0000C9F0 __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000C9F0                                         ; DATA XREF: .xdata$x:0000CA00o
.xdata$x:0000C9F1                 db 0FFh
.xdata$x:0000C9F2                 db 0FFh
.xdata$x:0000C9F3                 db 0FFh
.xdata$x:0000C9F4                 dd offset __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ$0
.xdata$x:0000C9F8 __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000C9F8                                         ; DATA XREF: __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:0000C9F9                 db    5
.xdata$x:0000C9FA                 db  93h ; 
.xdata$x:0000C9FB                 db  19h
.xdata$x:0000C9FC                 db    1
.xdata$x:0000C9FD                 db    0
.xdata$x:0000C9FE                 db    0
.xdata$x:0000C9FF                 db    0
.xdata$x:0000CA00                 dd offset __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
.xdata$x:0000CA04                 db    0
.xdata$x:0000CA05                 db    0
.xdata$x:0000CA06                 db    0
.xdata$x:0000CA07                 db    0
.xdata$x:0000CA08                 db    0
.xdata$x:0000CA09                 db    0
.xdata$x:0000CA0A                 db    0
.xdata$x:0000CA0B                 db    0
.xdata$x:0000CA0C                 db    0
.xdata$x:0000CA0D                 db    0
.xdata$x:0000CA0E                 db    0
.xdata$x:0000CA0F                 db    0
.xdata$x:0000CA10                 db    0
.xdata$x:0000CA11                 db    0
.xdata$x:0000CA12                 db    0
.xdata$x:0000CA13                 db    0
.xdata$x:0000CA14                 db    0
.xdata$x:0000CA15                 db    0
.xdata$x:0000CA16                 db    0
.xdata$x:0000CA17                 db    0
.xdata$x:0000CA18                 db    0
.xdata$x:0000CA19                 db    0
.xdata$x:0000CA1A                 db    0
.xdata$x:0000CA1B                 db    0
.xdata$x:0000CA1B _xdata$x        ends
.xdata$x:0000CA1B
.xdata$x:0000CA1C ; ===========================================================================
.xdata$x:0000CA1C
.xdata$x:0000CA1C ; Segment type: Pure data
.xdata$x:0000CA1C ; Segment permissions: Read
.xdata$x:0000CA1C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000CA1C                 assume cs:_xdata$x
.xdata$x:0000CA1C                 ;org 0CA1Ch
.xdata$x:0000CA1C ; COMDAT (pick associative to section at 6D28)
.xdata$x:0000CA1C __unwindtable$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z db 0FFh
.xdata$x:0000CA1C                                         ; DATA XREF: .xdata$x:0000CA2Co
.xdata$x:0000CA1D                 db 0FFh
.xdata$x:0000CA1E                 db 0FFh
.xdata$x:0000CA1F                 db 0FFh
.xdata$x:0000CA20                 dd offset __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z$0
.xdata$x:0000CA24 __ehfuncinfo$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z db  22h ; "
.xdata$x:0000CA24                                         ; DATA XREF: __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z+11o
.xdata$x:0000CA25                 db    5
.xdata$x:0000CA26                 db  93h ; 
.xdata$x:0000CA27                 db  19h
.xdata$x:0000CA28                 db    1
.xdata$x:0000CA29                 db    0
.xdata$x:0000CA2A                 db    0
.xdata$x:0000CA2B                 db    0
.xdata$x:0000CA2C                 dd offset __unwindtable$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z
.xdata$x:0000CA30                 db    0
.xdata$x:0000CA31                 db    0
.xdata$x:0000CA32                 db    0
.xdata$x:0000CA33                 db    0
.xdata$x:0000CA34                 db    0
.xdata$x:0000CA35                 db    0
.xdata$x:0000CA36                 db    0
.xdata$x:0000CA37                 db    0
.xdata$x:0000CA38                 db    0
.xdata$x:0000CA39                 db    0
.xdata$x:0000CA3A                 db    0
.xdata$x:0000CA3B                 db    0
.xdata$x:0000CA3C                 db    0
.xdata$x:0000CA3D                 db    0
.xdata$x:0000CA3E                 db    0
.xdata$x:0000CA3F                 db    0
.xdata$x:0000CA40                 db    0
.xdata$x:0000CA41                 db    0
.xdata$x:0000CA42                 db    0
.xdata$x:0000CA43                 db    0
.xdata$x:0000CA44                 db    0
.xdata$x:0000CA45                 db    0
.xdata$x:0000CA46                 db    0
.xdata$x:0000CA47                 db    0
.xdata$x:0000CA47 _xdata$x        ends
.xdata$x:0000CA47
.xdata$x:0000CA48 ; ===========================================================================
.xdata$x:0000CA48
.xdata$x:0000CA48 ; Segment type: Pure data
.xdata$x:0000CA48 ; Segment permissions: Read
.xdata$x:0000CA48 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000CA48                 assume cs:_xdata$x
.xdata$x:0000CA48                 ;org 0CA48h
.xdata$x:0000CA48 ; COMDAT (pick associative to section at 781C)
.xdata$x:0000CA48 __unwindtable$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ db 0FFh
.xdata$x:0000CA48                                         ; DATA XREF: .xdata$x:0000CA58o
.xdata$x:0000CA49                 db 0FFh
.xdata$x:0000CA4A                 db 0FFh
.xdata$x:0000CA4B                 db 0FFh
.xdata$x:0000CA4C                 dd offset __unwindfunclet$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ$0
.xdata$x:0000CA50 __ehfuncinfo$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ db  22h ; "
.xdata$x:0000CA50                                         ; DATA XREF: __ehhandler$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ+11o
.xdata$x:0000CA51                 db    5
.xdata$x:0000CA52                 db  93h ; 
.xdata$x:0000CA53                 db  19h
.xdata$x:0000CA54                 db    1
.xdata$x:0000CA55                 db    0
.xdata$x:0000CA56                 db    0
.xdata$x:0000CA57                 db    0
.xdata$x:0000CA58                 dd offset __unwindtable$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.xdata$x:0000CA5C                 db    0
.xdata$x:0000CA5D                 db    0
.xdata$x:0000CA5E                 db    0
.xdata$x:0000CA5F                 db    0
.xdata$x:0000CA60                 db    0
.xdata$x:0000CA61                 db    0
.xdata$x:0000CA62                 db    0
.xdata$x:0000CA63                 db    0
.xdata$x:0000CA64                 db    0
.xdata$x:0000CA65                 db    0
.xdata$x:0000CA66                 db    0
.xdata$x:0000CA67                 db    0
.xdata$x:0000CA68                 db    0
.xdata$x:0000CA69                 db    0
.xdata$x:0000CA6A                 db    0
.xdata$x:0000CA6B                 db    0
.xdata$x:0000CA6C                 db    0
.xdata$x:0000CA6D                 db    0
.xdata$x:0000CA6E                 db    0
.xdata$x:0000CA6F                 db    0
.xdata$x:0000CA70                 db    0
.xdata$x:0000CA71                 db    0
.xdata$x:0000CA72                 db    0
.xdata$x:0000CA73                 db    0
.xdata$x:0000CA73 _xdata$x        ends
.xdata$x:0000CA73
.xdata$x:0000CA74 ; ===========================================================================
.xdata$x:0000CA74
.xdata$x:0000CA74 ; Segment type: Pure data
.xdata$x:0000CA74 ; Segment permissions: Read
.xdata$x:0000CA74 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000CA74                 assume cs:_xdata$x
.xdata$x:0000CA74                 ;org 0CA74h
.xdata$x:0000CA74 ; COMDAT (pick associative to section at AADC)
.xdata$x:0000CA74 __unwindtable$?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ db 0FFh
.xdata$x:0000CA74                                         ; DATA XREF: .xdata$x:0000CA84o
.xdata$x:0000CA75                 db 0FFh
.xdata$x:0000CA76                 db 0FFh
.xdata$x:0000CA77                 db 0FFh
.xdata$x:0000CA78                 dd offset __unwindfunclet$?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ$0
.xdata$x:0000CA7C __ehfuncinfo$?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ db  22h ; "
.xdata$x:0000CA7C                                         ; DATA XREF: __ehhandler$?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ+11o
.xdata$x:0000CA7D                 db    5
.xdata$x:0000CA7E                 db  93h ; 
.xdata$x:0000CA7F                 db  19h
.xdata$x:0000CA80                 db    1
.xdata$x:0000CA81                 db    0
.xdata$x:0000CA82                 db    0
.xdata$x:0000CA83                 db    0
.xdata$x:0000CA84                 dd offset __unwindtable$?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ
.xdata$x:0000CA88                 align 20h
.xdata$x:0000CA88 _xdata$x        ends
.xdata$x:0000CA88
.xdata$x:0000CAA0 ; ===========================================================================
.xdata$x:0000CAA0
.xdata$x:0000CAA0 ; Segment type: Pure data
.xdata$x:0000CAA0 ; Segment permissions: Read
.xdata$x:0000CAA0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000CAA0                 assume cs:_xdata$x
.xdata$x:0000CAA0                 ;org 0CAA0h
.xdata$x:0000CAA0 ; COMDAT (pick associative to section at AFFC)
.xdata$x:0000CAA0 __unwindtable$?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ db 0FFh
.xdata$x:0000CAA0                                         ; DATA XREF: .xdata$x:0000CAB0o
.xdata$x:0000CAA1                 db 0FFh
.xdata$x:0000CAA2                 db 0FFh
.xdata$x:0000CAA3                 db 0FFh
.xdata$x:0000CAA4                 dd offset __unwindfunclet$?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ$0
.xdata$x:0000CAA8 __ehfuncinfo$?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ db  22h ; "
.xdata$x:0000CAA8                                         ; DATA XREF: __ehhandler$?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ+11o
.xdata$x:0000CAA9                 db    5
.xdata$x:0000CAAA                 db  93h ; 
.xdata$x:0000CAAB                 db  19h
.xdata$x:0000CAAC                 db    1
.xdata$x:0000CAAD                 db    0
.xdata$x:0000CAAE                 db    0
.xdata$x:0000CAAF                 db    0
.xdata$x:0000CAB0                 dd offset __unwindtable$?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ
.xdata$x:0000CAB4                 db    0
.xdata$x:0000CAB5                 db    0
.xdata$x:0000CAB6                 db    0
.xdata$x:0000CAB7                 db    0
.xdata$x:0000CAB8                 db    0
.xdata$x:0000CAB9                 db    0
.xdata$x:0000CABA                 db    0
.xdata$x:0000CABB                 db    0
.xdata$x:0000CABC                 db    0
.xdata$x:0000CABD                 db    0
.xdata$x:0000CABE                 db    0
.xdata$x:0000CABF                 db    0
.xdata$x:0000CAC0                 db    0
.xdata$x:0000CAC1                 db    0
.xdata$x:0000CAC2                 db    0
.xdata$x:0000CAC3                 db    0
.xdata$x:0000CAC4                 db    0
.xdata$x:0000CAC5                 db    0
.xdata$x:0000CAC6                 db    0
.xdata$x:0000CAC7                 db    0
.xdata$x:0000CAC8                 db    0
.xdata$x:0000CAC9                 db    0
.xdata$x:0000CACA                 db    0
.xdata$x:0000CACB                 db    0
.xdata$x:0000CACB _xdata$x        ends
.xdata$x:0000CACB
.xdata$x:0000CACC ; ===========================================================================
.xdata$x:0000CACC
.xdata$x:0000CACC ; Segment type: Pure data
.xdata$x:0000CACC ; Segment permissions: Read
.xdata$x:0000CACC _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000CACC                 assume cs:_xdata$x
.xdata$x:0000CACC                 ;org 0CACCh
.xdata$x:0000CACC ; COMDAT (pick associative to section at 9128)
.xdata$x:0000CACC __catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$5 db    0
.xdata$x:0000CACC                                         ; DATA XREF: .xdata$x:0000CB54o
.xdata$x:0000CACD                 db    0
.xdata$x:0000CACE                 db    0
.xdata$x:0000CACF                 db    0
.xdata$x:0000CAD0                 db    0
.xdata$x:0000CAD1                 db    0
.xdata$x:0000CAD2                 db    0
.xdata$x:0000CAD3                 db    0
.xdata$x:0000CAD4                 db    0
.xdata$x:0000CAD5                 db    0
.xdata$x:0000CAD6                 db    0
.xdata$x:0000CAD7                 db    0
.xdata$x:0000CAD8                 dd offset __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0
.xdata$x:0000CADC __catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$4 db    0
.xdata$x:0000CADC                                         ; DATA XREF: .xdata$x:0000CB40o
.xdata$x:0000CADD                 db    0
.xdata$x:0000CADE                 db    0
.xdata$x:0000CADF                 db    0
.xdata$x:0000CAE0                 db    0
.xdata$x:0000CAE1                 db    0
.xdata$x:0000CAE2                 db    0
.xdata$x:0000CAE3                 db    0
.xdata$x:0000CAE4                 db    0
.xdata$x:0000CAE5                 db    0
.xdata$x:0000CAE6                 db    0
.xdata$x:0000CAE7                 db    0
.xdata$x:0000CAE8                 dd offset __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$1
.xdata$x:0000CAEC __unwindtable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z db 0FFh
.xdata$x:0000CAEC                                         ; DATA XREF: .xdata$x:0000CB14o
.xdata$x:0000CAED                 db 0FFh
.xdata$x:0000CAEE                 db 0FFh
.xdata$x:0000CAEF                 db 0FFh
.xdata$x:0000CAF0                 db    0
.xdata$x:0000CAF1                 db    0
.xdata$x:0000CAF2                 db    0
.xdata$x:0000CAF3                 db    0
.xdata$x:0000CAF4                 db 0FFh
.xdata$x:0000CAF5                 db 0FFh
.xdata$x:0000CAF6                 db 0FFh
.xdata$x:0000CAF7                 db 0FFh
.xdata$x:0000CAF8                 db    0
.xdata$x:0000CAF9                 db    0
.xdata$x:0000CAFA                 db    0
.xdata$x:0000CAFB                 db    0
.xdata$x:0000CAFC                 db    1
.xdata$x:0000CAFD                 db    0
.xdata$x:0000CAFE                 db    0
.xdata$x:0000CAFF                 db    0
.xdata$x:0000CB00                 db    0
.xdata$x:0000CB01                 db    0
.xdata$x:0000CB02                 db    0
.xdata$x:0000CB03                 db    0
.xdata$x:0000CB04                 db    1
.xdata$x:0000CB05                 db    0
.xdata$x:0000CB06                 db    0
.xdata$x:0000CB07                 db    0
.xdata$x:0000CB08                 db    0
.xdata$x:0000CB09                 db    0
.xdata$x:0000CB0A                 db    0
.xdata$x:0000CB0B                 db    0
.xdata$x:0000CB0C __ehfuncinfo$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z db  22h ; "
.xdata$x:0000CB0C                                         ; DATA XREF: __ehhandler$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z+11o
.xdata$x:0000CB0D                 db    5
.xdata$x:0000CB0E                 db  93h ; 
.xdata$x:0000CB0F                 db  19h
.xdata$x:0000CB10                 db    4
.xdata$x:0000CB11                 db    0
.xdata$x:0000CB12                 db    0
.xdata$x:0000CB13                 db    0
.xdata$x:0000CB14                 dd offset __unwindtable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.xdata$x:0000CB18                 db    2
.xdata$x:0000CB19                 db    0
.xdata$x:0000CB1A                 db    0
.xdata$x:0000CB1B                 db    0
.xdata$x:0000CB1C                 dd offset __tryblocktable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.xdata$x:0000CB20                 db    0
.xdata$x:0000CB21                 db    0
.xdata$x:0000CB22                 db    0
.xdata$x:0000CB23                 db    0
.xdata$x:0000CB24                 db    0
.xdata$x:0000CB25                 db    0
.xdata$x:0000CB26                 db    0
.xdata$x:0000CB27                 db    0
.xdata$x:0000CB28                 db    0
.xdata$x:0000CB29                 db    0
.xdata$x:0000CB2A                 db    0
.xdata$x:0000CB2B                 db    0
.xdata$x:0000CB2C                 db    0
.xdata$x:0000CB2D                 db    0
.xdata$x:0000CB2E                 db    0
.xdata$x:0000CB2F                 db    0
.xdata$x:0000CB30 __tryblocktable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z db    2
.xdata$x:0000CB30                                         ; DATA XREF: .xdata$x:0000CB1Co
.xdata$x:0000CB31                 db    0
.xdata$x:0000CB32                 db    0
.xdata$x:0000CB33                 db    0
.xdata$x:0000CB34                 db    2
.xdata$x:0000CB35                 db    0
.xdata$x:0000CB36                 db    0
.xdata$x:0000CB37                 db    0
.xdata$x:0000CB38                 db    3
.xdata$x:0000CB39                 db    0
.xdata$x:0000CB3A                 db    0
.xdata$x:0000CB3B                 db    0
.xdata$x:0000CB3C                 db    1
.xdata$x:0000CB3D                 db    0
.xdata$x:0000CB3E                 db    0
.xdata$x:0000CB3F                 db    0
.xdata$x:0000CB40                 dd offset __catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$4
.xdata$x:0000CB44                 db    0
.xdata$x:0000CB45                 db    0
.xdata$x:0000CB46                 db    0
.xdata$x:0000CB47                 db    0
.xdata$x:0000CB48                 db    0
.xdata$x:0000CB49                 db    0
.xdata$x:0000CB4A                 db    0
.xdata$x:0000CB4B                 db    0
.xdata$x:0000CB4C                 db    3
.xdata$x:0000CB4D                 db    0
.xdata$x:0000CB4E                 db    0
.xdata$x:0000CB4F                 db    0
.xdata$x:0000CB50                 db    1
.xdata$x:0000CB51                 db    0
.xdata$x:0000CB52                 db    0
.xdata$x:0000CB53                 db    0
.xdata$x:0000CB54                 dd offset __catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$5
.xdata$x:0000CB54 _xdata$x        ends
.xdata$x:0000CB54
.xdata$x:0000CB58 ; ===========================================================================
.xdata$x:0000CB58
.xdata$x:0000CB58 ; Segment type: Pure data
.xdata$x:0000CB58 ; Segment permissions: Read
.xdata$x:0000CB58 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000CB58                 assume cs:_xdata$x
.xdata$x:0000CB58                 ;org 0CB58h
.xdata$x:0000CB58 __unwindtable$?init@WindowsMenu@@QAEXPAUHINSTANCE__@@PAUHMENU__@@PB_W@Z db 0FFh
.xdata$x:0000CB58                                         ; DATA XREF: .xdata$x:0000CBCCo
.xdata$x:0000CB59                 db 0FFh
.xdata$x:0000CB5A                 db 0FFh
.xdata$x:0000CB5B                 db 0FFh
.xdata$x:0000CB5C                 dd offset __unwindfunclet$?init@WindowsMenu@@QAEXPAUHINSTANCE__@@PAUHMENU__@@PB_W@Z$0
.xdata$x:0000CB60 __unwindtable$?doSortToTabs@WindowsDlg@@IAEXXZ db 0FFh
.xdata$x:0000CB60                                         ; DATA XREF: .xdata$x:0000CBF0o
.xdata$x:0000CB61                 db 0FFh
.xdata$x:0000CB62                 db 0FFh
.xdata$x:0000CB63                 db 0FFh
.xdata$x:0000CB64                 dd offset __unwindfunclet$?doSortToTabs@WindowsDlg@@IAEXXZ$0
.xdata$x:0000CB68 __unwindtable$?resetSelection@WindowsDlg@@IAEXXZ db 0FFh
.xdata$x:0000CB68                                         ; DATA XREF: .xdata$x:0000CC38o
.xdata$x:0000CB69                 db 0FFh
.xdata$x:0000CB6A                 db 0FFh
.xdata$x:0000CB6B                 db 0FFh
.xdata$x:0000CB6C                 dd offset __unwindfunclet$?resetSelection@WindowsDlg@@IAEXXZ$0
.xdata$x:0000CB70                 db    0
.xdata$x:0000CB71                 db    0
.xdata$x:0000CB72                 db    0
.xdata$x:0000CB73                 db    0
.xdata$x:0000CB74                 dd offset __unwindfunclet$?resetSelection@WindowsDlg@@IAEXXZ$1
.xdata$x:0000CB78 __unwindtable$??0WindowsDlg@@QAE@XZ db 0FFh
.xdata$x:0000CB78                                         ; DATA XREF: .xdata$x:0000CC80o
.xdata$x:0000CB79                 db 0FFh
.xdata$x:0000CB7A                 db 0FFh
.xdata$x:0000CB7B                 db 0FFh
.xdata$x:0000CB7C                 dd offset __unwindfunclet$??0WindowsDlg@@QAE@XZ$0
.xdata$x:0000CB80                 db    0
.xdata$x:0000CB81                 db    0
.xdata$x:0000CB82                 db    0
.xdata$x:0000CB83                 db    0
.xdata$x:0000CB84                 dd offset __unwindfunclet$??0WindowsDlg@@QAE@XZ$1
.xdata$x:0000CB88 __unwindtable$?run_dlgProc@WindowsDlg@@MAGHIIJ@Z db 0FFh
.xdata$x:0000CB88                                         ; DATA XREF: .xdata$x:0000CC5Co
.xdata$x:0000CB89                 db 0FFh
.xdata$x:0000CB8A                 db 0FFh
.xdata$x:0000CB8B                 db 0FFh
.xdata$x:0000CB8C                 dd offset __unwindfunclet$?run_dlgProc@WindowsDlg@@MAGHIIJ@Z$0
.xdata$x:0000CB90                 db    0
.xdata$x:0000CB91                 db    0
.xdata$x:0000CB92                 db    0
.xdata$x:0000CB93                 db    0
.xdata$x:0000CB94                 dd offset __unwindfunclet$?run_dlgProc@WindowsDlg@@MAGHIIJ@Z$1
.xdata$x:0000CB98                 db    1
.xdata$x:0000CB99                 db    0
.xdata$x:0000CB9A                 db    0
.xdata$x:0000CB9B                 db    0
.xdata$x:0000CB9C                 dd offset __unwindfunclet$?run_dlgProc@WindowsDlg@@MAGHIIJ@Z$2
.xdata$x:0000CBA0 __ehfuncinfo$?initPopupMenu@WindowsMenu@@QAEXPAUHMENU__@@PAVDocTabView@@@Z db  22h ; "
.xdata$x:0000CBA0                                         ; DATA XREF: __ehhandler$?initPopupMenu@WindowsMenu@@QAEXPAUHMENU__@@PAVDocTabView@@@Z+1Eo
.xdata$x:0000CBA1                 db    5
.xdata$x:0000CBA2                 db  93h ; 
.xdata$x:0000CBA3                 db  19h
.xdata$x:0000CBA4                 db    6
.xdata$x:0000CBA5                 db    0
.xdata$x:0000CBA6                 db    0
.xdata$x:0000CBA7                 db    0
.xdata$x:0000CBA8                 dd offset __unwindtable$?initPopupMenu@WindowsMenu@@QAEXPAUHMENU__@@PAVDocTabView@@@Z
.xdata$x:0000CBAC                 db    0
.xdata$x:0000CBAD                 db    0
.xdata$x:0000CBAE                 db    0
.xdata$x:0000CBAF                 db    0
.xdata$x:0000CBB0                 db    0
.xdata$x:0000CBB1                 db    0
.xdata$x:0000CBB2                 db    0
.xdata$x:0000CBB3                 db    0
.xdata$x:0000CBB4                 db    0
.xdata$x:0000CBB5                 db    0
.xdata$x:0000CBB6                 db    0
.xdata$x:0000CBB7                 db    0
.xdata$x:0000CBB8                 db    0
.xdata$x:0000CBB9                 db    0
.xdata$x:0000CBBA                 db    0
.xdata$x:0000CBBB                 db    0
.xdata$x:0000CBBC                 db    0
.xdata$x:0000CBBD                 db    0
.xdata$x:0000CBBE                 db    0
.xdata$x:0000CBBF                 db    0
.xdata$x:0000CBC0                 db    0
.xdata$x:0000CBC1                 db    0
.xdata$x:0000CBC2                 db    0
.xdata$x:0000CBC3                 db    0
.xdata$x:0000CBC4 __ehfuncinfo$?init@WindowsMenu@@QAEXPAUHINSTANCE__@@PAUHMENU__@@PB_W@Z db  22h ; "
.xdata$x:0000CBC4                                         ; DATA XREF: __ehhandler$?init@WindowsMenu@@QAEXPAUHINSTANCE__@@PAUHMENU__@@PB_W@Z+1Eo
.xdata$x:0000CBC5                 db    5
.xdata$x:0000CBC6                 db  93h ; 
.xdata$x:0000CBC7                 db  19h
.xdata$x:0000CBC8                 db    1
.xdata$x:0000CBC9                 db    0
.xdata$x:0000CBCA                 db    0
.xdata$x:0000CBCB                 db    0
.xdata$x:0000CBCC                 dd offset __unwindtable$?init@WindowsMenu@@QAEXPAUHINSTANCE__@@PAUHMENU__@@PB_W@Z
.xdata$x:0000CBD0                 db    0
.xdata$x:0000CBD1                 db    0
.xdata$x:0000CBD2                 db    0
.xdata$x:0000CBD3                 db    0
.xdata$x:0000CBD4                 db    0
.xdata$x:0000CBD5                 db    0
.xdata$x:0000CBD6                 db    0
.xdata$x:0000CBD7                 db    0
.xdata$x:0000CBD8                 db    0
.xdata$x:0000CBD9                 db    0
.xdata$x:0000CBDA                 db    0
.xdata$x:0000CBDB                 db    0
.xdata$x:0000CBDC                 db    0
.xdata$x:0000CBDD                 db    0
.xdata$x:0000CBDE                 db    0
.xdata$x:0000CBDF                 db    0
.xdata$x:0000CBE0                 db    0
.xdata$x:0000CBE1                 db    0
.xdata$x:0000CBE2                 db    0
.xdata$x:0000CBE3                 db    0
.xdata$x:0000CBE4                 db    0
.xdata$x:0000CBE5                 db    0
.xdata$x:0000CBE6                 db    0
.xdata$x:0000CBE7                 db    0
.xdata$x:0000CBE8 __ehfuncinfo$?doSortToTabs@WindowsDlg@@IAEXXZ db  22h ; "
.xdata$x:0000CBE8                                         ; DATA XREF: __ehhandler$?doSortToTabs@WindowsDlg@@IAEXXZ+11o
.xdata$x:0000CBE9                 db    5
.xdata$x:0000CBEA                 db  93h ; 
.xdata$x:0000CBEB                 db  19h
.xdata$x:0000CBEC                 db    1
.xdata$x:0000CBED                 db    0
.xdata$x:0000CBEE                 db    0
.xdata$x:0000CBEF                 db    0
.xdata$x:0000CBF0                 dd offset __unwindtable$?doSortToTabs@WindowsDlg@@IAEXXZ
.xdata$x:0000CBF4                 db    0
.xdata$x:0000CBF5                 db    0
.xdata$x:0000CBF6                 db    0
.xdata$x:0000CBF7                 db    0
.xdata$x:0000CBF8                 db    0
.xdata$x:0000CBF9                 db    0
.xdata$x:0000CBFA                 db    0
.xdata$x:0000CBFB                 db    0
.xdata$x:0000CBFC                 db    0
.xdata$x:0000CBFD                 db    0
.xdata$x:0000CBFE                 db    0
.xdata$x:0000CBFF                 db    0
.xdata$x:0000CC00                 db    0
.xdata$x:0000CC01                 db    0
.xdata$x:0000CC02                 db    0
.xdata$x:0000CC03                 db    0
.xdata$x:0000CC04                 db    0
.xdata$x:0000CC05                 db    0
.xdata$x:0000CC06                 db    0
.xdata$x:0000CC07                 db    0
.xdata$x:0000CC08                 db    0
.xdata$x:0000CC09                 db    0
.xdata$x:0000CC0A                 db    0
.xdata$x:0000CC0B                 db    0
.xdata$x:0000CC0C __ehfuncinfo$?doClose@WindowsDlg@@IAEXXZ db  22h ; "
.xdata$x:0000CC0C                                         ; DATA XREF: __ehhandler$?doClose@WindowsDlg@@IAEXXZ+14o
.xdata$x:0000CC0D                 db    5
.xdata$x:0000CC0E                 db  93h ; 
.xdata$x:0000CC0F                 db  19h
.xdata$x:0000CC10                 db  0Bh
.xdata$x:0000CC11                 db    0
.xdata$x:0000CC12                 db    0
.xdata$x:0000CC13                 db    0
.xdata$x:0000CC14                 dd offset __unwindtable$?doClose@WindowsDlg@@IAEXXZ
.xdata$x:0000CC18                 db    0
.xdata$x:0000CC19                 db    0
.xdata$x:0000CC1A                 db    0
.xdata$x:0000CC1B                 db    0
.xdata$x:0000CC1C                 db    0
.xdata$x:0000CC1D                 db    0
.xdata$x:0000CC1E                 db    0
.xdata$x:0000CC1F                 db    0
.xdata$x:0000CC20                 db    0
.xdata$x:0000CC21                 db    0
.xdata$x:0000CC22                 db    0
.xdata$x:0000CC23                 db    0
.xdata$x:0000CC24                 db    0
.xdata$x:0000CC25                 db    0
.xdata$x:0000CC26                 db    0
.xdata$x:0000CC27                 db    0
.xdata$x:0000CC28                 db    0
.xdata$x:0000CC29                 db    0
.xdata$x:0000CC2A                 db    0
.xdata$x:0000CC2B                 db    0
.xdata$x:0000CC2C                 db    0
.xdata$x:0000CC2D                 db    0
.xdata$x:0000CC2E                 db    0
.xdata$x:0000CC2F                 db    0
.xdata$x:0000CC30 __ehfuncinfo$?resetSelection@WindowsDlg@@IAEXXZ db  22h ; "
.xdata$x:0000CC30                                         ; DATA XREF: __ehhandler$?resetSelection@WindowsDlg@@IAEXXZ+14o
.xdata$x:0000CC31                 db    5
.xdata$x:0000CC32                 db  93h ; 
.xdata$x:0000CC33                 db  19h
.xdata$x:0000CC34                 db    2
.xdata$x:0000CC35                 db    0
.xdata$x:0000CC36                 db    0
.xdata$x:0000CC37                 db    0
.xdata$x:0000CC38                 dd offset __unwindtable$?resetSelection@WindowsDlg@@IAEXXZ
.xdata$x:0000CC3C                 db    0
.xdata$x:0000CC3D                 db    0
.xdata$x:0000CC3E                 db    0
.xdata$x:0000CC3F                 db    0
.xdata$x:0000CC40                 db    0
.xdata$x:0000CC41                 db    0
.xdata$x:0000CC42                 db    0
.xdata$x:0000CC43                 db    0
.xdata$x:0000CC44                 db    0
.xdata$x:0000CC45                 db    0
.xdata$x:0000CC46                 db    0
.xdata$x:0000CC47                 db    0
.xdata$x:0000CC48                 db    0
.xdata$x:0000CC49                 db    0
.xdata$x:0000CC4A                 db    0
.xdata$x:0000CC4B                 db    0
.xdata$x:0000CC4C                 db    0
.xdata$x:0000CC4D                 db    0
.xdata$x:0000CC4E                 db    0
.xdata$x:0000CC4F                 db    0
.xdata$x:0000CC50                 db    0
.xdata$x:0000CC51                 db    0
.xdata$x:0000CC52                 db    0
.xdata$x:0000CC53                 db    0
.xdata$x:0000CC54 __ehfuncinfo$?run_dlgProc@WindowsDlg@@MAGHIIJ@Z db  22h ; "
.xdata$x:0000CC54                                         ; DATA XREF: __ehhandler$?run_dlgProc@WindowsDlg@@MAGHIIJ@Z+14o
.xdata$x:0000CC55                 db    5
.xdata$x:0000CC56                 db  93h ; 
.xdata$x:0000CC57                 db  19h
.xdata$x:0000CC58                 db    3
.xdata$x:0000CC59                 db    0
.xdata$x:0000CC5A                 db    0
.xdata$x:0000CC5B                 db    0
.xdata$x:0000CC5C                 dd offset __unwindtable$?run_dlgProc@WindowsDlg@@MAGHIIJ@Z
.xdata$x:0000CC60                 db    0
.xdata$x:0000CC61                 db    0
.xdata$x:0000CC62                 db    0
.xdata$x:0000CC63                 db    0
.xdata$x:0000CC64                 db    0
.xdata$x:0000CC65                 db    0
.xdata$x:0000CC66                 db    0
.xdata$x:0000CC67                 db    0
.xdata$x:0000CC68                 db    0
.xdata$x:0000CC69                 db    0
.xdata$x:0000CC6A                 db    0
.xdata$x:0000CC6B                 db    0
.xdata$x:0000CC6C                 db    0
.xdata$x:0000CC6D                 db    0
.xdata$x:0000CC6E                 db    0
.xdata$x:0000CC6F                 db    0
.xdata$x:0000CC70                 db    0
.xdata$x:0000CC71                 db    0
.xdata$x:0000CC72                 db    0
.xdata$x:0000CC73                 db    0
.xdata$x:0000CC74                 db    0
.xdata$x:0000CC75                 db    0
.xdata$x:0000CC76                 db    0
.xdata$x:0000CC77                 db    0
.xdata$x:0000CC78 __ehfuncinfo$??0WindowsDlg@@QAE@XZ db  22h ; "
.xdata$x:0000CC78                                         ; DATA XREF: __ehhandler$??0WindowsDlg@@QAE@XZ+11o
.xdata$x:0000CC79                 db    5
.xdata$x:0000CC7A                 db  93h ; 
.xdata$x:0000CC7B                 db  19h
.xdata$x:0000CC7C                 db    2
.xdata$x:0000CC7D                 db    0
.xdata$x:0000CC7E                 db    0
.xdata$x:0000CC7F                 db    0
.xdata$x:0000CC80                 dd offset __unwindtable$??0WindowsDlg@@QAE@XZ
.xdata$x:0000CC84                 db    0
.xdata$x:0000CC85                 db    0
.xdata$x:0000CC86                 db    0
.xdata$x:0000CC87                 db    0
.xdata$x:0000CC88                 db    0
.xdata$x:0000CC89                 db    0
.xdata$x:0000CC8A                 db    0
.xdata$x:0000CC8B                 db    0
.xdata$x:0000CC8C                 db    0
.xdata$x:0000CC8D                 db    0
.xdata$x:0000CC8E                 db    0
.xdata$x:0000CC8F                 db    0
.xdata$x:0000CC90                 db    0
.xdata$x:0000CC91                 db    0
.xdata$x:0000CC92                 db    0
.xdata$x:0000CC93                 db    0
.xdata$x:0000CC94                 db    0
.xdata$x:0000CC95                 db    0
.xdata$x:0000CC96                 db    0
.xdata$x:0000CC97                 db    0
.xdata$x:0000CC98                 db    0
.xdata$x:0000CC99                 db    0
.xdata$x:0000CC9A                 db    0
.xdata$x:0000CC9B                 db    0
.xdata$x:0000CC9C __unwindtable$?initPopupMenu@WindowsMenu@@QAEXPAUHMENU__@@PAVDocTabView@@@Z db 0FFh
.xdata$x:0000CC9C                                         ; DATA XREF: .xdata$x:0000CBA8o
.xdata$x:0000CC9D                 db 0FFh
.xdata$x:0000CC9E                 db 0FFh
.xdata$x:0000CC9F                 db 0FFh
.xdata$x:0000CCA0                 dd offset __unwindfunclet$?initPopupMenu@WindowsMenu@@QAEXPAUHMENU__@@PAVDocTabView@@@Z$0
.xdata$x:0000CCA4                 align 8
.xdata$x:0000CCA8                 dd offset __unwindfunclet$?initPopupMenu@WindowsMenu@@QAEXPAUHMENU__@@PAVDocTabView@@@Z$1
.xdata$x:0000CCAC                 db 0FFh
.xdata$x:0000CCAD                 db 0FFh
.xdata$x:0000CCAE                 db 0FFh
.xdata$x:0000CCAF                 db 0FFh
.xdata$x:0000CCB0                 dd offset __unwindfunclet$?initPopupMenu@WindowsMenu@@QAEXPAUHMENU__@@PAVDocTabView@@@Z$1
.xdata$x:0000CCB4                 db    2
.xdata$x:0000CCB5                 db    0
.xdata$x:0000CCB6                 db    0
.xdata$x:0000CCB7                 db    0
.xdata$x:0000CCB8                 dd offset __unwindfunclet$?initPopupMenu@WindowsMenu@@QAEXPAUHMENU__@@PAVDocTabView@@@Z$2
.xdata$x:0000CCBC                 db    3
.xdata$x:0000CCBD                 db    0
.xdata$x:0000CCBE                 db    0
.xdata$x:0000CCBF                 db    0
.xdata$x:0000CCC0                 dd offset __unwindfunclet$?initPopupMenu@WindowsMenu@@QAEXPAUHMENU__@@PAVDocTabView@@@Z$3
.xdata$x:0000CCC4                 db    2
.xdata$x:0000CCC5                 db    0
.xdata$x:0000CCC6                 db    0
.xdata$x:0000CCC7                 db    0
.xdata$x:0000CCC8                 dd offset __unwindfunclet$?initPopupMenu@WindowsMenu@@QAEXPAUHMENU__@@PAVDocTabView@@@Z$4
.xdata$x:0000CCCC __unwindtable$?doClose@WindowsDlg@@IAEXXZ db 0FFh
.xdata$x:0000CCCC                                         ; DATA XREF: .xdata$x:0000CC14o
.xdata$x:0000CCCD                 db 0FFh
.xdata$x:0000CCCE                 db 0FFh
.xdata$x:0000CCCF                 db 0FFh
.xdata$x:0000CCD0                 dd offset __unwindfunclet$?doClose@WindowsDlg@@IAEXXZ$0
.xdata$x:0000CCD4                 align 8
.xdata$x:0000CCD8                 dd offset __unwindfunclet$?doClose@WindowsDlg@@IAEXXZ$1
.xdata$x:0000CCDC                 db    1
.xdata$x:0000CCDD                 db    0
.xdata$x:0000CCDE                 db    0
.xdata$x:0000CCDF                 db    0
.xdata$x:0000CCE0                 dd offset __unwindfunclet$?doClose@WindowsDlg@@IAEXXZ$2
.xdata$x:0000CCE4                 db    2
.xdata$x:0000CCE5                 db    0
.xdata$x:0000CCE6                 db    0
.xdata$x:0000CCE7                 db    0
.xdata$x:0000CCE8                 dd offset __unwindfunclet$?doClose@WindowsDlg@@IAEXXZ$3
.xdata$x:0000CCEC                 db    1
.xdata$x:0000CCED                 db    0
.xdata$x:0000CCEE                 db    0
.xdata$x:0000CCEF                 db    0
.xdata$x:0000CCF0                 dd offset __unwindfunclet$?doClose@WindowsDlg@@IAEXXZ$4
.xdata$x:0000CCF4                 db    4
.xdata$x:0000CCF5                 db    0
.xdata$x:0000CCF6                 db    0
.xdata$x:0000CCF7                 db    0
.xdata$x:0000CCF8                 dd offset __unwindfunclet$?doClose@WindowsDlg@@IAEXXZ$5
.xdata$x:0000CCFC                 db    5
.xdata$x:0000CCFD                 db    0
.xdata$x:0000CCFE                 db    0
.xdata$x:0000CCFF                 db    0
.xdata$x:0000CD00                 dd offset __unwindfunclet$?doClose@WindowsDlg@@IAEXXZ$6
.xdata$x:0000CD04                 db    6
.xdata$x:0000CD05                 db    0
.xdata$x:0000CD06                 db    0
.xdata$x:0000CD07                 db    0
.xdata$x:0000CD08                 dd offset __unwindfunclet$?doClose@WindowsDlg@@IAEXXZ$7
.xdata$x:0000CD0C                 db    5
.xdata$x:0000CD0D                 db    0
.xdata$x:0000CD0E                 db    0
.xdata$x:0000CD0F                 db    0
.xdata$x:0000CD10                 dd offset __unwindfunclet$?doClose@WindowsDlg@@IAEXXZ$8
.xdata$x:0000CD14                 db    8
.xdata$x:0000CD15                 db    0
.xdata$x:0000CD16                 db    0
.xdata$x:0000CD17                 db    0
.xdata$x:0000CD18                 dd offset __unwindfunclet$?doClose@WindowsDlg@@IAEXXZ$9
.xdata$x:0000CD1C                 db    4
.xdata$x:0000CD1D                 db    0
.xdata$x:0000CD1E                 db    0
.xdata$x:0000CD1F                 db    0
.xdata$x:0000CD20                 dd offset __unwindfunclet$?doClose@WindowsDlg@@IAEXXZ$8
.xdata$x:0000CD20 _xdata$x        ends
.xdata$x:0000CD20
.xdata$x:0000CD24 ; ===========================================================================
.xdata$x:0000CD24
.xdata$x:0000CD24 ; Segment type: Pure data
.xdata$x:0000CD24 ; Segment permissions: Read
.xdata$x:0000CD24 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000CD24                 assume cs:_xdata$x
.xdata$x:0000CD24                 ;org 0CD24h
.xdata$x:0000CD24 ; COMDAT (pick associative to section at 6AD0)
.xdata$x:0000CD24 __unwindtable$??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000CD24                                         ; DATA XREF: .xdata$x:0000CD34o
.xdata$x:0000CD25                 db 0FFh
.xdata$x:0000CD26                 db 0FFh
.xdata$x:0000CD27                 db 0FFh
.xdata$x:0000CD28                 dd offset __unwindfunclet$??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ$0
.xdata$x:0000CD2C __ehfuncinfo$??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000CD2C                                         ; DATA XREF: __ehhandler$??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ+11o
.xdata$x:0000CD2D                 db    5
.xdata$x:0000CD2E                 db  93h ; 
.xdata$x:0000CD2F                 db  19h
.xdata$x:0000CD30                 db    1
.xdata$x:0000CD31                 db    0
.xdata$x:0000CD32                 db    0
.xdata$x:0000CD33                 db    0
.xdata$x:0000CD34                 dd offset __unwindtable$??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ
.xdata$x:0000CD38                 db    0
.xdata$x:0000CD39                 db    0
.xdata$x:0000CD3A                 db    0
.xdata$x:0000CD3B                 db    0
.xdata$x:0000CD3C                 db    0
.xdata$x:0000CD3D                 db    0
.xdata$x:0000CD3E                 db    0
.xdata$x:0000CD3F                 db    0
.xdata$x:0000CD40                 db    0
.xdata$x:0000CD41                 db    0
.xdata$x:0000CD42                 db    0
.xdata$x:0000CD43                 db    0
.xdata$x:0000CD44                 db    0
.xdata$x:0000CD45                 db    0
.xdata$x:0000CD46                 db    0
.xdata$x:0000CD47                 db    0
.xdata$x:0000CD48                 db    0
.xdata$x:0000CD49                 db    0
.xdata$x:0000CD4A                 db    0
.xdata$x:0000CD4B                 db    0
.xdata$x:0000CD4C                 db    0
.xdata$x:0000CD4D                 db    0
.xdata$x:0000CD4E                 db    0
.xdata$x:0000CD4F                 db    0
.xdata$x:0000CD4F _xdata$x        ends
.xdata$x:0000CD4F
.xdata$x:0000CD50 ; ===========================================================================
.xdata$x:0000CD50
.xdata$x:0000CD50 ; Segment type: Pure data
.xdata$x:0000CD50 ; Segment permissions: Read
.xdata$x:0000CD50 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000CD50                 assume cs:_xdata$x
.xdata$x:0000CD50                 ;org 0CD50h
.xdata$x:0000CD50 ; COMDAT (pick associative to section at 76C0)
.xdata$x:0000CD50 __unwindtable$??1?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000CD50                                         ; DATA XREF: .xdata$x:0000CD60o
.xdata$x:0000CD51                 db 0FFh
.xdata$x:0000CD52                 db 0FFh
.xdata$x:0000CD53                 db 0FFh
.xdata$x:0000CD54                 dd offset __unwindfunclet$??1?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ$0
.xdata$x:0000CD58 __ehfuncinfo$??1?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000CD58                                         ; DATA XREF: __ehhandler$??1?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ+11o
.xdata$x:0000CD59                 db    5
.xdata$x:0000CD5A                 db  93h ; 
.xdata$x:0000CD5B                 db  19h
.xdata$x:0000CD5C                 db    1
.xdata$x:0000CD5D                 db    0
.xdata$x:0000CD5E                 db    0
.xdata$x:0000CD5F                 db    0
.xdata$x:0000CD60                 dd offset __unwindtable$??1?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ
.xdata$x:0000CD64                 db    0
.xdata$x:0000CD65                 db    0
.xdata$x:0000CD66                 db    0
.xdata$x:0000CD67                 db    0
.xdata$x:0000CD68                 db    0
.xdata$x:0000CD69                 db    0
.xdata$x:0000CD6A                 db    0
.xdata$x:0000CD6B                 db    0
.xdata$x:0000CD6C                 db    0
.xdata$x:0000CD6D                 db    0
.xdata$x:0000CD6E                 db    0
.xdata$x:0000CD6F                 db    0
.xdata$x:0000CD70                 db    0
.xdata$x:0000CD71                 db    0
.xdata$x:0000CD72                 db    0
.xdata$x:0000CD73                 db    0
.xdata$x:0000CD74                 db    0
.xdata$x:0000CD75                 db    0
.xdata$x:0000CD76                 db    0
.xdata$x:0000CD77                 db    0
.xdata$x:0000CD78                 db    0
.xdata$x:0000CD79                 db    0
.xdata$x:0000CD7A                 db    0
.xdata$x:0000CD7B                 db    0
.xdata$x:0000CD7B _xdata$x        ends
.xdata$x:0000CD7B
.xdata$x:0000CD7C ; ===========================================================================
.xdata$x:0000CD7C
.xdata$x:0000CD7C ; Segment type: Pure data
.xdata$x:0000CD7C ; Segment permissions: Read
.xdata$x:0000CD7C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000CD7C                 assume cs:_xdata$x
.xdata$x:0000CD7C                 ;org 0CD7Ch
.xdata$x:0000CD7C ; COMDAT (pick associative to section at 67D4)
.xdata$x:0000CD7C __unwindtable$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@ABV?$allocator@H@1@@Z db 0FFh
.xdata$x:0000CD7C                                         ; DATA XREF: .xdata$x:0000CD8Co
.xdata$x:0000CD7D                 db 0FFh
.xdata$x:0000CD7E                 db 0FFh
.xdata$x:0000CD7F                 db 0FFh
.xdata$x:0000CD80                 dd offset __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@ABV?$allocator@H@1@@Z$0
.xdata$x:0000CD84 __ehfuncinfo$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@ABV?$allocator@H@1@@Z db  22h ; "
.xdata$x:0000CD84                                         ; DATA XREF: __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@ABV?$allocator@H@1@@Z+11o
.xdata$x:0000CD85                 db    5
.xdata$x:0000CD86                 db  93h ; 
.xdata$x:0000CD87                 db  19h
.xdata$x:0000CD88                 db    1
.xdata$x:0000CD89                 db    0
.xdata$x:0000CD8A                 db    0
.xdata$x:0000CD8B                 db    0
.xdata$x:0000CD8C                 dd offset __unwindtable$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@ABV?$allocator@H@1@@Z
.xdata$x:0000CD90                 db    0
.xdata$x:0000CD91                 db    0
.xdata$x:0000CD92                 db    0
.xdata$x:0000CD93                 db    0
.xdata$x:0000CD94                 db    0
.xdata$x:0000CD95                 db    0
.xdata$x:0000CD96                 db    0
.xdata$x:0000CD97                 db    0
.xdata$x:0000CD98                 db    0
.xdata$x:0000CD99                 db    0
.xdata$x:0000CD9A                 db    0
.xdata$x:0000CD9B                 db    0
.xdata$x:0000CD9C                 db    0
.xdata$x:0000CD9D                 db    0
.xdata$x:0000CD9E                 db    0
.xdata$x:0000CD9F                 db    0
.xdata$x:0000CDA0                 db    0
.xdata$x:0000CDA1                 db    0
.xdata$x:0000CDA2                 db    0
.xdata$x:0000CDA3                 db    0
.xdata$x:0000CDA4                 db    0
.xdata$x:0000CDA5                 db    0
.xdata$x:0000CDA6                 db    0
.xdata$x:0000CDA7                 db    0
.xdata$x:0000CDA7 _xdata$x        ends
.xdata$x:0000CDA7
.xdata$x:0000CDA8 ; ===========================================================================
.xdata$x:0000CDA8
.xdata$x:0000CDA8 ; Segment type: Pure data
.xdata$x:0000CDA8 ; Segment permissions: Read
.xdata$x:0000CDA8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000CDA8                 assume cs:_xdata$x
.xdata$x:0000CDA8                 ;org 0CDA8h
.xdata$x:0000CDA8 ; COMDAT (pick associative to section at 74F0)
.xdata$x:0000CDA8 __unwindtable$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000CDA8                                         ; DATA XREF: .xdata$x:0000CDB8o
.xdata$x:0000CDA9                 db 0FFh
.xdata$x:0000CDAA                 db 0FFh
.xdata$x:0000CDAB                 db 0FFh
.xdata$x:0000CDAC                 dd offset __unwindfunclet$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@XZ$0
.xdata$x:0000CDB0 __ehfuncinfo$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000CDB0                                         ; DATA XREF: __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:0000CDB1                 db    5
.xdata$x:0000CDB2                 db  93h ; 
.xdata$x:0000CDB3                 db  19h
.xdata$x:0000CDB4                 db    1
.xdata$x:0000CDB5                 db    0
.xdata$x:0000CDB6                 db    0
.xdata$x:0000CDB7                 db    0
.xdata$x:0000CDB8                 dd offset __unwindtable$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@XZ
.xdata$x:0000CDBC                 db    0
.xdata$x:0000CDBD                 db    0
.xdata$x:0000CDBE                 db    0
.xdata$x:0000CDBF                 db    0
.xdata$x:0000CDC0                 db    0
.xdata$x:0000CDC1                 db    0
.xdata$x:0000CDC2                 db    0
.xdata$x:0000CDC3                 db    0
.xdata$x:0000CDC4                 db    0
.xdata$x:0000CDC5                 db    0
.xdata$x:0000CDC6                 db    0
.xdata$x:0000CDC7                 db    0
.xdata$x:0000CDC8                 db    0
.xdata$x:0000CDC9                 db    0
.xdata$x:0000CDCA                 db    0
.xdata$x:0000CDCB                 db    0
.xdata$x:0000CDCC                 db    0
.xdata$x:0000CDCD                 db    0
.xdata$x:0000CDCE                 db    0
.xdata$x:0000CDCF                 db    0
.xdata$x:0000CDD0                 db    0
.xdata$x:0000CDD1                 db    0
.xdata$x:0000CDD2                 db    0
.xdata$x:0000CDD3                 db    0
.xdata$x:0000CDD3 _xdata$x        ends
.xdata$x:0000CDD3
.xdata$x:0000CDD4 ; ===========================================================================
.xdata$x:0000CDD4
.xdata$x:0000CDD4 ; Segment type: Pure data
.xdata$x:0000CDD4 ; Segment permissions: Read
.xdata$x:0000CDD4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000CDD4                 assume cs:_xdata$x
.xdata$x:0000CDD4                 ;org 0CDD4h
.xdata$x:0000CDD4 ; COMDAT (pick associative to section at 6DDC)
.xdata$x:0000CDD4 __unwindtable$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000CDD4                                         ; DATA XREF: .xdata$x:0000CDE4o
.xdata$x:0000CDD5                 db 0FFh
.xdata$x:0000CDD6                 db 0FFh
.xdata$x:0000CDD7                 db 0FFh
.xdata$x:0000CDD8                 dd offset __unwindfunclet$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ$0
.xdata$x:0000CDDC __ehfuncinfo$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000CDDC                                         ; DATA XREF: __ehhandler$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ+11o
.xdata$x:0000CDDD                 db    5
.xdata$x:0000CDDE                 db  93h ; 
.xdata$x:0000CDDF                 db  19h
.xdata$x:0000CDE0                 db    1
.xdata$x:0000CDE1                 db    0
.xdata$x:0000CDE2                 db    0
.xdata$x:0000CDE3                 db    0
.xdata$x:0000CDE4                 dd offset __unwindtable$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
.xdata$x:0000CDE8                 align 20h
.xdata$x:0000CDE8 _xdata$x        ends
.xdata$x:0000CDE8
.xdata$x:0000CE00 ; ===========================================================================
.xdata$x:0000CE00
.xdata$x:0000CE00 ; Segment type: Pure data
.xdata$x:0000CE00 ; Segment permissions: Read
.xdata$x:0000CE00 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000CE00                 assume cs:_xdata$x
.xdata$x:0000CE00                 ;org 0CE00h
.xdata$x:0000CE00 ; COMDAT (pick associative to section at 7898)
.xdata$x:0000CE00 __unwindtable$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000CE00                                         ; DATA XREF: .xdata$x:0000CE10o
.xdata$x:0000CE01                 db 0FFh
.xdata$x:0000CE02                 db 0FFh
.xdata$x:0000CE03                 db 0FFh
.xdata$x:0000CE04                 dd offset __unwindfunclet$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ$0
.xdata$x:0000CE08 __ehfuncinfo$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000CE08                                         ; DATA XREF: __ehhandler$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ+11o
.xdata$x:0000CE09                 db    5
.xdata$x:0000CE0A                 db  93h ; 
.xdata$x:0000CE0B                 db  19h
.xdata$x:0000CE0C                 db    1
.xdata$x:0000CE0D                 db    0
.xdata$x:0000CE0E                 db    0
.xdata$x:0000CE0F                 db    0
.xdata$x:0000CE10                 dd offset __unwindtable$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
.xdata$x:0000CE14                 db    0
.xdata$x:0000CE15                 db    0
.xdata$x:0000CE16                 db    0
.xdata$x:0000CE17                 db    0
.xdata$x:0000CE18                 db    0
.xdata$x:0000CE19                 db    0
.xdata$x:0000CE1A                 db    0
.xdata$x:0000CE1B                 db    0
.xdata$x:0000CE1C                 db    0
.xdata$x:0000CE1D                 db    0
.xdata$x:0000CE1E                 db    0
.xdata$x:0000CE1F                 db    0
.xdata$x:0000CE20                 db    0
.xdata$x:0000CE21                 db    0
.xdata$x:0000CE22                 db    0
.xdata$x:0000CE23                 db    0
.xdata$x:0000CE24                 db    0
.xdata$x:0000CE25                 db    0
.xdata$x:0000CE26                 db    0
.xdata$x:0000CE27                 db    0
.xdata$x:0000CE28                 db    0
.xdata$x:0000CE29                 db    0
.xdata$x:0000CE2A                 db    0
.xdata$x:0000CE2B                 db    0
.xdata$x:0000CE2B _xdata$x        ends
.xdata$x:0000CE2B
.xdata$x:0000CE2C ; ===========================================================================
.xdata$x:0000CE2C
.xdata$x:0000CE2C ; Segment type: Pure data
.xdata$x:0000CE2C ; Segment permissions: Read
.xdata$x:0000CE2C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000CE2C                 assume cs:_xdata$x
.xdata$x:0000CE2C                 ;org 0CE2Ch
.xdata$x:0000CE2C ; COMDAT (pick associative to section at AB78)
.xdata$x:0000CE2C __unwindtable$?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ db 0FFh
.xdata$x:0000CE2C                                         ; DATA XREF: .xdata$x:0000CE3Co
.xdata$x:0000CE2D                 db 0FFh
.xdata$x:0000CE2E                 db 0FFh
.xdata$x:0000CE2F                 db 0FFh
.xdata$x:0000CE30                 dd offset __unwindfunclet$?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ$0
.xdata$x:0000CE34 __ehfuncinfo$?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ db  22h ; "
.xdata$x:0000CE34                                         ; DATA XREF: __ehhandler$?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ+11o
.xdata$x:0000CE35                 db    5
.xdata$x:0000CE36                 db  93h ; 
.xdata$x:0000CE37                 db  19h
.xdata$x:0000CE38                 db    1
.xdata$x:0000CE39                 db    0
.xdata$x:0000CE3A                 db    0
.xdata$x:0000CE3B                 db    0
.xdata$x:0000CE3C                 dd offset __unwindtable$?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ
.xdata$x:0000CE40                 db    0
.xdata$x:0000CE41                 db    0
.xdata$x:0000CE42                 db    0
.xdata$x:0000CE43                 db    0
.xdata$x:0000CE44                 db    0
.xdata$x:0000CE45                 db    0
.xdata$x:0000CE46                 db    0
.xdata$x:0000CE47                 db    0
.xdata$x:0000CE48                 db    0
.xdata$x:0000CE49                 db    0
.xdata$x:0000CE4A                 db    0
.xdata$x:0000CE4B                 db    0
.xdata$x:0000CE4C                 db    0
.xdata$x:0000CE4D                 db    0
.xdata$x:0000CE4E                 db    0
.xdata$x:0000CE4F                 db    0
.xdata$x:0000CE50                 db    0
.xdata$x:0000CE51                 db    0
.xdata$x:0000CE52                 db    0
.xdata$x:0000CE53                 db    0
.xdata$x:0000CE54                 db    0
.xdata$x:0000CE55                 db    0
.xdata$x:0000CE56                 db    0
.xdata$x:0000CE57                 db    0
.xdata$x:0000CE57 _xdata$x        ends
.xdata$x:0000CE57
.xdata$x:0000CE58 ; ===========================================================================
.xdata$x:0000CE58
.xdata$x:0000CE58 ; Segment type: Pure data
.xdata$x:0000CE58 ; Segment permissions: Read
.xdata$x:0000CE58 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000CE58                 assume cs:_xdata$x
.xdata$x:0000CE58                 ;org 0CE58h
.xdata$x:0000CE58 ; COMDAT (pick associative to section at B0A4)
.xdata$x:0000CE58 __unwindtable$?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ db 0FFh
.xdata$x:0000CE58                                         ; DATA XREF: .xdata$x:0000CE68o
.xdata$x:0000CE59                 db 0FFh
.xdata$x:0000CE5A                 db 0FFh
.xdata$x:0000CE5B                 db 0FFh
.xdata$x:0000CE5C                 dd offset __unwindfunclet$?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ$0
.xdata$x:0000CE60 __ehfuncinfo$?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ db  22h ; "
.xdata$x:0000CE60                                         ; DATA XREF: __ehhandler$?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ+11o
.xdata$x:0000CE61                 db    5
.xdata$x:0000CE62                 db  93h ; 
.xdata$x:0000CE63                 db  19h
.xdata$x:0000CE64                 db    1
.xdata$x:0000CE65                 db    0
.xdata$x:0000CE66                 db    0
.xdata$x:0000CE67                 db    0
.xdata$x:0000CE68                 dd offset __unwindtable$?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ
.xdata$x:0000CE6C                 db    0
.xdata$x:0000CE6D                 db    0
.xdata$x:0000CE6E                 db    0
.xdata$x:0000CE6F                 db    0
.xdata$x:0000CE70                 db    0
.xdata$x:0000CE71                 db    0
.xdata$x:0000CE72                 db    0
.xdata$x:0000CE73                 db    0
.xdata$x:0000CE74                 db    0
.xdata$x:0000CE75                 db    0
.xdata$x:0000CE76                 db    0
.xdata$x:0000CE77                 db    0
.xdata$x:0000CE78                 db    0
.xdata$x:0000CE79                 db    0
.xdata$x:0000CE7A                 db    0
.xdata$x:0000CE7B                 db    0
.xdata$x:0000CE7C                 db    0
.xdata$x:0000CE7D                 db    0
.xdata$x:0000CE7E                 db    0
.xdata$x:0000CE7F                 db    0
.xdata$x:0000CE80                 db    0
.xdata$x:0000CE81                 db    0
.xdata$x:0000CE82                 db    0
.xdata$x:0000CE83                 db    0
.xdata$x:0000CE83 _xdata$x        ends
.xdata$x:0000CE83
.xdata$x:0000CE84 ; ===========================================================================
.xdata$x:0000CE84
.xdata$x:0000CE84 ; Segment type: Pure data
.xdata$x:0000CE84 ; Segment permissions: Read
.xdata$x:0000CE84 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000CE84                 assume cs:_xdata$x
.xdata$x:0000CE84                 ;org 0CE84h
.xdata$x:0000CE84 ; COMDAT (pick associative to section at 98D0)
.xdata$x:0000CE84 __unwindtable$?_Make_iter@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@@Z db 0FFh
.xdata$x:0000CE84                                         ; DATA XREF: .xdata$x:0000CE9Co
.xdata$x:0000CE85                 db 0FFh
.xdata$x:0000CE86                 db 0FFh
.xdata$x:0000CE87                 db 0FFh
.xdata$x:0000CE88                 dd offset __unwindfunclet$?_Make_iter@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@@Z$1
.xdata$x:0000CE8C                 align 10h
.xdata$x:0000CE90                 dd offset __unwindfunclet$?_Make_iter@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@@Z$0
.xdata$x:0000CE94 __ehfuncinfo$?_Make_iter@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@@Z db  22h ; "
.xdata$x:0000CE94                                         ; DATA XREF: __ehhandler$?_Make_iter@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@@Z+11o
.xdata$x:0000CE95                 db    5
.xdata$x:0000CE96                 db  93h ; 
.xdata$x:0000CE97                 db  19h
.xdata$x:0000CE98                 db    2
.xdata$x:0000CE99                 db    0
.xdata$x:0000CE9A                 db    0
.xdata$x:0000CE9B                 db    0
.xdata$x:0000CE9C                 dd offset __unwindtable$?_Make_iter@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@@Z
.xdata$x:0000CEA0                 db    0
.xdata$x:0000CEA1                 db    0
.xdata$x:0000CEA2                 db    0
.xdata$x:0000CEA3                 db    0
.xdata$x:0000CEA4                 db    0
.xdata$x:0000CEA5                 db    0
.xdata$x:0000CEA6                 db    0
.xdata$x:0000CEA7                 db    0
.xdata$x:0000CEA8                 db    0
.xdata$x:0000CEA9                 db    0
.xdata$x:0000CEAA                 db    0
.xdata$x:0000CEAB                 db    0
.xdata$x:0000CEAC                 db    0
.xdata$x:0000CEAD                 db    0
.xdata$x:0000CEAE                 db    0
.xdata$x:0000CEAF                 db    0
.xdata$x:0000CEB0                 db    0
.xdata$x:0000CEB1                 db    0
.xdata$x:0000CEB2                 db    0
.xdata$x:0000CEB3                 db    0
.xdata$x:0000CEB4                 db    0
.xdata$x:0000CEB5                 db    0
.xdata$x:0000CEB6                 db    0
.xdata$x:0000CEB7                 db    0
.xdata$x:0000CEB7 _xdata$x        ends
.xdata$x:0000CEB7
.xdata$x:0000CEB8 ; ===========================================================================
.xdata$x:0000CEB8
.xdata$x:0000CEB8 ; Segment type: Pure data
.xdata$x:0000CEB8 ; Segment permissions: Read
.xdata$x:0000CEB8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000CEB8                 assume cs:_xdata$x
.xdata$x:0000CEB8                 ;org 0CEB8h
.xdata$x:0000CEB8 ; COMDAT (pick associative to section at C198)
.xdata$x:0000CEB8 __catchsym$?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z$2 db    0
.xdata$x:0000CEB8                                         ; DATA XREF: .xdata$x:0000CEE8o
.xdata$x:0000CEB9                 db    0
.xdata$x:0000CEBA                 db    0
.xdata$x:0000CEBB                 db    0
.xdata$x:0000CEBC                 db    0
.xdata$x:0000CEBD                 db    0
.xdata$x:0000CEBE                 db    0
.xdata$x:0000CEBF                 db    0
.xdata$x:0000CEC0                 db    0
.xdata$x:0000CEC1                 db    0
.xdata$x:0000CEC2                 db    0
.xdata$x:0000CEC3                 db    0
.xdata$x:0000CEC4                 dd offset __catch$?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z$0
.xdata$x:0000CEC8 __unwindtable$?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z db 0FFh
.xdata$x:0000CEC8                                         ; DATA XREF: .xdata$x:0000CEF4o
.xdata$x:0000CEC9                 db 0FFh
.xdata$x:0000CECA                 db 0FFh
.xdata$x:0000CECB                 db 0FFh
.xdata$x:0000CECC                 db    0
.xdata$x:0000CECD                 db    0
.xdata$x:0000CECE                 db    0
.xdata$x:0000CECF                 db    0
.xdata$x:0000CED0                 db 0FFh
.xdata$x:0000CED1                 db 0FFh
.xdata$x:0000CED2                 db 0FFh
.xdata$x:0000CED3                 db 0FFh
.xdata$x:0000CED4                 db    0
.xdata$x:0000CED5                 db    0
.xdata$x:0000CED6                 db    0
.xdata$x:0000CED7                 db    0
.xdata$x:0000CED8 __tryblocktable$?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z db    0
.xdata$x:0000CED8                                         ; DATA XREF: .xdata$x:0000CEFCo
.xdata$x:0000CED9                 db    0
.xdata$x:0000CEDA                 db    0
.xdata$x:0000CEDB                 db    0
.xdata$x:0000CEDC                 db    0
.xdata$x:0000CEDD                 db    0
.xdata$x:0000CEDE                 db    0
.xdata$x:0000CEDF                 db    0
.xdata$x:0000CEE0                 db    1
.xdata$x:0000CEE1                 db    0
.xdata$x:0000CEE2                 db    0
.xdata$x:0000CEE3                 db    0
.xdata$x:0000CEE4                 db    1
.xdata$x:0000CEE5                 db    0
.xdata$x:0000CEE6                 db    0
.xdata$x:0000CEE7                 db    0
.xdata$x:0000CEE8                 dd offset __catchsym$?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z$2
.xdata$x:0000CEEC __ehfuncinfo$?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z db  22h ; "
.xdata$x:0000CEEC                                         ; DATA XREF: __ehhandler$?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z+11o
.xdata$x:0000CEED                 db    5
.xdata$x:0000CEEE                 db  93h ; 
.xdata$x:0000CEEF                 db  19h
.xdata$x:0000CEF0                 db    2
.xdata$x:0000CEF1                 db    0
.xdata$x:0000CEF2                 db    0
.xdata$x:0000CEF3                 db    0
.xdata$x:0000CEF4                 dd offset __unwindtable$?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z
.xdata$x:0000CEF8                 db    1
.xdata$x:0000CEF9                 db    0
.xdata$x:0000CEFA                 db    0
.xdata$x:0000CEFB                 db    0
.xdata$x:0000CEFC                 dd offset __tryblocktable$?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z
.xdata$x:0000CF00                 db    0
.xdata$x:0000CF01                 db    0
.xdata$x:0000CF02                 db    0
.xdata$x:0000CF03                 db    0
.xdata$x:0000CF04                 db    0
.xdata$x:0000CF05                 db    0
.xdata$x:0000CF06                 db    0
.xdata$x:0000CF07                 db    0
.xdata$x:0000CF08                 db    0
.xdata$x:0000CF09                 db    0
.xdata$x:0000CF0A                 db    0
.xdata$x:0000CF0B                 db    0
.xdata$x:0000CF0C                 db    0
.xdata$x:0000CF0D                 db    0
.xdata$x:0000CF0E                 db    0
.xdata$x:0000CF0F                 db    0
.xdata$x:0000CF0F _xdata$x        ends
.xdata$x:0000CF0F
.xdata$x:0000CF10 ; ===========================================================================
.xdata$x:0000CF10
.xdata$x:0000CF10 ; Segment type: Pure data
.xdata$x:0000CF10 ; Segment permissions: Read
.xdata$x:0000CF10 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000CF10                 assume cs:_xdata$x
.xdata$x:0000CF10                 ;org 0CF10h
.xdata$x:0000CF10 ; COMDAT (pick associative to section at C2C0)
.xdata$x:0000CF10 __catchsym$?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXIABH@Z$2 db    0
.xdata$x:0000CF10                                         ; DATA XREF: .xdata$x:0000CF40o
.xdata$x:0000CF11                 db    0
.xdata$x:0000CF12                 db    0
.xdata$x:0000CF13                 db    0
.xdata$x:0000CF14                 db    0
.xdata$x:0000CF15                 db    0
.xdata$x:0000CF16                 db    0
.xdata$x:0000CF17                 db    0
.xdata$x:0000CF18                 db    0
.xdata$x:0000CF19                 db    0
.xdata$x:0000CF1A                 db    0
.xdata$x:0000CF1B                 db    0
.xdata$x:0000CF1C                 dd offset __catch$?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXIABH@Z$0
.xdata$x:0000CF20 __unwindtable$?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXIABH@Z db 0FFh
.xdata$x:0000CF20                                         ; DATA XREF: .xdata$x:0000CF4Co
.xdata$x:0000CF21                 db 0FFh
.xdata$x:0000CF22                 db 0FFh
.xdata$x:0000CF23                 db 0FFh
.xdata$x:0000CF24                 db    0
.xdata$x:0000CF25                 db    0
.xdata$x:0000CF26                 db    0
.xdata$x:0000CF27                 db    0
.xdata$x:0000CF28                 db 0FFh
.xdata$x:0000CF29                 db 0FFh
.xdata$x:0000CF2A                 db 0FFh
.xdata$x:0000CF2B                 db 0FFh
.xdata$x:0000CF2C                 db    0
.xdata$x:0000CF2D                 db    0
.xdata$x:0000CF2E                 db    0
.xdata$x:0000CF2F                 db    0
.xdata$x:0000CF30 __tryblocktable$?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXIABH@Z db    0
.xdata$x:0000CF30                                         ; DATA XREF: .xdata$x:0000CF54o
.xdata$x:0000CF31                 db    0
.xdata$x:0000CF32                 db    0
.xdata$x:0000CF33                 db    0
.xdata$x:0000CF34                 db    0
.xdata$x:0000CF35                 db    0
.xdata$x:0000CF36                 db    0
.xdata$x:0000CF37                 db    0
.xdata$x:0000CF38                 db    1
.xdata$x:0000CF39                 db    0
.xdata$x:0000CF3A                 db    0
.xdata$x:0000CF3B                 db    0
.xdata$x:0000CF3C                 db    1
.xdata$x:0000CF3D                 db    0
.xdata$x:0000CF3E                 db    0
.xdata$x:0000CF3F                 db    0
.xdata$x:0000CF40                 dd offset __catchsym$?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXIABH@Z$2
.xdata$x:0000CF44 __ehfuncinfo$?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXIABH@Z db  22h ; "
.xdata$x:0000CF44                                         ; DATA XREF: __ehhandler$?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXIABH@Z+11o
.xdata$x:0000CF45                 db    5
.xdata$x:0000CF46                 db  93h ; 
.xdata$x:0000CF47                 db  19h
.xdata$x:0000CF48                 db    2
.xdata$x:0000CF49                 db    0
.xdata$x:0000CF4A                 db    0
.xdata$x:0000CF4B                 db    0
.xdata$x:0000CF4C                 dd offset __unwindtable$?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXIABH@Z
.xdata$x:0000CF50                 db    1
.xdata$x:0000CF51                 db    0
.xdata$x:0000CF52                 db    0
.xdata$x:0000CF53                 db    0
.xdata$x:0000CF54                 dd offset __tryblocktable$?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXIABH@Z
.xdata$x:0000CF58                 db    0
.xdata$x:0000CF59                 db    0
.xdata$x:0000CF5A                 db    0
.xdata$x:0000CF5B                 db    0
.xdata$x:0000CF5C                 db    0
.xdata$x:0000CF5D                 db    0
.xdata$x:0000CF5E                 db    0
.xdata$x:0000CF5F                 db    0
.xdata$x:0000CF60                 db    0
.xdata$x:0000CF61                 db    0
.xdata$x:0000CF62                 db    0
.xdata$x:0000CF63                 db    0
.xdata$x:0000CF64                 db    0
.xdata$x:0000CF65                 db    0
.xdata$x:0000CF66                 db    0
.xdata$x:0000CF67                 db    0
.xdata$x:0000CF67 _xdata$x        ends
.xdata$x:0000CF67
.xdata$x:0000CF68 ; ===========================================================================
.xdata$x:0000CF68
.xdata$x:0000CF68 ; Segment type: Pure data
.xdata$x:0000CF68 ; Segment permissions: Read
.xdata$x:0000CF68 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000CF68                 assume cs:_xdata$x
.xdata$x:0000CF68                 ;org 0CF68h
.xdata$x:0000CF68 ; COMDAT (pick associative to section at B330)
.xdata$x:0000CF68 __ehfuncinfo$?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@0@Z db  22h ; "
.xdata$x:0000CF68                                         ; DATA XREF: __ehhandler$?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@0@Z+14o
.xdata$x:0000CF69                 db    5
.xdata$x:0000CF6A                 db  93h ; 
.xdata$x:0000CF6B                 db  19h
.xdata$x:0000CF6C                 db  0Ah
.xdata$x:0000CF6D                 db    0
.xdata$x:0000CF6E                 db    0
.xdata$x:0000CF6F                 db    0
.xdata$x:0000CF70                 dd offset __unwindtable$?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@0@Z
.xdata$x:0000CF74                 db    0
.xdata$x:0000CF75                 db    0
.xdata$x:0000CF76                 db    0
.xdata$x:0000CF77                 db    0
.xdata$x:0000CF78                 db    0
.xdata$x:0000CF79                 db    0
.xdata$x:0000CF7A                 db    0
.xdata$x:0000CF7B                 db    0
.xdata$x:0000CF7C                 db    0
.xdata$x:0000CF7D                 db    0
.xdata$x:0000CF7E                 db    0
.xdata$x:0000CF7F                 db    0
.xdata$x:0000CF80                 db    0
.xdata$x:0000CF81                 db    0
.xdata$x:0000CF82                 db    0
.xdata$x:0000CF83                 db    0
.xdata$x:0000CF84                 db    0
.xdata$x:0000CF85                 db    0
.xdata$x:0000CF86                 db    0
.xdata$x:0000CF87                 db    0
.xdata$x:0000CF88                 db    0
.xdata$x:0000CF89                 db    0
.xdata$x:0000CF8A                 db    0
.xdata$x:0000CF8B                 db    0
.xdata$x:0000CF8C __unwindtable$?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@0@Z db 0FFh
.xdata$x:0000CF8C                                         ; DATA XREF: .xdata$x:0000CF70o
.xdata$x:0000CF8D                 db 0FFh
.xdata$x:0000CF8E                 db 0FFh
.xdata$x:0000CF8F                 db 0FFh
.xdata$x:0000CF90                 dd offset __unwindfunclet$?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@0@Z$9
.xdata$x:0000CF94                 align 8
.xdata$x:0000CF98                 dd offset __unwindfunclet$?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@0@Z$0
.xdata$x:0000CF9C                 db    1
.xdata$x:0000CF9D                 db    0
.xdata$x:0000CF9E                 db    0
.xdata$x:0000CF9F                 db    0
.xdata$x:0000CFA0                 dd offset __unwindfunclet$?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@0@Z$1
.xdata$x:0000CFA4                 db    2
.xdata$x:0000CFA5                 db    0
.xdata$x:0000CFA6                 db    0
.xdata$x:0000CFA7                 db    0
.xdata$x:0000CFA8                 dd offset __unwindfunclet$?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@0@Z$2
.xdata$x:0000CFAC                 db    3
.xdata$x:0000CFAD                 db    0
.xdata$x:0000CFAE                 db    0
.xdata$x:0000CFAF                 db    0
.xdata$x:0000CFB0                 dd offset __unwindfunclet$?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@0@Z$3
.xdata$x:0000CFB4                 db    2
.xdata$x:0000CFB5                 db    0
.xdata$x:0000CFB6                 db    0
.xdata$x:0000CFB7                 db    0
.xdata$x:0000CFB8                 dd offset __unwindfunclet$?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@0@Z$4
.xdata$x:0000CFBC                 db    2
.xdata$x:0000CFBD                 db    0
.xdata$x:0000CFBE                 db    0
.xdata$x:0000CFBF                 db    0
.xdata$x:0000CFC0                 dd offset __unwindfunclet$?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@0@Z$5
.xdata$x:0000CFC4                 db    6
.xdata$x:0000CFC5                 db    0
.xdata$x:0000CFC6                 db    0
.xdata$x:0000CFC7                 db    0
.xdata$x:0000CFC8                 dd offset __unwindfunclet$?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@0@Z$6
.xdata$x:0000CFCC                 db    6
.xdata$x:0000CFCD                 db    0
.xdata$x:0000CFCE                 db    0
.xdata$x:0000CFCF                 db    0
.xdata$x:0000CFD0                 dd offset __unwindfunclet$?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@0@Z$7
.xdata$x:0000CFD4                 db    2
.xdata$x:0000CFD5                 db    0
.xdata$x:0000CFD6                 db    0
.xdata$x:0000CFD7                 db    0
.xdata$x:0000CFD8                 dd offset __unwindfunclet$?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@0@Z$8
.xdata$x:0000CFD8 _xdata$x        ends
.xdata$x:0000CFD8
.xdata$x:0000CFDC ; ===========================================================================
.xdata$x:0000CFDC
.xdata$x:0000CFDC ; Segment type: Pure data
.xdata$x:0000CFDC ; Segment permissions: Read
.xdata$x:0000CFDC _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000CFDC                 assume cs:_xdata$x
.xdata$x:0000CFDC                 ;org 0CFDCh
.xdata$x:0000CFDC ; COMDAT (pick associative to section at 9E0C)
.xdata$x:0000CFDC __catchsym$?_Reallocate@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z$2 db    0
.xdata$x:0000CFDC                                         ; DATA XREF: .xdata$x:0000D00Co
.xdata$x:0000CFDD                 db    0
.xdata$x:0000CFDE                 db    0
.xdata$x:0000CFDF                 db    0
.xdata$x:0000CFE0                 db    0
.xdata$x:0000CFE1                 db    0
.xdata$x:0000CFE2                 db    0
.xdata$x:0000CFE3                 db    0
.xdata$x:0000CFE4                 db    0
.xdata$x:0000CFE5                 db    0
.xdata$x:0000CFE6                 db    0
.xdata$x:0000CFE7                 db    0
.xdata$x:0000CFE8                 dd offset __catch$?_Reallocate@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z$0
.xdata$x:0000CFEC __unwindtable$?_Reallocate@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z db 0FFh
.xdata$x:0000CFEC                                         ; DATA XREF: .xdata$x:0000D018o
.xdata$x:0000CFED                 db 0FFh
.xdata$x:0000CFEE                 db 0FFh
.xdata$x:0000CFEF                 db 0FFh
.xdata$x:0000CFF0                 db    0
.xdata$x:0000CFF1                 db    0
.xdata$x:0000CFF2                 db    0
.xdata$x:0000CFF3                 db    0
.xdata$x:0000CFF4                 db 0FFh
.xdata$x:0000CFF5                 db 0FFh
.xdata$x:0000CFF6                 db 0FFh
.xdata$x:0000CFF7                 db 0FFh
.xdata$x:0000CFF8                 db    0
.xdata$x:0000CFF9                 db    0
.xdata$x:0000CFFA                 db    0
.xdata$x:0000CFFB                 db    0
.xdata$x:0000CFFC __tryblocktable$?_Reallocate@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z db    0
.xdata$x:0000CFFC                                         ; DATA XREF: .xdata$x:0000D020o
.xdata$x:0000CFFD                 db    0
.xdata$x:0000CFFE                 db    0
.xdata$x:0000CFFF                 db    0
.xdata$x:0000D000                 db    0
.xdata$x:0000D001                 db    0
.xdata$x:0000D002                 db    0
.xdata$x:0000D003                 db    0
.xdata$x:0000D004                 db    1
.xdata$x:0000D005                 db    0
.xdata$x:0000D006                 db    0
.xdata$x:0000D007                 db    0
.xdata$x:0000D008                 db    1
.xdata$x:0000D009                 db    0
.xdata$x:0000D00A                 db    0
.xdata$x:0000D00B                 db    0
.xdata$x:0000D00C                 dd offset __catchsym$?_Reallocate@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z$2
.xdata$x:0000D010 __ehfuncinfo$?_Reallocate@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z db  22h ; "
.xdata$x:0000D010                                         ; DATA XREF: __ehhandler$?_Reallocate@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z+11o
.xdata$x:0000D011                 db    5
.xdata$x:0000D012                 db  93h ; 
.xdata$x:0000D013                 db  19h
.xdata$x:0000D014                 db    2
.xdata$x:0000D015                 db    0
.xdata$x:0000D016                 db    0
.xdata$x:0000D017                 db    0
.xdata$x:0000D018                 dd offset __unwindtable$?_Reallocate@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z
.xdata$x:0000D01C                 db    1
.xdata$x:0000D01D                 db    0
.xdata$x:0000D01E                 db    0
.xdata$x:0000D01F                 db    0
.xdata$x:0000D020                 dd offset __tryblocktable$?_Reallocate@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z
.xdata$x:0000D024                 db    0
.xdata$x:0000D025                 db    0
.xdata$x:0000D026                 db    0
.xdata$x:0000D027                 db    0
.xdata$x:0000D028                 db    0
.xdata$x:0000D029                 db    0
.xdata$x:0000D02A                 db    0
.xdata$x:0000D02B                 db    0
.xdata$x:0000D02C                 db    0
.xdata$x:0000D02D                 db    0
.xdata$x:0000D02E                 db    0
.xdata$x:0000D02F                 db    0
.xdata$x:0000D030                 db    0
.xdata$x:0000D031                 db    0
.xdata$x:0000D032                 db    0
.xdata$x:0000D033                 db    0
.xdata$x:0000D033 _xdata$x        ends
.xdata$x:0000D033
.xdata$x:0000D034 ; ===========================================================================
.xdata$x:0000D034
.xdata$x:0000D034 ; Segment type: Pure data
.xdata$x:0000D034 ; Segment permissions: Read
.xdata$x:0000D034 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D034                 assume cs:_xdata$x
.xdata$x:0000D034                 ;org 0D034h
.xdata$x:0000D034 ; COMDAT (pick associative to section at 9C04)
.xdata$x:0000D034 __unwindtable$?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@IBEXPAH0@Z db 0FFh
.xdata$x:0000D034                                         ; DATA XREF: .xdata$x:0000D044o
.xdata$x:0000D035                 db 0FFh
.xdata$x:0000D036                 db 0FFh
.xdata$x:0000D037                 db 0FFh
.xdata$x:0000D038                 dd offset __unwindfunclet$?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@IBEXPAH0@Z$0
.xdata$x:0000D03C __ehfuncinfo$?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@IBEXPAH0@Z db  22h ; "
.xdata$x:0000D03C                                         ; DATA XREF: __ehhandler$?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@IBEXPAH0@Z+11o
.xdata$x:0000D03D                 db    5
.xdata$x:0000D03E                 db  93h ; 
.xdata$x:0000D03F                 db  19h
.xdata$x:0000D040                 db    1
.xdata$x:0000D041                 db    0
.xdata$x:0000D042                 db    0
.xdata$x:0000D043                 db    0
.xdata$x:0000D044                 dd offset __unwindtable$?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@IBEXPAH0@Z
.xdata$x:0000D048                 align 20h
.xdata$x:0000D048 _xdata$x        ends
.xdata$x:0000D048
.xdata$x:0000D060 ; ===========================================================================
.xdata$x:0000D060
.xdata$x:0000D060 ; Segment type: Pure data
.xdata$x:0000D060 ; Segment permissions: Read
.xdata$x:0000D060 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D060                 assume cs:_xdata$x
.xdata$x:0000D060                 ;org 0D060h
.xdata$x:0000D060 ; COMDAT (pick associative to section at 7AC8)
.xdata$x:0000D060 __unwindtable$??1WindowsDlg@@UAE@XZ db 0FFh
.xdata$x:0000D060                                         ; DATA XREF: .xdata$x:0000D078o
.xdata$x:0000D061                 db 0FFh
.xdata$x:0000D062                 db 0FFh
.xdata$x:0000D063                 db 0FFh
.xdata$x:0000D064                 dd offset __unwindfunclet$??1WindowsDlg@@UAE@XZ$0
.xdata$x:0000D068                 db    0
.xdata$x:0000D069                 db    0
.xdata$x:0000D06A                 db    0
.xdata$x:0000D06B                 db    0
.xdata$x:0000D06C                 dd offset __unwindfunclet$??1WindowsDlg@@UAE@XZ$1
.xdata$x:0000D070 __ehfuncinfo$??1WindowsDlg@@UAE@XZ db  22h ; "
.xdata$x:0000D070                                         ; DATA XREF: __ehhandler$??1WindowsDlg@@UAE@XZ+11o
.xdata$x:0000D071                 db    5
.xdata$x:0000D072                 db  93h ; 
.xdata$x:0000D073                 db  19h
.xdata$x:0000D074                 db    2
.xdata$x:0000D075                 db    0
.xdata$x:0000D076                 db    0
.xdata$x:0000D077                 db    0
.xdata$x:0000D078                 dd offset __unwindtable$??1WindowsDlg@@UAE@XZ
.xdata$x:0000D07C                 db    0
.xdata$x:0000D07D                 db    0
.xdata$x:0000D07E                 db    0
.xdata$x:0000D07F                 db    0
.xdata$x:0000D080                 db    0
.xdata$x:0000D081                 db    0
.xdata$x:0000D082                 db    0
.xdata$x:0000D083                 db    0
.xdata$x:0000D084                 db    0
.xdata$x:0000D085                 db    0
.xdata$x:0000D086                 db    0
.xdata$x:0000D087                 db    0
.xdata$x:0000D088                 db    0
.xdata$x:0000D089                 db    0
.xdata$x:0000D08A                 db    0
.xdata$x:0000D08B                 db    0
.xdata$x:0000D08C                 db    0
.xdata$x:0000D08D                 db    0
.xdata$x:0000D08E                 db    0
.xdata$x:0000D08F                 db    0
.xdata$x:0000D090                 db    0
.xdata$x:0000D091                 db    0
.xdata$x:0000D092                 db    0
.xdata$x:0000D093                 db    0
.xdata$x:0000D093 _xdata$x        ends
.xdata$x:0000D093
.xdata$x:0000D094 ; ===========================================================================
.xdata$x:0000D094
.xdata$x:0000D094 ; Segment type: Pure data
.xdata$x:0000D094 ; Segment permissions: Read
.xdata$x:0000D094 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D094                 assume cs:_xdata$x
.xdata$x:0000D094                 ;org 0D094h
.xdata$x:0000D094 ; COMDAT (pick associative to section at 61E4)
.xdata$x:0000D094 __unwindtable$??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ db 0FFh
.xdata$x:0000D094                                         ; DATA XREF: .xdata$x:0000D0A4o
.xdata$x:0000D095                 db 0FFh
.xdata$x:0000D096                 db 0FFh
.xdata$x:0000D097                 db 0FFh
.xdata$x:0000D098                 dd offset __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ$0
.xdata$x:0000D09C __ehfuncinfo$??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ db  22h ; "
.xdata$x:0000D09C                                         ; DATA XREF: __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ+11o
.xdata$x:0000D09D                 db    5
.xdata$x:0000D09E                 db  93h ; 
.xdata$x:0000D09F                 db  19h
.xdata$x:0000D0A0                 db    1
.xdata$x:0000D0A1                 db    0
.xdata$x:0000D0A2                 db    0
.xdata$x:0000D0A3                 db    0
.xdata$x:0000D0A4                 dd offset __unwindtable$??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ
.xdata$x:0000D0A8                 align 20h
.xdata$x:0000D0A8 _xdata$x        ends
.xdata$x:0000D0A8
.xdata$x:0000D0C0 ; ===========================================================================
.xdata$x:0000D0C0
.xdata$x:0000D0C0 ; Segment type: Pure data
.xdata$x:0000D0C0 ; Segment permissions: Read
.xdata$x:0000D0C0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D0C0                 assume cs:_xdata$x
.xdata$x:0000D0C0                 ;org 0D0C0h
.xdata$x:0000D0C0 ; COMDAT (pick associative to section at 7110)
.xdata$x:0000D0C0 __unwindtable$??1?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ db 0FFh
.xdata$x:0000D0C0                                         ; DATA XREF: .xdata$x:0000D0D0o
.xdata$x:0000D0C1                 db 0FFh
.xdata$x:0000D0C2                 db 0FFh
.xdata$x:0000D0C3                 db 0FFh
.xdata$x:0000D0C4                 dd offset __unwindfunclet$??1?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ$0
.xdata$x:0000D0C8 __ehfuncinfo$??1?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ db  22h ; "
.xdata$x:0000D0C8                                         ; DATA XREF: __ehhandler$??1?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ+11o
.xdata$x:0000D0C9                 db    5
.xdata$x:0000D0CA                 db  93h ; 
.xdata$x:0000D0CB                 db  19h
.xdata$x:0000D0CC                 db    1
.xdata$x:0000D0CD                 db    0
.xdata$x:0000D0CE                 db    0
.xdata$x:0000D0CF                 db    0
.xdata$x:0000D0D0                 dd offset __unwindtable$??1?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ
.xdata$x:0000D0D4                 db    0
.xdata$x:0000D0D5                 db    0
.xdata$x:0000D0D6                 db    0
.xdata$x:0000D0D7                 db    0
.xdata$x:0000D0D8                 db    0
.xdata$x:0000D0D9                 db    0
.xdata$x:0000D0DA                 db    0
.xdata$x:0000D0DB                 db    0
.xdata$x:0000D0DC                 db    0
.xdata$x:0000D0DD                 db    0
.xdata$x:0000D0DE                 db    0
.xdata$x:0000D0DF                 db    0
.xdata$x:0000D0E0                 db    0
.xdata$x:0000D0E1                 db    0
.xdata$x:0000D0E2                 db    0
.xdata$x:0000D0E3                 db    0
.xdata$x:0000D0E4                 db    0
.xdata$x:0000D0E5                 db    0
.xdata$x:0000D0E6                 db    0
.xdata$x:0000D0E7                 db    0
.xdata$x:0000D0E8                 db    0
.xdata$x:0000D0E9                 db    0
.xdata$x:0000D0EA                 db    0
.xdata$x:0000D0EB                 db    0
.xdata$x:0000D0EB _xdata$x        ends
.xdata$x:0000D0EB
.xdata$x:0000D0EC ; ===========================================================================
.xdata$x:0000D0EC
.xdata$x:0000D0EC ; Segment type: Pure data
.xdata$x:0000D0EC ; Segment permissions: Read
.xdata$x:0000D0EC _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D0EC                 assume cs:_xdata$x
.xdata$x:0000D0EC                 ;org 0D0ECh
.xdata$x:0000D0EC ; COMDAT (pick associative to section at 616C)
.xdata$x:0000D0EC __unwindtable$??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@ABU01@@Z db 0FFh
.xdata$x:0000D0EC                                         ; DATA XREF: .xdata$x:0000D0FCo
.xdata$x:0000D0ED                 db 0FFh
.xdata$x:0000D0EE                 db 0FFh
.xdata$x:0000D0EF                 db 0FFh
.xdata$x:0000D0F0                 dd offset __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@ABU01@@Z$0
.xdata$x:0000D0F4 __ehfuncinfo$??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@ABU01@@Z db  22h ; "
.xdata$x:0000D0F4                                         ; DATA XREF: __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@ABU01@@Z+11o
.xdata$x:0000D0F5                 db    5
.xdata$x:0000D0F6                 db  93h ; 
.xdata$x:0000D0F7                 db  19h
.xdata$x:0000D0F8                 db    1
.xdata$x:0000D0F9                 db    0
.xdata$x:0000D0FA                 db    0
.xdata$x:0000D0FB                 db    0
.xdata$x:0000D0FC                 dd offset __unwindtable$??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@ABU01@@Z
.xdata$x:0000D100                 db    0
.xdata$x:0000D101                 db    0
.xdata$x:0000D102                 db    0
.xdata$x:0000D103                 db    0
.xdata$x:0000D104                 db    0
.xdata$x:0000D105                 db    0
.xdata$x:0000D106                 db    0
.xdata$x:0000D107                 db    0
.xdata$x:0000D108                 db    0
.xdata$x:0000D109                 db    0
.xdata$x:0000D10A                 db    0
.xdata$x:0000D10B                 db    0
.xdata$x:0000D10C                 db    0
.xdata$x:0000D10D                 db    0
.xdata$x:0000D10E                 db    0
.xdata$x:0000D10F                 db    0
.xdata$x:0000D110                 db    0
.xdata$x:0000D111                 db    0
.xdata$x:0000D112                 db    0
.xdata$x:0000D113                 db    0
.xdata$x:0000D114                 db    0
.xdata$x:0000D115                 db    0
.xdata$x:0000D116                 db    0
.xdata$x:0000D117                 db    0
.xdata$x:0000D117 _xdata$x        ends
.xdata$x:0000D117
.xdata$x:0000D118 ; ===========================================================================
.xdata$x:0000D118
.xdata$x:0000D118 ; Segment type: Pure data
.xdata$x:0000D118 ; Segment permissions: Read
.xdata$x:0000D118 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D118                 assume cs:_xdata$x
.xdata$x:0000D118                 ;org 0D118h
.xdata$x:0000D118 ; COMDAT (pick associative to section at 6950)
.xdata$x:0000D118 __unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z db 0FFh
.xdata$x:0000D118                                         ; DATA XREF: .xdata$x:0000D128o
.xdata$x:0000D119                 db 0FFh
.xdata$x:0000D11A                 db 0FFh
.xdata$x:0000D11B                 db 0FFh
.xdata$x:0000D11C                 dd offset __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z$0
.xdata$x:0000D120 __ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z db  22h ; "
.xdata$x:0000D120                                         ; DATA XREF: __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z+11o
.xdata$x:0000D121                 db    5
.xdata$x:0000D122                 db  93h ; 
.xdata$x:0000D123                 db  19h
.xdata$x:0000D124                 db    1
.xdata$x:0000D125                 db    0
.xdata$x:0000D126                 db    0
.xdata$x:0000D127                 db    0
.xdata$x:0000D128                 dd offset __unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z
.xdata$x:0000D12C                 db    0
.xdata$x:0000D12D                 db    0
.xdata$x:0000D12E                 db    0
.xdata$x:0000D12F                 db    0
.xdata$x:0000D130                 db    0
.xdata$x:0000D131                 db    0
.xdata$x:0000D132                 db    0
.xdata$x:0000D133                 db    0
.xdata$x:0000D134                 db    0
.xdata$x:0000D135                 db    0
.xdata$x:0000D136                 db    0
.xdata$x:0000D137                 db    0
.xdata$x:0000D138                 db    0
.xdata$x:0000D139                 db    0
.xdata$x:0000D13A                 db    0
.xdata$x:0000D13B                 db    0
.xdata$x:0000D13C                 db    0
.xdata$x:0000D13D                 db    0
.xdata$x:0000D13E                 db    0
.xdata$x:0000D13F                 db    0
.xdata$x:0000D140                 db    0
.xdata$x:0000D141                 db    0
.xdata$x:0000D142                 db    0
.xdata$x:0000D143                 db    0
.xdata$x:0000D143 _xdata$x        ends
.xdata$x:0000D143
.xdata$x:0000D144 ; ===========================================================================
.xdata$x:0000D144
.xdata$x:0000D144 ; Segment type: Pure data
.xdata$x:0000D144 ; Segment permissions: Read
.xdata$x:0000D144 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D144                 assume cs:_xdata$x
.xdata$x:0000D144                 ;org 0D144h
.xdata$x:0000D144 ; COMDAT (pick associative to section at 75E0)
.xdata$x:0000D144 __unwindtable$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000D144                                         ; DATA XREF: .xdata$x:0000D154o
.xdata$x:0000D145                 db 0FFh
.xdata$x:0000D146                 db 0FFh
.xdata$x:0000D147                 db 0FFh
.xdata$x:0000D148                 dd offset __unwindfunclet$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ$0
.xdata$x:0000D14C __ehfuncinfo$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000D14C                                         ; DATA XREF: __ehhandler$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:0000D14D                 db    5
.xdata$x:0000D14E                 db  93h ; 
.xdata$x:0000D14F                 db  19h
.xdata$x:0000D150                 db    1
.xdata$x:0000D151                 db    0
.xdata$x:0000D152                 db    0
.xdata$x:0000D153                 db    0
.xdata$x:0000D154                 dd offset __unwindtable$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
.xdata$x:0000D158                 db    0
.xdata$x:0000D159                 db    0
.xdata$x:0000D15A                 db    0
.xdata$x:0000D15B                 db    0
.xdata$x:0000D15C                 db    0
.xdata$x:0000D15D                 db    0
.xdata$x:0000D15E                 db    0
.xdata$x:0000D15F                 db    0
.xdata$x:0000D160                 db    0
.xdata$x:0000D161                 db    0
.xdata$x:0000D162                 db    0
.xdata$x:0000D163                 db    0
.xdata$x:0000D164                 db    0
.xdata$x:0000D165                 db    0
.xdata$x:0000D166                 db    0
.xdata$x:0000D167                 db    0
.xdata$x:0000D168                 db    0
.xdata$x:0000D169                 db    0
.xdata$x:0000D16A                 db    0
.xdata$x:0000D16B                 db    0
.xdata$x:0000D16C                 db    0
.xdata$x:0000D16D                 db    0
.xdata$x:0000D16E                 db    0
.xdata$x:0000D16F                 db    0
.xdata$x:0000D16F _xdata$x        ends
.xdata$x:0000D16F
.xdata$x:0000D170 ; ===========================================================================
.xdata$x:0000D170
.xdata$x:0000D170 ; Segment type: Pure data
.xdata$x:0000D170 ; Segment permissions: Read
.xdata$x:0000D170 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D170                 assume cs:_xdata$x
.xdata$x:0000D170                 ;org 0D170h
.xdata$x:0000D170 ; COMDAT (pick associative to section at 68CC)
.xdata$x:0000D170 __unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z db 0FFh
.xdata$x:0000D170                                         ; DATA XREF: .xdata$x:0000D180o
.xdata$x:0000D171                 db 0FFh
.xdata$x:0000D172                 db 0FFh
.xdata$x:0000D173                 db 0FFh
.xdata$x:0000D174                 dd offset __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z$0
.xdata$x:0000D178 __ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z db  22h ; "
.xdata$x:0000D178                                         ; DATA XREF: __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z+11o
.xdata$x:0000D179                 db    5
.xdata$x:0000D17A                 db  93h ; 
.xdata$x:0000D17B                 db  19h
.xdata$x:0000D17C                 db    1
.xdata$x:0000D17D                 db    0
.xdata$x:0000D17E                 db    0
.xdata$x:0000D17F                 db    0
.xdata$x:0000D180                 dd offset __unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z
.xdata$x:0000D184                 db    0
.xdata$x:0000D185                 db    0
.xdata$x:0000D186                 db    0
.xdata$x:0000D187                 db    0
.xdata$x:0000D188                 db    0
.xdata$x:0000D189                 db    0
.xdata$x:0000D18A                 db    0
.xdata$x:0000D18B                 db    0
.xdata$x:0000D18C                 db    0
.xdata$x:0000D18D                 db    0
.xdata$x:0000D18E                 db    0
.xdata$x:0000D18F                 db    0
.xdata$x:0000D190                 db    0
.xdata$x:0000D191                 db    0
.xdata$x:0000D192                 db    0
.xdata$x:0000D193                 db    0
.xdata$x:0000D194                 db    0
.xdata$x:0000D195                 db    0
.xdata$x:0000D196                 db    0
.xdata$x:0000D197                 db    0
.xdata$x:0000D198                 db    0
.xdata$x:0000D199                 db    0
.xdata$x:0000D19A                 db    0
.xdata$x:0000D19B                 db    0
.xdata$x:0000D19B _xdata$x        ends
.xdata$x:0000D19B
.xdata$x:0000D19C ; ===========================================================================
.xdata$x:0000D19C
.xdata$x:0000D19C ; Segment type: Pure data
.xdata$x:0000D19C ; Segment permissions: Read
.xdata$x:0000D19C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D19C                 assume cs:_xdata$x
.xdata$x:0000D19C                 ;org 0D19Ch
.xdata$x:0000D19C ; COMDAT (pick associative to section at 6A54)
.xdata$x:0000D19C __unwindtable$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z db 0FFh
.xdata$x:0000D19C                                         ; DATA XREF: .xdata$x:0000D1ACo
.xdata$x:0000D19D                 db 0FFh
.xdata$x:0000D19E                 db 0FFh
.xdata$x:0000D19F                 db 0FFh
.xdata$x:0000D1A0                 dd offset __unwindfunclet$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z$0
.xdata$x:0000D1A4 __ehfuncinfo$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z db  22h ; "
.xdata$x:0000D1A4                                         ; DATA XREF: __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z+11o
.xdata$x:0000D1A5                 db    5
.xdata$x:0000D1A6                 db  93h ; 
.xdata$x:0000D1A7                 db  19h
.xdata$x:0000D1A8                 db    1
.xdata$x:0000D1A9                 db    0
.xdata$x:0000D1AA                 db    0
.xdata$x:0000D1AB                 db    0
.xdata$x:0000D1AC                 dd offset __unwindtable$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z
.xdata$x:0000D1B0                 db    0
.xdata$x:0000D1B1                 db    0
.xdata$x:0000D1B2                 db    0
.xdata$x:0000D1B3                 db    0
.xdata$x:0000D1B4                 db    0
.xdata$x:0000D1B5                 db    0
.xdata$x:0000D1B6                 db    0
.xdata$x:0000D1B7                 db    0
.xdata$x:0000D1B8                 db    0
.xdata$x:0000D1B9                 db    0
.xdata$x:0000D1BA                 db    0
.xdata$x:0000D1BB                 db    0
.xdata$x:0000D1BC                 db    0
.xdata$x:0000D1BD                 db    0
.xdata$x:0000D1BE                 db    0
.xdata$x:0000D1BF                 db    0
.xdata$x:0000D1C0                 db    0
.xdata$x:0000D1C1                 db    0
.xdata$x:0000D1C2                 db    0
.xdata$x:0000D1C3                 db    0
.xdata$x:0000D1C4                 db    0
.xdata$x:0000D1C5                 db    0
.xdata$x:0000D1C6                 db    0
.xdata$x:0000D1C7                 db    0
.xdata$x:0000D1C7 _xdata$x        ends
.xdata$x:0000D1C7
.xdata$x:0000D1C8 ; ===========================================================================
.xdata$x:0000D1C8
.xdata$x:0000D1C8 ; Segment type: Pure data
.xdata$x:0000D1C8 ; Segment permissions: Read
.xdata$x:0000D1C8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D1C8                 assume cs:_xdata$x
.xdata$x:0000D1C8                 ;org 0D1C8h
.xdata$x:0000D1C8 ; COMDAT (pick associative to section at 7650)
.xdata$x:0000D1C8 __unwindtable$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000D1C8                                         ; DATA XREF: .xdata$x:0000D1D8o
.xdata$x:0000D1C9                 db 0FFh
.xdata$x:0000D1CA                 db 0FFh
.xdata$x:0000D1CB                 db 0FFh
.xdata$x:0000D1CC                 dd offset __unwindfunclet$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ$0
.xdata$x:0000D1D0 __ehfuncinfo$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000D1D0                                         ; DATA XREF: __ehhandler$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:0000D1D1                 db    5
.xdata$x:0000D1D2                 db  93h ; 
.xdata$x:0000D1D3                 db  19h
.xdata$x:0000D1D4                 db    1
.xdata$x:0000D1D5                 db    0
.xdata$x:0000D1D6                 db    0
.xdata$x:0000D1D7                 db    0
.xdata$x:0000D1D8                 dd offset __unwindtable$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
.xdata$x:0000D1DC                 db    0
.xdata$x:0000D1DD                 db    0
.xdata$x:0000D1DE                 db    0
.xdata$x:0000D1DF                 db    0
.xdata$x:0000D1E0                 db    0
.xdata$x:0000D1E1                 db    0
.xdata$x:0000D1E2                 db    0
.xdata$x:0000D1E3                 db    0
.xdata$x:0000D1E4                 db    0
.xdata$x:0000D1E5                 db    0
.xdata$x:0000D1E6                 db    0
.xdata$x:0000D1E7                 db    0
.xdata$x:0000D1E8                 db    0
.xdata$x:0000D1E9                 db    0
.xdata$x:0000D1EA                 db    0
.xdata$x:0000D1EB                 db    0
.xdata$x:0000D1EC                 db    0
.xdata$x:0000D1ED                 db    0
.xdata$x:0000D1EE                 db    0
.xdata$x:0000D1EF                 db    0
.xdata$x:0000D1F0                 db    0
.xdata$x:0000D1F1                 db    0
.xdata$x:0000D1F2                 db    0
.xdata$x:0000D1F3                 db    0
.xdata$x:0000D1F3 _xdata$x        ends
.xdata$x:0000D1F3
.xdata$x:0000D1F4 ; ===========================================================================
.xdata$x:0000D1F4
.xdata$x:0000D1F4 ; Segment type: Pure data
.xdata$x:0000D1F4 ; Segment permissions: Read
.xdata$x:0000D1F4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D1F4                 assume cs:_xdata$x
.xdata$x:0000D1F4                 ;org 0D1F4h
.xdata$x:0000D1F4 ; COMDAT (pick associative to section at 69DC)
.xdata$x:0000D1F4 __unwindtable$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z db 0FFh
.xdata$x:0000D1F4                                         ; DATA XREF: .xdata$x:0000D204o
.xdata$x:0000D1F5                 db 0FFh
.xdata$x:0000D1F6                 db 0FFh
.xdata$x:0000D1F7                 db 0FFh
.xdata$x:0000D1F8                 dd offset __unwindfunclet$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z$0
.xdata$x:0000D1FC __ehfuncinfo$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z db  22h ; "
.xdata$x:0000D1FC                                         ; DATA XREF: __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z+11o
.xdata$x:0000D1FD                 db    5
.xdata$x:0000D1FE                 db  93h ; 
.xdata$x:0000D1FF                 db  19h
.xdata$x:0000D200                 db    1
.xdata$x:0000D201                 db    0
.xdata$x:0000D202                 db    0
.xdata$x:0000D203                 db    0
.xdata$x:0000D204                 dd offset __unwindtable$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z
.xdata$x:0000D208                 align 20h
.xdata$x:0000D208 _xdata$x        ends
.xdata$x:0000D208
.xdata$x:0000D220 ; ===========================================================================
.xdata$x:0000D220
.xdata$x:0000D220 ; Segment type: Pure data
.xdata$x:0000D220 ; Segment permissions: Read
.xdata$x:0000D220 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D220                 assume cs:_xdata$x
.xdata$x:0000D220                 ;org 0D220h
.xdata$x:0000D220 ; COMDAT (pick associative to section at 5EAC)
.xdata$x:0000D220 __ehfuncinfo$??$stable_sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@UBufferEquivalent@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0UBufferEquivalent@@@Z db  22h ; "
.xdata$x:0000D220                                         ; DATA XREF: __ehhandler$??$stable_sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@UBufferEquivalent@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0UBufferEquivalent@@@Z+11o
.xdata$x:0000D221                 db    5
.xdata$x:0000D222                 db  93h ; 
.xdata$x:0000D223                 db  19h
.xdata$x:0000D224                 db    8
.xdata$x:0000D225                 db    0
.xdata$x:0000D226                 db    0
.xdata$x:0000D227                 db    0
.xdata$x:0000D228                 dd offset __unwindtable$??$stable_sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@UBufferEquivalent@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0UBufferEquivalent@@@Z
.xdata$x:0000D22C                 db    0
.xdata$x:0000D22D                 db    0
.xdata$x:0000D22E                 db    0
.xdata$x:0000D22F                 db    0
.xdata$x:0000D230                 db    0
.xdata$x:0000D231                 db    0
.xdata$x:0000D232                 db    0
.xdata$x:0000D233                 db    0
.xdata$x:0000D234                 db    0
.xdata$x:0000D235                 db    0
.xdata$x:0000D236                 db    0
.xdata$x:0000D237                 db    0
.xdata$x:0000D238                 db    0
.xdata$x:0000D239                 db    0
.xdata$x:0000D23A                 db    0
.xdata$x:0000D23B                 db    0
.xdata$x:0000D23C                 db    0
.xdata$x:0000D23D                 db    0
.xdata$x:0000D23E                 db    0
.xdata$x:0000D23F                 db    0
.xdata$x:0000D240                 db    0
.xdata$x:0000D241                 db    0
.xdata$x:0000D242                 db    0
.xdata$x:0000D243                 db    0
.xdata$x:0000D244 __unwindtable$??$stable_sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@UBufferEquivalent@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0UBufferEquivalent@@@Z db 0FFh
.xdata$x:0000D244                                         ; DATA XREF: .xdata$x:0000D228o
.xdata$x:0000D245                 db 0FFh
.xdata$x:0000D246                 db 0FFh
.xdata$x:0000D247                 db 0FFh
.xdata$x:0000D248                 dd offset __unwindfunclet$??$stable_sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@UBufferEquivalent@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0UBufferEquivalent@@@Z$0
.xdata$x:0000D24C                 align 10h
.xdata$x:0000D250                 dd offset __unwindfunclet$??$stable_sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@UBufferEquivalent@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0UBufferEquivalent@@@Z$1
.xdata$x:0000D254                 db    1
.xdata$x:0000D255                 db    0
.xdata$x:0000D256                 db    0
.xdata$x:0000D257                 db    0
.xdata$x:0000D258                 dd offset __unwindfunclet$??$stable_sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@UBufferEquivalent@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0UBufferEquivalent@@@Z$2
.xdata$x:0000D25C                 db    2
.xdata$x:0000D25D                 db    0
.xdata$x:0000D25E                 db    0
.xdata$x:0000D25F                 db    0
.xdata$x:0000D260                 dd offset __unwindfunclet$??$stable_sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@UBufferEquivalent@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0UBufferEquivalent@@@Z$3
.xdata$x:0000D264                 db    1
.xdata$x:0000D265                 db    0
.xdata$x:0000D266                 db    0
.xdata$x:0000D267                 db    0
.xdata$x:0000D268                 dd offset __unwindfunclet$??$stable_sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@UBufferEquivalent@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0UBufferEquivalent@@@Z$4
.xdata$x:0000D26C                 db    1
.xdata$x:0000D26D                 db    0
.xdata$x:0000D26E                 db    0
.xdata$x:0000D26F                 db    0
.xdata$x:0000D270                 dd offset __unwindfunclet$??$stable_sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@UBufferEquivalent@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0UBufferEquivalent@@@Z$5
.xdata$x:0000D274                 db    1
.xdata$x:0000D275                 db    0
.xdata$x:0000D276                 db    0
.xdata$x:0000D277                 db    0
.xdata$x:0000D278                 dd offset __unwindfunclet$??$stable_sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@UBufferEquivalent@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0UBufferEquivalent@@@Z$6
.xdata$x:0000D27C                 db    1
.xdata$x:0000D27D                 db    0
.xdata$x:0000D27E                 db    0
.xdata$x:0000D27F                 db    0
.xdata$x:0000D280                 dd offset __unwindfunclet$??$stable_sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@UBufferEquivalent@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0UBufferEquivalent@@@Z$7
.xdata$x:0000D280 _xdata$x        ends
.xdata$x:0000D280
.xdata$x:0000D284 ; ===========================================================================
.xdata$x:0000D284
.xdata$x:0000D284 ; Segment type: Pure data
.xdata$x:0000D284 ; Segment permissions: Read
.xdata$x:0000D284 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D284                 assume cs:_xdata$x
.xdata$x:0000D284                 ;org 0D284h
.xdata$x:0000D284 ; COMDAT (pick associative to section at 5BA4)
.xdata$x:0000D284 __ehfuncinfo$??$remove_if@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@V?$binder2nd@U?$equal_to@H@std@@@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0V?$binder2nd@U?$equal_to@H@std@@@0@@Z db  22h ; "
.xdata$x:0000D284                                         ; DATA XREF: __ehhandler$??$remove_if@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@V?$binder2nd@U?$equal_to@H@std@@@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0V?$binder2nd@U?$equal_to@H@std@@@0@@Z+11o
.xdata$x:0000D285                 db    5
.xdata$x:0000D286                 db  93h ; 
.xdata$x:0000D287                 db  19h
.xdata$x:0000D288                 db    8
.xdata$x:0000D289                 db    0
.xdata$x:0000D28A                 db    0
.xdata$x:0000D28B                 db    0
.xdata$x:0000D28C                 dd offset __unwindtable$??$remove_if@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@V?$binder2nd@U?$equal_to@H@std@@@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0V?$binder2nd@U?$equal_to@H@std@@@0@@Z
.xdata$x:0000D290                 db    0
.xdata$x:0000D291                 db    0
.xdata$x:0000D292                 db    0
.xdata$x:0000D293                 db    0
.xdata$x:0000D294                 db    0
.xdata$x:0000D295                 db    0
.xdata$x:0000D296                 db    0
.xdata$x:0000D297                 db    0
.xdata$x:0000D298                 db    0
.xdata$x:0000D299                 db    0
.xdata$x:0000D29A                 db    0
.xdata$x:0000D29B                 db    0
.xdata$x:0000D29C                 db    0
.xdata$x:0000D29D                 db    0
.xdata$x:0000D29E                 db    0
.xdata$x:0000D29F                 db    0
.xdata$x:0000D2A0                 db    0
.xdata$x:0000D2A1                 db    0
.xdata$x:0000D2A2                 db    0
.xdata$x:0000D2A3                 db    0
.xdata$x:0000D2A4                 db    0
.xdata$x:0000D2A5                 db    0
.xdata$x:0000D2A6                 db    0
.xdata$x:0000D2A7                 db    0
.xdata$x:0000D2A8 __unwindtable$??$remove_if@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@V?$binder2nd@U?$equal_to@H@std@@@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0V?$binder2nd@U?$equal_to@H@std@@@0@@Z db 0FFh
.xdata$x:0000D2A8                                         ; DATA XREF: .xdata$x:0000D28Co
.xdata$x:0000D2A9                 db 0FFh
.xdata$x:0000D2AA                 db 0FFh
.xdata$x:0000D2AB                 db 0FFh
.xdata$x:0000D2AC                 dd offset __unwindfunclet$??$remove_if@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@V?$binder2nd@U?$equal_to@H@std@@@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0V?$binder2nd@U?$equal_to@H@std@@@0@@Z$5
.xdata$x:0000D2B0                 db    0
.xdata$x:0000D2B1                 db    0
.xdata$x:0000D2B2                 db    0
.xdata$x:0000D2B3                 db    0
.xdata$x:0000D2B4                 dd offset __unwindfunclet$??$remove_if@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@V?$binder2nd@U?$equal_to@H@std@@@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0V?$binder2nd@U?$equal_to@H@std@@@0@@Z$0
.xdata$x:0000D2B8                 db    1
.xdata$x:0000D2B9                 db    0
.xdata$x:0000D2BA                 db    0
.xdata$x:0000D2BB                 db    0
.xdata$x:0000D2BC                 dd offset __unwindfunclet$??$remove_if@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@V?$binder2nd@U?$equal_to@H@std@@@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0V?$binder2nd@U?$equal_to@H@std@@@0@@Z$1
.xdata$x:0000D2C0                 db    2
.xdata$x:0000D2C1                 db    0
.xdata$x:0000D2C2                 db    0
.xdata$x:0000D2C3                 db    0
.xdata$x:0000D2C4                 dd offset __unwindfunclet$??$remove_if@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@V?$binder2nd@U?$equal_to@H@std@@@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0V?$binder2nd@U?$equal_to@H@std@@@0@@Z$2
.xdata$x:0000D2C8                 db    3
.xdata$x:0000D2C9                 db    0
.xdata$x:0000D2CA                 db    0
.xdata$x:0000D2CB                 db    0
.xdata$x:0000D2CC                 dd offset __unwindfunclet$??$remove_if@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@V?$binder2nd@U?$equal_to@H@std@@@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0V?$binder2nd@U?$equal_to@H@std@@@0@@Z$3
.xdata$x:0000D2D0                 db    2
.xdata$x:0000D2D1                 db    0
.xdata$x:0000D2D2                 db    0
.xdata$x:0000D2D3                 db    0
.xdata$x:0000D2D4                 dd offset __unwindfunclet$??$remove_if@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@V?$binder2nd@U?$equal_to@H@std@@@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0V?$binder2nd@U?$equal_to@H@std@@@0@@Z$4
.xdata$x:0000D2D8                 db    2
.xdata$x:0000D2D9                 db    0
.xdata$x:0000D2DA                 db    0
.xdata$x:0000D2DB                 db    0
.xdata$x:0000D2DC                 dd offset __unwindfunclet$??$remove_if@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@V?$binder2nd@U?$equal_to@H@std@@@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0V?$binder2nd@U?$equal_to@H@std@@@0@@Z$6
.xdata$x:0000D2E0                 db    2
.xdata$x:0000D2E1                 db    0
.xdata$x:0000D2E2                 db    0
.xdata$x:0000D2E3                 db    0
.xdata$x:0000D2E4                 dd offset __unwindfunclet$??$remove_if@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@V?$binder2nd@U?$equal_to@H@std@@@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0V?$binder2nd@U?$equal_to@H@std@@@0@@Z$7
.xdata$x:0000D2E4 _xdata$x        ends
.xdata$x:0000D2E4
.xdata$x:0000D2E8 ; ===========================================================================
.xdata$x:0000D2E8
.xdata$x:0000D2E8 ; Segment type: Pure data
.xdata$x:0000D2E8 ; Segment permissions: Read
.xdata$x:0000D2E8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D2E8                 assume cs:_xdata$x
.xdata$x:0000D2E8                 ;org 0D2E8h
.xdata$x:0000D2E8 ; COMDAT (pick associative to section at 62D0)
.xdata$x:0000D2E8 __unwindtable$??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ db 0FFh
.xdata$x:0000D2E8                                         ; DATA XREF: .xdata$x:0000D2F8o
.xdata$x:0000D2E9                 db 0FFh
.xdata$x:0000D2EA                 db 0FFh
.xdata$x:0000D2EB                 db 0FFh
.xdata$x:0000D2EC                 dd offset __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ$0
.xdata$x:0000D2F0 __ehfuncinfo$??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ db  22h ; "
.xdata$x:0000D2F0                                         ; DATA XREF: __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ+11o
.xdata$x:0000D2F1                 db    5
.xdata$x:0000D2F2                 db  93h ; 
.xdata$x:0000D2F3                 db  19h
.xdata$x:0000D2F4                 db    1
.xdata$x:0000D2F5                 db    0
.xdata$x:0000D2F6                 db    0
.xdata$x:0000D2F7                 db    0
.xdata$x:0000D2F8                 dd offset __unwindtable$??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ
.xdata$x:0000D2FC                 db    0
.xdata$x:0000D2FD                 db    0
.xdata$x:0000D2FE                 db    0
.xdata$x:0000D2FF                 db    0
.xdata$x:0000D300                 db    0
.xdata$x:0000D301                 db    0
.xdata$x:0000D302                 db    0
.xdata$x:0000D303                 db    0
.xdata$x:0000D304                 db    0
.xdata$x:0000D305                 db    0
.xdata$x:0000D306                 db    0
.xdata$x:0000D307                 db    0
.xdata$x:0000D308                 db    0
.xdata$x:0000D309                 db    0
.xdata$x:0000D30A                 db    0
.xdata$x:0000D30B                 db    0
.xdata$x:0000D30C                 db    0
.xdata$x:0000D30D                 db    0
.xdata$x:0000D30E                 db    0
.xdata$x:0000D30F                 db    0
.xdata$x:0000D310                 db    0
.xdata$x:0000D311                 db    0
.xdata$x:0000D312                 db    0
.xdata$x:0000D313                 db    0
.xdata$x:0000D313 _xdata$x        ends
.xdata$x:0000D313
.xdata$x:0000D314 ; ===========================================================================
.xdata$x:0000D314
.xdata$x:0000D314 ; Segment type: Pure data
.xdata$x:0000D314 ; Segment permissions: Read
.xdata$x:0000D314 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D314                 assume cs:_xdata$x
.xdata$x:0000D314                 ;org 0D314h
.xdata$x:0000D314 ; COMDAT (pick associative to section at 7180)
.xdata$x:0000D314 __unwindtable$??1?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ db 0FFh
.xdata$x:0000D314                                         ; DATA XREF: .xdata$x:0000D324o
.xdata$x:0000D315                 db 0FFh
.xdata$x:0000D316                 db 0FFh
.xdata$x:0000D317                 db 0FFh
.xdata$x:0000D318                 dd offset __unwindfunclet$??1?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ$0
.xdata$x:0000D31C __ehfuncinfo$??1?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ db  22h ; "
.xdata$x:0000D31C                                         ; DATA XREF: __ehhandler$??1?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ+11o
.xdata$x:0000D31D                 db    5
.xdata$x:0000D31E                 db  93h ; 
.xdata$x:0000D31F                 db  19h
.xdata$x:0000D320                 db    1
.xdata$x:0000D321                 db    0
.xdata$x:0000D322                 db    0
.xdata$x:0000D323                 db    0
.xdata$x:0000D324                 dd offset __unwindtable$??1?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ
.xdata$x:0000D328                 align 20h
.xdata$x:0000D328 _xdata$x        ends
.xdata$x:0000D328
.xdata$x:0000D340 ; ===========================================================================
.xdata$x:0000D340
.xdata$x:0000D340 ; Segment type: Pure data
.xdata$x:0000D340 ; Segment permissions: Read
.xdata$x:0000D340 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D340                 assume cs:_xdata$x
.xdata$x:0000D340                 ;org 0D340h
.xdata$x:0000D340 ; COMDAT (pick associative to section at 6258)
.xdata$x:0000D340 __unwindtable$??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@ABU01@@Z db 0FFh
.xdata$x:0000D340                                         ; DATA XREF: .xdata$x:0000D350o
.xdata$x:0000D341                 db 0FFh
.xdata$x:0000D342                 db 0FFh
.xdata$x:0000D343                 db 0FFh
.xdata$x:0000D344                 dd offset __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@ABU01@@Z$0
.xdata$x:0000D348 __ehfuncinfo$??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@ABU01@@Z db  22h ; "
.xdata$x:0000D348                                         ; DATA XREF: __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@ABU01@@Z+11o
.xdata$x:0000D349                 db    5
.xdata$x:0000D34A                 db  93h ; 
.xdata$x:0000D34B                 db  19h
.xdata$x:0000D34C                 db    1
.xdata$x:0000D34D                 db    0
.xdata$x:0000D34E                 db    0
.xdata$x:0000D34F                 db    0
.xdata$x:0000D350                 dd offset __unwindtable$??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@ABU01@@Z
.xdata$x:0000D354                 db    0
.xdata$x:0000D355                 db    0
.xdata$x:0000D356                 db    0
.xdata$x:0000D357                 db    0
.xdata$x:0000D358                 db    0
.xdata$x:0000D359                 db    0
.xdata$x:0000D35A                 db    0
.xdata$x:0000D35B                 db    0
.xdata$x:0000D35C                 db    0
.xdata$x:0000D35D                 db    0
.xdata$x:0000D35E                 db    0
.xdata$x:0000D35F                 db    0
.xdata$x:0000D360                 db    0
.xdata$x:0000D361                 db    0
.xdata$x:0000D362                 db    0
.xdata$x:0000D363                 db    0
.xdata$x:0000D364                 db    0
.xdata$x:0000D365                 db    0
.xdata$x:0000D366                 db    0
.xdata$x:0000D367                 db    0
.xdata$x:0000D368                 db    0
.xdata$x:0000D369                 db    0
.xdata$x:0000D36A                 db    0
.xdata$x:0000D36B                 db    0
.xdata$x:0000D36B _xdata$x        ends
.xdata$x:0000D36B
.xdata$x:0000D36C ; ===========================================================================
.xdata$x:0000D36C
.xdata$x:0000D36C ; Segment type: Pure data
.xdata$x:0000D36C ; Segment permissions: Read
.xdata$x:0000D36C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D36C                 assume cs:_xdata$x
.xdata$x:0000D36C                 ;org 0D36Ch
.xdata$x:0000D36C ; COMDAT (pick associative to section at 64C0)
.xdata$x:0000D36C __unwindtable$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PB_WPBU_Container_base12@1@@Z db 0FFh
.xdata$x:0000D36C                                         ; DATA XREF: .xdata$x:0000D37Co
.xdata$x:0000D36D                 db 0FFh
.xdata$x:0000D36E                 db 0FFh
.xdata$x:0000D36F                 db 0FFh
.xdata$x:0000D370                 dd offset __unwindfunclet$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PB_WPBU_Container_base12@1@@Z$0
.xdata$x:0000D374 __ehfuncinfo$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PB_WPBU_Container_base12@1@@Z db  22h ; "
.xdata$x:0000D374                                         ; DATA XREF: __ehhandler$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PB_WPBU_Container_base12@1@@Z+11o
.xdata$x:0000D375                 db    5
.xdata$x:0000D376                 db  93h ; 
.xdata$x:0000D377                 db  19h
.xdata$x:0000D378                 db    1
.xdata$x:0000D379                 db    0
.xdata$x:0000D37A                 db    0
.xdata$x:0000D37B                 db    0
.xdata$x:0000D37C                 dd offset __unwindtable$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PB_WPBU_Container_base12@1@@Z
.xdata$x:0000D380                 db    0
.xdata$x:0000D381                 db    0
.xdata$x:0000D382                 db    0
.xdata$x:0000D383                 db    0
.xdata$x:0000D384                 db    0
.xdata$x:0000D385                 db    0
.xdata$x:0000D386                 db    0
.xdata$x:0000D387                 db    0
.xdata$x:0000D388                 db    0
.xdata$x:0000D389                 db    0
.xdata$x:0000D38A                 db    0
.xdata$x:0000D38B                 db    0
.xdata$x:0000D38C                 db    0
.xdata$x:0000D38D                 db    0
.xdata$x:0000D38E                 db    0
.xdata$x:0000D38F                 db    0
.xdata$x:0000D390                 db    0
.xdata$x:0000D391                 db    0
.xdata$x:0000D392                 db    0
.xdata$x:0000D393                 db    0
.xdata$x:0000D394                 db    0
.xdata$x:0000D395                 db    0
.xdata$x:0000D396                 db    0
.xdata$x:0000D397                 db    0
.xdata$x:0000D397 _xdata$x        ends
.xdata$x:0000D397
.xdata$x:0000D398 ; ===========================================================================
.xdata$x:0000D398
.xdata$x:0000D398 ; Segment type: Pure data
.xdata$x:0000D398 ; Segment permissions: Read
.xdata$x:0000D398 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D398                 assume cs:_xdata$x
.xdata$x:0000D398                 ;org 0D398h
.xdata$x:0000D398 ; COMDAT (pick associative to section at 72E0)
.xdata$x:0000D398 __unwindtable$??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000D398                                         ; DATA XREF: .xdata$x:0000D3A8o
.xdata$x:0000D399                 db 0FFh
.xdata$x:0000D39A                 db 0FFh
.xdata$x:0000D39B                 db 0FFh
.xdata$x:0000D39C                 dd offset __unwindfunclet$??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ$0
.xdata$x:0000D3A0 __ehfuncinfo$??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000D3A0                                         ; DATA XREF: __ehhandler$??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:0000D3A1                 db    5
.xdata$x:0000D3A2                 db  93h ; 
.xdata$x:0000D3A3                 db  19h
.xdata$x:0000D3A4                 db    1
.xdata$x:0000D3A5                 db    0
.xdata$x:0000D3A6                 db    0
.xdata$x:0000D3A7                 db    0
.xdata$x:0000D3A8                 dd offset __unwindtable$??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ
.xdata$x:0000D3AC                 db    0
.xdata$x:0000D3AD                 db    0
.xdata$x:0000D3AE                 db    0
.xdata$x:0000D3AF                 db    0
.xdata$x:0000D3B0                 db    0
.xdata$x:0000D3B1                 db    0
.xdata$x:0000D3B2                 db    0
.xdata$x:0000D3B3                 db    0
.xdata$x:0000D3B4                 db    0
.xdata$x:0000D3B5                 db    0
.xdata$x:0000D3B6                 db    0
.xdata$x:0000D3B7                 db    0
.xdata$x:0000D3B8                 db    0
.xdata$x:0000D3B9                 db    0
.xdata$x:0000D3BA                 db    0
.xdata$x:0000D3BB                 db    0
.xdata$x:0000D3BC                 db    0
.xdata$x:0000D3BD                 db    0
.xdata$x:0000D3BE                 db    0
.xdata$x:0000D3BF                 db    0
.xdata$x:0000D3C0                 db    0
.xdata$x:0000D3C1                 db    0
.xdata$x:0000D3C2                 db    0
.xdata$x:0000D3C3                 db    0
.xdata$x:0000D3C3 _xdata$x        ends
.xdata$x:0000D3C3
.xdata$x:0000D3C4 ; ===========================================================================
.xdata$x:0000D3C4
.xdata$x:0000D3C4 ; Segment type: Pure data
.xdata$x:0000D3C4 ; Segment permissions: Read
.xdata$x:0000D3C4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D3C4                 assume cs:_xdata$x
.xdata$x:0000D3C4                 ;org 0D3C4h
.xdata$x:0000D3C4 ; COMDAT (pick associative to section at 643C)
.xdata$x:0000D3C4 __unwindtable$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z db 0FFh
.xdata$x:0000D3C4                                         ; DATA XREF: .xdata$x:0000D3D4o
.xdata$x:0000D3C5                 db 0FFh
.xdata$x:0000D3C6                 db 0FFh
.xdata$x:0000D3C7                 db 0FFh
.xdata$x:0000D3C8                 dd offset __unwindfunclet$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z$0
.xdata$x:0000D3CC __ehfuncinfo$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z db  22h ; "
.xdata$x:0000D3CC                                         ; DATA XREF: __ehhandler$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z+11o
.xdata$x:0000D3CD                 db    5
.xdata$x:0000D3CE                 db  93h ; 
.xdata$x:0000D3CF                 db  19h
.xdata$x:0000D3D0                 db    1
.xdata$x:0000D3D1                 db    0
.xdata$x:0000D3D2                 db    0
.xdata$x:0000D3D3                 db    0
.xdata$x:0000D3D4                 dd offset __unwindtable$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z
.xdata$x:0000D3D8                 db    0
.xdata$x:0000D3D9                 db    0
.xdata$x:0000D3DA                 db    0
.xdata$x:0000D3DB                 db    0
.xdata$x:0000D3DC                 db    0
.xdata$x:0000D3DD                 db    0
.xdata$x:0000D3DE                 db    0
.xdata$x:0000D3DF                 db    0
.xdata$x:0000D3E0                 db    0
.xdata$x:0000D3E1                 db    0
.xdata$x:0000D3E2                 db    0
.xdata$x:0000D3E3                 db    0
.xdata$x:0000D3E4                 db    0
.xdata$x:0000D3E5                 db    0
.xdata$x:0000D3E6                 db    0
.xdata$x:0000D3E7                 db    0
.xdata$x:0000D3E8                 db    0
.xdata$x:0000D3E9                 db    0
.xdata$x:0000D3EA                 db    0
.xdata$x:0000D3EB                 db    0
.xdata$x:0000D3EC                 db    0
.xdata$x:0000D3ED                 db    0
.xdata$x:0000D3EE                 db    0
.xdata$x:0000D3EF                 db    0
.xdata$x:0000D3EF _xdata$x        ends
.xdata$x:0000D3EF
.xdata$x:0000D3F0 ; ===========================================================================
.xdata$x:0000D3F0
.xdata$x:0000D3F0 ; Segment type: Pure data
.xdata$x:0000D3F0 ; Segment permissions: Read
.xdata$x:0000D3F0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D3F0                 assume cs:_xdata$x
.xdata$x:0000D3F0                 ;org 0D3F0h
.xdata$x:0000D3F0 ; COMDAT (pick associative to section at 65C4)
.xdata$x:0000D3F0 __unwindtable$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base12@1@@Z db 0FFh
.xdata$x:0000D3F0                                         ; DATA XREF: .xdata$x:0000D400o
.xdata$x:0000D3F1                 db 0FFh
.xdata$x:0000D3F2                 db 0FFh
.xdata$x:0000D3F3                 db 0FFh
.xdata$x:0000D3F4                 dd offset __unwindfunclet$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base12@1@@Z$0
.xdata$x:0000D3F8 __ehfuncinfo$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base12@1@@Z db  22h ; "
.xdata$x:0000D3F8                                         ; DATA XREF: __ehhandler$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base12@1@@Z+11o
.xdata$x:0000D3F9                 db    5
.xdata$x:0000D3FA                 db  93h ; 
.xdata$x:0000D3FB                 db  19h
.xdata$x:0000D3FC                 db    1
.xdata$x:0000D3FD                 db    0
.xdata$x:0000D3FE                 db    0
.xdata$x:0000D3FF                 db    0
.xdata$x:0000D400                 dd offset __unwindtable$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base12@1@@Z
.xdata$x:0000D404                 db    0
.xdata$x:0000D405                 db    0
.xdata$x:0000D406                 db    0
.xdata$x:0000D407                 db    0
.xdata$x:0000D408                 db    0
.xdata$x:0000D409                 db    0
.xdata$x:0000D40A                 db    0
.xdata$x:0000D40B                 db    0
.xdata$x:0000D40C                 db    0
.xdata$x:0000D40D                 db    0
.xdata$x:0000D40E                 db    0
.xdata$x:0000D40F                 db    0
.xdata$x:0000D410                 db    0
.xdata$x:0000D411                 db    0
.xdata$x:0000D412                 db    0
.xdata$x:0000D413                 db    0
.xdata$x:0000D414                 db    0
.xdata$x:0000D415                 db    0
.xdata$x:0000D416                 db    0
.xdata$x:0000D417                 db    0
.xdata$x:0000D418                 db    0
.xdata$x:0000D419                 db    0
.xdata$x:0000D41A                 db    0
.xdata$x:0000D41B                 db    0
.xdata$x:0000D41B _xdata$x        ends
.xdata$x:0000D41B
.xdata$x:0000D41C ; ===========================================================================
.xdata$x:0000D41C
.xdata$x:0000D41C ; Segment type: Pure data
.xdata$x:0000D41C ; Segment permissions: Read
.xdata$x:0000D41C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D41C                 assume cs:_xdata$x
.xdata$x:0000D41C                 ;org 0D41Ch
.xdata$x:0000D41C ; COMDAT (pick associative to section at 8394)
.xdata$x:0000D41C __unwindtable$??G?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEHABV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@@Z db 0FFh
.xdata$x:0000D41C                                         ; DATA XREF: .xdata$x:0000D42Co
.xdata$x:0000D41D                 db 0FFh
.xdata$x:0000D41E                 db 0FFh
.xdata$x:0000D41F                 db 0FFh
.xdata$x:0000D420                 dd offset __unwindfunclet$??G?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEHABV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@@Z$0
.xdata$x:0000D424 __ehfuncinfo$??G?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEHABV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@@Z db  22h ; "
.xdata$x:0000D424                                         ; DATA XREF: __ehhandler$??G?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEHABV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@@Z+11o
.xdata$x:0000D425                 db    5
.xdata$x:0000D426                 db  93h ; 
.xdata$x:0000D427                 db  19h
.xdata$x:0000D428                 db    1
.xdata$x:0000D429                 db    0
.xdata$x:0000D42A                 db    0
.xdata$x:0000D42B                 db    0
.xdata$x:0000D42C                 dd offset __unwindtable$??G?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEHABV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@@Z
.xdata$x:0000D430                 db    0
.xdata$x:0000D431                 db    0
.xdata$x:0000D432                 db    0
.xdata$x:0000D433                 db    0
.xdata$x:0000D434                 db    0
.xdata$x:0000D435                 db    0
.xdata$x:0000D436                 db    0
.xdata$x:0000D437                 db    0
.xdata$x:0000D438                 db    0
.xdata$x:0000D439                 db    0
.xdata$x:0000D43A                 db    0
.xdata$x:0000D43B                 db    0
.xdata$x:0000D43C                 db    0
.xdata$x:0000D43D                 db    0
.xdata$x:0000D43E                 db    0
.xdata$x:0000D43F                 db    0
.xdata$x:0000D440                 db    0
.xdata$x:0000D441                 db    0
.xdata$x:0000D442                 db    0
.xdata$x:0000D443                 db    0
.xdata$x:0000D444                 db    0
.xdata$x:0000D445                 db    0
.xdata$x:0000D446                 db    0
.xdata$x:0000D447                 db    0
.xdata$x:0000D447 _xdata$x        ends
.xdata$x:0000D447
.xdata$x:0000D448 ; ===========================================================================
.xdata$x:0000D448
.xdata$x:0000D448 ; Segment type: Pure data
.xdata$x:0000D448 ; Segment permissions: Read
.xdata$x:0000D448 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D448                 assume cs:_xdata$x
.xdata$x:0000D448                 ;org 0D448h
.xdata$x:0000D448 ; COMDAT (pick associative to section at 7350)
.xdata$x:0000D448 __unwindtable$??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000D448                                         ; DATA XREF: .xdata$x:0000D458o
.xdata$x:0000D449                 db 0FFh
.xdata$x:0000D44A                 db 0FFh
.xdata$x:0000D44B                 db 0FFh
.xdata$x:0000D44C                 dd offset __unwindfunclet$??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ$0
.xdata$x:0000D450 __ehfuncinfo$??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000D450                                         ; DATA XREF: __ehhandler$??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:0000D451                 db    5
.xdata$x:0000D452                 db  93h ; 
.xdata$x:0000D453                 db  19h
.xdata$x:0000D454                 db    1
.xdata$x:0000D455                 db    0
.xdata$x:0000D456                 db    0
.xdata$x:0000D457                 db    0
.xdata$x:0000D458                 dd offset __unwindtable$??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ
.xdata$x:0000D45C                 db    0
.xdata$x:0000D45D                 db    0
.xdata$x:0000D45E                 db    0
.xdata$x:0000D45F                 db    0
.xdata$x:0000D460                 db    0
.xdata$x:0000D461                 db    0
.xdata$x:0000D462                 db    0
.xdata$x:0000D463                 db    0
.xdata$x:0000D464                 db    0
.xdata$x:0000D465                 db    0
.xdata$x:0000D466                 db    0
.xdata$x:0000D467                 db    0
.xdata$x:0000D468                 db    0
.xdata$x:0000D469                 db    0
.xdata$x:0000D46A                 db    0
.xdata$x:0000D46B                 db    0
.xdata$x:0000D46C                 db    0
.xdata$x:0000D46D                 db    0
.xdata$x:0000D46E                 db    0
.xdata$x:0000D46F                 db    0
.xdata$x:0000D470                 db    0
.xdata$x:0000D471                 db    0
.xdata$x:0000D472                 db    0
.xdata$x:0000D473                 db    0
.xdata$x:0000D473 _xdata$x        ends
.xdata$x:0000D473
.xdata$x:0000D474 ; ===========================================================================
.xdata$x:0000D474
.xdata$x:0000D474 ; Segment type: Pure data
.xdata$x:0000D474 ; Segment permissions: Read
.xdata$x:0000D474 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D474                 assume cs:_xdata$x
.xdata$x:0000D474                 ;org 0D474h
.xdata$x:0000D474 ; COMDAT (pick associative to section at 654C)
.xdata$x:0000D474 __unwindtable$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z db 0FFh
.xdata$x:0000D474                                         ; DATA XREF: .xdata$x:0000D484o
.xdata$x:0000D475                 db 0FFh
.xdata$x:0000D476                 db 0FFh
.xdata$x:0000D477                 db 0FFh
.xdata$x:0000D478                 dd offset __unwindfunclet$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z$0
.xdata$x:0000D47C __ehfuncinfo$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z db  22h ; "
.xdata$x:0000D47C                                         ; DATA XREF: __ehhandler$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z+11o
.xdata$x:0000D47D                 db    5
.xdata$x:0000D47E                 db  93h ; 
.xdata$x:0000D47F                 db  19h
.xdata$x:0000D480                 db    1
.xdata$x:0000D481                 db    0
.xdata$x:0000D482                 db    0
.xdata$x:0000D483                 db    0
.xdata$x:0000D484                 dd offset __unwindtable$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z
.xdata$x:0000D488                 align 20h
.xdata$x:0000D488 _xdata$x        ends
.xdata$x:0000D488
.xdata$x:0000D4A0 ; ===========================================================================
.xdata$x:0000D4A0
.xdata$x:0000D4A0 ; Segment type: Pure data
.xdata$x:0000D4A0 ; Segment permissions: Read
.xdata$x:0000D4A0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D4A0                 assume cs:_xdata$x
.xdata$x:0000D4A0                 ;org 0D4A0h
.xdata$x:0000D4A0 ; COMDAT (pick associative to section at 6B60)
.xdata$x:0000D4A0 __unwindtable$??0?$_Vector_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000D4A0                                         ; DATA XREF: .xdata$x:0000D4B0o
.xdata$x:0000D4A1                 db 0FFh
.xdata$x:0000D4A2                 db 0FFh
.xdata$x:0000D4A3                 db 0FFh
.xdata$x:0000D4A4                 dd offset __unwindfunclet$??0?$_Vector_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0
.xdata$x:0000D4A8 __ehfuncinfo$??0?$_Vector_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000D4A8                                         ; DATA XREF: __ehhandler$??0?$_Vector_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ+11o
.xdata$x:0000D4A9                 db    5
.xdata$x:0000D4AA                 db  93h ; 
.xdata$x:0000D4AB                 db  19h
.xdata$x:0000D4AC                 db    1
.xdata$x:0000D4AD                 db    0
.xdata$x:0000D4AE                 db    0
.xdata$x:0000D4AF                 db    0
.xdata$x:0000D4B0                 dd offset __unwindtable$??0?$_Vector_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.xdata$x:0000D4B4                 db    0
.xdata$x:0000D4B5                 db    0
.xdata$x:0000D4B6                 db    0
.xdata$x:0000D4B7                 db    0
.xdata$x:0000D4B8                 db    0
.xdata$x:0000D4B9                 db    0
.xdata$x:0000D4BA                 db    0
.xdata$x:0000D4BB                 db    0
.xdata$x:0000D4BC                 db    0
.xdata$x:0000D4BD                 db    0
.xdata$x:0000D4BE                 db    0
.xdata$x:0000D4BF                 db    0
.xdata$x:0000D4C0                 db    0
.xdata$x:0000D4C1                 db    0
.xdata$x:0000D4C2                 db    0
.xdata$x:0000D4C3                 db    0
.xdata$x:0000D4C4                 db    0
.xdata$x:0000D4C5                 db    0
.xdata$x:0000D4C6                 db    0
.xdata$x:0000D4C7                 db    0
.xdata$x:0000D4C8                 db    0
.xdata$x:0000D4C9                 db    0
.xdata$x:0000D4CA                 db    0
.xdata$x:0000D4CB                 db    0
.xdata$x:0000D4CB _xdata$x        ends
.xdata$x:0000D4CB
.xdata$x:0000D4CC ; ===========================================================================
.xdata$x:0000D4CC
.xdata$x:0000D4CC ; Segment type: Pure data
.xdata$x:0000D4CC ; Segment permissions: Read
.xdata$x:0000D4CC _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D4CC                 assume cs:_xdata$x
.xdata$x:0000D4CC                 ;org 0D4CCh
.xdata$x:0000D4CC ; COMDAT (pick associative to section at 7730)
.xdata$x:0000D4CC __unwindtable$??1?$_Vector_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000D4CC                                         ; DATA XREF: .xdata$x:0000D4DCo
.xdata$x:0000D4CD                 db 0FFh
.xdata$x:0000D4CE                 db 0FFh
.xdata$x:0000D4CF                 db 0FFh
.xdata$x:0000D4D0                 dd offset __unwindfunclet$??1?$_Vector_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0
.xdata$x:0000D4D4 __ehfuncinfo$??1?$_Vector_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000D4D4                                         ; DATA XREF: __ehhandler$??1?$_Vector_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ+11o
.xdata$x:0000D4D5                 db    5
.xdata$x:0000D4D6                 db  93h ; 
.xdata$x:0000D4D7                 db  19h
.xdata$x:0000D4D8                 db    1
.xdata$x:0000D4D9                 db    0
.xdata$x:0000D4DA                 db    0
.xdata$x:0000D4DB                 db    0
.xdata$x:0000D4DC                 dd offset __unwindtable$??1?$_Vector_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.xdata$x:0000D4E0                 db    0
.xdata$x:0000D4E1                 db    0
.xdata$x:0000D4E2                 db    0
.xdata$x:0000D4E3                 db    0
.xdata$x:0000D4E4                 db    0
.xdata$x:0000D4E5                 db    0
.xdata$x:0000D4E6                 db    0
.xdata$x:0000D4E7                 db    0
.xdata$x:0000D4E8                 db    0
.xdata$x:0000D4E9                 db    0
.xdata$x:0000D4EA                 db    0
.xdata$x:0000D4EB                 db    0
.xdata$x:0000D4EC                 db    0
.xdata$x:0000D4ED                 db    0
.xdata$x:0000D4EE                 db    0
.xdata$x:0000D4EF                 db    0
.xdata$x:0000D4F0                 db    0
.xdata$x:0000D4F1                 db    0
.xdata$x:0000D4F2                 db    0
.xdata$x:0000D4F3                 db    0
.xdata$x:0000D4F4                 db    0
.xdata$x:0000D4F5                 db    0
.xdata$x:0000D4F6                 db    0
.xdata$x:0000D4F7                 db    0
.xdata$x:0000D4F7 _xdata$x        ends
.xdata$x:0000D4F7
.xdata$x:0000D4F8 ; ===========================================================================
.xdata$x:0000D4F8
.xdata$x:0000D4F8 ; Segment type: Pure data
.xdata$x:0000D4F8 ; Segment permissions: Read
.xdata$x:0000D4F8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D4F8                 assume cs:_xdata$x
.xdata$x:0000D4F8                 ;org 0D4F8h
.xdata$x:0000D4F8 ; COMDAT (pick associative to section at 6850)
.xdata$x:0000D4F8 __unwindtable$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z db 0FFh
.xdata$x:0000D4F8                                         ; DATA XREF: .xdata$x:0000D508o
.xdata$x:0000D4F9                 db 0FFh
.xdata$x:0000D4FA                 db 0FFh
.xdata$x:0000D4FB                 db 0FFh
.xdata$x:0000D4FC                 dd offset __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z$0
.xdata$x:0000D500 __ehfuncinfo$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z db  22h ; "
.xdata$x:0000D500                                         ; DATA XREF: __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z+11o
.xdata$x:0000D501                 db    5
.xdata$x:0000D502                 db  93h ; 
.xdata$x:0000D503                 db  19h
.xdata$x:0000D504                 db    1
.xdata$x:0000D505                 db    0
.xdata$x:0000D506                 db    0
.xdata$x:0000D507                 db    0
.xdata$x:0000D508                 dd offset __unwindtable$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z
.xdata$x:0000D50C                 db    0
.xdata$x:0000D50D                 db    0
.xdata$x:0000D50E                 db    0
.xdata$x:0000D50F                 db    0
.xdata$x:0000D510                 db    0
.xdata$x:0000D511                 db    0
.xdata$x:0000D512                 db    0
.xdata$x:0000D513                 db    0
.xdata$x:0000D514                 db    0
.xdata$x:0000D515                 db    0
.xdata$x:0000D516                 db    0
.xdata$x:0000D517                 db    0
.xdata$x:0000D518                 db    0
.xdata$x:0000D519                 db    0
.xdata$x:0000D51A                 db    0
.xdata$x:0000D51B                 db    0
.xdata$x:0000D51C                 db    0
.xdata$x:0000D51D                 db    0
.xdata$x:0000D51E                 db    0
.xdata$x:0000D51F                 db    0
.xdata$x:0000D520                 db    0
.xdata$x:0000D521                 db    0
.xdata$x:0000D522                 db    0
.xdata$x:0000D523                 db    0
.xdata$x:0000D523 _xdata$x        ends
.xdata$x:0000D523
.xdata$x:0000D524 ; ===========================================================================
.xdata$x:0000D524
.xdata$x:0000D524 ; Segment type: Pure data
.xdata$x:0000D524 ; Segment permissions: Read
.xdata$x:0000D524 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D524                 assume cs:_xdata$x
.xdata$x:0000D524                 ;org 0D524h
.xdata$x:0000D524 ; COMDAT (pick associative to section at 7568)
.xdata$x:0000D524 __unwindtable$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000D524                                         ; DATA XREF: .xdata$x:0000D534o
.xdata$x:0000D525                 db 0FFh
.xdata$x:0000D526                 db 0FFh
.xdata$x:0000D527                 db 0FFh
.xdata$x:0000D528                 dd offset __unwindfunclet$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ$0
.xdata$x:0000D52C __ehfuncinfo$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000D52C                                         ; DATA XREF: __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:0000D52D                 db    5
.xdata$x:0000D52E                 db  93h ; 
.xdata$x:0000D52F                 db  19h
.xdata$x:0000D530                 db    1
.xdata$x:0000D531                 db    0
.xdata$x:0000D532                 db    0
.xdata$x:0000D533                 db    0
.xdata$x:0000D534                 dd offset __unwindtable$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
.xdata$x:0000D538                 db    0
.xdata$x:0000D539                 db    0
.xdata$x:0000D53A                 db    0
.xdata$x:0000D53B                 db    0
.xdata$x:0000D53C                 db    0
.xdata$x:0000D53D                 db    0
.xdata$x:0000D53E                 db    0
.xdata$x:0000D53F                 db    0
.xdata$x:0000D540                 db    0
.xdata$x:0000D541                 db    0
.xdata$x:0000D542                 db    0
.xdata$x:0000D543                 db    0
.xdata$x:0000D544                 db    0
.xdata$x:0000D545                 db    0
.xdata$x:0000D546                 db    0
.xdata$x:0000D547                 db    0
.xdata$x:0000D548                 db    0
.xdata$x:0000D549                 db    0
.xdata$x:0000D54A                 db    0
.xdata$x:0000D54B                 db    0
.xdata$x:0000D54C                 db    0
.xdata$x:0000D54D                 db    0
.xdata$x:0000D54E                 db    0
.xdata$x:0000D54F                 db    0
.xdata$x:0000D54F _xdata$x        ends
.xdata$x:0000D54F
.xdata$x:0000D550 ; ===========================================================================
.xdata$x:0000D550
.xdata$x:0000D550 ; Segment type: Pure data
.xdata$x:0000D550 ; Segment permissions: Read
.xdata$x:0000D550 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D550                 assume cs:_xdata$x
.xdata$x:0000D550                 ;org 0D550h
.xdata$x:0000D550 ; COMDAT (pick associative to section at 7910)
.xdata$x:0000D550 __unwindtable$??1?$vector@_WV?$allocator@_W@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000D550                                         ; DATA XREF: .xdata$x:0000D560o
.xdata$x:0000D551                 db 0FFh
.xdata$x:0000D552                 db 0FFh
.xdata$x:0000D553                 db 0FFh
.xdata$x:0000D554                 dd offset __unwindfunclet$??1?$vector@_WV?$allocator@_W@std@@@std@@QAE@XZ$0
.xdata$x:0000D558 __ehfuncinfo$??1?$vector@_WV?$allocator@_W@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000D558                                         ; DATA XREF: __ehhandler$??1?$vector@_WV?$allocator@_W@std@@@std@@QAE@XZ+11o
.xdata$x:0000D559                 db    5
.xdata$x:0000D55A                 db  93h ; 
.xdata$x:0000D55B                 db  19h
.xdata$x:0000D55C                 db    1
.xdata$x:0000D55D                 db    0
.xdata$x:0000D55E                 db    0
.xdata$x:0000D55F                 db    0
.xdata$x:0000D560                 dd offset __unwindtable$??1?$vector@_WV?$allocator@_W@std@@@std@@QAE@XZ
.xdata$x:0000D564                 db    0
.xdata$x:0000D565                 db    0
.xdata$x:0000D566                 db    0
.xdata$x:0000D567                 db    0
.xdata$x:0000D568                 db    0
.xdata$x:0000D569                 db    0
.xdata$x:0000D56A                 db    0
.xdata$x:0000D56B                 db    0
.xdata$x:0000D56C                 db    0
.xdata$x:0000D56D                 db    0
.xdata$x:0000D56E                 db    0
.xdata$x:0000D56F                 db    0
.xdata$x:0000D570                 db    0
.xdata$x:0000D571                 db    0
.xdata$x:0000D572                 db    0
.xdata$x:0000D573                 db    0
.xdata$x:0000D574                 db    0
.xdata$x:0000D575                 db    0
.xdata$x:0000D576                 db    0
.xdata$x:0000D577                 db    0
.xdata$x:0000D578                 db    0
.xdata$x:0000D579                 db    0
.xdata$x:0000D57A                 db    0
.xdata$x:0000D57B                 db    0
.xdata$x:0000D57B _xdata$x        ends
.xdata$x:0000D57B
.xdata$x:0000D57C ; ===========================================================================
.xdata$x:0000D57C
.xdata$x:0000D57C ; Segment type: Pure data
.xdata$x:0000D57C ; Segment permissions: Read
.xdata$x:0000D57C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D57C                 assume cs:_xdata$x
.xdata$x:0000D57C                 ;org 0D57Ch
.xdata$x:0000D57C ; COMDAT (pick associative to section at 9F68)
.xdata$x:0000D57C __catchsym$?_Reallocate@?$vector@_WV?$allocator@_W@std@@@std@@IAEXI@Z$2 db    0
.xdata$x:0000D57C                                         ; DATA XREF: .xdata$x:0000D5ACo
.xdata$x:0000D57D                 db    0
.xdata$x:0000D57E                 db    0
.xdata$x:0000D57F                 db    0
.xdata$x:0000D580                 db    0
.xdata$x:0000D581                 db    0
.xdata$x:0000D582                 db    0
.xdata$x:0000D583                 db    0
.xdata$x:0000D584                 db    0
.xdata$x:0000D585                 db    0
.xdata$x:0000D586                 db    0
.xdata$x:0000D587                 db    0
.xdata$x:0000D588                 dd offset __catch$?_Reallocate@?$vector@_WV?$allocator@_W@std@@@std@@IAEXI@Z$0
.xdata$x:0000D58C __unwindtable$?_Reallocate@?$vector@_WV?$allocator@_W@std@@@std@@IAEXI@Z db 0FFh
.xdata$x:0000D58C                                         ; DATA XREF: .xdata$x:0000D5B8o
.xdata$x:0000D58D                 db 0FFh
.xdata$x:0000D58E                 db 0FFh
.xdata$x:0000D58F                 db 0FFh
.xdata$x:0000D590                 db    0
.xdata$x:0000D591                 db    0
.xdata$x:0000D592                 db    0
.xdata$x:0000D593                 db    0
.xdata$x:0000D594                 db 0FFh
.xdata$x:0000D595                 db 0FFh
.xdata$x:0000D596                 db 0FFh
.xdata$x:0000D597                 db 0FFh
.xdata$x:0000D598                 db    0
.xdata$x:0000D599                 db    0
.xdata$x:0000D59A                 db    0
.xdata$x:0000D59B                 db    0
.xdata$x:0000D59C __tryblocktable$?_Reallocate@?$vector@_WV?$allocator@_W@std@@@std@@IAEXI@Z db    0
.xdata$x:0000D59C                                         ; DATA XREF: .xdata$x:0000D5C0o
.xdata$x:0000D59D                 db    0
.xdata$x:0000D59E                 db    0
.xdata$x:0000D59F                 db    0
.xdata$x:0000D5A0                 db    0
.xdata$x:0000D5A1                 db    0
.xdata$x:0000D5A2                 db    0
.xdata$x:0000D5A3                 db    0
.xdata$x:0000D5A4                 db    1
.xdata$x:0000D5A5                 db    0
.xdata$x:0000D5A6                 db    0
.xdata$x:0000D5A7                 db    0
.xdata$x:0000D5A8                 db    1
.xdata$x:0000D5A9                 db    0
.xdata$x:0000D5AA                 db    0
.xdata$x:0000D5AB                 db    0
.xdata$x:0000D5AC                 dd offset __catchsym$?_Reallocate@?$vector@_WV?$allocator@_W@std@@@std@@IAEXI@Z$2
.xdata$x:0000D5B0 __ehfuncinfo$?_Reallocate@?$vector@_WV?$allocator@_W@std@@@std@@IAEXI@Z db  22h ; "
.xdata$x:0000D5B0                                         ; DATA XREF: __ehhandler$?_Reallocate@?$vector@_WV?$allocator@_W@std@@@std@@IAEXI@Z+11o
.xdata$x:0000D5B1                 db    5
.xdata$x:0000D5B2                 db  93h ; 
.xdata$x:0000D5B3                 db  19h
.xdata$x:0000D5B4                 db    2
.xdata$x:0000D5B5                 db    0
.xdata$x:0000D5B6                 db    0
.xdata$x:0000D5B7                 db    0
.xdata$x:0000D5B8                 dd offset __unwindtable$?_Reallocate@?$vector@_WV?$allocator@_W@std@@@std@@IAEXI@Z
.xdata$x:0000D5BC                 db    1
.xdata$x:0000D5BD                 db    0
.xdata$x:0000D5BE                 db    0
.xdata$x:0000D5BF                 db    0
.xdata$x:0000D5C0                 dd offset __tryblocktable$?_Reallocate@?$vector@_WV?$allocator@_W@std@@@std@@IAEXI@Z
.xdata$x:0000D5C4                 db    0
.xdata$x:0000D5C5                 db    0
.xdata$x:0000D5C6                 db    0
.xdata$x:0000D5C7                 db    0
.xdata$x:0000D5C8                 db    0
.xdata$x:0000D5C9                 db    0
.xdata$x:0000D5CA                 db    0
.xdata$x:0000D5CB                 db    0
.xdata$x:0000D5CC                 db    0
.xdata$x:0000D5CD                 db    0
.xdata$x:0000D5CE                 db    0
.xdata$x:0000D5CF                 db    0
.xdata$x:0000D5D0                 db    0
.xdata$x:0000D5D1                 db    0
.xdata$x:0000D5D2                 db    0
.xdata$x:0000D5D3                 db    0
.xdata$x:0000D5D3 _xdata$x        ends
.xdata$x:0000D5D3
.xdata$x:0000D5D4 ; ===========================================================================
.xdata$x:0000D5D4
.xdata$x:0000D5D4 ; Segment type: Pure data
.xdata$x:0000D5D4 ; Segment permissions: Read
.xdata$x:0000D5D4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D5D4                 assume cs:_xdata$x
.xdata$x:0000D5D4                 ;org 0D5D4h
.xdata$x:0000D5D4 ; COMDAT (pick associative to section at 9CE0)
.xdata$x:0000D5D4 __unwindtable$?_Orphan_range@?$vector@_WV?$allocator@_W@std@@@std@@IBEXPA_W0@Z db 0FFh
.xdata$x:0000D5D4                                         ; DATA XREF: .xdata$x:0000D5E4o
.xdata$x:0000D5D5                 db 0FFh
.xdata$x:0000D5D6                 db 0FFh
.xdata$x:0000D5D7                 db 0FFh
.xdata$x:0000D5D8                 dd offset __unwindfunclet$?_Orphan_range@?$vector@_WV?$allocator@_W@std@@@std@@IBEXPA_W0@Z$0
.xdata$x:0000D5DC __ehfuncinfo$?_Orphan_range@?$vector@_WV?$allocator@_W@std@@@std@@IBEXPA_W0@Z db  22h ; "
.xdata$x:0000D5DC                                         ; DATA XREF: __ehhandler$?_Orphan_range@?$vector@_WV?$allocator@_W@std@@@std@@IBEXPA_W0@Z+11o
.xdata$x:0000D5DD                 db    5
.xdata$x:0000D5DE                 db  93h ; 
.xdata$x:0000D5DF                 db  19h
.xdata$x:0000D5E0                 db    1
.xdata$x:0000D5E1                 db    0
.xdata$x:0000D5E2                 db    0
.xdata$x:0000D5E3                 db    0
.xdata$x:0000D5E4                 dd offset __unwindtable$?_Orphan_range@?$vector@_WV?$allocator@_W@std@@@std@@IBEXPA_W0@Z
.xdata$x:0000D5E8                 align 20h
.xdata$x:0000D5E8 _xdata$x        ends
.xdata$x:0000D5E8
.xdata$x:0000D600 ; ===========================================================================
.xdata$x:0000D600
.xdata$x:0000D600 ; Segment type: Pure data
.xdata$x:0000D600 ; Segment permissions: Read
.xdata$x:0000D600 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D600                 assume cs:_xdata$x
.xdata$x:0000D600                 ;org 0D600h
.xdata$x:0000D600 ; COMDAT (pick associative to section at 2628)
.xdata$x:0000D600 __ehfuncinfo$??$?0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@X@?$vector@_WV?$allocator@_W@std@@@std@@QAE@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z db  22h ; "
.xdata$x:0000D600                                         ; DATA XREF: __ehhandler$??$?0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@X@?$vector@_WV?$allocator@_W@std@@@std@@QAE@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z+11o
.xdata$x:0000D601                 db    5
.xdata$x:0000D602                 db  93h ; 
.xdata$x:0000D603                 db  19h
.xdata$x:0000D604                 db    5
.xdata$x:0000D605                 db    0
.xdata$x:0000D606                 db    0
.xdata$x:0000D607                 db    0
.xdata$x:0000D608                 dd offset __unwindtable$??$?0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@X@?$vector@_WV?$allocator@_W@std@@@std@@QAE@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z
.xdata$x:0000D60C                 db    0
.xdata$x:0000D60D                 db    0
.xdata$x:0000D60E                 db    0
.xdata$x:0000D60F                 db    0
.xdata$x:0000D610                 db    0
.xdata$x:0000D611                 db    0
.xdata$x:0000D612                 db    0
.xdata$x:0000D613                 db    0
.xdata$x:0000D614                 db    0
.xdata$x:0000D615                 db    0
.xdata$x:0000D616                 db    0
.xdata$x:0000D617                 db    0
.xdata$x:0000D618                 db    0
.xdata$x:0000D619                 db    0
.xdata$x:0000D61A                 db    0
.xdata$x:0000D61B                 db    0
.xdata$x:0000D61C                 db    0
.xdata$x:0000D61D                 db    0
.xdata$x:0000D61E                 db    0
.xdata$x:0000D61F                 db    0
.xdata$x:0000D620                 db    0
.xdata$x:0000D621                 db    0
.xdata$x:0000D622                 db    0
.xdata$x:0000D623                 db    0
.xdata$x:0000D624 __unwindtable$??$?0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@X@?$vector@_WV?$allocator@_W@std@@@std@@QAE@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z db 0FFh
.xdata$x:0000D624                                         ; DATA XREF: .xdata$x:0000D608o
.xdata$x:0000D625                 db 0FFh
.xdata$x:0000D626                 db 0FFh
.xdata$x:0000D627                 db 0FFh
.xdata$x:0000D628                 dd offset __unwindfunclet$??$?0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@X@?$vector@_WV?$allocator@_W@std@@@std@@QAE@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$0
.xdata$x:0000D62C                 align 10h
.xdata$x:0000D630                 dd offset __unwindfunclet$??$?0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@X@?$vector@_WV?$allocator@_W@std@@@std@@QAE@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$1
.xdata$x:0000D634                 db    1
.xdata$x:0000D635                 db    0
.xdata$x:0000D636                 db    0
.xdata$x:0000D637                 db    0
.xdata$x:0000D638                 dd offset __unwindfunclet$??$?0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@X@?$vector@_WV?$allocator@_W@std@@@std@@QAE@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$2
.xdata$x:0000D63C                 db    2
.xdata$x:0000D63D                 db    0
.xdata$x:0000D63E                 db    0
.xdata$x:0000D63F                 db    0
.xdata$x:0000D640                 dd offset __unwindfunclet$??$?0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@X@?$vector@_WV?$allocator@_W@std@@@std@@QAE@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$3
.xdata$x:0000D644                 db    3
.xdata$x:0000D645                 db    0
.xdata$x:0000D646                 db    0
.xdata$x:0000D647                 db    0
.xdata$x:0000D648                 dd offset __unwindfunclet$??$?0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@X@?$vector@_WV?$allocator@_W@std@@@std@@QAE@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$4
.xdata$x:0000D648 _xdata$x        ends
.xdata$x:0000D648
.xdata$x:0000D64C ; ===========================================================================
.xdata$x:0000D64C
.xdata$x:0000D64C ; Segment type: Pure data
.xdata$x:0000D64C ; Segment permissions: Read
.xdata$x:0000D64C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D64C                 assume cs:_xdata$x
.xdata$x:0000D64C                 ;org 0D64Ch
.xdata$x:0000D64C ; COMDAT (pick associative to section at 54D0)
.xdata$x:0000D64C __unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z db 0FFh
.xdata$x:0000D64C                                         ; DATA XREF: .xdata$x:0000D65Co
.xdata$x:0000D64D                 db 0FFh
.xdata$x:0000D64E                 db 0FFh
.xdata$x:0000D64F                 db 0FFh
.xdata$x:0000D650                 dd offset __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0
.xdata$x:0000D654 __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z db  22h ; "
.xdata$x:0000D654                                         ; DATA XREF: __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z+11o
.xdata$x:0000D655                 db    5
.xdata$x:0000D656                 db  93h ; 
.xdata$x:0000D657                 db  19h
.xdata$x:0000D658                 db    1
.xdata$x:0000D659                 db    0
.xdata$x:0000D65A                 db    0
.xdata$x:0000D65B                 db    0
.xdata$x:0000D65C                 dd offset __unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.xdata$x:0000D660                 db    0
.xdata$x:0000D661                 db    0
.xdata$x:0000D662                 db    0
.xdata$x:0000D663                 db    0
.xdata$x:0000D664                 db    0
.xdata$x:0000D665                 db    0
.xdata$x:0000D666                 db    0
.xdata$x:0000D667                 db    0
.xdata$x:0000D668                 db    0
.xdata$x:0000D669                 db    0
.xdata$x:0000D66A                 db    0
.xdata$x:0000D66B                 db    0
.xdata$x:0000D66C                 db    0
.xdata$x:0000D66D                 db    0
.xdata$x:0000D66E                 db    0
.xdata$x:0000D66F                 db    0
.xdata$x:0000D670                 db    0
.xdata$x:0000D671                 db    0
.xdata$x:0000D672                 db    0
.xdata$x:0000D673                 db    0
.xdata$x:0000D674                 db    0
.xdata$x:0000D675                 db    0
.xdata$x:0000D676                 db    0
.xdata$x:0000D677                 db    0
.xdata$x:0000D677 _xdata$x        ends
.xdata$x:0000D677
.xdata$x:0000D678 ; ===========================================================================
.xdata$x:0000D678
.xdata$x:0000D678 ; Segment type: Pure data
.xdata$x:0000D678 ; Segment permissions: Read
.xdata$x:0000D678 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D678                 assume cs:_xdata$x
.xdata$x:0000D678                 ;org 0D678h
.xdata$x:0000D678 ; COMDAT (pick associative to section at 390C)
.xdata$x:0000D678 __unwindtable$??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0PB_WI@Z db 0FFh
.xdata$x:0000D678                                         ; DATA XREF: .xdata$x:0000D6A0o
.xdata$x:0000D679                 db 0FFh
.xdata$x:0000D67A                 db 0FFh
.xdata$x:0000D67B                 db 0FFh
.xdata$x:0000D67C                 dd offset __unwindfunclet$??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0PB_WI@Z$0
.xdata$x:0000D680                 db    0
.xdata$x:0000D681                 db    0
.xdata$x:0000D682                 db    0
.xdata$x:0000D683                 db    0
.xdata$x:0000D684                 dd offset __unwindfunclet$??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0PB_WI@Z$1
.xdata$x:0000D688                 db    1
.xdata$x:0000D689                 db    0
.xdata$x:0000D68A                 db    0
.xdata$x:0000D68B                 db    0
.xdata$x:0000D68C                 dd offset __unwindfunclet$??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0PB_WI@Z$2
.xdata$x:0000D690                 db    2
.xdata$x:0000D691                 db    0
.xdata$x:0000D692                 db    0
.xdata$x:0000D693                 db    0
.xdata$x:0000D694                 dd offset __unwindfunclet$??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0PB_WI@Z$3
.xdata$x:0000D698 __ehfuncinfo$??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0PB_WI@Z db  22h ; "
.xdata$x:0000D698                                         ; DATA XREF: __ehhandler$??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0PB_WI@Z+11o
.xdata$x:0000D699                 db    5
.xdata$x:0000D69A                 db  93h ; 
.xdata$x:0000D69B                 db  19h
.xdata$x:0000D69C                 db    4
.xdata$x:0000D69D                 db    0
.xdata$x:0000D69E                 db    0
.xdata$x:0000D69F                 db    0
.xdata$x:0000D6A0                 dd offset __unwindtable$??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0PB_WI@Z
.xdata$x:0000D6A4                 db    0
.xdata$x:0000D6A5                 db    0
.xdata$x:0000D6A6                 db    0
.xdata$x:0000D6A7                 db    0
.xdata$x:0000D6A8                 db    0
.xdata$x:0000D6A9                 db    0
.xdata$x:0000D6AA                 db    0
.xdata$x:0000D6AB                 db    0
.xdata$x:0000D6AC                 db    0
.xdata$x:0000D6AD                 db    0
.xdata$x:0000D6AE                 db    0
.xdata$x:0000D6AF                 db    0
.xdata$x:0000D6B0                 db    0
.xdata$x:0000D6B1                 db    0
.xdata$x:0000D6B2                 db    0
.xdata$x:0000D6B3                 db    0
.xdata$x:0000D6B4                 db    0
.xdata$x:0000D6B5                 db    0
.xdata$x:0000D6B6                 db    0
.xdata$x:0000D6B7                 db    0
.xdata$x:0000D6B8                 db    0
.xdata$x:0000D6B9                 db    0
.xdata$x:0000D6BA                 db    0
.xdata$x:0000D6BB                 db    0
.xdata$x:0000D6BB _xdata$x        ends
.xdata$x:0000D6BB
.xdata$x:0000D6BC ; ===========================================================================
.xdata$x:0000D6BC
.xdata$x:0000D6BC ; Segment type: Pure data
.xdata$x:0000D6BC ; Segment permissions: Read
.xdata$x:0000D6BC _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D6BC                 assume cs:_xdata$x
.xdata$x:0000D6BC                 ;org 0D6BCh
.xdata$x:0000D6BC ; COMDAT (pick associative to section at 4C28)
.xdata$x:0000D6BC __unwindtable$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@YAPAHV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@@Z db 0FFh
.xdata$x:0000D6BC                                         ; DATA XREF: .xdata$x:0000D6CCo
.xdata$x:0000D6BD                 db 0FFh
.xdata$x:0000D6BE                 db 0FFh
.xdata$x:0000D6BF                 db 0FFh
.xdata$x:0000D6C0                 dd offset __unwindfunclet$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@YAPAHV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@@Z$0
.xdata$x:0000D6C4 __ehfuncinfo$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@YAPAHV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@@Z db  22h ; "
.xdata$x:0000D6C4                                         ; DATA XREF: __ehhandler$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@YAPAHV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@@Z+11o
.xdata$x:0000D6C5                 db    5
.xdata$x:0000D6C6                 db  93h ; 
.xdata$x:0000D6C7                 db  19h
.xdata$x:0000D6C8                 db    1
.xdata$x:0000D6C9                 db    0
.xdata$x:0000D6CA                 db    0
.xdata$x:0000D6CB                 db    0
.xdata$x:0000D6CC                 dd offset __unwindtable$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@YAPAHV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@@Z
.xdata$x:0000D6D0                 db    0
.xdata$x:0000D6D1                 db    0
.xdata$x:0000D6D2                 db    0
.xdata$x:0000D6D3                 db    0
.xdata$x:0000D6D4                 db    0
.xdata$x:0000D6D5                 db    0
.xdata$x:0000D6D6                 db    0
.xdata$x:0000D6D7                 db    0
.xdata$x:0000D6D8                 db    0
.xdata$x:0000D6D9                 db    0
.xdata$x:0000D6DA                 db    0
.xdata$x:0000D6DB                 db    0
.xdata$x:0000D6DC                 db    0
.xdata$x:0000D6DD                 db    0
.xdata$x:0000D6DE                 db    0
.xdata$x:0000D6DF                 db    0
.xdata$x:0000D6E0                 db    0
.xdata$x:0000D6E1                 db    0
.xdata$x:0000D6E2                 db    0
.xdata$x:0000D6E3                 db    0
.xdata$x:0000D6E4                 db    0
.xdata$x:0000D6E5                 db    0
.xdata$x:0000D6E6                 db    0
.xdata$x:0000D6E7                 db    0
.xdata$x:0000D6E7 _xdata$x        ends
.xdata$x:0000D6E7
.xdata$x:0000D6E8 ; ===========================================================================
.xdata$x:0000D6E8
.xdata$x:0000D6E8 ; Segment type: Pure data
.xdata$x:0000D6E8 ; Segment permissions: Read
.xdata$x:0000D6E8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D6E8                 assume cs:_xdata$x
.xdata$x:0000D6E8                 ;org 0D6E8h
.xdata$x:0000D6E8 ; COMDAT (pick associative to section at 3A8C)
.xdata$x:0000D6E8 __unwindtable$??$_Dist_type@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAPAHV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@@Z db 0FFh
.xdata$x:0000D6E8                                         ; DATA XREF: .xdata$x:0000D6F8o
.xdata$x:0000D6E9                 db 0FFh
.xdata$x:0000D6EA                 db 0FFh
.xdata$x:0000D6EB                 db 0FFh
.xdata$x:0000D6EC                 dd offset __unwindfunclet$??$_Dist_type@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAPAHV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@@Z$0
.xdata$x:0000D6F0 __ehfuncinfo$??$_Dist_type@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAPAHV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@@Z db  22h ; "
.xdata$x:0000D6F0                                         ; DATA XREF: __ehhandler$??$_Dist_type@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAPAHV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@@Z+11o
.xdata$x:0000D6F1                 db    5
.xdata$x:0000D6F2                 db  93h ; 
.xdata$x:0000D6F3                 db  19h
.xdata$x:0000D6F4                 db    1
.xdata$x:0000D6F5                 db    0
.xdata$x:0000D6F6                 db    0
.xdata$x:0000D6F7                 db    0
.xdata$x:0000D6F8                 dd offset __unwindtable$??$_Dist_type@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAPAHV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@@Z
.xdata$x:0000D6FC                 db    0
.xdata$x:0000D6FD                 db    0
.xdata$x:0000D6FE                 db    0
.xdata$x:0000D6FF                 db    0
.xdata$x:0000D700                 db    0
.xdata$x:0000D701                 db    0
.xdata$x:0000D702                 db    0
.xdata$x:0000D703                 db    0
.xdata$x:0000D704                 db    0
.xdata$x:0000D705                 db    0
.xdata$x:0000D706                 db    0
.xdata$x:0000D707                 db    0
.xdata$x:0000D708                 db    0
.xdata$x:0000D709                 db    0
.xdata$x:0000D70A                 db    0
.xdata$x:0000D70B                 db    0
.xdata$x:0000D70C                 db    0
.xdata$x:0000D70D                 db    0
.xdata$x:0000D70E                 db    0
.xdata$x:0000D70F                 db    0
.xdata$x:0000D710                 db    0
.xdata$x:0000D711                 db    0
.xdata$x:0000D712                 db    0
.xdata$x:0000D713                 db    0
.xdata$x:0000D713 _xdata$x        ends
.xdata$x:0000D713
.xdata$x:0000D714 ; ===========================================================================
.xdata$x:0000D714
.xdata$x:0000D714 ; Segment type: Pure data
.xdata$x:0000D714 ; Segment permissions: Read
.xdata$x:0000D714 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D714                 assume cs:_xdata$x
.xdata$x:0000D714                 ;org 0D714h
.xdata$x:0000D714 ; COMDAT (pick associative to section at 51B8)
.xdata$x:0000D714 __unwindtable$??$_Val_type@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAPAHV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@@Z db 0FFh
.xdata$x:0000D714                                         ; DATA XREF: .xdata$x:0000D724o
.xdata$x:0000D715                 db 0FFh
.xdata$x:0000D716                 db 0FFh
.xdata$x:0000D717                 db 0FFh
.xdata$x:0000D718                 dd offset __unwindfunclet$??$_Val_type@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAPAHV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@@Z$0
.xdata$x:0000D71C __ehfuncinfo$??$_Val_type@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAPAHV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@@Z db  22h ; "
.xdata$x:0000D71C                                         ; DATA XREF: __ehhandler$??$_Val_type@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAPAHV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@@Z+11o
.xdata$x:0000D71D                 db    5
.xdata$x:0000D71E                 db  93h ; 
.xdata$x:0000D71F                 db  19h
.xdata$x:0000D720                 db    1
.xdata$x:0000D721                 db    0
.xdata$x:0000D722                 db    0
.xdata$x:0000D723                 db    0
.xdata$x:0000D724                 dd offset __unwindtable$??$_Val_type@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAPAHV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@@Z
.xdata$x:0000D728                 align 20h
.xdata$x:0000D728 _xdata$x        ends
.xdata$x:0000D728
.xdata$x:0000D740 ; ===========================================================================
.xdata$x:0000D740
.xdata$x:0000D740 ; Segment type: Pure data
.xdata$x:0000D740 ; Segment permissions: Read
.xdata$x:0000D740 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D740                 assume cs:_xdata$x
.xdata$x:0000D740                 ;org 0D740h
.xdata$x:0000D740 ; COMDAT (pick associative to section at 47DC)
.xdata$x:0000D740 __unwindtable$??$_Stable_sort@PAHHHUBufferEquivalent@@@std@@YAXPAH000UBufferEquivalent@@@Z db 0FFh
.xdata$x:0000D740                                         ; DATA XREF: .xdata$x:0000D750o
.xdata$x:0000D741                 db 0FFh
.xdata$x:0000D742                 db 0FFh
.xdata$x:0000D743                 db 0FFh
.xdata$x:0000D744                 dd offset __unwindfunclet$??$_Stable_sort@PAHHHUBufferEquivalent@@@std@@YAXPAH000UBufferEquivalent@@@Z$0
.xdata$x:0000D748 __ehfuncinfo$??$_Stable_sort@PAHHHUBufferEquivalent@@@std@@YAXPAH000UBufferEquivalent@@@Z db  22h ; "
.xdata$x:0000D748                                         ; DATA XREF: __ehhandler$??$_Stable_sort@PAHHHUBufferEquivalent@@@std@@YAXPAH000UBufferEquivalent@@@Z+11o
.xdata$x:0000D749                 db    5
.xdata$x:0000D74A                 db  93h ; 
.xdata$x:0000D74B                 db  19h
.xdata$x:0000D74C                 db    1
.xdata$x:0000D74D                 db    0
.xdata$x:0000D74E                 db    0
.xdata$x:0000D74F                 db    0
.xdata$x:0000D750                 dd offset __unwindtable$??$_Stable_sort@PAHHHUBufferEquivalent@@@std@@YAXPAH000UBufferEquivalent@@@Z
.xdata$x:0000D754                 db    0
.xdata$x:0000D755                 db    0
.xdata$x:0000D756                 db    0
.xdata$x:0000D757                 db    0
.xdata$x:0000D758                 db    0
.xdata$x:0000D759                 db    0
.xdata$x:0000D75A                 db    0
.xdata$x:0000D75B                 db    0
.xdata$x:0000D75C                 db    0
.xdata$x:0000D75D                 db    0
.xdata$x:0000D75E                 db    0
.xdata$x:0000D75F                 db    0
.xdata$x:0000D760                 db    0
.xdata$x:0000D761                 db    0
.xdata$x:0000D762                 db    0
.xdata$x:0000D763                 db    0
.xdata$x:0000D764                 db    0
.xdata$x:0000D765                 db    0
.xdata$x:0000D766                 db    0
.xdata$x:0000D767                 db    0
.xdata$x:0000D768                 db    0
.xdata$x:0000D769                 db    0
.xdata$x:0000D76A                 db    0
.xdata$x:0000D76B                 db    0
.xdata$x:0000D76B _xdata$x        ends
.xdata$x:0000D76B
.xdata$x:0000D76C ; ===========================================================================
.xdata$x:0000D76C
.xdata$x:0000D76C ; Segment type: Pure data
.xdata$x:0000D76C ; Segment permissions: Read
.xdata$x:0000D76C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D76C                 assume cs:_xdata$x
.xdata$x:0000D76C                 ;org 0D76Ch
.xdata$x:0000D76C ; COMDAT (pick associative to section at 58B8)
.xdata$x:0000D76C __ehfuncinfo$??$find_if@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@V?$binder2nd@U?$equal_to@H@std@@@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0V?$binder2nd@U?$equal_to@H@std@@@0@@Z db  22h ; "
.xdata$x:0000D76C                                         ; DATA XREF: __ehhandler$??$find_if@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@V?$binder2nd@U?$equal_to@H@std@@@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0V?$binder2nd@U?$equal_to@H@std@@@0@@Z+11o
.xdata$x:0000D76D                 db    5
.xdata$x:0000D76E                 db  93h ; 
.xdata$x:0000D76F                 db  19h
.xdata$x:0000D770                 db    7
.xdata$x:0000D771                 db    0
.xdata$x:0000D772                 db    0
.xdata$x:0000D773                 db    0
.xdata$x:0000D774                 dd offset __unwindtable$??$find_if@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@V?$binder2nd@U?$equal_to@H@std@@@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0V?$binder2nd@U?$equal_to@H@std@@@0@@Z
.xdata$x:0000D778                 db    0
.xdata$x:0000D779                 db    0
.xdata$x:0000D77A                 db    0
.xdata$x:0000D77B                 db    0
.xdata$x:0000D77C                 db    0
.xdata$x:0000D77D                 db    0
.xdata$x:0000D77E                 db    0
.xdata$x:0000D77F                 db    0
.xdata$x:0000D780                 db    0
.xdata$x:0000D781                 db    0
.xdata$x:0000D782                 db    0
.xdata$x:0000D783                 db    0
.xdata$x:0000D784                 db    0
.xdata$x:0000D785                 db    0
.xdata$x:0000D786                 db    0
.xdata$x:0000D787                 db    0
.xdata$x:0000D788                 db    0
.xdata$x:0000D789                 db    0
.xdata$x:0000D78A                 db    0
.xdata$x:0000D78B                 db    0
.xdata$x:0000D78C                 db    0
.xdata$x:0000D78D                 db    0
.xdata$x:0000D78E                 db    0
.xdata$x:0000D78F                 db    0
.xdata$x:0000D790 __unwindtable$??$find_if@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@V?$binder2nd@U?$equal_to@H@std@@@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0V?$binder2nd@U?$equal_to@H@std@@@0@@Z db 0FFh
.xdata$x:0000D790                                         ; DATA XREF: .xdata$x:0000D774o
.xdata$x:0000D791                 db 0FFh
.xdata$x:0000D792                 db 0FFh
.xdata$x:0000D793                 db 0FFh
.xdata$x:0000D794                 dd offset __unwindfunclet$??$find_if@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@V?$binder2nd@U?$equal_to@H@std@@@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0V?$binder2nd@U?$equal_to@H@std@@@0@@Z$6
.xdata$x:0000D798                 db    0
.xdata$x:0000D799                 db    0
.xdata$x:0000D79A                 db    0
.xdata$x:0000D79B                 db    0
.xdata$x:0000D79C                 dd offset __unwindfunclet$??$find_if@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@V?$binder2nd@U?$equal_to@H@std@@@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0V?$binder2nd@U?$equal_to@H@std@@@0@@Z$0
.xdata$x:0000D7A0                 db    1
.xdata$x:0000D7A1                 db    0
.xdata$x:0000D7A2                 db    0
.xdata$x:0000D7A3                 db    0
.xdata$x:0000D7A4                 dd offset __unwindfunclet$??$find_if@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@V?$binder2nd@U?$equal_to@H@std@@@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0V?$binder2nd@U?$equal_to@H@std@@@0@@Z$1
.xdata$x:0000D7A8                 db    2
.xdata$x:0000D7A9                 db    0
.xdata$x:0000D7AA                 db    0
.xdata$x:0000D7AB                 db    0
.xdata$x:0000D7AC                 dd offset __unwindfunclet$??$find_if@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@V?$binder2nd@U?$equal_to@H@std@@@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0V?$binder2nd@U?$equal_to@H@std@@@0@@Z$2
.xdata$x:0000D7B0                 db    3
.xdata$x:0000D7B1                 db    0
.xdata$x:0000D7B2                 db    0
.xdata$x:0000D7B3                 db    0
.xdata$x:0000D7B4                 dd offset __unwindfunclet$??$find_if@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@V?$binder2nd@U?$equal_to@H@std@@@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0V?$binder2nd@U?$equal_to@H@std@@@0@@Z$3
.xdata$x:0000D7B8                 db    2
.xdata$x:0000D7B9                 db    0
.xdata$x:0000D7BA                 db    0
.xdata$x:0000D7BB                 db    0
.xdata$x:0000D7BC                 dd offset __unwindfunclet$??$find_if@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@V?$binder2nd@U?$equal_to@H@std@@@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0V?$binder2nd@U?$equal_to@H@std@@@0@@Z$4
.xdata$x:0000D7C0                 db    2
.xdata$x:0000D7C1                 db    0
.xdata$x:0000D7C2                 db    0
.xdata$x:0000D7C3                 db    0
.xdata$x:0000D7C4                 dd offset __unwindfunclet$??$find_if@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@V?$binder2nd@U?$equal_to@H@std@@@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0V?$binder2nd@U?$equal_to@H@std@@@0@@Z$5
.xdata$x:0000D7C4 _xdata$x        ends
.xdata$x:0000D7C4
.xdata$x:0000D7C8 ; ===========================================================================
.xdata$x:0000D7C8
.xdata$x:0000D7C8 ; Segment type: Pure data
.xdata$x:0000D7C8 ; Segment permissions: Read
.xdata$x:0000D7C8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D7C8                 assume cs:_xdata$x
.xdata$x:0000D7C8                 ;org 0D7C8h
.xdata$x:0000D7C8 ; COMDAT (pick associative to section at 335C)
.xdata$x:0000D7C8 __unwindtable$??$_Construct@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$vector@_WV?$allocator@_W@std@@@std@@QAEXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z db 0FFh
.xdata$x:0000D7C8                                         ; DATA XREF: .xdata$x:0000D7F0o
.xdata$x:0000D7C9                 db 0FFh
.xdata$x:0000D7CA                 db 0FFh
.xdata$x:0000D7CB                 db 0FFh
.xdata$x:0000D7CC                 dd offset __unwindfunclet$??$_Construct@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$vector@_WV?$allocator@_W@std@@@std@@QAEXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$0
.xdata$x:0000D7D0                 db    0
.xdata$x:0000D7D1                 db    0
.xdata$x:0000D7D2                 db    0
.xdata$x:0000D7D3                 db    0
.xdata$x:0000D7D4                 dd offset __unwindfunclet$??$_Construct@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$vector@_WV?$allocator@_W@std@@@std@@QAEXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$1
.xdata$x:0000D7D8                 db    1
.xdata$x:0000D7D9                 db    0
.xdata$x:0000D7DA                 db    0
.xdata$x:0000D7DB                 db    0
.xdata$x:0000D7DC                 dd offset __unwindfunclet$??$_Construct@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$vector@_WV?$allocator@_W@std@@@std@@QAEXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$2
.xdata$x:0000D7E0                 db    2
.xdata$x:0000D7E1                 db    0
.xdata$x:0000D7E2                 db    0
.xdata$x:0000D7E3                 db    0
.xdata$x:0000D7E4                 dd offset __unwindfunclet$??$_Construct@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$vector@_WV?$allocator@_W@std@@@std@@QAEXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$3
.xdata$x:0000D7E8 __ehfuncinfo$??$_Construct@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$vector@_WV?$allocator@_W@std@@@std@@QAEXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z db  22h ; "
.xdata$x:0000D7E8                                         ; DATA XREF: __ehhandler$??$_Construct@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$vector@_WV?$allocator@_W@std@@@std@@QAEXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z+11o
.xdata$x:0000D7E9                 db    5
.xdata$x:0000D7EA                 db  93h ; 
.xdata$x:0000D7EB                 db  19h
.xdata$x:0000D7EC                 db    4
.xdata$x:0000D7ED                 db    0
.xdata$x:0000D7EE                 db    0
.xdata$x:0000D7EF                 db    0
.xdata$x:0000D7F0                 dd offset __unwindtable$??$_Construct@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$vector@_WV?$allocator@_W@std@@@std@@QAEXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z
.xdata$x:0000D7F4                 db    0
.xdata$x:0000D7F5                 db    0
.xdata$x:0000D7F6                 db    0
.xdata$x:0000D7F7                 db    0
.xdata$x:0000D7F8                 db    0
.xdata$x:0000D7F9                 db    0
.xdata$x:0000D7FA                 db    0
.xdata$x:0000D7FB                 db    0
.xdata$x:0000D7FC                 db    0
.xdata$x:0000D7FD                 db    0
.xdata$x:0000D7FE                 db    0
.xdata$x:0000D7FF                 db    0
.xdata$x:0000D800                 db    0
.xdata$x:0000D801                 db    0
.xdata$x:0000D802                 db    0
.xdata$x:0000D803                 db    0
.xdata$x:0000D804                 db    0
.xdata$x:0000D805                 db    0
.xdata$x:0000D806                 db    0
.xdata$x:0000D807                 db    0
.xdata$x:0000D808                 db    0
.xdata$x:0000D809                 db    0
.xdata$x:0000D80A                 db    0
.xdata$x:0000D80B                 db    0
.xdata$x:0000D80B _xdata$x        ends
.xdata$x:0000D80B
.xdata$x:0000D80C ; ===========================================================================
.xdata$x:0000D80C
.xdata$x:0000D80C ; Segment type: Pure data
.xdata$x:0000D80C ; Segment permissions: Read
.xdata$x:0000D80C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D80C                 assume cs:_xdata$x
.xdata$x:0000D80C                 ;org 0D80Ch
.xdata$x:0000D80C ; COMDAT (pick associative to section at 37B8)
.xdata$x:0000D80C __unwindtable$??$_Debug_range2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z db 0FFh
.xdata$x:0000D80C                                         ; DATA XREF: .xdata$x:0000D824o
.xdata$x:0000D80D                 db 0FFh
.xdata$x:0000D80E                 db 0FFh
.xdata$x:0000D80F                 db 0FFh
.xdata$x:0000D810                 dd offset __unwindfunclet$??$_Debug_range2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z$0
.xdata$x:0000D814                 align 8
.xdata$x:0000D818                 dd offset __unwindfunclet$??$_Debug_range2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z$1
.xdata$x:0000D81C __ehfuncinfo$??$_Debug_range2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z db  22h ; "
.xdata$x:0000D81C                                         ; DATA XREF: __ehhandler$??$_Debug_range2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z+11o
.xdata$x:0000D81D                 db    5
.xdata$x:0000D81E                 db  93h ; 
.xdata$x:0000D81F                 db  19h
.xdata$x:0000D820                 db    2
.xdata$x:0000D821                 db    0
.xdata$x:0000D822                 db    0
.xdata$x:0000D823                 db    0
.xdata$x:0000D824                 dd offset __unwindtable$??$_Debug_range2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z
.xdata$x:0000D828                 align 20h
.xdata$x:0000D828 _xdata$x        ends
.xdata$x:0000D828
.xdata$x:0000D840 ; ===========================================================================
.xdata$x:0000D840
.xdata$x:0000D840 ; Segment type: Pure data
.xdata$x:0000D840 ; Segment permissions: Read
.xdata$x:0000D840 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D840                 assume cs:_xdata$x
.xdata$x:0000D840                 ;org 0D840h
.xdata$x:0000D840 ; COMDAT (pick associative to section at 3458)
.xdata$x:0000D840 __catchsym$??$_Construct@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$vector@_WV?$allocator@_W@std@@@std@@QAEXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0Uforward_iterator_tag@1@@Z$8 db    0
.xdata$x:0000D840                                         ; DATA XREF: .xdata$x:0000D860o
.xdata$x:0000D841                 db    0
.xdata$x:0000D842                 db    0
.xdata$x:0000D843                 db    0
.xdata$x:0000D844                 db    0
.xdata$x:0000D845                 db    0
.xdata$x:0000D846                 db    0
.xdata$x:0000D847                 db    0
.xdata$x:0000D848                 db    0
.xdata$x:0000D849                 db    0
.xdata$x:0000D84A                 db    0
.xdata$x:0000D84B                 db    0
.xdata$x:0000D84C                 dd offset __catch$??$_Construct@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$vector@_WV?$allocator@_W@std@@@std@@QAEXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0Uforward_iterator_tag@1@@Z$0
.xdata$x:0000D850 __tryblocktable$??$_Construct@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$vector@_WV?$allocator@_W@std@@@std@@QAEXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0Uforward_iterator_tag@1@@Z db    4
.xdata$x:0000D850                                         ; DATA XREF: .xdata$x:0000D874o
.xdata$x:0000D851                 db    0
.xdata$x:0000D852                 db    0
.xdata$x:0000D853                 db    0
.xdata$x:0000D854                 db    6
.xdata$x:0000D855                 db    0
.xdata$x:0000D856                 db    0
.xdata$x:0000D857                 db    0
.xdata$x:0000D858                 db    7
.xdata$x:0000D859                 db    0
.xdata$x:0000D85A                 db    0
.xdata$x:0000D85B                 db    0
.xdata$x:0000D85C                 db    1
.xdata$x:0000D85D                 db    0
.xdata$x:0000D85E                 db    0
.xdata$x:0000D85F                 db    0
.xdata$x:0000D860                 dd offset __catchsym$??$_Construct@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$vector@_WV?$allocator@_W@std@@@std@@QAEXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0Uforward_iterator_tag@1@@Z$8
.xdata$x:0000D864 __ehfuncinfo$??$_Construct@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$vector@_WV?$allocator@_W@std@@@std@@QAEXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0Uforward_iterator_tag@1@@Z db  22h ; "
.xdata$x:0000D864                                         ; DATA XREF: __ehhandler$??$_Construct@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$vector@_WV?$allocator@_W@std@@@std@@QAEXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0Uforward_iterator_tag@1@@Z+11o
.xdata$x:0000D865                 db    5
.xdata$x:0000D866                 db  93h ; 
.xdata$x:0000D867                 db  19h
.xdata$x:0000D868                 db    8
.xdata$x:0000D869                 db    0
.xdata$x:0000D86A                 db    0
.xdata$x:0000D86B                 db    0
.xdata$x:0000D86C                 dd offset __unwindtable$??$_Construct@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$vector@_WV?$allocator@_W@std@@@std@@QAEXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0Uforward_iterator_tag@1@@Z
.xdata$x:0000D870                 db    1
.xdata$x:0000D871                 db    0
.xdata$x:0000D872                 db    0
.xdata$x:0000D873                 db    0
.xdata$x:0000D874                 dd offset __tryblocktable$??$_Construct@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$vector@_WV?$allocator@_W@std@@@std@@QAEXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0Uforward_iterator_tag@1@@Z
.xdata$x:0000D878                 db    0
.xdata$x:0000D879                 db    0
.xdata$x:0000D87A                 db    0
.xdata$x:0000D87B                 db    0
.xdata$x:0000D87C                 db    0
.xdata$x:0000D87D                 db    0
.xdata$x:0000D87E                 db    0
.xdata$x:0000D87F                 db    0
.xdata$x:0000D880                 db    0
.xdata$x:0000D881                 db    0
.xdata$x:0000D882                 db    0
.xdata$x:0000D883                 db    0
.xdata$x:0000D884                 db    0
.xdata$x:0000D885                 db    0
.xdata$x:0000D886                 db    0
.xdata$x:0000D887                 db    0
.xdata$x:0000D888 __unwindtable$??$_Construct@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$vector@_WV?$allocator@_W@std@@@std@@QAEXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0Uforward_iterator_tag@1@@Z db 0FFh
.xdata$x:0000D888                                         ; DATA XREF: .xdata$x:0000D86Co
.xdata$x:0000D889                 db 0FFh
.xdata$x:0000D88A                 db 0FFh
.xdata$x:0000D88B                 db 0FFh
.xdata$x:0000D88C                 dd offset __unwindfunclet$??$_Construct@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$vector@_WV?$allocator@_W@std@@@std@@QAEXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0Uforward_iterator_tag@1@@Z$2
.xdata$x:0000D890                 db    0
.xdata$x:0000D891                 db    0
.xdata$x:0000D892                 db    0
.xdata$x:0000D893                 db    0
.xdata$x:0000D894                 dd offset __unwindfunclet$??$_Construct@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$vector@_WV?$allocator@_W@std@@@std@@QAEXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0Uforward_iterator_tag@1@@Z$3
.xdata$x:0000D898                 db    1
.xdata$x:0000D899                 db    0
.xdata$x:0000D89A                 db    0
.xdata$x:0000D89B                 db    0
.xdata$x:0000D89C                 dd offset __unwindfunclet$??$_Construct@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$vector@_WV?$allocator@_W@std@@@std@@QAEXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0Uforward_iterator_tag@1@@Z$4
.xdata$x:0000D8A0                 db    2
.xdata$x:0000D8A1                 db    0
.xdata$x:0000D8A2                 db    0
.xdata$x:0000D8A3                 db    0
.xdata$x:0000D8A4                 dd offset __unwindfunclet$??$_Construct@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$vector@_WV?$allocator@_W@std@@@std@@QAEXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0Uforward_iterator_tag@1@@Z$5
.xdata$x:0000D8A8                 db    1
.xdata$x:0000D8A9                 db    0
.xdata$x:0000D8AA                 db    0
.xdata$x:0000D8AB                 db    0
.xdata$x:0000D8AC                 db    0
.xdata$x:0000D8AD                 db    0
.xdata$x:0000D8AE                 db    0
.xdata$x:0000D8AF                 db    0
.xdata$x:0000D8B0                 db    4
.xdata$x:0000D8B1                 db    0
.xdata$x:0000D8B2                 db    0
.xdata$x:0000D8B3                 db    0
.xdata$x:0000D8B4                 dd offset __unwindfunclet$??$_Construct@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$vector@_WV?$allocator@_W@std@@@std@@QAEXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0Uforward_iterator_tag@1@@Z$6
.xdata$x:0000D8B8                 db    5
.xdata$x:0000D8B9                 db    0
.xdata$x:0000D8BA                 db    0
.xdata$x:0000D8BB                 db    0
.xdata$x:0000D8BC                 dd offset __unwindfunclet$??$_Construct@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$vector@_WV?$allocator@_W@std@@@std@@QAEXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0Uforward_iterator_tag@1@@Z$7
.xdata$x:0000D8C0                 db    1
.xdata$x:0000D8C1                 db    0
.xdata$x:0000D8C2                 db    0
.xdata$x:0000D8C3                 db    0
.xdata$x:0000D8C4                 db    0
.xdata$x:0000D8C5                 db    0
.xdata$x:0000D8C6                 db    0
.xdata$x:0000D8C7                 db    0
.xdata$x:0000D8C7 _xdata$x        ends
.xdata$x:0000D8C7
.xdata$x:0000D8C8 ; ===========================================================================
.xdata$x:0000D8C8
.xdata$x:0000D8C8 ; Segment type: Pure data
.xdata$x:0000D8C8 ; Segment permissions: Read
.xdata$x:0000D8C8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D8C8                 assume cs:_xdata$x
.xdata$x:0000D8C8                 ;org 0D8C8h
.xdata$x:0000D8C8 ; COMDAT (pick associative to section at 55D4)
.xdata$x:0000D8C8 __unwindtable$??$construct@_W_W@?$allocator@_W@std@@QAEXPA_W$$QA_W@Z db 0FFh
.xdata$x:0000D8C8                                         ; DATA XREF: .xdata$x:0000D8D8o
.xdata$x:0000D8C9                 db 0FFh
.xdata$x:0000D8CA                 db 0FFh
.xdata$x:0000D8CB                 db 0FFh
.xdata$x:0000D8CC                 dd offset __unwindfunclet$??$construct@_W_W@?$allocator@_W@std@@QAEXPA_W$$QA_W@Z$0
.xdata$x:0000D8D0 __ehfuncinfo$??$construct@_W_W@?$allocator@_W@std@@QAEXPA_W$$QA_W@Z db  22h ; "
.xdata$x:0000D8D0                                         ; DATA XREF: __ehhandler$??$construct@_W_W@?$allocator@_W@std@@QAEXPA_W$$QA_W@Z+11o
.xdata$x:0000D8D1                 db    5
.xdata$x:0000D8D2                 db  93h ; 
.xdata$x:0000D8D3                 db  19h
.xdata$x:0000D8D4                 db    1
.xdata$x:0000D8D5                 db    0
.xdata$x:0000D8D6                 db    0
.xdata$x:0000D8D7                 db    0
.xdata$x:0000D8D8                 dd offset __unwindtable$??$construct@_W_W@?$allocator@_W@std@@QAEXPA_W$$QA_W@Z
.xdata$x:0000D8DC                 db    0
.xdata$x:0000D8DD                 db    0
.xdata$x:0000D8DE                 db    0
.xdata$x:0000D8DF                 db    0
.xdata$x:0000D8E0                 db    0
.xdata$x:0000D8E1                 db    0
.xdata$x:0000D8E2                 db    0
.xdata$x:0000D8E3                 db    0
.xdata$x:0000D8E4                 db    0
.xdata$x:0000D8E5                 db    0
.xdata$x:0000D8E6                 db    0
.xdata$x:0000D8E7                 db    0
.xdata$x:0000D8E8                 db    0
.xdata$x:0000D8E9                 db    0
.xdata$x:0000D8EA                 db    0
.xdata$x:0000D8EB                 db    0
.xdata$x:0000D8EC                 db    0
.xdata$x:0000D8ED                 db    0
.xdata$x:0000D8EE                 db    0
.xdata$x:0000D8EF                 db    0
.xdata$x:0000D8F0                 db    0
.xdata$x:0000D8F1                 db    0
.xdata$x:0000D8F2                 db    0
.xdata$x:0000D8F3                 db    0
.xdata$x:0000D8F3 _xdata$x        ends
.xdata$x:0000D8F3
.xdata$x:0000D8F4 ; ===========================================================================
.xdata$x:0000D8F4
.xdata$x:0000D8F4 ; Segment type: Pure data
.xdata$x:0000D8F4 ; Segment permissions: Read
.xdata$x:0000D8F4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D8F4                 assume cs:_xdata$x
.xdata$x:0000D8F4                 ;org 0D8F4h
.xdata$x:0000D8F4 ; COMDAT (pick associative to section at 52D0)
.xdata$x:0000D8F4 __unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z db 0FFh
.xdata$x:0000D8F4                                         ; DATA XREF: .xdata$x:0000D904o
.xdata$x:0000D8F5                 db 0FFh
.xdata$x:0000D8F6                 db 0FFh
.xdata$x:0000D8F7                 db 0FFh
.xdata$x:0000D8F8                 dd offset __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0
.xdata$x:0000D8FC __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z db  22h ; "
.xdata$x:0000D8FC                                         ; DATA XREF: __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z+11o
.xdata$x:0000D8FD                 db    5
.xdata$x:0000D8FE                 db  93h ; 
.xdata$x:0000D8FF                 db  19h
.xdata$x:0000D900                 db    1
.xdata$x:0000D901                 db    0
.xdata$x:0000D902                 db    0
.xdata$x:0000D903                 db    0
.xdata$x:0000D904                 dd offset __unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.xdata$x:0000D908                 align 20h
.xdata$x:0000D908 _xdata$x        ends
.xdata$x:0000D908
.xdata$x:0000D920 ; ===========================================================================
.xdata$x:0000D920
.xdata$x:0000D920 ; Segment type: Pure data
.xdata$x:0000D920 ; Segment permissions: Read
.xdata$x:0000D920 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D920                 assume cs:_xdata$x
.xdata$x:0000D920                 ;org 0D920h
.xdata$x:0000D920 ; COMDAT (pick associative to section at 53D0)
.xdata$x:0000D920 __unwindtable$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z db 0FFh
.xdata$x:0000D920                                         ; DATA XREF: .xdata$x:0000D930o
.xdata$x:0000D921                 db 0FFh
.xdata$x:0000D922                 db 0FFh
.xdata$x:0000D923                 db 0FFh
.xdata$x:0000D924                 dd offset __unwindfunclet$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z$0
.xdata$x:0000D928 __ehfuncinfo$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z db  22h ; "
.xdata$x:0000D928                                         ; DATA XREF: __ehhandler$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z+11o
.xdata$x:0000D929                 db    5
.xdata$x:0000D92A                 db  93h ; 
.xdata$x:0000D92B                 db  19h
.xdata$x:0000D92C                 db    1
.xdata$x:0000D92D                 db    0
.xdata$x:0000D92E                 db    0
.xdata$x:0000D92F                 db    0
.xdata$x:0000D930                 dd offset __unwindtable$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z
.xdata$x:0000D934                 db    0
.xdata$x:0000D935                 db    0
.xdata$x:0000D936                 db    0
.xdata$x:0000D937                 db    0
.xdata$x:0000D938                 db    0
.xdata$x:0000D939                 db    0
.xdata$x:0000D93A                 db    0
.xdata$x:0000D93B                 db    0
.xdata$x:0000D93C                 db    0
.xdata$x:0000D93D                 db    0
.xdata$x:0000D93E                 db    0
.xdata$x:0000D93F                 db    0
.xdata$x:0000D940                 db    0
.xdata$x:0000D941                 db    0
.xdata$x:0000D942                 db    0
.xdata$x:0000D943                 db    0
.xdata$x:0000D944                 db    0
.xdata$x:0000D945                 db    0
.xdata$x:0000D946                 db    0
.xdata$x:0000D947                 db    0
.xdata$x:0000D948                 db    0
.xdata$x:0000D949                 db    0
.xdata$x:0000D94A                 db    0
.xdata$x:0000D94B                 db    0
.xdata$x:0000D94B _xdata$x        ends
.xdata$x:0000D94B
.xdata$x:0000D94C ; ===========================================================================
.xdata$x:0000D94C
.xdata$x:0000D94C ; Segment type: Pure data
.xdata$x:0000D94C ; Segment permissions: Read
.xdata$x:0000D94C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D94C                 assume cs:_xdata$x
.xdata$x:0000D94C                 ;org 0D94Ch
.xdata$x:0000D94C ; COMDAT (pick associative to section at 2BE4)
.xdata$x:0000D94C __unwindtable$??$_Buffered_merge_sort@PAHHHUBufferEquivalent@@@std@@YAXPAH0HAAV?$_Temp_iterator@H@0@UBufferEquivalent@@@Z db 0FFh
.xdata$x:0000D94C                                         ; DATA XREF: .xdata$x:0000D95Co
.xdata$x:0000D94D                 db 0FFh
.xdata$x:0000D94E                 db 0FFh
.xdata$x:0000D94F                 db 0FFh
.xdata$x:0000D950                 dd offset __unwindfunclet$??$_Buffered_merge_sort@PAHHHUBufferEquivalent@@@std@@YAXPAH0HAAV?$_Temp_iterator@H@0@UBufferEquivalent@@@Z$0
.xdata$x:0000D954 __ehfuncinfo$??$_Buffered_merge_sort@PAHHHUBufferEquivalent@@@std@@YAXPAH0HAAV?$_Temp_iterator@H@0@UBufferEquivalent@@@Z db  22h ; "
.xdata$x:0000D954                                         ; DATA XREF: __ehhandler$??$_Buffered_merge_sort@PAHHHUBufferEquivalent@@@std@@YAXPAH0HAAV?$_Temp_iterator@H@0@UBufferEquivalent@@@Z+11o
.xdata$x:0000D955                 db    5
.xdata$x:0000D956                 db  93h ; 
.xdata$x:0000D957                 db  19h
.xdata$x:0000D958                 db    1
.xdata$x:0000D959                 db    0
.xdata$x:0000D95A                 db    0
.xdata$x:0000D95B                 db    0
.xdata$x:0000D95C                 dd offset __unwindtable$??$_Buffered_merge_sort@PAHHHUBufferEquivalent@@@std@@YAXPAH0HAAV?$_Temp_iterator@H@0@UBufferEquivalent@@@Z
.xdata$x:0000D960                 db    0
.xdata$x:0000D961                 db    0
.xdata$x:0000D962                 db    0
.xdata$x:0000D963                 db    0
.xdata$x:0000D964                 db    0
.xdata$x:0000D965                 db    0
.xdata$x:0000D966                 db    0
.xdata$x:0000D967                 db    0
.xdata$x:0000D968                 db    0
.xdata$x:0000D969                 db    0
.xdata$x:0000D96A                 db    0
.xdata$x:0000D96B                 db    0
.xdata$x:0000D96C                 db    0
.xdata$x:0000D96D                 db    0
.xdata$x:0000D96E                 db    0
.xdata$x:0000D96F                 db    0
.xdata$x:0000D970                 db    0
.xdata$x:0000D971                 db    0
.xdata$x:0000D972                 db    0
.xdata$x:0000D973                 db    0
.xdata$x:0000D974                 db    0
.xdata$x:0000D975                 db    0
.xdata$x:0000D976                 db    0
.xdata$x:0000D977                 db    0
.xdata$x:0000D977 _xdata$x        ends
.xdata$x:0000D977
.xdata$x:0000D978 ; ===========================================================================
.xdata$x:0000D978
.xdata$x:0000D978 ; Segment type: Pure data
.xdata$x:0000D978 ; Segment permissions: Read
.xdata$x:0000D978 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D978                 assume cs:_xdata$x
.xdata$x:0000D978                 ;org 0D978h
.xdata$x:0000D978 ; COMDAT (pick associative to section at 283C)
.xdata$x:0000D978 __unwindtable$??$_Buffered_merge@PAHHHUBufferEquivalent@@@std@@YAXPAH00HHAAV?$_Temp_iterator@H@0@UBufferEquivalent@@@Z db 0FFh
.xdata$x:0000D978                                         ; DATA XREF: .xdata$x:0000D990o
.xdata$x:0000D979                 db 0FFh
.xdata$x:0000D97A                 db 0FFh
.xdata$x:0000D97B                 db 0FFh
.xdata$x:0000D97C                 dd offset __unwindfunclet$??$_Buffered_merge@PAHHHUBufferEquivalent@@@std@@YAXPAH00HHAAV?$_Temp_iterator@H@0@UBufferEquivalent@@@Z$0
.xdata$x:0000D980                 db 0FFh
.xdata$x:0000D981                 db 0FFh
.xdata$x:0000D982                 db 0FFh
.xdata$x:0000D983                 db 0FFh
.xdata$x:0000D984                 dd offset __unwindfunclet$??$_Buffered_merge@PAHHHUBufferEquivalent@@@std@@YAXPAH00HHAAV?$_Temp_iterator@H@0@UBufferEquivalent@@@Z$2
.xdata$x:0000D988 __ehfuncinfo$??$_Buffered_merge@PAHHHUBufferEquivalent@@@std@@YAXPAH00HHAAV?$_Temp_iterator@H@0@UBufferEquivalent@@@Z db  22h ; "
.xdata$x:0000D988                                         ; DATA XREF: __ehhandler$??$_Buffered_merge@PAHHHUBufferEquivalent@@@std@@YAXPAH00HHAAV?$_Temp_iterator@H@0@UBufferEquivalent@@@Z+11o
.xdata$x:0000D989                 db    5
.xdata$x:0000D98A                 db  93h ; 
.xdata$x:0000D98B                 db  19h
.xdata$x:0000D98C                 db    2
.xdata$x:0000D98D                 db    0
.xdata$x:0000D98E                 db    0
.xdata$x:0000D98F                 db    0
.xdata$x:0000D990                 dd offset __unwindtable$??$_Buffered_merge@PAHHHUBufferEquivalent@@@std@@YAXPAH00HHAAV?$_Temp_iterator@H@0@UBufferEquivalent@@@Z
.xdata$x:0000D994                 db    0
.xdata$x:0000D995                 db    0
.xdata$x:0000D996                 db    0
.xdata$x:0000D997                 db    0
.xdata$x:0000D998                 db    0
.xdata$x:0000D999                 db    0
.xdata$x:0000D99A                 db    0
.xdata$x:0000D99B                 db    0
.xdata$x:0000D99C                 db    0
.xdata$x:0000D99D                 db    0
.xdata$x:0000D99E                 db    0
.xdata$x:0000D99F                 db    0
.xdata$x:0000D9A0                 db    0
.xdata$x:0000D9A1                 db    0
.xdata$x:0000D9A2                 db    0
.xdata$x:0000D9A3                 db    0
.xdata$x:0000D9A4                 db    0
.xdata$x:0000D9A5                 db    0
.xdata$x:0000D9A6                 db    0
.xdata$x:0000D9A7                 db    0
.xdata$x:0000D9A8                 db    0
.xdata$x:0000D9A9                 db    0
.xdata$x:0000D9AA                 db    0
.xdata$x:0000D9AB                 db    0
.xdata$x:0000D9AB _xdata$x        ends
.xdata$x:0000D9AB
.xdata$x:0000D9AC ; ===========================================================================
.xdata$x:0000D9AC
.xdata$x:0000D9AC ; Segment type: Pure data
.xdata$x:0000D9AC ; Segment permissions: Read
.xdata$x:0000D9AC _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D9AC                 assume cs:_xdata$x
.xdata$x:0000D9AC                 ;org 0D9ACh
.xdata$x:0000D9AC ; COMDAT (pick associative to section at 57B4)
.xdata$x:0000D9AC __unwindtable$??$distance@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YAHV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0@Z db 0FFh
.xdata$x:0000D9AC                                         ; DATA XREF: .xdata$x:0000D9D4o
.xdata$x:0000D9AD                 db 0FFh
.xdata$x:0000D9AE                 db 0FFh
.xdata$x:0000D9AF                 db 0FFh
.xdata$x:0000D9B0                 dd offset __unwindfunclet$??$distance@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YAHV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0@Z$0
.xdata$x:0000D9B4                 align 8
.xdata$x:0000D9B8                 dd offset __unwindfunclet$??$distance@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YAHV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0@Z$1
.xdata$x:0000D9BC                 db    1
.xdata$x:0000D9BD                 db    0
.xdata$x:0000D9BE                 db    0
.xdata$x:0000D9BF                 db    0
.xdata$x:0000D9C0                 dd offset __unwindfunclet$??$distance@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YAHV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0@Z$2
.xdata$x:0000D9C4                 db    2
.xdata$x:0000D9C5                 db    0
.xdata$x:0000D9C6                 db    0
.xdata$x:0000D9C7                 db    0
.xdata$x:0000D9C8                 dd offset __unwindfunclet$??$distance@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YAHV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0@Z$3
.xdata$x:0000D9CC __ehfuncinfo$??$distance@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YAHV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0@Z db  22h ; "
.xdata$x:0000D9CC                                         ; DATA XREF: __ehhandler$??$distance@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YAHV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0@Z+11o
.xdata$x:0000D9CD                 db    5
.xdata$x:0000D9CE                 db  93h ; 
.xdata$x:0000D9CF                 db  19h
.xdata$x:0000D9D0                 db    4
.xdata$x:0000D9D1                 db    0
.xdata$x:0000D9D2                 db    0
.xdata$x:0000D9D3                 db    0
.xdata$x:0000D9D4                 dd offset __unwindtable$??$distance@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YAHV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0@Z
.xdata$x:0000D9D8                 db    0
.xdata$x:0000D9D9                 db    0
.xdata$x:0000D9DA                 db    0
.xdata$x:0000D9DB                 db    0
.xdata$x:0000D9DC                 db    0
.xdata$x:0000D9DD                 db    0
.xdata$x:0000D9DE                 db    0
.xdata$x:0000D9DF                 db    0
.xdata$x:0000D9E0                 db    0
.xdata$x:0000D9E1                 db    0
.xdata$x:0000D9E2                 db    0
.xdata$x:0000D9E3                 db    0
.xdata$x:0000D9E4                 db    0
.xdata$x:0000D9E5                 db    0
.xdata$x:0000D9E6                 db    0
.xdata$x:0000D9E7                 db    0
.xdata$x:0000D9E8                 db    0
.xdata$x:0000D9E9                 db    0
.xdata$x:0000D9EA                 db    0
.xdata$x:0000D9EB                 db    0
.xdata$x:0000D9EC                 db    0
.xdata$x:0000D9ED                 db    0
.xdata$x:0000D9EE                 db    0
.xdata$x:0000D9EF                 db    0
.xdata$x:0000D9EF _xdata$x        ends
.xdata$x:0000D9EF
.xdata$x:0000D9F0 ; ===========================================================================
.xdata$x:0000D9F0
.xdata$x:0000D9F0 ; Segment type: Pure data
.xdata$x:0000D9F0 ; Segment permissions: Read
.xdata$x:0000D9F0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D9F0                 assume cs:_xdata$x
.xdata$x:0000D9F0                 ;org 0D9F0h
.xdata$x:0000D9F0 ; COMDAT (pick associative to section at 4A34)
.xdata$x:0000D9F0 __unwindtable$??$_Ucopy@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$vector@_WV?$allocator@_W@std@@@std@@IAEPA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0PA_W@Z db 0FFh
.xdata$x:0000D9F0                                         ; DATA XREF: .xdata$x:0000DA18o
.xdata$x:0000D9F1                 db 0FFh
.xdata$x:0000D9F2                 db 0FFh
.xdata$x:0000D9F3                 db 0FFh
.xdata$x:0000D9F4                 dd offset __unwindfunclet$??$_Ucopy@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$vector@_WV?$allocator@_W@std@@@std@@IAEPA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0PA_W@Z$0
.xdata$x:0000D9F8                 db    0
.xdata$x:0000D9F9                 db    0
.xdata$x:0000D9FA                 db    0
.xdata$x:0000D9FB                 db    0
.xdata$x:0000D9FC                 dd offset __unwindfunclet$??$_Ucopy@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$vector@_WV?$allocator@_W@std@@@std@@IAEPA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0PA_W@Z$1
.xdata$x:0000DA00                 db    1
.xdata$x:0000DA01                 db    0
.xdata$x:0000DA02                 db    0
.xdata$x:0000DA03                 db    0
.xdata$x:0000DA04                 dd offset __unwindfunclet$??$_Ucopy@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$vector@_WV?$allocator@_W@std@@@std@@IAEPA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0PA_W@Z$2
.xdata$x:0000DA08                 db    2
.xdata$x:0000DA09                 db    0
.xdata$x:0000DA0A                 db    0
.xdata$x:0000DA0B                 db    0
.xdata$x:0000DA0C                 dd offset __unwindfunclet$??$_Ucopy@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$vector@_WV?$allocator@_W@std@@@std@@IAEPA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0PA_W@Z$3
.xdata$x:0000DA10 __ehfuncinfo$??$_Ucopy@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$vector@_WV?$allocator@_W@std@@@std@@IAEPA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0PA_W@Z db  22h ; "
.xdata$x:0000DA10                                         ; DATA XREF: __ehhandler$??$_Ucopy@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$vector@_WV?$allocator@_W@std@@@std@@IAEPA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0PA_W@Z+11o
.xdata$x:0000DA11                 db    5
.xdata$x:0000DA12                 db  93h ; 
.xdata$x:0000DA13                 db  19h
.xdata$x:0000DA14                 db    4
.xdata$x:0000DA15                 db    0
.xdata$x:0000DA16                 db    0
.xdata$x:0000DA17                 db    0
.xdata$x:0000DA18                 dd offset __unwindtable$??$_Ucopy@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$vector@_WV?$allocator@_W@std@@@std@@IAEPA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0PA_W@Z
.xdata$x:0000DA1C                 db    0
.xdata$x:0000DA1D                 db    0
.xdata$x:0000DA1E                 db    0
.xdata$x:0000DA1F                 db    0
.xdata$x:0000DA20                 db    0
.xdata$x:0000DA21                 db    0
.xdata$x:0000DA22                 db    0
.xdata$x:0000DA23                 db    0
.xdata$x:0000DA24                 db    0
.xdata$x:0000DA25                 db    0
.xdata$x:0000DA26                 db    0
.xdata$x:0000DA27                 db    0
.xdata$x:0000DA28                 db    0
.xdata$x:0000DA29                 db    0
.xdata$x:0000DA2A                 db    0
.xdata$x:0000DA2B                 db    0
.xdata$x:0000DA2C                 db    0
.xdata$x:0000DA2D                 db    0
.xdata$x:0000DA2E                 db    0
.xdata$x:0000DA2F                 db    0
.xdata$x:0000DA30                 db    0
.xdata$x:0000DA31                 db    0
.xdata$x:0000DA32                 db    0
.xdata$x:0000DA33                 db    0
.xdata$x:0000DA33 _xdata$x        ends
.xdata$x:0000DA33
.xdata$x:0000DA34 ; ===========================================================================
.xdata$x:0000DA34
.xdata$x:0000DA34 ; Segment type: Pure data
.xdata$x:0000DA34 ; Segment permissions: Read
.xdata$x:0000DA34 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000DA34                 assume cs:_xdata$x
.xdata$x:0000DA34                 ;org 0DA34h
.xdata$x:0000DA34 ; COMDAT (pick associative to section at 306C)
.xdata$x:0000DA34 __ehfuncinfo$??$_Chunked_merge@PAHV?$_Temp_iterator@H@std@@HUBufferEquivalent@@@std@@YAXPAH0V?$_Temp_iterator@H@0@HHUBufferEquivalent@@@Z db  22h ; "
.xdata$x:0000DA34                                         ; DATA XREF: __ehhandler$??$_Chunked_merge@PAHV?$_Temp_iterator@H@std@@HUBufferEquivalent@@@std@@YAXPAH0V?$_Temp_iterator@H@0@HHUBufferEquivalent@@@Z+14o
.xdata$x:0000DA35                 db    5
.xdata$x:0000DA36                 db  93h ; 
.xdata$x:0000DA37                 db  19h
.xdata$x:0000DA38                 db    5
.xdata$x:0000DA39                 db    0
.xdata$x:0000DA3A                 db    0
.xdata$x:0000DA3B                 db    0
.xdata$x:0000DA3C                 dd offset __unwindtable$??$_Chunked_merge@PAHV?$_Temp_iterator@H@std@@HUBufferEquivalent@@@std@@YAXPAH0V?$_Temp_iterator@H@0@HHUBufferEquivalent@@@Z
.xdata$x:0000DA40                 db    0
.xdata$x:0000DA41                 db    0
.xdata$x:0000DA42                 db    0
.xdata$x:0000DA43                 db    0
.xdata$x:0000DA44                 db    0
.xdata$x:0000DA45                 db    0
.xdata$x:0000DA46                 db    0
.xdata$x:0000DA47                 db    0
.xdata$x:0000DA48                 db    0
.xdata$x:0000DA49                 db    0
.xdata$x:0000DA4A                 db    0
.xdata$x:0000DA4B                 db    0
.xdata$x:0000DA4C                 db    0
.xdata$x:0000DA4D                 db    0
.xdata$x:0000DA4E                 db    0
.xdata$x:0000DA4F                 db    0
.xdata$x:0000DA50                 db    0
.xdata$x:0000DA51                 db    0
.xdata$x:0000DA52                 db    0
.xdata$x:0000DA53                 db    0
.xdata$x:0000DA54                 db    0
.xdata$x:0000DA55                 db    0
.xdata$x:0000DA56                 db    0
.xdata$x:0000DA57                 db    0
.xdata$x:0000DA58 __unwindtable$??$_Chunked_merge@PAHV?$_Temp_iterator@H@std@@HUBufferEquivalent@@@std@@YAXPAH0V?$_Temp_iterator@H@0@HHUBufferEquivalent@@@Z db 0FFh
.xdata$x:0000DA58                                         ; DATA XREF: .xdata$x:0000DA3Co
.xdata$x:0000DA59                 db 0FFh
.xdata$x:0000DA5A                 db 0FFh
.xdata$x:0000DA5B                 db 0FFh
.xdata$x:0000DA5C                 dd offset __unwindfunclet$??$_Chunked_merge@PAHV?$_Temp_iterator@H@std@@HUBufferEquivalent@@@std@@YAXPAH0V?$_Temp_iterator@H@0@HHUBufferEquivalent@@@Z$0
.xdata$x:0000DA60                 db    0
.xdata$x:0000DA61                 db    0
.xdata$x:0000DA62                 db    0
.xdata$x:0000DA63                 db    0
.xdata$x:0000DA64                 dd offset __unwindfunclet$??$_Chunked_merge@PAHV?$_Temp_iterator@H@std@@HUBufferEquivalent@@@std@@YAXPAH0V?$_Temp_iterator@H@0@HHUBufferEquivalent@@@Z$1
.xdata$x:0000DA68                 db    0
.xdata$x:0000DA69                 db    0
.xdata$x:0000DA6A                 db    0
.xdata$x:0000DA6B                 db    0
.xdata$x:0000DA6C                 dd offset __unwindfunclet$??$_Chunked_merge@PAHV?$_Temp_iterator@H@std@@HUBufferEquivalent@@@std@@YAXPAH0V?$_Temp_iterator@H@0@HHUBufferEquivalent@@@Z$2
.xdata$x:0000DA70                 db    0
.xdata$x:0000DA71                 db    0
.xdata$x:0000DA72                 db    0
.xdata$x:0000DA73                 db    0
.xdata$x:0000DA74                 dd offset __unwindfunclet$??$_Chunked_merge@PAHV?$_Temp_iterator@H@std@@HUBufferEquivalent@@@std@@YAXPAH0V?$_Temp_iterator@H@0@HHUBufferEquivalent@@@Z$3
.xdata$x:0000DA78                 db    0
.xdata$x:0000DA79                 db    0
.xdata$x:0000DA7A                 db    0
.xdata$x:0000DA7B                 db    0
.xdata$x:0000DA7C                 dd offset __unwindfunclet$??$_Chunked_merge@PAHV?$_Temp_iterator@H@std@@HUBufferEquivalent@@@std@@YAXPAH0V?$_Temp_iterator@H@0@HHUBufferEquivalent@@@Z$5
.xdata$x:0000DA7C _xdata$x        ends
.xdata$x:0000DA7C
.xdata$x:0000DA80 ; ===========================================================================
.xdata$x:0000DA80
.xdata$x:0000DA80 ; Segment type: Pure data
.xdata$x:0000DA80 ; Segment permissions: Read
.xdata$x:0000DA80 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000DA80                 assume cs:_xdata$x
.xdata$x:0000DA80                 ;org 0DA80h
.xdata$x:0000DA80 ; COMDAT (pick associative to section at 43A8)
.xdata$x:0000DA80 __unwindtable$??$_Move@PAHV?$_Temp_iterator@H@std@@@std@@YA?AV?$_Temp_iterator@H@0@PAH0V10@@Z db 0FFh
.xdata$x:0000DA80                                         ; DATA XREF: .xdata$x:0000DAA0o
.xdata$x:0000DA81                 db 0FFh
.xdata$x:0000DA82                 db 0FFh
.xdata$x:0000DA83                 db 0FFh
.xdata$x:0000DA84                 dd offset __unwindfunclet$??$_Move@PAHV?$_Temp_iterator@H@std@@@std@@YA?AV?$_Temp_iterator@H@0@PAH0V10@@Z$2
.xdata$x:0000DA88                 db    0
.xdata$x:0000DA89                 db    0
.xdata$x:0000DA8A                 db    0
.xdata$x:0000DA8B                 db    0
.xdata$x:0000DA8C                 dd offset __unwindfunclet$??$_Move@PAHV?$_Temp_iterator@H@std@@@std@@YA?AV?$_Temp_iterator@H@0@PAH0V10@@Z$0
.xdata$x:0000DA90                 db    1
.xdata$x:0000DA91                 db    0
.xdata$x:0000DA92                 db    0
.xdata$x:0000DA93                 db    0
.xdata$x:0000DA94                 dd offset __unwindfunclet$??$_Move@PAHV?$_Temp_iterator@H@std@@@std@@YA?AV?$_Temp_iterator@H@0@PAH0V10@@Z$1
.xdata$x:0000DA98 __ehfuncinfo$??$_Move@PAHV?$_Temp_iterator@H@std@@@std@@YA?AV?$_Temp_iterator@H@0@PAH0V10@@Z db  22h ; "
.xdata$x:0000DA98                                         ; DATA XREF: __ehhandler$??$_Move@PAHV?$_Temp_iterator@H@std@@@std@@YA?AV?$_Temp_iterator@H@0@PAH0V10@@Z+11o
.xdata$x:0000DA99                 db    5
.xdata$x:0000DA9A                 db  93h ; 
.xdata$x:0000DA9B                 db  19h
.xdata$x:0000DA9C                 db    3
.xdata$x:0000DA9D                 db    0
.xdata$x:0000DA9E                 db    0
.xdata$x:0000DA9F                 db    0
.xdata$x:0000DAA0                 dd offset __unwindtable$??$_Move@PAHV?$_Temp_iterator@H@std@@@std@@YA?AV?$_Temp_iterator@H@0@PAH0V10@@Z
.xdata$x:0000DAA4                 db    0
.xdata$x:0000DAA5                 db    0
.xdata$x:0000DAA6                 db    0
.xdata$x:0000DAA7                 db    0
.xdata$x:0000DAA8                 db    0
.xdata$x:0000DAA9                 db    0
.xdata$x:0000DAAA                 db    0
.xdata$x:0000DAAB                 db    0
.xdata$x:0000DAAC                 db    0
.xdata$x:0000DAAD                 db    0
.xdata$x:0000DAAE                 db    0
.xdata$x:0000DAAF                 db    0
.xdata$x:0000DAB0                 db    0
.xdata$x:0000DAB1                 db    0
.xdata$x:0000DAB2                 db    0
.xdata$x:0000DAB3                 db    0
.xdata$x:0000DAB4                 db    0
.xdata$x:0000DAB5                 db    0
.xdata$x:0000DAB6                 db    0
.xdata$x:0000DAB7                 db    0
.xdata$x:0000DAB8                 db    0
.xdata$x:0000DAB9                 db    0
.xdata$x:0000DABA                 db    0
.xdata$x:0000DABB                 db    0
.xdata$x:0000DABB _xdata$x        ends
.xdata$x:0000DABB
.xdata$x:0000DABC ; ===========================================================================
.xdata$x:0000DABC
.xdata$x:0000DABC ; Segment type: Pure data
.xdata$x:0000DABC ; Segment permissions: Read
.xdata$x:0000DABC _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000DABC                 assume cs:_xdata$x
.xdata$x:0000DABC                 ;org 0DABCh
.xdata$x:0000DABC ; COMDAT (pick associative to section at 2D98)
.xdata$x:0000DABC __unwindtable$??$_Buffered_rotate@PAHHH@std@@YAPAHPAH00HHAAV?$_Temp_iterator@H@0@@Z db 0FFh
.xdata$x:0000DABC                                         ; DATA XREF: .xdata$x:0000DAD4o
.xdata$x:0000DABD                 db 0FFh
.xdata$x:0000DABE                 db 0FFh
.xdata$x:0000DABF                 db 0FFh
.xdata$x:0000DAC0                 dd offset __unwindfunclet$??$_Buffered_rotate@PAHHH@std@@YAPAHPAH00HHAAV?$_Temp_iterator@H@0@@Z$0
.xdata$x:0000DAC4                 db 0FFh
.xdata$x:0000DAC5                 db 0FFh
.xdata$x:0000DAC6                 db 0FFh
.xdata$x:0000DAC7                 db 0FFh
.xdata$x:0000DAC8                 dd offset __unwindfunclet$??$_Buffered_rotate@PAHHH@std@@YAPAHPAH00HHAAV?$_Temp_iterator@H@0@@Z$2
.xdata$x:0000DACC __ehfuncinfo$??$_Buffered_rotate@PAHHH@std@@YAPAHPAH00HHAAV?$_Temp_iterator@H@0@@Z db  22h ; "
.xdata$x:0000DACC                                         ; DATA XREF: __ehhandler$??$_Buffered_rotate@PAHHH@std@@YAPAHPAH00HHAAV?$_Temp_iterator@H@0@@Z+11o
.xdata$x:0000DACD                 db    5
.xdata$x:0000DACE                 db  93h ; 
.xdata$x:0000DACF                 db  19h
.xdata$x:0000DAD0                 db    2
.xdata$x:0000DAD1                 db    0
.xdata$x:0000DAD2                 db    0
.xdata$x:0000DAD3                 db    0
.xdata$x:0000DAD4                 dd offset __unwindtable$??$_Buffered_rotate@PAHHH@std@@YAPAHPAH00HHAAV?$_Temp_iterator@H@0@@Z
.xdata$x:0000DAD8                 db    0
.xdata$x:0000DAD9                 db    0
.xdata$x:0000DADA                 db    0
.xdata$x:0000DADB                 db    0
.xdata$x:0000DADC                 db    0
.xdata$x:0000DADD                 db    0
.xdata$x:0000DADE                 db    0
.xdata$x:0000DADF                 db    0
.xdata$x:0000DAE0                 db    0
.xdata$x:0000DAE1                 db    0
.xdata$x:0000DAE2                 db    0
.xdata$x:0000DAE3                 db    0
.xdata$x:0000DAE4                 db    0
.xdata$x:0000DAE5                 db    0
.xdata$x:0000DAE6                 db    0
.xdata$x:0000DAE7                 db    0
.xdata$x:0000DAE8                 db    0
.xdata$x:0000DAE9                 db    0
.xdata$x:0000DAEA                 db    0
.xdata$x:0000DAEB                 db    0
.xdata$x:0000DAEC                 db    0
.xdata$x:0000DAED                 db    0
.xdata$x:0000DAEE                 db    0
.xdata$x:0000DAEF                 db    0
.xdata$x:0000DAEF _xdata$x        ends
.xdata$x:0000DAEF
.xdata$x:0000DAF0 ; ===========================================================================
.xdata$x:0000DAF0
.xdata$x:0000DAF0 ; Segment type: Pure data
.xdata$x:0000DAF0 ; Segment permissions: Read
.xdata$x:0000DAF0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000DAF0                 assume cs:_xdata$x
.xdata$x:0000DAF0                 ;org 0DAF0h
.xdata$x:0000DAF0 ; COMDAT (pick associative to section at 3B50)
.xdata$x:0000DAF0 __unwindtable$??$_Distance2@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@H@std@@YAXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0AAHUrandom_access_iterator_tag@0@@Z db 0FFh
.xdata$x:0000DAF0                                         ; DATA XREF: .xdata$x:0000DB08o
.xdata$x:0000DAF1                 db 0FFh
.xdata$x:0000DAF2                 db 0FFh
.xdata$x:0000DAF3                 db 0FFh
.xdata$x:0000DAF4                 dd offset __unwindfunclet$??$_Distance2@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@H@std@@YAXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0AAHUrandom_access_iterator_tag@0@@Z$0
.xdata$x:0000DAF8                 db    0
.xdata$x:0000DAF9                 db    0
.xdata$x:0000DAFA                 db    0
.xdata$x:0000DAFB                 db    0
.xdata$x:0000DAFC                 dd offset __unwindfunclet$??$_Distance2@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@H@std@@YAXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0AAHUrandom_access_iterator_tag@0@@Z$1
.xdata$x:0000DB00 __ehfuncinfo$??$_Distance2@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@H@std@@YAXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0AAHUrandom_access_iterator_tag@0@@Z db  22h ; "
.xdata$x:0000DB00                                         ; DATA XREF: __ehhandler$??$_Distance2@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@H@std@@YAXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0AAHUrandom_access_iterator_tag@0@@Z+11o
.xdata$x:0000DB01                 db    5
.xdata$x:0000DB02                 db  93h ; 
.xdata$x:0000DB03                 db  19h
.xdata$x:0000DB04                 db    2
.xdata$x:0000DB05                 db    0
.xdata$x:0000DB06                 db    0
.xdata$x:0000DB07                 db    0
.xdata$x:0000DB08                 dd offset __unwindtable$??$_Distance2@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@H@std@@YAXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0AAHUrandom_access_iterator_tag@0@@Z
.xdata$x:0000DB0C                 db    0
.xdata$x:0000DB0D                 db    0
.xdata$x:0000DB0E                 db    0
.xdata$x:0000DB0F                 db    0
.xdata$x:0000DB10                 db    0
.xdata$x:0000DB11                 db    0
.xdata$x:0000DB12                 db    0
.xdata$x:0000DB13                 db    0
.xdata$x:0000DB14                 db    0
.xdata$x:0000DB15                 db    0
.xdata$x:0000DB16                 db    0
.xdata$x:0000DB17                 db    0
.xdata$x:0000DB18                 db    0
.xdata$x:0000DB19                 db    0
.xdata$x:0000DB1A                 db    0
.xdata$x:0000DB1B                 db    0
.xdata$x:0000DB1C                 db    0
.xdata$x:0000DB1D                 db    0
.xdata$x:0000DB1E                 db    0
.xdata$x:0000DB1F                 db    0
.xdata$x:0000DB20                 db    0
.xdata$x:0000DB21                 db    0
.xdata$x:0000DB22                 db    0
.xdata$x:0000DB23                 db    0
.xdata$x:0000DB23 _xdata$x        ends
.xdata$x:0000DB23
.xdata$x:0000DB24 ; ===========================================================================
.xdata$x:0000DB24
.xdata$x:0000DB24 ; Segment type: Pure data
.xdata$x:0000DB24 ; Segment permissions: Read
.xdata$x:0000DB24 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000DB24                 assume cs:_xdata$x
.xdata$x:0000DB24                 ;org 0DB24h
.xdata$x:0000DB24 ; COMDAT (pick associative to section at 4ED0)
.xdata$x:0000DB24 __unwindtable$??$_Uninitialized_copy@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@PA_WU?$_Wrap_alloc@V?$allocator@_W@std@@@2@@std@@YAPA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0PA_WAAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@@Z db 0FFh
.xdata$x:0000DB24                                         ; DATA XREF: .xdata$x:0000DB4Co
.xdata$x:0000DB25                 db 0FFh
.xdata$x:0000DB26                 db 0FFh
.xdata$x:0000DB27                 db 0FFh
.xdata$x:0000DB28                 dd offset __unwindfunclet$??$_Uninitialized_copy@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@PA_WU?$_Wrap_alloc@V?$allocator@_W@std@@@2@@std@@YAPA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0PA_WAAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@@Z$0
.xdata$x:0000DB2C                 align 10h
.xdata$x:0000DB30                 dd offset __unwindfunclet$??$_Uninitialized_copy@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@PA_WU?$_Wrap_alloc@V?$allocator@_W@std@@@2@@std@@YAPA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0PA_WAAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@@Z$1
.xdata$x:0000DB34                 db    1
.xdata$x:0000DB35                 db    0
.xdata$x:0000DB36                 db    0
.xdata$x:0000DB37                 db    0
.xdata$x:0000DB38                 dd offset __unwindfunclet$??$_Uninitialized_copy@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@PA_WU?$_Wrap_alloc@V?$allocator@_W@std@@@2@@std@@YAPA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0PA_WAAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@@Z$2
.xdata$x:0000DB3C                 db    1
.xdata$x:0000DB3D                 db    0
.xdata$x:0000DB3E                 db    0
.xdata$x:0000DB3F                 db    0
.xdata$x:0000DB40                 dd offset __unwindfunclet$??$_Uninitialized_copy@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@PA_WU?$_Wrap_alloc@V?$allocator@_W@std@@@2@@std@@YAPA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0PA_WAAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@@Z$3
.xdata$x:0000DB44 __ehfuncinfo$??$_Uninitialized_copy@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@PA_WU?$_Wrap_alloc@V?$allocator@_W@std@@@2@@std@@YAPA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0PA_WAAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@@Z db  22h ; "
.xdata$x:0000DB44                                         ; DATA XREF: __ehhandler$??$_Uninitialized_copy@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@PA_WU?$_Wrap_alloc@V?$allocator@_W@std@@@2@@std@@YAPA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0PA_WAAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@@Z+11o
.xdata$x:0000DB45                 db    5
.xdata$x:0000DB46                 db  93h ; 
.xdata$x:0000DB47                 db  19h
.xdata$x:0000DB48                 db    4
.xdata$x:0000DB49                 db    0
.xdata$x:0000DB4A                 db    0
.xdata$x:0000DB4B                 db    0
.xdata$x:0000DB4C                 dd offset __unwindtable$??$_Uninitialized_copy@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@PA_WU?$_Wrap_alloc@V?$allocator@_W@std@@@2@@std@@YAPA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0PA_WAAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@@Z
.xdata$x:0000DB50                 db    0
.xdata$x:0000DB51                 db    0
.xdata$x:0000DB52                 db    0
.xdata$x:0000DB53                 db    0
.xdata$x:0000DB54                 db    0
.xdata$x:0000DB55                 db    0
.xdata$x:0000DB56                 db    0
.xdata$x:0000DB57                 db    0
.xdata$x:0000DB58                 db    0
.xdata$x:0000DB59                 db    0
.xdata$x:0000DB5A                 db    0
.xdata$x:0000DB5B                 db    0
.xdata$x:0000DB5C                 db    0
.xdata$x:0000DB5D                 db    0
.xdata$x:0000DB5E                 db    0
.xdata$x:0000DB5F                 db    0
.xdata$x:0000DB60                 db    0
.xdata$x:0000DB61                 db    0
.xdata$x:0000DB62                 db    0
.xdata$x:0000DB63                 db    0
.xdata$x:0000DB64                 db    0
.xdata$x:0000DB65                 db    0
.xdata$x:0000DB66                 db    0
.xdata$x:0000DB67                 db    0
.xdata$x:0000DB67 _xdata$x        ends
.xdata$x:0000DB67
.xdata$x:0000DB68 ; ===========================================================================
.xdata$x:0000DB68
.xdata$x:0000DB68 ; Segment type: Pure data
.xdata$x:0000DB68 ; Segment permissions: Read
.xdata$x:0000DB68 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000DB68                 assume cs:_xdata$x
.xdata$x:0000DB68                 ;org 0DB68h
.xdata$x:0000DB68 ; COMDAT (pick associative to section at 4014)
.xdata$x:0000DB68 __ehfuncinfo$??$_Merge@PAHPAHV?$_Temp_iterator@H@std@@UBufferEquivalent@@@std@@YA?AV?$_Temp_iterator@H@0@PAH000V10@UBufferEquivalent@@@Z db  22h ; "
.xdata$x:0000DB68                                         ; DATA XREF: __ehhandler$??$_Merge@PAHPAHV?$_Temp_iterator@H@std@@UBufferEquivalent@@@std@@YA?AV?$_Temp_iterator@H@0@PAH000V10@UBufferEquivalent@@@Z+11o
.xdata$x:0000DB69                 db    5
.xdata$x:0000DB6A                 db  93h ; 
.xdata$x:0000DB6B                 db  19h
.xdata$x:0000DB6C                 db    5
.xdata$x:0000DB6D                 db    0
.xdata$x:0000DB6E                 db    0
.xdata$x:0000DB6F                 db    0
.xdata$x:0000DB70                 dd offset __unwindtable$??$_Merge@PAHPAHV?$_Temp_iterator@H@std@@UBufferEquivalent@@@std@@YA?AV?$_Temp_iterator@H@0@PAH000V10@UBufferEquivalent@@@Z
.xdata$x:0000DB74                 db    0
.xdata$x:0000DB75                 db    0
.xdata$x:0000DB76                 db    0
.xdata$x:0000DB77                 db    0
.xdata$x:0000DB78                 db    0
.xdata$x:0000DB79                 db    0
.xdata$x:0000DB7A                 db    0
.xdata$x:0000DB7B                 db    0
.xdata$x:0000DB7C                 db    0
.xdata$x:0000DB7D                 db    0
.xdata$x:0000DB7E                 db    0
.xdata$x:0000DB7F                 db    0
.xdata$x:0000DB80                 db    0
.xdata$x:0000DB81                 db    0
.xdata$x:0000DB82                 db    0
.xdata$x:0000DB83                 db    0
.xdata$x:0000DB84                 db    0
.xdata$x:0000DB85                 db    0
.xdata$x:0000DB86                 db    0
.xdata$x:0000DB87                 db    0
.xdata$x:0000DB88                 db    0
.xdata$x:0000DB89                 db    0
.xdata$x:0000DB8A                 db    0
.xdata$x:0000DB8B                 db    0
.xdata$x:0000DB8C __unwindtable$??$_Merge@PAHPAHV?$_Temp_iterator@H@std@@UBufferEquivalent@@@std@@YA?AV?$_Temp_iterator@H@0@PAH000V10@UBufferEquivalent@@@Z db 0FFh
.xdata$x:0000DB8C                                         ; DATA XREF: .xdata$x:0000DB70o
.xdata$x:0000DB8D                 db 0FFh
.xdata$x:0000DB8E                 db 0FFh
.xdata$x:0000DB8F                 db 0FFh
.xdata$x:0000DB90                 dd offset __unwindfunclet$??$_Merge@PAHPAHV?$_Temp_iterator@H@std@@UBufferEquivalent@@@std@@YA?AV?$_Temp_iterator@H@0@PAH000V10@UBufferEquivalent@@@Z$4
.xdata$x:0000DB94                 align 8
.xdata$x:0000DB98                 dd offset __unwindfunclet$??$_Merge@PAHPAHV?$_Temp_iterator@H@std@@UBufferEquivalent@@@std@@YA?AV?$_Temp_iterator@H@0@PAH000V10@UBufferEquivalent@@@Z$0
.xdata$x:0000DB9C                 db    1
.xdata$x:0000DB9D                 db    0
.xdata$x:0000DB9E                 db    0
.xdata$x:0000DB9F                 db    0
.xdata$x:0000DBA0                 dd offset __unwindfunclet$??$_Merge@PAHPAHV?$_Temp_iterator@H@std@@UBufferEquivalent@@@std@@YA?AV?$_Temp_iterator@H@0@PAH000V10@UBufferEquivalent@@@Z$1
.xdata$x:0000DBA4                 db    1
.xdata$x:0000DBA5                 db    0
.xdata$x:0000DBA6                 db    0
.xdata$x:0000DBA7                 db    0
.xdata$x:0000DBA8                 dd offset __unwindfunclet$??$_Merge@PAHPAHV?$_Temp_iterator@H@std@@UBufferEquivalent@@@std@@YA?AV?$_Temp_iterator@H@0@PAH000V10@UBufferEquivalent@@@Z$2
.xdata$x:0000DBAC                 db    1
.xdata$x:0000DBAD                 db    0
.xdata$x:0000DBAE                 db    0
.xdata$x:0000DBAF                 db    0
.xdata$x:0000DBB0                 dd offset __unwindfunclet$??$_Merge@PAHPAHV?$_Temp_iterator@H@std@@UBufferEquivalent@@@std@@YA?AV?$_Temp_iterator@H@0@PAH000V10@UBufferEquivalent@@@Z$3
.xdata$x:0000DBB0 _xdata$x        ends
.xdata$x:0000DBB0
.xdata$x:0000DBB4 ; ===========================================================================
.xdata$x:0000DBB4
.xdata$x:0000DBB4 ; Segment type: Pure data
.xdata$x:0000DBB4 ; Segment permissions: Read
.xdata$x:0000DBB4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000DBB4                 assume cs:_xdata$x
.xdata$x:0000DBB4                 ;org 0DBB4h
.xdata$x:0000DBB4 ; COMDAT (pick associative to section at 4498)
.xdata$x:0000DBB4 __unwindtable$??$_Move@PAHV?$_Temp_iterator@H@std@@@std@@YA?AV?$_Temp_iterator@H@0@PAH0V10@U_Nonscalar_ptr_iterator_tag@0@@Z db 0FFh
.xdata$x:0000DBB4                                         ; DATA XREF: .xdata$x:0000DBCCo
.xdata$x:0000DBB5                 db 0FFh
.xdata$x:0000DBB6                 db 0FFh
.xdata$x:0000DBB7                 db 0FFh
.xdata$x:0000DBB8                 dd offset __unwindfunclet$??$_Move@PAHV?$_Temp_iterator@H@std@@@std@@YA?AV?$_Temp_iterator@H@0@PAH0V10@U_Nonscalar_ptr_iterator_tag@0@@Z$1
.xdata$x:0000DBBC                 align 10h
.xdata$x:0000DBC0                 dd offset __unwindfunclet$??$_Move@PAHV?$_Temp_iterator@H@std@@@std@@YA?AV?$_Temp_iterator@H@0@PAH0V10@U_Nonscalar_ptr_iterator_tag@0@@Z$0
.xdata$x:0000DBC4 __ehfuncinfo$??$_Move@PAHV?$_Temp_iterator@H@std@@@std@@YA?AV?$_Temp_iterator@H@0@PAH0V10@U_Nonscalar_ptr_iterator_tag@0@@Z db  22h ; "
.xdata$x:0000DBC4                                         ; DATA XREF: __ehhandler$??$_Move@PAHV?$_Temp_iterator@H@std@@@std@@YA?AV?$_Temp_iterator@H@0@PAH0V10@U_Nonscalar_ptr_iterator_tag@0@@Z+11o
.xdata$x:0000DBC5                 db    5
.xdata$x:0000DBC6                 db  93h ; 
.xdata$x:0000DBC7                 db  19h
.xdata$x:0000DBC8                 db    2
.xdata$x:0000DBC9                 db    0
.xdata$x:0000DBCA                 db    0
.xdata$x:0000DBCB                 db    0
.xdata$x:0000DBCC                 dd offset __unwindtable$??$_Move@PAHV?$_Temp_iterator@H@std@@@std@@YA?AV?$_Temp_iterator@H@0@PAH0V10@U_Nonscalar_ptr_iterator_tag@0@@Z
.xdata$x:0000DBD0                 db    0
.xdata$x:0000DBD1                 db    0
.xdata$x:0000DBD2                 db    0
.xdata$x:0000DBD3                 db    0
.xdata$x:0000DBD4                 db    0
.xdata$x:0000DBD5                 db    0
.xdata$x:0000DBD6                 db    0
.xdata$x:0000DBD7                 db    0
.xdata$x:0000DBD8                 db    0
.xdata$x:0000DBD9                 db    0
.xdata$x:0000DBDA                 db    0
.xdata$x:0000DBDB                 db    0
.xdata$x:0000DBDC                 db    0
.xdata$x:0000DBDD                 db    0
.xdata$x:0000DBDE                 db    0
.xdata$x:0000DBDF                 db    0
.xdata$x:0000DBE0                 db    0
.xdata$x:0000DBE1                 db    0
.xdata$x:0000DBE2                 db    0
.xdata$x:0000DBE3                 db    0
.xdata$x:0000DBE4                 db    0
.xdata$x:0000DBE5                 db    0
.xdata$x:0000DBE6                 db    0
.xdata$x:0000DBE7                 db    0
.xdata$x:0000DBE7 _xdata$x        ends
.xdata$x:0000DBE7
.xdata$x:0000DBE8 ; ===========================================================================
.xdata$x:0000DBE8
.xdata$x:0000DBE8 ; Segment type: Pure data
.xdata$x:0000DBE8 ; Segment permissions: Read
.xdata$x:0000DBE8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000DBE8                 assume cs:_xdata$x
.xdata$x:0000DBE8                 ;org 0DBE8h
.xdata$x:0000DBE8 ; COMDAT (pick associative to section at 4BAC)
.xdata$x:0000DBE8 __unwindtable$??$_Unchecked@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@@Z db 0FFh
.xdata$x:0000DBE8                                         ; DATA XREF: .xdata$x:0000DBF8o
.xdata$x:0000DBE9                 db 0FFh
.xdata$x:0000DBEA                 db 0FFh
.xdata$x:0000DBEB                 db 0FFh
.xdata$x:0000DBEC                 dd offset __unwindfunclet$??$_Unchecked@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@@Z$0
.xdata$x:0000DBF0 __ehfuncinfo$??$_Unchecked@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@@Z db  22h ; "
.xdata$x:0000DBF0                                         ; DATA XREF: __ehhandler$??$_Unchecked@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@@Z+11o
.xdata$x:0000DBF1                 db    5
.xdata$x:0000DBF2                 db  93h ; 
.xdata$x:0000DBF3                 db  19h
.xdata$x:0000DBF4                 db    1
.xdata$x:0000DBF5                 db    0
.xdata$x:0000DBF6                 db    0
.xdata$x:0000DBF7                 db    0
.xdata$x:0000DBF8                 dd offset __unwindtable$??$_Unchecked@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@@Z
.xdata$x:0000DBFC                 db    0
.xdata$x:0000DBFD                 db    0
.xdata$x:0000DBFE                 db    0
.xdata$x:0000DBFF                 db    0
.xdata$x:0000DC00                 db    0
.xdata$x:0000DC01                 db    0
.xdata$x:0000DC02                 db    0
.xdata$x:0000DC03                 db    0
.xdata$x:0000DC04                 db    0
.xdata$x:0000DC05                 db    0
.xdata$x:0000DC06                 db    0
.xdata$x:0000DC07                 db    0
.xdata$x:0000DC08                 db    0
.xdata$x:0000DC09                 db    0
.xdata$x:0000DC0A                 db    0
.xdata$x:0000DC0B                 db    0
.xdata$x:0000DC0C                 db    0
.xdata$x:0000DC0D                 db    0
.xdata$x:0000DC0E                 db    0
.xdata$x:0000DC0F                 db    0
.xdata$x:0000DC10                 db    0
.xdata$x:0000DC11                 db    0
.xdata$x:0000DC12                 db    0
.xdata$x:0000DC13                 db    0
.xdata$x:0000DC13 _xdata$x        ends
.xdata$x:0000DC13
.xdata$x:0000DC14 ; ===========================================================================
.xdata$x:0000DC14
.xdata$x:0000DC14 ; Segment type: Pure data
.xdata$x:0000DC14 ; Segment permissions: Read
.xdata$x:0000DC14 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000DC14                 assume cs:_xdata$x
.xdata$x:0000DC14                 ;org 0DC14h
.xdata$x:0000DC14 ; COMDAT (pick associative to section at 32A8)
.xdata$x:0000DC14 __unwindtable$??$_Construct@HH@std@@YAXPAH$$QAH@Z db 0FFh
.xdata$x:0000DC14                                         ; DATA XREF: .xdata$x:0000DC24o
.xdata$x:0000DC15                 db 0FFh
.xdata$x:0000DC16                 db 0FFh
.xdata$x:0000DC17                 db 0FFh
.xdata$x:0000DC18                 dd offset __unwindfunclet$??$_Construct@HH@std@@YAXPAH$$QAH@Z$0
.xdata$x:0000DC1C __ehfuncinfo$??$_Construct@HH@std@@YAXPAH$$QAH@Z db  22h ; "
.xdata$x:0000DC1C                                         ; DATA XREF: __ehhandler$??$_Construct@HH@std@@YAXPAH$$QAH@Z+11o
.xdata$x:0000DC1D                 db    5
.xdata$x:0000DC1E                 db  93h ; 
.xdata$x:0000DC1F                 db  19h
.xdata$x:0000DC20                 db    1
.xdata$x:0000DC21                 db    0
.xdata$x:0000DC22                 db    0
.xdata$x:0000DC23                 db    0
.xdata$x:0000DC24                 dd offset __unwindtable$??$_Construct@HH@std@@YAXPAH$$QAH@Z
.xdata$x:0000DC28                 align 20h
.xdata$x:0000DC28 _xdata$x        ends
.xdata$x:0000DC28
.rdata:0000DC40 ; ===========================================================================
.rdata:0000DC40
.rdata:0000DC40 ; Segment type: Pure data
.rdata:0000DC40 ; Segment permissions: Read
.rdata:0000DC40 ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000DC40 _rdata          segment para public 'DATA' use32
.rdata:0000DC40                 assume cs:_rdata
.rdata:0000DC40                 ;org 0DC40h
.rdata:0000DC40 ; COMDAT (pick any)
.rdata:0000DC40                 public ??_C@_1JA@EADLBAJ@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:0000DC40 ; wchar_t `string'
.rdata:0000DC40 ??_C@_1JA@EADLBAJ@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:0000DC40                                         ; DATA XREF: std::_Distance2<int *,int>(int *,int *,int &,std::random_access_iterator_tag)+10o
.rdata:0000DC40                                         ; std::_Distance2<int *,int>(int *,int *,int &,std::random_access_iterator_tag)+26o ...
.rdata:0000DC40                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:0000DC40                 unicode 0, <clude\xutility>,0
.rdata:0000DC40 _rdata          ends
.rdata:0000DC40
.rdata:0000DCD0 ; ===========================================================================
.rdata:0000DCD0
.rdata:0000DCD0 ; Segment type: Pure data
.rdata:0000DCD0 ; Segment permissions: Read
.rdata:0000DCD0 _rdata          segment dword public 'DATA' use32
.rdata:0000DCD0                 assume cs:_rdata
.rdata:0000DCD0                 ;org 0DCD0h
.rdata:0000DCD0 ; COMDAT (pick any)
.rdata:0000DCD0                 public ??_C@_1DC@POOIKBAO@?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5?$AAC?$AAO?$AAR?$AAR?$AAU?$AAP?$AAT?$AAE?$AAD?$AA?$CB?$AA?$AA@
.rdata:0000DCD0 ; wchar_t `string'
.rdata:0000DCD0 ??_C@_1DC@POOIKBAO@?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5?$AAC?$AAO?$AAR?$AAR?$AAU?$AAP?$AAT?$AAE?$AAD?$AA?$CB?$AA?$AA@:
.rdata:0000DCD0                                         ; DATA XREF: std::_Iterator_base12::_Orphan_me(void)+4Do
.rdata:0000DCD0                 unicode 0, <ITERATOR LIST CORRUPTED!>,0
.rdata:0000DD02                 align 4
.rdata:0000DD02 _rdata          ends
.rdata:0000DD02
.rdata:0000DD04 ; ===========================================================================
.rdata:0000DD04
.rdata:0000DD04 ; Segment type: Pure data
.rdata:0000DD04 ; Segment permissions: Read
.rdata:0000DD04 ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000DD04 _rdata          segment para public 'DATA' use32
.rdata:0000DD04                 assume cs:_rdata
.rdata:0000DD04                 ;org 0DD04h
.rdata:0000DD04 ; COMDAT (pick any)
.rdata:0000DD04                 public ??_C@_1KO@LJAFCIDL@?$AAc?$AA?3?$AA?2?$AAw?$AAo?$AAr?$AAk?$AAs?$AAp?$AAa?$AAc?$AAe?$AA?2?$AAn?$AAo?$AAt?$AAe?$AAp?$AAa?$AAd?$AA?9?$AAp?$AAl?$AAu?$AAs?$AA?9?$AAp?$AAl?$AAu?$AAs?$AA?9?$AA6@
.rdata:0000DD04 ; wchar_t `string'
.rdata:0000DD04 ??_C@_1KO@LJAFCIDL@?$AAc?$AA?3?$AA?2?$AAw?$AAo?$AAr?$AAk?$AAs?$AAp?$AAa?$AAc?$AAe?$AA?2?$AAn?$AAo?$AAt?$AAe?$AAp?$AAa?$AAd?$AA?9?$AAp?$AAl?$AAu?$AAs?$AA?9?$AAp?$AAl?$AAu?$AAs?$AA?9?$AA6@:
.rdata:0000DD04                                         ; DATA XREF: CWinMgr::CalcLayout(HWND__ *)+1Eo
.rdata:0000DD04                                         ; CWinMgr::CalcLayout(tagRECT,HWND__ *)+15o
.rdata:0000DD04                 unicode 0, <c:\workspace\notepad-plus-plus-6.7.9.2\powereditor\src\wi>
.rdata:0000DD04                 unicode 0, <ncontrols\windowsdlg\WinMgr.h>,0
.rdata:0000DDB2                 align 4
.rdata:0000DDB2 _rdata          ends
.rdata:0000DDB2
.rdata:0000DDB4 ; ===========================================================================
.rdata:0000DDB4
.rdata:0000DDB4 ; Segment type: Pure data
.rdata:0000DDB4 ; Segment permissions: Read
.rdata:0000DDB4 _rdata          segment dword public 'DATA' use32
.rdata:0000DDB4                 assume cs:_rdata
.rdata:0000DDB4                 ;org 0DDB4h
.rdata:0000DDB4 ; COMDAT (pick any)
.rdata:0000DDB4                 public ??_C@_19HBMCHKM@?$AAh?$AAW?$AAn?$AAd?$AA?$AA@
.rdata:0000DDB4 ; wchar_t `string'
.rdata:0000DDB4 ??_C@_19HBMCHKM@?$AAh?$AAW?$AAn?$AAd?$AA?$AA@:
.rdata:0000DDB4                                         ; DATA XREF: CWinMgr::CalcLayout(HWND__ *)+23o
.rdata:0000DDB4                 unicode 0, <hWnd>,0
.rdata:0000DDBE                 align 10h
.rdata:0000DDBE _rdata          ends
.rdata:0000DDBE
.rdata:0000DDC0 ; ===========================================================================
.rdata:0000DDC0
.rdata:0000DDC0 ; Segment type: Pure data
.rdata:0000DDC0 ; Segment permissions: Read
.rdata:0000DDC0 _rdata          segment dword public 'DATA' use32
.rdata:0000DDC0                 assume cs:_rdata
.rdata:0000DDC0                 ;org 0DDC0h
.rdata:0000DDC0 ; COMDAT (pick any)
.rdata:0000DDC0                 public ??_C@_1M@JJLBEALK@?$AAm?$AA_?$AAm?$AAa?$AAp?$AA?$AA@
.rdata:0000DDC0 ; wchar_t `string'
.rdata:0000DDC0 ??_C@_1M@JJLBEALK@?$AAm?$AA_?$AAm?$AAa?$AAp?$AA?$AA@:
.rdata:0000DDC0                                         ; DATA XREF: CWinMgr::CalcLayout(tagRECT,HWND__ *)+1Ao
.rdata:0000DDC0                 unicode 0, <m_map>,0
.rdata:0000DDC0 _rdata          ends
.rdata:0000DDC0
.rdata:0000DDCC ; ===========================================================================
.rdata:0000DDCC
.rdata:0000DDCC ; Segment type: Pure data
.rdata:0000DDCC ; Segment permissions: Read
.rdata:0000DDCC _rdata          segment dword public 'DATA' use32
.rdata:0000DDCC                 assume cs:_rdata
.rdata:0000DDCC                 ;org 0DDCCh
.rdata:0000DDCC ; COMDAT (pick largest)
.rdata:0000DDCC                 dd offset ??_R4Window@@6B@ ; const Window::`RTTI Complete Object Locator'
.rdata:0000DDD0                 public ??_7Window@@6B@
.rdata:0000DDD0 ; const Window::`vftable'
.rdata:0000DDD0 ??_7Window@@6B@ dd offset ??_EWindow@@UAEPAXI@Z
.rdata:0000DDD0                                         ; DATA XREF: Window::~Window(void)+Ao
.rdata:0000DDD0                                         ; Window::`vector deleting destructor'(uint)
.rdata:0000DDD4                 dd offset ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z ; Window::init(HINSTANCE__ *,HWND__ *)
.rdata:0000DDD8                 dd offset __purecall
.rdata:0000DDDC                 dd offset ?display@Window@@UBEX_N@Z ; Window::display(bool)
.rdata:0000DDE0                 dd offset ?reSizeTo@Window@@UAEXAAUtagRECT@@@Z ; Window::reSizeTo(tagRECT &)
.rdata:0000DDE4                 dd offset ?reSizeToWH@Window@@UAEXAAUtagRECT@@@Z ; Window::reSizeToWH(tagRECT &)
.rdata:0000DDE8                 dd offset ?redraw@Window@@UBEX_N@Z ; Window::redraw(bool)
.rdata:0000DDEC                 dd offset ?getClientRect@Window@@UBEXAAUtagRECT@@@Z ; Window::getClientRect(tagRECT &)
.rdata:0000DDF0                 dd offset ?getWindowRect@Window@@UBEXAAUtagRECT@@@Z ; Window::getWindowRect(tagRECT &)
.rdata:0000DDF4                 dd offset ?getWidth@Window@@UBEHXZ ; Window::getWidth(void)
.rdata:0000DDF8                 dd offset ?getHeight@Window@@UBEHXZ ; Window::getHeight(void)
.rdata:0000DDFC                 dd offset ?isVisible@Window@@UBE_NXZ ; Window::isVisible(void)
.rdata:0000DDFC _rdata          ends
.rdata:0000DDFC
.rdata:0000DE00 ; ===========================================================================
.rdata:0000DE00
.rdata:0000DE00 ; Segment type: Pure data
.rdata:0000DE00 ; Segment permissions: Read
.rdata:0000DE00 _rdata          segment dword public 'DATA' use32
.rdata:0000DE00                 assume cs:_rdata
.rdata:0000DE00                 ;org 0DE00h
.rdata:0000DE00 ; COMDAT (pick largest)
.rdata:0000DE00                 dd offset ??_R4StaticDialog@@6B@ ; const StaticDialog::`RTTI Complete Object Locator'
.rdata:0000DE04                 public ??_7StaticDialog@@6B@
.rdata:0000DE04 ; const StaticDialog::`vftable'
.rdata:0000DE04 ??_7StaticDialog@@6B@ dd offset ??_EStaticDialog@@UAEPAXI@Z
.rdata:0000DE04                                         ; DATA XREF: StaticDialog::~StaticDialog(void)+29o
.rdata:0000DE04                                         ; StaticDialog::`vector deleting destructor'(uint)
.rdata:0000DE08                 dd offset ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z ; Window::init(HINSTANCE__ *,HWND__ *)
.rdata:0000DE0C                 dd offset ?destroy@StaticDialog@@UAEXXZ ; StaticDialog::destroy(void)
.rdata:0000DE10                 dd offset ?display@StaticDialog@@UBEX_N@Z ; StaticDialog::display(bool)
.rdata:0000DE14                 dd offset ?reSizeTo@Window@@UAEXAAUtagRECT@@@Z ; Window::reSizeTo(tagRECT &)
.rdata:0000DE18                 dd offset ?reSizeToWH@Window@@UAEXAAUtagRECT@@@Z ; Window::reSizeToWH(tagRECT &)
.rdata:0000DE1C                 dd offset ?redraw@Window@@UBEX_N@Z ; Window::redraw(bool)
.rdata:0000DE20                 dd offset ?getClientRect@Window@@UBEXAAUtagRECT@@@Z ; Window::getClientRect(tagRECT &)
.rdata:0000DE24                 dd offset ?getWindowRect@Window@@UBEXAAUtagRECT@@@Z ; Window::getWindowRect(tagRECT &)
.rdata:0000DE28                 dd offset ?getWidth@Window@@UBEHXZ ; Window::getWidth(void)
.rdata:0000DE2C                 dd offset ?getHeight@Window@@UBEHXZ ; Window::getHeight(void)
.rdata:0000DE30                 dd offset ?isVisible@Window@@UBE_NXZ ; Window::isVisible(void)
.rdata:0000DE34                 dd offset ?create@StaticDialog@@UAEXH_N0@Z ; StaticDialog::create(int,bool,bool)
.rdata:0000DE38                 dd offset ?isCreated@StaticDialog@@UBE_NXZ ; StaticDialog::isCreated(void)
.rdata:0000DE3C                 dd offset __purecall
.rdata:0000DE3C _rdata          ends
.rdata:0000DE3C
.rdata:0000DE40 ; ===========================================================================
.rdata:0000DE40
.rdata:0000DE40 ; Segment type: Pure data
.rdata:0000DE40 ; Segment permissions: Read
.rdata:0000DE40 _rdata          segment dword public 'DATA' use32
.rdata:0000DE40                 assume cs:_rdata
.rdata:0000DE40                 ;org 0DE40h
.rdata:0000DE40 ; COMDAT (pick largest)
.rdata:0000DE40                 dd offset ??_R4error_category@std@@6B@ ; const std::error_category::`RTTI Complete Object Locator'
.rdata:0000DE44                 public ??_7error_category@std@@6B@
.rdata:0000DE44 ; const std::error_category::`vftable'
.rdata:0000DE44 ??_7error_category@std@@6B@ dd offset ??_Eerror_category@std@@UAEPAXI@Z
.rdata:0000DE44                                         ; DATA XREF: std::error_category::error_category(void)+Ao
.rdata:0000DE44                                         ; std::error_category::~error_category(void)+Ao
.rdata:0000DE44                                         ; std::error_category::`vector deleting destructor'(uint)
.rdata:0000DE48                 dd offset __purecall
.rdata:0000DE4C                 dd offset __purecall
.rdata:0000DE50                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:0000DE54                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:0000DE58                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:0000DE58 _rdata          ends
.rdata:0000DE58
.rdata:0000DE5C ; ===========================================================================
.rdata:0000DE5C
.rdata:0000DE5C ; Segment type: Pure data
.rdata:0000DE5C ; Segment permissions: Read
.rdata:0000DE5C _rdata          segment dword public 'DATA' use32
.rdata:0000DE5C                 assume cs:_rdata
.rdata:0000DE5C                 ;org 0DE5Ch
.rdata:0000DE5C ; COMDAT (pick largest)
.rdata:0000DE5C                 dd offset ??_R4_Generic_error_category@std@@6B@ ; const std::_Generic_error_category::`RTTI Complete Object Locator'
.rdata:0000DE60                 public ??_7_Generic_error_category@std@@6B@
.rdata:0000DE60 ; const std::_Generic_error_category::`vftable'
.rdata:0000DE60 ??_7_Generic_error_category@std@@6B@ dd offset ??_E_Generic_error_category@std@@UAEPAXI@Z
.rdata:0000DE60                                         ; DATA XREF: std::_Generic_error_category::_Generic_error_category(void)+38o
.rdata:0000DE60                                         ; std::_Generic_error_category::`vector deleting destructor'(uint)
.rdata:0000DE64                 dd offset ?name@_Generic_error_category@std@@UBEPBDXZ ; std::_Generic_error_category::name(void)
.rdata:0000DE68                 dd offset ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
.rdata:0000DE6C                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:0000DE70                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:0000DE74                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:0000DE74 _rdata          ends
.rdata:0000DE74
.rdata:0000DE78 ; ===========================================================================
.rdata:0000DE78
.rdata:0000DE78 ; Segment type: Pure data
.rdata:0000DE78 ; Segment permissions: Read
.rdata:0000DE78 _rdata          segment dword public 'DATA' use32
.rdata:0000DE78                 assume cs:_rdata
.rdata:0000DE78                 ;org 0DE78h
.rdata:0000DE78 ; COMDAT (pick any)
.rdata:0000DE78                 public ??_C@_07DCLBNMLN@generic?$AA@
.rdata:0000DE78 ; `string'
.rdata:0000DE78 ??_C@_07DCLBNMLN@generic?$AA@ db 'generic',0
.rdata:0000DE78                                         ; DATA XREF: std::_Generic_error_category::name(void)+7o
.rdata:0000DE78 _rdata          ends
.rdata:0000DE78
.rdata:0000DE80 ; ===========================================================================
.rdata:0000DE80
.rdata:0000DE80 ; Segment type: Pure data
.rdata:0000DE80 ; Segment permissions: Read
.rdata:0000DE80 _rdata          segment dword public 'DATA' use32
.rdata:0000DE80                 assume cs:_rdata
.rdata:0000DE80                 ;org 0DE80h
.rdata:0000DE80 ; COMDAT (pick any)
.rdata:0000DE80                 public ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
.rdata:0000DE80 ; `string'
.rdata:0000DE80 ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ db 'unknown error',0
.rdata:0000DE80                                         ; DATA XREF: std::_Generic_error_category::message(int):loc_BB70o
.rdata:0000DE80                                         ; std::_System_error_category::message(int):loc_BCECo
.rdata:0000DE8E                 align 10h
.rdata:0000DE8E _rdata          ends
.rdata:0000DE8E
.rdata:0000DE90 ; ===========================================================================
.rdata:0000DE90
.rdata:0000DE90 ; Segment type: Pure data
.rdata:0000DE90 ; Segment permissions: Read
.rdata:0000DE90 _rdata          segment dword public 'DATA' use32
.rdata:0000DE90                 assume cs:_rdata
.rdata:0000DE90                 ;org 0DE90h
.rdata:0000DE90 ; COMDAT (pick largest)
.rdata:0000DE90                 dd offset ??_R4_Iostream_error_category@std@@6B@ ; const std::_Iostream_error_category::`RTTI Complete Object Locator'
.rdata:0000DE94                 public ??_7_Iostream_error_category@std@@6B@
.rdata:0000DE94 ; const std::_Iostream_error_category::`vftable'
.rdata:0000DE94 ??_7_Iostream_error_category@std@@6B@ dd offset ??_E_Iostream_error_category@std@@UAEPAXI@Z
.rdata:0000DE94                                         ; DATA XREF: std::_Iostream_error_category::_Iostream_error_category(void)+38o
.rdata:0000DE94                                         ; std::_Iostream_error_category::`vector deleting destructor'(uint)
.rdata:0000DE98                 dd offset ?name@_Iostream_error_category@std@@UBEPBDXZ ; std::_Iostream_error_category::name(void)
.rdata:0000DE9C                 dd offset ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message(int)
.rdata:0000DEA0                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:0000DEA4                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:0000DEA8                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:0000DEA8 _rdata          ends
.rdata:0000DEA8
.rdata:0000DEAC ; ===========================================================================
.rdata:0000DEAC
.rdata:0000DEAC ; Segment type: Pure data
.rdata:0000DEAC ; Segment permissions: Read
.rdata:0000DEAC _rdata          segment dword public 'DATA' use32
.rdata:0000DEAC                 assume cs:_rdata
.rdata:0000DEAC                 ;org 0DEACh
.rdata:0000DEAC ; COMDAT (pick any)
.rdata:0000DEAC                 public ??_C@_08LLGCOLLL@iostream?$AA@
.rdata:0000DEAC ; `string'
.rdata:0000DEAC ??_C@_08LLGCOLLL@iostream?$AA@ db 'iostream',0
.rdata:0000DEAC                                         ; DATA XREF: std::_Iostream_error_category::name(void)+7o
.rdata:0000DEB5                 align 4
.rdata:0000DEB5 _rdata          ends
.rdata:0000DEB5
.rdata:0000DEB8 ; ===========================================================================
.rdata:0000DEB8
.rdata:0000DEB8 ; Segment type: Pure data
.rdata:0000DEB8 ; Segment permissions: Read
.rdata:0000DEB8 _rdata          segment dword public 'DATA' use32
.rdata:0000DEB8                 assume cs:_rdata
.rdata:0000DEB8                 ;org 0DEB8h
.rdata:0000DEB8 ; COMDAT (pick any)
.rdata:0000DEB8                 public ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
.rdata:0000DEB8 ; char `string'[]
.rdata:0000DEB8 ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ db 'iostream stream error',0
.rdata:0000DEB8                                         ; DATA XREF: std::_Iostream_error_category::message(int)+35o
.rdata:0000DECE                 align 10h
.rdata:0000DECE _rdata          ends
.rdata:0000DECE
.rdata:0000DED0 ; ===========================================================================
.rdata:0000DED0
.rdata:0000DED0 ; Segment type: Pure data
.rdata:0000DED0 ; Segment permissions: Read
.rdata:0000DED0 _rdata          segment dword public 'DATA' use32
.rdata:0000DED0                 assume cs:_rdata
.rdata:0000DED0                 ;org 0DED0h
.rdata:0000DED0 ; COMDAT (pick largest)
.rdata:0000DED0                 dd offset ??_R4_System_error_category@std@@6B@ ; const std::_System_error_category::`RTTI Complete Object Locator'
.rdata:0000DED4                 public ??_7_System_error_category@std@@6B@
.rdata:0000DED4 ; const std::_System_error_category::`vftable'
.rdata:0000DED4 ??_7_System_error_category@std@@6B@ dd offset ??_E_System_error_category@std@@UAEPAXI@Z
.rdata:0000DED4                                         ; DATA XREF: std::_System_error_category::_System_error_category(void)+38o
.rdata:0000DED4                                         ; std::_System_error_category::`vector deleting destructor'(uint)
.rdata:0000DED8                 dd offset ?name@_System_error_category@std@@UBEPBDXZ ; std::_System_error_category::name(void)
.rdata:0000DEDC                 dd offset ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message(int)
.rdata:0000DEE0                 dd offset ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition(int)
.rdata:0000DEE4                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:0000DEE8                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:0000DEE8 _rdata          ends
.rdata:0000DEE8
.rdata:0000DEEC ; ===========================================================================
.rdata:0000DEEC
.rdata:0000DEEC ; Segment type: Pure data
.rdata:0000DEEC ; Segment permissions: Read
.rdata:0000DEEC _rdata          segment dword public 'DATA' use32
.rdata:0000DEEC                 assume cs:_rdata
.rdata:0000DEEC                 ;org 0DEECh
.rdata:0000DEEC ; COMDAT (pick any)
.rdata:0000DEEC                 public ??_C@_06FHFOAHML@system?$AA@
.rdata:0000DEEC ; `string'
.rdata:0000DEEC ??_C@_06FHFOAHML@system?$AA@ db 'system',0
.rdata:0000DEEC                                         ; DATA XREF: std::_System_error_category::name(void)+7o
.rdata:0000DEF3                 align 4
.rdata:0000DEF3 _rdata          ends
.rdata:0000DEF3
.bss:0000DEF4 ; ===========================================================================
.bss:0000DEF4
.bss:0000DEF4 ; Segment type: Uninitialized
.bss:0000DEF4 ; Segment permissions: Read/Write
.bss:0000DEF4 _bss            segment dword public 'BSS' use32
.bss:0000DEF4                 assume cs:_bss
.bss:0000DEF4                 ;org 0DEF4h
.bss:0000DEF4 ; COMDAT (pick any)
.bss:0000DEF4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:0000DEF4                 public ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
.bss:0000DEF4 ; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
.bss:0000DEF4 ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A db    ? ;
.bss:0000DEF4                                         ; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o
.bss:0000DEF4                                         ; `dynamic atexit destructor for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o ...
.bss:0000DEF5                 db    ? ;
.bss:0000DEF6                 db    ? ;
.bss:0000DEF7                 db    ? ;
.bss:0000DEF7 _bss            ends
.bss:0000DEF7
.bss:0000DEF8 ; ===========================================================================
.bss:0000DEF8
.bss:0000DEF8 ; Segment type: Uninitialized
.bss:0000DEF8 ; Segment permissions: Read/Write
.bss:0000DEF8 _bss            segment dword public 'BSS' use32
.bss:0000DEF8                 assume cs:_bss
.bss:0000DEF8                 ;org 0DEF8h
.bss:0000DEF8 ; COMDAT (pick any)
.bss:0000DEF8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:0000DEF8                 public ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
.bss:0000DEF8 ; std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object
.bss:0000DEF8 ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A db    ? ;
.bss:0000DEF8                                         ; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
.bss:0000DEF8                                         ; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
.bss:0000DEF9                 db    ? ;
.bss:0000DEFA                 db    ? ;
.bss:0000DEFB                 db    ? ;
.bss:0000DEFB _bss            ends
.bss:0000DEFB
.bss:0000DEFC ; ===========================================================================
.bss:0000DEFC
.bss:0000DEFC ; Segment type: Uninitialized
.bss:0000DEFC ; Segment permissions: Read/Write
.bss:0000DEFC _bss            segment dword public 'BSS' use32
.bss:0000DEFC                 assume cs:_bss
.bss:0000DEFC                 ;org 0DEFCh
.bss:0000DEFC ; COMDAT (pick any)
.bss:0000DEFC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:0000DEFC                 public ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
.bss:0000DEFC ; std::_System_error_category std::_Error_objects<int>::_System_object
.bss:0000DEFC ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A db    ? ;
.bss:0000DEFC                                         ; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o
.bss:0000DEFC                                         ; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o ...
.bss:0000DEFD                 db    ? ;
.bss:0000DEFE                 db    ? ;
.bss:0000DEFF                 db    ? ;
.bss:0000DEFF _bss            ends
.bss:0000DEFF
.rdata:0000DF00 ; ===========================================================================
.rdata:0000DF00
.rdata:0000DF00 ; Segment type: Pure data
.rdata:0000DF00 ; Segment permissions: Read
.rdata:0000DF00 _rdata          segment dword public 'DATA' use32
.rdata:0000DF00                 assume cs:_rdata
.rdata:0000DF00                 ;org 0DF00h
.rdata:0000DF00 ; COMDAT (pick any)
.rdata:0000DF00                 public ?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB
.rdata:0000DF00 ; public: static unsigned int const std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::npos
.rdata:0000DF00 ?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB dd 0FFFFFFFFh
.rdata:0000DF00                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+3Dr
.rdata:0000DF00                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)+5Dr
.rdata:0000DF00 _rdata          ends
.rdata:0000DF00
.bss:0000DF04 ; ===========================================================================
.bss:0000DF04
.bss:0000DF04 ; Segment type: Uninitialized
.bss:0000DF04 ; Segment permissions: Read/Write
.bss:0000DF04 _bss            segment dword public 'BSS' use32
.bss:0000DF04                 assume cs:_bss
.bss:0000DF04                 ;org 0DF04h
.bss:0000DF04 ; COMDAT (pick any)
.bss:0000DF04                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:0000DF04                 public ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
.bss:0000DF04 ; std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id
.bss:0000DF04 ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A db    ? ;
.bss:0000DF04                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)+5o
.bss:0000DF05                 db    ? ;
.bss:0000DF06                 db    ? ;
.bss:0000DF07                 db    ? ;
.bss:0000DF07 _bss            ends
.bss:0000DF07
.bss:0000DF08 ; ===========================================================================
.bss:0000DF08
.bss:0000DF08 ; Segment type: Uninitialized
.bss:0000DF08 ; Segment permissions: Read/Write
.bss:0000DF08 _bss            segment dword public 'BSS' use32
.bss:0000DF08                 assume cs:_bss
.bss:0000DF08                 ;org 0DF08h
.bss:0000DF08 ; COMDAT (pick any)
.bss:0000DF08                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:0000DF08                 public ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
.bss:0000DF08 ; std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id
.bss:0000DF08 ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A db    ? ;
.bss:0000DF08                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)+5o
.bss:0000DF09                 db    ? ;
.bss:0000DF0A                 db    ? ;
.bss:0000DF0B                 db    ? ;
.bss:0000DF0B _bss            ends
.bss:0000DF0B
.rdata:0000DF0C ; ===========================================================================
.rdata:0000DF0C
.rdata:0000DF0C ; Segment type: Pure data
.rdata:0000DF0C ; Segment permissions: Read
.rdata:0000DF0C _rdata          segment dword public 'DATA' use32
.rdata:0000DF0C                 assume cs:_rdata
.rdata:0000DF0C                 ;org 0DF0Ch
.rdata:0000DF0C ; COMDAT (pick largest)
.rdata:0000DF0C                 dd offset ??_R4WindowsDlg@@6B@ ; const WindowsDlg::`RTTI Complete Object Locator'
.rdata:0000DF10                 public ??_7WindowsDlg@@6B@
.rdata:0000DF10 ; const WindowsDlg::`vftable'
.rdata:0000DF10 ??_7WindowsDlg@@6B@ dd offset ??_EWindowsDlg@@UAEPAXI@Z
.rdata:0000DF10                                         ; DATA XREF: WindowsDlg::WindowsDlg(void)+3Do
.rdata:0000DF10                                         ; WindowsDlg::`vector deleting destructor'(uint)
.rdata:0000DF14                 dd offset ?init@WindowsDlg@@EAEXPAUHINSTANCE__@@PAUHWND__@@@Z ; WindowsDlg::init(HINSTANCE__ *,HWND__ *)
.rdata:0000DF18                 dd offset ?destroy@WindowsDlg@@MAEXXZ ; WindowsDlg::destroy(void)
.rdata:0000DF1C                 dd offset ?display@StaticDialog@@UBEX_N@Z ; StaticDialog::display(bool)
.rdata:0000DF20                 dd offset ?reSizeTo@Window@@UAEXAAUtagRECT@@@Z ; Window::reSizeTo(tagRECT &)
.rdata:0000DF24                 dd offset ?reSizeToWH@Window@@UAEXAAUtagRECT@@@Z ; Window::reSizeToWH(tagRECT &)
.rdata:0000DF28                 dd offset ?redraw@Window@@UBEX_N@Z ; Window::redraw(bool)
.rdata:0000DF2C                 dd offset ?getClientRect@Window@@UBEXAAUtagRECT@@@Z ; Window::getClientRect(tagRECT &)
.rdata:0000DF30                 dd offset ?getWindowRect@Window@@UBEXAAUtagRECT@@@Z ; Window::getWindowRect(tagRECT &)
.rdata:0000DF34                 dd offset ?getWidth@Window@@UBEHXZ ; Window::getWidth(void)
.rdata:0000DF38                 dd offset ?getHeight@Window@@UBEHXZ ; Window::getHeight(void)
.rdata:0000DF3C                 dd offset ?isVisible@Window@@UBE_NXZ ; Window::isVisible(void)
.rdata:0000DF40                 dd offset ?create@StaticDialog@@UAEXH_N0@Z ; StaticDialog::create(int,bool,bool)
.rdata:0000DF44                 dd offset ?isCreated@StaticDialog@@UBE_NXZ ; StaticDialog::isCreated(void)
.rdata:0000DF48                 dd offset ?run_dlgProc@WindowsDlg@@MAGHIIJ@Z ; WindowsDlg::run_dlgProc(uint,uint,long)
.rdata:0000DF4C                 dd offset ?onInitDialog@WindowsDlg@@MAEHXZ ; WindowsDlg::onInitDialog(void)
.rdata:0000DF50                 dd offset ?onSize@WindowsDlg@@MAEXIHH@Z ; WindowsDlg::onSize(uint,int,int)
.rdata:0000DF54                 dd offset ?onGetMinMaxInfo@WindowsDlg@@MAEXPAUtagMINMAXINFO@@@Z ; WindowsDlg::onGetMinMaxInfo(tagMINMAXINFO *)
.rdata:0000DF58                 dd offset ?onWinMgr@WindowsDlg@@MAEJIJ@Z ; WindowsDlg::onWinMgr(uint,long)
.rdata:0000DF5C                 dd offset ?init@WindowsDlg@@UAEXPAUHINSTANCE__@@PAUHWND__@@PAVDocTabView@@@Z ; WindowsDlg::init(HINSTANCE__ *,HWND__ *,DocTabView *)
.rdata:0000DF5C _rdata          ends
.rdata:0000DF5C
.rdata:0000DF60 ; ===========================================================================
.rdata:0000DF60
.rdata:0000DF60 ; Segment type: Pure data
.rdata:0000DF60 ; Segment permissions: Read
.rdata:0000DF60 ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000DF60 _rdata          segment para public 'DATA' use32
.rdata:0000DF60                 assume cs:_rdata
.rdata:0000DF60                 ;org 0DF60h
.rdata:0000DF60 ; COMDAT (pick any)
.rdata:0000DF60                 public ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:0000DF60 ; wchar_t `string'
.rdata:0000DF60 ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:0000DF60                                         ; DATA XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_Compat(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)+2Fo
.rdata:0000DF60                                         ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_Compat(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)+5Fo ...
.rdata:0000DF60                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:0000DF60                 unicode 0, <clude\xstring>,0
.rdata:0000DFEE                 align 10h
.rdata:0000DFEE _rdata          ends
.rdata:0000DFEE
.bss:0000DFF0 ; ===========================================================================
.bss:0000DFF0
.bss:0000DFF0 ; Segment type: Uninitialized
.bss:0000DFF0 ; Segment permissions: Read/Write
.bss:0000DFF0 _bss            segment dword public 'BSS' use32
.bss:0000DFF0                 assume cs:_bss
.bss:0000DFF0                 ;org 0DFF0h
.bss:0000DFF0 ; COMDAT (pick any)
.bss:0000DFF0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:0000DFF0                 public ?id@?$numpunct@D@std@@2V0locale@2@A
.bss:0000DFF0 ; std::locale::id std::numpunct<char>::id
.bss:0000DFF0 ?id@?$numpunct@D@std@@2V0locale@2@A db    ? ;
.bss:0000DFF0                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::numpunct<char>::id''(void)+5o
.bss:0000DFF1                 db    ? ;
.bss:0000DFF2                 db    ? ;
.bss:0000DFF3                 db    ? ;
.bss:0000DFF3 _bss            ends
.bss:0000DFF3
.bss:0000DFF4 ; ===========================================================================
.bss:0000DFF4
.bss:0000DFF4 ; Segment type: Uninitialized
.bss:0000DFF4 ; Segment permissions: Read/Write
.bss:0000DFF4 _bss            segment dword public 'BSS' use32
.bss:0000DFF4                 assume cs:_bss
.bss:0000DFF4                 ;org 0DFF4h
.bss:0000DFF4 ; COMDAT (pick any)
.bss:0000DFF4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:0000DFF4                 public ?id@?$numpunct@_W@std@@2V0locale@2@A
.bss:0000DFF4 ; std::locale::id std::numpunct<wchar_t>::id
.bss:0000DFF4 ?id@?$numpunct@_W@std@@2V0locale@2@A db    ? ;
.bss:0000DFF4                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::numpunct<wchar_t>::id''(void)+5o
.bss:0000DFF5                 db    ? ;
.bss:0000DFF6                 db    ? ;
.bss:0000DFF7                 db    ? ;
.bss:0000DFF7 _bss            ends
.bss:0000DFF7
.rdata:0000DFF8 ; ===========================================================================
.rdata:0000DFF8
.rdata:0000DFF8 ; Segment type: Pure data
.rdata:0000DFF8 ; Segment permissions: Read
.rdata:0000DFF8 ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000DFF8 _rdata          segment para public 'DATA' use32
.rdata:0000DFF8                 assume cs:_rdata
.rdata:0000DFF8                 ;org 0DFF8h
.rdata:0000DFF8 ; COMDAT (pick any)
.rdata:0000DFF8                 public ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:0000DFF8 ; wchar_t `string'
.rdata:0000DFF8 ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:0000DFF8                                         ; DATA XREF: std::vector<int,std::allocator<int>>::operator[](uint)+19o
.rdata:0000DFF8                                         ; std::vector<int,std::allocator<int>>::operator[](uint)+49o ...
.rdata:0000DFF8                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:0000DFF8                 unicode 0, <clude\vector>,0
.rdata:0000DFF8 _rdata          ends
.rdata:0000DFF8
.rdata:0000E084 ; ===========================================================================
.rdata:0000E084
.rdata:0000E084 ; Segment type: Pure data
.rdata:0000E084 ; Segment permissions: Read
.rdata:0000E084 _rdata          segment dword public 'DATA' use32
.rdata:0000E084                 assume cs:_rdata
.rdata:0000E084                 ;org 0E084h
.rdata:0000E084 ; COMDAT (pick any)
.rdata:0000E084                 public ??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@
.rdata:0000E084 ; wchar_t `string'
.rdata:0000E084 ??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@:
.rdata:0000E084                                         ; DATA XREF: std::vector<int,std::allocator<int>>::operator[](uint)+1Eo
.rdata:0000E084                                         ; std::vector<wchar_t,std::allocator<wchar_t>>::operator[](uint)+1Eo
.rdata:0000E084                 unicode 0, <vector subscript out of range>,0
.rdata:0000E084 _rdata          ends
.rdata:0000E084
.rdata:0000E0C0 ; ===========================================================================
.rdata:0000E0C0
.rdata:0000E0C0 ; Segment type: Pure data
.rdata:0000E0C0 ; Segment permissions: Read
.rdata:0000E0C0 _rdata          segment dword public 'DATA' use32
.rdata:0000E0C0                 assume cs:_rdata
.rdata:0000E0C0                 ;org 0E0C0h
.rdata:0000E0C0 ; COMDAT (pick any)
.rdata:0000E0C0                 public ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@
.rdata:0000E0C0 ; `string'
.rdata:0000E0C0 ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ db 'Standard C++ Libraries Out of Range',0
.rdata:0000E0C0                                         ; DATA XREF: std::vector<int,std::allocator<int>>::operator[](uint)+2Bo
.rdata:0000E0C0                                         ; std::vector<wchar_t,std::allocator<wchar_t>>::operator[](uint)+2Bo ...
.rdata:0000E0C0 _rdata          ends
.rdata:0000E0C0
.rdata:0000E0E4 ; ===========================================================================
.rdata:0000E0E4
.rdata:0000E0E4 ; Segment type: Pure data
.rdata:0000E0E4 ; Segment permissions: Read
.rdata:0000E0E4 ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000E0E4 _rdata          segment para public 'DATA' use32
.rdata:0000E0E4                 assume cs:_rdata
.rdata:0000E0E4                 ;org 0E0E4h
.rdata:0000E0E4 ; COMDAT (pick any)
.rdata:0000E0E4                 public ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@
.rdata:0000E0E4 ; `string'
.rdata:0000E0E4 ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@:
.rdata:0000E0E4                                         ; DATA XREF: std::vector<int,std::allocator<int>>::operator[](uint):loc_80D8o
.rdata:0000E0E4                                         ; std::vector<wchar_t,std::allocator<wchar_t>>::operator[](uint):loc_8168o ...
.rdata:0000E0E4                 unicode 0, <"Standard C++ Libraries Out of Range" && 0>,0
.rdata:0000E13A                 align 4
.rdata:0000E13A _rdata          ends
.rdata:0000E13A
.rdata:0000E13C ; ===========================================================================
.rdata:0000E13C
.rdata:0000E13C ; Segment type: Pure data
.rdata:0000E13C ; Segment permissions: Read
.rdata:0000E13C _rdata          segment dword public 'DATA' use32
.rdata:0000E13C                 assume cs:_rdata
.rdata:0000E13C                 ;org 0E13Ch
.rdata:0000E13C ; COMDAT (pick any)
.rdata:0000E13C                 public ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
.rdata:0000E13C ; `string'
.rdata:0000E13C ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@:
.rdata:0000E13C                                         ; DATA XREF: std::vector<int,std::allocator<int>>::operator[](uint)+3Do
.rdata:0000E13C                                         ; std::vector<wchar_t,std::allocator<wchar_t>>::operator[](uint)+3Do ...
.rdata:0000E13C                 unicode 0, <%s>,0
.rdata:0000E142                 align 4
.rdata:0000E142 _rdata          ends
.rdata:0000E142
.rdata:0000E144 ; ===========================================================================
.rdata:0000E144
.rdata:0000E144 ; Segment type: Pure data
.rdata:0000E144 ; Segment permissions: Read
.rdata:0000E144 ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000E144 _rdata          segment para public 'DATA' use32
.rdata:0000E144                 assume cs:_rdata
.rdata:0000E144                 ;org 0E144h
.rdata:0000E144 ; COMDAT (pick any)
.rdata:0000E144                 public ??_C@_1HC@HBCEAHKD@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAi?$AAn?$AAt?$AA?0?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAa?$AAl?$AAl?$AAo?$AAc@
.rdata:0000E144 ; `string'
.rdata:0000E144 ??_C@_1HC@HBCEAHKD@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAi?$AAn?$AAt?$AA?0?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAa?$AAl?$AAl?$AAo?$AAc@:
.rdata:0000E144                                         ; DATA XREF: std::vector<int,std::allocator<int>>::operator[](uint)+6Ao
.rdata:0000E144                 unicode 0, <std::vector>
.rdata:0000E144                 dw 3Ch
.rdata:0000E144                 unicode 0, <int,class std::allocator>
.rdata:0000E144                 dw 3Ch
.rdata:0000E144                 unicode 0, <int>
.rdata:0000E144                 dw 3Eh
.rdata:0000E144                 unicode 0, < >
.rdata:0000E144                 dw 3Eh
.rdata:0000E144                 unicode 0, <::operator []>,0
.rdata:0000E1B6                 align 4
.rdata:0000E1B6 _rdata          ends
.rdata:0000E1B6
.rdata:0000E1B8 ; ===========================================================================
.rdata:0000E1B8
.rdata:0000E1B8 ; Segment type: Pure data
.rdata:0000E1B8 ; Segment permissions: Read
.rdata:0000E1B8 _rdata          segment dword public 'DATA' use32
.rdata:0000E1B8                 assume cs:_rdata
.rdata:0000E1B8                 ;org 0E1B8h
.rdata:0000E1B8 ; COMDAT (pick any)
.rdata:0000E1B8                 public ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@
.rdata:0000E1B8 ; `string'
.rdata:0000E1B8 ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@:
.rdata:0000E1B8                                         ; DATA XREF: std::vector<int,std::allocator<int>>::operator[](uint)+6Fo
.rdata:0000E1B8                                         ; std::vector<wchar_t,std::allocator<wchar_t>>::operator[](uint)+6Fo ...
.rdata:0000E1B8                 unicode 0, <"out of range">,0
.rdata:0000E1D6                 align 4
.rdata:0000E1D6 _rdata          ends
.rdata:0000E1D6
.rdata:0000E1D8 ; ===========================================================================
.rdata:0000E1D8
.rdata:0000E1D8 ; Segment type: Pure data
.rdata:0000E1D8 ; Segment permissions: Read
.rdata:0000E1D8 ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000E1D8 _rdata          segment para public 'DATA' use32
.rdata:0000E1D8                 assume cs:_rdata
.rdata:0000E1D8                 ;org 0E1D8h
.rdata:0000E1D8 ; COMDAT (pick any)
.rdata:0000E1D8                 public ??_C@_1EI@HGIDLLCM@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAe?$AAr?$AAa?$AAs?$AAe?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAo?$AAu?$AAt?$AAs?$AAi?$AAd?$AAe?$AA?5?$AAr?$AAa@
.rdata:0000E1D8 ; wchar_t `string'
.rdata:0000E1D8 ??_C@_1EI@HGIDLLCM@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAe?$AAr?$AAa?$AAs?$AAe?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAo?$AAu?$AAt?$AAs?$AAi?$AAd?$AAe?$AA?5?$AAr?$AAa@:
.rdata:0000E1D8                                         ; DATA XREF: std::vector<int,std::allocator<int>>::erase(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>)+1EBo
.rdata:0000E1D8                 unicode 0, <vector erase iterator outside range>,0
.rdata:0000E1D8 _rdata          ends
.rdata:0000E1D8
.rdata:0000E220 ; ===========================================================================
.rdata:0000E220
.rdata:0000E220 ; Segment type: Pure data
.rdata:0000E220 ; Segment permissions: Read
.rdata:0000E220 ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000E220 _rdata          segment para public 'DATA' use32
.rdata:0000E220                 assume cs:_rdata
.rdata:0000E220                 ;org 0E220h
.rdata:0000E220 ; COMDAT (pick any)
.rdata:0000E220                 public ??_C@_1IC@MBIJKJB@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAw?$AAc?$AAh?$AAa?$AAr?$AA_?$AAt?$AA?0?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAa@
.rdata:0000E220 ; `string'
.rdata:0000E220 ??_C@_1IC@MBIJKJB@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAw?$AAc?$AAh?$AAa?$AAr?$AA_?$AAt?$AA?0?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAa@:
.rdata:0000E220                                         ; DATA XREF: std::vector<wchar_t,std::allocator<wchar_t>>::operator[](uint)+6Ao
.rdata:0000E220                 unicode 0, <std::vector>
.rdata:0000E220                 dw 3Ch
.rdata:0000E220                 unicode 0, <wchar_t,class std::allocator>
.rdata:0000E220                 dw 3Ch
.rdata:0000E220                 unicode 0, <wchar_t>
.rdata:0000E220                 dw 3Eh
.rdata:0000E220                 unicode 0, < >
.rdata:0000E220                 dw 3Eh
.rdata:0000E220                 unicode 0, <::operator []>,0
.rdata:0000E2A2                 align 4
.rdata:0000E2A2 _rdata          ends
.rdata:0000E2A2
.rdata:0000E2A4 ; ===========================================================================
.rdata:0000E2A4
.rdata:0000E2A4 ; Segment type: Pure data
.rdata:0000E2A4 ; Segment permissions: Read
.rdata:0000E2A4 ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000E2A4 _rdata          segment para public 'DATA' use32
.rdata:0000E2A4                 assume cs:_rdata
.rdata:0000E2A4                 ;org 0E2A4h
.rdata:0000E2A4 ; COMDAT (pick any)
.rdata:0000E2A4                 public ??_C@_1EG@FOHJJHAC@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAa?$AAb@
.rdata:0000E2A4 ; wchar_t `string'
.rdata:0000E2A4 ??_C@_1EG@FOHJJHAC@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAa?$AAb@:
.rdata:0000E2A4                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator*(void)+49o
.rdata:0000E2A4                 unicode 0, <vector iterator not dereferencable>,0
.rdata:0000E2EA                 align 4
.rdata:0000E2EA _rdata          ends
.rdata:0000E2EA
.rdata:0000E2EC ; ===========================================================================
.rdata:0000E2EC
.rdata:0000E2EC ; Segment type: Pure data
.rdata:0000E2EC ; Segment permissions: Read
.rdata:0000E2EC ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000E2EC _rdata          segment para public 'DATA' use32
.rdata:0000E2EC                 assume cs:_rdata
.rdata:0000E2EC                 ;org 0E2ECh
.rdata:0000E2EC ; COMDAT (pick any)
.rdata:0000E2EC                 public ??_C@_1ME@LLCFNFIO@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
.rdata:0000E2EC ; `string'
.rdata:0000E2EC ??_C@_1ME@LLCFNFIO@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@:
.rdata:0000E2EC                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator*(void)+8Fo
.rdata:0000E2EC                 unicode 0, <std::_Vector_const_iterator>
.rdata:0000E2EC                 dw 3Ch
.rdata:0000E2EC                 unicode 0, <class std::_Vector_val>
.rdata:0000E2EC                 dw 3Ch
.rdata:0000E2EC                 unicode 0, <struct std::_Simple_types>
.rdata:0000E2EC                 dw 3Ch
.rdata:0000E2EC                 unicode 0, <int>
.rdata:0000E2EC                 dw 3Eh
.rdata:0000E2EC                 unicode 0, < >
.rdata:0000E2EC                 dw 3Eh
.rdata:0000E2EC                 unicode 0, < >
.rdata:0000E2EC                 dw 3Eh
.rdata:0000E2EC                 unicode 0, <::operator *>,0
.rdata:0000E2EC _rdata          ends
.rdata:0000E2EC
.rdata:0000E3B0 ; ===========================================================================
.rdata:0000E3B0
.rdata:0000E3B0 ; Segment type: Pure data
.rdata:0000E3B0 ; Segment permissions: Read
.rdata:0000E3B0 ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000E3B0 _rdata          segment para public 'DATA' use32
.rdata:0000E3B0                 assume cs:_rdata
.rdata:0000E3B0                 ;org 0E3B0h
.rdata:0000E3B0 ; COMDAT (pick any)
.rdata:0000E3B0                 public ??_C@_1EE@EJDKCLKB@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAi?$AAn?$AAc?$AAr?$AAe?$AAm?$AAe?$AAn?$AAt?$AAa?$AAb?$AAl@
.rdata:0000E3B0 ; wchar_t `string'
.rdata:0000E3B0 ??_C@_1EE@EJDKCLKB@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAi?$AAn?$AAc?$AAr?$AAe?$AAm?$AAe?$AAn?$AAt?$AAa?$AAb?$AAl@:
.rdata:0000E3B0                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator++(void)+36o
.rdata:0000E3B0                 unicode 0, <vector iterator not incrementable>,0
.rdata:0000E3B0 _rdata          ends
.rdata:0000E3B0
.rdata:0000E3F4 ; ===========================================================================
.rdata:0000E3F4
.rdata:0000E3F4 ; Segment type: Pure data
.rdata:0000E3F4 ; Segment permissions: Read
.rdata:0000E3F4 ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000E3F4 _rdata          segment para public 'DATA' use32
.rdata:0000E3F4                 assume cs:_rdata
.rdata:0000E3F4                 ;org 0E3F4h
.rdata:0000E3F4 ; COMDAT (pick any)
.rdata:0000E3F4                 public ??_C@_1MG@OPNGNDCB@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
.rdata:0000E3F4 ; `string'
.rdata:0000E3F4 ??_C@_1MG@OPNGNDCB@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@:
.rdata:0000E3F4                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator++(void)+7Co
.rdata:0000E3F4                 unicode 0, <std::_Vector_const_iterator>
.rdata:0000E3F4                 dw 3Ch
.rdata:0000E3F4                 unicode 0, <class std::_Vector_val>
.rdata:0000E3F4                 dw 3Ch
.rdata:0000E3F4                 unicode 0, <struct std::_Simple_types>
.rdata:0000E3F4                 dw 3Ch
.rdata:0000E3F4                 unicode 0, <int>
.rdata:0000E3F4                 dw 3Eh
.rdata:0000E3F4                 unicode 0, < >
.rdata:0000E3F4                 dw 3Eh
.rdata:0000E3F4                 unicode 0, < >
.rdata:0000E3F4                 dw 3Eh
.rdata:0000E3F4                 unicode 0, <::operator ++>,0
.rdata:0000E4BA                 align 4
.rdata:0000E4BA _rdata          ends
.rdata:0000E4BA
.rdata:0000E4BC ; ===========================================================================
.rdata:0000E4BC
.rdata:0000E4BC ; Segment type: Pure data
.rdata:0000E4BC ; Segment permissions: Read
.rdata:0000E4BC _rdata          segment dword public 'DATA' use32
.rdata:0000E4BC                 assume cs:_rdata
.rdata:0000E4BC                 ;org 0E4BCh
.rdata:0000E4BC ; COMDAT (pick any)
.rdata:0000E4BC                 public ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
.rdata:0000E4BC ; char `string'[]
.rdata:0000E4BC ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ db 'string too long',0
.rdata:0000E4BC                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+7o
.rdata:0000E4BC                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xlen(void)+7o
.rdata:0000E4BC _rdata          ends
.rdata:0000E4BC
.rdata:0000E4CC ; ===========================================================================
.rdata:0000E4CC
.rdata:0000E4CC ; Segment type: Pure data
.rdata:0000E4CC ; Segment permissions: Read
.rdata:0000E4CC _rdata          segment dword public 'DATA' use32
.rdata:0000E4CC                 assume cs:_rdata
.rdata:0000E4CC                 ;org 0E4CCh
.rdata:0000E4CC ; COMDAT (pick any)
.rdata:0000E4CC                 public ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
.rdata:0000E4CC ; char `string'[]
.rdata:0000E4CC ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ db 'invalid string position',0
.rdata:0000E4CC                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+7o
.rdata:0000E4CC                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)+7o
.rdata:0000E4CC _rdata          ends
.rdata:0000E4CC
.rdata:0000E4E4 ; ===========================================================================
.rdata:0000E4E4
.rdata:0000E4E4 ; Segment type: Pure data
.rdata:0000E4E4 ; Segment permissions: Read
.rdata:0000E4E4 _rdata          segment dword public 'DATA' use32
.rdata:0000E4E4                 assume cs:_rdata
.rdata:0000E4E4                 ;org 0E4E4h
.rdata:0000E4E4 ; COMDAT (pick any)
.rdata:0000E4E4                 public ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
.rdata:0000E4E4 ; char `string'[]
.rdata:0000E4E4 ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ db 'vector<T> too long',0
.rdata:0000E4E4                                         ; DATA XREF: std::vector<int,std::allocator<int>>::_Xlen(void)+7o
.rdata:0000E4E4                                         ; std::vector<wchar_t,std::allocator<wchar_t>>::_Xlen(void)+7o
.rdata:0000E4F7                 align 4
.rdata:0000E4F7 _rdata          ends
.rdata:0000E4F7
.rdata:0000E4F8 ; ===========================================================================
.rdata:0000E4F8
.rdata:0000E4F8 ; Segment type: Pure data
.rdata:0000E4F8 ; Segment permissions: Read
.rdata:0000E4F8 _rdata          segment dword public 'DATA' use32
.rdata:0000E4F8                 assume cs:_rdata
.rdata:0000E4F8                 ;org 0E4F8h
.rdata:0000E4F8 ; COMDAT (pick any)
.rdata:0000E4F8                 public ??_C@_1DM@HINDPMBP@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AAs?$AA?5?$AAi?$AAn?$AAc?$AAo?$AAm?$AAp?$AAa?$AAt?$AAi?$AAb?$AAl?$AAe?$AA?$AA@
.rdata:0000E4F8 ; wchar_t `string'
.rdata:0000E4F8 ??_C@_1DM@HINDPMBP@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AAs?$AA?5?$AAi?$AAn?$AAc?$AAo?$AAm?$AAp?$AAa?$AAt?$AAi?$AAb?$AAl?$AAe?$AA?$AA@:
.rdata:0000E4F8                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Compat(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>> const &)+34o
.rdata:0000E4F8                 unicode 0, <vector iterators incompatible>,0
.rdata:0000E4F8 _rdata          ends
.rdata:0000E4F8
.rdata:0000E534 ; ===========================================================================
.rdata:0000E534
.rdata:0000E534 ; Segment type: Pure data
.rdata:0000E534 ; Segment permissions: Read
.rdata:0000E534 _rdata          segment dword public 'DATA' use32
.rdata:0000E534                 assume cs:_rdata
.rdata:0000E534                 ;org 0E534h
.rdata:0000E534 ; COMDAT (pick any)
.rdata:0000E534                 public ??_C@_0CI@FNPHFCCM@Standard?5C?$CL?$CL?5Libraries?5Invalid?5A@
.rdata:0000E534 ; `string'
.rdata:0000E534 ??_C@_0CI@FNPHFCCM@Standard?5C?$CL?$CL?5Libraries?5Invalid?5A@ db 'Standard C++ Libraries Invalid Argument',0
.rdata:0000E534                                         ; DATA XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_Compat(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)+41o
.rdata:0000E534                                         ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Compat(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>> const &)+41o
.rdata:0000E534 _rdata          ends
.rdata:0000E534
.rdata:0000E55C ; ===========================================================================
.rdata:0000E55C
.rdata:0000E55C ; Segment type: Pure data
.rdata:0000E55C ; Segment permissions: Read
.rdata:0000E55C ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000E55C _rdata          segment para public 'DATA' use32
.rdata:0000E55C                 assume cs:_rdata
.rdata:0000E55C                 ;org 0E55Ch
.rdata:0000E55C ; COMDAT (pick any)
.rdata:0000E55C                 public ??_C@_1FO@GJIHNDLM@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5@
.rdata:0000E55C ; `string'
.rdata:0000E55C ??_C@_1FO@GJIHNDLM@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5@:
.rdata:0000E55C                                         ; DATA XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_Compat(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &):loc_8E7Eo
.rdata:0000E55C                                         ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Compat(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>> const &):loc_8F1Ao
.rdata:0000E55C                 unicode 0, <"Standard C++ Libraries Invalid Argument" && 0>,0
.rdata:0000E5BA                 align 4
.rdata:0000E5BA _rdata          ends
.rdata:0000E5BA
.rdata:0000E5BC ; ===========================================================================
.rdata:0000E5BC
.rdata:0000E5BC ; Segment type: Pure data
.rdata:0000E5BC ; Segment permissions: Read
.rdata:0000E5BC _rdata          segment dword public 'DATA' use32
.rdata:0000E5BC                 assume cs:_rdata
.rdata:0000E5BC                 ;org 0E5BCh
.rdata:0000E5BC ; COMDAT (pick any)
.rdata:0000E5BC                 public ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@
.rdata:0000E5BC ; `string'
.rdata:0000E5BC ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@:
.rdata:0000E5BC                                         ; DATA XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_Compat(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)+85o
.rdata:0000E5BC                                         ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Compat(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>> const &)+85o
.rdata:0000E5BC                 unicode 0, <"invalid argument">,0
.rdata:0000E5E2                 align 4
.rdata:0000E5E2 _rdata          ends
.rdata:0000E5E2
.rdata:0000E5E4 ; ===========================================================================
.rdata:0000E5E4
.rdata:0000E5E4 ; Segment type: Pure data
.rdata:0000E5E4 ; Segment permissions: Read
.rdata:0000E5E4 ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000E5E4 _rdata          segment para public 'DATA' use32
.rdata:0000E5E4                 assume cs:_rdata
.rdata:0000E5E4                 ;org 0E5E4h
.rdata:0000E5E4 ; COMDAT (pick any)
.rdata:0000E5E4                 public ??_C@_1LO@MGELDLOO@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
.rdata:0000E5E4 ; `string'
.rdata:0000E5E4 ??_C@_1LO@MGELDLOO@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@:
.rdata:0000E5E4                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Compat(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>> const &)+80o
.rdata:0000E5E4                 unicode 0, <std::_Vector_const_iterator>
.rdata:0000E5E4                 dw 3Ch
.rdata:0000E5E4                 unicode 0, <class std::_Vector_val>
.rdata:0000E5E4                 dw 3Ch
.rdata:0000E5E4                 unicode 0, <struct std::_Simple_types>
.rdata:0000E5E4                 dw 3Ch
.rdata:0000E5E4                 unicode 0, <int>
.rdata:0000E5E4                 dw 3Eh
.rdata:0000E5E4                 unicode 0, < >
.rdata:0000E5E4                 dw 3Eh
.rdata:0000E5E4                 unicode 0, < >
.rdata:0000E5E4                 dw 3Eh
.rdata:0000E5E4                 unicode 0, <::_Compat>,0
.rdata:0000E6A2                 align 4
.rdata:0000E6A2 _rdata          ends
.rdata:0000E6A2
.rdata:0000E6A4 ; ===========================================================================
.rdata:0000E6A4
.rdata:0000E6A4 ; Segment type: Pure data
.rdata:0000E6A4 ; Segment permissions: Read
.rdata:0000E6A4 _rdata          segment dword public 'DATA' use32
.rdata:0000E6A4                 assume cs:_rdata
.rdata:0000E6A4                 ;org 0E6A4h
.rdata:0000E6A4 ; COMDAT (pick any)
.rdata:0000E6A4                 public ??_C@_1DM@KDEKGMPF@?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AAs?$AA?5?$AAi?$AAn?$AAc?$AAo?$AAm?$AAp?$AAa?$AAt?$AAi?$AAb?$AAl?$AAe?$AA?$AA@
.rdata:0000E6A4 ; wchar_t `string'
.rdata:0000E6A4 ??_C@_1DM@KDEKGMPF@?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AAs?$AA?5?$AAi?$AAn?$AAc?$AAo?$AAm?$AAp?$AAa?$AAt?$AAi?$AAb?$AAl?$AAe?$AA?$AA@:
.rdata:0000E6A4                                         ; DATA XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_Compat(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)+34o
.rdata:0000E6A4                 unicode 0, <string iterators incompatible>,0
.rdata:0000E6A4 _rdata          ends
.rdata:0000E6A4
.rdata:0000E6E0 ; ===========================================================================
.rdata:0000E6E0
.rdata:0000E6E0 ; Segment type: Pure data
.rdata:0000E6E0 ; Segment permissions: Read
.rdata:0000E6E0 ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000E6E0 _rdata          segment para public 'DATA' use32
.rdata:0000E6E0                 assume cs:_rdata
.rdata:0000E6E0                 ;org 0E6E0h
.rdata:0000E6E0 ; COMDAT (pick any)
.rdata:0000E6E0                 public ??_C@_1MG@CLNEOJNJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAS?$AAt?$AAr?$AAi?$AAn?$AAg?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
.rdata:0000E6E0 ; `string'
.rdata:0000E6E0 ??_C@_1MG@CLNEOJNJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAS?$AAt?$AAr?$AAi?$AAn?$AAg?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@:
.rdata:0000E6E0                                         ; DATA XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_Compat(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)+80o
.rdata:0000E6E0                 unicode 0, <std::_String_const_iterator>
.rdata:0000E6E0                 dw 3Ch
.rdata:0000E6E0                 unicode 0, <class std::_String_val>
.rdata:0000E6E0                 dw 3Ch
.rdata:0000E6E0                 unicode 0, <struct std::_Simple_types>
.rdata:0000E6E0                 dw 3Ch
.rdata:0000E6E0                 unicode 0, <wchar_t>
.rdata:0000E6E0                 dw 3Eh
.rdata:0000E6E0                 unicode 0, < >
.rdata:0000E6E0                 dw 3Eh
.rdata:0000E6E0                 unicode 0, < >
.rdata:0000E6E0                 dw 3Eh
.rdata:0000E6E0                 unicode 0, <::_Compat>,0
.rdata:0000E7A6                 align 4
.rdata:0000E7A6 _rdata          ends
.rdata:0000E7A6
.rdata:0000E7A8 ; ===========================================================================
.rdata:0000E7A8
.rdata:0000E7A8 ; Segment type: Pure data
.rdata:0000E7A8 ; Segment permissions: Read
.rdata:0000E7A8 _rdata          segment dword public 'DATA' use32
.rdata:0000E7A8                 assume cs:_rdata
.rdata:0000E7A8                 ;org 0E7A8h
.rdata:0000E7A8 ; COMDAT (pick any)
.rdata:0000E7A8                 public ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
.rdata:0000E7A8 ; wchar_t `string'
.rdata:0000E7A8 ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@:
.rdata:0000E7A8                                         ; DATA XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+11o
.rdata:0000E7A8                                         ; std::_Debug_pointer<int>(int *,wchar_t const *,uint)+11o ...
.rdata:0000E7A8                 unicode 0, <invalid null pointer>,0
.rdata:0000E7D2                 align 4
.rdata:0000E7D2 _rdata          ends
.rdata:0000E7D2
.rdata:0000E7D4 ; ===========================================================================
.rdata:0000E7D4
.rdata:0000E7D4 ; Segment type: Pure data
.rdata:0000E7D4 ; Segment permissions: Read
.rdata:0000E7D4 ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000E7D4 _rdata          segment para public 'DATA' use32
.rdata:0000E7D4                 assume cs:_rdata
.rdata:0000E7D4                 ;org 0E7D4h
.rdata:0000E7D4 ; COMDAT (pick any)
.rdata:0000E7D4                 public ??_C@_1JC@HALMDPKM@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:0000E7D4 ; wchar_t `string'
.rdata:0000E7D4 ??_C@_1JC@HALMDPKM@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:0000E7D4                                         ; DATA XREF: std::_Buffered_merge<int *,int,int,BufferEquivalent>(int *,int *,int *,int,int,std::_Temp_iterator<int> &,BufferEquivalent)+46o
.rdata:0000E7D4                                         ; std::_Insertion_sort1<int *,BufferEquivalent,int>(int *,int *,BufferEquivalent,int *)+49o ...
.rdata:0000E7D4                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:0000E7D4                 unicode 0, <clude\algorithm>,0
.rdata:0000E866                 align 4
.rdata:0000E866 _rdata          ends
.rdata:0000E866
.rdata:0000E868 ; ===========================================================================
.rdata:0000E868
.rdata:0000E868 ; Segment type: Pure data
.rdata:0000E868 ; Segment permissions: Read
.rdata:0000E868 _rdata          segment dword public 'DATA' use32
.rdata:0000E868                 assume cs:_rdata
.rdata:0000E868                 ;org 0E868h
.rdata:0000E868 ; COMDAT (pick any)
.rdata:0000E868                 public ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@
.rdata:0000E868 ; wchar_t `string'
.rdata:0000E868 ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@:
.rdata:0000E868                                         ; DATA XREF: std::_Debug_range2<int *>(int *,int *,wchar_t const *,uint,std::random_access_iterator_tag)+43o
.rdata:0000E868                                         ; std::_Debug_range2<wchar_t *>(wchar_t *,wchar_t *,wchar_t const *,uint,std::random_access_iterator_tag)+43o ...
.rdata:0000E868                 unicode 0, <invalid iterator range>,0
.rdata:0000E896                 align 4
.rdata:0000E896 _rdata          ends
.rdata:0000E896
.rdata:0000E898 ; ===========================================================================
.rdata:0000E898
.rdata:0000E898 ; Segment type: Pure data
.rdata:0000E898 ; Segment permissions: Read
.rdata:0000E898 ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000E898 _rdata          segment para public 'DATA' use32
.rdata:0000E898                 assume cs:_rdata
.rdata:0000E898                 ;org 0E898h
.rdata:0000E898 ; COMDAT (pick any)
.rdata:0000E898                 public ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:0000E898 ; wchar_t `string'
.rdata:0000E898 ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:0000E898                                         ; DATA XREF: std::_Uninit_copy<wchar_t,wchar_t>(wchar_t *,wchar_t *,wchar_t *,std::_Wrap_alloc<std::allocator<wchar_t>> &,std::_Scalar_ptr_iterator_tag)+9o
.rdata:0000E898                                         ; std::_Uninit_copy<wchar_t,wchar_t>(wchar_t *,wchar_t *,wchar_t *,std::_Wrap_alloc<std::allocator<wchar_t>> &,std::_Scalar_ptr_iterator_tag)+23o ...
.rdata:0000E898                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:0000E898                 unicode 0, <clude\xmemory>,0
.rdata:0000E926                 align 4
.rdata:0000E926 _rdata          ends
.rdata:0000E926
.rdata:0000E928 ; ===========================================================================
.rdata:0000E928
.rdata:0000E928 ; Segment type: Pure data
.rdata:0000E928 ; Segment permissions: Read
.rdata:0000E928 _rdata          segment dword public 'DATA' use32
.rdata:0000E928                 assume cs:_rdata
.rdata:0000E928                 ;org 0E928h
.rdata:0000E928 ; COMDAT (pick any)
.rdata:0000E928                 public ??_C@_1CE@IGJMOCCK@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAo?$AAp?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AA?$AA@
.rdata:0000E928 ; wchar_t `string'
.rdata:0000E928 ??_C@_1CE@IGJMOCCK@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAo?$AAp?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AA?$AA@:
.rdata:0000E928                                         ; DATA XREF: std::_Debug_lt_pred<BufferEquivalent,int &,int &>(BufferEquivalent,int &,int &,wchar_t const *,uint)+6Bo
.rdata:0000E928                 unicode 0, <invalid operator>
.rdata:0000E928                 dw 3Ch, 0
.rdata:0000E928 _rdata          ends
.rdata:0000E928
.rdata$r:0000E94C ; ===========================================================================
.rdata$r:0000E94C
.rdata$r:0000E94C ; Segment type: Pure data
.rdata$r:0000E94C ; Segment permissions: Read
.rdata$r:0000E94C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000E94C                 assume cs:_rdata$r
.rdata$r:0000E94C                 ;org 0E94Ch
.rdata$r:0000E94C ; COMDAT (pick any)
.rdata$r:0000E94C                 public ??_R4Window@@6B@
.rdata$r:0000E94C ; const Window::`RTTI Complete Object Locator'
.rdata$r:0000E94C ??_R4Window@@6B@ db    0                ; DATA XREF: .rdata:0000DDCCo
.rdata$r:0000E94D                 db    0
.rdata$r:0000E94E                 db    0
.rdata$r:0000E94F                 db    0
.rdata$r:0000E950                 db    0
.rdata$r:0000E951                 db    0
.rdata$r:0000E952                 db    0
.rdata$r:0000E953                 db    0
.rdata$r:0000E954                 db    0
.rdata$r:0000E955                 db    0
.rdata$r:0000E956                 db    0
.rdata$r:0000E957                 db    0
.rdata$r:0000E958                 dd offset ??_R0?AVWindow@@@8 ; Window `RTTI Type Descriptor'
.rdata$r:0000E95C                 dd offset ??_R3Window@@8 ; Window::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000E95C _rdata$r        ends
.rdata$r:0000E95C
.data$r:0000E960 ; ===========================================================================
.data$r:0000E960
.data$r:0000E960 ; Segment type: Pure data
.data$r:0000E960 ; Segment permissions: Read/Write
.data$r:0000E960 _data$r         segment dword public 'DATA' use32
.data$r:0000E960                 assume cs:_data$r
.data$r:0000E960                 ;org 0E960h
.data$r:0000E960 ; COMDAT (pick any)
.data$r:0000E960                 public ??_R0?AVWindow@@@8
.data$r:0000E960 ; class Window `RTTI Type Descriptor'
.data$r:0000E960 ??_R0?AVWindow@@@8 dd offset ??_7type_info@@6B@
.data$r:0000E960                                         ; DATA XREF: .rdata$r:0000E958o
.data$r:0000E960                                         ; .rdata$r:Window::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:0000E960                                         ; const type_info::`vftable'
.data$r:0000E964                 align 8
.data$r:0000E968 a_?avwindow@@   db '.?AVWindow@@',0
.data$r:0000E975                 align 4
.data$r:0000E975 _data$r         ends
.data$r:0000E975
.rdata$r:0000E978 ; ===========================================================================
.rdata$r:0000E978
.rdata$r:0000E978 ; Segment type: Pure data
.rdata$r:0000E978 ; Segment permissions: Read
.rdata$r:0000E978 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000E978                 assume cs:_rdata$r
.rdata$r:0000E978                 ;org 0E978h
.rdata$r:0000E978 ; COMDAT (pick any)
.rdata$r:0000E978                 public ??_R3Window@@8
.rdata$r:0000E978 ; Window::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000E978 ??_R3Window@@8  db    0                 ; DATA XREF: .rdata$r:0000E95Co
.rdata$r:0000E978                                         ; .rdata$r:0000E9A8o
.rdata$r:0000E979                 db    0
.rdata$r:0000E97A                 db    0
.rdata$r:0000E97B                 db    0
.rdata$r:0000E97C                 db    0
.rdata$r:0000E97D                 db    0
.rdata$r:0000E97E                 db    0
.rdata$r:0000E97F                 db    0
.rdata$r:0000E980                 db    1
.rdata$r:0000E981                 db    0
.rdata$r:0000E982                 db    0
.rdata$r:0000E983                 db    0
.rdata$r:0000E984                 dd offset ??_R2Window@@8 ; Window::`RTTI Base Class Array'
.rdata$r:0000E984 _rdata$r        ends
.rdata$r:0000E984
.rdata$r:0000E988 ; ===========================================================================
.rdata$r:0000E988
.rdata$r:0000E988 ; Segment type: Pure data
.rdata$r:0000E988 ; Segment permissions: Read
.rdata$r:0000E988 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000E988                 assume cs:_rdata$r
.rdata$r:0000E988                 ;org 0E988h
.rdata$r:0000E988 ; COMDAT (pick any)
.rdata$r:0000E988                 public ??_R2Window@@8
.rdata$r:0000E988 ; Window::`RTTI Base Class Array'
.rdata$r:0000E988 ??_R2Window@@8  dd offset ??_R1A@?0A@EA@Window@@8
.rdata$r:0000E988                                         ; DATA XREF: .rdata$r:0000E984o
.rdata$r:0000E988                                         ; Window::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000E98C                 db    0
.rdata$r:0000E98D                 align 10h
.rdata$r:0000E98D _rdata$r        ends
.rdata$r:0000E98D
.rdata$r:0000E990 ; ===========================================================================
.rdata$r:0000E990
.rdata$r:0000E990 ; Segment type: Pure data
.rdata$r:0000E990 ; Segment permissions: Read
.rdata$r:0000E990 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000E990                 assume cs:_rdata$r
.rdata$r:0000E990                 ;org 0E990h
.rdata$r:0000E990 ; COMDAT (pick any)
.rdata$r:0000E990                 public ??_R1A@?0A@EA@Window@@8
.rdata$r:0000E990 ; Window::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000E990 ??_R1A@?0A@EA@Window@@8 dd offset ??_R0?AVWindow@@@8
.rdata$r:0000E990                                         ; DATA XREF: .rdata$r:Window::`RTTI Base Class Array'o
.rdata$r:0000E990                                         ; .rdata$r:0000E9F0o ...
.rdata$r:0000E990                                         ; Window `RTTI Type Descriptor'
.rdata$r:0000E994                 db    0
.rdata$r:0000E995                 db    0
.rdata$r:0000E996                 db    0
.rdata$r:0000E997                 db    0
.rdata$r:0000E998                 db    0
.rdata$r:0000E999                 db    0
.rdata$r:0000E99A                 db    0
.rdata$r:0000E99B                 db    0
.rdata$r:0000E99C                 db 0FFh
.rdata$r:0000E99D                 db 0FFh
.rdata$r:0000E99E                 db 0FFh
.rdata$r:0000E99F                 db 0FFh
.rdata$r:0000E9A0                 db    0
.rdata$r:0000E9A1                 db    0
.rdata$r:0000E9A2                 db    0
.rdata$r:0000E9A3                 db    0
.rdata$r:0000E9A4                 db  40h ; @
.rdata$r:0000E9A5                 db    0
.rdata$r:0000E9A6                 db    0
.rdata$r:0000E9A7                 db    0
.rdata$r:0000E9A8                 dd offset ??_R3Window@@8 ; Window::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000E9A8 _rdata$r        ends
.rdata$r:0000E9A8
.rdata$r:0000E9AC ; ===========================================================================
.rdata$r:0000E9AC
.rdata$r:0000E9AC ; Segment type: Pure data
.rdata$r:0000E9AC ; Segment permissions: Read
.rdata$r:0000E9AC _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000E9AC                 assume cs:_rdata$r
.rdata$r:0000E9AC                 ;org 0E9ACh
.rdata$r:0000E9AC ; COMDAT (pick any)
.rdata$r:0000E9AC                 public ??_R4StaticDialog@@6B@
.rdata$r:0000E9AC ; const StaticDialog::`RTTI Complete Object Locator'
.rdata$r:0000E9AC ??_R4StaticDialog@@6B@ db    0          ; DATA XREF: .rdata:0000DE00o
.rdata$r:0000E9AD                 db    0
.rdata$r:0000E9AE                 db    0
.rdata$r:0000E9AF                 db    0
.rdata$r:0000E9B0                 db    0
.rdata$r:0000E9B1                 db    0
.rdata$r:0000E9B2                 db    0
.rdata$r:0000E9B3                 db    0
.rdata$r:0000E9B4                 db    0
.rdata$r:0000E9B5                 db    0
.rdata$r:0000E9B6                 db    0
.rdata$r:0000E9B7                 db    0
.rdata$r:0000E9B8                 dd offset ??_R0?AVStaticDialog@@@8 ; StaticDialog `RTTI Type Descriptor'
.rdata$r:0000E9BC                 dd offset ??_R3StaticDialog@@8 ; StaticDialog::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000E9BC _rdata$r        ends
.rdata$r:0000E9BC
.data$r:0000E9C0 ; ===========================================================================
.data$r:0000E9C0
.data$r:0000E9C0 ; Segment type: Pure data
.data$r:0000E9C0 ; Segment permissions: Read/Write
.data$r:0000E9C0 _data$r         segment dword public 'DATA' use32
.data$r:0000E9C0                 assume cs:_data$r
.data$r:0000E9C0                 ;org 0E9C0h
.data$r:0000E9C0 ; COMDAT (pick any)
.data$r:0000E9C0                 public ??_R0?AVStaticDialog@@@8
.data$r:0000E9C0 ; class StaticDialog `RTTI Type Descriptor'
.data$r:0000E9C0 ??_R0?AVStaticDialog@@@8 dd offset ??_7type_info@@6B@
.data$r:0000E9C0                                         ; DATA XREF: .rdata$r:0000E9B8o
.data$r:0000E9C0                                         ; .rdata$r:StaticDialog::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:0000E9C0                                         ; const type_info::`vftable'
.data$r:0000E9C4                 align 8
.data$r:0000E9C8 a_?avstaticdial db '.?AVStaticDialog@@',0
.data$r:0000E9DB                 align 4
.data$r:0000E9DB _data$r         ends
.data$r:0000E9DB
.rdata$r:0000E9DC ; ===========================================================================
.rdata$r:0000E9DC
.rdata$r:0000E9DC ; Segment type: Pure data
.rdata$r:0000E9DC ; Segment permissions: Read
.rdata$r:0000E9DC _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000E9DC                 assume cs:_rdata$r
.rdata$r:0000E9DC                 ;org 0E9DCh
.rdata$r:0000E9DC ; COMDAT (pick any)
.rdata$r:0000E9DC                 public ??_R3StaticDialog@@8
.rdata$r:0000E9DC ; StaticDialog::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000E9DC ??_R3StaticDialog@@8 db    0            ; DATA XREF: .rdata$r:0000E9BCo
.rdata$r:0000E9DC                                         ; .rdata$r:0000EA10o
.rdata$r:0000E9DD                 db    0
.rdata$r:0000E9DE                 db    0
.rdata$r:0000E9DF                 db    0
.rdata$r:0000E9E0                 db    0
.rdata$r:0000E9E1                 db    0
.rdata$r:0000E9E2                 db    0
.rdata$r:0000E9E3                 db    0
.rdata$r:0000E9E4                 db    2
.rdata$r:0000E9E5                 db    0
.rdata$r:0000E9E6                 db    0
.rdata$r:0000E9E7                 db    0
.rdata$r:0000E9E8                 dd offset ??_R2StaticDialog@@8 ; StaticDialog::`RTTI Base Class Array'
.rdata$r:0000E9E8 _rdata$r        ends
.rdata$r:0000E9E8
.rdata$r:0000E9EC ; ===========================================================================
.rdata$r:0000E9EC
.rdata$r:0000E9EC ; Segment type: Pure data
.rdata$r:0000E9EC ; Segment permissions: Read
.rdata$r:0000E9EC _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000E9EC                 assume cs:_rdata$r
.rdata$r:0000E9EC                 ;org 0E9ECh
.rdata$r:0000E9EC ; COMDAT (pick any)
.rdata$r:0000E9EC                 public ??_R2StaticDialog@@8
.rdata$r:0000E9EC ; StaticDialog::`RTTI Base Class Array'
.rdata$r:0000E9EC ??_R2StaticDialog@@8 dd offset ??_R1A@?0A@EA@StaticDialog@@8
.rdata$r:0000E9EC                                         ; DATA XREF: .rdata$r:0000E9E8o
.rdata$r:0000E9EC                                         ; StaticDialog::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000E9F0                 dd offset ??_R1A@?0A@EA@Window@@8 ; Window::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000E9F4                 db    0
.rdata$r:0000E9F5                 align 4
.rdata$r:0000E9F5 _rdata$r        ends
.rdata$r:0000E9F5
.rdata$r:0000E9F8 ; ===========================================================================
.rdata$r:0000E9F8
.rdata$r:0000E9F8 ; Segment type: Pure data
.rdata$r:0000E9F8 ; Segment permissions: Read
.rdata$r:0000E9F8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000E9F8                 assume cs:_rdata$r
.rdata$r:0000E9F8                 ;org 0E9F8h
.rdata$r:0000E9F8 ; COMDAT (pick any)
.rdata$r:0000E9F8                 public ??_R1A@?0A@EA@StaticDialog@@8
.rdata$r:0000E9F8 ; StaticDialog::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000E9F8 ??_R1A@?0A@EA@StaticDialog@@8 dd offset ??_R0?AVStaticDialog@@@8
.rdata$r:0000E9F8                                         ; DATA XREF: .rdata$r:StaticDialog::`RTTI Base Class Array'o
.rdata$r:0000E9F8                                         ; .rdata$r:0000EC38o ...
.rdata$r:0000E9F8                                         ; StaticDialog `RTTI Type Descriptor'
.rdata$r:0000E9FC                 db    1
.rdata$r:0000E9FD                 db    0
.rdata$r:0000E9FE                 db    0
.rdata$r:0000E9FF                 db    0
.rdata$r:0000EA00                 db    0
.rdata$r:0000EA01                 db    0
.rdata$r:0000EA02                 db    0
.rdata$r:0000EA03                 db    0
.rdata$r:0000EA04                 db 0FFh
.rdata$r:0000EA05                 db 0FFh
.rdata$r:0000EA06                 db 0FFh
.rdata$r:0000EA07                 db 0FFh
.rdata$r:0000EA08                 db    0
.rdata$r:0000EA09                 db    0
.rdata$r:0000EA0A                 db    0
.rdata$r:0000EA0B                 db    0
.rdata$r:0000EA0C                 db  40h ; @
.rdata$r:0000EA0D                 db    0
.rdata$r:0000EA0E                 db    0
.rdata$r:0000EA0F                 db    0
.rdata$r:0000EA10                 dd offset ??_R3StaticDialog@@8 ; StaticDialog::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000EA10 _rdata$r        ends
.rdata$r:0000EA10
.rdata$r:0000EA14 ; ===========================================================================
.rdata$r:0000EA14
.rdata$r:0000EA14 ; Segment type: Pure data
.rdata$r:0000EA14 ; Segment permissions: Read
.rdata$r:0000EA14 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000EA14                 assume cs:_rdata$r
.rdata$r:0000EA14                 ;org 0EA14h
.rdata$r:0000EA14 ; COMDAT (pick any)
.rdata$r:0000EA14                 public ??_R4error_category@std@@6B@
.rdata$r:0000EA14 ; const std::error_category::`RTTI Complete Object Locator'
.rdata$r:0000EA14 ??_R4error_category@std@@6B@ db    0    ; DATA XREF: .rdata:0000DE40o
.rdata$r:0000EA15                 db    0
.rdata$r:0000EA16                 db    0
.rdata$r:0000EA17                 db    0
.rdata$r:0000EA18                 db    0
.rdata$r:0000EA19                 db    0
.rdata$r:0000EA1A                 db    0
.rdata$r:0000EA1B                 db    0
.rdata$r:0000EA1C                 db    0
.rdata$r:0000EA1D                 db    0
.rdata$r:0000EA1E                 db    0
.rdata$r:0000EA1F                 db    0
.rdata$r:0000EA20                 dd offset ??_R0?AVerror_category@std@@@8 ; std::error_category `RTTI Type Descriptor'
.rdata$r:0000EA24                 dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000EA24 _rdata$r        ends
.rdata$r:0000EA24
.data$r:0000EA28 ; ===========================================================================
.data$r:0000EA28
.data$r:0000EA28 ; Segment type: Pure data
.data$r:0000EA28 ; Segment permissions: Read/Write
.data$r:0000EA28 _data$r         segment dword public 'DATA' use32
.data$r:0000EA28                 assume cs:_data$r
.data$r:0000EA28                 ;org 0EA28h
.data$r:0000EA28 ; COMDAT (pick any)
.data$r:0000EA28                 public ??_R0?AVerror_category@std@@@8
.data$r:0000EA28 ; class std::error_category `RTTI Type Descriptor'
.data$r:0000EA28 ??_R0?AVerror_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:0000EA28                                         ; DATA XREF: .rdata$r:0000EA20o
.data$r:0000EA28                                         ; .rdata$r:std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:0000EA28                                         ; const type_info::`vftable'
.data$r:0000EA2C                 align 10h
.data$r:0000EA30 a_?averror_cate db '.?AVerror_category@std@@',0
.data$r:0000EA49                 align 4
.data$r:0000EA49 _data$r         ends
.data$r:0000EA49
.rdata$r:0000EA4C ; ===========================================================================
.rdata$r:0000EA4C
.rdata$r:0000EA4C ; Segment type: Pure data
.rdata$r:0000EA4C ; Segment permissions: Read
.rdata$r:0000EA4C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000EA4C                 assume cs:_rdata$r
.rdata$r:0000EA4C                 ;org 0EA4Ch
.rdata$r:0000EA4C ; COMDAT (pick any)
.rdata$r:0000EA4C                 public ??_R3error_category@std@@8
.rdata$r:0000EA4C ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000EA4C ??_R3error_category@std@@8 db    0      ; DATA XREF: .rdata$r:0000EA24o
.rdata$r:0000EA4C                                         ; .rdata$r:0000EA7Co
.rdata$r:0000EA4D                 db    0
.rdata$r:0000EA4E                 db    0
.rdata$r:0000EA4F                 db    0
.rdata$r:0000EA50                 db    0
.rdata$r:0000EA51                 db    0
.rdata$r:0000EA52                 db    0
.rdata$r:0000EA53                 db    0
.rdata$r:0000EA54                 db    1
.rdata$r:0000EA55                 db    0
.rdata$r:0000EA56                 db    0
.rdata$r:0000EA57                 db    0
.rdata$r:0000EA58                 dd offset ??_R2error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
.rdata$r:0000EA58 _rdata$r        ends
.rdata$r:0000EA58
.rdata$r:0000EA5C ; ===========================================================================
.rdata$r:0000EA5C
.rdata$r:0000EA5C ; Segment type: Pure data
.rdata$r:0000EA5C ; Segment permissions: Read
.rdata$r:0000EA5C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000EA5C                 assume cs:_rdata$r
.rdata$r:0000EA5C                 ;org 0EA5Ch
.rdata$r:0000EA5C ; COMDAT (pick any)
.rdata$r:0000EA5C                 public ??_R2error_category@std@@8
.rdata$r:0000EA5C ; std::error_category::`RTTI Base Class Array'
.rdata$r:0000EA5C ??_R2error_category@std@@8 dd offset ??_R1A@?0A@EA@error_category@std@@8
.rdata$r:0000EA5C                                         ; DATA XREF: .rdata$r:0000EA58o
.rdata$r:0000EA5C                                         ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000EA60                 db    0
.rdata$r:0000EA61                 align 4
.rdata$r:0000EA61 _rdata$r        ends
.rdata$r:0000EA61
.rdata$r:0000EA64 ; ===========================================================================
.rdata$r:0000EA64
.rdata$r:0000EA64 ; Segment type: Pure data
.rdata$r:0000EA64 ; Segment permissions: Read
.rdata$r:0000EA64 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000EA64                 assume cs:_rdata$r
.rdata$r:0000EA64                 ;org 0EA64h
.rdata$r:0000EA64 ; COMDAT (pick any)
.rdata$r:0000EA64                 public ??_R1A@?0A@EA@error_category@std@@8
.rdata$r:0000EA64 ; std::error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000EA64 ??_R1A@?0A@EA@error_category@std@@8 dd offset ??_R0?AVerror_category@std@@@8
.rdata$r:0000EA64                                         ; DATA XREF: .rdata$r:std::error_category::`RTTI Base Class Array'o
.rdata$r:0000EA64                                         ; .rdata$r:0000EAD4o ...
.rdata$r:0000EA64                                         ; std::error_category `RTTI Type Descriptor'
.rdata$r:0000EA68                 align 10h
.rdata$r:0000EA70                 db 0FFh
.rdata$r:0000EA71                 db 0FFh
.rdata$r:0000EA72                 db 0FFh
.rdata$r:0000EA73                 db 0FFh
.rdata$r:0000EA74                 db    0
.rdata$r:0000EA75                 db    0
.rdata$r:0000EA76                 db    0
.rdata$r:0000EA77                 db    0
.rdata$r:0000EA78                 db  40h ; @
.rdata$r:0000EA79                 db    0
.rdata$r:0000EA7A                 db    0
.rdata$r:0000EA7B                 db    0
.rdata$r:0000EA7C                 dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000EA7C _rdata$r        ends
.rdata$r:0000EA7C
.rdata$r:0000EA80 ; ===========================================================================
.rdata$r:0000EA80
.rdata$r:0000EA80 ; Segment type: Pure data
.rdata$r:0000EA80 ; Segment permissions: Read
.rdata$r:0000EA80 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000EA80                 assume cs:_rdata$r
.rdata$r:0000EA80                 ;org 0EA80h
.rdata$r:0000EA80 ; COMDAT (pick any)
.rdata$r:0000EA80                 public ??_R4_Generic_error_category@std@@6B@
.rdata$r:0000EA80 ; const std::_Generic_error_category::`RTTI Complete Object Locator'
.rdata$r:0000EA80 ??_R4_Generic_error_category@std@@6B@ db    0
.rdata$r:0000EA80                                         ; DATA XREF: .rdata:0000DE5Co
.rdata$r:0000EA81                 db    0
.rdata$r:0000EA82                 db    0
.rdata$r:0000EA83                 db    0
.rdata$r:0000EA84                 db    0
.rdata$r:0000EA85                 db    0
.rdata$r:0000EA86                 db    0
.rdata$r:0000EA87                 db    0
.rdata$r:0000EA88                 db    0
.rdata$r:0000EA89                 db    0
.rdata$r:0000EA8A                 db    0
.rdata$r:0000EA8B                 db    0
.rdata$r:0000EA8C                 dd offset ??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category `RTTI Type Descriptor'
.rdata$r:0000EA90                 dd offset ??_R3_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000EA90 _rdata$r        ends
.rdata$r:0000EA90
.data$r:0000EA94 ; ===========================================================================
.data$r:0000EA94
.data$r:0000EA94 ; Segment type: Pure data
.data$r:0000EA94 ; Segment permissions: Read/Write
.data$r:0000EA94 _data$r         segment dword public 'DATA' use32
.data$r:0000EA94                 assume cs:_data$r
.data$r:0000EA94                 ;org 0EA94h
.data$r:0000EA94 ; COMDAT (pick any)
.data$r:0000EA94                 public ??_R0?AV_Generic_error_category@std@@@8
.data$r:0000EA94 ; class std::_Generic_error_category `RTTI Type Descriptor'
.data$r:0000EA94 ??_R0?AV_Generic_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:0000EA94                                         ; DATA XREF: .rdata$r:0000EA8Co
.data$r:0000EA94                                         ; .rdata$r:std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:0000EA94                                         ; const type_info::`vftable'
.data$r:0000EA98                 db    0
.data$r:0000EA99                 db    0
.data$r:0000EA9A                 db    0
.data$r:0000EA9B                 db    0
.data$r:0000EA9C                 db  2Eh ; .
.data$r:0000EA9D                 db  3Fh ; ?
.data$r:0000EA9E                 db  41h ; A
.data$r:0000EA9F                 db  56h ; V
.data$r:0000EAA0                 db  5Fh ; _
.data$r:0000EAA1                 db  47h ; G
.data$r:0000EAA2                 db  65h ; e
.data$r:0000EAA3                 db  6Eh ; n
.data$r:0000EAA4                 db  65h ; e
.data$r:0000EAA5                 db  72h ; r
.data$r:0000EAA6                 db  69h ; i
.data$r:0000EAA7                 db  63h ; c
.data$r:0000EAA8                 db  5Fh ; _
.data$r:0000EAA9                 db  65h ; e
.data$r:0000EAAA                 db  72h ; r
.data$r:0000EAAB                 db  72h ; r
.data$r:0000EAAC                 db  6Fh ; o
.data$r:0000EAAD                 db  72h ; r
.data$r:0000EAAE                 db  5Fh ; _
.data$r:0000EAAF                 db  63h ; c
.data$r:0000EAB0                 db  61h ; a
.data$r:0000EAB1                 db  74h ; t
.data$r:0000EAB2                 db  65h ; e
.data$r:0000EAB3                 db  67h ; g
.data$r:0000EAB4                 db  6Fh ; o
.data$r:0000EAB5                 db  72h ; r
.data$r:0000EAB6                 db  79h ; y
.data$r:0000EAB7                 db  40h ; @
.data$r:0000EAB8                 db  73h ; s
.data$r:0000EAB9                 db  74h ; t
.data$r:0000EABA                 db  64h ; d
.data$r:0000EABB                 db  40h ; @
.data$r:0000EABC                 db  40h ; @
.data$r:0000EABD                 db    0
.data$r:0000EABE                 align 10h
.data$r:0000EABE _data$r         ends
.data$r:0000EABE
.rdata$r:0000EAC0 ; ===========================================================================
.rdata$r:0000EAC0
.rdata$r:0000EAC0 ; Segment type: Pure data
.rdata$r:0000EAC0 ; Segment permissions: Read
.rdata$r:0000EAC0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000EAC0                 assume cs:_rdata$r
.rdata$r:0000EAC0                 ;org 0EAC0h
.rdata$r:0000EAC0 ; COMDAT (pick any)
.rdata$r:0000EAC0                 public ??_R3_Generic_error_category@std@@8
.rdata$r:0000EAC0 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000EAC0 ??_R3_Generic_error_category@std@@8 db    0
.rdata$r:0000EAC0                                         ; DATA XREF: .rdata$r:0000EA90o
.rdata$r:0000EAC0                                         ; .rdata$r:0000EAF4o
.rdata$r:0000EAC1                 db    0
.rdata$r:0000EAC2                 db    0
.rdata$r:0000EAC3                 db    0
.rdata$r:0000EAC4                 db    0
.rdata$r:0000EAC5                 db    0
.rdata$r:0000EAC6                 db    0
.rdata$r:0000EAC7                 db    0
.rdata$r:0000EAC8                 db    2
.rdata$r:0000EAC9                 db    0
.rdata$r:0000EACA                 db    0
.rdata$r:0000EACB                 db    0
.rdata$r:0000EACC                 dd offset ??_R2_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
.rdata$r:0000EACC _rdata$r        ends
.rdata$r:0000EACC
.rdata$r:0000EAD0 ; ===========================================================================
.rdata$r:0000EAD0
.rdata$r:0000EAD0 ; Segment type: Pure data
.rdata$r:0000EAD0 ; Segment permissions: Read
.rdata$r:0000EAD0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000EAD0                 assume cs:_rdata$r
.rdata$r:0000EAD0                 ;org 0EAD0h
.rdata$r:0000EAD0 ; COMDAT (pick any)
.rdata$r:0000EAD0                 public ??_R2_Generic_error_category@std@@8
.rdata$r:0000EAD0 ; std::_Generic_error_category::`RTTI Base Class Array'
.rdata$r:0000EAD0 ??_R2_Generic_error_category@std@@8 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8
.rdata$r:0000EAD0                                         ; DATA XREF: .rdata$r:0000EACCo
.rdata$r:0000EAD0                                         ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000EAD4                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000EAD8                 db    0
.rdata$r:0000EAD9                 align 4
.rdata$r:0000EAD9 _rdata$r        ends
.rdata$r:0000EAD9
.rdata$r:0000EADC ; ===========================================================================
.rdata$r:0000EADC
.rdata$r:0000EADC ; Segment type: Pure data
.rdata$r:0000EADC ; Segment permissions: Read
.rdata$r:0000EADC _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000EADC                 assume cs:_rdata$r
.rdata$r:0000EADC                 ;org 0EADCh
.rdata$r:0000EADC ; COMDAT (pick any)
.rdata$r:0000EADC                 public ??_R1A@?0A@EA@_Generic_error_category@std@@8
.rdata$r:0000EADC ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000EADC ??_R1A@?0A@EA@_Generic_error_category@std@@8 dd offset ??_R0?AV_Generic_error_category@std@@@8
.rdata$r:0000EADC                                         ; DATA XREF: .rdata$r:std::_Generic_error_category::`RTTI Base Class Array'o
.rdata$r:0000EADC                                         ; .rdata$r:0000EB4Co ...
.rdata$r:0000EADC                                         ; std::_Generic_error_category `RTTI Type Descriptor'
.rdata$r:0000EAE0                 db    1
.rdata$r:0000EAE1                 db    0
.rdata$r:0000EAE2                 db    0
.rdata$r:0000EAE3                 db    0
.rdata$r:0000EAE4                 db    0
.rdata$r:0000EAE5                 db    0
.rdata$r:0000EAE6                 db    0
.rdata$r:0000EAE7                 db    0
.rdata$r:0000EAE8                 db 0FFh
.rdata$r:0000EAE9                 db 0FFh
.rdata$r:0000EAEA                 db 0FFh
.rdata$r:0000EAEB                 db 0FFh
.rdata$r:0000EAEC                 db    0
.rdata$r:0000EAED                 db    0
.rdata$r:0000EAEE                 db    0
.rdata$r:0000EAEF                 db    0
.rdata$r:0000EAF0                 db  40h ; @
.rdata$r:0000EAF1                 db    0
.rdata$r:0000EAF2                 db    0
.rdata$r:0000EAF3                 db    0
.rdata$r:0000EAF4                 dd offset ??_R3_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000EAF4 _rdata$r        ends
.rdata$r:0000EAF4
.rdata$r:0000EAF8 ; ===========================================================================
.rdata$r:0000EAF8
.rdata$r:0000EAF8 ; Segment type: Pure data
.rdata$r:0000EAF8 ; Segment permissions: Read
.rdata$r:0000EAF8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000EAF8                 assume cs:_rdata$r
.rdata$r:0000EAF8                 ;org 0EAF8h
.rdata$r:0000EAF8 ; COMDAT (pick any)
.rdata$r:0000EAF8                 public ??_R4_Iostream_error_category@std@@6B@
.rdata$r:0000EAF8 ; const std::_Iostream_error_category::`RTTI Complete Object Locator'
.rdata$r:0000EAF8 ??_R4_Iostream_error_category@std@@6B@ db    0
.rdata$r:0000EAF8                                         ; DATA XREF: .rdata:0000DE90o
.rdata$r:0000EAF9                 db    0
.rdata$r:0000EAFA                 db    0
.rdata$r:0000EAFB                 db    0
.rdata$r:0000EAFC                 db    0
.rdata$r:0000EAFD                 db    0
.rdata$r:0000EAFE                 db    0
.rdata$r:0000EAFF                 db    0
.rdata$r:0000EB00                 db    0
.rdata$r:0000EB01                 db    0
.rdata$r:0000EB02                 db    0
.rdata$r:0000EB03                 db    0
.rdata$r:0000EB04                 dd offset ??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category `RTTI Type Descriptor'
.rdata$r:0000EB08                 dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000EB08 _rdata$r        ends
.rdata$r:0000EB08
.data$r:0000EB0C ; ===========================================================================
.data$r:0000EB0C
.data$r:0000EB0C ; Segment type: Pure data
.data$r:0000EB0C ; Segment permissions: Read/Write
.data$r:0000EB0C _data$r         segment dword public 'DATA' use32
.data$r:0000EB0C                 assume cs:_data$r
.data$r:0000EB0C                 ;org 0EB0Ch
.data$r:0000EB0C ; COMDAT (pick any)
.data$r:0000EB0C                 public ??_R0?AV_Iostream_error_category@std@@@8
.data$r:0000EB0C ; class std::_Iostream_error_category `RTTI Type Descriptor'
.data$r:0000EB0C ??_R0?AV_Iostream_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:0000EB0C                                         ; DATA XREF: .rdata$r:0000EB04o
.data$r:0000EB0C                                         ; .rdata$r:std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:0000EB0C                                         ; const type_info::`vftable'
.data$r:0000EB10                 db    0
.data$r:0000EB11                 db    0
.data$r:0000EB12                 db    0
.data$r:0000EB13                 db    0
.data$r:0000EB14                 db  2Eh ; .
.data$r:0000EB15                 db  3Fh ; ?
.data$r:0000EB16                 db  41h ; A
.data$r:0000EB17                 db  56h ; V
.data$r:0000EB18                 db  5Fh ; _
.data$r:0000EB19                 db  49h ; I
.data$r:0000EB1A                 db  6Fh ; o
.data$r:0000EB1B                 db  73h ; s
.data$r:0000EB1C                 db  74h ; t
.data$r:0000EB1D                 db  72h ; r
.data$r:0000EB1E                 db  65h ; e
.data$r:0000EB1F                 db  61h ; a
.data$r:0000EB20                 db  6Dh ; m
.data$r:0000EB21                 db  5Fh ; _
.data$r:0000EB22                 db  65h ; e
.data$r:0000EB23                 db  72h ; r
.data$r:0000EB24                 db  72h ; r
.data$r:0000EB25                 db  6Fh ; o
.data$r:0000EB26                 db  72h ; r
.data$r:0000EB27                 db  5Fh ; _
.data$r:0000EB28                 db  63h ; c
.data$r:0000EB29                 db  61h ; a
.data$r:0000EB2A                 db  74h ; t
.data$r:0000EB2B                 db  65h ; e
.data$r:0000EB2C                 db  67h ; g
.data$r:0000EB2D                 db  6Fh ; o
.data$r:0000EB2E                 db  72h ; r
.data$r:0000EB2F                 db  79h ; y
.data$r:0000EB30                 db  40h ; @
.data$r:0000EB31                 db  73h ; s
.data$r:0000EB32                 db  74h ; t
.data$r:0000EB33                 db  64h ; d
.data$r:0000EB34                 db  40h ; @
.data$r:0000EB35                 db  40h ; @
.data$r:0000EB36                 db    0
.data$r:0000EB37                 align 4
.data$r:0000EB37 _data$r         ends
.data$r:0000EB37
.rdata$r:0000EB38 ; ===========================================================================
.rdata$r:0000EB38
.rdata$r:0000EB38 ; Segment type: Pure data
.rdata$r:0000EB38 ; Segment permissions: Read
.rdata$r:0000EB38 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000EB38                 assume cs:_rdata$r
.rdata$r:0000EB38                 ;org 0EB38h
.rdata$r:0000EB38 ; COMDAT (pick any)
.rdata$r:0000EB38                 public ??_R3_Iostream_error_category@std@@8
.rdata$r:0000EB38 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000EB38 ??_R3_Iostream_error_category@std@@8 db    0
.rdata$r:0000EB38                                         ; DATA XREF: .rdata$r:0000EB08o
.rdata$r:0000EB38                                         ; .rdata$r:0000EB70o
.rdata$r:0000EB39                 db    0
.rdata$r:0000EB3A                 db    0
.rdata$r:0000EB3B                 db    0
.rdata$r:0000EB3C                 db    0
.rdata$r:0000EB3D                 db    0
.rdata$r:0000EB3E                 db    0
.rdata$r:0000EB3F                 db    0
.rdata$r:0000EB40                 db    3
.rdata$r:0000EB41                 db    0
.rdata$r:0000EB42                 db    0
.rdata$r:0000EB43                 db    0
.rdata$r:0000EB44                 dd offset ??_R2_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
.rdata$r:0000EB44 _rdata$r        ends
.rdata$r:0000EB44
.rdata$r:0000EB48 ; ===========================================================================
.rdata$r:0000EB48
.rdata$r:0000EB48 ; Segment type: Pure data
.rdata$r:0000EB48 ; Segment permissions: Read
.rdata$r:0000EB48 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000EB48                 assume cs:_rdata$r
.rdata$r:0000EB48                 ;org 0EB48h
.rdata$r:0000EB48 ; COMDAT (pick any)
.rdata$r:0000EB48                 public ??_R2_Iostream_error_category@std@@8
.rdata$r:0000EB48 ; std::_Iostream_error_category::`RTTI Base Class Array'
.rdata$r:0000EB48 ??_R2_Iostream_error_category@std@@8 dd offset ??_R1A@?0A@EA@_Iostream_error_category@std@@8
.rdata$r:0000EB48                                         ; DATA XREF: .rdata$r:0000EB44o
.rdata$r:0000EB48                                         ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000EB4C                 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000EB50                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000EB54                 db    0
.rdata$r:0000EB55                 align 4
.rdata$r:0000EB55 _rdata$r        ends
.rdata$r:0000EB55
.rdata$r:0000EB58 ; ===========================================================================
.rdata$r:0000EB58
.rdata$r:0000EB58 ; Segment type: Pure data
.rdata$r:0000EB58 ; Segment permissions: Read
.rdata$r:0000EB58 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000EB58                 assume cs:_rdata$r
.rdata$r:0000EB58                 ;org 0EB58h
.rdata$r:0000EB58 ; COMDAT (pick any)
.rdata$r:0000EB58                 public ??_R1A@?0A@EA@_Iostream_error_category@std@@8
.rdata$r:0000EB58 ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000EB58 ??_R1A@?0A@EA@_Iostream_error_category@std@@8 dd offset ??_R0?AV_Iostream_error_category@std@@@8
.rdata$r:0000EB58                                         ; DATA XREF: .rdata$r:std::_Iostream_error_category::`RTTI Base Class Array'o
.rdata$r:0000EB58                                         ; std::_Iostream_error_category `RTTI Type Descriptor'
.rdata$r:0000EB5C                 db    2
.rdata$r:0000EB5D                 db    0
.rdata$r:0000EB5E                 db    0
.rdata$r:0000EB5F                 db    0
.rdata$r:0000EB60                 db    0
.rdata$r:0000EB61                 db    0
.rdata$r:0000EB62                 db    0
.rdata$r:0000EB63                 db    0
.rdata$r:0000EB64                 db 0FFh
.rdata$r:0000EB65                 db 0FFh
.rdata$r:0000EB66                 db 0FFh
.rdata$r:0000EB67                 db 0FFh
.rdata$r:0000EB68                 db    0
.rdata$r:0000EB69                 db    0
.rdata$r:0000EB6A                 db    0
.rdata$r:0000EB6B                 db    0
.rdata$r:0000EB6C                 db  40h ; @
.rdata$r:0000EB6D                 db    0
.rdata$r:0000EB6E                 db    0
.rdata$r:0000EB6F                 db    0
.rdata$r:0000EB70                 dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000EB70 _rdata$r        ends
.rdata$r:0000EB70
.rdata$r:0000EB74 ; ===========================================================================
.rdata$r:0000EB74
.rdata$r:0000EB74 ; Segment type: Pure data
.rdata$r:0000EB74 ; Segment permissions: Read
.rdata$r:0000EB74 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000EB74                 assume cs:_rdata$r
.rdata$r:0000EB74                 ;org 0EB74h
.rdata$r:0000EB74 ; COMDAT (pick any)
.rdata$r:0000EB74                 public ??_R4_System_error_category@std@@6B@
.rdata$r:0000EB74 ; const std::_System_error_category::`RTTI Complete Object Locator'
.rdata$r:0000EB74 ??_R4_System_error_category@std@@6B@ db    0 ; DATA XREF: .rdata:0000DED0o
.rdata$r:0000EB75                 db    0
.rdata$r:0000EB76                 db    0
.rdata$r:0000EB77                 db    0
.rdata$r:0000EB78                 db    0
.rdata$r:0000EB79                 db    0
.rdata$r:0000EB7A                 db    0
.rdata$r:0000EB7B                 db    0
.rdata$r:0000EB7C                 db    0
.rdata$r:0000EB7D                 db    0
.rdata$r:0000EB7E                 db    0
.rdata$r:0000EB7F                 db    0
.rdata$r:0000EB80                 dd offset ??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category `RTTI Type Descriptor'
.rdata$r:0000EB84                 dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000EB84 _rdata$r        ends
.rdata$r:0000EB84
.data$r:0000EB88 ; ===========================================================================
.data$r:0000EB88
.data$r:0000EB88 ; Segment type: Pure data
.data$r:0000EB88 ; Segment permissions: Read/Write
.data$r:0000EB88 _data$r         segment dword public 'DATA' use32
.data$r:0000EB88                 assume cs:_data$r
.data$r:0000EB88                 ;org 0EB88h
.data$r:0000EB88 ; COMDAT (pick any)
.data$r:0000EB88                 public ??_R0?AV_System_error_category@std@@@8
.data$r:0000EB88 ; class std::_System_error_category `RTTI Type Descriptor'
.data$r:0000EB88 ??_R0?AV_System_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:0000EB88                                         ; DATA XREF: .rdata$r:0000EB80o
.data$r:0000EB88                                         ; .rdata$r:std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:0000EB88                                         ; const type_info::`vftable'
.data$r:0000EB8C                 align 10h
.data$r:0000EB90 a_?av_system_er db '.?AV_System_error_category@std@@',0
.data$r:0000EBB1                 align 4
.data$r:0000EBB1 _data$r         ends
.data$r:0000EBB1
.rdata$r:0000EBB4 ; ===========================================================================
.rdata$r:0000EBB4
.rdata$r:0000EBB4 ; Segment type: Pure data
.rdata$r:0000EBB4 ; Segment permissions: Read
.rdata$r:0000EBB4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000EBB4                 assume cs:_rdata$r
.rdata$r:0000EBB4                 ;org 0EBB4h
.rdata$r:0000EBB4 ; COMDAT (pick any)
.rdata$r:0000EBB4                 public ??_R3_System_error_category@std@@8
.rdata$r:0000EBB4 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000EBB4 ??_R3_System_error_category@std@@8 db    0 ; DATA XREF: .rdata$r:0000EB84o
.rdata$r:0000EBB4                                         ; .rdata$r:0000EBECo
.rdata$r:0000EBB5                 db    0
.rdata$r:0000EBB6                 db    0
.rdata$r:0000EBB7                 db    0
.rdata$r:0000EBB8                 db    0
.rdata$r:0000EBB9                 db    0
.rdata$r:0000EBBA                 db    0
.rdata$r:0000EBBB                 db    0
.rdata$r:0000EBBC                 db    3
.rdata$r:0000EBBD                 db    0
.rdata$r:0000EBBE                 db    0
.rdata$r:0000EBBF                 db    0
.rdata$r:0000EBC0                 dd offset ??_R2_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
.rdata$r:0000EBC0 _rdata$r        ends
.rdata$r:0000EBC0
.rdata$r:0000EBC4 ; ===========================================================================
.rdata$r:0000EBC4
.rdata$r:0000EBC4 ; Segment type: Pure data
.rdata$r:0000EBC4 ; Segment permissions: Read
.rdata$r:0000EBC4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000EBC4                 assume cs:_rdata$r
.rdata$r:0000EBC4                 ;org 0EBC4h
.rdata$r:0000EBC4 ; COMDAT (pick any)
.rdata$r:0000EBC4                 public ??_R2_System_error_category@std@@8
.rdata$r:0000EBC4 ; std::_System_error_category::`RTTI Base Class Array'
.rdata$r:0000EBC4 ??_R2_System_error_category@std@@8 dd offset ??_R1A@?0A@EA@_System_error_category@std@@8
.rdata$r:0000EBC4                                         ; DATA XREF: .rdata$r:0000EBC0o
.rdata$r:0000EBC4                                         ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000EBC8                 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000EBCC                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000EBD0                 db    0
.rdata$r:0000EBD1                 align 4
.rdata$r:0000EBD1 _rdata$r        ends
.rdata$r:0000EBD1
.rdata$r:0000EBD4 ; ===========================================================================
.rdata$r:0000EBD4
.rdata$r:0000EBD4 ; Segment type: Pure data
.rdata$r:0000EBD4 ; Segment permissions: Read
.rdata$r:0000EBD4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000EBD4                 assume cs:_rdata$r
.rdata$r:0000EBD4                 ;org 0EBD4h
.rdata$r:0000EBD4 ; COMDAT (pick any)
.rdata$r:0000EBD4                 public ??_R1A@?0A@EA@_System_error_category@std@@8
.rdata$r:0000EBD4 ; std::_System_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000EBD4 ??_R1A@?0A@EA@_System_error_category@std@@8 dd offset ??_R0?AV_System_error_category@std@@@8
.rdata$r:0000EBD4                                         ; DATA XREF: .rdata$r:std::_System_error_category::`RTTI Base Class Array'o
.rdata$r:0000EBD4                                         ; std::_System_error_category `RTTI Type Descriptor'
.rdata$r:0000EBD8                 db    2
.rdata$r:0000EBD9                 db    0
.rdata$r:0000EBDA                 db    0
.rdata$r:0000EBDB                 db    0
.rdata$r:0000EBDC                 db    0
.rdata$r:0000EBDD                 db    0
.rdata$r:0000EBDE                 db    0
.rdata$r:0000EBDF                 db    0
.rdata$r:0000EBE0                 db 0FFh
.rdata$r:0000EBE1                 db 0FFh
.rdata$r:0000EBE2                 db 0FFh
.rdata$r:0000EBE3                 db 0FFh
.rdata$r:0000EBE4                 db    0
.rdata$r:0000EBE5                 db    0
.rdata$r:0000EBE6                 db    0
.rdata$r:0000EBE7                 db    0
.rdata$r:0000EBE8                 db  40h ; @
.rdata$r:0000EBE9                 db    0
.rdata$r:0000EBEA                 db    0
.rdata$r:0000EBEB                 db    0
.rdata$r:0000EBEC                 dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000EBEC _rdata$r        ends
.rdata$r:0000EBEC
.rdata$r:0000EBF0 ; ===========================================================================
.rdata$r:0000EBF0
.rdata$r:0000EBF0 ; Segment type: Pure data
.rdata$r:0000EBF0 ; Segment permissions: Read
.rdata$r:0000EBF0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000EBF0                 assume cs:_rdata$r
.rdata$r:0000EBF0                 ;org 0EBF0h
.rdata$r:0000EBF0 ; COMDAT (pick any)
.rdata$r:0000EBF0                 public ??_R4WindowsDlg@@6B@
.rdata$r:0000EBF0 ; const WindowsDlg::`RTTI Complete Object Locator'
.rdata$r:0000EBF0 ??_R4WindowsDlg@@6B@ db    0            ; DATA XREF: .rdata:0000DF0Co
.rdata$r:0000EBF1                 db    0
.rdata$r:0000EBF2                 db    0
.rdata$r:0000EBF3                 db    0
.rdata$r:0000EBF4                 db    0
.rdata$r:0000EBF5                 db    0
.rdata$r:0000EBF6                 db    0
.rdata$r:0000EBF7                 db    0
.rdata$r:0000EBF8                 db    0
.rdata$r:0000EBF9                 db    0
.rdata$r:0000EBFA                 db    0
.rdata$r:0000EBFB                 db    0
.rdata$r:0000EBFC                 dd offset ??_R0?AVWindowsDlg@@@8 ; WindowsDlg `RTTI Type Descriptor'
.rdata$r:0000EC00                 dd offset ??_R3WindowsDlg@@8 ; WindowsDlg::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000EC00 _rdata$r        ends
.rdata$r:0000EC00
.data$r:0000EC04 ; ===========================================================================
.data$r:0000EC04
.data$r:0000EC04 ; Segment type: Pure data
.data$r:0000EC04 ; Segment permissions: Read/Write
.data$r:0000EC04 _data$r         segment dword public 'DATA' use32
.data$r:0000EC04                 assume cs:_data$r
.data$r:0000EC04                 ;org 0EC04h
.data$r:0000EC04 ; COMDAT (pick any)
.data$r:0000EC04                 public ??_R0?AVWindowsDlg@@@8
.data$r:0000EC04 ; class WindowsDlg `RTTI Type Descriptor'
.data$r:0000EC04 ??_R0?AVWindowsDlg@@@8 dd offset ??_7type_info@@6B@
.data$r:0000EC04                                         ; DATA XREF: .rdata$r:0000EBFCo
.data$r:0000EC04                                         ; .rdata$r:WindowsDlg::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:0000EC04                                         ; const type_info::`vftable'
.data$r:0000EC08                 db    0
.data$r:0000EC09                 db    0
.data$r:0000EC0A                 db    0
.data$r:0000EC0B                 db    0
.data$r:0000EC0C                 db  2Eh ; .
.data$r:0000EC0D                 db  3Fh ; ?
.data$r:0000EC0E                 db  41h ; A
.data$r:0000EC0F                 db  56h ; V
.data$r:0000EC10                 db  57h ; W
.data$r:0000EC11                 db  69h ; i
.data$r:0000EC12                 db  6Eh ; n
.data$r:0000EC13                 db  64h ; d
.data$r:0000EC14                 db  6Fh ; o
.data$r:0000EC15                 db  77h ; w
.data$r:0000EC16                 db  73h ; s
.data$r:0000EC17                 db  44h ; D
.data$r:0000EC18                 db  6Ch ; l
.data$r:0000EC19                 db  67h ; g
.data$r:0000EC1A                 db  40h ; @
.data$r:0000EC1B                 db  40h ; @
.data$r:0000EC1C                 db    0
.data$r:0000EC1D                 align 10h
.data$r:0000EC1D _data$r         ends
.data$r:0000EC1D
.rdata$r:0000EC20 ; ===========================================================================
.rdata$r:0000EC20
.rdata$r:0000EC20 ; Segment type: Pure data
.rdata$r:0000EC20 ; Segment permissions: Read
.rdata$r:0000EC20 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000EC20                 assume cs:_rdata$r
.rdata$r:0000EC20                 ;org 0EC20h
.rdata$r:0000EC20 ; COMDAT (pick any)
.rdata$r:0000EC20                 public ??_R3WindowsDlg@@8
.rdata$r:0000EC20 ; WindowsDlg::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000EC20 ??_R3WindowsDlg@@8 db    0              ; DATA XREF: .rdata$r:0000EC00o
.rdata$r:0000EC20                                         ; .rdata$r:0000EC5Co
.rdata$r:0000EC21                 db    0
.rdata$r:0000EC22                 db    0
.rdata$r:0000EC23                 db    0
.rdata$r:0000EC24                 db    0
.rdata$r:0000EC25                 db    0
.rdata$r:0000EC26                 db    0
.rdata$r:0000EC27                 db    0
.rdata$r:0000EC28                 db    4
.rdata$r:0000EC29                 db    0
.rdata$r:0000EC2A                 db    0
.rdata$r:0000EC2B                 db    0
.rdata$r:0000EC2C                 dd offset ??_R2WindowsDlg@@8 ; WindowsDlg::`RTTI Base Class Array'
.rdata$r:0000EC2C _rdata$r        ends
.rdata$r:0000EC2C
.rdata$r:0000EC30 ; ===========================================================================
.rdata$r:0000EC30
.rdata$r:0000EC30 ; Segment type: Pure data
.rdata$r:0000EC30 ; Segment permissions: Read
.rdata$r:0000EC30 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000EC30                 assume cs:_rdata$r
.rdata$r:0000EC30                 ;org 0EC30h
.rdata$r:0000EC30 ; COMDAT (pick any)
.rdata$r:0000EC30                 public ??_R2WindowsDlg@@8
.rdata$r:0000EC30 ; WindowsDlg::`RTTI Base Class Array'
.rdata$r:0000EC30 ??_R2WindowsDlg@@8 dd offset ??_R1A@?0A@EA@WindowsDlg@@8
.rdata$r:0000EC30                                         ; DATA XREF: .rdata$r:0000EC2Co
.rdata$r:0000EC30                                         ; WindowsDlg::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000EC34                 dd offset ??_R1A@?0A@EA@SizeableDlg@@8 ; SizeableDlg::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000EC38                 dd offset ??_R1A@?0A@EA@StaticDialog@@8 ; StaticDialog::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000EC3C                 dd offset ??_R1A@?0A@EA@Window@@8 ; Window::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000EC40                 db    0
.rdata$r:0000EC41                 align 4
.rdata$r:0000EC41 _rdata$r        ends
.rdata$r:0000EC41
.rdata$r:0000EC44 ; ===========================================================================
.rdata$r:0000EC44
.rdata$r:0000EC44 ; Segment type: Pure data
.rdata$r:0000EC44 ; Segment permissions: Read
.rdata$r:0000EC44 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000EC44                 assume cs:_rdata$r
.rdata$r:0000EC44                 ;org 0EC44h
.rdata$r:0000EC44 ; COMDAT (pick any)
.rdata$r:0000EC44                 public ??_R1A@?0A@EA@WindowsDlg@@8
.rdata$r:0000EC44 ; WindowsDlg::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000EC44 ??_R1A@?0A@EA@WindowsDlg@@8 dd offset ??_R0?AVWindowsDlg@@@8
.rdata$r:0000EC44                                         ; DATA XREF: .rdata$r:WindowsDlg::`RTTI Base Class Array'o
.rdata$r:0000EC44                                         ; WindowsDlg `RTTI Type Descriptor'
.rdata$r:0000EC48                 db    3
.rdata$r:0000EC49                 db    0
.rdata$r:0000EC4A                 db    0
.rdata$r:0000EC4B                 db    0
.rdata$r:0000EC4C                 db    0
.rdata$r:0000EC4D                 db    0
.rdata$r:0000EC4E                 db    0
.rdata$r:0000EC4F                 db    0
.rdata$r:0000EC50                 db 0FFh
.rdata$r:0000EC51                 db 0FFh
.rdata$r:0000EC52                 db 0FFh
.rdata$r:0000EC53                 db 0FFh
.rdata$r:0000EC54                 db    0
.rdata$r:0000EC55                 db    0
.rdata$r:0000EC56                 db    0
.rdata$r:0000EC57                 db    0
.rdata$r:0000EC58                 db  40h ; @
.rdata$r:0000EC59                 db    0
.rdata$r:0000EC5A                 db    0
.rdata$r:0000EC5B                 db    0
.rdata$r:0000EC5C                 dd offset ??_R3WindowsDlg@@8 ; WindowsDlg::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000EC5C _rdata$r        ends
.rdata$r:0000EC5C
.rdata$r:0000EC60 ; ===========================================================================
.rdata$r:0000EC60
.rdata$r:0000EC60 ; Segment type: Pure data
.rdata$r:0000EC60 ; Segment permissions: Read
.rdata$r:0000EC60 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000EC60                 assume cs:_rdata$r
.rdata$r:0000EC60                 ;org 0EC60h
.rdata$r:0000EC60 ; COMDAT (pick any)
.rdata$r:0000EC60                 public ??_R1A@?0A@EA@SizeableDlg@@8
.rdata$r:0000EC60 ; SizeableDlg::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000EC60 ??_R1A@?0A@EA@SizeableDlg@@8 dd offset ??_R0?AVSizeableDlg@@@8
.rdata$r:0000EC60                                         ; DATA XREF: .rdata$r:0000EC34o
.rdata$r:0000EC60                                         ; .rdata$r:SizeableDlg::`RTTI Base Class Array'o
.rdata$r:0000EC60                                         ; SizeableDlg `RTTI Type Descriptor'
.rdata$r:0000EC64                 db    2
.rdata$r:0000EC65                 db    0
.rdata$r:0000EC66                 db    0
.rdata$r:0000EC67                 db    0
.rdata$r:0000EC68                 db    0
.rdata$r:0000EC69                 db    0
.rdata$r:0000EC6A                 db    0
.rdata$r:0000EC6B                 db    0
.rdata$r:0000EC6C                 db 0FFh
.rdata$r:0000EC6D                 db 0FFh
.rdata$r:0000EC6E                 db 0FFh
.rdata$r:0000EC6F                 db 0FFh
.rdata$r:0000EC70                 db    0
.rdata$r:0000EC71                 db    0
.rdata$r:0000EC72                 db    0
.rdata$r:0000EC73                 db    0
.rdata$r:0000EC74                 db  40h ; @
.rdata$r:0000EC75                 db    0
.rdata$r:0000EC76                 db    0
.rdata$r:0000EC77                 db    0
.rdata$r:0000EC78                 dd offset ??_R3SizeableDlg@@8 ; SizeableDlg::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000EC78 _rdata$r        ends
.rdata$r:0000EC78
.data$r:0000EC7C ; ===========================================================================
.data$r:0000EC7C
.data$r:0000EC7C ; Segment type: Pure data
.data$r:0000EC7C ; Segment permissions: Read/Write
.data$r:0000EC7C _data$r         segment dword public 'DATA' use32
.data$r:0000EC7C                 assume cs:_data$r
.data$r:0000EC7C                 ;org 0EC7Ch
.data$r:0000EC7C ; COMDAT (pick any)
.data$r:0000EC7C                 public ??_R0?AVSizeableDlg@@@8
.data$r:0000EC7C ; class SizeableDlg `RTTI Type Descriptor'
.data$r:0000EC7C ??_R0?AVSizeableDlg@@@8 dd offset ??_7type_info@@6B@
.data$r:0000EC7C                                         ; DATA XREF: .rdata$r:SizeableDlg::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:0000EC7C                                         ; const type_info::`vftable'
.data$r:0000EC80                 db    0
.data$r:0000EC81                 db    0
.data$r:0000EC82                 db    0
.data$r:0000EC83                 db    0
.data$r:0000EC84                 db  2Eh ; .
.data$r:0000EC85                 db  3Fh ; ?
.data$r:0000EC86                 db  41h ; A
.data$r:0000EC87                 db  56h ; V
.data$r:0000EC88                 db  53h ; S
.data$r:0000EC89                 db  69h ; i
.data$r:0000EC8A                 db  7Ah ; z
.data$r:0000EC8B                 db  65h ; e
.data$r:0000EC8C                 db  61h ; a
.data$r:0000EC8D                 db  62h ; b
.data$r:0000EC8E                 db  6Ch ; l
.data$r:0000EC8F                 db  65h ; e
.data$r:0000EC90                 db  44h ; D
.data$r:0000EC91                 db  6Ch ; l
.data$r:0000EC92                 db  67h ; g
.data$r:0000EC93                 db  40h ; @
.data$r:0000EC94                 db  40h ; @
.data$r:0000EC95                 db    0
.data$r:0000EC96                 align 4
.data$r:0000EC96 _data$r         ends
.data$r:0000EC96
.rdata$r:0000EC98 ; ===========================================================================
.rdata$r:0000EC98
.rdata$r:0000EC98 ; Segment type: Pure data
.rdata$r:0000EC98 ; Segment permissions: Read
.rdata$r:0000EC98 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000EC98                 assume cs:_rdata$r
.rdata$r:0000EC98                 ;org 0EC98h
.rdata$r:0000EC98 ; COMDAT (pick any)
.rdata$r:0000EC98                 public ??_R3SizeableDlg@@8
.rdata$r:0000EC98 ; SizeableDlg::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000EC98 ??_R3SizeableDlg@@8 db    0             ; DATA XREF: .rdata$r:0000EC78o
.rdata$r:0000EC99                 db    0
.rdata$r:0000EC9A                 db    0
.rdata$r:0000EC9B                 db    0
.rdata$r:0000EC9C                 db    0
.rdata$r:0000EC9D                 db    0
.rdata$r:0000EC9E                 db    0
.rdata$r:0000EC9F                 db    0
.rdata$r:0000ECA0                 db    3
.rdata$r:0000ECA1                 db    0
.rdata$r:0000ECA2                 db    0
.rdata$r:0000ECA3                 db    0
.rdata$r:0000ECA4                 dd offset ??_R2SizeableDlg@@8 ; SizeableDlg::`RTTI Base Class Array'
.rdata$r:0000ECA4 _rdata$r        ends
.rdata$r:0000ECA4
.rdata$r:0000ECA8 ; ===========================================================================
.rdata$r:0000ECA8
.rdata$r:0000ECA8 ; Segment type: Pure data
.rdata$r:0000ECA8 ; Segment permissions: Read
.rdata$r:0000ECA8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000ECA8                 assume cs:_rdata$r
.rdata$r:0000ECA8                 ;org 0ECA8h
.rdata$r:0000ECA8 ; COMDAT (pick any)
.rdata$r:0000ECA8                 public ??_R2SizeableDlg@@8
.rdata$r:0000ECA8 ; SizeableDlg::`RTTI Base Class Array'
.rdata$r:0000ECA8 ??_R2SizeableDlg@@8 dd offset ??_R1A@?0A@EA@SizeableDlg@@8
.rdata$r:0000ECA8                                         ; DATA XREF: .rdata$r:0000ECA4o
.rdata$r:0000ECA8                                         ; SizeableDlg::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000ECAC                 dd offset ??_R1A@?0A@EA@StaticDialog@@8 ; StaticDialog::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000ECB0                 dd offset ??_R1A@?0A@EA@Window@@8 ; Window::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000ECB4                 db    0
.rdata$r:0000ECB5                 align 4
.rdata$r:0000ECB5 _rdata$r        ends
.rdata$r:0000ECB5
.CRT$XCU:0000ECB8 ; ===========================================================================
.CRT$XCU:0000ECB8
.CRT$XCU:0000ECB8 ; Segment type: Pure data
.CRT$XCU:0000ECB8 ; Segment permissions: Read
.CRT$XCU:0000ECB8 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0000ECB8                 assume cs:_CRT$XCU
.CRT$XCU:0000ECB8                 ;org 0ECB8h
.CRT$XCU:0000ECB8 _piecewise_construct$initializer$ dd offset ??__Epiecewise_construct@std@@YAXXZ ; std::`dynamic initializer for 'piecewise_construct''(void)
.CRT$XCU:0000ECBC _allocator_arg$initializer$ dd offset ??__Eallocator_arg@std@@YAXXZ ; std::`dynamic initializer for 'allocator_arg''(void)
.CRT$XCU:0000ECC0 _ignore$initializer$ dd offset ??__Eignore@std@@YAXXZ ; std::`dynamic initializer for 'ignore''(void)
.CRT$XCU:0000ECC4 __Tuple_alloc$initializer$ dd offset ??__E_Tuple_alloc@std@@YAXXZ ; std::`dynamic initializer for '_Tuple_alloc''(void)
.CRT$XCU:0000ECC8 _WDN_NOTIFY$initializer$ dd offset ??__EWDN_NOTIFY@@YAXXZ ; `dynamic initializer for 'WDN_NOTIFY''(void)
.CRT$XCU:0000ECCC _WindowsDlgMap$initializer$ dd offset ??__EWindowsDlgMap@@YAXXZ ; `dynamic initializer for 'WindowsDlgMap''(void)
.CRT$XCU:0000ECCC _CRT$XCU        ends
.CRT$XCU:0000ECCC
.CRT$XCU:0000ECD0 ; ===========================================================================
.CRT$XCU:0000ECD0
.CRT$XCU:0000ECD0 ; Segment type: Pure data
.CRT$XCU:0000ECD0 ; Segment permissions: Read
.CRT$XCU:0000ECD0 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0000ECD0                 assume cs:_CRT$XCU
.CRT$XCU:0000ECD0                 ;org 0ECD0h
.CRT$XCU:0000ECD0 ; COMDAT (pick associative to section at DEF4)
.CRT$XCU:0000ECD0 ; public: static void (__cdecl *std::_Error_objects<int>::_Generic_object$initializer$)(void)
.CRT$XCU:0000ECD0 ?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
.CRT$XCU:0000ECD0 _CRT$XCU        ends
.CRT$XCU:0000ECD0
.CRT$XCU:0000ECD4 ; ===========================================================================
.CRT$XCU:0000ECD4
.CRT$XCU:0000ECD4 ; Segment type: Pure data
.CRT$XCU:0000ECD4 ; Segment permissions: Read
.CRT$XCU:0000ECD4 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0000ECD4                 assume cs:_CRT$XCU
.CRT$XCU:0000ECD4                 ;org 0ECD4h
.CRT$XCU:0000ECD4 ; COMDAT (pick associative to section at DEF8)
.CRT$XCU:0000ECD4 ; public: static void (__cdecl *std::_Error_objects<int>::_Iostream_object$initializer$)(void)
.CRT$XCU:0000ECD4 ?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
.CRT$XCU:0000ECD4 _CRT$XCU        ends
.CRT$XCU:0000ECD4
.CRT$XCU:0000ECD8 ; ===========================================================================
.CRT$XCU:0000ECD8
.CRT$XCU:0000ECD8 ; Segment type: Pure data
.CRT$XCU:0000ECD8 ; Segment permissions: Read
.CRT$XCU:0000ECD8 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0000ECD8                 assume cs:_CRT$XCU
.CRT$XCU:0000ECD8                 ;org 0ECD8h
.CRT$XCU:0000ECD8 ; COMDAT (pick associative to section at DEFC)
.CRT$XCU:0000ECD8 ; public: static void (__cdecl *std::_Error_objects<int>::_System_object$initializer$)(void)
.CRT$XCU:0000ECD8 ?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)
.CRT$XCU:0000ECD8 _CRT$XCU        ends
.CRT$XCU:0000ECD8
.CRT$XCU:0000ECDC ; ===========================================================================
.CRT$XCU:0000ECDC
.CRT$XCU:0000ECDC ; Segment type: Pure data
.CRT$XCU:0000ECDC ; Segment permissions: Read
.CRT$XCU:0000ECDC _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0000ECDC                 assume cs:_CRT$XCU
.CRT$XCU:0000ECDC                 ;org 0ECDCh
.CRT$XCU:0000ECDC ; COMDAT (pick associative to section at DF04)
.CRT$XCU:0000ECDC ; public: static void (__cdecl *std::num_put<char, class std::back_insert_iterator<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>::id$initializer$)(void)
.CRT$XCU:0000ECDC ?id$initializer$@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2P6AXXZA dd offset ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)
.CRT$XCU:0000ECDC _CRT$XCU        ends
.CRT$XCU:0000ECDC
.CRT$XCU:0000ECE0 ; ===========================================================================
.CRT$XCU:0000ECE0
.CRT$XCU:0000ECE0 ; Segment type: Pure data
.CRT$XCU:0000ECE0 ; Segment permissions: Read
.CRT$XCU:0000ECE0 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0000ECE0                 assume cs:_CRT$XCU
.CRT$XCU:0000ECE0                 ;org 0ECE0h
.CRT$XCU:0000ECE0 ; COMDAT (pick associative to section at DF08)
.CRT$XCU:0000ECE0 ; public: static void (__cdecl *std::num_put<wchar_t, class std::back_insert_iterator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::id$initializer$)(void)
.CRT$XCU:0000ECE0 ?id$initializer$@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2P6AXXZA dd offset ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)
.CRT$XCU:0000ECE0 _CRT$XCU        ends
.CRT$XCU:0000ECE0
.CRT$XCU:0000ECE4 ; ===========================================================================
.CRT$XCU:0000ECE4
.CRT$XCU:0000ECE4 ; Segment type: Pure data
.CRT$XCU:0000ECE4 ; Segment permissions: Read
.CRT$XCU:0000ECE4 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0000ECE4                 assume cs:_CRT$XCU
.CRT$XCU:0000ECE4                 ;org 0ECE4h
.CRT$XCU:0000ECE4 ; COMDAT (pick associative to section at DFF0)
.CRT$XCU:0000ECE4 ; public: static void (__cdecl *std::numpunct<char>::id$initializer$)(void)
.CRT$XCU:0000ECE4 ?id$initializer$@?$numpunct@D@std@@2P6AXXZA dd offset ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::numpunct<char>::id''(void)
.CRT$XCU:0000ECE4 _CRT$XCU        ends
.CRT$XCU:0000ECE4
.CRT$XCU:0000ECE8 ; ===========================================================================
.CRT$XCU:0000ECE8
.CRT$XCU:0000ECE8 ; Segment type: Pure data
.CRT$XCU:0000ECE8 ; Segment permissions: Read
.CRT$XCU:0000ECE8 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0000ECE8                 assume cs:_CRT$XCU
.CRT$XCU:0000ECE8                 ;org 0ECE8h
.CRT$XCU:0000ECE8 ; COMDAT (pick associative to section at DFF4)
.CRT$XCU:0000ECE8 ; public: static void (__cdecl *std::numpunct<wchar_t>::id$initializer$)(void)
.CRT$XCU:0000ECE8 ?id$initializer$@?$numpunct@_W@std@@2P6AXXZA dd offset ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::numpunct<wchar_t>::id''(void)
.CRT$XCU:0000ECE8 _CRT$XCU        ends
.CRT$XCU:0000ECE8
UNDEF:0000ECF0 ; ===========================================================================
UNDEF:0000ECF0
UNDEF:0000ECF0 ; Segment type: Externs
UNDEF:0000ECF0 ; UNDEF
UNDEF:0000ECF0                 extrn __purecall:near   ; DATA XREF: .rdata:0000DDD8o
UNDEF:0000ECF0                                         ; .rdata:0000DE3Co ...
UNDEF:0000ECF4 ; void *__cdecl operator new(unsigned int)
UNDEF:0000ECF4                 extrn ??2@YAPAXI@Z:near ; CODE XREF: std::_Allocate<char>(uint,char *)+1Dp
UNDEF:0000ECF4                                         ; std::_Allocate<int>(uint,int *)+23p ...
UNDEF:0000ECF8 ; void __cdecl operator delete(void *)
UNDEF:0000ECF8                 extrn ??3@YAXPAX@Z:near ; CODE XREF: std::return_temporary_buffer<int>(int *)+7p
UNDEF:0000ECF8                                         ; StaticDialog::`scalar deleting destructor'(uint)+1Bp ...
UNDEF:0000ECFC ; int __cdecl atexit(void (__cdecl *)())
UNDEF:0000ECFC                 extrn _atexit:near      ; CODE XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+12p
UNDEF:0000ECFC                                         ; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+12p ...
UNDEF:0000ED00                 extrn __invalid_parameter:near
UNDEF:0000ED00                                         ; CODE XREF: std::vector<int,std::allocator<int>>::operator[](uint)+74p
UNDEF:0000ED00                                         ; std::vector<wchar_t,std::allocator<wchar_t>>::operator[](uint)+74p ...
UNDEF:0000ED04 ; _DWORD __thiscall std::_Lockit::_Lockit(std::_Lockit *__hidden this, int)
UNDEF:0000ED04                 extrn ??0_Lockit@std@@QAE@H@Z:near
UNDEF:0000ED04                                         ; CODE XREF: std::_Iterator_base12::~_Iterator_base12(void)+2Dp
UNDEF:0000ED04                                         ; std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+55p ...
UNDEF:0000ED08 ; _DWORD __thiscall std::_Lockit::~_Lockit(std::_Lockit *__hidden this)
UNDEF:0000ED08                 extrn ??1_Lockit@std@@QAE@XZ:near
UNDEF:0000ED08                                         ; CODE XREF: std::_Iterator_base12::~_Iterator_base12(void)+4Bp
UNDEF:0000ED08                                         ; __unwindfunclet$??1_Iterator_base12@std@@QAE@XZ$0+3j ...
UNDEF:0000ED0C ; __int32 __cdecl wcstol(const wchar_t *Str, wchar_t **EndPtr, int Radix)
UNDEF:0000ED0C                 extrn _wcstol:near      ; CODE XREF: NumericStringEquivalence::numstrcmp(wchar_t const *,wchar_t const *)+78p
UNDEF:0000ED0C                                         ; NumericStringEquivalence::numstrcmp(wchar_t const *,wchar_t const *)+8Cp
UNDEF:0000ED10                 extrn __hypot:near      ; CODE XREF: _hypot+1Dp
UNDEF:0000ED14 ; int __cdecl iswupper(wint_t C)
UNDEF:0000ED14                 extrn _iswupper:near    ; CODE XREF: NumericStringEquivalence::numstrcmp(wchar_t const *,wchar_t const *)+E6p
UNDEF:0000ED14                                         ; NumericStringEquivalence::numstrcmp(wchar_t const *,wchar_t const *)+12Cp
UNDEF:0000ED18 ; int __cdecl iswdigit(wint_t C)
UNDEF:0000ED18                 extrn _iswdigit:near    ; CODE XREF: NumericStringEquivalence::numstrcmp(wchar_t const *,wchar_t const *)+4Fp
UNDEF:0000ED18                                         ; NumericStringEquivalence::numstrcmp(wchar_t const *,wchar_t const *)+62p
UNDEF:0000ED1C ; int __cdecl iswascii(wint_t C)
UNDEF:0000ED1C                 extrn _iswascii:near    ; CODE XREF: NumericStringEquivalence::numstrcmp(wchar_t const *,wchar_t const *)+D3p
UNDEF:0000ED1C                                         ; NumericStringEquivalence::numstrcmp(wchar_t const *,wchar_t const *)+119p
UNDEF:0000ED20 ; wint_t __cdecl towlower(wint_t C)
UNDEF:0000ED20                 extrn _towlower:near    ; CODE XREF: NumericStringEquivalence::numstrcmp(wchar_t const *,wchar_t const *)+F9p
UNDEF:0000ED20                                         ; NumericStringEquivalence::numstrcmp(wchar_t const *,wchar_t const *)+13Fp
UNDEF:0000ED24 ; size_t __cdecl wcslen(const wchar_t *Str)
UNDEF:0000ED24                 extrn _wcslen:near      ; CODE XREF: std::char_traits<wchar_t>::length(wchar_t const *)+1Bp
UNDEF:0000ED28 ; wchar_t *__cdecl wcsncpy(wchar_t *Dest, const wchar_t *Source, size_t Count)
UNDEF:0000ED28                 extrn _wcsncpy:near     ; CODE XREF: WindowsDlg::run_dlgProc(uint,uint,long)+231p
UNDEF:0000ED28                                         ; WindowsDlg::run_dlgProc(uint,uint,long)+359p ...
UNDEF:0000ED2C ; void *__cdecl memmove(void *Dst, const void *Src, size_t Size)
UNDEF:0000ED2C                 extrn _memmove:near     ; CODE XREF: std::_Move<int *,int *>(int *,int *,int *,std::_Scalar_ptr_iterator_tag)+1Fp
UNDEF:0000ED2C                                         ; std::_Move_backward<int *,int *>(int *,int *,int *,std::_Scalar_ptr_iterator_tag)+27p ...
UNDEF:0000ED30 ; void *__cdecl memcpy(void *Dst, const void *Src, size_t Size)
UNDEF:0000ED30                 extrn _memcpy:near      ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+1Ep
UNDEF:0000ED30                                         ; _wmemcpy+11p
UNDEF:0000ED34 ; void *__cdecl memset(void *Dst, int Val, size_t Size)
UNDEF:0000ED34                 extrn _memset:near      ; CODE XREF: WindowsDlg::onInitDialog(void)+145p
UNDEF:0000ED34                                         ; WindowsMenu::init(HINSTANCE__ *,HMENU__ *,wchar_t const *)+FCp ...
UNDEF:0000ED38 ; size_t __cdecl strlen(const char *Str)
UNDEF:0000ED38                 extrn _strlen:near      ; CODE XREF: std::char_traits<char>::length(char const *)+1Bp
UNDEF:0000ED3C ; void __cdecl operator delete[](void *)
UNDEF:0000ED3C                 extrn ??_V@YAXPAX@Z:near
UNDEF:0000ED3C                                         ; CODE XREF: WindowsDlg::doSave(void)+FDp
UNDEF:0000ED3C                                         ; WindowsDlg::doClose(void)+43Ap ...
UNDEF:0000ED40 ; void *__cdecl operator new[](unsigned int)
UNDEF:0000ED40                 extrn ??_U@YAPAXI@Z:near
UNDEF:0000ED40                                         ; CODE XREF: WindowsDlg::doSave(void)+70p
UNDEF:0000ED40                                         ; WindowsDlg::doClose(void)+C0p ...
UNDEF:0000ED44 ; void *__cdecl operator new(unsigned int, const struct std::nothrow_t *)
UNDEF:0000ED44                 extrn ??2@YAPAXIABUnothrow_t@std@@@Z:near
UNDEF:0000ED44                                         ; CODE XREF: std::get_temporary_buffer<int>(int)+47p
UNDEF:0000ED48                 extrn __CrtDbgReportW:near
UNDEF:0000ED48                                         ; CODE XREF: std::vector<int,std::allocator<int>>::operator[](uint)+50p
UNDEF:0000ED48                                         ; std::vector<wchar_t,std::allocator<wchar_t>>::operator[](uint)+50p ...
UNDEF:0000ED4C ; void __cdecl std::_Debug_message(const wchar_t *, const wchar_t *, unsigned int)
UNDEF:0000ED4C                 extrn ?_Debug_message@std@@YAXPB_W0I@Z:near
UNDEF:0000ED4C                                         ; CODE XREF: std::_Debug_lt_pred<BufferEquivalent,int &,int &>(BufferEquivalent,int &,int &,wchar_t const *,uint)+70p
UNDEF:0000ED4C                                         ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+16p ...
UNDEF:0000ED50 ; void __cdecl std::_Xbad_alloc()
UNDEF:0000ED50                 extrn ?_Xbad_alloc@std@@YAXXZ:near
UNDEF:0000ED50                                         ; CODE XREF: std::_Allocate<char>(uint,char *):loc_276Ep
UNDEF:0000ED50                                         ; std::_Allocate<int>(uint,int *):loc_27B0p ...
UNDEF:0000ED54 ; void __cdecl std::_Xlength_error(const char *)
UNDEF:0000ED54                 extrn ?_Xlength_error@std@@YAXPBD@Z:near
UNDEF:0000ED54                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+Cp
UNDEF:0000ED54                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xlen(void)+Cp ...
UNDEF:0000ED58 ; void __cdecl std::_Xout_of_range(const char *)
UNDEF:0000ED58                 extrn ?_Xout_of_range@std@@YAXPBD@Z:near
UNDEF:0000ED58                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+Cp
UNDEF:0000ED58                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)+Cp
UNDEF:0000ED5C ; void __cdecl _wassert(const wchar_t *Message, const wchar_t *File, unsigned int Line)
UNDEF:0000ED5C                 extrn __wassert:near    ; CODE XREF: WindowsDlg::init(HINSTANCE__ *,HWND__ *)+1Fp
UNDEF:0000ED5C                                         ; CWinMgr::CalcLayout(HWND__ *)+28p ...
UNDEF:0000ED60 ; int __stdcall LoadStringW(HINSTANCE hInstance, UINT uID, LPWSTR lpBuffer, int cchBufferMax)
UNDEF:0000ED60                 extrn __imp__LoadStringW@16:near
UNDEF:0000ED60                                         ; CODE XREF: WindowsMenu::init(HINSTANCE__ *,HMENU__ *,wchar_t const *)+127p
UNDEF:0000ED60                                         ; DATA XREF: WindowsMenu::init(HINSTANCE__ *,HMENU__ *,wchar_t const *)+127r
UNDEF:0000ED64 ; LPWSTR __stdcall lstrcatW(LPWSTR lpString1, LPCWSTR lpString2)
UNDEF:0000ED64                 extrn __imp__lstrcatW@8:near
UNDEF:0000ED64                                         ; CODE XREF: WindowsDlg::run_dlgProc(uint,uint,long)+2DAp
UNDEF:0000ED64                                         ; DATA XREF: WindowsDlg::run_dlgProc(uint,uint,long)+2DAr
UNDEF:0000ED68 ; int __stdcall lstrlenW(LPCWSTR lpString)
UNDEF:0000ED68                 extrn __imp__lstrlenW@4:near
UNDEF:0000ED68                                         ; CODE XREF: WindowsDlg::run_dlgProc(uint,uint,long)+250p
UNDEF:0000ED68                                         ; WindowsDlg::run_dlgProc(uint,uint,long)+2B5p ...
UNDEF:0000ED6C ; UINT __stdcall RegisterWindowMessageW(LPCWSTR lpString)
UNDEF:0000ED6C                 extrn __imp__RegisterWindowMessageW@4:near
UNDEF:0000ED6C                                         ; CODE XREF: `dynamic initializer for 'WDN_NOTIFY''(void)+8p
UNDEF:0000ED6C                                         ; DATA XREF: `dynamic initializer for 'WDN_NOTIFY''(void)+8r
UNDEF:0000ED70 ; LRESULT __stdcall SendMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
UNDEF:0000ED70                 extrn __imp__SendMessageW@16:near
UNDEF:0000ED70                                         ; CODE XREF: WindowsDlg::doRefresh(bool)+111p
UNDEF:0000ED70                                         ; WindowsDlg::run_dlgProc(uint,uint,long)+481p ...
UNDEF:0000ED74 ; BOOL __stdcall PostMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
UNDEF:0000ED74                 extrn __imp__PostMessageW@16:near
UNDEF:0000ED74                                         ; CODE XREF: WindowsDlg::run_dlgProc(uint,uint,long)+649p
UNDEF:0000ED74                                         ; DATA XREF: WindowsDlg::run_dlgProc(uint,uint,long)+649r
UNDEF:0000ED78 ; BOOL __stdcall DestroyWindow(HWND hWnd)
UNDEF:0000ED78                 extrn __imp__DestroyWindow@4:near
UNDEF:0000ED78                                         ; CODE XREF: WindowsDlg::destroy(void)+32p
UNDEF:0000ED78                                         ; StaticDialog::destroy(void)+29p
UNDEF:0000ED78                                         ; DATA XREF: ...
UNDEF:0000ED7C ; BOOL __stdcall ShowWindow(HWND hWnd, int nCmdShow)
UNDEF:0000ED7C                 extrn __imp__ShowWindow@8:near
UNDEF:0000ED7C                                         ; CODE XREF: Window::display(bool)+2Cp
UNDEF:0000ED7C                                         ; DATA XREF: Window::display(bool)+2Cr
UNDEF:0000ED80 ; BOOL __stdcall MoveWindow(HWND hWnd, int X, int Y, int nWidth, int nHeight, BOOL bRepaint)
UNDEF:0000ED80                 extrn __imp__MoveWindow@24:near
UNDEF:0000ED80                                         ; CODE XREF: Window::reSizeTo(tagRECT &)+2Bp
UNDEF:0000ED80                                         ; Window::reSizeToWH(tagRECT &)+36p
UNDEF:0000ED80                                         ; DATA XREF: ...
UNDEF:0000ED84 ; BOOL __stdcall SetWindowPos(HWND hWnd, HWND hWndInsertAfter, int X, int Y, int cx, int cy, UINT uFlags)
UNDEF:0000ED84                 extrn __imp__SetWindowPos@28:near
UNDEF:0000ED84                                         ; CODE XREF: WindowsDlg::onInitDialog(void)+228p
UNDEF:0000ED84                                         ; DATA XREF: WindowsDlg::onInitDialog(void)+228r
UNDEF:0000ED88 ; BOOL __stdcall IsWindowVisible(HWND hWnd)
UNDEF:0000ED88                 extrn __imp__IsWindowVisible@4:near
UNDEF:0000ED88                                         ; CODE XREF: Window::getHeight(void)+2Bp
UNDEF:0000ED88                                         ; Window::isVisible(void)+10p
UNDEF:0000ED88                                         ; DATA XREF: ...
UNDEF:0000ED8C ; INT_PTR __stdcall DialogBoxParamW(HINSTANCE hInstance, LPCWSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
UNDEF:0000ED8C                 extrn __imp__DialogBoxParamW@20:near
UNDEF:0000ED8C                                         ; CODE XREF: WindowsDlg::doDialog(TiXmlNodeA *)+2Cp
UNDEF:0000ED8C                                         ; DATA XREF: WindowsDlg::doDialog(TiXmlNodeA *)+2Cr
UNDEF:0000ED90 ; BOOL __stdcall EndDialog(HWND hDlg, INT_PTR nResult)
UNDEF:0000ED90                 extrn __imp__EndDialog@8:near
UNDEF:0000ED90                                         ; CODE XREF: WindowsDlg::run_dlgProc(uint,uint,long)+F4p
UNDEF:0000ED90                                         ; WindowsDlg::activateCurrent(void)+A4p
UNDEF:0000ED90                                         ; DATA XREF: ...
UNDEF:0000ED94 ; HWND __stdcall GetDlgItem(HWND hDlg, int nIDDlgItem)
UNDEF:0000ED94                 extrn __imp__GetDlgItem@8:near
UNDEF:0000ED94                                         ; CODE XREF: WindowsDlg::changeDlgLang(void)+151p
UNDEF:0000ED94                                         ; WindowsDlg::onInitDialog(void)+DAp ...
UNDEF:0000ED98 ; SHORT __stdcall GetKeyState(int nVirtKey)
UNDEF:0000ED98                 extrn __imp__GetKeyState@4:near
UNDEF:0000ED98                                         ; CODE XREF: WindowsDlg::run_dlgProc(uint,uint,long)+676p
UNDEF:0000ED98                                         ; WindowsDlg::run_dlgProc(uint,uint,long)+682p ...
UNDEF:0000ED9C ; BOOL __stdcall EnableWindow(HWND hWnd, BOOL bEnable)
UNDEF:0000ED9C                 extrn __imp__EnableWindow@8:near
UNDEF:0000ED9C                                         ; CODE XREF: WindowsDlg::updateButtonState(void)+3Ap
UNDEF:0000ED9C                                         ; WindowsDlg::updateButtonState(void)+55p ...
UNDEF:0000EDA0 ; int __stdcall GetSystemMetrics(int nIndex)
UNDEF:0000EDA0                 extrn __imp__GetSystemMetrics@4:near
UNDEF:0000EDA0                                         ; CODE XREF: WindowsDlg::fitColumnsToSize(void)+6Fp
UNDEF:0000EDA0                                         ; DATA XREF: WindowsDlg::fitColumnsToSize(void)+6Fr
UNDEF:0000EDA4 ; HMENU __stdcall LoadMenuW(HINSTANCE hInstance, LPCWSTR lpMenuName)
UNDEF:0000EDA4                 extrn __imp__LoadMenuW@8:near
UNDEF:0000EDA4                                         ; CODE XREF: WindowsMenu::init(HINSTANCE__ *,HMENU__ *,wchar_t const *)+37p
UNDEF:0000EDA4                                         ; DATA XREF: WindowsMenu::init(HINSTANCE__ *,HMENU__ *,wchar_t const *)+37r
UNDEF:0000EDA8 ; UINT __stdcall GetMenuState(HMENU hMenu, UINT uId, UINT uFlags)
UNDEF:0000EDA8                 extrn __imp__GetMenuState@12:near
UNDEF:0000EDA8                                         ; CODE XREF: WindowsMenu::init(HINSTANCE__ *,HMENU__ *,wchar_t const *)+E0p
UNDEF:0000EDA8                                         ; WindowsMenu::initPopupMenu(HMENU__ *,DocTabView *)+1EBp
UNDEF:0000EDA8                                         ; DATA XREF: ...
UNDEF:0000EDAC ; BOOL __stdcall DestroyMenu(HMENU hMenu)
UNDEF:0000EDAC                 extrn __imp__DestroyMenu@4:near
UNDEF:0000EDAC                                         ; CODE XREF: WindowsMenu::~WindowsMenu(void)+15p
UNDEF:0000EDAC                                         ; DATA XREF: WindowsMenu::~WindowsMenu(void)+15r
UNDEF:0000EDB0 ; int __stdcall GetMenuItemCount(HMENU hMenu)
UNDEF:0000EDB0                 extrn __imp__GetMenuItemCount@4:near
UNDEF:0000EDB0                                         ; CODE XREF: WindowsMenu::init(HINSTANCE__ *,HMENU__ *,wchar_t const *)+B6p
UNDEF:0000EDB0                                         ; DATA XREF: WindowsMenu::init(HINSTANCE__ *,HMENU__ *,wchar_t const *)+B6r
UNDEF:0000EDB4 ; BOOL __stdcall ModifyMenuW(HMENU hMnu, UINT uPosition, UINT uFlags, UINT_PTR uIDNewItem, LPCWSTR lpNewItem)
UNDEF:0000EDB4                 extrn __imp__ModifyMenuW@20:near
UNDEF:0000EDB4                                         ; CODE XREF: WindowsMenu::init(HINSTANCE__ *,HMENU__ *,wchar_t const *)+96p
UNDEF:0000EDB4                                         ; DATA XREF: WindowsMenu::init(HINSTANCE__ *,HMENU__ *,wchar_t const *)+96r
UNDEF:0000EDB8 ; BOOL __stdcall DeleteMenu(HMENU hMenu, UINT uPosition, UINT uFlags)
UNDEF:0000EDB8                 extrn __imp__DeleteMenu@12:near
UNDEF:0000EDB8                                         ; CODE XREF: WindowsMenu::initPopupMenu(HMENU__ *,DocTabView *)+26Cp
UNDEF:0000EDB8                                         ; DATA XREF: WindowsMenu::initPopupMenu(HMENU__ *,DocTabView *)+26Cr
UNDEF:0000EDBC ; BOOL __stdcall InsertMenuItemW(HMENU hmenu, UINT item, BOOL fByPosition, LPCMENUITEMINFOW lpmi)
UNDEF:0000EDBC                 extrn __imp__InsertMenuItemW@16:near
UNDEF:0000EDBC                                         ; CODE XREF: WindowsMenu::init(HINSTANCE__ *,HMENU__ *,wchar_t const *)+179p
UNDEF:0000EDBC                                         ; WindowsMenu::initPopupMenu(HMENU__ *,DocTabView *)+20Cp
UNDEF:0000EDBC                                         ; DATA XREF: ...
UNDEF:0000EDC0 ; BOOL __stdcall SetMenuItemInfoW(HMENU hmenu, UINT item, BOOL fByPositon, LPCMENUITEMINFOW lpmii)
UNDEF:0000EDC0                 extrn __imp__SetMenuItemInfoW@16:near
UNDEF:0000EDC0                                         ; CODE XREF: WindowsMenu::initPopupMenu(HMENU__ *,DocTabView *)+225p
UNDEF:0000EDC0                                         ; DATA XREF: WindowsMenu::initPopupMenu(HMENU__ *,DocTabView *)+225r
UNDEF:0000EDC4 ; BOOL __stdcall UpdateWindow(HWND hWnd)
UNDEF:0000EDC4                 extrn __imp__UpdateWindow@4:near
UNDEF:0000EDC4                                         ; CODE XREF: Window::redraw(bool)+27p
UNDEF:0000EDC4                                         ; DATA XREF: Window::redraw(bool)+27r
UNDEF:0000EDC8 ; BOOL __stdcall InvalidateRect(HWND hWnd, const RECT *lpRect, BOOL bErase)
UNDEF:0000EDC8                 extrn __imp__InvalidateRect@12:near
UNDEF:0000EDC8                                         ; CODE XREF: WindowsDlg::doRefresh(bool)+127p
UNDEF:0000EDC8                                         ; WindowsDlg::run_dlgProc(uint,uint,long)+5C8p ...
UNDEF:0000EDCC ; BOOL __stdcall SetWindowTextW(HWND hWnd, LPCWSTR lpString)
UNDEF:0000EDCC                 extrn __imp__SetWindowTextW@8:near
UNDEF:0000EDCC                                         ; CODE XREF: WindowsDlg::changeDlgLang(void)+C3p
UNDEF:0000EDCC                                         ; WindowsDlg::changeDlgLang(void)+181p
UNDEF:0000EDCC                                         ; DATA XREF: ...
UNDEF:0000EDD0 ; BOOL __stdcall GetClientRect(HWND hWnd, LPRECT lpRect)
UNDEF:0000EDD0                 extrn __imp__GetClientRect@8:near
UNDEF:0000EDD0                                         ; CODE XREF: WindowsDlg::onInitDialog(void)+12Ep
UNDEF:0000EDD0                                         ; WindowsDlg::fitColumnsToSize(void)+1Ep ...
UNDEF:0000EDD4 ; BOOL __stdcall GetWindowRect(HWND hWnd, LPRECT lpRect)
UNDEF:0000EDD4                 extrn __imp__GetWindowRect@8:near
UNDEF:0000EDD4                                         ; CODE XREF: WindowsDlg::run_dlgProc(uint,uint,long)+E5p
UNDEF:0000EDD4                                         ; WindowsDlg::destroy(void)+15p ...
UNDEF:0000EDD8 ; LONG __stdcall SetWindowLongW(HWND hWnd, int nIndex, LONG dwNewLong)
UNDEF:0000EDD8                 extrn __imp__SetWindowLongW@12:near
UNDEF:0000EDD8                                         ; CODE XREF: StaticDialog::~StaticDialog(void)+50p
UNDEF:0000EDD8                                         ; DATA XREF: StaticDialog::~StaticDialog(void)+50r
UNDEF:0000EDDC ; public: __thiscall WINRECT::WINRECT(unsigned short, int, long)
UNDEF:0000EDDC                 extrn ??0WINRECT@@QAE@GHJ@Z:near
UNDEF:0000EDDC                                         ; CODE XREF: `dynamic initializer for 'WindowsDlgMap''(void)+11p
UNDEF:0000EDDC                                         ; `dynamic initializer for 'WindowsDlgMap''(void)+21p ...
UNDEF:0000EDE0 ; _DWORD __thiscall CWinMgr::~CWinMgr(CWinMgr *__hidden this)
UNDEF:0000EDE0                 extrn ??1CWinMgr@@UAE@XZ:near
UNDEF:0000EDE0                                         ; CODE XREF: SizeableDlg::~SizeableDlg(void)+37p
UNDEF:0000EDE0                                         ; __unwindfunclet$??1SizeableDlg@@UAE@XZ$1+6j
UNDEF:0000EDE4 ; struct WINRECT *__thiscall CWinMgr::FindRect(CWinMgr *__hidden this, int)
UNDEF:0000EDE4                 extrn ?FindRect@CWinMgr@@QAEPAVWINRECT@@H@Z:near
UNDEF:0000EDE4                                         ; CODE XREF: CWinMgr::GetRect(uint)+Ep
UNDEF:0000EDE8 ; void __thiscall CWinMgr::InitToFitSizeFromCurrent(CWinMgr *__hidden this, HWND)
UNDEF:0000EDE8                 extrn ?InitToFitSizeFromCurrent@CWinMgr@@QAEXPAUHWND__@@@Z:near
UNDEF:0000EDE8                                         ; CODE XREF: WindowsDlg::onInitDialog(void)+20p
UNDEF:0000EDEC ; public: virtual void * __thiscall Window::`vector deleting destructor'(unsigned int)
UNDEF:0000EDEC                 extrn ??_EWindow@@UAEPAXI@Z:near ; weak
UNDEF:0000EDEC                                         ; DATA XREF: .rdata:const Window::`vftable'o
UNDEF:0000EDF0 ; public: virtual void __thiscall StaticDialog::create(int, bool, bool)
UNDEF:0000EDF0                 extrn ?create@StaticDialog@@UAEXH_N0@Z:near
UNDEF:0000EDF0                                         ; DATA XREF: .rdata:0000DE34o
UNDEF:0000EDF0                                         ; .rdata:0000DF40o
UNDEF:0000EDF4 ; void __thiscall StaticDialog::goToCenter(StaticDialog *__hidden this)
UNDEF:0000EDF4                 extrn ?goToCenter@StaticDialog@@QAEXXZ:near
UNDEF:0000EDF4                                         ; CODE XREF: WindowsDlg::onInitDialog(void)+233p
UNDEF:0000EDF8 ; public: virtual void __thiscall StaticDialog::display(bool)const
UNDEF:0000EDF8                 extrn ?display@StaticDialog@@UBEX_N@Z:near
UNDEF:0000EDF8                                         ; DATA XREF: .rdata:0000DE10o
UNDEF:0000EDF8                                         ; .rdata:0000DF1Co
UNDEF:0000EDFC ; INT_PTR __stdcall StaticDialog::dlgProc(HWND, UINT, WPARAM, LPARAM)
UNDEF:0000EDFC                 extrn ?dlgProc@StaticDialog@@KGHPAUHWND__@@IIJ@Z:near
UNDEF:0000EDFC                                         ; DATA XREF: WindowsDlg::doDialog(TiXmlNodeA *)+14o
UNDEF:0000EE00 ; public: virtual void * __thiscall StaticDialog::`vector deleting destructor'(unsigned int)
UNDEF:0000EE00                 extrn ??_EStaticDialog@@UAEPAXI@Z:near ; weak
UNDEF:0000EE00                                         ; DATA XREF: .rdata:const StaticDialog::`vftable'o
UNDEF:0000EE04 ; _DWORD __thiscall SizeableDlg::SizeableDlg(SizeableDlg *__hidden this, struct WINRECT *)
UNDEF:0000EE04                 extrn ??0SizeableDlg@@QAE@PAVWINRECT@@@Z:near
UNDEF:0000EE04                                         ; CODE XREF: WindowsDlg::WindowsDlg(void)+2Ep
UNDEF:0000EE08 ; int SizeableDlg::run_dlgProc(SizeableDlg *__hidden this, unsigned int, unsigned int, __int32)
UNDEF:0000EE08                 extrn ?run_dlgProc@SizeableDlg@@MAGHIIJ@Z:near
UNDEF:0000EE08                                         ; CODE XREF: WindowsDlg::run_dlgProc(uint,uint,long)+80p
UNDEF:0000EE08                                         ; WindowsDlg::run_dlgProc(uint,uint,long)+739p
UNDEF:0000EE0C ; void __thiscall SizeableDlg::onSize(SizeableDlg *__hidden this, unsigned int, int, int)
UNDEF:0000EE0C                 extrn ?onSize@SizeableDlg@@MAEXIHH@Z:near
UNDEF:0000EE0C                                         ; CODE XREF: WindowsDlg::onSize(uint,int,int)+16p
UNDEF:0000EE10 ; void __thiscall SizeableDlg::onGetMinMaxInfo(SizeableDlg *__hidden this, struct tagMINMAXINFO *)
UNDEF:0000EE10                 extrn ?onGetMinMaxInfo@SizeableDlg@@MAEXPAUtagMINMAXINFO@@@Z:near
UNDEF:0000EE10                                         ; CODE XREF: WindowsDlg::onGetMinMaxInfo(tagMINMAXINFO *)+Ep
UNDEF:0000EE14 ; __int32 __thiscall SizeableDlg::onWinMgr(SizeableDlg *__hidden this, unsigned int, __int32)
UNDEF:0000EE14                 extrn ?onWinMgr@SizeableDlg@@MAEJIJ@Z:near
UNDEF:0000EE14                                         ; CODE XREF: WindowsDlg::onWinMgr(uint,long)+A7p
UNDEF:0000EE18 ; public: virtual void * __thiscall std::error_category::`vector deleting destructor'(unsigned int)
UNDEF:0000EE18                 extrn ??_Eerror_category@std@@UAEPAXI@Z:near ; weak
UNDEF:0000EE18                                         ; DATA XREF: .rdata:const std::error_category::`vftable'o
UNDEF:0000EE1C ; const char *__cdecl std::_Syserror_map(int)
UNDEF:0000EE1C                 extrn ?_Syserror_map@std@@YAPBDH@Z:near
UNDEF:0000EE1C                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+Bp
UNDEF:0000EE1C                                         ; std::_Generic_error_category::message(int)+33p
UNDEF:0000EE20 ; const char *__cdecl std::_Winerror_map(int)
UNDEF:0000EE20                 extrn ?_Winerror_map@std@@YAPBDH@Z:near
UNDEF:0000EE20                                         ; CODE XREF: std::_System_error_category::message(int)+33p
UNDEF:0000EE24 ; public: virtual void * __thiscall std::_Generic_error_category::`vector deleting destructor'(unsigned int)
UNDEF:0000EE24                 extrn ??_E_Generic_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:0000EE24                                         ; DATA XREF: .rdata:const std::_Generic_error_category::`vftable'o
UNDEF:0000EE28 ; public: virtual void * __thiscall std::_Iostream_error_category::`vector deleting destructor'(unsigned int)
UNDEF:0000EE28                 extrn ??_E_Iostream_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:0000EE28                                         ; DATA XREF: .rdata:const std::_Iostream_error_category::`vftable'o
UNDEF:0000EE2C ; public: virtual void * __thiscall std::_System_error_category::`vector deleting destructor'(unsigned int)
UNDEF:0000EE2C                 extrn ??_E_System_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:0000EE2C                                         ; DATA XREF: .rdata:const std::_System_error_category::`vftable'o
UNDEF:0000EE30 ; class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> __cdecl BuildMenuFileName(int, unsigned int, class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const &)
UNDEF:0000EE30                 extrn ?BuildMenuFileName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HIABV12@@Z:near
UNDEF:0000EE30                                         ; CODE XREF: WindowsMenu::initPopupMenu(HMENU__ *,DocTabView *)+118p
UNDEF:0000EE34 ; const wchar_t *__thiscall WcharMbcsConvertor::char2wchar(WcharMbcsConvertor *__hidden this, const char *, unsigned int, int, int *, int *)
UNDEF:0000EE34                 extrn ?char2wchar@WcharMbcsConvertor@@QAEPB_WPBDIHPAH1@Z:near
UNDEF:0000EE34                                         ; CODE XREF: WindowsDlg::changeDlgLang(void)+B0p
UNDEF:0000EE34                                         ; WindowsDlg::changeDlgLang(void)+171p
UNDEF:0000EE38 ; public: virtual void * __thiscall WindowsDlg::`vector deleting destructor'(unsigned int)
UNDEF:0000EE38                 extrn ??_EWindowsDlg@@UAEPAXI@Z:near ; weak
UNDEF:0000EE38                                         ; DATA XREF: .rdata:const WindowsDlg::`vftable'o
UNDEF:0000EE3C ; struct TiXmlNodeA *__thiscall TiXmlNodeA::NextSibling(TiXmlNodeA *__hidden this, const char *)
UNDEF:0000EE3C                 extrn ?NextSibling@TiXmlNodeA@@QBEPAV1@PBD@Z:near
UNDEF:0000EE3C                                         ; CODE XREF: WindowsDlg::changeDlgLang(void)+E6p
UNDEF:0000EE40 ; struct TiXmlElementA *__thiscall TiXmlNodeA::FirstChildElement(TiXmlNodeA *__hidden this, const char *)
UNDEF:0000EE40                 extrn ?FirstChildElement@TiXmlNodeA@@QBEPAVTiXmlElementA@@PBD@Z:near
UNDEF:0000EE40                                         ; CODE XREF: WindowsDlg::changeDlgLang(void)+D4p
UNDEF:0000EE44 ; struct TiXmlDocumentA *__thiscall TiXmlNodeA::GetDocument(TiXmlNodeA *__hidden this)
UNDEF:0000EE44                 extrn ?GetDocument@TiXmlNodeA@@QBEPAVTiXmlDocumentA@@XZ:near
UNDEF:0000EE44                                         ; CODE XREF: WindowsDlg::changeDlgLang(void)+2Ep
UNDEF:0000EE48 ; const char *__thiscall TiXmlElementA::Attribute(TiXmlElementA *__hidden this, const char *)
UNDEF:0000EE48                 extrn ?Attribute@TiXmlElementA@@QBEPBDPBD@Z:near
UNDEF:0000EE48                                         ; CODE XREF: WindowsDlg::changeDlgLang(void)+7Ep
UNDEF:0000EE48                                         ; WindowsDlg::changeDlgLang(void)+11Fp
UNDEF:0000EE4C ; const char *__thiscall TiXmlElementA::Attribute(TiXmlElementA *__hidden this, const char *, int *)
UNDEF:0000EE4C                 extrn ?Attribute@TiXmlElementA@@QBEPBDPBDPAH@Z:near
UNDEF:0000EE4C                                         ; CODE XREF: WindowsDlg::changeDlgLang(void)+10Fp
UNDEF:0000EE50 ; struct Buffer *__thiscall DocTabView::getBufferByIndex(DocTabView *__hidden this, int)
UNDEF:0000EE50                 extrn ?getBufferByIndex@DocTabView@@QAEPAVBuffer@@H@Z:near
UNDEF:0000EE50                                         ; CODE XREF: WindowsDlg::run_dlgProc(uint,uint,long)+1E3p
UNDEF:0000EE50                                         ; WindowsMenu::initPopupMenu(HMENU__ *,DocTabView *)+B0p ...
UNDEF:0000EE54 ; int __thiscall EncodingMapper::getEncodingFromString(EncodingMapper *__hidden this, const char *)
UNDEF:0000EE54                 extrn ?getEncodingFromString@EncodingMapper@@QBEHPBD@Z:near
UNDEF:0000EE54                                         ; CODE XREF: WindowsDlg::changeDlgLang(void)+64p
UNDEF:0000EE58 ; __fastcall __security_check_cookie(x)
UNDEF:0000EE58                 extrn @__security_check_cookie@4:near
UNDEF:0000EE58                                         ; CODE XREF: WindowsDlg::onInitDialog(void)+24Cp
UNDEF:0000EE58                                         ; WindowsDlg::fitColumnsToSize(void)+A3p ...
UNDEF:0000EE5C ; __stdcall _CxxThrowException(x, x)
UNDEF:0000EE5C                 extrn __CxxThrowException@8:near
UNDEF:0000EE5C                                         ; CODE XREF: __catch$??$_Construct@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$vector@_WV?$allocator@_W@std@@@std@@QAEXV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0Uforward_iterator_tag@1@@Z$0+Cp
UNDEF:0000EE5C                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1+10p ...
UNDEF:0000EE60                 extrn ___CxxFrameHandler3:near
UNDEF:0000EE60                                         ; CODE XREF: __ehhandler$??0WindowsDlg@@QAE@XZ+16j
UNDEF:0000EE60                                         ; __ehhandler$?run_dlgProc@WindowsDlg@@MAGHIIJ@Z+19j ...
UNDEF:0000EE64 ; struct std::nothrow_t std::nothrow
UNDEF:0000EE64                 extrn ?nothrow@std@@3Unothrow_t@1@B:near
UNDEF:0000EE64                                         ; DATA XREF: std::get_temporary_buffer<int>(int)+3Bo
UNDEF:0000EE68 ; const type_info::`vftable'
UNDEF:0000EE68                 extrn ??_7type_info@@6B@:near
UNDEF:0000EE68                                         ; DATA XREF: .data$r:Window `RTTI Type Descriptor'o
UNDEF:0000EE68                                         ; .data$r:StaticDialog `RTTI Type Descriptor'o ...
UNDEF:0000EE6C ; protected: static class WcharMbcsConvertor * WcharMbcsConvertor::_pSelf
UNDEF:0000EE6C                 extrn ?_pSelf@WcharMbcsConvertor@@1PAV1@A:near
UNDEF:0000EE6C                                         ; DATA XREF: WcharMbcsConvertor::getInstance(void)+3r
UNDEF:0000EE70 ; private: static class NppParameters * NppParameters::_pSelf
UNDEF:0000EE70                 extrn ?_pSelf@NppParameters@@0PAV1@A:near
UNDEF:0000EE70                                         ; DATA XREF: NppParameters::getInstance(void)+3r
UNDEF:0000EE74 ; private: static class FileManager * FileManager::_pSelf
UNDEF:0000EE74                 extrn ?_pSelf@FileManager@@0PAV1@A:near
UNDEF:0000EE74                                         ; DATA XREF: FileManager::getInstance(void)+3r
UNDEF:0000EE78 ; private: static class EncodingMapper * EncodingMapper::_pSelf
UNDEF:0000EE78                 extrn ?_pSelf@EncodingMapper@@0PAV1@A:near
UNDEF:0000EE78                                         ; DATA XREF: EncodingMapper::getInstance(void)+3r
UNDEF:0000EE7C                 extrn ___security_cookie:near
UNDEF:0000EE7C                                         ; DATA XREF: WindowsDlg::WindowsDlg(void)+12r
UNDEF:0000EE7C                                         ; WindowsDlg::run_dlgProc(uint,uint,long)+18r ...
UNDEF:0000EE80                 extrn __fltused:near
UNDEF:0000EE80
UNDEF:0000EE80
UNDEF:0000EE80                 end