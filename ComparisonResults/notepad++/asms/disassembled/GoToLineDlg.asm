.data:00000000 ;
.data:00000000 ; +-------------------------------------------------------------------------+
.data:00000000 ; |   This file has been generated by The Interactive Disassembler (IDA)    |
.data:00000000 ; |           Copyright (c) 2015 Hex-Rays, <support@hex-rays.com>           |
.data:00000000 ; |                      License info: 48-3677-7074-51                      |
.data:00000000 ; |             Michalis Polychronakis, Stony Brook University              |
.data:00000000 ; +-------------------------------------------------------------------------+
.data:00000000 ;
.data:00000000 ; Input MD5   : B80027D19699F02986C5E733CEE49192
.data:00000000 ; Input CRC32 : 1EB3167F
.data:00000000
.data:00000000 ; File Name   : C:\workspace\notepad-plus-plus-6.7.9.2\PowerEditor\visual.net\Unicode Debug\GoToLineDlg.obj
.data:00000000 ; Format      : COFF (X386MAGIC)
.data:00000000 ; includelib "uuid.lib"
.data:00000000 ; includelib "libcpmtd"
.data:00000000 ; must resolve: ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
.data:00000000 ; must resolve: ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
.data:00000000 ; must resolve: ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
.data:00000000 ; must resolve: ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
.data:00000000 ; must resolve: ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
.data:00000000 ; must resolve: ?id@?$numpunct@D@std@@2V0locale@2@A
.data:00000000 ; must resolve: ?id@?$numpunct@_W@std@@2V0locale@2@A
.data:00000000 ; includelib "LIBCMTD"
.data:00000000 ; includelib "OLDNAMES"
.data:00000000
.data:00000000                 include uni.inc ; see unicode subdir of ida for info on unicode
.data:00000000
.data:00000000                 .686p
.data:00000000                 .mmx
.data:00000000                 .model flat
.data:00000000
.data:00000000 ; ===========================================================================
.data:00000000
.data:00000000 ; Segment type: Pure data
.data:00000000 ; Segment permissions: Read/Write
.data:00000000 ; Segment alignment 'qword' can not be represented in assembly
.data:00000000 _data           segment para public 'DATA' use32
.data:00000000                 assume cs:_data
.data:00000000 _acTop_xpm      dd offset $SG143412     ; "12 12 56 1"
.data:00000004                 dd offset $SG143413     ; " \tc #FFFFFF"
.data:00000008                 dd offset $SG143414     ; ".\tc #8AB2E9"
.data:0000000C                 dd offset $SG143415     ; "+\tc #CCDCF6"
.data:00000010                 dd offset $SG143416     ; "@\tc #80ABEA"
.data:00000014                 dd offset $SG143417     ; "#\tc #7DA9E8"
.data:00000018                 dd offset $SG143418     ; "$\tc #C7DAF3"
.data:0000001C                 dd offset $SG143419     ; "%\tc #79A7E6"
.data:00000020                 dd offset $SG143420     ; "&\tc #ADC8EF"
.data:00000024                 dd offset $SG143421     ; "*\tc #87B0E8"
.data:00000028                 dd offset $SG143422     ; "=\tc #BBD2F0"
.data:0000002C                 dd offset $SG143423     ; "-\tc #6EA0E2"
.data:00000030                 dd offset $SG143424     ; ";\tc #A8C7EE"
.data:00000034                 dd offset $SG143425     ; ">\tc #A3C2ED"
.data:00000038                 dd offset $SG143426     ; ",\tc #75A4E3"
.data:0000003C                 dd offset $SG143427     ; "'\tc #A7C4EB"
.data:00000040                 dd offset $SG143428     ; ")\tc #6297E1"
.data:00000044                 dd offset $SG143429     ; "!\tc #A1C1EC"
.data:00000048                 dd offset $SG143430     ; "~\tc #92B7E8"
.data:0000004C                 dd offset $SG143431     ; "{\tc #99BBE9"
.data:00000050                 dd offset $SG143432     ; "]\tc #6197DD"
.data:00000054                 dd offset $SG143433     ; "^\tc #96B9E6"
.data:00000058                 dd offset $SG143434     ; "/\tc #538EDB"
.data:0000005C                 dd offset $SG143435     ; "(\tc #99BBEA"
.data:00000060                 dd offset $SG143436     ; "_\tc #80AAE3"
.data:00000064                 dd offset $SG143437     ; ":\tc #81ABE3"
.data:00000068                 dd offset $SG143438     ; "<\tc #8AB1E4"
.data:0000006C                 dd offset $SG143439     ; "[\tc #4B88D6"
.data:00000070                 dd offset $SG143440     ; "}\tc #4882D1"
.data:00000074                 dd offset $SG143441     ; "|\tc #4384D6"
.data:00000078                 dd offset $SG143442     ; "1\tc #90B5E7"
.data:0000007C                 dd offset $SG143443     ; "2\tc #74A3E0"
.data:00000080                 dd offset $SG143444     ; "3\tc #77A4E0"
.data:00000084                 dd offset $SG143445     ; "4\tc #81ABE2"
.data:00000088                 dd offset $SG143446     ; "5\tc #437FD3"
.data:0000008C                 dd offset $SG143447     ; "6\tc #7FA2DF"
.data:00000090                 dd offset $SG143448     ; "7\tc #3577D2"
.data:00000094                 dd offset $SG143449     ; "8\tc #87AFE4"
.data:00000098                 dd offset $SG143450     ; "9\tc #72A1DF"
.data:0000009C                 dd offset $SG143451     ; "0\tc #7CA9E1"
.data:000000A0                 dd offset $SG143452     ; "a\tc #3F7AD0"
.data:000000A4                 dd offset $SG143453     ; "b\tc #85A4DE"
.data:000000A8                 dd offset $SG143454     ; "c\tc #FBFCFE"
.data:000000AC                 dd offset $SG143455     ; "d\tc #236ECD"
.data:000000B0                 dd offset $SG143456     ; "e\tc #7EA8E1"
.data:000000B4                 dd offset $SG143457     ; "f\tc #79A6E0"
.data:000000B8                 dd offset $SG143458     ; "g\tc #3D77D0"
.data:000000BC                 dd offset $SG143459     ; "h\tc #87A4DC"
.data:000000C0                 dd offset $SG143460     ; "i\tc #1A62C9"
.data:000000C4                 dd offset $SG143461     ; "j\tc #75A3DF"
.data:000000C8                 dd offset $SG143462     ; "k\tc #3C74CF"
.data:000000CC                 dd offset $SG143463     ; "l\tc #8DA6DE"
.data:000000D0                 dd offset $SG143464     ; "m\tc #1859C4"
.data:000000D4                 dd offset $SG143465     ; "n\tc #3B71CC"
.data:000000D8                 dd offset $SG143466     ; "o\tc #8EA5DD"
.data:000000DC                 dd offset $SG143467     ; "p\tc #164EC0"
.data:000000E0                 dd offset $SG143468     ; "q\tc #92A7DD"
.data:000000E4                 dd offset $SG143469     ; "    .+      "
.data:000000E8                 dd offset $SG143470     ; "    @#$     "
.data:000000EC                 dd offset $SG143471     ; "    %&*=    "
.data:000000F0                 dd offset $SG143472     ; "    -;>,'   "
.data:000000F4                 dd offset $SG143473     ; "    )!~{]^  "
.data:000000F8                 dd offset $SG143474     ; "    /(_:<[} "
.data:000000FC                 dd offset $SG143475     ; "    |123456 "
.data:00000100                 dd offset $SG143476     ; "    7890abc "
.data:00000104                 dd offset $SG143477     ; "    defgh   "
.data:00000108                 dd offset $SG143478     ; "    ijkl    "
.data:0000010C                 dd offset $SG143479     ; "    mno     "
.data:00000110                 dd offset $SG143480     ; "    pq      "
.data:00000114                 align 8
.data:00000118 _acBottom_xpm   dd offset $SG143482     ; "12 12 54 1"
.data:0000011C                 dd offset $SG143483     ; " \tc #FFFFFF"
.data:00000120                 dd offset $SG143484     ; ".\tc #C4D7F3"
.data:00000124                 dd offset $SG143485     ; "+\tc #72A1E3"
.data:00000128                 dd offset $SG143486     ; "@\tc #C1D6F2"
.data:0000012C                 dd offset $SG143487     ; "#\tc #6397E1"
.data:00000130                 dd offset $SG143488     ; "$\tc #5990DD"
.data:00000134                 dd offset $SG143489     ; "%\tc #BBD2F0"
.data:00000138                 dd offset $SG143490     ; "&\tc #7AA6E5"
.data:0000013C                 dd offset $SG143491     ; "*\tc #9ABDEA"
.data:00000140                 dd offset $SG143492     ; "=\tc #4A87D9"
.data:00000144                 dd offset $SG143493     ; "-\tc #B1CAEE"
.data:00000148                 dd offset $SG143494     ; ";\tc #75A4E3"
.data:0000014C                 dd offset $SG143495     ; ">\tc #99BBE9"
.data:00000150                 dd offset $SG143496     ; ",\tc #95B9E8"
.data:00000154                 dd offset $SG143497     ; "'\tc #3A7CD4"
.data:00000158                 dd offset $SG143498     ; ")\tc #A9C6EC"
.data:0000015C                 dd offset $SG143499     ; "!\tc #71A0E0"
.data:00000160                 dd offset $SG143500     ; "~\tc #86AFE5"
.data:00000164                 dd offset $SG143501     ; "{\tc #8DB2E6"
.data:00000168                 dd offset $SG143502     ; "]\tc #2A72CF"
.data:0000016C                 dd offset $SG143503     ; "^\tc #73A0E0"
.data:00000170                 dd offset $SG143504     ; "/\tc #6B9DE0"
.data:00000174                 dd offset $SG143505     ; "(\tc #95B8E8"
.data:00000178                 dd offset $SG143506     ; "_\tc #81ABE3"
.data:0000017C                 dd offset $SG143507     ; ":\tc #72A1DF"
.data:00000180                 dd offset $SG143508     ; "<\tc #83ADE3"
.data:00000184                 dd offset $SG143509     ; "[\tc #1B65C9"
.data:00000188                 dd offset $SG143510     ; "}\tc #5F95DC"
.data:0000018C                 dd offset $SG143511     ; "|\tc #8BB3E5"
.data:00000190                 dd offset $SG143512     ; "1\tc #77A4E0"
.data:00000194                 dd offset $SG143513     ; "2\tc #679ADC"
.data:00000198                 dd offset $SG143514     ; "3\tc #7AA6E1"
.data:0000019C                 dd offset $SG143515     ; "4\tc #195CC6"
.data:000001A0                 dd offset $SG143516     ; "5\tc #FCFDFE"
.data:000001A4                 dd offset $SG143517     ; "6\tc #8DB2E4"
.data:000001A8                 dd offset $SG143518     ; "7\tc #4885D6"
.data:000001AC                 dd offset $SG143519     ; "8\tc #7CA9E1"
.data:000001B0                 dd offset $SG143520     ; "9\tc #6698DB"
.data:000001B4                 dd offset $SG143521     ; "0\tc #71A1DE"
.data:000001B8                 dd offset $SG143522     ; "a\tc #1752C0"
.data:000001BC                 dd offset $SG143523     ; "b\tc #88ABE0"
.data:000001C0                 dd offset $SG143524     ; "c\tc #3D77D0"
.data:000001C4                 dd offset $SG143525     ; "d\tc #6E9FDD"
.data:000001C8                 dd offset $SG143526     ; "e\tc #699BDC"
.data:000001CC                 dd offset $SG143527     ; "f\tc #1547BD"
.data:000001D0                 dd offset $SG143528     ; "g\tc #8DA6DE"
.data:000001D4                 dd offset $SG143529     ; "h\tc #376BC9"
.data:000001D8                 dd offset $SG143530     ; "i\tc #6295DA"
.data:000001DC                 dd offset $SG143531     ; "j\tc #1440B9"
.data:000001E0                 dd offset $SG143532     ; "k\tc #8DA0DB"
.data:000001E4                 dd offset $SG143533     ; "l\tc #315FC4"
.data:000001E8                 dd offset $SG143534     ; "m\tc #1339B7"
.data:000001EC                 dd offset $SG143535     ; "n\tc #909FDA"
.data:000001F0                 dd offset $SG143536     ; "o\tc #1233B4"
.data:000001F4                 dd offset $SG143537     ; "         .+ "
.data:000001F8                 dd offset $SG143538     ; "        @#$ "
.data:000001FC                 dd offset $SG143539     ; "       %&*= L"
.data:00000200                 dd offset $SG143540     ; "      -;>,' "
.data:00000204                 dd offset $SG143541     ; "     )!>~{] "
.data:00000208                 dd offset $SG143542     ; "    ^/(_:<[ "
.data:0000020C                 dd offset $SG143543     ; "    (}|1234 "
.data:00000210                 dd offset $SG143544     ; "    567890a "
.data:00000214                 dd offset $SG143545     ; "      bcdef "
.data:00000218                 dd offset $SG143546     ; "       ghij "
.data:0000021C                 dd offset $SG143547     ; "        klm "
.data:00000220                 dd offset $SG143548     ; "         no "
.data:00000224                 align 8
.data:00000228 _bookmark_xpm   dd offset $SG143550     ; "13 14 54 1"
.data:0000022C                 dd offset $SG143551     ; " \tc None"
.data:00000230                 dd offset $SG143552     ; ".\tc #545254"
.data:00000234                 dd offset $SG143553     ; "+\tc #3C3E3C"
.data:00000238                 dd offset $SG143554     ; "@\tc #646464"
.data:0000023C                 dd offset $SG143555     ; "#\tc #A4A4A4"
.data:00000240                 dd offset $SG143556     ; "$\tc #B7B8B7"
.data:00000244                 dd offset $SG143557     ; "%\tc #747284"
.data:00000248                 dd offset $SG143558     ; "&\tc #B4B2C4"
.data:0000024C                 dd offset $SG143559     ; "*\tc #DCD7E4"
.data:00000250                 dd offset $SG143560     ; "=\tc #1C1A1C"
.data:00000254                 dd offset $SG143561     ; "-\tc #403E58"
.data:00000258                 dd offset $SG143562     ; ";\tc #5C5A8C"
.data:0000025C                 dd offset $SG143563     ; ">\tc #7C7EAC"
.data:00000260                 dd offset $SG143564     ; ",\tc #7C8EBC"
.data:00000264                 dd offset $SG143565     ; "'\tc #242644"
.data:00000268                 dd offset $SG143566     ; ")\tc #282668"
.data:0000026C                 dd offset $SG143567     ; "!\tc #24367C"
.data:00000270                 dd offset $SG143568     ; "~\tc #244A84"
.data:00000274                 dd offset $SG143569     ; "{\tc #2C5098"
.data:00000278                 dd offset $SG143570     ; "]\tc #14162C"
.data:0000027C                 dd offset $SG143571     ; "^\tc #142E7C"
.data:00000280                 dd offset $SG143572     ; "/\tc #143789"
.data:00000284                 dd offset $SG143573     ; "(\tc #204990"
.data:00000288                 dd offset $SG143574     ; "_\tc #174091"
.data:0000028C                 dd offset $SG143575     ; ":\tc #0C0630"
.data:00000290                 dd offset $SG143576     ; "<\tc #24327C"
.data:00000294                 dd offset $SG143577     ; "[\tc #2450A0"
.data:00000298                 dd offset $SG143578     ; "}\tc #345DB4"
.data:0000029C                 dd offset $SG143579     ; "|\tc #3C68B8"
.data:000002A0                 dd offset $SG143580     ; "1\tc #141244"
.data:000002A4                 dd offset $SG143581     ; "2\tc #24428C"
.data:000002A8                 dd offset $SG143582     ; "3\tc #3462B9"
.data:000002AC                 dd offset $SG143583     ; "4\tc #4470C4"
.data:000002B0                 dd offset $SG143584     ; "5\tc #4C7FD6"
.data:000002B4                 dd offset $SG143585     ; "6\tc #4472CC"
.data:000002B8                 dd offset $SG143586     ; "7\tc #24224C"
.data:000002BC                 dd offset $SG143587     ; "8\tc #5C8DEC"
.data:000002C0                 dd offset $SG143588     ; "9\tc #5C94F6"
.data:000002C4                 dd offset $SG143589     ; "0\tc #5482DF"
.data:000002C8                 dd offset $SG143590     ; "a\tc #619DF7"
.data:000002CC                 dd offset $SG143591     ; "b\tc #6CA6FC"
.data:000002D0                 dd offset $SG143592     ; "c\tc #64A2FC"
.data:000002D4                 dd offset $SG143593     ; "d\tc #1C2E5C"
.data:000002D8                 dd offset $SG143594     ; "e\tc #6CA2FC"
.data:000002DC                 dd offset $SG143595     ; "f\tc #74B2FC"
.data:000002E0                 dd offset $SG143596     ; "g\tc #7CB8FC"
.data:000002E4                 dd offset $SG143597     ; "h\tc #1C3264"
.data:000002E8                 dd offset $SG143598     ; "i\tc #346AD4"
.data:000002EC                 dd offset $SG143599     ; "j\tc #7CBEFC"
.data:000002F0                 dd offset $SG143600     ; "k\tc #3C72DC"
.data:000002F4                 dd offset $SG143601     ; "l\tc #243250"
.data:000002F8                 dd offset $SG143602     ; "m\tc #346AB4"
.data:000002FC                 dd offset $SG143603     ; "n\tc #3C82DC"
.data:00000300                 dd offset $SG143604     ; "o\tc #6C6A6C"
.data:00000304                 dd offset $SG143605     ; "     .+.     "
.data:00000308                 dd offset $SG143606     ; "   @##$##@   "
.data:0000030C                 dd offset $SG143607     ; "  @%&***&%@  "
.data:00000310                 dd offset $SG143608     ; " =-;>,,,>;-= "
.data:00000314                 dd offset $SG143609     ; " ')!~{{{~!)' "
.data:00000318                 dd offset $SG143610     ; "])^/({{{(_^)]"
.data:0000031C                 dd offset $SG143611     ; ":<_[}|||}[_<:"
.data:00000320                 dd offset $SG143612     ; "12[3455563[21"
.data:00000324                 dd offset $SG143613     ; "7_365899063_7"
.data:00000328                 dd offset $SG143614     ; " /|09abc904/ "
.data:0000032C                 dd offset $SG143615     ; " d}8efgfb83d "
.data:00000330                 dd offset $SG143616     ; "  hiafjgakh  "
.data:00000334                 dd offset $SG143617     ; "   l~mnm~l   "
.data:00000338                 dd offset $SG143618     ; "     o@o     "
.data:00000338 _data           ends
.data:00000338
.rdata:0000033C ; ===========================================================================
.rdata:0000033C
.rdata:0000033C ; Segment type: Pure data
.rdata:0000033C ; Segment permissions: Read
.rdata:0000033C _rdata          segment dword public 'DATA' use32
.rdata:0000033C                 assume cs:_rdata
.rdata:0000033C                 ;org 33Ch
.rdata:0000033C $SG143412       db '12 12 56 1',0       ; DATA XREF: .data:_acTop_xpmo
.rdata:00000347                 align 4
.rdata:00000348 $SG143413       db ' ',9,'c #FFFFFF',0  ; DATA XREF: .data:00000004o
.rdata:00000354 $SG143414       db '.',9,'c #8AB2E9',0  ; DATA XREF: .data:00000008o
.rdata:00000360 $SG143415       db '+',9,'c #CCDCF6',0  ; DATA XREF: .data:0000000Co
.rdata:0000036C $SG143416       db '@',9,'c #80ABEA',0  ; DATA XREF: .data:00000010o
.rdata:00000378 $SG143417       db '#',9,'c #7DA9E8',0  ; DATA XREF: .data:00000014o
.rdata:00000384 $SG143418       db '$',9,'c #C7DAF3',0  ; DATA XREF: .data:00000018o
.rdata:00000390 $SG143419       db '%',9,'c #79A7E6',0  ; DATA XREF: .data:0000001Co
.rdata:0000039C $SG143420       db '&',9,'c #ADC8EF',0  ; DATA XREF: .data:00000020o
.rdata:000003A8 $SG143421       db '*',9,'c #87B0E8',0  ; DATA XREF: .data:00000024o
.rdata:000003B4 $SG143422       db '=',9,'c #BBD2F0',0  ; DATA XREF: .data:00000028o
.rdata:000003C0 $SG143423       db '-',9,'c #6EA0E2',0  ; DATA XREF: .data:0000002Co
.rdata:000003CC $SG143424       db ';',9,'c #A8C7EE',0  ; DATA XREF: .data:00000030o
.rdata:000003D8 $SG143425       db '>',9,'c #A3C2ED',0  ; DATA XREF: .data:00000034o
.rdata:000003E4 $SG143426       db ',',9,'c #75A4E3',0  ; DATA XREF: .data:00000038o
.rdata:000003F0 $SG143427       db 27h,9,'c #A7C4EB',0  ; DATA XREF: .data:0000003Co
.rdata:000003FC $SG143428       db ')',9,'c #6297E1',0  ; DATA XREF: .data:00000040o
.rdata:00000408 $SG143429       db '!',9,'c #A1C1EC',0  ; DATA XREF: .data:00000044o
.rdata:00000414 $SG143430       db '~',9,'c #92B7E8',0  ; DATA XREF: .data:00000048o
.rdata:00000420 $SG143431       db '{',9,'c #99BBE9',0  ; DATA XREF: .data:0000004Co
.rdata:0000042C $SG143432       db ']',9,'c #6197DD',0  ; DATA XREF: .data:00000050o
.rdata:00000438 $SG143433       db '^',9,'c #96B9E6',0  ; DATA XREF: .data:00000054o
.rdata:00000444 $SG143434       db '/',9,'c #538EDB',0  ; DATA XREF: .data:00000058o
.rdata:00000450 $SG143435       db '(',9,'c #99BBEA',0  ; DATA XREF: .data:0000005Co
.rdata:0000045C $SG143436       db '_',9,'c #80AAE3',0  ; DATA XREF: .data:00000060o
.rdata:00000468 $SG143437       db ':',9,'c #81ABE3',0  ; DATA XREF: .data:00000064o
.rdata:00000474 $SG143438       db '<',9,'c #8AB1E4',0  ; DATA XREF: .data:00000068o
.rdata:00000480 $SG143439       db '[',9,'c #4B88D6',0  ; DATA XREF: .data:0000006Co
.rdata:0000048C $SG143440       db '}',9,'c #4882D1',0  ; DATA XREF: .data:00000070o
.rdata:00000498 $SG143441       db '|',9,'c #4384D6',0  ; DATA XREF: .data:00000074o
.rdata:000004A4 $SG143442       db '1',9,'c #90B5E7',0  ; DATA XREF: .data:00000078o
.rdata:000004B0 $SG143443       db '2',9,'c #74A3E0',0  ; DATA XREF: .data:0000007Co
.rdata:000004BC $SG143444       db '3',9,'c #77A4E0',0  ; DATA XREF: .data:00000080o
.rdata:000004C8 $SG143445       db '4',9,'c #81ABE2',0  ; DATA XREF: .data:00000084o
.rdata:000004D4 $SG143446       db '5',9,'c #437FD3',0  ; DATA XREF: .data:00000088o
.rdata:000004E0 $SG143447       db '6',9,'c #7FA2DF',0  ; DATA XREF: .data:0000008Co
.rdata:000004EC $SG143448       db '7',9,'c #3577D2',0  ; DATA XREF: .data:00000090o
.rdata:000004F8 $SG143449       db '8',9,'c #87AFE4',0  ; DATA XREF: .data:00000094o
.rdata:00000504 $SG143450       db '9',9,'c #72A1DF',0  ; DATA XREF: .data:00000098o
.rdata:00000510 $SG143451       db '0',9,'c #7CA9E1',0  ; DATA XREF: .data:0000009Co
.rdata:0000051C $SG143452       db 'a',9,'c #3F7AD0',0  ; DATA XREF: .data:000000A0o
.rdata:00000528 $SG143453       db 'b',9,'c #85A4DE',0  ; DATA XREF: .data:000000A4o
.rdata:00000534 $SG143454       db 'c',9,'c #FBFCFE',0  ; DATA XREF: .data:000000A8o
.rdata:00000540 $SG143455       db 'd',9,'c #236ECD',0  ; DATA XREF: .data:000000ACo
.rdata:0000054C $SG143456       db 'e',9,'c #7EA8E1',0  ; DATA XREF: .data:000000B0o
.rdata:00000558 $SG143457       db 'f',9,'c #79A6E0',0  ; DATA XREF: .data:000000B4o
.rdata:00000564 $SG143458       db 'g',9,'c #3D77D0',0  ; DATA XREF: .data:000000B8o
.rdata:00000570 $SG143459       db 'h',9,'c #87A4DC',0  ; DATA XREF: .data:000000BCo
.rdata:0000057C $SG143460       db 'i',9,'c #1A62C9',0  ; DATA XREF: .data:000000C0o
.rdata:00000588 $SG143461       db 'j',9,'c #75A3DF',0  ; DATA XREF: .data:000000C4o
.rdata:00000594 $SG143462       db 'k',9,'c #3C74CF',0  ; DATA XREF: .data:000000C8o
.rdata:000005A0 $SG143463       db 'l',9,'c #8DA6DE',0  ; DATA XREF: .data:000000CCo
.rdata:000005AC $SG143464       db 'm',9,'c #1859C4',0  ; DATA XREF: .data:000000D0o
.rdata:000005B8 $SG143465       db 'n',9,'c #3B71CC',0  ; DATA XREF: .data:000000D4o
.rdata:000005C4 $SG143466       db 'o',9,'c #8EA5DD',0  ; DATA XREF: .data:000000D8o
.rdata:000005D0 $SG143467       db 'p',9,'c #164EC0',0  ; DATA XREF: .data:000000DCo
.rdata:000005DC $SG143468       db 'q',9,'c #92A7DD',0  ; DATA XREF: .data:000000E0o
.rdata:000005E8 $SG143469       db '    .+      ',0     ; DATA XREF: .data:000000E4o
.rdata:000005F5                 align 4
.rdata:000005F8 $SG143470       db '    @#$     ',0     ; DATA XREF: .data:000000E8o
.rdata:00000605                 align 4
.rdata:00000608 $SG143471       db '    %&*=    ',0     ; DATA XREF: .data:000000ECo
.rdata:00000615                 align 4
.rdata:00000618 $SG143472       db '    -;>,',27h,'   ',0 ; DATA XREF: .data:000000F0o
.rdata:00000625                 align 4
.rdata:00000628 $SG143473       db '    )!~{]^  ',0     ; DATA XREF: .data:000000F4o
.rdata:00000635                 align 4
.rdata:00000638 $SG143474       db '    /(_:<[} ',0     ; DATA XREF: .data:000000F8o
.rdata:00000645                 align 4
.rdata:00000648 $SG143475       db '    |123456 ',0     ; DATA XREF: .data:000000FCo
.rdata:00000655                 align 4
.rdata:00000658 $SG143476       db '    7890abc ',0     ; DATA XREF: .data:00000100o
.rdata:00000665                 align 4
.rdata:00000668 $SG143477       db '    defgh   ',0     ; DATA XREF: .data:00000104o
.rdata:00000675                 align 4
.rdata:00000678 $SG143478       db '    ijkl    ',0     ; DATA XREF: .data:00000108o
.rdata:00000685                 align 4
.rdata:00000688 $SG143479       db '    mno     ',0     ; DATA XREF: .data:0000010Co
.rdata:00000695                 align 4
.rdata:00000698 $SG143480       db '    pq      ',0     ; DATA XREF: .data:00000110o
.rdata:000006A5                 align 4
.rdata:000006A8 $SG143482       db '12 12 54 1',0       ; DATA XREF: .data:_acBottom_xpmo
.rdata:000006B3                 align 4
.rdata:000006B4 $SG143483       db ' ',9,'c #FFFFFF',0  ; DATA XREF: .data:0000011Co
.rdata:000006C0 $SG143484       db '.',9,'c #C4D7F3',0  ; DATA XREF: .data:00000120o
.rdata:000006CC $SG143485       db '+',9,'c #72A1E3',0  ; DATA XREF: .data:00000124o
.rdata:000006D8 $SG143486       db '@',9,'c #C1D6F2',0  ; DATA XREF: .data:00000128o
.rdata:000006E4 $SG143487       db '#',9,'c #6397E1',0  ; DATA XREF: .data:0000012Co
.rdata:000006F0 $SG143488       db '$',9,'c #5990DD',0  ; DATA XREF: .data:00000130o
.rdata:000006FC $SG143489       db '%',9,'c #BBD2F0',0  ; DATA XREF: .data:00000134o
.rdata:00000708 $SG143490       db '&',9,'c #7AA6E5',0  ; DATA XREF: .data:00000138o
.rdata:00000714 $SG143491       db '*',9,'c #9ABDEA',0  ; DATA XREF: .data:0000013Co
.rdata:00000720 $SG143492       db '=',9,'c #4A87D9',0  ; DATA XREF: .data:00000140o
.rdata:0000072C $SG143493       db '-',9,'c #B1CAEE',0  ; DATA XREF: .data:00000144o
.rdata:00000738 $SG143494       db ';',9,'c #75A4E3',0  ; DATA XREF: .data:00000148o
.rdata:00000744 $SG143495       db '>',9,'c #99BBE9',0  ; DATA XREF: .data:0000014Co
.rdata:00000750 $SG143496       db ',',9,'c #95B9E8',0  ; DATA XREF: .data:00000150o
.rdata:0000075C $SG143497       db 27h,9,'c #3A7CD4',0  ; DATA XREF: .data:00000154o
.rdata:00000768 $SG143498       db ')',9,'c #A9C6EC',0  ; DATA XREF: .data:00000158o
.rdata:00000774 $SG143499       db '!',9,'c #71A0E0',0  ; DATA XREF: .data:0000015Co
.rdata:00000780 $SG143500       db '~',9,'c #86AFE5',0  ; DATA XREF: .data:00000160o
.rdata:0000078C $SG143501       db '{',9,'c #8DB2E6',0  ; DATA XREF: .data:00000164o
.rdata:00000798 $SG143502       db ']',9,'c #2A72CF',0  ; DATA XREF: .data:00000168o
.rdata:000007A4 $SG143503       db '^',9,'c #73A0E0',0  ; DATA XREF: .data:0000016Co
.rdata:000007B0 $SG143504       db '/',9,'c #6B9DE0',0  ; DATA XREF: .data:00000170o
.rdata:000007BC $SG143505       db '(',9,'c #95B8E8',0  ; DATA XREF: .data:00000174o
.rdata:000007C8 $SG143506       db '_',9,'c #81ABE3',0  ; DATA XREF: .data:00000178o
.rdata:000007D4 $SG143507       db ':',9,'c #72A1DF',0  ; DATA XREF: .data:0000017Co
.rdata:000007E0 $SG143508       db '<',9,'c #83ADE3',0  ; DATA XREF: .data:00000180o
.rdata:000007EC $SG143509       db '[',9,'c #1B65C9',0  ; DATA XREF: .data:00000184o
.rdata:000007F8 $SG143510       db '}',9,'c #5F95DC',0  ; DATA XREF: .data:00000188o
.rdata:00000804 $SG143511       db '|',9,'c #8BB3E5',0  ; DATA XREF: .data:0000018Co
.rdata:00000810 $SG143512       db '1',9,'c #77A4E0',0  ; DATA XREF: .data:00000190o
.rdata:0000081C $SG143513       db '2',9,'c #679ADC',0  ; DATA XREF: .data:00000194o
.rdata:00000828 $SG143514       db '3',9,'c #7AA6E1',0  ; DATA XREF: .data:00000198o
.rdata:00000834 $SG143515       db '4',9,'c #195CC6',0  ; DATA XREF: .data:0000019Co
.rdata:00000840 $SG143516       db '5',9,'c #FCFDFE',0  ; DATA XREF: .data:000001A0o
.rdata:0000084C $SG143517       db '6',9,'c #8DB2E4',0  ; DATA XREF: .data:000001A4o
.rdata:00000858 $SG143518       db '7',9,'c #4885D6',0  ; DATA XREF: .data:000001A8o
.rdata:00000864 $SG143519       db '8',9,'c #7CA9E1',0  ; DATA XREF: .data:000001ACo
.rdata:00000870 $SG143520       db '9',9,'c #6698DB',0  ; DATA XREF: .data:000001B0o
.rdata:0000087C $SG143521       db '0',9,'c #71A1DE',0  ; DATA XREF: .data:000001B4o
.rdata:00000888 $SG143522       db 'a',9,'c #1752C0',0  ; DATA XREF: .data:000001B8o
.rdata:00000894 $SG143523       db 'b',9,'c #88ABE0',0  ; DATA XREF: .data:000001BCo
.rdata:000008A0 $SG143524       db 'c',9,'c #3D77D0',0  ; DATA XREF: .data:000001C0o
.rdata:000008AC $SG143525       db 'd',9,'c #6E9FDD',0  ; DATA XREF: .data:000001C4o
.rdata:000008B8 $SG143526       db 'e',9,'c #699BDC',0  ; DATA XREF: .data:000001C8o
.rdata:000008C4 $SG143527       db 'f',9,'c #1547BD',0  ; DATA XREF: .data:000001CCo
.rdata:000008D0 $SG143528       db 'g',9,'c #8DA6DE',0  ; DATA XREF: .data:000001D0o
.rdata:000008DC $SG143529       db 'h',9,'c #376BC9',0  ; DATA XREF: .data:000001D4o
.rdata:000008E8 $SG143530       db 'i',9,'c #6295DA',0  ; DATA XREF: .data:000001D8o
.rdata:000008F4 $SG143531       db 'j',9,'c #1440B9',0  ; DATA XREF: .data:000001DCo
.rdata:00000900 $SG143532       db 'k',9,'c #8DA0DB',0  ; DATA XREF: .data:000001E0o
.rdata:0000090C $SG143533       db 'l',9,'c #315FC4',0  ; DATA XREF: .data:000001E4o
.rdata:00000918 $SG143534       db 'm',9,'c #1339B7',0  ; DATA XREF: .data:000001E8o
.rdata:00000924 $SG143535       db 'n',9,'c #909FDA',0  ; DATA XREF: .data:000001ECo
.rdata:00000930 $SG143536       db 'o',9,'c #1233B4',0  ; DATA XREF: .data:000001F0o
.rdata:0000093C $SG143537       db '         .+ ',0     ; DATA XREF: .data:000001F4o
.rdata:00000949                 align 4
.rdata:0000094C $SG143538       db '        @#$ ',0     ; DATA XREF: .data:000001F8o
.rdata:00000959                 align 4
.rdata:0000095C $SG143539       db '       %&*= L',0    ; DATA XREF: .data:000001FCo
.rdata:0000096A                 align 4
.rdata:0000096C $SG143540       db '      -;>,',27h,' ',0 ; DATA XREF: .data:00000200o
.rdata:00000979                 align 4
.rdata:0000097C $SG143541       db '     )!>~{] ',0     ; DATA XREF: .data:00000204o
.rdata:00000989                 align 4
.rdata:0000098C $SG143542       db '    ^/(_:<[ ',0     ; DATA XREF: .data:00000208o
.rdata:00000999                 align 4
.rdata:0000099C $SG143543       db '    (}|1234 ',0     ; DATA XREF: .data:0000020Co
.rdata:000009A9                 align 4
.rdata:000009AC $SG143544       db '    567890a ',0     ; DATA XREF: .data:00000210o
.rdata:000009B9                 align 4
.rdata:000009BC $SG143545       db '      bcdef ',0     ; DATA XREF: .data:00000214o
.rdata:000009C9                 align 4
.rdata:000009CC $SG143546       db '       ghij ',0     ; DATA XREF: .data:00000218o
.rdata:000009D9                 align 4
.rdata:000009DC $SG143547       db '        klm ',0     ; DATA XREF: .data:0000021Co
.rdata:000009E9                 align 4
.rdata:000009EC $SG143548       db '         no ',0     ; DATA XREF: .data:00000220o
.rdata:000009F9                 align 4
.rdata:000009FC $SG143550       db '13 14 54 1',0       ; DATA XREF: .data:_bookmark_xpmo
.rdata:00000A07                 align 4
.rdata:00000A08 $SG143551       db ' ',9,'c None',0     ; DATA XREF: .data:0000022Co
.rdata:00000A11                 align 4
.rdata:00000A14 $SG143552       db '.',9,'c #545254',0  ; DATA XREF: .data:00000230o
.rdata:00000A20 $SG143553       db '+',9,'c #3C3E3C',0  ; DATA XREF: .data:00000234o
.rdata:00000A2C $SG143554       db '@',9,'c #646464',0  ; DATA XREF: .data:00000238o
.rdata:00000A38 $SG143555       db '#',9,'c #A4A4A4',0  ; DATA XREF: .data:0000023Co
.rdata:00000A44 $SG143556       db '$',9,'c #B7B8B7',0  ; DATA XREF: .data:00000240o
.rdata:00000A50 $SG143557       db '%',9,'c #747284',0  ; DATA XREF: .data:00000244o
.rdata:00000A5C $SG143558       db '&',9,'c #B4B2C4',0  ; DATA XREF: .data:00000248o
.rdata:00000A68 $SG143559       db '*',9,'c #DCD7E4',0  ; DATA XREF: .data:0000024Co
.rdata:00000A74 $SG143560       db '=',9,'c #1C1A1C',0  ; DATA XREF: .data:00000250o
.rdata:00000A80 $SG143561       db '-',9,'c #403E58',0  ; DATA XREF: .data:00000254o
.rdata:00000A8C $SG143562       db ';',9,'c #5C5A8C',0  ; DATA XREF: .data:00000258o
.rdata:00000A98 $SG143563       db '>',9,'c #7C7EAC',0  ; DATA XREF: .data:0000025Co
.rdata:00000AA4 $SG143564       db ',',9,'c #7C8EBC',0  ; DATA XREF: .data:00000260o
.rdata:00000AB0 $SG143565       db 27h,9,'c #242644',0  ; DATA XREF: .data:00000264o
.rdata:00000ABC $SG143566       db ')',9,'c #282668',0  ; DATA XREF: .data:00000268o
.rdata:00000AC8 $SG143567       db '!',9,'c #24367C',0  ; DATA XREF: .data:0000026Co
.rdata:00000AD4 $SG143568       db '~',9,'c #244A84',0  ; DATA XREF: .data:00000270o
.rdata:00000AE0 $SG143569       db '{',9,'c #2C5098',0  ; DATA XREF: .data:00000274o
.rdata:00000AEC $SG143570       db ']',9,'c #14162C',0  ; DATA XREF: .data:00000278o
.rdata:00000AF8 $SG143571       db '^',9,'c #142E7C',0  ; DATA XREF: .data:0000027Co
.rdata:00000B04 $SG143572       db '/',9,'c #143789',0  ; DATA XREF: .data:00000280o
.rdata:00000B10 $SG143573       db '(',9,'c #204990',0  ; DATA XREF: .data:00000284o
.rdata:00000B1C $SG143574       db '_',9,'c #174091',0  ; DATA XREF: .data:00000288o
.rdata:00000B28 $SG143575       db ':',9,'c #0C0630',0  ; DATA XREF: .data:0000028Co
.rdata:00000B34 $SG143576       db '<',9,'c #24327C',0  ; DATA XREF: .data:00000290o
.rdata:00000B40 $SG143577       db '[',9,'c #2450A0',0  ; DATA XREF: .data:00000294o
.rdata:00000B4C $SG143578       db '}',9,'c #345DB4',0  ; DATA XREF: .data:00000298o
.rdata:00000B58 $SG143579       db '|',9,'c #3C68B8',0  ; DATA XREF: .data:0000029Co
.rdata:00000B64 $SG143580       db '1',9,'c #141244',0  ; DATA XREF: .data:000002A0o
.rdata:00000B70 $SG143581       db '2',9,'c #24428C',0  ; DATA XREF: .data:000002A4o
.rdata:00000B7C $SG143582       db '3',9,'c #3462B9',0  ; DATA XREF: .data:000002A8o
.rdata:00000B88 $SG143583       db '4',9,'c #4470C4',0  ; DATA XREF: .data:000002ACo
.rdata:00000B94 $SG143584       db '5',9,'c #4C7FD6',0  ; DATA XREF: .data:000002B0o
.rdata:00000BA0 $SG143585       db '6',9,'c #4472CC',0  ; DATA XREF: .data:000002B4o
.rdata:00000BAC $SG143586       db '7',9,'c #24224C',0  ; DATA XREF: .data:000002B8o
.rdata:00000BB8 $SG143587       db '8',9,'c #5C8DEC',0  ; DATA XREF: .data:000002BCo
.rdata:00000BC4 $SG143588       db '9',9,'c #5C94F6',0  ; DATA XREF: .data:000002C0o
.rdata:00000BD0 $SG143589       db '0',9,'c #5482DF',0  ; DATA XREF: .data:000002C4o
.rdata:00000BDC $SG143590       db 'a',9,'c #619DF7',0  ; DATA XREF: .data:000002C8o
.rdata:00000BE8 $SG143591       db 'b',9,'c #6CA6FC',0  ; DATA XREF: .data:000002CCo
.rdata:00000BF4 $SG143592       db 'c',9,'c #64A2FC',0  ; DATA XREF: .data:000002D0o
.rdata:00000C00 $SG143593       db 'd',9,'c #1C2E5C',0  ; DATA XREF: .data:000002D4o
.rdata:00000C0C $SG143594       db 'e',9,'c #6CA2FC',0  ; DATA XREF: .data:000002D8o
.rdata:00000C18 $SG143595       db 'f',9,'c #74B2FC',0  ; DATA XREF: .data:000002DCo
.rdata:00000C24 $SG143596       db 'g',9,'c #7CB8FC',0  ; DATA XREF: .data:000002E0o
.rdata:00000C30 $SG143597       db 'h',9,'c #1C3264',0  ; DATA XREF: .data:000002E4o
.rdata:00000C3C $SG143598       db 'i',9,'c #346AD4',0  ; DATA XREF: .data:000002E8o
.rdata:00000C48 $SG143599       db 'j',9,'c #7CBEFC',0  ; DATA XREF: .data:000002ECo
.rdata:00000C54 $SG143600       db 'k',9,'c #3C72DC',0  ; DATA XREF: .data:000002F0o
.rdata:00000C60 $SG143601       db 'l',9,'c #243250',0  ; DATA XREF: .data:000002F4o
.rdata:00000C6C $SG143602       db 'm',9,'c #346AB4',0  ; DATA XREF: .data:000002F8o
.rdata:00000C78 $SG143603       db 'n',9,'c #3C82DC',0  ; DATA XREF: .data:000002FCo
.rdata:00000C84 $SG143604       db 'o',9,'c #6C6A6C',0  ; DATA XREF: .data:00000300o
.rdata:00000C90 $SG143605       db '     .+.     ',0    ; DATA XREF: .data:00000304o
.rdata:00000C9E                 align 10h
.rdata:00000CA0 $SG143606       db '   @##$##@   ',0    ; DATA XREF: .data:00000308o
.rdata:00000CAE                 align 10h
.rdata:00000CB0 $SG143607       db '  @%&***&%@  ',0    ; DATA XREF: .data:0000030Co
.rdata:00000CBE                 align 10h
.rdata:00000CC0 $SG143608       db ' =-;>,,,>;-= ',0    ; DATA XREF: .data:00000310o
.rdata:00000CCE                 align 10h
.rdata:00000CD0 $SG143609       db ' ',27h,')!~{{{~!)',27h,' ',0
.rdata:00000CD0                                         ; DATA XREF: .data:00000314o
.rdata:00000CDE                 align 10h
.rdata:00000CE0 $SG143610       db '])^/({{{(_^)]',0    ; DATA XREF: .data:00000318o
.rdata:00000CEE                 align 10h
.rdata:00000CF0 $SG143611       db ':<_[}|||}[_<:',0    ; DATA XREF: .data:0000031Co
.rdata:00000CFE                 align 10h
.rdata:00000D00 $SG143612       db '12[3455563[21',0    ; DATA XREF: .data:00000320o
.rdata:00000D0E                 align 10h
.rdata:00000D10 $SG143613       db '7_365899063_7',0    ; DATA XREF: .data:00000324o
.rdata:00000D1E                 align 10h
.rdata:00000D20 $SG143614       db ' /|09abc904/ ',0    ; DATA XREF: .data:00000328o
.rdata:00000D2E                 align 10h
.rdata:00000D30 $SG143615       db ' d}8efgfb83d ',0    ; DATA XREF: .data:0000032Co
.rdata:00000D3E                 align 10h
.rdata:00000D40 $SG143616       db '  hiafjgakh  ',0    ; DATA XREF: .data:00000330o
.rdata:00000D4E                 align 10h
.rdata:00000D50 $SG143617       db '   l~mnm~l   ',0    ; DATA XREF: .data:00000334o
.rdata:00000D5E                 align 10h
.rdata:00000D60 $SG143618       db '     o@o     ',0    ; DATA XREF: .data:00000338o
.rdata:00000D6E                 align 10h
.rdata:00000D6E _rdata          ends
.rdata:00000D6E
.text$mn:00000D70 ; ===========================================================================
.text$mn:00000D70
.text$mn:00000D70 ; Segment type: Pure code
.text$mn:00000D70 ; Segment permissions: Read/Execute
.text$mn:00000D70 _text$mn        segment para public 'CODE' use32
.text$mn:00000D70                 assume cs:_text$mn
.text$mn:00000D70                 ;org 0D70h
.text$mn:00000D70                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00000D70
.text$mn:00000D70 ; =============== S U B R O U T I N E =======================================
.text$mn:00000D70
.text$mn:00000D70 ; Attributes: bp-based frame
.text$mn:00000D70
.text$mn:00000D70 ; int __stdcall GoToLineDlg::run_dlgProc(GoToLineDlg *this, unsigned int, unsigned int, __int32)
.text$mn:00000D70                 public ?run_dlgProc@GoToLineDlg@@MAGHIIJ@Z
.text$mn:00000D70 ?run_dlgProc@GoToLineDlg@@MAGHIIJ@Z proc near
.text$mn:00000D70
.text$mn:00000D70 Dst             = dword ptr -74h
.text$mn:00000D70 var_70          = dword ptr -70h
.text$mn:00000D70 var_6C          = dword ptr -6Ch
.text$mn:00000D70 var_18          = dword ptr -18h
.text$mn:00000D70 var_14          = dword ptr -14h
.text$mn:00000D70 var_10          = dword ptr -10h
.text$mn:00000D70 var_C           = dword ptr -0Ch
.text$mn:00000D70 var_8           = dword ptr -8
.text$mn:00000D70 var_2           = byte ptr -2
.text$mn:00000D70 var_1           = byte ptr -1
.text$mn:00000D70 this            = dword ptr  8
.text$mn:00000D70 arg_4           = dword ptr  0Ch
.text$mn:00000D70 arg_8           = dword ptr  10h
.text$mn:00000D70
.text$mn:00000D70                 push    ebp
.text$mn:00000D71                 mov     ebp, esp
.text$mn:00000D73                 sub     esp, 74h
.text$mn:00000D76                 mov     eax, [ebp+arg_4]
.text$mn:00000D79                 mov     [ebp+var_10], eax
.text$mn:00000D7C                 cmp     [ebp+var_10], 110h
.text$mn:00000D83                 jz      short loc_D93
.text$mn:00000D85                 cmp     [ebp+var_10], 111h
.text$mn:00000D8C                 jz      short loc_DC0
.text$mn:00000D8E                 jmp     loc_FE7
.text$mn:00000D93 ; ---------------------------------------------------------------------------
.text$mn:00000D93
.text$mn:00000D93 loc_D93:                                ; CODE XREF: GoToLineDlg::run_dlgProc(uint,uint,long)+13j
.text$mn:00000D93                 push    0               ; lParam
.text$mn:00000D95                 push    1               ; wParam
.text$mn:00000D97                 push    0F1h ; '±'      ; Msg
.text$mn:00000D9C                 push    7D7h            ; nIDDlgItem
.text$mn:00000DA1                 mov     ecx, [ebp+this]
.text$mn:00000DA4                 mov     edx, [ecx+0Ch]
.text$mn:00000DA7                 push    edx             ; hDlg
.text$mn:00000DA8                 call    dword ptr ds:__imp__SendDlgItemMessageW@20 ; SendDlgItemMessageW(x,x,x,x,x)
.text$mn:00000DAE                 mov     ecx, [ebp+this] ; this
.text$mn:00000DB1                 call    ?goToCenter@StaticDialog@@QAEXXZ ; StaticDialog::goToCenter(void)
.text$mn:00000DB6                 mov     eax, 1
.text$mn:00000DBB                 jmp     loc_FE9
.text$mn:00000DC0 ; ---------------------------------------------------------------------------
.text$mn:00000DC0
.text$mn:00000DC0 loc_DC0:                                ; CODE XREF: GoToLineDlg::run_dlgProc(uint,uint,long)+1Cj
.text$mn:00000DC0                 mov     eax, [ebp+arg_8]
.text$mn:00000DC3                 mov     [ebp+var_8], eax
.text$mn:00000DC6                 cmp     [ebp+var_8], 2
.text$mn:00000DCA                 ja      short loc_DDD
.text$mn:00000DCC                 cmp     [ebp+var_8], 2
.text$mn:00000DD0                 jz      short loc_DFC
.text$mn:00000DD2                 cmp     [ebp+var_8], 1
.text$mn:00000DD6                 jz      short loc_E1D
.text$mn:00000DD8                 jmp     loc_FAE
.text$mn:00000DDD ; ---------------------------------------------------------------------------
.text$mn:00000DDD
.text$mn:00000DDD loc_DDD:                                ; CODE XREF: GoToLineDlg::run_dlgProc(uint,uint,long)+5Aj
.text$mn:00000DDD                 cmp     [ebp+var_8], 7D7h
.text$mn:00000DE4                 jb      loc_FAE
.text$mn:00000DEA                 cmp     [ebp+var_8], 7D8h
.text$mn:00000DF1                 jbe     loc_F34
.text$mn:00000DF7                 jmp     loc_FAE
.text$mn:00000DFC ; ---------------------------------------------------------------------------
.text$mn:00000DFC
.text$mn:00000DFC loc_DFC:                                ; CODE XREF: GoToLineDlg::run_dlgProc(uint,uint,long)+60j
.text$mn:00000DFC                 push    0
.text$mn:00000DFE                 mov     ecx, [ebp+this]
.text$mn:00000E01                 mov     edx, [ecx]
.text$mn:00000E03                 mov     ecx, [ebp+this]
.text$mn:00000E06                 mov     eax, [edx+0Ch]
.text$mn:00000E09                 call    eax
.text$mn:00000E0B                 mov     ecx, [ebp+this] ; this
.text$mn:00000E0E                 call    ?cleanLineEdit@GoToLineDlg@@ABEXXZ ; GoToLineDlg::cleanLineEdit(void)
.text$mn:00000E13                 mov     eax, 1
.text$mn:00000E18                 jmp     loc_FE9
.text$mn:00000E1D ; ---------------------------------------------------------------------------
.text$mn:00000E1D
.text$mn:00000E1D loc_E1D:                                ; CODE XREF: GoToLineDlg::run_dlgProc(uint,uint,long)+66j
.text$mn:00000E1D                 mov     ecx, [ebp+this] ; this
.text$mn:00000E20                 call    ?getLine@GoToLineDlg@@ABEHXZ ; GoToLineDlg::getLine(void)
.text$mn:00000E25                 mov     [ebp+var_C], eax
.text$mn:00000E28                 cmp     [ebp+var_C], 0FFFFFFFFh
.text$mn:00000E2C                 jz      loc_ED5
.text$mn:00000E32                 push    0
.text$mn:00000E34                 mov     ecx, [ebp+this]
.text$mn:00000E37                 mov     edx, [ecx]
.text$mn:00000E39                 mov     ecx, [ebp+this]
.text$mn:00000E3C                 mov     eax, [edx+0Ch]
.text$mn:00000E3F                 call    eax
.text$mn:00000E41                 mov     ecx, [ebp+this] ; this
.text$mn:00000E44                 call    ?cleanLineEdit@GoToLineDlg@@ABEXXZ ; GoToLineDlg::cleanLineEdit(void)
.text$mn:00000E49                 mov     ecx, [ebp+this]
.text$mn:00000E4C                 cmp     dword ptr [ecx+20h], 0
.text$mn:00000E50                 jnz     short loc_E8A
.text$mn:00000E52                 push    0               ; __int32
.text$mn:00000E54                 mov     edx, [ebp+var_C]
.text$mn:00000E57                 sub     edx, 1
.text$mn:00000E5A                 push    edx             ; unsigned int
.text$mn:00000E5B                 push    8B8h            ; unsigned int
.text$mn:00000E60                 mov     eax, [ebp+this]
.text$mn:00000E63                 mov     ecx, [eax+24h]
.text$mn:00000E66                 mov     ecx, [ecx]      ; this
.text$mn:00000E68                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00000E6D                 push    0               ; __int32
.text$mn:00000E6F                 mov     edx, [ebp+var_C]
.text$mn:00000E72                 sub     edx, 1
.text$mn:00000E75                 push    edx             ; unsigned int
.text$mn:00000E76                 push    7E8h            ; unsigned int
.text$mn:00000E7B                 mov     eax, [ebp+this]
.text$mn:00000E7E                 mov     ecx, [eax+24h]
.text$mn:00000E81                 mov     ecx, [ecx]      ; this
.text$mn:00000E83                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00000E88                 jmp     short loc_ED5
.text$mn:00000E8A ; ---------------------------------------------------------------------------
.text$mn:00000E8A
.text$mn:00000E8A loc_E8A:                                ; CODE XREF: GoToLineDlg::run_dlgProc(uint,uint,long)+E0j
.text$mn:00000E8A                 push    0               ; __int32
.text$mn:00000E8C                 mov     edx, [ebp+var_C]
.text$mn:00000E8F                 push    edx             ; unsigned int
.text$mn:00000E90                 push    876h            ; unsigned int
.text$mn:00000E95                 mov     eax, [ebp+this]
.text$mn:00000E98                 mov     ecx, [eax+24h]
.text$mn:00000E9B                 mov     ecx, [ecx]      ; this
.text$mn:00000E9D                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00000EA2                 mov     [ebp+var_18], eax
.text$mn:00000EA5                 push    0               ; __int32
.text$mn:00000EA7                 mov     edx, [ebp+var_18]
.text$mn:00000EAA                 push    edx             ; unsigned int
.text$mn:00000EAB                 push    8B8h            ; unsigned int
.text$mn:00000EB0                 mov     eax, [ebp+this]
.text$mn:00000EB3                 mov     ecx, [eax+24h]
.text$mn:00000EB6                 mov     ecx, [ecx]      ; this
.text$mn:00000EB8                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00000EBD                 push    0               ; __int32
.text$mn:00000EBF                 mov     edx, [ebp+var_C]
.text$mn:00000EC2                 push    edx             ; unsigned int
.text$mn:00000EC3                 push    7E9h            ; unsigned int
.text$mn:00000EC8                 mov     eax, [ebp+this]
.text$mn:00000ECB                 mov     ecx, [eax+24h]
.text$mn:00000ECE                 mov     ecx, [ecx]      ; this
.text$mn:00000ED0                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00000ED5
.text$mn:00000ED5 loc_ED5:                                ; CODE XREF: GoToLineDlg::run_dlgProc(uint,uint,long)+BCj
.text$mn:00000ED5                                         ; GoToLineDlg::run_dlgProc(uint,uint,long)+118j
.text$mn:00000ED5                 push    5Ch ; '\'       ; Size
.text$mn:00000ED7                 push    0               ; Val
.text$mn:00000ED9                 lea     edx, [ebp+Dst]
.text$mn:00000EDC                 push    edx             ; Dst
.text$mn:00000EDD                 call    _memset
.text$mn:00000EE2                 add     esp, 0Ch
.text$mn:00000EE5                 mov     [ebp+var_6C], 7DDh
.text$mn:00000EEC                 mov     eax, [ebp+this]
.text$mn:00000EEF                 mov     ecx, [eax+0Ch]
.text$mn:00000EF2                 mov     [ebp+Dst], ecx
.text$mn:00000EF5                 mov     edx, [ebp+this]
.text$mn:00000EF8                 mov     eax, [edx+0Ch]
.text$mn:00000EFB                 push    eax             ; hWnd
.text$mn:00000EFC                 call    dword ptr ds:__imp__GetDlgCtrlID@4 ; GetDlgCtrlID(x)
.text$mn:00000F02                 mov     [ebp+var_70], eax
.text$mn:00000F05                 lea     ecx, [ebp+Dst]
.text$mn:00000F08                 push    ecx             ; lParam
.text$mn:00000F09                 push    62Bh            ; wParam
.text$mn:00000F0E                 push    4Eh ; 'N'       ; Msg
.text$mn:00000F10                 mov     edx, [ebp+this]
.text$mn:00000F13                 mov     eax, [edx+8]
.text$mn:00000F16                 push    eax             ; hWnd
.text$mn:00000F17                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000F1D                 mov     ecx, [ebp+this]
.text$mn:00000F20                 mov     edx, [ecx+24h]
.text$mn:00000F23                 mov     ecx, [edx]      ; this
.text$mn:00000F25                 call    ?getFocus@Window@@QBEXXZ ; Window::getFocus(void)
.text$mn:00000F2A                 mov     eax, 1
.text$mn:00000F2F                 jmp     loc_FE9
.text$mn:00000F34 ; ---------------------------------------------------------------------------
.text$mn:00000F34
.text$mn:00000F34 loc_F34:                                ; CODE XREF: GoToLineDlg::run_dlgProc(uint,uint,long)+81j
.text$mn:00000F34                 cmp     [ebp+arg_8], 7D7h
.text$mn:00000F3B                 jnz     short loc_F51
.text$mn:00000F3D                 mov     [ebp+var_1], 1
.text$mn:00000F41                 mov     [ebp+var_2], 0
.text$mn:00000F45                 mov     eax, [ebp+this]
.text$mn:00000F48                 mov     dword ptr [eax+20h], 0
.text$mn:00000F4F                 jmp     short loc_F63
.text$mn:00000F51 ; ---------------------------------------------------------------------------
.text$mn:00000F51
.text$mn:00000F51 loc_F51:                                ; CODE XREF: GoToLineDlg::run_dlgProc(uint,uint,long)+1CBj
.text$mn:00000F51                 mov     [ebp+var_1], 0
.text$mn:00000F55                 mov     [ebp+var_2], 1
.text$mn:00000F59                 mov     ecx, [ebp+this]
.text$mn:00000F5C                 mov     dword ptr [ecx+20h], 1
.text$mn:00000F63
.text$mn:00000F63 loc_F63:                                ; CODE XREF: GoToLineDlg::run_dlgProc(uint,uint,long)+1DFj
.text$mn:00000F63                 push    0               ; lParam
.text$mn:00000F65                 movzx   edx, [ebp+var_1]
.text$mn:00000F69                 push    edx             ; wParam
.text$mn:00000F6A                 push    0F1h ; '±'      ; Msg
.text$mn:00000F6F                 push    7D7h            ; nIDDlgItem
.text$mn:00000F74                 mov     eax, [ebp+this]
.text$mn:00000F77                 mov     ecx, [eax+0Ch]
.text$mn:00000F7A                 push    ecx             ; hDlg
.text$mn:00000F7B                 call    dword ptr ds:__imp__SendDlgItemMessageW@20 ; SendDlgItemMessageW(x,x,x,x,x)
.text$mn:00000F81                 push    0               ; lParam
.text$mn:00000F83                 movzx   edx, [ebp+var_2]
.text$mn:00000F87                 push    edx             ; wParam
.text$mn:00000F88                 push    0F1h ; '±'      ; Msg
.text$mn:00000F8D                 push    7D8h            ; nIDDlgItem
.text$mn:00000F92                 mov     eax, [ebp+this]
.text$mn:00000F95                 mov     ecx, [eax+0Ch]
.text$mn:00000F98                 push    ecx             ; hDlg
.text$mn:00000F99                 call    dword ptr ds:__imp__SendDlgItemMessageW@20 ; SendDlgItemMessageW(x,x,x,x,x)
.text$mn:00000F9F                 mov     ecx, [ebp+this] ; this
.text$mn:00000FA2                 call    ?updateLinesNumbers@GoToLineDlg@@ABEXXZ ; GoToLineDlg::updateLinesNumbers(void)
.text$mn:00000FA7                 mov     eax, 1
.text$mn:00000FAC                 jmp     short loc_FE9
.text$mn:00000FAE ; ---------------------------------------------------------------------------
.text$mn:00000FAE
.text$mn:00000FAE loc_FAE:                                ; CODE XREF: GoToLineDlg::run_dlgProc(uint,uint,long)+68j
.text$mn:00000FAE                                         ; GoToLineDlg::run_dlgProc(uint,uint,long)+74j ...
.text$mn:00000FAE                 mov     edx, [ebp+arg_8]
.text$mn:00000FB1                 shr     edx, 10h
.text$mn:00000FB4                 and     edx, 0FFFFh
.text$mn:00000FBA                 movzx   eax, dx
.text$mn:00000FBD                 mov     [ebp+var_14], eax
.text$mn:00000FC0                 cmp     [ebp+var_14], 6
.text$mn:00000FC4                 jz      short loc_FD1
.text$mn:00000FC6                 cmp     [ebp+var_14], 100h
.text$mn:00000FCD                 jz      short loc_FD1
.text$mn:00000FCF                 jmp     short loc_FE0
.text$mn:00000FD1 ; ---------------------------------------------------------------------------
.text$mn:00000FD1
.text$mn:00000FD1 loc_FD1:                                ; CODE XREF: GoToLineDlg::run_dlgProc(uint,uint,long)+254j
.text$mn:00000FD1                                         ; GoToLineDlg::run_dlgProc(uint,uint,long)+25Dj
.text$mn:00000FD1                 mov     ecx, [ebp+this] ; this
.text$mn:00000FD4                 call    ?updateLinesNumbers@GoToLineDlg@@ABEXXZ ; GoToLineDlg::updateLinesNumbers(void)
.text$mn:00000FD9                 mov     eax, 1
.text$mn:00000FDE                 jmp     short loc_FE9
.text$mn:00000FE0 ; ---------------------------------------------------------------------------
.text$mn:00000FE0
.text$mn:00000FE0 loc_FE0:                                ; CODE XREF: GoToLineDlg::run_dlgProc(uint,uint,long)+25Fj
.text$mn:00000FE0                 mov     eax, 1
.text$mn:00000FE5                 jmp     short loc_FE9
.text$mn:00000FE7 ; ---------------------------------------------------------------------------
.text$mn:00000FE7
.text$mn:00000FE7 loc_FE7:                                ; CODE XREF: GoToLineDlg::run_dlgProc(uint,uint,long)+1Ej
.text$mn:00000FE7                 xor     eax, eax
.text$mn:00000FE9
.text$mn:00000FE9 loc_FE9:                                ; CODE XREF: GoToLineDlg::run_dlgProc(uint,uint,long)+4Bj
.text$mn:00000FE9                                         ; GoToLineDlg::run_dlgProc(uint,uint,long)+A8j ...
.text$mn:00000FE9                 mov     esp, ebp
.text$mn:00000FEB                 pop     ebp
.text$mn:00000FEC                 retn    10h
.text$mn:00000FEC ?run_dlgProc@GoToLineDlg@@MAGHIIJ@Z endp
.text$mn:00000FEC
.text$mn:00000FEC ; ---------------------------------------------------------------------------
.text$mn:00000FEF                 align 10h
.text$mn:00000FF0
.text$mn:00000FF0 ; =============== S U B R O U T I N E =======================================
.text$mn:00000FF0
.text$mn:00000FF0 ; Attributes: bp-based frame
.text$mn:00000FF0
.text$mn:00000FF0 ; void __thiscall GoToLineDlg::updateLinesNumbers(GoToLineDlg *__hidden this)
.text$mn:00000FF0                 public ?updateLinesNumbers@GoToLineDlg@@ABEXXZ
.text$mn:00000FF0 ?updateLinesNumbers@GoToLineDlg@@ABEXXZ proc near
.text$mn:00000FF0                                         ; CODE XREF: GoToLineDlg::run_dlgProc(uint,uint,long)+232p
.text$mn:00000FF0                                         ; GoToLineDlg::run_dlgProc(uint,uint,long)+264p
.text$mn:00000FF0
.text$mn:00000FF0 var_C           = dword ptr -0Ch
.text$mn:00000FF0 uValue          = dword ptr -8
.text$mn:00000FF0 var_4           = dword ptr -4
.text$mn:00000FF0
.text$mn:00000FF0                 push    ebp
.text$mn:00000FF1                 mov     ebp, esp
.text$mn:00000FF3                 sub     esp, 0Ch
.text$mn:00000FF6                 mov     [ebp+var_4], ecx
.text$mn:00000FF9                 mov     [ebp+uValue], 0
.text$mn:00001000                 mov     [ebp+var_C], 0
.text$mn:00001007                 mov     eax, [ebp+var_4]
.text$mn:0000100A                 cmp     dword ptr [eax+20h], 0
.text$mn:0000100E                 jnz     short loc_103E
.text$mn:00001010                 mov     ecx, [ebp+var_4]
.text$mn:00001013                 mov     edx, [ecx+24h]
.text$mn:00001016                 mov     ecx, [edx]      ; this
.text$mn:00001018                 call    ?getCurrentLineNumber@ScintillaEditView@@QBEJXZ ; ScintillaEditView::getCurrentLineNumber(void)
.text$mn:0000101D                 add     eax, 1
.text$mn:00001020                 mov     [ebp+uValue], eax
.text$mn:00001023                 push    0               ; __int32
.text$mn:00001025                 push    0               ; unsigned int
.text$mn:00001027                 push    86Ah            ; unsigned int
.text$mn:0000102C                 mov     eax, [ebp+var_4]
.text$mn:0000102F                 mov     ecx, [eax+24h]
.text$mn:00001032                 mov     ecx, [ecx]      ; this
.text$mn:00001034                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00001039                 mov     [ebp+var_C], eax
.text$mn:0000103C                 jmp     short loc_106A
.text$mn:0000103E ; ---------------------------------------------------------------------------
.text$mn:0000103E
.text$mn:0000103E loc_103E:                               ; CODE XREF: GoToLineDlg::updateLinesNumbers(void)+1Ej
.text$mn:0000103E                 push    0               ; __int32
.text$mn:00001040                 push    0               ; unsigned int
.text$mn:00001042                 push    7D8h            ; unsigned int
.text$mn:00001047                 mov     edx, [ebp+var_4]
.text$mn:0000104A                 mov     eax, [edx+24h]
.text$mn:0000104D                 mov     ecx, [eax]      ; this
.text$mn:0000104F                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00001054                 mov     [ebp+uValue], eax
.text$mn:00001057                 mov     ecx, [ebp+var_4]
.text$mn:0000105A                 mov     edx, [ecx+24h]
.text$mn:0000105D                 mov     ecx, [edx]      ; this
.text$mn:0000105F                 call    ?getCurrentDocLen@ScintillaEditView@@QBEHXZ ; ScintillaEditView::getCurrentDocLen(void)
.text$mn:00001064                 sub     eax, 1
.text$mn:00001067                 mov     [ebp+var_C], eax
.text$mn:0000106A
.text$mn:0000106A loc_106A:                               ; CODE XREF: GoToLineDlg::updateLinesNumbers(void)+4Cj
.text$mn:0000106A                 push    0               ; bSigned
.text$mn:0000106C                 mov     eax, [ebp+uValue]
.text$mn:0000106F                 push    eax             ; uValue
.text$mn:00001070                 push    7D2h            ; nIDDlgItem
.text$mn:00001075                 mov     ecx, [ebp+var_4]
.text$mn:00001078                 mov     edx, [ecx+0Ch]
.text$mn:0000107B                 push    edx             ; hDlg
.text$mn:0000107C                 call    dword ptr ds:__imp__SetDlgItemInt@16 ; SetDlgItemInt(x,x,x,x)
.text$mn:00001082                 push    0               ; bSigned
.text$mn:00001084                 mov     eax, [ebp+var_C]
.text$mn:00001087                 push    eax             ; uValue
.text$mn:00001088                 push    7D3h            ; nIDDlgItem
.text$mn:0000108D                 mov     ecx, [ebp+var_4]
.text$mn:00001090                 mov     edx, [ecx+0Ch]
.text$mn:00001093                 push    edx             ; hDlg
.text$mn:00001094                 call    dword ptr ds:__imp__SetDlgItemInt@16 ; SetDlgItemInt(x,x,x,x)
.text$mn:0000109A                 mov     esp, ebp
.text$mn:0000109C                 pop     ebp
.text$mn:0000109D                 retn
.text$mn:0000109D ?updateLinesNumbers@GoToLineDlg@@ABEXXZ endp
.text$mn:0000109D
.text$mn:0000109D ; ---------------------------------------------------------------------------
.text$mn:0000109E                 align 10h
.text$mn:0000109E _text$mn        ends
.text$mn:0000109E
.text$mn:000010A0 ; ===========================================================================
.text$mn:000010A0
.text$mn:000010A0 ; Segment type: Pure code
.text$mn:000010A0 ; Segment permissions: Read/Execute
.text$mn:000010A0 _text$mn        segment para public 'CODE' use32
.text$mn:000010A0                 assume cs:_text$mn
.text$mn:000010A0                 ;org 10A0h
.text$mn:000010A0 ; COMDAT (pick any)
.text$mn:000010A0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000010A0
.text$mn:000010A0 ; =============== S U B R O U T I N E =======================================
.text$mn:000010A0
.text$mn:000010A0 ; Attributes: bp-based frame
.text$mn:000010A0
.text$mn:000010A0 ; char * __cdecl std::_Allocate<char>(unsigned int, char *)
.text$mn:000010A0                 public ??$_Allocate@D@std@@YAPADIPAD@Z
.text$mn:000010A0 ??$_Allocate@D@std@@YAPADIPAD@Z proc near
.text$mn:000010A0                                         ; CODE XREF: std::allocator<char>::allocate(uint)+Dp
.text$mn:000010A0
.text$mn:000010A0 var_4           = dword ptr -4
.text$mn:000010A0 arg_0           = dword ptr  8
.text$mn:000010A0
.text$mn:000010A0                 push    ebp
.text$mn:000010A1                 mov     ebp, esp
.text$mn:000010A3                 push    ecx
.text$mn:000010A4                 mov     [ebp+var_4], 0
.text$mn:000010AB                 cmp     [ebp+arg_0], 0
.text$mn:000010AF                 jnz     short loc_10B3
.text$mn:000010B1                 jmp     short loc_10D3
.text$mn:000010B3 ; ---------------------------------------------------------------------------
.text$mn:000010B3
.text$mn:000010B3 loc_10B3:                               ; CODE XREF: std::_Allocate<char>(uint,char *)+Fj
.text$mn:000010B3                 cmp     [ebp+arg_0], 0FFFFFFFFh
.text$mn:000010B7                 ja      short loc_10CE
.text$mn:000010B9                 mov     eax, [ebp+arg_0]
.text$mn:000010BC                 push    eax             ; unsigned int
.text$mn:000010BD                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:000010C2                 add     esp, 4
.text$mn:000010C5                 mov     [ebp+var_4], eax
.text$mn:000010C8                 cmp     [ebp+var_4], 0
.text$mn:000010CC                 jnz     short loc_10D3
.text$mn:000010CE
.text$mn:000010CE loc_10CE:                               ; CODE XREF: std::_Allocate<char>(uint,char *)+17j
.text$mn:000010CE                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:000010D3
.text$mn:000010D3 loc_10D3:                               ; CODE XREF: std::_Allocate<char>(uint,char *)+11j
.text$mn:000010D3                                         ; std::_Allocate<char>(uint,char *)+2Cj
.text$mn:000010D3                 mov     eax, [ebp+var_4]
.text$mn:000010D6                 mov     esp, ebp
.text$mn:000010D8                 pop     ebp
.text$mn:000010D9                 retn
.text$mn:000010D9 ??$_Allocate@D@std@@YAPADIPAD@Z endp
.text$mn:000010D9
.text$mn:000010D9 ; ---------------------------------------------------------------------------
.text$mn:000010DA                 align 4
.text$mn:000010DA _text$mn        ends
.text$mn:000010DA
.text$mn:000010DC ; ===========================================================================
.text$mn:000010DC
.text$mn:000010DC ; Segment type: Pure code
.text$mn:000010DC ; Segment permissions: Read/Execute
.text$mn:000010DC _text$mn        segment para public 'CODE' use32
.text$mn:000010DC                 assume cs:_text$mn
.text$mn:000010DC                 ;org 10DCh
.text$mn:000010DC ; COMDAT (pick any)
.text$mn:000010DC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000010DC
.text$mn:000010DC ; =============== S U B R O U T I N E =======================================
.text$mn:000010DC
.text$mn:000010DC ; Attributes: bp-based frame
.text$mn:000010DC
.text$mn:000010DC ; struct std::_Container_proxy * __cdecl std::_Allocate<struct std::_Container_proxy>(unsigned int, struct std::_Container_proxy *)
.text$mn:000010DC                 public ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z
.text$mn:000010DC ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z proc near
.text$mn:000010DC                                         ; CODE XREF: std::allocator<std::_Container_proxy>::allocate(uint)+Dp
.text$mn:000010DC
.text$mn:000010DC var_4           = dword ptr -4
.text$mn:000010DC arg_0           = dword ptr  8
.text$mn:000010DC
.text$mn:000010DC                 push    ebp
.text$mn:000010DD                 mov     ebp, esp
.text$mn:000010DF                 push    ecx
.text$mn:000010E0                 mov     [ebp+var_4], 0
.text$mn:000010E7                 cmp     [ebp+arg_0], 0
.text$mn:000010EB                 jnz     short loc_10EF
.text$mn:000010ED                 jmp     short loc_1115
.text$mn:000010EF ; ---------------------------------------------------------------------------
.text$mn:000010EF
.text$mn:000010EF loc_10EF:                               ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+Fj
.text$mn:000010EF                 cmp     [ebp+arg_0], 1FFFFFFFh
.text$mn:000010F6                 ja      short loc_1110
.text$mn:000010F8                 mov     eax, [ebp+arg_0]
.text$mn:000010FB                 shl     eax, 3
.text$mn:000010FE                 push    eax             ; unsigned int
.text$mn:000010FF                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00001104                 add     esp, 4
.text$mn:00001107                 mov     [ebp+var_4], eax
.text$mn:0000110A                 cmp     [ebp+var_4], 0
.text$mn:0000110E                 jnz     short loc_1115
.text$mn:00001110
.text$mn:00001110 loc_1110:                               ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+1Aj
.text$mn:00001110                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:00001115
.text$mn:00001115 loc_1115:                               ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+11j
.text$mn:00001115                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+32j
.text$mn:00001115                 mov     eax, [ebp+var_4]
.text$mn:00001118                 mov     esp, ebp
.text$mn:0000111A                 pop     ebp
.text$mn:0000111B                 retn
.text$mn:0000111B ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z endp
.text$mn:0000111B
.text$mn:0000111B _text$mn        ends
.text$mn:0000111B
.text$mn:0000111C ; ===========================================================================
.text$mn:0000111C
.text$mn:0000111C ; Segment type: Pure code
.text$mn:0000111C ; Segment permissions: Read/Execute
.text$mn:0000111C _text$mn        segment para public 'CODE' use32
.text$mn:0000111C                 assume cs:_text$mn
.text$mn:0000111C                 ;org 111Ch
.text$mn:0000111C ; COMDAT (pick any)
.text$mn:0000111C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000111C
.text$mn:0000111C ; =============== S U B R O U T I N E =======================================
.text$mn:0000111C
.text$mn:0000111C ; Attributes: bp-based frame
.text$mn:0000111C
.text$mn:0000111C ; int __cdecl std::_Debug_pointer<char>(int, wchar_t *, unsigned int)
.text$mn:0000111C                 public ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z
.text$mn:0000111C ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z proc near
.text$mn:0000111C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+15p
.text$mn:0000111C                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+1Bp
.text$mn:0000111C
.text$mn:0000111C arg_0           = dword ptr  8
.text$mn:0000111C arg_4           = dword ptr  0Ch
.text$mn:0000111C arg_8           = dword ptr  10h
.text$mn:0000111C
.text$mn:0000111C                 push    ebp
.text$mn:0000111D                 mov     ebp, esp
.text$mn:0000111F                 cmp     [ebp+arg_0], 0
.text$mn:00001123                 jnz     short loc_113A
.text$mn:00001125                 mov     eax, [ebp+arg_8]
.text$mn:00001128                 push    eax             ; unsigned int
.text$mn:00001129                 mov     ecx, [ebp+arg_4]
.text$mn:0000112C                 push    ecx             ; wchar_t *
.text$mn:0000112D                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:00001132                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00001137                 add     esp, 0Ch
.text$mn:0000113A
.text$mn:0000113A loc_113A:                               ; CODE XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+7j
.text$mn:0000113A                 pop     ebp
.text$mn:0000113B                 retn
.text$mn:0000113B ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z endp
.text$mn:0000113B
.text$mn:0000113B _text$mn        ends
.text$mn:0000113B
.text$mn:0000113C ; ===========================================================================
.text$mn:0000113C
.text$mn:0000113C ; Segment type: Pure code
.text$mn:0000113C ; Segment permissions: Read/Execute
.text$mn:0000113C _text$mn        segment para public 'CODE' use32
.text$mn:0000113C                 assume cs:_text$mn
.text$mn:0000113C                 ;org 113Ch
.text$mn:0000113C ; COMDAT (pick any)
.text$mn:0000113C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000113C
.text$mn:0000113C ; =============== S U B R O U T I N E =======================================
.text$mn:0000113C
.text$mn:0000113C ; Attributes: bp-based frame
.text$mn:0000113C
.text$mn:0000113C ; char * __cdecl std::addressof<char>(char &)
.text$mn:0000113C                 public ??$addressof@D@std@@YAPADAAD@Z
.text$mn:0000113C ??$addressof@D@std@@YAPADAAD@Z proc near
.text$mn:0000113C                                         ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+19p
.text$mn:0000113C                                         ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)+19p ...
.text$mn:0000113C
.text$mn:0000113C arg_0           = dword ptr  8
.text$mn:0000113C
.text$mn:0000113C                 push    ebp
.text$mn:0000113D                 mov     ebp, esp
.text$mn:0000113F                 mov     eax, [ebp+arg_0]
.text$mn:00001142                 pop     ebp
.text$mn:00001143                 retn
.text$mn:00001143 ??$addressof@D@std@@YAPADAAD@Z endp
.text$mn:00001143
.text$mn:00001143 _text$mn        ends
.text$mn:00001143
.text$mn:00001144 ; ===========================================================================
.text$mn:00001144
.text$mn:00001144 ; Segment type: Pure code
.text$mn:00001144 ; Segment permissions: Read/Execute
.text$mn:00001144 _text$mn        segment para public 'CODE' use32
.text$mn:00001144                 assume cs:_text$mn
.text$mn:00001144                 ;org 1144h
.text$mn:00001144 ; COMDAT (pick any)
.text$mn:00001144                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001144
.text$mn:00001144 ; =============== S U B R O U T I N E =======================================
.text$mn:00001144
.text$mn:00001144 ; Attributes: bp-based frame
.text$mn:00001144
.text$mn:00001144 ; int __stdcall std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(void *, int)
.text$mn:00001144                 public ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
.text$mn:00001144 ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z proc near
.text$mn:00001144                                         ; CODE XREF: $LN19+4Bp
.text$mn:00001144
.text$mn:00001144 var_4           = dword ptr -4
.text$mn:00001144 arg_0           = dword ptr  8
.text$mn:00001144 arg_4           = dword ptr  0Ch
.text$mn:00001144
.text$mn:00001144                 push    ebp
.text$mn:00001145                 mov     ebp, esp
.text$mn:00001147                 push    ecx
.text$mn:00001148                 mov     [ebp+var_4], ecx
.text$mn:0000114B                 mov     eax, [ebp+arg_4]
.text$mn:0000114E                 push    eax
.text$mn:0000114F                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:00001154                 add     esp, 4
.text$mn:00001157                 push    eax             ; int
.text$mn:00001158                 mov     ecx, [ebp+arg_0]
.text$mn:0000115B                 push    ecx             ; void *
.text$mn:0000115C                 mov     edx, [ebp+var_4]
.text$mn:0000115F                 push    edx             ; int
.text$mn:00001160                 call    ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(std::allocator<char> &,char * *,char * &)
.text$mn:00001165                 add     esp, 0Ch
.text$mn:00001168                 mov     esp, ebp
.text$mn:0000116A                 pop     ebp
.text$mn:0000116B                 retn    8
.text$mn:0000116B ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z endp
.text$mn:0000116B
.text$mn:0000116B ; ---------------------------------------------------------------------------
.text$mn:0000116E                 align 10h
.text$mn:0000116E _text$mn        ends
.text$mn:0000116E
.text$mn:00001170 ; ===========================================================================
.text$mn:00001170
.text$mn:00001170 ; Segment type: Pure code
.text$mn:00001170 ; Segment permissions: Read/Execute
.text$mn:00001170 _text$mn        segment para public 'CODE' use32
.text$mn:00001170                 assume cs:_text$mn
.text$mn:00001170                 ;org 1170h
.text$mn:00001170 ; COMDAT (pick any)
.text$mn:00001170                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001170
.text$mn:00001170 ; =============== S U B R O U T I N E =======================================
.text$mn:00001170
.text$mn:00001170 ; Attributes: bp-based frame
.text$mn:00001170
.text$mn:00001170 ; int __stdcall std::allocator<char>::construct<char *,char * &>(void *, int)
.text$mn:00001170                 public ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$mn:00001170 ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
.text$mn:00001170                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(std::allocator<char> &,char * *,char * &)+17p
.text$mn:00001170
.text$mn:00001170 var_1C          = dword ptr -1Ch
.text$mn:00001170 var_18          = dword ptr -18h
.text$mn:00001170 var_14          = dword ptr -14h
.text$mn:00001170 var_10          = dword ptr -10h
.text$mn:00001170 var_C           = dword ptr -0Ch
.text$mn:00001170 var_4           = dword ptr -4
.text$mn:00001170 arg_0           = dword ptr  8
.text$mn:00001170 arg_4           = dword ptr  0Ch
.text$mn:00001170
.text$mn:00001170                 push    ebp
.text$mn:00001171                 mov     ebp, esp
.text$mn:00001173                 push    0FFFFFFFFh
.text$mn:00001175                 push    offset __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$mn:0000117A                 mov     eax, large fs:0
.text$mn:00001180                 push    eax
.text$mn:00001181                 sub     esp, 10h
.text$mn:00001184                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001189                 xor     eax, ebp
.text$mn:0000118B                 push    eax
.text$mn:0000118C                 lea     eax, [ebp+var_C]
.text$mn:0000118F                 mov     large fs:0, eax
.text$mn:00001195                 mov     [ebp+var_18], ecx
.text$mn:00001198                 mov     eax, [ebp+arg_0]
.text$mn:0000119B                 push    eax             ; void *
.text$mn:0000119C                 push    4               ; unsigned int
.text$mn:0000119E                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:000011A3                 add     esp, 8
.text$mn:000011A6                 mov     [ebp+var_10], eax
.text$mn:000011A9                 mov     [ebp+var_4], 0
.text$mn:000011B0                 cmp     [ebp+var_10], 0
.text$mn:000011B4                 jz      short loc_11D1
.text$mn:000011B6                 mov     ecx, [ebp+arg_4]
.text$mn:000011B9                 push    ecx
.text$mn:000011BA                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:000011BF                 add     esp, 4
.text$mn:000011C2                 mov     edx, [ebp+var_10]
.text$mn:000011C5                 mov     eax, [eax]
.text$mn:000011C7                 mov     [edx], eax
.text$mn:000011C9                 mov     ecx, [ebp+var_10]
.text$mn:000011CC                 mov     [ebp+var_14], ecx
.text$mn:000011CF                 jmp     short loc_11D8
.text$mn:000011D1 ; ---------------------------------------------------------------------------
.text$mn:000011D1
.text$mn:000011D1 loc_11D1:                               ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+44j
.text$mn:000011D1                 mov     [ebp+var_14], 0
.text$mn:000011D8
.text$mn:000011D8 loc_11D8:                               ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+5Fj
.text$mn:000011D8                 mov     edx, [ebp+var_14]
.text$mn:000011DB                 mov     [ebp+var_1C], edx
.text$mn:000011DE                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000011E5                 mov     ecx, [ebp+var_C]
.text$mn:000011E8                 mov     large fs:0, ecx
.text$mn:000011EF                 pop     ecx
.text$mn:000011F0                 mov     esp, ebp
.text$mn:000011F2                 pop     ebp
.text$mn:000011F3                 retn    8
.text$mn:000011F3 ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp
.text$mn:000011F3
.text$mn:000011F3 ; ---------------------------------------------------------------------------
.text$mn:000011F6                 align 4
.text$mn:000011F6 _text$mn        ends
.text$mn:000011F6
.text$x:000011F8 ; ===========================================================================
.text$x:000011F8
.text$x:000011F8 ; Segment type: Pure code
.text$x:000011F8 ; Segment permissions: Read/Execute
.text$x:000011F8 _text$x         segment para public 'CODE' use32
.text$x:000011F8                 assume cs:_text$x
.text$x:000011F8                 ;org 11F8h
.text$x:000011F8 ; COMDAT (pick associative to section at 1170)
.text$x:000011F8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000011F8
.text$x:000011F8 ; =============== S U B R O U T I N E =======================================
.text$x:000011F8
.text$x:000011F8
.text$x:000011F8 __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 proc near
.text$x:000011F8                                         ; DATA XREF: .xdata$x:00002E50o
.text$x:000011F8                 mov     eax, [ebp+8]
.text$x:000011FB                 push    eax
.text$x:000011FC                 mov     eax, [ebp-10h]
.text$x:000011FF                 push    eax             ; void *
.text$x:00001200                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00001205                 add     esp, 8
.text$x:00001208                 retn
.text$x:00001208 __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 endp
.text$x:00001208
.text$x:00001209
.text$x:00001209 ; =============== S U B R O U T I N E =======================================
.text$x:00001209
.text$x:00001209
.text$x:00001209 __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
.text$x:00001209                                         ; DATA XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+5o
.text$x:00001209
.text$x:00001209 arg_4           = dword ptr  8
.text$x:00001209
.text$x:00001209                 mov     edx, [esp+arg_4]
.text$x:0000120D                 lea     eax, [edx+0Ch]
.text$x:00001210                 mov     ecx, [edx-14h]
.text$x:00001213                 xor     ecx, eax
.text$x:00001215                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000121A                 mov     eax, offset __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$x:0000121F                 jmp     ___CxxFrameHandler3
.text$x:0000121F __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp
.text$x:0000121F
.text$x:0000121F _text$x         ends
.text$x:0000121F
.text$mn:00001224 ; ===========================================================================
.text$mn:00001224
.text$mn:00001224 ; Segment type: Pure code
.text$mn:00001224 ; Segment permissions: Read/Execute
.text$mn:00001224 _text$mn        segment para public 'CODE' use32
.text$mn:00001224                 assume cs:_text$mn
.text$mn:00001224                 ;org 1224h
.text$mn:00001224 ; COMDAT (pick any)
.text$mn:00001224                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001224
.text$mn:00001224 ; =============== S U B R O U T I N E =======================================
.text$mn:00001224
.text$mn:00001224 ; Attributes: bp-based frame
.text$mn:00001224
.text$mn:00001224 ; int __cdecl std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(int, void *, int)
.text$mn:00001224                 public ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
.text$mn:00001224 ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z proc near
.text$mn:00001224                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)+1Cp
.text$mn:00001224
.text$mn:00001224 arg_0           = dword ptr  8
.text$mn:00001224 arg_4           = dword ptr  0Ch
.text$mn:00001224 arg_8           = dword ptr  10h
.text$mn:00001224
.text$mn:00001224                 push    ebp
.text$mn:00001225                 mov     ebp, esp
.text$mn:00001227                 mov     eax, [ebp+arg_8]
.text$mn:0000122A                 push    eax
.text$mn:0000122B                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:00001230                 add     esp, 4
.text$mn:00001233                 push    eax             ; int
.text$mn:00001234                 mov     ecx, [ebp+arg_4]
.text$mn:00001237                 push    ecx             ; void *
.text$mn:00001238                 mov     ecx, [ebp+arg_0]
.text$mn:0000123B                 call    ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)
.text$mn:00001240                 pop     ebp
.text$mn:00001241                 retn
.text$mn:00001241 ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z endp
.text$mn:00001241
.text$mn:00001241 ; ---------------------------------------------------------------------------
.text$mn:00001242                 align 4
.text$mn:00001242 _text$mn        ends
.text$mn:00001242
.text$mn:00001244 ; ===========================================================================
.text$mn:00001244
.text$mn:00001244 ; Segment type: Pure code
.text$mn:00001244 ; Segment permissions: Read/Execute
.text$mn:00001244 _text$mn        segment para public 'CODE' use32
.text$mn:00001244                 assume cs:_text$mn
.text$mn:00001244                 ;org 1244h
.text$mn:00001244 ; COMDAT (pick any)
.text$mn:00001244                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001244
.text$mn:00001244 ; =============== S U B R O U T I N E =======================================
.text$mn:00001244
.text$mn:00001244 ; Attributes: bp-based frame
.text$mn:00001244
.text$mn:00001244 ; int __stdcall std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(void *, int)
.text$mn:00001244                 public ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:00001244 ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$mn:00001244                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+32p
.text$mn:00001244
.text$mn:00001244 var_1C          = dword ptr -1Ch
.text$mn:00001244 var_18          = dword ptr -18h
.text$mn:00001244 var_14          = dword ptr -14h
.text$mn:00001244 var_10          = dword ptr -10h
.text$mn:00001244 var_C           = dword ptr -0Ch
.text$mn:00001244 var_4           = dword ptr -4
.text$mn:00001244 arg_0           = dword ptr  8
.text$mn:00001244 arg_4           = dword ptr  0Ch
.text$mn:00001244
.text$mn:00001244                 push    ebp
.text$mn:00001245                 mov     ebp, esp
.text$mn:00001247                 push    0FFFFFFFFh
.text$mn:00001249                 push    offset __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:0000124E                 mov     eax, large fs:0
.text$mn:00001254                 push    eax
.text$mn:00001255                 sub     esp, 10h
.text$mn:00001258                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000125D                 xor     eax, ebp
.text$mn:0000125F                 push    eax
.text$mn:00001260                 lea     eax, [ebp+var_C]
.text$mn:00001263                 mov     large fs:0, eax
.text$mn:00001269                 mov     [ebp+var_18], ecx
.text$mn:0000126C                 mov     eax, [ebp+arg_0]
.text$mn:0000126F                 push    eax             ; void *
.text$mn:00001270                 push    8               ; unsigned int
.text$mn:00001272                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00001277                 add     esp, 8
.text$mn:0000127A                 mov     [ebp+var_10], eax
.text$mn:0000127D                 mov     [ebp+var_4], 0
.text$mn:00001284                 cmp     [ebp+var_10], 0
.text$mn:00001288                 jz      short loc_12AB
.text$mn:0000128A                 mov     ecx, [ebp+arg_4]
.text$mn:0000128D                 push    ecx
.text$mn:0000128E                 call    ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>(std::_Container_proxy &)
.text$mn:00001293                 add     esp, 4
.text$mn:00001296                 mov     edx, [eax]
.text$mn:00001298                 mov     eax, [eax+4]
.text$mn:0000129B                 mov     ecx, [ebp+var_10]
.text$mn:0000129E                 mov     [ecx], edx
.text$mn:000012A0                 mov     [ecx+4], eax
.text$mn:000012A3                 mov     edx, [ebp+var_10]
.text$mn:000012A6                 mov     [ebp+var_14], edx
.text$mn:000012A9                 jmp     short loc_12B2
.text$mn:000012AB ; ---------------------------------------------------------------------------
.text$mn:000012AB
.text$mn:000012AB loc_12AB:                               ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+44j
.text$mn:000012AB                 mov     [ebp+var_14], 0
.text$mn:000012B2
.text$mn:000012B2 loc_12B2:                               ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+65j
.text$mn:000012B2                 mov     eax, [ebp+var_14]
.text$mn:000012B5                 mov     [ebp+var_1C], eax
.text$mn:000012B8                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000012BF                 mov     ecx, [ebp+var_C]
.text$mn:000012C2                 mov     large fs:0, ecx
.text$mn:000012C9                 pop     ecx
.text$mn:000012CA                 mov     esp, ebp
.text$mn:000012CC                 pop     ebp
.text$mn:000012CD                 retn    8
.text$mn:000012CD ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$mn:000012CD
.text$mn:000012CD _text$mn        ends
.text$mn:000012CD
.text$x:000012D0 ; ===========================================================================
.text$x:000012D0
.text$x:000012D0 ; Segment type: Pure code
.text$x:000012D0 ; Segment permissions: Read/Execute
.text$x:000012D0 _text$x         segment para public 'CODE' use32
.text$x:000012D0                 assume cs:_text$x
.text$x:000012D0                 ;org 12D0h
.text$x:000012D0 ; COMDAT (pick associative to section at 1244)
.text$x:000012D0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000012D0
.text$x:000012D0 ; =============== S U B R O U T I N E =======================================
.text$x:000012D0
.text$x:000012D0
.text$x:000012D0 __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 proc near
.text$x:000012D0                                         ; DATA XREF: .xdata$x:00002E24o
.text$x:000012D0                 mov     eax, [ebp+8]
.text$x:000012D3                 push    eax
.text$x:000012D4                 mov     eax, [ebp-10h]
.text$x:000012D7                 push    eax             ; void *
.text$x:000012D8                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:000012DD                 add     esp, 8
.text$x:000012E0                 retn
.text$x:000012E0 __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 endp
.text$x:000012E0
.text$x:000012E1
.text$x:000012E1 ; =============== S U B R O U T I N E =======================================
.text$x:000012E1
.text$x:000012E1
.text$x:000012E1 __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$x:000012E1                                         ; DATA XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+5o
.text$x:000012E1
.text$x:000012E1 arg_4           = dword ptr  8
.text$x:000012E1
.text$x:000012E1                 mov     edx, [esp+arg_4]
.text$x:000012E5                 lea     eax, [edx+0Ch]
.text$x:000012E8                 mov     ecx, [edx-14h]
.text$x:000012EB                 xor     ecx, eax
.text$x:000012ED                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000012F2                 mov     eax, offset __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$x:000012F7                 jmp     ___CxxFrameHandler3
.text$x:000012F7 __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$x:000012F7
.text$x:000012F7 _text$x         ends
.text$x:000012F7
.text$mn:000012FC ; ===========================================================================
.text$mn:000012FC
.text$mn:000012FC ; Segment type: Pure code
.text$mn:000012FC ; Segment permissions: Read/Execute
.text$mn:000012FC _text$mn        segment para public 'CODE' use32
.text$mn:000012FC                 assume cs:_text$mn
.text$mn:000012FC                 ;org 12FCh
.text$mn:000012FC ; COMDAT (pick any)
.text$mn:000012FC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000012FC
.text$mn:000012FC ; =============== S U B R O U T I N E =======================================
.text$mn:000012FC
.text$mn:000012FC ; Attributes: bp-based frame
.text$mn:000012FC
.text$mn:000012FC ; public: void __thiscall std::_Wrap_alloc<class std::allocator<char>>::destroy<char *>(char * *)
.text$mn:000012FC                 public ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
.text$mn:000012FC ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z proc near
.text$mn:000012FC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+3Ap
.text$mn:000012FC
.text$mn:000012FC var_4           = dword ptr -4
.text$mn:000012FC arg_0           = dword ptr  8
.text$mn:000012FC
.text$mn:000012FC                 push    ebp
.text$mn:000012FD                 mov     ebp, esp
.text$mn:000012FF                 push    ecx
.text$mn:00001300                 mov     [ebp+var_4], ecx
.text$mn:00001303                 mov     eax, [ebp+arg_0]
.text$mn:00001306                 push    eax
.text$mn:00001307                 mov     ecx, [ebp+var_4]
.text$mn:0000130A                 push    ecx
.text$mn:0000130B                 call    ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char * *)
.text$mn:00001310                 add     esp, 8
.text$mn:00001313                 mov     esp, ebp
.text$mn:00001315                 pop     ebp
.text$mn:00001316                 retn    4
.text$mn:00001316 ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z endp
.text$mn:00001316
.text$mn:00001316 ; ---------------------------------------------------------------------------
.text$mn:00001319                 align 4
.text$mn:00001319 _text$mn        ends
.text$mn:00001319
.text$mn:0000131C ; ===========================================================================
.text$mn:0000131C
.text$mn:0000131C ; Segment type: Pure code
.text$mn:0000131C ; Segment permissions: Read/Execute
.text$mn:0000131C _text$mn        segment para public 'CODE' use32
.text$mn:0000131C                 assume cs:_text$mn
.text$mn:0000131C                 ;org 131Ch
.text$mn:0000131C ; COMDAT (pick any)
.text$mn:0000131C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000131C
.text$mn:0000131C ; =============== S U B R O U T I N E =======================================
.text$mn:0000131C
.text$mn:0000131C ; Attributes: bp-based frame
.text$mn:0000131C
.text$mn:0000131C ; public: void __thiscall std::allocator<char>::destroy<char *>(char * *)
.text$mn:0000131C                 public ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
.text$mn:0000131C ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z proc near
.text$mn:0000131C                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char * *)+Ap
.text$mn:0000131C
.text$mn:0000131C var_4           = dword ptr -4
.text$mn:0000131C
.text$mn:0000131C                 push    ebp
.text$mn:0000131D                 mov     ebp, esp
.text$mn:0000131F                 push    ecx
.text$mn:00001320                 mov     [ebp+var_4], ecx
.text$mn:00001323                 mov     esp, ebp
.text$mn:00001325                 pop     ebp
.text$mn:00001326                 retn    4
.text$mn:00001326 ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z endp
.text$mn:00001326
.text$mn:00001326 ; ---------------------------------------------------------------------------
.text$mn:00001329                 align 4
.text$mn:00001329 _text$mn        ends
.text$mn:00001329
.text$mn:0000132C ; ===========================================================================
.text$mn:0000132C
.text$mn:0000132C ; Segment type: Pure code
.text$mn:0000132C ; Segment permissions: Read/Execute
.text$mn:0000132C _text$mn        segment para public 'CODE' use32
.text$mn:0000132C                 assume cs:_text$mn
.text$mn:0000132C                 ;org 132Ch
.text$mn:0000132C ; COMDAT (pick any)
.text$mn:0000132C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000132C
.text$mn:0000132C ; =============== S U B R O U T I N E =======================================
.text$mn:0000132C
.text$mn:0000132C ; Attributes: bp-based frame
.text$mn:0000132C
.text$mn:0000132C ; public: static void __cdecl std::allocator_traits<class std::allocator<char>>::destroy<char *>(class std::allocator<char> &, char * *)
.text$mn:0000132C                 public ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
.text$mn:0000132C ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z proc near
.text$mn:0000132C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)+Fp
.text$mn:0000132C
.text$mn:0000132C arg_0           = dword ptr  8
.text$mn:0000132C arg_4           = dword ptr  0Ch
.text$mn:0000132C
.text$mn:0000132C                 push    ebp
.text$mn:0000132D                 mov     ebp, esp
.text$mn:0000132F                 mov     eax, [ebp+arg_4]
.text$mn:00001332                 push    eax
.text$mn:00001333                 mov     ecx, [ebp+arg_0]
.text$mn:00001336                 call    ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ; std::allocator<char>::destroy<char *>(char * *)
.text$mn:0000133B                 pop     ebp
.text$mn:0000133C                 retn
.text$mn:0000133C ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z endp
.text$mn:0000133C
.text$mn:0000133C ; ---------------------------------------------------------------------------
.text$mn:0000133D                 align 10h
.text$mn:0000133D _text$mn        ends
.text$mn:0000133D
.text$mn:00001340 ; ===========================================================================
.text$mn:00001340
.text$mn:00001340 ; Segment type: Pure code
.text$mn:00001340 ; Segment permissions: Read/Execute
.text$mn:00001340 _text$mn        segment para public 'CODE' use32
.text$mn:00001340                 assume cs:_text$mn
.text$mn:00001340                 ;org 1340h
.text$mn:00001340 ; COMDAT (pick any)
.text$mn:00001340                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001340
.text$mn:00001340 ; =============== S U B R O U T I N E =======================================
.text$mn:00001340
.text$mn:00001340 ; Attributes: bp-based frame
.text$mn:00001340
.text$mn:00001340 ; public: void __thiscall std::allocator<struct std::_Container_proxy>::destroy<struct std::_Container_proxy>(struct std::_Container_proxy *)
.text$mn:00001340                 public ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z
.text$mn:00001340 ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z proc near
.text$mn:00001340                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+22p
.text$mn:00001340
.text$mn:00001340 var_4           = dword ptr -4
.text$mn:00001340
.text$mn:00001340                 push    ebp
.text$mn:00001341                 mov     ebp, esp
.text$mn:00001343                 push    ecx
.text$mn:00001344                 mov     [ebp+var_4], ecx
.text$mn:00001347                 mov     esp, ebp
.text$mn:00001349                 pop     ebp
.text$mn:0000134A                 retn    4
.text$mn:0000134A ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z endp
.text$mn:0000134A
.text$mn:0000134A ; ---------------------------------------------------------------------------
.text$mn:0000134D                 align 10h
.text$mn:0000134D _text$mn        ends
.text$mn:0000134D
.text$mn:00001350 ; ===========================================================================
.text$mn:00001350
.text$mn:00001350 ; Segment type: Pure code
.text$mn:00001350 ; Segment permissions: Read/Execute
.text$mn:00001350 _text$mn        segment para public 'CODE' use32
.text$mn:00001350                 assume cs:_text$mn
.text$mn:00001350                 ;org 1350h
.text$mn:00001350 ; COMDAT (pick any)
.text$mn:00001350                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001350
.text$mn:00001350 ; =============== S U B R O U T I N E =======================================
.text$mn:00001350
.text$mn:00001350 ; Attributes: bp-based frame
.text$mn:00001350
.text$mn:00001350 ; char * & __cdecl std::forward<char * &>(char * &)
.text$mn:00001350                 public ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
.text$mn:00001350 ??$forward@AAPAD@std@@YAAAPADAAPAD@Z proc near
.text$mn:00001350                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)+Bp
.text$mn:00001350                                         ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)+4Ap ...
.text$mn:00001350
.text$mn:00001350 arg_0           = dword ptr  8
.text$mn:00001350
.text$mn:00001350                 push    ebp
.text$mn:00001351                 mov     ebp, esp
.text$mn:00001353                 mov     eax, [ebp+arg_0]
.text$mn:00001356                 pop     ebp
.text$mn:00001357                 retn
.text$mn:00001357 ??$forward@AAPAD@std@@YAAAPADAAPAD@Z endp
.text$mn:00001357
.text$mn:00001357 _text$mn        ends
.text$mn:00001357
.text$mn:00001358 ; ===========================================================================
.text$mn:00001358
.text$mn:00001358 ; Segment type: Pure code
.text$mn:00001358 ; Segment permissions: Read/Execute
.text$mn:00001358 _text$mn        segment para public 'CODE' use32
.text$mn:00001358                 assume cs:_text$mn
.text$mn:00001358                 ;org 1358h
.text$mn:00001358 ; COMDAT (pick any)
.text$mn:00001358                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001358
.text$mn:00001358 ; =============== S U B R O U T I N E =======================================
.text$mn:00001358
.text$mn:00001358 ; Attributes: bp-based frame
.text$mn:00001358
.text$mn:00001358 ; struct std::_Container_proxy && __cdecl std::forward<struct std::_Container_proxy>(struct std::_Container_proxy &)
.text$mn:00001358                 public ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z
.text$mn:00001358 ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z proc near
.text$mn:00001358                                         ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+4Ap
.text$mn:00001358
.text$mn:00001358 arg_0           = dword ptr  8
.text$mn:00001358
.text$mn:00001358                 push    ebp
.text$mn:00001359                 mov     ebp, esp
.text$mn:0000135B                 mov     eax, [ebp+arg_0]
.text$mn:0000135E                 pop     ebp
.text$mn:0000135F                 retn
.text$mn:0000135F ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z endp
.text$mn:0000135F
.text$mn:0000135F _text$mn        ends
.text$mn:0000135F
.text$mn:00001360 ; ===========================================================================
.text$mn:00001360
.text$mn:00001360 ; Segment type: Pure code
.text$mn:00001360 ; Segment permissions: Read/Execute
.text$mn:00001360 _text$mn        segment para public 'CODE' use32
.text$mn:00001360                 assume cs:_text$mn
.text$mn:00001360                 ;org 1360h
.text$mn:00001360 ; COMDAT (pick any)
.text$mn:00001360                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001360
.text$mn:00001360 ; =============== S U B R O U T I N E =======================================
.text$mn:00001360
.text$mn:00001360 ; Attributes: bp-based frame
.text$mn:00001360
.text$mn:00001360 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>(class std::allocator<char> const &)
.text$mn:00001360                 public ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$mn:00001360 ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
.text$mn:00001360                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+34p
.text$mn:00001360
.text$mn:00001360 var_10          = dword ptr -10h
.text$mn:00001360 var_C           = dword ptr -0Ch
.text$mn:00001360 var_4           = dword ptr -4
.text$mn:00001360
.text$mn:00001360                 push    ebp
.text$mn:00001361                 mov     ebp, esp
.text$mn:00001363                 push    0FFFFFFFFh
.text$mn:00001365                 push    offset __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$mn:0000136A                 mov     eax, large fs:0
.text$mn:00001370                 push    eax
.text$mn:00001371                 push    ecx
.text$mn:00001372                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001377                 xor     eax, ebp
.text$mn:00001379                 push    eax
.text$mn:0000137A                 lea     eax, [ebp+var_C]
.text$mn:0000137D                 mov     large fs:0, eax
.text$mn:00001383                 mov     [ebp+var_10], ecx
.text$mn:00001386                 mov     ecx, [ebp+var_10]
.text$mn:00001389                 call    ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)
.text$mn:0000138E                 mov     [ebp+var_4], 0
.text$mn:00001395                 mov     ecx, [ebp+var_10]
.text$mn:00001398                 call    ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)
.text$mn:0000139D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000013A4                 mov     eax, [ebp+var_10]
.text$mn:000013A7                 mov     ecx, [ebp+var_C]
.text$mn:000013AA                 mov     large fs:0, ecx
.text$mn:000013B1                 pop     ecx
.text$mn:000013B2                 mov     esp, ebp
.text$mn:000013B4                 pop     ebp
.text$mn:000013B5                 retn    4
.text$mn:000013B5 ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp
.text$mn:000013B5
.text$mn:000013B5 _text$mn        ends
.text$mn:000013B5
.text$x:000013B8 ; ===========================================================================
.text$x:000013B8
.text$x:000013B8 ; Segment type: Pure code
.text$x:000013B8 ; Segment permissions: Read/Execute
.text$x:000013B8 _text$x         segment para public 'CODE' use32
.text$x:000013B8                 assume cs:_text$x
.text$x:000013B8                 ;org 13B8h
.text$x:000013B8 ; COMDAT (pick associative to section at 1360)
.text$x:000013B8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000013B8
.text$x:000013B8 ; =============== S U B R O U T I N E =======================================
.text$x:000013B8
.text$x:000013B8
.text$x:000013B8 __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 proc near
.text$x:000013B8                                         ; DATA XREF: .xdata$x:00002B5Co
.text$x:000013B8                 mov     ecx, [ebp-10h]
.text$x:000013BB                 jmp     ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$x:000013BB __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 endp
.text$x:000013BB
.text$x:000013C0
.text$x:000013C0 ; =============== S U B R O U T I N E =======================================
.text$x:000013C0
.text$x:000013C0
.text$x:000013C0 __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
.text$x:000013C0                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+5o
.text$x:000013C0
.text$x:000013C0 arg_4           = dword ptr  8
.text$x:000013C0
.text$x:000013C0                 mov     edx, [esp+arg_4]
.text$x:000013C4                 lea     eax, [edx+0Ch]
.text$x:000013C7                 mov     ecx, [edx-8]
.text$x:000013CA                 xor     ecx, eax
.text$x:000013CC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000013D1                 mov     eax, offset __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$x:000013D6                 jmp     ___CxxFrameHandler3
.text$x:000013D6 __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp
.text$x:000013D6
.text$x:000013D6 ; ---------------------------------------------------------------------------
.text$x:000013DB                 align 4
.text$x:000013DB _text$x         ends
.text$x:000013DB
.text$mn:000013DC ; ===========================================================================
.text$mn:000013DC
.text$mn:000013DC ; Segment type: Pure code
.text$mn:000013DC ; Segment permissions: Read/Execute
.text$mn:000013DC _text$mn        segment para public 'CODE' use32
.text$mn:000013DC                 assume cs:_text$mn
.text$mn:000013DC                 ;org 13DCh
.text$mn:000013DC ; COMDAT (pick any)
.text$mn:000013DC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000013DC
.text$mn:000013DC ; =============== S U B R O U T I N E =======================================
.text$mn:000013DC
.text$mn:000013DC ; Attributes: bp-based frame
.text$mn:000013DC
.text$mn:000013DC ; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::_String_val<struct std::_Simple_types<char>>(void)
.text$mn:000013DC                 public ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:000013DC ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$mn:000013DC                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+29p
.text$mn:000013DC
.text$mn:000013DC var_10          = dword ptr -10h
.text$mn:000013DC var_C           = dword ptr -0Ch
.text$mn:000013DC var_4           = dword ptr -4
.text$mn:000013DC
.text$mn:000013DC                 push    ebp
.text$mn:000013DD                 mov     ebp, esp
.text$mn:000013DF                 push    0FFFFFFFFh
.text$mn:000013E1                 push    offset __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:000013E6                 mov     eax, large fs:0
.text$mn:000013EC                 push    eax
.text$mn:000013ED                 push    ecx
.text$mn:000013EE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000013F3                 xor     eax, ebp
.text$mn:000013F5                 push    eax
.text$mn:000013F6                 lea     eax, [ebp+var_C]
.text$mn:000013F9                 mov     large fs:0, eax
.text$mn:000013FF                 mov     [ebp+var_10], ecx
.text$mn:00001402                 mov     ecx, [ebp+var_10] ; this
.text$mn:00001405                 call    ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
.text$mn:0000140A                 mov     [ebp+var_4], 0
.text$mn:00001411                 mov     eax, [ebp+var_10]
.text$mn:00001414                 mov     dword ptr [eax+14h], 0
.text$mn:0000141B                 mov     ecx, [ebp+var_10]
.text$mn:0000141E                 mov     dword ptr [ecx+18h], 0
.text$mn:00001425                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000142C                 mov     eax, [ebp+var_10]
.text$mn:0000142F                 mov     ecx, [ebp+var_C]
.text$mn:00001432                 mov     large fs:0, ecx
.text$mn:00001439                 pop     ecx
.text$mn:0000143A                 mov     esp, ebp
.text$mn:0000143C                 pop     ebp
.text$mn:0000143D                 retn
.text$mn:0000143D ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$mn:0000143D
.text$mn:0000143D ; ---------------------------------------------------------------------------
.text$mn:0000143E                 align 10h
.text$mn:0000143E _text$mn        ends
.text$mn:0000143E
.text$x:00001440 ; ===========================================================================
.text$x:00001440
.text$x:00001440 ; Segment type: Pure code
.text$x:00001440 ; Segment permissions: Read/Execute
.text$x:00001440 _text$x         segment para public 'CODE' use32
.text$x:00001440                 assume cs:_text$x
.text$x:00001440                 ;org 1440h
.text$x:00001440 ; COMDAT (pick associative to section at 13DC)
.text$x:00001440                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00001440
.text$x:00001440 ; =============== S U B R O U T I N E =======================================
.text$x:00001440
.text$x:00001440
.text$x:00001440 __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 proc near
.text$x:00001440                                         ; DATA XREF: .xdata$x:00002B04o
.text$x:00001440                 mov     ecx, [ebp-10h]  ; this
.text$x:00001443                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00001443 __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 endp
.text$x:00001443
.text$x:00001448
.text$x:00001448 ; =============== S U B R O U T I N E =======================================
.text$x:00001448
.text$x:00001448
.text$x:00001448 __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$x:00001448                                         ; DATA XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+5o
.text$x:00001448
.text$x:00001448 arg_4           = dword ptr  8
.text$x:00001448
.text$x:00001448                 mov     edx, [esp+arg_4]
.text$x:0000144C                 lea     eax, [edx+0Ch]
.text$x:0000144F                 mov     ecx, [edx-8]
.text$x:00001452                 xor     ecx, eax
.text$x:00001454                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001459                 mov     eax, offset __ehfuncinfo$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$x:0000145E                 jmp     ___CxxFrameHandler3
.text$x:0000145E __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$x:0000145E
.text$x:0000145E ; ---------------------------------------------------------------------------
.text$x:00001463                 align 4
.text$x:00001463 _text$x         ends
.text$x:00001463
.text$mn:00001464 ; ===========================================================================
.text$mn:00001464
.text$mn:00001464 ; Segment type: Pure code
.text$mn:00001464 ; Segment permissions: Read/Execute
.text$mn:00001464 _text$mn        segment para public 'CODE' use32
.text$mn:00001464                 assume cs:_text$mn
.text$mn:00001464                 ;org 1464h
.text$mn:00001464 ; COMDAT (pick any)
.text$mn:00001464                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001464
.text$mn:00001464 ; =============== S U B R O U T I N E =======================================
.text$mn:00001464
.text$mn:00001464 ; Attributes: bp-based frame
.text$mn:00001464
.text$mn:00001464 ; public: __thiscall std::_Wrap_alloc<class std::allocator<char>>::_Wrap_alloc<class std::allocator<char>>(void)
.text$mn:00001464                 public ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
.text$mn:00001464 ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ proc near
.text$mn:00001464                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)+Ap
.text$mn:00001464
.text$mn:00001464 var_4           = dword ptr -4
.text$mn:00001464
.text$mn:00001464                 push    ebp
.text$mn:00001465                 mov     ebp, esp
.text$mn:00001467                 push    ecx
.text$mn:00001468                 mov     [ebp+var_4], ecx
.text$mn:0000146B                 mov     ecx, [ebp+var_4]
.text$mn:0000146E                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:00001473                 mov     eax, [ebp+var_4]
.text$mn:00001476                 mov     esp, ebp
.text$mn:00001478                 pop     ebp
.text$mn:00001479                 retn
.text$mn:00001479 ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ endp
.text$mn:00001479
.text$mn:00001479 ; ---------------------------------------------------------------------------
.text$mn:0000147A                 align 4
.text$mn:0000147A _text$mn        ends
.text$mn:0000147A
.text$mn:0000147C ; ===========================================================================
.text$mn:0000147C
.text$mn:0000147C ; Segment type: Pure code
.text$mn:0000147C ; Segment permissions: Read/Execute
.text$mn:0000147C _text$mn        segment para public 'CODE' use32
.text$mn:0000147C                 assume cs:_text$mn
.text$mn:0000147C                 ;org 147Ch
.text$mn:0000147C ; COMDAT (pick any)
.text$mn:0000147C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000147C
.text$mn:0000147C ; =============== S U B R O U T I N E =======================================
.text$mn:0000147C
.text$mn:0000147C ; Attributes: bp-based frame
.text$mn:0000147C
.text$mn:0000147C ; public: __thiscall std::allocator<char>::allocator<char>(void)
.text$mn:0000147C                 public ??0?$allocator@D@std@@QAE@XZ
.text$mn:0000147C ??0?$allocator@D@std@@QAE@XZ proc near  ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)+Ap
.text$mn:0000147C                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+2Bp
.text$mn:0000147C
.text$mn:0000147C var_4           = dword ptr -4
.text$mn:0000147C
.text$mn:0000147C                 push    ebp
.text$mn:0000147D                 mov     ebp, esp
.text$mn:0000147F                 push    ecx
.text$mn:00001480                 mov     [ebp+var_4], ecx
.text$mn:00001483                 mov     eax, [ebp+var_4]
.text$mn:00001486                 mov     esp, ebp
.text$mn:00001488                 pop     ebp
.text$mn:00001489                 retn
.text$mn:00001489 ??0?$allocator@D@std@@QAE@XZ endp
.text$mn:00001489
.text$mn:00001489 ; ---------------------------------------------------------------------------
.text$mn:0000148A                 align 4
.text$mn:0000148A _text$mn        ends
.text$mn:0000148A
.text$mn:0000148C ; ===========================================================================
.text$mn:0000148C
.text$mn:0000148C ; Segment type: Pure code
.text$mn:0000148C ; Segment permissions: Read/Execute
.text$mn:0000148C _text$mn        segment para public 'CODE' use32
.text$mn:0000148C                 assume cs:_text$mn
.text$mn:0000148C                 ;org 148Ch
.text$mn:0000148C ; COMDAT (pick any)
.text$mn:0000148C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000148C
.text$mn:0000148C ; =============== S U B R O U T I N E =======================================
.text$mn:0000148C
.text$mn:0000148C ; Attributes: bp-based frame
.text$mn:0000148C
.text$mn:0000148C ; public: __thiscall std::allocator<struct std::_Container_proxy>::allocator<struct std::_Container_proxy>(void)
.text$mn:0000148C                 public ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ
.text$mn:0000148C ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ proc near
.text$mn:0000148C                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+Cp
.text$mn:0000148C                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+Cp
.text$mn:0000148C
.text$mn:0000148C var_4           = dword ptr -4
.text$mn:0000148C
.text$mn:0000148C                 push    ebp
.text$mn:0000148D                 mov     ebp, esp
.text$mn:0000148F                 push    ecx
.text$mn:00001490                 mov     [ebp+var_4], ecx
.text$mn:00001493                 mov     eax, [ebp+var_4]
.text$mn:00001496                 mov     esp, ebp
.text$mn:00001498                 pop     ebp
.text$mn:00001499                 retn
.text$mn:00001499 ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ endp
.text$mn:00001499
.text$mn:00001499 ; ---------------------------------------------------------------------------
.text$mn:0000149A                 align 4
.text$mn:0000149A _text$mn        ends
.text$mn:0000149A
.text$mn:0000149C ; ===========================================================================
.text$mn:0000149C
.text$mn:0000149C ; Segment type: Pure code
.text$mn:0000149C ; Segment permissions: Read/Execute
.text$mn:0000149C _text$mn        segment para public 'CODE' use32
.text$mn:0000149C                 assume cs:_text$mn
.text$mn:0000149C                 ;org 149Ch
.text$mn:0000149C ; COMDAT (pick any)
.text$mn:0000149C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000149C
.text$mn:0000149C ; =============== S U B R O U T I N E =======================================
.text$mn:0000149C
.text$mn:0000149C ; Attributes: bp-based frame
.text$mn:0000149C
.text$mn:0000149C ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char *Str)
.text$mn:0000149C                 public ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$mn:0000149C ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
.text$mn:0000149C                                         ; CODE XREF: std::_Generic_error_category::message(int)+5Ap
.text$mn:0000149C                                         ; std::_Iostream_error_category::message(int)+3Dp ...
.text$mn:0000149C
.text$mn:0000149C var_14          = dword ptr -14h
.text$mn:0000149C var_D           = byte ptr -0Dh
.text$mn:0000149C var_C           = dword ptr -0Ch
.text$mn:0000149C var_4           = dword ptr -4
.text$mn:0000149C Str             = dword ptr  8
.text$mn:0000149C
.text$mn:0000149C                 push    ebp
.text$mn:0000149D                 mov     ebp, esp
.text$mn:0000149F                 push    0FFFFFFFFh
.text$mn:000014A1                 push    offset __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$mn:000014A6                 mov     eax, large fs:0
.text$mn:000014AC                 push    eax
.text$mn:000014AD                 sub     esp, 8
.text$mn:000014B0                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000014B5                 xor     eax, ebp
.text$mn:000014B7                 push    eax
.text$mn:000014B8                 lea     eax, [ebp+var_C]
.text$mn:000014BB                 mov     large fs:0, eax
.text$mn:000014C1                 mov     [ebp+var_14], ecx
.text$mn:000014C4                 lea     ecx, [ebp+var_D]
.text$mn:000014C7                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:000014CC                 push    eax
.text$mn:000014CD                 mov     ecx, [ebp+var_14]
.text$mn:000014D0                 call    ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)
.text$mn:000014D5                 mov     [ebp+var_4], 0
.text$mn:000014DC                 push    0               ; Size
.text$mn:000014DE                 push    0               ; char
.text$mn:000014E0                 mov     ecx, [ebp+var_14]
.text$mn:000014E3                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:000014E8                 mov     eax, [ebp+Str]
.text$mn:000014EB                 push    eax             ; Str
.text$mn:000014EC                 mov     ecx, [ebp+var_14]
.text$mn:000014EF                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)
.text$mn:000014F4                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000014FB                 mov     eax, [ebp+var_14]
.text$mn:000014FE                 mov     ecx, [ebp+var_C]
.text$mn:00001501                 mov     large fs:0, ecx
.text$mn:00001508                 pop     ecx
.text$mn:00001509                 mov     esp, ebp
.text$mn:0000150B                 pop     ebp
.text$mn:0000150C                 retn    4
.text$mn:0000150C ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp
.text$mn:0000150C
.text$mn:0000150C ; ---------------------------------------------------------------------------
.text$mn:0000150F                 align 10h
.text$mn:0000150F _text$mn        ends
.text$mn:0000150F
.text$x:00001510 ; ===========================================================================
.text$x:00001510
.text$x:00001510 ; Segment type: Pure code
.text$x:00001510 ; Segment permissions: Read/Execute
.text$x:00001510 _text$x         segment para public 'CODE' use32
.text$x:00001510                 assume cs:_text$x
.text$x:00001510                 ;org 1510h
.text$x:00001510 ; COMDAT (pick associative to section at 149C)
.text$x:00001510                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00001510
.text$x:00001510 ; =============== S U B R O U T I N E =======================================
.text$x:00001510
.text$x:00001510
.text$x:00001510 __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 proc near
.text$x:00001510                                         ; DATA XREF: .xdata$x:00002BB4o
.text$x:00001510                 mov     ecx, [ebp-14h]
.text$x:00001513                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:00001513 __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 endp
.text$x:00001513
.text$x:00001518
.text$x:00001518 ; =============== S U B R O U T I N E =======================================
.text$x:00001518
.text$x:00001518
.text$x:00001518 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
.text$x:00001518                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+5o
.text$x:00001518
.text$x:00001518 arg_4           = dword ptr  8
.text$x:00001518
.text$x:00001518                 mov     edx, [esp+arg_4]
.text$x:0000151C                 lea     eax, [edx+0Ch]
.text$x:0000151F                 mov     ecx, [edx-0Ch]
.text$x:00001522                 xor     ecx, eax
.text$x:00001524                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001529                 mov     eax, offset __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$x:0000152E                 jmp     ___CxxFrameHandler3
.text$x:0000152E __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp
.text$x:0000152E
.text$x:0000152E ; ---------------------------------------------------------------------------
.text$x:00001533                 align 4
.text$x:00001533 _text$x         ends
.text$x:00001533
.text$mn:00001534 ; ===========================================================================
.text$mn:00001534
.text$mn:00001534 ; Segment type: Pure code
.text$mn:00001534 ; Segment permissions: Read/Execute
.text$mn:00001534 _text$mn        segment para public 'CODE' use32
.text$mn:00001534                 assume cs:_text$mn
.text$mn:00001534                 ;org 1534h
.text$mn:00001534 ; COMDAT (pick any)
.text$mn:00001534                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001534
.text$mn:00001534 ; =============== S U B R O U T I N E =======================================
.text$mn:00001534
.text$mn:00001534 ; Attributes: bp-based frame
.text$mn:00001534
.text$mn:00001534 ; _DWORD __thiscall std::_Container_base12::_Container_base12(std::_Container_base12 *__hidden this)
.text$mn:00001534                 public ??0_Container_base12@std@@QAE@XZ
.text$mn:00001534 ??0_Container_base12@std@@QAE@XZ proc near
.text$mn:00001534                                         ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+29p
.text$mn:00001534
.text$mn:00001534 var_4           = dword ptr -4
.text$mn:00001534
.text$mn:00001534                 push    ebp
.text$mn:00001535                 mov     ebp, esp
.text$mn:00001537                 push    ecx
.text$mn:00001538                 mov     [ebp+var_4], ecx
.text$mn:0000153B                 mov     eax, [ebp+var_4]
.text$mn:0000153E                 mov     dword ptr [eax], 0
.text$mn:00001544                 mov     eax, [ebp+var_4]
.text$mn:00001547                 mov     esp, ebp
.text$mn:00001549                 pop     ebp
.text$mn:0000154A                 retn
.text$mn:0000154A ??0_Container_base12@std@@QAE@XZ endp
.text$mn:0000154A
.text$mn:0000154A ; ---------------------------------------------------------------------------
.text$mn:0000154B                 align 4
.text$mn:0000154B _text$mn        ends
.text$mn:0000154B
.text$mn:0000154C ; ===========================================================================
.text$mn:0000154C
.text$mn:0000154C ; Segment type: Pure code
.text$mn:0000154C ; Segment permissions: Read/Execute
.text$mn:0000154C _text$mn        segment para public 'CODE' use32
.text$mn:0000154C                 assume cs:_text$mn
.text$mn:0000154C                 ;org 154Ch
.text$mn:0000154C ; COMDAT (pick any)
.text$mn:0000154C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000154C
.text$mn:0000154C ; =============== S U B R O U T I N E =======================================
.text$mn:0000154C
.text$mn:0000154C ; Attributes: bp-based frame
.text$mn:0000154C
.text$mn:0000154C ; _DWORD __thiscall std::_Container_proxy::_Container_proxy(std::_Container_proxy *__hidden this)
.text$mn:0000154C                 public ??0_Container_proxy@std@@QAE@XZ
.text$mn:0000154C ??0_Container_proxy@std@@QAE@XZ proc near
.text$mn:0000154C                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+23p
.text$mn:0000154C
.text$mn:0000154C var_4           = dword ptr -4
.text$mn:0000154C
.text$mn:0000154C                 push    ebp
.text$mn:0000154D                 mov     ebp, esp
.text$mn:0000154F                 push    ecx
.text$mn:00001550                 mov     [ebp+var_4], ecx
.text$mn:00001553                 mov     eax, [ebp+var_4]
.text$mn:00001556                 mov     dword ptr [eax], 0
.text$mn:0000155C                 mov     ecx, [ebp+var_4]
.text$mn:0000155F                 mov     dword ptr [ecx+4], 0
.text$mn:00001566                 mov     eax, [ebp+var_4]
.text$mn:00001569                 mov     esp, ebp
.text$mn:0000156B                 pop     ebp
.text$mn:0000156C                 retn
.text$mn:0000156C ??0_Container_proxy@std@@QAE@XZ endp
.text$mn:0000156C
.text$mn:0000156C ; ---------------------------------------------------------------------------
.text$mn:0000156D                 align 10h
.text$mn:0000156D _text$mn        ends
.text$mn:0000156D
.text$mn:00001570 ; ===========================================================================
.text$mn:00001570
.text$mn:00001570 ; Segment type: Pure code
.text$mn:00001570 ; Segment permissions: Read/Execute
.text$mn:00001570 _text$mn        segment para public 'CODE' use32
.text$mn:00001570                 assume cs:_text$mn
.text$mn:00001570                 ;org 1570h
.text$mn:00001570 ; COMDAT (pick any)
.text$mn:00001570                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001570
.text$mn:00001570 ; =============== S U B R O U T I N E =======================================
.text$mn:00001570
.text$mn:00001570 ; Attributes: bp-based frame
.text$mn:00001570
.text$mn:00001570 ; _DWORD __thiscall std::_Generic_error_category::_Generic_error_category(std::_Generic_error_category *__hidden this)
.text$mn:00001570                 public ??0_Generic_error_category@std@@QAE@XZ
.text$mn:00001570 ??0_Generic_error_category@std@@QAE@XZ proc near
.text$mn:00001570                                         ; CODE XREF: std::_Iostream_error_category::_Iostream_error_category(void)+29p
.text$mn:00001570                                         ; std::_System_error_category::_System_error_category(void)+29p ...
.text$mn:00001570
.text$mn:00001570 var_10          = dword ptr -10h
.text$mn:00001570 var_C           = dword ptr -0Ch
.text$mn:00001570 var_4           = dword ptr -4
.text$mn:00001570
.text$mn:00001570                 push    ebp
.text$mn:00001571                 mov     ebp, esp
.text$mn:00001573                 push    0FFFFFFFFh
.text$mn:00001575                 push    offset __ehhandler$??0_Generic_error_category@std@@QAE@XZ
.text$mn:0000157A                 mov     eax, large fs:0
.text$mn:00001580                 push    eax
.text$mn:00001581                 push    ecx
.text$mn:00001582                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001587                 xor     eax, ebp
.text$mn:00001589                 push    eax
.text$mn:0000158A                 lea     eax, [ebp+var_C]
.text$mn:0000158D                 mov     large fs:0, eax
.text$mn:00001593                 mov     [ebp+var_10], ecx
.text$mn:00001596                 mov     ecx, [ebp+var_10] ; this
.text$mn:00001599                 call    ??0error_category@std@@QAE@XZ ; std::error_category::error_category(void)
.text$mn:0000159E                 mov     [ebp+var_4], 0
.text$mn:000015A5                 mov     eax, [ebp+var_10]
.text$mn:000015A8                 mov     dword ptr [eax], offset ??_7_Generic_error_category@std@@6B@ ; const std::_Generic_error_category::`vftable'
.text$mn:000015AE                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000015B5                 mov     eax, [ebp+var_10]
.text$mn:000015B8                 mov     ecx, [ebp+var_C]
.text$mn:000015BB                 mov     large fs:0, ecx
.text$mn:000015C2                 pop     ecx
.text$mn:000015C3                 mov     esp, ebp
.text$mn:000015C5                 pop     ebp
.text$mn:000015C6                 retn
.text$mn:000015C6 ??0_Generic_error_category@std@@QAE@XZ endp
.text$mn:000015C6
.text$mn:000015C6 ; ---------------------------------------------------------------------------
.text$mn:000015C7                 align 4
.text$mn:000015C7 _text$mn        ends
.text$mn:000015C7
.text$x:000015C8 ; ===========================================================================
.text$x:000015C8
.text$x:000015C8 ; Segment type: Pure code
.text$x:000015C8 ; Segment permissions: Read/Execute
.text$x:000015C8 _text$x         segment para public 'CODE' use32
.text$x:000015C8                 assume cs:_text$x
.text$x:000015C8                 ;org 15C8h
.text$x:000015C8 ; COMDAT (pick associative to section at 1570)
.text$x:000015C8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000015C8
.text$x:000015C8 ; =============== S U B R O U T I N E =======================================
.text$x:000015C8
.text$x:000015C8
.text$x:000015C8 __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0 proc near
.text$x:000015C8                                         ; DATA XREF: .xdata$x:00002C98o
.text$x:000015C8                 mov     ecx, [ebp-10h]  ; this
.text$x:000015CB                 jmp     ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$x:000015CB __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0 endp
.text$x:000015CB
.text$x:000015D0
.text$x:000015D0 ; =============== S U B R O U T I N E =======================================
.text$x:000015D0
.text$x:000015D0
.text$x:000015D0 __ehhandler$??0_Generic_error_category@std@@QAE@XZ proc near
.text$x:000015D0                                         ; DATA XREF: std::_Generic_error_category::_Generic_error_category(void)+5o
.text$x:000015D0
.text$x:000015D0 arg_4           = dword ptr  8
.text$x:000015D0
.text$x:000015D0                 mov     edx, [esp+arg_4]
.text$x:000015D4                 lea     eax, [edx+0Ch]
.text$x:000015D7                 mov     ecx, [edx-8]
.text$x:000015DA                 xor     ecx, eax
.text$x:000015DC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000015E1                 mov     eax, offset __ehfuncinfo$??0_Generic_error_category@std@@QAE@XZ
.text$x:000015E6                 jmp     ___CxxFrameHandler3
.text$x:000015E6 __ehhandler$??0_Generic_error_category@std@@QAE@XZ endp
.text$x:000015E6
.text$x:000015E6 ; ---------------------------------------------------------------------------
.text$x:000015EB                 align 4
.text$x:000015EB _text$x         ends
.text$x:000015EB
.text$mn:000015EC ; ===========================================================================
.text$mn:000015EC
.text$mn:000015EC ; Segment type: Pure code
.text$mn:000015EC ; Segment permissions: Read/Execute
.text$mn:000015EC _text$mn        segment para public 'CODE' use32
.text$mn:000015EC                 assume cs:_text$mn
.text$mn:000015EC                 ;org 15ECh
.text$mn:000015EC ; COMDAT (pick any)
.text$mn:000015EC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000015EC
.text$mn:000015EC ; =============== S U B R O U T I N E =======================================
.text$mn:000015EC
.text$mn:000015EC ; Attributes: bp-based frame
.text$mn:000015EC
.text$mn:000015EC ; _DWORD __thiscall std::_Ignore::_Ignore(std::_Ignore *__hidden this)
.text$mn:000015EC                 public ??0_Ignore@std@@QAE@XZ
.text$mn:000015EC ??0_Ignore@std@@QAE@XZ proc near        ; CODE XREF: std::`dynamic initializer for 'ignore''(void)+8p
.text$mn:000015EC
.text$mn:000015EC var_4           = dword ptr -4
.text$mn:000015EC
.text$mn:000015EC                 push    ebp
.text$mn:000015ED                 mov     ebp, esp
.text$mn:000015EF                 push    ecx
.text$mn:000015F0                 mov     [ebp+var_4], ecx
.text$mn:000015F3                 mov     eax, [ebp+var_4]
.text$mn:000015F6                 mov     esp, ebp
.text$mn:000015F8                 pop     ebp
.text$mn:000015F9                 retn
.text$mn:000015F9 ??0_Ignore@std@@QAE@XZ endp
.text$mn:000015F9
.text$mn:000015F9 ; ---------------------------------------------------------------------------
.text$mn:000015FA                 align 4
.text$mn:000015FA _text$mn        ends
.text$mn:000015FA
.text$mn:000015FC ; ===========================================================================
.text$mn:000015FC
.text$mn:000015FC ; Segment type: Pure code
.text$mn:000015FC ; Segment permissions: Read/Execute
.text$mn:000015FC _text$mn        segment para public 'CODE' use32
.text$mn:000015FC                 assume cs:_text$mn
.text$mn:000015FC                 ;org 15FCh
.text$mn:000015FC ; COMDAT (pick any)
.text$mn:000015FC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000015FC
.text$mn:000015FC ; =============== S U B R O U T I N E =======================================
.text$mn:000015FC
.text$mn:000015FC ; Attributes: bp-based frame
.text$mn:000015FC
.text$mn:000015FC ; _DWORD __thiscall std::_Iostream_error_category::_Iostream_error_category(std::_Iostream_error_category *__hidden this)
.text$mn:000015FC                 public ??0_Iostream_error_category@std@@QAE@XZ
.text$mn:000015FC ??0_Iostream_error_category@std@@QAE@XZ proc near
.text$mn:000015FC                                         ; CODE XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p
.text$mn:000015FC
.text$mn:000015FC var_10          = dword ptr -10h
.text$mn:000015FC var_C           = dword ptr -0Ch
.text$mn:000015FC var_4           = dword ptr -4
.text$mn:000015FC
.text$mn:000015FC                 push    ebp
.text$mn:000015FD                 mov     ebp, esp
.text$mn:000015FF                 push    0FFFFFFFFh
.text$mn:00001601                 push    offset __ehhandler$??0_Iostream_error_category@std@@QAE@XZ
.text$mn:00001606                 mov     eax, large fs:0
.text$mn:0000160C                 push    eax
.text$mn:0000160D                 push    ecx
.text$mn:0000160E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001613                 xor     eax, ebp
.text$mn:00001615                 push    eax
.text$mn:00001616                 lea     eax, [ebp+var_C]
.text$mn:00001619                 mov     large fs:0, eax
.text$mn:0000161F                 mov     [ebp+var_10], ecx
.text$mn:00001622                 mov     ecx, [ebp+var_10] ; this
.text$mn:00001625                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$mn:0000162A                 mov     [ebp+var_4], 0
.text$mn:00001631                 mov     eax, [ebp+var_10]
.text$mn:00001634                 mov     dword ptr [eax], offset ??_7_Iostream_error_category@std@@6B@ ; const std::_Iostream_error_category::`vftable'
.text$mn:0000163A                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001641                 mov     eax, [ebp+var_10]
.text$mn:00001644                 mov     ecx, [ebp+var_C]
.text$mn:00001647                 mov     large fs:0, ecx
.text$mn:0000164E                 pop     ecx
.text$mn:0000164F                 mov     esp, ebp
.text$mn:00001651                 pop     ebp
.text$mn:00001652                 retn
.text$mn:00001652 ??0_Iostream_error_category@std@@QAE@XZ endp
.text$mn:00001652
.text$mn:00001652 ; ---------------------------------------------------------------------------
.text$mn:00001653                 align 4
.text$mn:00001653 _text$mn        ends
.text$mn:00001653
.text$x:00001654 ; ===========================================================================
.text$x:00001654
.text$x:00001654 ; Segment type: Pure code
.text$x:00001654 ; Segment permissions: Read/Execute
.text$x:00001654 _text$x         segment para public 'CODE' use32
.text$x:00001654                 assume cs:_text$x
.text$x:00001654                 ;org 1654h
.text$x:00001654 ; COMDAT (pick associative to section at 15FC)
.text$x:00001654                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00001654
.text$x:00001654 ; =============== S U B R O U T I N E =======================================
.text$x:00001654
.text$x:00001654
.text$x:00001654 __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0 proc near
.text$x:00001654                                         ; DATA XREF: .xdata$x:00002D1Co
.text$x:00001654                 mov     ecx, [ebp-10h]  ; this
.text$x:00001657                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00001657 __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0 endp
.text$x:00001657
.text$x:0000165C
.text$x:0000165C ; =============== S U B R O U T I N E =======================================
.text$x:0000165C
.text$x:0000165C
.text$x:0000165C __ehhandler$??0_Iostream_error_category@std@@QAE@XZ proc near
.text$x:0000165C                                         ; DATA XREF: std::_Iostream_error_category::_Iostream_error_category(void)+5o
.text$x:0000165C
.text$x:0000165C arg_4           = dword ptr  8
.text$x:0000165C
.text$x:0000165C                 mov     edx, [esp+arg_4]
.text$x:00001660                 lea     eax, [edx+0Ch]
.text$x:00001663                 mov     ecx, [edx-8]
.text$x:00001666                 xor     ecx, eax
.text$x:00001668                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000166D                 mov     eax, offset __ehfuncinfo$??0_Iostream_error_category@std@@QAE@XZ
.text$x:00001672                 jmp     ___CxxFrameHandler3
.text$x:00001672 __ehhandler$??0_Iostream_error_category@std@@QAE@XZ endp
.text$x:00001672
.text$x:00001672 ; ---------------------------------------------------------------------------
.text$x:00001677                 align 4
.text$x:00001677 _text$x         ends
.text$x:00001677
.text$mn:00001678 ; ===========================================================================
.text$mn:00001678
.text$mn:00001678 ; Segment type: Pure code
.text$mn:00001678 ; Segment permissions: Read/Execute
.text$mn:00001678 _text$mn        segment para public 'CODE' use32
.text$mn:00001678                 assume cs:_text$mn
.text$mn:00001678                 ;org 1678h
.text$mn:00001678 ; COMDAT (pick any)
.text$mn:00001678                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001678
.text$mn:00001678 ; =============== S U B R O U T I N E =======================================
.text$mn:00001678
.text$mn:00001678 ; Attributes: bp-based frame
.text$mn:00001678
.text$mn:00001678 ; _DWORD __thiscall std::_System_error_category::_System_error_category(std::_System_error_category *__hidden this)
.text$mn:00001678                 public ??0_System_error_category@std@@QAE@XZ
.text$mn:00001678 ??0_System_error_category@std@@QAE@XZ proc near
.text$mn:00001678                                         ; CODE XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p
.text$mn:00001678
.text$mn:00001678 var_10          = dword ptr -10h
.text$mn:00001678 var_C           = dword ptr -0Ch
.text$mn:00001678 var_4           = dword ptr -4
.text$mn:00001678
.text$mn:00001678                 push    ebp
.text$mn:00001679                 mov     ebp, esp
.text$mn:0000167B                 push    0FFFFFFFFh
.text$mn:0000167D                 push    offset __ehhandler$??0_System_error_category@std@@QAE@XZ
.text$mn:00001682                 mov     eax, large fs:0
.text$mn:00001688                 push    eax
.text$mn:00001689                 push    ecx
.text$mn:0000168A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000168F                 xor     eax, ebp
.text$mn:00001691                 push    eax
.text$mn:00001692                 lea     eax, [ebp+var_C]
.text$mn:00001695                 mov     large fs:0, eax
.text$mn:0000169B                 mov     [ebp+var_10], ecx
.text$mn:0000169E                 mov     ecx, [ebp+var_10] ; this
.text$mn:000016A1                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$mn:000016A6                 mov     [ebp+var_4], 0
.text$mn:000016AD                 mov     eax, [ebp+var_10]
.text$mn:000016B0                 mov     dword ptr [eax], offset ??_7_System_error_category@std@@6B@ ; const std::_System_error_category::`vftable'
.text$mn:000016B6                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000016BD                 mov     eax, [ebp+var_10]
.text$mn:000016C0                 mov     ecx, [ebp+var_C]
.text$mn:000016C3                 mov     large fs:0, ecx
.text$mn:000016CA                 pop     ecx
.text$mn:000016CB                 mov     esp, ebp
.text$mn:000016CD                 pop     ebp
.text$mn:000016CE                 retn
.text$mn:000016CE ??0_System_error_category@std@@QAE@XZ endp
.text$mn:000016CE
.text$mn:000016CE ; ---------------------------------------------------------------------------
.text$mn:000016CF                 align 10h
.text$mn:000016CF _text$mn        ends
.text$mn:000016CF
.text$x:000016D0 ; ===========================================================================
.text$x:000016D0
.text$x:000016D0 ; Segment type: Pure code
.text$x:000016D0 ; Segment permissions: Read/Execute
.text$x:000016D0 _text$x         segment para public 'CODE' use32
.text$x:000016D0                 assume cs:_text$x
.text$x:000016D0                 ;org 16D0h
.text$x:000016D0 ; COMDAT (pick associative to section at 1678)
.text$x:000016D0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000016D0
.text$x:000016D0 ; =============== S U B R O U T I N E =======================================
.text$x:000016D0
.text$x:000016D0
.text$x:000016D0 __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0 proc near
.text$x:000016D0                                         ; DATA XREF: .xdata$x:00002DA0o
.text$x:000016D0                 mov     ecx, [ebp-10h]  ; this
.text$x:000016D3                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:000016D3 __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0 endp
.text$x:000016D3
.text$x:000016D8
.text$x:000016D8 ; =============== S U B R O U T I N E =======================================
.text$x:000016D8
.text$x:000016D8
.text$x:000016D8 __ehhandler$??0_System_error_category@std@@QAE@XZ proc near
.text$x:000016D8                                         ; DATA XREF: std::_System_error_category::_System_error_category(void)+5o
.text$x:000016D8
.text$x:000016D8 arg_4           = dword ptr  8
.text$x:000016D8
.text$x:000016D8                 mov     edx, [esp+arg_4]
.text$x:000016DC                 lea     eax, [edx+0Ch]
.text$x:000016DF                 mov     ecx, [edx-8]
.text$x:000016E2                 xor     ecx, eax
.text$x:000016E4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000016E9                 mov     eax, offset __ehfuncinfo$??0_System_error_category@std@@QAE@XZ
.text$x:000016EE                 jmp     ___CxxFrameHandler3
.text$x:000016EE __ehhandler$??0_System_error_category@std@@QAE@XZ endp
.text$x:000016EE
.text$x:000016EE ; ---------------------------------------------------------------------------
.text$x:000016F3                 align 4
.text$x:000016F3 _text$x         ends
.text$x:000016F3
.text$mn:000016F4 ; ===========================================================================
.text$mn:000016F4
.text$mn:000016F4 ; Segment type: Pure code
.text$mn:000016F4 ; Segment permissions: Read/Execute
.text$mn:000016F4 _text$mn        segment para public 'CODE' use32
.text$mn:000016F4                 assume cs:_text$mn
.text$mn:000016F4                 ;org 16F4h
.text$mn:000016F4 ; COMDAT (pick any)
.text$mn:000016F4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000016F4
.text$mn:000016F4 ; =============== S U B R O U T I N E =======================================
.text$mn:000016F4
.text$mn:000016F4 ; Attributes: bp-based frame
.text$mn:000016F4
.text$mn:000016F4 ; _DWORD __thiscall std::error_category::error_category(std::error_category *__hidden this)
.text$mn:000016F4                 public ??0error_category@std@@QAE@XZ
.text$mn:000016F4 ??0error_category@std@@QAE@XZ proc near ; CODE XREF: std::_Generic_error_category::_Generic_error_category(void)+29p
.text$mn:000016F4
.text$mn:000016F4 var_4           = dword ptr -4
.text$mn:000016F4
.text$mn:000016F4                 push    ebp
.text$mn:000016F5                 mov     ebp, esp
.text$mn:000016F7                 push    ecx
.text$mn:000016F8                 mov     [ebp+var_4], ecx
.text$mn:000016FB                 mov     eax, [ebp+var_4]
.text$mn:000016FE                 mov     dword ptr [eax], offset ??_7error_category@std@@6B@ ; const std::error_category::`vftable'
.text$mn:00001704                 mov     eax, [ebp+var_4]
.text$mn:00001707                 mov     esp, ebp
.text$mn:00001709                 pop     ebp
.text$mn:0000170A                 retn
.text$mn:0000170A ??0error_category@std@@QAE@XZ endp
.text$mn:0000170A
.text$mn:0000170A ; ---------------------------------------------------------------------------
.text$mn:0000170B                 align 4
.text$mn:0000170B _text$mn        ends
.text$mn:0000170B
.text$mn:0000170C ; ===========================================================================
.text$mn:0000170C
.text$mn:0000170C ; Segment type: Pure code
.text$mn:0000170C ; Segment permissions: Read/Execute
.text$mn:0000170C _text$mn        segment para public 'CODE' use32
.text$mn:0000170C                 assume cs:_text$mn
.text$mn:0000170C                 ;org 170Ch
.text$mn:0000170C ; COMDAT (pick any)
.text$mn:0000170C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000170C
.text$mn:0000170C ; =============== S U B R O U T I N E =======================================
.text$mn:0000170C
.text$mn:0000170C ; Attributes: bp-based frame
.text$mn:0000170C
.text$mn:0000170C ; _DWORD __thiscall std::error_condition::error_condition(std::error_condition *this, int, const struct std::error_category *)
.text$mn:0000170C                 public ??0error_condition@std@@QAE@HABVerror_category@1@@Z
.text$mn:0000170C ??0error_condition@std@@QAE@HABVerror_category@1@@Z proc near
.text$mn:0000170C                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+24p
.text$mn:0000170C                                         ; std::_System_error_category::default_error_condition(int)+3Dp ...
.text$mn:0000170C
.text$mn:0000170C var_4           = dword ptr -4
.text$mn:0000170C arg_0           = dword ptr  8
.text$mn:0000170C arg_4           = dword ptr  0Ch
.text$mn:0000170C
.text$mn:0000170C                 push    ebp
.text$mn:0000170D                 mov     ebp, esp
.text$mn:0000170F                 push    ecx
.text$mn:00001710                 mov     [ebp+var_4], ecx
.text$mn:00001713                 mov     eax, [ebp+var_4]
.text$mn:00001716                 mov     ecx, [ebp+arg_0]
.text$mn:00001719                 mov     [eax], ecx
.text$mn:0000171B                 mov     edx, [ebp+var_4]
.text$mn:0000171E                 mov     eax, [ebp+arg_4]
.text$mn:00001721                 mov     [edx+4], eax
.text$mn:00001724                 mov     eax, [ebp+var_4]
.text$mn:00001727                 mov     esp, ebp
.text$mn:00001729                 pop     ebp
.text$mn:0000172A                 retn    8
.text$mn:0000172A ??0error_condition@std@@QAE@HABVerror_category@1@@Z endp
.text$mn:0000172A
.text$mn:0000172A ; ---------------------------------------------------------------------------
.text$mn:0000172D                 align 10h
.text$mn:0000172D _text$mn        ends
.text$mn:0000172D
.text$mn:00001730 ; ===========================================================================
.text$mn:00001730
.text$mn:00001730 ; Segment type: Pure code
.text$mn:00001730 ; Segment permissions: Read/Execute
.text$mn:00001730 _text$mn        segment para public 'CODE' use32
.text$mn:00001730                 assume cs:_text$mn
.text$mn:00001730                 ;org 1730h
.text$mn:00001730 ; COMDAT (pick any)
.text$mn:00001730                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001730
.text$mn:00001730 ; =============== S U B R O U T I N E =======================================
.text$mn:00001730
.text$mn:00001730 ; Attributes: bp-based frame
.text$mn:00001730
.text$mn:00001730 ; _DWORD __thiscall std::locale::id::id(std::locale::id *this, unsigned int)
.text$mn:00001730                 public ??0id@locale@std@@QAE@I@Z
.text$mn:00001730 ??0id@locale@std@@QAE@I@Z proc near     ; CODE XREF: `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)+Ap
.text$mn:00001730                                         ; `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)+Ap ...
.text$mn:00001730
.text$mn:00001730 var_4           = dword ptr -4
.text$mn:00001730 arg_0           = dword ptr  8
.text$mn:00001730
.text$mn:00001730                 push    ebp
.text$mn:00001731                 mov     ebp, esp
.text$mn:00001733                 push    ecx
.text$mn:00001734                 mov     [ebp+var_4], ecx
.text$mn:00001737                 mov     eax, [ebp+var_4]
.text$mn:0000173A                 mov     ecx, [ebp+arg_0]
.text$mn:0000173D                 mov     [eax], ecx
.text$mn:0000173F                 mov     eax, [ebp+var_4]
.text$mn:00001742                 mov     esp, ebp
.text$mn:00001744                 pop     ebp
.text$mn:00001745                 retn    4
.text$mn:00001745 ??0id@locale@std@@QAE@I@Z endp
.text$mn:00001745
.text$mn:00001745 _text$mn        ends
.text$mn:00001745
.text$mn:00001748 ; ===========================================================================
.text$mn:00001748
.text$mn:00001748 ; Segment type: Pure code
.text$mn:00001748 ; Segment permissions: Read/Execute
.text$mn:00001748 _text$mn        segment para public 'CODE' use32
.text$mn:00001748                 assume cs:_text$mn
.text$mn:00001748                 ;org 1748h
.text$mn:00001748 ; COMDAT (pick any)
.text$mn:00001748                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001748
.text$mn:00001748 ; =============== S U B R O U T I N E =======================================
.text$mn:00001748
.text$mn:00001748 ; Attributes: bp-based frame
.text$mn:00001748
.text$mn:00001748 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::~_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>(void)
.text$mn:00001748                 public ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$mn:00001748 ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00001748                                         ; CODE XREF: __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0+3j
.text$mn:00001748                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+43p ...
.text$mn:00001748
.text$mn:00001748 var_10          = dword ptr -10h
.text$mn:00001748 var_C           = dword ptr -0Ch
.text$mn:00001748 var_4           = dword ptr -4
.text$mn:00001748
.text$mn:00001748                 push    ebp
.text$mn:00001749                 mov     ebp, esp
.text$mn:0000174B                 push    0FFFFFFFFh
.text$mn:0000174D                 push    offset __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$mn:00001752                 mov     eax, large fs:0
.text$mn:00001758                 push    eax
.text$mn:00001759                 push    ecx
.text$mn:0000175A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000175F                 xor     eax, ebp
.text$mn:00001761                 push    eax
.text$mn:00001762                 lea     eax, [ebp+var_C]
.text$mn:00001765                 mov     large fs:0, eax
.text$mn:0000176B                 mov     [ebp+var_10], ecx
.text$mn:0000176E                 mov     [ebp+var_4], 0
.text$mn:00001775                 mov     ecx, [ebp+var_10]
.text$mn:00001778                 call    ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)
.text$mn:0000177D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001784                 mov     ecx, [ebp+var_10]
.text$mn:00001787                 call    ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$mn:0000178C                 mov     ecx, [ebp+var_C]
.text$mn:0000178F                 mov     large fs:0, ecx
.text$mn:00001796                 pop     ecx
.text$mn:00001797                 mov     esp, ebp
.text$mn:00001799                 pop     ebp
.text$mn:0000179A                 retn
.text$mn:0000179A ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp
.text$mn:0000179A
.text$mn:0000179A ; ---------------------------------------------------------------------------
.text$mn:0000179B                 align 4
.text$mn:0000179B _text$mn        ends
.text$mn:0000179B
.text$x:0000179C ; ===========================================================================
.text$x:0000179C
.text$x:0000179C ; Segment type: Pure code
.text$x:0000179C ; Segment permissions: Read/Execute
.text$x:0000179C _text$x         segment para public 'CODE' use32
.text$x:0000179C                 assume cs:_text$x
.text$x:0000179C                 ;org 179Ch
.text$x:0000179C ; COMDAT (pick associative to section at 1748)
.text$x:0000179C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000179C
.text$x:0000179C ; =============== S U B R O U T I N E =======================================
.text$x:0000179C
.text$x:0000179C
.text$x:0000179C __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:0000179C                                         ; DATA XREF: .xdata$x:00002B88o
.text$x:0000179C                 mov     ecx, [ebp-10h]
.text$x:0000179F                 jmp     ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$x:0000179F __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:0000179F
.text$x:000017A4
.text$x:000017A4 ; =============== S U B R O U T I N E =======================================
.text$x:000017A4
.text$x:000017A4
.text$x:000017A4 __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
.text$x:000017A4                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+5o
.text$x:000017A4
.text$x:000017A4 arg_4           = dword ptr  8
.text$x:000017A4
.text$x:000017A4                 mov     edx, [esp+arg_4]
.text$x:000017A8                 lea     eax, [edx+0Ch]
.text$x:000017AB                 mov     ecx, [edx-8]
.text$x:000017AE                 xor     ecx, eax
.text$x:000017B0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000017B5                 mov     eax, offset __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$x:000017BA                 jmp     ___CxxFrameHandler3
.text$x:000017BA __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp
.text$x:000017BA
.text$x:000017BA ; ---------------------------------------------------------------------------
.text$x:000017BF                 align 10h
.text$x:000017BF _text$x         ends
.text$x:000017BF
.text$mn:000017C0 ; ===========================================================================
.text$mn:000017C0
.text$mn:000017C0 ; Segment type: Pure code
.text$mn:000017C0 ; Segment permissions: Read/Execute
.text$mn:000017C0 _text$mn        segment para public 'CODE' use32
.text$mn:000017C0                 assume cs:_text$mn
.text$mn:000017C0                 ;org 17C0h
.text$mn:000017C0 ; COMDAT (pick any)
.text$mn:000017C0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000017C0
.text$mn:000017C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000017C0
.text$mn:000017C0 ; Attributes: bp-based frame
.text$mn:000017C0
.text$mn:000017C0 ; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::~_String_val<struct std::_Simple_types<char>>(void)
.text$mn:000017C0                 public ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:000017C0 ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$mn:000017C0                                         ; CODE XREF: __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0+3j
.text$mn:000017C0                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+3Fp ...
.text$mn:000017C0
.text$mn:000017C0 var_10          = dword ptr -10h
.text$mn:000017C0 var_C           = dword ptr -0Ch
.text$mn:000017C0 var_4           = dword ptr -4
.text$mn:000017C0
.text$mn:000017C0                 push    ebp
.text$mn:000017C1                 mov     ebp, esp
.text$mn:000017C3                 push    0FFFFFFFFh
.text$mn:000017C5                 push    offset __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:000017CA                 mov     eax, large fs:0
.text$mn:000017D0                 push    eax
.text$mn:000017D1                 push    ecx
.text$mn:000017D2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000017D7                 xor     eax, ebp
.text$mn:000017D9                 push    eax
.text$mn:000017DA                 lea     eax, [ebp+var_C]
.text$mn:000017DD                 mov     large fs:0, eax
.text$mn:000017E3                 mov     [ebp+var_10], ecx
.text$mn:000017E6                 mov     [ebp+var_4], 0
.text$mn:000017ED                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000017F4                 mov     ecx, [ebp+var_10] ; this
.text$mn:000017F7                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:000017FC                 mov     ecx, [ebp+var_C]
.text$mn:000017FF                 mov     large fs:0, ecx
.text$mn:00001806                 pop     ecx
.text$mn:00001807                 mov     esp, ebp
.text$mn:00001809                 pop     ebp
.text$mn:0000180A                 retn
.text$mn:0000180A ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$mn:0000180A
.text$mn:0000180A ; ---------------------------------------------------------------------------
.text$mn:0000180B                 align 4
.text$mn:0000180B _text$mn        ends
.text$mn:0000180B
.text$x:0000180C ; ===========================================================================
.text$x:0000180C
.text$x:0000180C ; Segment type: Pure code
.text$x:0000180C ; Segment permissions: Read/Execute
.text$x:0000180C _text$x         segment para public 'CODE' use32
.text$x:0000180C                 assume cs:_text$x
.text$x:0000180C                 ;org 180Ch
.text$x:0000180C ; COMDAT (pick associative to section at 17C0)
.text$x:0000180C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000180C
.text$x:0000180C ; =============== S U B R O U T I N E =======================================
.text$x:0000180C
.text$x:0000180C
.text$x:0000180C __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 proc near
.text$x:0000180C                                         ; DATA XREF: .xdata$x:00002B30o
.text$x:0000180C                 mov     ecx, [ebp-10h]  ; this
.text$x:0000180F                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:0000180F __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 endp
.text$x:0000180F
.text$x:00001814
.text$x:00001814 ; =============== S U B R O U T I N E =======================================
.text$x:00001814
.text$x:00001814
.text$x:00001814 __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$x:00001814                                         ; DATA XREF: std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)+5o
.text$x:00001814
.text$x:00001814 arg_4           = dword ptr  8
.text$x:00001814
.text$x:00001814                 mov     edx, [esp+arg_4]
.text$x:00001818                 lea     eax, [edx+0Ch]
.text$x:0000181B                 mov     ecx, [edx-8]
.text$x:0000181E                 xor     ecx, eax
.text$x:00001820                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001825                 mov     eax, offset __ehfuncinfo$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$x:0000182A                 jmp     ___CxxFrameHandler3
.text$x:0000182A __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$x:0000182A
.text$x:0000182A ; ---------------------------------------------------------------------------
.text$x:0000182F                 align 10h
.text$x:0000182F _text$x         ends
.text$x:0000182F
.text$mn:00001830 ; ===========================================================================
.text$mn:00001830
.text$mn:00001830 ; Segment type: Pure code
.text$mn:00001830 ; Segment permissions: Read/Execute
.text$mn:00001830 _text$mn        segment para public 'CODE' use32
.text$mn:00001830                 assume cs:_text$mn
.text$mn:00001830                 ;org 1830h
.text$mn:00001830 ; COMDAT (pick any)
.text$mn:00001830                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001830
.text$mn:00001830 ; =============== S U B R O U T I N E =======================================
.text$mn:00001830
.text$mn:00001830 ; Attributes: bp-based frame
.text$mn:00001830
.text$mn:00001830 ; public: __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::~basic_string<char, struct std::char_traits<char>, class std::allocator<char>>(void)
.text$mn:00001830                 public ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:00001830 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$mn:00001830                                         ; CODE XREF: __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+13j
.text$mn:00001830                                         ; __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+13j ...
.text$mn:00001830
.text$mn:00001830 var_10          = dword ptr -10h
.text$mn:00001830 var_C           = dword ptr -0Ch
.text$mn:00001830 var_4           = dword ptr -4
.text$mn:00001830
.text$mn:00001830                 push    ebp
.text$mn:00001831                 mov     ebp, esp
.text$mn:00001833                 push    0FFFFFFFFh
.text$mn:00001835                 push    offset __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:0000183A                 mov     eax, large fs:0
.text$mn:00001840                 push    eax
.text$mn:00001841                 push    ecx
.text$mn:00001842                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001847                 xor     eax, ebp
.text$mn:00001849                 push    eax
.text$mn:0000184A                 lea     eax, [ebp+var_C]
.text$mn:0000184D                 mov     large fs:0, eax
.text$mn:00001853                 mov     [ebp+var_10], ecx
.text$mn:00001856                 mov     [ebp+var_4], 0
.text$mn:0000185D                 push    0               ; Size
.text$mn:0000185F                 push    1               ; char
.text$mn:00001861                 mov     ecx, [ebp+var_10]
.text$mn:00001864                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00001869                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001870                 mov     ecx, [ebp+var_10]
.text$mn:00001873                 call    ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$mn:00001878                 mov     ecx, [ebp+var_C]
.text$mn:0000187B                 mov     large fs:0, ecx
.text$mn:00001882                 pop     ecx
.text$mn:00001883                 mov     esp, ebp
.text$mn:00001885                 pop     ebp
.text$mn:00001886                 retn
.text$mn:00001886 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$mn:00001886
.text$mn:00001886 ; ---------------------------------------------------------------------------
.text$mn:00001887                 align 4
.text$mn:00001887 _text$mn        ends
.text$mn:00001887
.text$x:00001888 ; ===========================================================================
.text$x:00001888
.text$x:00001888 ; Segment type: Pure code
.text$x:00001888 ; Segment permissions: Read/Execute
.text$x:00001888 _text$x         segment para public 'CODE' use32
.text$x:00001888                 assume cs:_text$x
.text$x:00001888                 ;org 1888h
.text$x:00001888 ; COMDAT (pick associative to section at 1830)
.text$x:00001888                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00001888
.text$x:00001888 ; =============== S U B R O U T I N E =======================================
.text$x:00001888
.text$x:00001888
.text$x:00001888 __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 proc near
.text$x:00001888                                         ; DATA XREF: .xdata$x:00002BE0o
.text$x:00001888                 mov     ecx, [ebp-10h]
.text$x:0000188B                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:0000188B __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 endp
.text$x:0000188B
.text$x:00001890
.text$x:00001890 ; =============== S U B R O U T I N E =======================================
.text$x:00001890
.text$x:00001890
.text$x:00001890 __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$x:00001890                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+5o
.text$x:00001890
.text$x:00001890 arg_4           = dword ptr  8
.text$x:00001890
.text$x:00001890                 mov     edx, [esp+arg_4]
.text$x:00001894                 lea     eax, [edx+0Ch]
.text$x:00001897                 mov     ecx, [edx-8]
.text$x:0000189A                 xor     ecx, eax
.text$x:0000189C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000018A1                 mov     eax, offset __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$x:000018A6                 jmp     ___CxxFrameHandler3
.text$x:000018A6 __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$x:000018A6
.text$x:000018A6 ; ---------------------------------------------------------------------------
.text$x:000018AB                 align 4
.text$x:000018AB _text$x         ends
.text$x:000018AB
.text$mn:000018AC ; ===========================================================================
.text$mn:000018AC
.text$mn:000018AC ; Segment type: Pure code
.text$mn:000018AC ; Segment permissions: Read/Execute
.text$mn:000018AC _text$mn        segment para public 'CODE' use32
.text$mn:000018AC                 assume cs:_text$mn
.text$mn:000018AC                 ;org 18ACh
.text$mn:000018AC ; COMDAT (pick any)
.text$mn:000018AC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000018AC
.text$mn:000018AC ; =============== S U B R O U T I N E =======================================
.text$mn:000018AC
.text$mn:000018AC ; Attributes: bp-based frame
.text$mn:000018AC
.text$mn:000018AC ; _DWORD __thiscall std::_Container_base12::~_Container_base12(std::_Container_base12 *__hidden this)
.text$mn:000018AC                 public ??1_Container_base12@std@@QAE@XZ
.text$mn:000018AC ??1_Container_base12@std@@QAE@XZ proc near
.text$mn:000018AC                                         ; CODE XREF: __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0+3j
.text$mn:000018AC                                         ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)+37p ...
.text$mn:000018AC
.text$mn:000018AC var_4           = dword ptr -4
.text$mn:000018AC
.text$mn:000018AC                 push    ebp
.text$mn:000018AD                 mov     ebp, esp
.text$mn:000018AF                 push    ecx
.text$mn:000018B0                 mov     [ebp+var_4], ecx
.text$mn:000018B3                 mov     ecx, [ebp+var_4] ; this
.text$mn:000018B6                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:000018BB                 mov     esp, ebp
.text$mn:000018BD                 pop     ebp
.text$mn:000018BE                 retn
.text$mn:000018BE ??1_Container_base12@std@@QAE@XZ endp
.text$mn:000018BE
.text$mn:000018BE ; ---------------------------------------------------------------------------
.text$mn:000018BF                 align 10h
.text$mn:000018BF _text$mn        ends
.text$mn:000018BF
.text$mn:000018C0 ; ===========================================================================
.text$mn:000018C0
.text$mn:000018C0 ; Segment type: Pure code
.text$mn:000018C0 ; Segment permissions: Read/Execute
.text$mn:000018C0 _text$mn        segment para public 'CODE' use32
.text$mn:000018C0                 assume cs:_text$mn
.text$mn:000018C0                 ;org 18C0h
.text$mn:000018C0 ; COMDAT (pick any)
.text$mn:000018C0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000018C0
.text$mn:000018C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000018C0
.text$mn:000018C0 ; Attributes: bp-based frame
.text$mn:000018C0
.text$mn:000018C0 ; _DWORD __thiscall std::_Generic_error_category::~_Generic_error_category(std::_Generic_error_category *__hidden this)
.text$mn:000018C0                 public ??1_Generic_error_category@std@@UAE@XZ
.text$mn:000018C0 ??1_Generic_error_category@std@@UAE@XZ proc near
.text$mn:000018C0                                         ; CODE XREF: __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0+3j
.text$mn:000018C0                                         ; __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0+3j ...
.text$mn:000018C0
.text$mn:000018C0 var_10          = dword ptr -10h
.text$mn:000018C0 var_C           = dword ptr -0Ch
.text$mn:000018C0 var_4           = dword ptr -4
.text$mn:000018C0
.text$mn:000018C0                 push    ebp
.text$mn:000018C1                 mov     ebp, esp
.text$mn:000018C3                 push    0FFFFFFFFh
.text$mn:000018C5                 push    offset __ehhandler$??1_Generic_error_category@std@@UAE@XZ
.text$mn:000018CA                 mov     eax, large fs:0
.text$mn:000018D0                 push    eax
.text$mn:000018D1                 push    ecx
.text$mn:000018D2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000018D7                 xor     eax, ebp
.text$mn:000018D9                 push    eax
.text$mn:000018DA                 lea     eax, [ebp+var_C]
.text$mn:000018DD                 mov     large fs:0, eax
.text$mn:000018E3                 mov     [ebp+var_10], ecx
.text$mn:000018E6                 mov     [ebp+var_4], 0
.text$mn:000018ED                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000018F4                 mov     ecx, [ebp+var_10] ; this
.text$mn:000018F7                 call    ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$mn:000018FC                 mov     ecx, [ebp+var_C]
.text$mn:000018FF                 mov     large fs:0, ecx
.text$mn:00001906                 pop     ecx
.text$mn:00001907                 mov     esp, ebp
.text$mn:00001909                 pop     ebp
.text$mn:0000190A                 retn
.text$mn:0000190A ??1_Generic_error_category@std@@UAE@XZ endp
.text$mn:0000190A
.text$mn:0000190A ; ---------------------------------------------------------------------------
.text$mn:0000190B                 align 4
.text$mn:0000190B _text$mn        ends
.text$mn:0000190B
.text$x:0000190C ; ===========================================================================
.text$x:0000190C
.text$x:0000190C ; Segment type: Pure code
.text$x:0000190C ; Segment permissions: Read/Execute
.text$x:0000190C _text$x         segment para public 'CODE' use32
.text$x:0000190C                 assume cs:_text$x
.text$x:0000190C                 ;org 190Ch
.text$x:0000190C ; COMDAT (pick associative to section at 18C0)
.text$x:0000190C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000190C
.text$x:0000190C ; =============== S U B R O U T I N E =======================================
.text$x:0000190C
.text$x:0000190C
.text$x:0000190C __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0 proc near
.text$x:0000190C                                         ; DATA XREF: .xdata$x:00002CF0o
.text$x:0000190C                 mov     ecx, [ebp-10h]  ; this
.text$x:0000190F                 jmp     ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$x:0000190F __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0 endp
.text$x:0000190F
.text$x:00001914
.text$x:00001914 ; =============== S U B R O U T I N E =======================================
.text$x:00001914
.text$x:00001914
.text$x:00001914 __ehhandler$??1_Generic_error_category@std@@UAE@XZ proc near
.text$x:00001914                                         ; DATA XREF: std::_Generic_error_category::~_Generic_error_category(void)+5o
.text$x:00001914
.text$x:00001914 arg_4           = dword ptr  8
.text$x:00001914
.text$x:00001914                 mov     edx, [esp+arg_4]
.text$x:00001918                 lea     eax, [edx+0Ch]
.text$x:0000191B                 mov     ecx, [edx-8]
.text$x:0000191E                 xor     ecx, eax
.text$x:00001920                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001925                 mov     eax, offset __ehfuncinfo$??1_Generic_error_category@std@@UAE@XZ
.text$x:0000192A                 jmp     ___CxxFrameHandler3
.text$x:0000192A __ehhandler$??1_Generic_error_category@std@@UAE@XZ endp
.text$x:0000192A
.text$x:0000192A ; ---------------------------------------------------------------------------
.text$x:0000192F                 align 10h
.text$x:0000192F _text$x         ends
.text$x:0000192F
.text$mn:00001930 ; ===========================================================================
.text$mn:00001930
.text$mn:00001930 ; Segment type: Pure code
.text$mn:00001930 ; Segment permissions: Read/Execute
.text$mn:00001930 _text$mn        segment para public 'CODE' use32
.text$mn:00001930                 assume cs:_text$mn
.text$mn:00001930                 ;org 1930h
.text$mn:00001930 ; COMDAT (pick any)
.text$mn:00001930                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001930
.text$mn:00001930 ; =============== S U B R O U T I N E =======================================
.text$mn:00001930
.text$mn:00001930 ; Attributes: bp-based frame
.text$mn:00001930
.text$mn:00001930 ; _DWORD __thiscall std::_Iostream_error_category::~_Iostream_error_category(std::_Iostream_error_category *__hidden this)
.text$mn:00001930                 public ??1_Iostream_error_category@std@@UAE@XZ
.text$mn:00001930 ??1_Iostream_error_category@std@@UAE@XZ proc near
.text$mn:00001930                                         ; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+Ap
.text$mn:00001930                                         ; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p
.text$mn:00001930
.text$mn:00001930 var_10          = dword ptr -10h
.text$mn:00001930 var_C           = dword ptr -0Ch
.text$mn:00001930 var_4           = dword ptr -4
.text$mn:00001930
.text$mn:00001930                 push    ebp
.text$mn:00001931                 mov     ebp, esp
.text$mn:00001933                 push    0FFFFFFFFh
.text$mn:00001935                 push    offset __ehhandler$??1_Iostream_error_category@std@@UAE@XZ
.text$mn:0000193A                 mov     eax, large fs:0
.text$mn:00001940                 push    eax
.text$mn:00001941                 push    ecx
.text$mn:00001942                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001947                 xor     eax, ebp
.text$mn:00001949                 push    eax
.text$mn:0000194A                 lea     eax, [ebp+var_C]
.text$mn:0000194D                 mov     large fs:0, eax
.text$mn:00001953                 mov     [ebp+var_10], ecx
.text$mn:00001956                 mov     [ebp+var_4], 0
.text$mn:0000195D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001964                 mov     ecx, [ebp+var_10] ; this
.text$mn:00001967                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:0000196C                 mov     ecx, [ebp+var_C]
.text$mn:0000196F                 mov     large fs:0, ecx
.text$mn:00001976                 pop     ecx
.text$mn:00001977                 mov     esp, ebp
.text$mn:00001979                 pop     ebp
.text$mn:0000197A                 retn
.text$mn:0000197A ??1_Iostream_error_category@std@@UAE@XZ endp
.text$mn:0000197A
.text$mn:0000197A ; ---------------------------------------------------------------------------
.text$mn:0000197B                 align 4
.text$mn:0000197B _text$mn        ends
.text$mn:0000197B
.text$x:0000197C ; ===========================================================================
.text$x:0000197C
.text$x:0000197C ; Segment type: Pure code
.text$x:0000197C ; Segment permissions: Read/Execute
.text$x:0000197C _text$x         segment para public 'CODE' use32
.text$x:0000197C                 assume cs:_text$x
.text$x:0000197C                 ;org 197Ch
.text$x:0000197C ; COMDAT (pick associative to section at 1930)
.text$x:0000197C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000197C
.text$x:0000197C ; =============== S U B R O U T I N E =======================================
.text$x:0000197C
.text$x:0000197C
.text$x:0000197C __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0 proc near
.text$x:0000197C                                         ; DATA XREF: .xdata$x:00002D74o
.text$x:0000197C                 mov     ecx, [ebp-10h]  ; this
.text$x:0000197F                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:0000197F __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0 endp
.text$x:0000197F
.text$x:00001984
.text$x:00001984 ; =============== S U B R O U T I N E =======================================
.text$x:00001984
.text$x:00001984
.text$x:00001984 __ehhandler$??1_Iostream_error_category@std@@UAE@XZ proc near
.text$x:00001984                                         ; DATA XREF: std::_Iostream_error_category::~_Iostream_error_category(void)+5o
.text$x:00001984
.text$x:00001984 arg_4           = dword ptr  8
.text$x:00001984
.text$x:00001984                 mov     edx, [esp+arg_4]
.text$x:00001988                 lea     eax, [edx+0Ch]
.text$x:0000198B                 mov     ecx, [edx-8]
.text$x:0000198E                 xor     ecx, eax
.text$x:00001990                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001995                 mov     eax, offset __ehfuncinfo$??1_Iostream_error_category@std@@UAE@XZ
.text$x:0000199A                 jmp     ___CxxFrameHandler3
.text$x:0000199A __ehhandler$??1_Iostream_error_category@std@@UAE@XZ endp
.text$x:0000199A
.text$x:0000199A ; ---------------------------------------------------------------------------
.text$x:0000199F                 align 10h
.text$x:0000199F _text$x         ends
.text$x:0000199F
.text$mn:000019A0 ; ===========================================================================
.text$mn:000019A0
.text$mn:000019A0 ; Segment type: Pure code
.text$mn:000019A0 ; Segment permissions: Read/Execute
.text$mn:000019A0 _text$mn        segment para public 'CODE' use32
.text$mn:000019A0                 assume cs:_text$mn
.text$mn:000019A0                 ;org 19A0h
.text$mn:000019A0 ; COMDAT (pick any)
.text$mn:000019A0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000019A0
.text$mn:000019A0 ; =============== S U B R O U T I N E =======================================
.text$mn:000019A0
.text$mn:000019A0 ; Attributes: bp-based frame
.text$mn:000019A0
.text$mn:000019A0 ; _DWORD __thiscall std::_System_error_category::~_System_error_category(std::_System_error_category *__hidden this)
.text$mn:000019A0                 public ??1_System_error_category@std@@UAE@XZ
.text$mn:000019A0 ??1_System_error_category@std@@UAE@XZ proc near
.text$mn:000019A0                                         ; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+Ap
.text$mn:000019A0                                         ; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p
.text$mn:000019A0
.text$mn:000019A0 var_10          = dword ptr -10h
.text$mn:000019A0 var_C           = dword ptr -0Ch
.text$mn:000019A0 var_4           = dword ptr -4
.text$mn:000019A0
.text$mn:000019A0                 push    ebp
.text$mn:000019A1                 mov     ebp, esp
.text$mn:000019A3                 push    0FFFFFFFFh
.text$mn:000019A5                 push    offset __ehhandler$??1_System_error_category@std@@UAE@XZ
.text$mn:000019AA                 mov     eax, large fs:0
.text$mn:000019B0                 push    eax
.text$mn:000019B1                 push    ecx
.text$mn:000019B2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000019B7                 xor     eax, ebp
.text$mn:000019B9                 push    eax
.text$mn:000019BA                 lea     eax, [ebp+var_C]
.text$mn:000019BD                 mov     large fs:0, eax
.text$mn:000019C3                 mov     [ebp+var_10], ecx
.text$mn:000019C6                 mov     [ebp+var_4], 0
.text$mn:000019CD                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000019D4                 mov     ecx, [ebp+var_10] ; this
.text$mn:000019D7                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:000019DC                 mov     ecx, [ebp+var_C]
.text$mn:000019DF                 mov     large fs:0, ecx
.text$mn:000019E6                 pop     ecx
.text$mn:000019E7                 mov     esp, ebp
.text$mn:000019E9                 pop     ebp
.text$mn:000019EA                 retn
.text$mn:000019EA ??1_System_error_category@std@@UAE@XZ endp
.text$mn:000019EA
.text$mn:000019EA ; ---------------------------------------------------------------------------
.text$mn:000019EB                 align 4
.text$mn:000019EB _text$mn        ends
.text$mn:000019EB
.text$x:000019EC ; ===========================================================================
.text$x:000019EC
.text$x:000019EC ; Segment type: Pure code
.text$x:000019EC ; Segment permissions: Read/Execute
.text$x:000019EC _text$x         segment para public 'CODE' use32
.text$x:000019EC                 assume cs:_text$x
.text$x:000019EC                 ;org 19ECh
.text$x:000019EC ; COMDAT (pick associative to section at 19A0)
.text$x:000019EC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000019EC
.text$x:000019EC ; =============== S U B R O U T I N E =======================================
.text$x:000019EC
.text$x:000019EC
.text$x:000019EC __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0 proc near
.text$x:000019EC                                         ; DATA XREF: .xdata$x:00002DF8o
.text$x:000019EC                 mov     ecx, [ebp-10h]  ; this
.text$x:000019EF                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:000019EF __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0 endp
.text$x:000019EF
.text$x:000019F4
.text$x:000019F4 ; =============== S U B R O U T I N E =======================================
.text$x:000019F4
.text$x:000019F4
.text$x:000019F4 __ehhandler$??1_System_error_category@std@@UAE@XZ proc near
.text$x:000019F4                                         ; DATA XREF: std::_System_error_category::~_System_error_category(void)+5o
.text$x:000019F4
.text$x:000019F4 arg_4           = dword ptr  8
.text$x:000019F4
.text$x:000019F4                 mov     edx, [esp+arg_4]
.text$x:000019F8                 lea     eax, [edx+0Ch]
.text$x:000019FB                 mov     ecx, [edx-8]
.text$x:000019FE                 xor     ecx, eax
.text$x:00001A00                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001A05                 mov     eax, offset __ehfuncinfo$??1_System_error_category@std@@UAE@XZ
.text$x:00001A0A                 jmp     ___CxxFrameHandler3
.text$x:00001A0A __ehhandler$??1_System_error_category@std@@UAE@XZ endp
.text$x:00001A0A
.text$x:00001A0A ; ---------------------------------------------------------------------------
.text$x:00001A0F                 align 10h
.text$x:00001A0F _text$x         ends
.text$x:00001A0F
.text$mn:00001A10 ; ===========================================================================
.text$mn:00001A10
.text$mn:00001A10 ; Segment type: Pure code
.text$mn:00001A10 ; Segment permissions: Read/Execute
.text$mn:00001A10 _text$mn        segment para public 'CODE' use32
.text$mn:00001A10                 assume cs:_text$mn
.text$mn:00001A10                 ;org 1A10h
.text$mn:00001A10 ; COMDAT (pick any)
.text$mn:00001A10                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001A10
.text$mn:00001A10 ; =============== S U B R O U T I N E =======================================
.text$mn:00001A10
.text$mn:00001A10 ; Attributes: bp-based frame
.text$mn:00001A10
.text$mn:00001A10 ; _DWORD __thiscall std::error_category::~error_category(std::error_category *__hidden this)
.text$mn:00001A10                 public ??1error_category@std@@UAE@XZ
.text$mn:00001A10 ??1error_category@std@@UAE@XZ proc near ; CODE XREF: __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0+3j
.text$mn:00001A10                                         ; std::_Generic_error_category::~_Generic_error_category(void)+37p ...
.text$mn:00001A10
.text$mn:00001A10 var_4           = dword ptr -4
.text$mn:00001A10
.text$mn:00001A10                 push    ebp
.text$mn:00001A11                 mov     ebp, esp
.text$mn:00001A13                 push    ecx
.text$mn:00001A14                 mov     [ebp+var_4], ecx
.text$mn:00001A17                 mov     eax, [ebp+var_4]
.text$mn:00001A1A                 mov     dword ptr [eax], offset ??_7error_category@std@@6B@ ; const std::error_category::`vftable'
.text$mn:00001A20                 mov     esp, ebp
.text$mn:00001A22                 pop     ebp
.text$mn:00001A23                 retn
.text$mn:00001A23 ??1error_category@std@@UAE@XZ endp
.text$mn:00001A23
.text$mn:00001A23 _text$mn        ends
.text$mn:00001A23
.text$mn:00001A24 ; ===========================================================================
.text$mn:00001A24
.text$mn:00001A24 ; Segment type: Pure code
.text$mn:00001A24 ; Segment permissions: Read/Execute
.text$mn:00001A24 _text$mn        segment para public 'CODE' use32
.text$mn:00001A24                 assume cs:_text$mn
.text$mn:00001A24                 ;org 1A24h
.text$mn:00001A24 ; COMDAT (pick any)
.text$mn:00001A24                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001A24
.text$mn:00001A24 ; =============== S U B R O U T I N E =======================================
.text$mn:00001A24
.text$mn:00001A24 ; Attributes: bp-based frame
.text$mn:00001A24
.text$mn:00001A24 ; void *__cdecl operator new(unsigned int, void *)
.text$mn:00001A24                 public ??2@YAPAXIPAX@Z
.text$mn:00001A24 ??2@YAPAXIPAX@Z proc near               ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+2Ep
.text$mn:00001A24                                         ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+2Ep
.text$mn:00001A24
.text$mn:00001A24 arg_4           = dword ptr  0Ch
.text$mn:00001A24
.text$mn:00001A24                 push    ebp
.text$mn:00001A25                 mov     ebp, esp
.text$mn:00001A27                 mov     eax, [ebp+arg_4]
.text$mn:00001A2A                 pop     ebp
.text$mn:00001A2B                 retn
.text$mn:00001A2B ??2@YAPAXIPAX@Z endp
.text$mn:00001A2B
.text$mn:00001A2B _text$mn        ends
.text$mn:00001A2B
.text$mn:00001A2C ; ===========================================================================
.text$mn:00001A2C
.text$mn:00001A2C ; Segment type: Pure code
.text$mn:00001A2C ; Segment permissions: Read/Execute
.text$mn:00001A2C _text$mn        segment para public 'CODE' use32
.text$mn:00001A2C                 assume cs:_text$mn
.text$mn:00001A2C                 ;org 1A2Ch
.text$mn:00001A2C ; COMDAT (pick any)
.text$mn:00001A2C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001A2C
.text$mn:00001A2C ; =============== S U B R O U T I N E =======================================
.text$mn:00001A2C
.text$mn:00001A2C ; Attributes: bp-based frame
.text$mn:00001A2C
.text$mn:00001A2C ; void __cdecl operator delete(void *)
.text$mn:00001A2C                 public ??3@YAXPAX0@Z
.text$mn:00001A2C ??3@YAXPAX0@Z   proc near               ; CODE XREF: __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0+8p
.text$mn:00001A2C                                         ; __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0+8p
.text$mn:00001A2C                 push    ebp
.text$mn:00001A2D                 mov     ebp, esp
.text$mn:00001A2F                 pop     ebp
.text$mn:00001A30                 retn
.text$mn:00001A30 ??3@YAXPAX0@Z   endp
.text$mn:00001A30
.text$mn:00001A30 ; ---------------------------------------------------------------------------
.text$mn:00001A31                 align 4
.text$mn:00001A31 _text$mn        ends
.text$mn:00001A31
.text$mn:00001A34 ; ===========================================================================
.text$mn:00001A34
.text$mn:00001A34 ; Segment type: Pure code
.text$mn:00001A34 ; Segment permissions: Read/Execute
.text$mn:00001A34 _text$mn        segment para public 'CODE' use32
.text$mn:00001A34                 assume cs:_text$mn
.text$mn:00001A34                 ;org 1A34h
.text$mn:00001A34 ; COMDAT (pick any)
.text$mn:00001A34                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001A34
.text$mn:00001A34 ; =============== S U B R O U T I N E =======================================
.text$mn:00001A34
.text$mn:00001A34 ; Attributes: bp-based frame
.text$mn:00001A34
.text$mn:00001A34 ; public: bool __thiscall std::error_category::operator==(class std::error_category const &)const
.text$mn:00001A34                 public ??8error_category@std@@QBE_NABV01@@Z
.text$mn:00001A34 ??8error_category@std@@QBE_NABV01@@Z proc near
.text$mn:00001A34                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+1Dp
.text$mn:00001A34                                         ; std::error_category::equivalent(std::error_code const &,int)+15p
.text$mn:00001A34
.text$mn:00001A34 var_8           = dword ptr -8
.text$mn:00001A34 var_4           = dword ptr -4
.text$mn:00001A34 arg_0           = dword ptr  8
.text$mn:00001A34
.text$mn:00001A34                 push    ebp
.text$mn:00001A35                 mov     ebp, esp
.text$mn:00001A37                 sub     esp, 8
.text$mn:00001A3A                 mov     [ebp+var_8], ecx
.text$mn:00001A3D                 mov     eax, [ebp+var_8]
.text$mn:00001A40                 cmp     eax, [ebp+arg_0]
.text$mn:00001A43                 jnz     short loc_1A4E
.text$mn:00001A45                 mov     [ebp+var_4], 1
.text$mn:00001A4C                 jmp     short loc_1A55
.text$mn:00001A4E ; ---------------------------------------------------------------------------
.text$mn:00001A4E
.text$mn:00001A4E loc_1A4E:                               ; CODE XREF: std::error_category::operator==(std::error_category const &)+Fj
.text$mn:00001A4E                 mov     [ebp+var_4], 0
.text$mn:00001A55
.text$mn:00001A55 loc_1A55:                               ; CODE XREF: std::error_category::operator==(std::error_category const &)+18j
.text$mn:00001A55                 mov     al, byte ptr [ebp+var_4]
.text$mn:00001A58                 mov     esp, ebp
.text$mn:00001A5A                 pop     ebp
.text$mn:00001A5B                 retn    4
.text$mn:00001A5B ??8error_category@std@@QBE_NABV01@@Z endp
.text$mn:00001A5B
.text$mn:00001A5B ; ---------------------------------------------------------------------------
.text$mn:00001A5E                 align 10h
.text$mn:00001A5E _text$mn        ends
.text$mn:00001A5E
.text$mn:00001A60 ; ===========================================================================
.text$mn:00001A60
.text$mn:00001A60 ; Segment type: Pure code
.text$mn:00001A60 ; Segment permissions: Read/Execute
.text$mn:00001A60 _text$mn        segment para public 'CODE' use32
.text$mn:00001A60                 assume cs:_text$mn
.text$mn:00001A60                 ;org 1A60h
.text$mn:00001A60 ; COMDAT (pick any)
.text$mn:00001A60                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001A60
.text$mn:00001A60 ; =============== S U B R O U T I N E =======================================
.text$mn:00001A60
.text$mn:00001A60 ; Attributes: bp-based frame
.text$mn:00001A60
.text$mn:00001A60 ; int __stdcall std::error_condition::operator==(std::error_condition *)
.text$mn:00001A60                 public ??8error_condition@std@@QBE_NABV01@@Z
.text$mn:00001A60 ??8error_condition@std@@QBE_NABV01@@Z proc near
.text$mn:00001A60                                         ; CODE XREF: std::error_category::equivalent(int,std::error_condition const &)+24p
.text$mn:00001A60
.text$mn:00001A60 var_8           = dword ptr -8
.text$mn:00001A60 var_4           = dword ptr -4
.text$mn:00001A60 arg_0           = dword ptr  8
.text$mn:00001A60
.text$mn:00001A60                 push    ebp
.text$mn:00001A61                 mov     ebp, esp
.text$mn:00001A63                 sub     esp, 8
.text$mn:00001A66                 push    esi
.text$mn:00001A67                 mov     [ebp+var_4], ecx
.text$mn:00001A6A                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00001A6D                 call    ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
.text$mn:00001A72                 push    eax
.text$mn:00001A73                 mov     ecx, [ebp+var_4] ; this
.text$mn:00001A76                 call    ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
.text$mn:00001A7B                 mov     ecx, eax
.text$mn:00001A7D                 call    ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
.text$mn:00001A82                 movzx   eax, al
.text$mn:00001A85                 test    eax, eax
.text$mn:00001A87                 jz      short loc_1AA8
.text$mn:00001A89                 mov     ecx, [ebp+var_4] ; this
.text$mn:00001A8C                 call    ?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
.text$mn:00001A91                 mov     esi, eax
.text$mn:00001A93                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00001A96                 call    ?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
.text$mn:00001A9B                 cmp     esi, eax
.text$mn:00001A9D                 jnz     short loc_1AA8
.text$mn:00001A9F                 mov     [ebp+var_8], 1
.text$mn:00001AA6                 jmp     short loc_1AAF
.text$mn:00001AA8 ; ---------------------------------------------------------------------------
.text$mn:00001AA8
.text$mn:00001AA8 loc_1AA8:                               ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+27j
.text$mn:00001AA8                                         ; std::error_condition::operator==(std::error_condition const &)+3Dj
.text$mn:00001AA8                 mov     [ebp+var_8], 0
.text$mn:00001AAF
.text$mn:00001AAF loc_1AAF:                               ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+46j
.text$mn:00001AAF                 mov     al, byte ptr [ebp+var_8]
.text$mn:00001AB2                 pop     esi
.text$mn:00001AB3                 mov     esp, ebp
.text$mn:00001AB5                 pop     ebp
.text$mn:00001AB6                 retn    4
.text$mn:00001AB6 ??8error_condition@std@@QBE_NABV01@@Z endp
.text$mn:00001AB6
.text$mn:00001AB6 ; ---------------------------------------------------------------------------
.text$mn:00001AB9                 align 4
.text$mn:00001AB9 _text$mn        ends
.text$mn:00001AB9
.text$mn:00001ABC ; ===========================================================================
.text$mn:00001ABC
.text$mn:00001ABC ; Segment type: Pure code
.text$mn:00001ABC ; Segment permissions: Read/Execute
.text$mn:00001ABC _text$mn        segment para public 'CODE' use32
.text$mn:00001ABC                 assume cs:_text$mn
.text$mn:00001ABC                 ;org 1ABCh
.text$mn:00001ABC ; COMDAT (pick any)
.text$mn:00001ABC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001ABC
.text$mn:00001ABC ; =============== S U B R O U T I N E =======================================
.text$mn:00001ABC
.text$mn:00001ABC ; Attributes: bp-based frame
.text$mn:00001ABC
.text$mn:00001ABC ; public: virtual void * __thiscall std::_Generic_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00001ABC                 public ??_G_Generic_error_category@std@@UAEPAXI@Z
.text$mn:00001ABC ??_G_Generic_error_category@std@@UAEPAXI@Z proc near
.text$mn:00001ABC
.text$mn:00001ABC var_4           = dword ptr -4
.text$mn:00001ABC arg_0           = dword ptr  8
.text$mn:00001ABC
.text$mn:00001ABC                 push    ebp
.text$mn:00001ABD                 mov     ebp, esp
.text$mn:00001ABF                 push    ecx
.text$mn:00001AC0                 mov     [ebp+var_4], ecx
.text$mn:00001AC3                 mov     ecx, [ebp+var_4] ; this
.text$mn:00001AC6                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:00001ACB                 mov     eax, [ebp+arg_0]
.text$mn:00001ACE                 and     eax, 1
.text$mn:00001AD1                 jz      short loc_1ADF
.text$mn:00001AD3                 mov     ecx, [ebp+var_4]
.text$mn:00001AD6                 push    ecx             ; void *
.text$mn:00001AD7                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00001ADC                 add     esp, 4
.text$mn:00001ADF
.text$mn:00001ADF loc_1ADF:                               ; CODE XREF: std::_Generic_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00001ADF                 mov     eax, [ebp+var_4]
.text$mn:00001AE2                 mov     esp, ebp
.text$mn:00001AE4                 pop     ebp
.text$mn:00001AE5                 retn    4
.text$mn:00001AE5 ??_G_Generic_error_category@std@@UAEPAXI@Z endp
.text$mn:00001AE5
.text$mn:00001AE5 _text$mn        ends
.text$mn:00001AE5
.text$mn:00001AE8 ; ===========================================================================
.text$mn:00001AE8
.text$mn:00001AE8 ; Segment type: Pure code
.text$mn:00001AE8 ; Segment permissions: Read/Execute
.text$mn:00001AE8 _text$mn        segment para public 'CODE' use32
.text$mn:00001AE8                 assume cs:_text$mn
.text$mn:00001AE8                 ;org 1AE8h
.text$mn:00001AE8 ; COMDAT (pick any)
.text$mn:00001AE8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001AE8
.text$mn:00001AE8 ; =============== S U B R O U T I N E =======================================
.text$mn:00001AE8
.text$mn:00001AE8 ; Attributes: bp-based frame
.text$mn:00001AE8
.text$mn:00001AE8 ; public: virtual void * __thiscall std::_Iostream_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00001AE8                 public ??_G_Iostream_error_category@std@@UAEPAXI@Z
.text$mn:00001AE8 ??_G_Iostream_error_category@std@@UAEPAXI@Z proc near
.text$mn:00001AE8
.text$mn:00001AE8 var_4           = dword ptr -4
.text$mn:00001AE8 arg_0           = dword ptr  8
.text$mn:00001AE8
.text$mn:00001AE8                 push    ebp
.text$mn:00001AE9                 mov     ebp, esp
.text$mn:00001AEB                 push    ecx
.text$mn:00001AEC                 mov     [ebp+var_4], ecx
.text$mn:00001AEF                 mov     ecx, [ebp+var_4] ; this
.text$mn:00001AF2                 call    ??1_Iostream_error_category@std@@UAE@XZ ; std::_Iostream_error_category::~_Iostream_error_category(void)
.text$mn:00001AF7                 mov     eax, [ebp+arg_0]
.text$mn:00001AFA                 and     eax, 1
.text$mn:00001AFD                 jz      short loc_1B0B
.text$mn:00001AFF                 mov     ecx, [ebp+var_4]
.text$mn:00001B02                 push    ecx             ; void *
.text$mn:00001B03                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00001B08                 add     esp, 4
.text$mn:00001B0B
.text$mn:00001B0B loc_1B0B:                               ; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00001B0B                 mov     eax, [ebp+var_4]
.text$mn:00001B0E                 mov     esp, ebp
.text$mn:00001B10                 pop     ebp
.text$mn:00001B11                 retn    4
.text$mn:00001B11 ??_G_Iostream_error_category@std@@UAEPAXI@Z endp
.text$mn:00001B11
.text$mn:00001B11 _text$mn        ends
.text$mn:00001B11
.text$mn:00001B14 ; ===========================================================================
.text$mn:00001B14
.text$mn:00001B14 ; Segment type: Pure code
.text$mn:00001B14 ; Segment permissions: Read/Execute
.text$mn:00001B14 _text$mn        segment para public 'CODE' use32
.text$mn:00001B14                 assume cs:_text$mn
.text$mn:00001B14                 ;org 1B14h
.text$mn:00001B14 ; COMDAT (pick any)
.text$mn:00001B14                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001B14
.text$mn:00001B14 ; =============== S U B R O U T I N E =======================================
.text$mn:00001B14
.text$mn:00001B14 ; Attributes: bp-based frame
.text$mn:00001B14
.text$mn:00001B14 ; public: virtual void * __thiscall std::_System_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00001B14                 public ??_G_System_error_category@std@@UAEPAXI@Z
.text$mn:00001B14 ??_G_System_error_category@std@@UAEPAXI@Z proc near
.text$mn:00001B14
.text$mn:00001B14 var_4           = dword ptr -4
.text$mn:00001B14 arg_0           = dword ptr  8
.text$mn:00001B14
.text$mn:00001B14                 push    ebp
.text$mn:00001B15                 mov     ebp, esp
.text$mn:00001B17                 push    ecx
.text$mn:00001B18                 mov     [ebp+var_4], ecx
.text$mn:00001B1B                 mov     ecx, [ebp+var_4] ; this
.text$mn:00001B1E                 call    ??1_System_error_category@std@@UAE@XZ ; std::_System_error_category::~_System_error_category(void)
.text$mn:00001B23                 mov     eax, [ebp+arg_0]
.text$mn:00001B26                 and     eax, 1
.text$mn:00001B29                 jz      short loc_1B37
.text$mn:00001B2B                 mov     ecx, [ebp+var_4]
.text$mn:00001B2E                 push    ecx             ; void *
.text$mn:00001B2F                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00001B34                 add     esp, 4
.text$mn:00001B37
.text$mn:00001B37 loc_1B37:                               ; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00001B37                 mov     eax, [ebp+var_4]
.text$mn:00001B3A                 mov     esp, ebp
.text$mn:00001B3C                 pop     ebp
.text$mn:00001B3D                 retn    4
.text$mn:00001B3D ??_G_System_error_category@std@@UAEPAXI@Z endp
.text$mn:00001B3D
.text$mn:00001B3D _text$mn        ends
.text$mn:00001B3D
.text$mn:00001B40 ; ===========================================================================
.text$mn:00001B40
.text$mn:00001B40 ; Segment type: Pure code
.text$mn:00001B40 ; Segment permissions: Read/Execute
.text$mn:00001B40 _text$mn        segment para public 'CODE' use32
.text$mn:00001B40                 assume cs:_text$mn
.text$mn:00001B40                 ;org 1B40h
.text$mn:00001B40 ; COMDAT (pick any)
.text$mn:00001B40                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001B40
.text$mn:00001B40 ; =============== S U B R O U T I N E =======================================
.text$mn:00001B40
.text$mn:00001B40 ; Attributes: bp-based frame
.text$mn:00001B40
.text$mn:00001B40 ; public: virtual void * __thiscall std::error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00001B40                 public ??_Gerror_category@std@@UAEPAXI@Z
.text$mn:00001B40 ??_Gerror_category@std@@UAEPAXI@Z proc near
.text$mn:00001B40
.text$mn:00001B40 var_4           = dword ptr -4
.text$mn:00001B40 arg_0           = dword ptr  8
.text$mn:00001B40
.text$mn:00001B40                 push    ebp
.text$mn:00001B41                 mov     ebp, esp
.text$mn:00001B43                 push    ecx
.text$mn:00001B44                 mov     [ebp+var_4], ecx
.text$mn:00001B47                 mov     ecx, [ebp+var_4] ; this
.text$mn:00001B4A                 call    ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$mn:00001B4F                 mov     eax, [ebp+arg_0]
.text$mn:00001B52                 and     eax, 1
.text$mn:00001B55                 jz      short loc_1B63
.text$mn:00001B57                 mov     ecx, [ebp+var_4]
.text$mn:00001B5A                 push    ecx             ; void *
.text$mn:00001B5B                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00001B60                 add     esp, 4
.text$mn:00001B63
.text$mn:00001B63 loc_1B63:                               ; CODE XREF: std::error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00001B63                 mov     eax, [ebp+var_4]
.text$mn:00001B66                 mov     esp, ebp
.text$mn:00001B68                 pop     ebp
.text$mn:00001B69                 retn    4
.text$mn:00001B69 ??_Gerror_category@std@@UAEPAXI@Z endp
.text$mn:00001B69
.text$mn:00001B69 _text$mn        ends
.text$mn:00001B69
.text$di:00001B6C ; ===========================================================================
.text$di:00001B6C
.text$di:00001B6C ; Segment type: Pure code
.text$di:00001B6C ; Segment permissions: Read/Execute
.text$di:00001B6C _text$di        segment para public 'CODE' use32
.text$di:00001B6C                 assume cs:_text$di
.text$di:00001B6C                 ;org 1B6Ch
.text$di:00001B6C ; COMDAT (pick any)
.text$di:00001B6C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00001B6C
.text$di:00001B6C ; =============== S U B R O U T I N E =======================================
.text$di:00001B6C
.text$di:00001B6C ; Attributes: bp-based frame
.text$di:00001B6C
.text$di:00001B6C ; void __cdecl `dynamic initializer for 'public: static class std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
.text$di:00001B6C ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc near
.text$di:00001B6C                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Generic_object$initializer$)(void)o
.text$di:00001B6C                 push    ebp
.text$di:00001B6D                 mov     ebp, esp
.text$di:00001B6F                 mov     ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
.text$di:00001B74                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$di:00001B79                 push    offset ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:00001B7E                 call    _atexit
.text$di:00001B83                 add     esp, 4
.text$di:00001B86                 pop     ebp
.text$di:00001B87                 retn
.text$di:00001B87 ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp
.text$di:00001B87
.text$di:00001B87 _text$di        ends
.text$di:00001B87
.text$di:00001B88 ; ===========================================================================
.text$di:00001B88
.text$di:00001B88 ; Segment type: Pure code
.text$di:00001B88 ; Segment permissions: Read/Execute
.text$di:00001B88 _text$di        segment para public 'CODE' use32
.text$di:00001B88                 assume cs:_text$di
.text$di:00001B88                 ;org 1B88h
.text$di:00001B88 ; COMDAT (pick any)
.text$di:00001B88                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00001B88
.text$di:00001B88 ; =============== S U B R O U T I N E =======================================
.text$di:00001B88
.text$di:00001B88 ; Attributes: bp-based frame
.text$di:00001B88
.text$di:00001B88 ; void __cdecl `dynamic initializer for 'public: static class std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
.text$di:00001B88 ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
.text$di:00001B88                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Iostream_object$initializer$)(void)o
.text$di:00001B88                 push    ebp
.text$di:00001B89                 mov     ebp, esp
.text$di:00001B8B                 mov     ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
.text$di:00001B90                 call    ??0_Iostream_error_category@std@@QAE@XZ ; std::_Iostream_error_category::_Iostream_error_category(void)
.text$di:00001B95                 push    offset ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:00001B9A                 call    _atexit
.text$di:00001B9F                 add     esp, 4
.text$di:00001BA2                 pop     ebp
.text$di:00001BA3                 retn
.text$di:00001BA3 ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp
.text$di:00001BA3
.text$di:00001BA3 _text$di        ends
.text$di:00001BA3
.text$di:00001BA4 ; ===========================================================================
.text$di:00001BA4
.text$di:00001BA4 ; Segment type: Pure code
.text$di:00001BA4 ; Segment permissions: Read/Execute
.text$di:00001BA4 _text$di        segment para public 'CODE' use32
.text$di:00001BA4                 assume cs:_text$di
.text$di:00001BA4                 ;org 1BA4h
.text$di:00001BA4 ; COMDAT (pick any)
.text$di:00001BA4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00001BA4
.text$di:00001BA4 ; =============== S U B R O U T I N E =======================================
.text$di:00001BA4
.text$di:00001BA4 ; Attributes: bp-based frame
.text$di:00001BA4
.text$di:00001BA4 ; void __cdecl `dynamic initializer for 'public: static class std::_System_error_category std::_Error_objects<int>::_System_object''(void)
.text$di:00001BA4 ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
.text$di:00001BA4                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_System_object$initializer$)(void)o
.text$di:00001BA4                 push    ebp
.text$di:00001BA5                 mov     ebp, esp
.text$di:00001BA7                 mov     ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
.text$di:00001BAC                 call    ??0_System_error_category@std@@QAE@XZ ; std::_System_error_category::_System_error_category(void)
.text$di:00001BB1                 push    offset ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:00001BB6                 call    _atexit
.text$di:00001BBB                 add     esp, 4
.text$di:00001BBE                 pop     ebp
.text$di:00001BBF                 retn
.text$di:00001BBF ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp
.text$di:00001BBF
.text$di:00001BBF _text$di        ends
.text$di:00001BBF
.text$di:00001BC0 ; ===========================================================================
.text$di:00001BC0
.text$di:00001BC0 ; Segment type: Pure code
.text$di:00001BC0 ; Segment permissions: Read/Execute
.text$di:00001BC0 _text$di        segment para public 'CODE' use32
.text$di:00001BC0                 assume cs:_text$di
.text$di:00001BC0                 ;org 1BC0h
.text$di:00001BC0 ; COMDAT (pick any)
.text$di:00001BC0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00001BC0
.text$di:00001BC0 ; =============== S U B R O U T I N E =======================================
.text$di:00001BC0
.text$di:00001BC0 ; Attributes: bp-based frame
.text$di:00001BC0
.text$di:00001BC0 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::num_put<char, class std::back_insert_iterator<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>::id''(void)
.text$di:00001BC0 ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00001BC0                                         ; DATA XREF: .CRT$XCU:void (*std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id$initializer$)(void)o
.text$di:00001BC0                 push    ebp
.text$di:00001BC1                 mov     ebp, esp
.text$di:00001BC3                 push    0               ; unsigned int
.text$di:00001BC5                 mov     ecx, offset ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; this
.text$di:00001BCA                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00001BCF                 pop     ebp
.text$di:00001BD0                 retn
.text$di:00001BD0 ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00001BD0
.text$di:00001BD0 ; ---------------------------------------------------------------------------
.text$di:00001BD1                 align 4
.text$di:00001BD1 _text$di        ends
.text$di:00001BD1
.text$di:00001BD4 ; ===========================================================================
.text$di:00001BD4
.text$di:00001BD4 ; Segment type: Pure code
.text$di:00001BD4 ; Segment permissions: Read/Execute
.text$di:00001BD4 _text$di        segment para public 'CODE' use32
.text$di:00001BD4                 assume cs:_text$di
.text$di:00001BD4                 ;org 1BD4h
.text$di:00001BD4 ; COMDAT (pick any)
.text$di:00001BD4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00001BD4
.text$di:00001BD4 ; =============== S U B R O U T I N E =======================================
.text$di:00001BD4
.text$di:00001BD4 ; Attributes: bp-based frame
.text$di:00001BD4
.text$di:00001BD4 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::num_put<wchar_t, class std::back_insert_iterator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::id''(void)
.text$di:00001BD4 ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00001BD4                                         ; DATA XREF: .CRT$XCU:void (*std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id$initializer$)(void)o
.text$di:00001BD4                 push    ebp
.text$di:00001BD5                 mov     ebp, esp
.text$di:00001BD7                 push    0               ; unsigned int
.text$di:00001BD9                 mov     ecx, offset ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; this
.text$di:00001BDE                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00001BE3                 pop     ebp
.text$di:00001BE4                 retn
.text$di:00001BE4 ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00001BE4
.text$di:00001BE4 ; ---------------------------------------------------------------------------
.text$di:00001BE5                 align 4
.text$di:00001BE5 _text$di        ends
.text$di:00001BE5
.text$di:00001BE8 ; ===========================================================================
.text$di:00001BE8
.text$di:00001BE8 ; Segment type: Pure code
.text$di:00001BE8 ; Segment permissions: Read/Execute
.text$di:00001BE8 _text$di        segment para public 'CODE' use32
.text$di:00001BE8                 assume cs:_text$di
.text$di:00001BE8                 ;org 1BE8h
.text$di:00001BE8 ; COMDAT (pick any)
.text$di:00001BE8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00001BE8
.text$di:00001BE8 ; =============== S U B R O U T I N E =======================================
.text$di:00001BE8
.text$di:00001BE8 ; Attributes: bp-based frame
.text$di:00001BE8
.text$di:00001BE8 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::numpunct<char>::id''(void)
.text$di:00001BE8 ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00001BE8                                         ; DATA XREF: .CRT$XCU:void (*std::numpunct<char>::id$initializer$)(void)o
.text$di:00001BE8                 push    ebp
.text$di:00001BE9                 mov     ebp, esp
.text$di:00001BEB                 push    0               ; unsigned int
.text$di:00001BED                 mov     ecx, offset ?id@?$numpunct@D@std@@2V0locale@2@A ; this
.text$di:00001BF2                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00001BF7                 pop     ebp
.text$di:00001BF8                 retn
.text$di:00001BF8 ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00001BF8
.text$di:00001BF8 ; ---------------------------------------------------------------------------
.text$di:00001BF9                 align 4
.text$di:00001BF9 _text$di        ends
.text$di:00001BF9
.text$di:00001BFC ; ===========================================================================
.text$di:00001BFC
.text$di:00001BFC ; Segment type: Pure code
.text$di:00001BFC ; Segment permissions: Read/Execute
.text$di:00001BFC _text$di        segment para public 'CODE' use32
.text$di:00001BFC                 assume cs:_text$di
.text$di:00001BFC                 ;org 1BFCh
.text$di:00001BFC ; COMDAT (pick any)
.text$di:00001BFC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00001BFC
.text$di:00001BFC ; =============== S U B R O U T I N E =======================================
.text$di:00001BFC
.text$di:00001BFC ; Attributes: bp-based frame
.text$di:00001BFC
.text$di:00001BFC ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::numpunct<wchar_t>::id''(void)
.text$di:00001BFC ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00001BFC                                         ; DATA XREF: .CRT$XCU:void (*std::numpunct<wchar_t>::id$initializer$)(void)o
.text$di:00001BFC                 push    ebp
.text$di:00001BFD                 mov     ebp, esp
.text$di:00001BFF                 push    0               ; unsigned int
.text$di:00001C01                 mov     ecx, offset ?id@?$numpunct@_W@std@@2V0locale@2@A ; this
.text$di:00001C06                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00001C0B                 pop     ebp
.text$di:00001C0C                 retn
.text$di:00001C0C ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00001C0C
.text$di:00001C0C ; ---------------------------------------------------------------------------
.text$di:00001C0D                 align 10h
.text$di:00001C0D _text$di        ends
.text$di:00001C0D
.text$di:00001C10 ; ===========================================================================
.text$di:00001C10
.text$di:00001C10 ; Segment type: Pure code
.text$di:00001C10 ; Segment permissions: Read/Execute
.text$di:00001C10 _text$di        segment para public 'CODE' use32
.text$di:00001C10                 assume cs:_text$di
.text$di:00001C10                 ;org 1C10h
.text$di:00001C10 ; COMDAT (pick any)
.text$di:00001C10                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00001C10
.text$di:00001C10 ; =============== S U B R O U T I N E =======================================
.text$di:00001C10
.text$di:00001C10 ; Attributes: bp-based frame
.text$di:00001C10
.text$di:00001C10 ; void __cdecl std::`dynamic initializer for '_Tuple_alloc''(void)
.text$di:00001C10 ??__E_Tuple_alloc@std@@YAXXZ proc near  ; DATA XREF: .CRT$XCU:__Tuple_alloc$initializer$o
.text$di:00001C10
.text$di:00001C10 var_1           = byte ptr -1
.text$di:00001C10
.text$di:00001C10                 push    ebp
.text$di:00001C11                 mov     ebp, esp
.text$di:00001C13                 push    ecx
.text$di:00001C14                 xor     eax, eax
.text$di:00001C16                 mov     [ebp+var_1], al
.text$di:00001C19                 mov     esp, ebp
.text$di:00001C1B                 pop     ebp
.text$di:00001C1C                 retn
.text$di:00001C1C ??__E_Tuple_alloc@std@@YAXXZ endp
.text$di:00001C1C
.text$di:00001C1C ; ---------------------------------------------------------------------------
.text$di:00001C1D                 align 10h
.text$di:00001C1D _text$di        ends
.text$di:00001C1D
.text$di:00001C20 ; ===========================================================================
.text$di:00001C20
.text$di:00001C20 ; Segment type: Pure code
.text$di:00001C20 ; Segment permissions: Read/Execute
.text$di:00001C20 _text$di        segment para public 'CODE' use32
.text$di:00001C20                 assume cs:_text$di
.text$di:00001C20                 ;org 1C20h
.text$di:00001C20 ; COMDAT (pick any)
.text$di:00001C20                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00001C20
.text$di:00001C20 ; =============== S U B R O U T I N E =======================================
.text$di:00001C20
.text$di:00001C20 ; Attributes: bp-based frame
.text$di:00001C20
.text$di:00001C20 ; void __cdecl std::`dynamic initializer for 'allocator_arg''(void)
.text$di:00001C20 ??__Eallocator_arg@std@@YAXXZ proc near ; DATA XREF: .CRT$XCU:_allocator_arg$initializer$o
.text$di:00001C20
.text$di:00001C20 var_1           = byte ptr -1
.text$di:00001C20
.text$di:00001C20                 push    ebp
.text$di:00001C21                 mov     ebp, esp
.text$di:00001C23                 push    ecx
.text$di:00001C24                 xor     eax, eax
.text$di:00001C26                 mov     [ebp+var_1], al
.text$di:00001C29                 mov     esp, ebp
.text$di:00001C2B                 pop     ebp
.text$di:00001C2C                 retn
.text$di:00001C2C ??__Eallocator_arg@std@@YAXXZ endp
.text$di:00001C2C
.text$di:00001C2C ; ---------------------------------------------------------------------------
.text$di:00001C2D                 align 10h
.text$di:00001C2D _text$di        ends
.text$di:00001C2D
.text$di:00001C30 ; ===========================================================================
.text$di:00001C30
.text$di:00001C30 ; Segment type: Pure code
.text$di:00001C30 ; Segment permissions: Read/Execute
.text$di:00001C30 _text$di        segment para public 'CODE' use32
.text$di:00001C30                 assume cs:_text$di
.text$di:00001C30                 ;org 1C30h
.text$di:00001C30 ; COMDAT (pick any)
.text$di:00001C30                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00001C30
.text$di:00001C30 ; =============== S U B R O U T I N E =======================================
.text$di:00001C30
.text$di:00001C30 ; Attributes: bp-based frame
.text$di:00001C30
.text$di:00001C30 ; void __cdecl std::`dynamic initializer for 'ignore''(void)
.text$di:00001C30 ??__Eignore@std@@YAXXZ proc near        ; DATA XREF: .CRT$XCU:_ignore$initializer$o
.text$di:00001C30                 push    ebp
.text$di:00001C31                 mov     ebp, esp
.text$di:00001C33                 mov     ecx, offset _ignore ; this
.text$di:00001C38                 call    ??0_Ignore@std@@QAE@XZ ; std::_Ignore::_Ignore(void)
.text$di:00001C3D                 pop     ebp
.text$di:00001C3E                 retn
.text$di:00001C3E ??__Eignore@std@@YAXXZ endp
.text$di:00001C3E
.text$di:00001C3E ; ---------------------------------------------------------------------------
.text$di:00001C3F                 align 10h
.text$di:00001C3F _text$di        ends
.text$di:00001C3F
.text$di:00001C40 ; ===========================================================================
.text$di:00001C40
.text$di:00001C40 ; Segment type: Pure code
.text$di:00001C40 ; Segment permissions: Read/Execute
.text$di:00001C40 _text$di        segment para public 'CODE' use32
.text$di:00001C40                 assume cs:_text$di
.text$di:00001C40                 ;org 1C40h
.text$di:00001C40 ; COMDAT (pick any)
.text$di:00001C40                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00001C40
.text$di:00001C40 ; =============== S U B R O U T I N E =======================================
.text$di:00001C40
.text$di:00001C40 ; Attributes: bp-based frame
.text$di:00001C40
.text$di:00001C40 ; void __cdecl std::`dynamic initializer for 'piecewise_construct''(void)
.text$di:00001C40 ??__Epiecewise_construct@std@@YAXXZ proc near
.text$di:00001C40                                         ; DATA XREF: .CRT$XCU:_piecewise_construct$initializer$o
.text$di:00001C40
.text$di:00001C40 var_1           = byte ptr -1
.text$di:00001C40
.text$di:00001C40                 push    ebp
.text$di:00001C41                 mov     ebp, esp
.text$di:00001C43                 push    ecx
.text$di:00001C44                 xor     eax, eax
.text$di:00001C46                 mov     [ebp+var_1], al
.text$di:00001C49                 mov     esp, ebp
.text$di:00001C4B                 pop     ebp
.text$di:00001C4C                 retn
.text$di:00001C4C ??__Epiecewise_construct@std@@YAXXZ endp
.text$di:00001C4C
.text$di:00001C4C ; ---------------------------------------------------------------------------
.text$di:00001C4D                 align 10h
.text$di:00001C4D _text$di        ends
.text$di:00001C4D
.text$yd:00001C50 ; ===========================================================================
.text$yd:00001C50
.text$yd:00001C50 ; Segment type: Pure code
.text$yd:00001C50 ; Segment permissions: Read/Execute
.text$yd:00001C50 _text$yd        segment para public 'CODE' use32
.text$yd:00001C50                 assume cs:_text$yd
.text$yd:00001C50                 ;org 1C50h
.text$yd:00001C50 ; COMDAT (pick any)
.text$yd:00001C50                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$yd:00001C50
.text$yd:00001C50 ; =============== S U B R O U T I N E =======================================
.text$yd:00001C50
.text$yd:00001C50 ; Attributes: bp-based frame
.text$yd:00001C50
.text$yd:00001C50 ; void __cdecl `dynamic atexit destructor for 'public: static std::_Generic_error_category std::_Error_objects<int>::_Generic_object''()
.text$yd:00001C50 ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc near
.text$yd:00001C50                                         ; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+Do
.text$yd:00001C50                 push    ebp
.text$yd:00001C51                 mov     ebp, esp
.text$yd:00001C53                 mov     ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
.text$yd:00001C58                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$yd:00001C5D                 pop     ebp
.text$yd:00001C5E                 retn
.text$yd:00001C5E ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp
.text$yd:00001C5E
.text$yd:00001C5E ; ---------------------------------------------------------------------------
.text$yd:00001C5F                 align 10h
.text$yd:00001C5F _text$yd        ends
.text$yd:00001C5F
.text$yd:00001C60 ; ===========================================================================
.text$yd:00001C60
.text$yd:00001C60 ; Segment type: Pure code
.text$yd:00001C60 ; Segment permissions: Read/Execute
.text$yd:00001C60 _text$yd        segment para public 'CODE' use32
.text$yd:00001C60                 assume cs:_text$yd
.text$yd:00001C60                 ;org 1C60h
.text$yd:00001C60 ; COMDAT (pick any)
.text$yd:00001C60                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$yd:00001C60
.text$yd:00001C60 ; =============== S U B R O U T I N E =======================================
.text$yd:00001C60
.text$yd:00001C60 ; Attributes: bp-based frame
.text$yd:00001C60
.text$yd:00001C60 ; void __cdecl `dynamic atexit destructor for 'public: static std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''()
.text$yd:00001C60 ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
.text$yd:00001C60                                         ; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+Do
.text$yd:00001C60                 push    ebp
.text$yd:00001C61                 mov     ebp, esp
.text$yd:00001C63                 mov     ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
.text$yd:00001C68                 call    ??1_Iostream_error_category@std@@UAE@XZ ; std::_Iostream_error_category::~_Iostream_error_category(void)
.text$yd:00001C6D                 pop     ebp
.text$yd:00001C6E                 retn
.text$yd:00001C6E ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp
.text$yd:00001C6E
.text$yd:00001C6E ; ---------------------------------------------------------------------------
.text$yd:00001C6F                 align 10h
.text$yd:00001C6F _text$yd        ends
.text$yd:00001C6F
.text$yd:00001C70 ; ===========================================================================
.text$yd:00001C70
.text$yd:00001C70 ; Segment type: Pure code
.text$yd:00001C70 ; Segment permissions: Read/Execute
.text$yd:00001C70 _text$yd        segment para public 'CODE' use32
.text$yd:00001C70                 assume cs:_text$yd
.text$yd:00001C70                 ;org 1C70h
.text$yd:00001C70 ; COMDAT (pick any)
.text$yd:00001C70                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$yd:00001C70
.text$yd:00001C70 ; =============== S U B R O U T I N E =======================================
.text$yd:00001C70
.text$yd:00001C70 ; Attributes: bp-based frame
.text$yd:00001C70
.text$yd:00001C70 ; void __cdecl `dynamic atexit destructor for 'public: static std::_System_error_category std::_Error_objects<int>::_System_object''()
.text$yd:00001C70 ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
.text$yd:00001C70                                         ; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+Do
.text$yd:00001C70                 push    ebp
.text$yd:00001C71                 mov     ebp, esp
.text$yd:00001C73                 mov     ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
.text$yd:00001C78                 call    ??1_System_error_category@std@@UAE@XZ ; std::_System_error_category::~_System_error_category(void)
.text$yd:00001C7D                 pop     ebp
.text$yd:00001C7E                 retn
.text$yd:00001C7E ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp
.text$yd:00001C7E
.text$yd:00001C7E ; ---------------------------------------------------------------------------
.text$yd:00001C7F                 align 10h
.text$yd:00001C7F _text$yd        ends
.text$yd:00001C7F
.text$mn:00001C80 ; ===========================================================================
.text$mn:00001C80
.text$mn:00001C80 ; Segment type: Pure code
.text$mn:00001C80 ; Segment permissions: Read/Execute
.text$mn:00001C80 _text$mn        segment para public 'CODE' use32
.text$mn:00001C80                 assume cs:_text$mn
.text$mn:00001C80                 ;org 1C80h
.text$mn:00001C80 ; COMDAT (pick any)
.text$mn:00001C80                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001C80
.text$mn:00001C80 ; =============== S U B R O U T I N E =======================================
.text$mn:00001C80
.text$mn:00001C80 ; Attributes: bp-based frame
.text$mn:00001C80
.text$mn:00001C80 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Alloc_proxy(void)
.text$mn:00001C80                 public ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
.text$mn:00001C80 ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00001C80                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+38p
.text$mn:00001C80
.text$mn:00001C80 var_10          = byte ptr -10h
.text$mn:00001C80 var_8           = dword ptr -8
.text$mn:00001C80 var_1           = byte ptr -1
.text$mn:00001C80
.text$mn:00001C80                 push    ebp
.text$mn:00001C81                 mov     ebp, esp
.text$mn:00001C83                 sub     esp, 10h
.text$mn:00001C86                 mov     [ebp+var_8], ecx
.text$mn:00001C89                 lea     ecx, [ebp+var_1]
.text$mn:00001C8C                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:00001C91                 push    1
.text$mn:00001C93                 lea     ecx, [ebp+var_1]
.text$mn:00001C96                 call    ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate(uint)
.text$mn:00001C9B                 mov     ecx, [ebp+var_8]
.text$mn:00001C9E                 mov     [ecx], eax
.text$mn:00001CA0                 lea     ecx, [ebp+var_10] ; this
.text$mn:00001CA3                 call    ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy(void)
.text$mn:00001CA8                 push    eax             ; int
.text$mn:00001CA9                 mov     edx, [ebp+var_8]
.text$mn:00001CAC                 mov     eax, [edx]
.text$mn:00001CAE                 push    eax             ; void *
.text$mn:00001CAF                 lea     ecx, [ebp+var_1]
.text$mn:00001CB2                 call    ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:00001CB7                 mov     ecx, [ebp+var_8]
.text$mn:00001CBA                 mov     edx, [ecx]
.text$mn:00001CBC                 mov     eax, [ebp+var_8]
.text$mn:00001CBF                 mov     [edx], eax
.text$mn:00001CC1                 mov     esp, ebp
.text$mn:00001CC3                 pop     ebp
.text$mn:00001CC4                 retn
.text$mn:00001CC4 ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp
.text$mn:00001CC4
.text$mn:00001CC4 ; ---------------------------------------------------------------------------
.text$mn:00001CC5                 align 4
.text$mn:00001CC5 _text$mn        ends
.text$mn:00001CC5
.text$mn:00001CC8 ; ===========================================================================
.text$mn:00001CC8
.text$mn:00001CC8 ; Segment type: Pure code
.text$mn:00001CC8 ; Segment permissions: Read/Execute
.text$mn:00001CC8 _text$mn        segment para public 'CODE' use32
.text$mn:00001CC8                 assume cs:_text$mn
.text$mn:00001CC8                 ;org 1CC8h
.text$mn:00001CC8 ; COMDAT (pick any)
.text$mn:00001CC8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001CC8
.text$mn:00001CC8 ; =============== S U B R O U T I N E =======================================
.text$mn:00001CC8
.text$mn:00001CC8 ; Attributes: bp-based frame
.text$mn:00001CC8
.text$mn:00001CC8 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Copy(unsigned int, unsigned int)
.text$mn:00001CC8                 public ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00001CC8 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
.text$mn:00001CC8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+37p
.text$mn:00001CC8
.text$mn:00001CC8 var_20          = dword ptr -20h
.text$mn:00001CC8 var_1C          = dword ptr -1Ch
.text$mn:00001CC8 var_18          = dword ptr -18h
.text$mn:00001CC8 var_11          = byte ptr -11h
.text$mn:00001CC8 var_10          = dword ptr -10h
.text$mn:00001CC8 var_C           = byte ptr -0Ch
.text$mn:00001CC8 var_4           = dword ptr -4
.text$mn:00001CC8 arg_0           = dword ptr  8
.text$mn:00001CC8
.text$mn:00001CC8 ; FUNCTION CHUNK AT .text$mn:00001DEA SIZE 00000009 BYTES
.text$mn:00001CC8
.text$mn:00001CC8                 push    ebp
.text$mn:00001CC9                 mov     ebp, esp
.text$mn:00001CCB                 push    0FFFFFFFFh
.text$mn:00001CCD                 push    offset __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00001CD2                 mov     eax, large fs:0
.text$mn:00001CD8                 push    eax
.text$mn:00001CD9                 push    ecx
.text$mn:00001CDA                 sub     esp, 10h
.text$mn:00001CDD                 push    ebx
.text$mn:00001CDE                 push    esi
.text$mn:00001CDF                 push    edi
.text$mn:00001CE0                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001CE5                 xor     eax, ebp
.text$mn:00001CE7                 push    eax
.text$mn:00001CE8                 lea     eax, [ebp+var_C]
.text$mn:00001CEB                 mov     large fs:0, eax
.text$mn:00001CF1                 mov     [ebp+var_10], esp
.text$mn:00001CF4                 mov     [ebp+var_18], ecx
.text$mn:00001CF7                 mov     eax, [ebp+arg_0]
.text$mn:00001CFA                 or      eax, 0Fh
.text$mn:00001CFD                 mov     [ebp+var_1C], eax
.text$mn:00001D00                 mov     ecx, [ebp+var_18]
.text$mn:00001D03                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00001D08                 cmp     eax, [ebp+var_1C]
.text$mn:00001D0B                 jnb     short loc_1D15
.text$mn:00001D0D                 mov     ecx, [ebp+arg_0]
.text$mn:00001D10                 mov     [ebp+var_1C], ecx
.text$mn:00001D13                 jmp     short loc_1D67
.text$mn:00001D15 ; ---------------------------------------------------------------------------
.text$mn:00001D15
.text$mn:00001D15 loc_1D15:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+43j
.text$mn:00001D15                 mov     edx, [ebp+var_18]
.text$mn:00001D18                 mov     ecx, [edx+18h]
.text$mn:00001D1B                 shr     ecx, 1
.text$mn:00001D1D                 mov     eax, [ebp+var_1C]
.text$mn:00001D20                 xor     edx, edx
.text$mn:00001D22                 mov     esi, 3
.text$mn:00001D27                 div     esi
.text$mn:00001D29                 cmp     ecx, eax
.text$mn:00001D2B                 ja      short loc_1D2F
.text$mn:00001D2D                 jmp     short loc_1D67
.text$mn:00001D2F ; ---------------------------------------------------------------------------
.text$mn:00001D2F
.text$mn:00001D2F loc_1D2F:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+63j
.text$mn:00001D2F                 mov     ecx, [ebp+var_18]
.text$mn:00001D32                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00001D37                 mov     edx, [ebp+var_18]
.text$mn:00001D3A                 mov     ecx, [edx+18h]
.text$mn:00001D3D                 shr     ecx, 1
.text$mn:00001D3F                 sub     eax, ecx
.text$mn:00001D41                 mov     edx, [ebp+var_18]
.text$mn:00001D44                 cmp     [edx+18h], eax
.text$mn:00001D47                 ja      short loc_1D5C
.text$mn:00001D49                 mov     eax, [ebp+var_18]
.text$mn:00001D4C                 mov     ecx, [eax+18h]
.text$mn:00001D4F                 shr     ecx, 1
.text$mn:00001D51                 mov     edx, [ebp+var_18]
.text$mn:00001D54                 add     ecx, [edx+18h]
.text$mn:00001D57                 mov     [ebp+var_1C], ecx
.text$mn:00001D5A                 jmp     short loc_1D67
.text$mn:00001D5C ; ---------------------------------------------------------------------------
.text$mn:00001D5C
.text$mn:00001D5C loc_1D5C:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+7Fj
.text$mn:00001D5C                 mov     ecx, [ebp+var_18]
.text$mn:00001D5F                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00001D64                 mov     [ebp+var_1C], eax
.text$mn:00001D67
.text$mn:00001D67 loc_1D67:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+4Bj
.text$mn:00001D67                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+65j ...
.text$mn:00001D67                 mov     [ebp+var_4], 0
.text$mn:00001D6E                 mov     eax, [ebp+var_1C]
.text$mn:00001D71                 add     eax, 1
.text$mn:00001D74                 push    eax
.text$mn:00001D75                 lea     ecx, [ebp+var_11]
.text$mn:00001D78                 push    ecx
.text$mn:00001D79                 mov     ecx, [ebp+var_18]
.text$mn:00001D7C                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00001D81                 mov     ecx, eax
.text$mn:00001D83                 call    ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
.text$mn:00001D88                 mov     [ebp+var_20], eax
.text$mn:00001D8B                 jmp     short loc_1DEA
.text$mn:00001D8B ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp
.text$mn:00001D8B
.text$mn:00001D8D
.text$mn:00001D8D ; =============== S U B R O U T I N E =======================================
.text$mn:00001D8D
.text$mn:00001D8D
.text$mn:00001D8D __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 proc near
.text$mn:00001D8D                                         ; DATA XREF: .xdata$x:00002C14o
.text$mn:00001D8D
.text$mn:00001D8D ; FUNCTION CHUNK AT .text$mn:00001DD4 SIZE 00000009 BYTES
.text$mn:00001D8D ; FUNCTION CHUNK AT .text$mn:00001DE4 SIZE 00000006 BYTES
.text$mn:00001D8D
.text$mn:00001D8D                 mov     [ebp-10h], esp
.text$mn:00001D90                 mov     edx, [ebp+8]
.text$mn:00001D93                 mov     [ebp-1Ch], edx
.text$mn:00001D96                 mov     byte ptr [ebp-4], 2
.text$mn:00001D9A                 mov     eax, [ebp-1Ch]
.text$mn:00001D9D                 add     eax, 1
.text$mn:00001DA0                 push    eax
.text$mn:00001DA1                 lea     ecx, [ebp-12h]
.text$mn:00001DA4                 push    ecx
.text$mn:00001DA5                 mov     ecx, [ebp-18h]
.text$mn:00001DA8                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00001DAD                 mov     ecx, eax
.text$mn:00001DAF                 call    ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
.text$mn:00001DB4                 mov     [ebp-20h], eax
.text$mn:00001DB7                 jmp     short loc_1DD4
.text$mn:00001DB7 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 endp
.text$mn:00001DB7
.text$mn:00001DB9
.text$mn:00001DB9 ; =============== S U B R O U T I N E =======================================
.text$mn:00001DB9
.text$mn:00001DB9 ; Attributes: noreturn
.text$mn:00001DB9
.text$mn:00001DB9 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 proc near
.text$mn:00001DB9                                         ; DATA XREF: .xdata$x:00002C24o
.text$mn:00001DB9                 push    0               ; Size
.text$mn:00001DBB                 push    1               ; char
.text$mn:00001DBD                 mov     ecx, [ebp-18h]
.text$mn:00001DC0                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00001DC5                 push    0
.text$mn:00001DC7                 push    0
.text$mn:00001DC9                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00001DC9 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 endp
.text$mn:00001DC9
.text$mn:00001DCE ; ---------------------------------------------------------------------------
.text$mn:00001DCE                 mov     eax, offset $LN17
.text$mn:00001DD3                 retn
.text$mn:00001DD4 ; ---------------------------------------------------------------------------
.text$mn:00001DD4 ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00001DD4
.text$mn:00001DD4 loc_1DD4:                               ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+2Aj
.text$mn:00001DD4                 mov     dword ptr [ebp-4], 1
.text$mn:00001DDB                 jmp     short loc_1DE4
.text$mn:00001DDB ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00001DDD
.text$mn:00001DDD ; =============== S U B R O U T I N E =======================================
.text$mn:00001DDD
.text$mn:00001DDD
.text$mn:00001DDD $LN17           proc near               ; DATA XREF: .text$mn:00001DCEo
.text$mn:00001DDD                 mov     dword ptr [ebp-4], 1
.text$mn:00001DDD $LN17           endp ; sp-analysis failed
.text$mn:00001DDD
.text$mn:00001DE4 ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00001DE4
.text$mn:00001DE4 loc_1DE4:                               ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+4Ej
.text$mn:00001DE4                 mov     eax, offset $LN19
.text$mn:00001DE9                 retn
.text$mn:00001DE9 ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00001DEA ; ---------------------------------------------------------------------------
.text$mn:00001DEA ; START OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00001DEA
.text$mn:00001DEA loc_1DEA:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+C3j
.text$mn:00001DEA                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001DF1                 jmp     short loc_1DFA
.text$mn:00001DF1 ; END OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00001DF3
.text$mn:00001DF3 ; =============== S U B R O U T I N E =======================================
.text$mn:00001DF3
.text$mn:00001DF3
.text$mn:00001DF3 $LN19           proc near               ; DATA XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:loc_1DE4o
.text$mn:00001DF3                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:00001DFA
.text$mn:00001DFA loc_1DFA:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+129j
.text$mn:00001DFA                 cmp     dword ptr [ebp+0Ch], 0
.text$mn:00001DFE                 jbe     short loc_1E19
.text$mn:00001E00                 mov     edx, [ebp+0Ch]
.text$mn:00001E03                 push    edx             ; Size
.text$mn:00001E04                 mov     ecx, [ebp-18h]
.text$mn:00001E07                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00001E0C                 push    eax             ; Src
.text$mn:00001E0D                 mov     eax, [ebp-20h]
.text$mn:00001E10                 push    eax             ; Dst
.text$mn:00001E11                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00001E16                 add     esp, 0Ch
.text$mn:00001E19
.text$mn:00001E19 loc_1E19:                               ; CODE XREF: $LN19+Bj
.text$mn:00001E19                 push    0               ; Size
.text$mn:00001E1B                 push    1               ; char
.text$mn:00001E1D                 mov     ecx, [ebp-18h]
.text$mn:00001E20                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00001E25                 lea     ecx, [ebp-20h]
.text$mn:00001E28                 push    ecx             ; int
.text$mn:00001E29                 mov     edx, [ebp-18h]
.text$mn:00001E2C                 add     edx, 4
.text$mn:00001E2F                 push    edx             ; void *
.text$mn:00001E30                 lea     eax, [ebp-13h]
.text$mn:00001E33                 push    eax
.text$mn:00001E34                 mov     ecx, [ebp-18h]
.text$mn:00001E37                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00001E3C                 mov     ecx, eax
.text$mn:00001E3E                 call    ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)
.text$mn:00001E43                 mov     ecx, [ebp-18h]
.text$mn:00001E46                 mov     edx, [ebp-1Ch]
.text$mn:00001E49                 mov     [ecx+18h], edx
.text$mn:00001E4C                 mov     eax, [ebp+0Ch]
.text$mn:00001E4F                 push    eax
.text$mn:00001E50                 mov     ecx, [ebp-18h]
.text$mn:00001E53                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00001E58                 mov     ecx, [ebp-0Ch]
.text$mn:00001E5B                 mov     large fs:0, ecx
.text$mn:00001E62                 pop     ecx
.text$mn:00001E63                 pop     edi
.text$mn:00001E64                 pop     esi
.text$mn:00001E65                 pop     ebx
.text$mn:00001E66                 mov     esp, ebp
.text$mn:00001E68                 pop     ebp
.text$mn:00001E69                 retn    8
.text$mn:00001E69 $LN19           endp ; sp-analysis failed
.text$mn:00001E69
.text$mn:00001E69 _text$mn        ends
.text$mn:00001E69
.text$x:00001E6C ; ===========================================================================
.text$x:00001E6C
.text$x:00001E6C ; Segment type: Pure code
.text$x:00001E6C ; Segment permissions: Read/Execute
.text$x:00001E6C _text$x         segment para public 'CODE' use32
.text$x:00001E6C                 assume cs:_text$x
.text$x:00001E6C                 ;org 1E6Ch
.text$x:00001E6C ; COMDAT (pick associative to section at 1CC8)
.text$x:00001E6C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00001E6C
.text$x:00001E6C ; =============== S U B R O U T I N E =======================================
.text$x:00001E6C
.text$x:00001E6C
.text$x:00001E6C __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
.text$x:00001E6C                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+5o
.text$x:00001E6C
.text$x:00001E6C arg_4           = dword ptr  8
.text$x:00001E6C
.text$x:00001E6C                 mov     edx, [esp+arg_4]
.text$x:00001E70                 lea     eax, [edx+0Ch]
.text$x:00001E73                 mov     ecx, [edx-24h]
.text$x:00001E76                 xor     ecx, eax
.text$x:00001E78                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001E7D                 mov     eax, offset __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$x:00001E82                 jmp     ___CxxFrameHandler3
.text$x:00001E82 __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp
.text$x:00001E82
.text$x:00001E82 ; ---------------------------------------------------------------------------
.text$x:00001E87                 align 4
.text$x:00001E87 _text$x         ends
.text$x:00001E87
.text$mn:00001E88 ; ===========================================================================
.text$mn:00001E88
.text$mn:00001E88 ; Segment type: Pure code
.text$mn:00001E88 ; Segment permissions: Read/Execute
.text$mn:00001E88 _text$mn        segment para public 'CODE' use32
.text$mn:00001E88                 assume cs:_text$mn
.text$mn:00001E88                 ;org 1E88h
.text$mn:00001E88 ; COMDAT (pick any)
.text$mn:00001E88                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001E88
.text$mn:00001E88 ; =============== S U B R O U T I N E =======================================
.text$mn:00001E88
.text$mn:00001E88 ; Attributes: bp-based frame
.text$mn:00001E88
.text$mn:00001E88 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Eos(unsigned int)
.text$mn:00001E88                 public ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
.text$mn:00001E88 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z proc near
.text$mn:00001E88                                         ; CODE XREF: $LN19+60p
.text$mn:00001E88                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+83p ...
.text$mn:00001E88
.text$mn:00001E88 var_8           = dword ptr -8
.text$mn:00001E88 var_1           = byte ptr -1
.text$mn:00001E88 arg_0           = dword ptr  8
.text$mn:00001E88
.text$mn:00001E88                 push    ebp
.text$mn:00001E89                 mov     ebp, esp
.text$mn:00001E8B                 sub     esp, 8
.text$mn:00001E8E                 mov     [ebp+var_8], ecx
.text$mn:00001E91                 mov     [ebp+var_1], 0
.text$mn:00001E95                 mov     eax, [ebp+var_8]
.text$mn:00001E98                 mov     ecx, [ebp+arg_0]
.text$mn:00001E9B                 mov     [eax+14h], ecx
.text$mn:00001E9E                 lea     edx, [ebp+var_1]
.text$mn:00001EA1                 push    edx
.text$mn:00001EA2                 mov     ecx, [ebp+var_8]
.text$mn:00001EA5                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00001EAA                 add     eax, [ebp+arg_0]
.text$mn:00001EAD                 push    eax
.text$mn:00001EAE                 call    ?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign(char &,char const &)
.text$mn:00001EB3                 add     esp, 8
.text$mn:00001EB6                 mov     esp, ebp
.text$mn:00001EB8                 pop     ebp
.text$mn:00001EB9                 retn    4
.text$mn:00001EB9 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z endp
.text$mn:00001EB9
.text$mn:00001EB9 _text$mn        ends
.text$mn:00001EB9
.text$mn:00001EBC ; ===========================================================================
.text$mn:00001EBC
.text$mn:00001EBC ; Segment type: Pure code
.text$mn:00001EBC ; Segment permissions: Read/Execute
.text$mn:00001EBC _text$mn        segment para public 'CODE' use32
.text$mn:00001EBC                 assume cs:_text$mn
.text$mn:00001EBC                 ;org 1EBCh
.text$mn:00001EBC ; COMDAT (pick any)
.text$mn:00001EBC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001EBC
.text$mn:00001EBC ; =============== S U B R O U T I N E =======================================
.text$mn:00001EBC
.text$mn:00001EBC ; Attributes: bp-based frame
.text$mn:00001EBC
.text$mn:00001EBC ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Free_proxy(void)
.text$mn:00001EBC                 public ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
.text$mn:00001EBC ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00001EBC                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+30p
.text$mn:00001EBC
.text$mn:00001EBC var_8           = dword ptr -8
.text$mn:00001EBC var_1           = byte ptr -1
.text$mn:00001EBC
.text$mn:00001EBC                 push    ebp
.text$mn:00001EBD                 mov     ebp, esp
.text$mn:00001EBF                 sub     esp, 8
.text$mn:00001EC2                 mov     [ebp+var_8], ecx
.text$mn:00001EC5                 lea     ecx, [ebp+var_1]
.text$mn:00001EC8                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:00001ECD                 mov     ecx, [ebp+var_8] ; this
.text$mn:00001ED0                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00001ED5                 mov     eax, [ebp+var_8]
.text$mn:00001ED8                 mov     ecx, [eax]
.text$mn:00001EDA                 push    ecx
.text$mn:00001EDB                 lea     ecx, [ebp+var_1]
.text$mn:00001EDE                 call    ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:00001EE3                 push    1               ; int
.text$mn:00001EE5                 mov     edx, [ebp+var_8]
.text$mn:00001EE8                 mov     eax, [edx]
.text$mn:00001EEA                 push    eax             ; void *
.text$mn:00001EEB                 lea     ecx, [ebp+var_1]
.text$mn:00001EEE                 call    ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate(std::_Container_proxy *,uint)
.text$mn:00001EF3                 mov     ecx, [ebp+var_8]
.text$mn:00001EF6                 mov     dword ptr [ecx], 0
.text$mn:00001EFC                 mov     esp, ebp
.text$mn:00001EFE                 pop     ebp
.text$mn:00001EFF                 retn
.text$mn:00001EFF ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp
.text$mn:00001EFF
.text$mn:00001EFF _text$mn        ends
.text$mn:00001EFF
.text$mn:00001F00 ; ===========================================================================
.text$mn:00001F00
.text$mn:00001F00 ; Segment type: Pure code
.text$mn:00001F00 ; Segment permissions: Read/Execute
.text$mn:00001F00 _text$mn        segment para public 'CODE' use32
.text$mn:00001F00                 assume cs:_text$mn
.text$mn:00001F00                 ;org 1F00h
.text$mn:00001F00 ; COMDAT (pick any)
.text$mn:00001F00                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001F00
.text$mn:00001F00 ; =============== S U B R O U T I N E =======================================
.text$mn:00001F00
.text$mn:00001F00 ; Attributes: bp-based frame
.text$mn:00001F00
.text$mn:00001F00 ; public: struct std::_Wrap_alloc<class std::allocator<char>> __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Getal(void)const
.text$mn:00001F00                 public ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
.text$mn:00001F00 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ proc near
.text$mn:00001F00                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+B4p
.text$mn:00001F00                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+1Bp ...
.text$mn:00001F00
.text$mn:00001F00 var_4           = dword ptr -4
.text$mn:00001F00 arg_0           = dword ptr  8
.text$mn:00001F00
.text$mn:00001F00                 push    ebp
.text$mn:00001F01                 mov     ebp, esp
.text$mn:00001F03                 push    ecx
.text$mn:00001F04                 mov     [ebp+var_4], ecx
.text$mn:00001F07                 mov     ecx, [ebp+arg_0]
.text$mn:00001F0A                 call    ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)
.text$mn:00001F0F                 mov     eax, [ebp+arg_0]
.text$mn:00001F12                 mov     esp, ebp
.text$mn:00001F14                 pop     ebp
.text$mn:00001F15                 retn    4
.text$mn:00001F15 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ endp
.text$mn:00001F15
.text$mn:00001F15 _text$mn        ends
.text$mn:00001F15
.text$mn:00001F18 ; ===========================================================================
.text$mn:00001F18
.text$mn:00001F18 ; Segment type: Pure code
.text$mn:00001F18 ; Segment permissions: Read/Execute
.text$mn:00001F18 _text$mn        segment para public 'CODE' use32
.text$mn:00001F18                 assume cs:_text$mn
.text$mn:00001F18                 ;org 1F18h
.text$mn:00001F18 ; COMDAT (pick any)
.text$mn:00001F18                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001F18
.text$mn:00001F18 ; =============== S U B R O U T I N E =======================================
.text$mn:00001F18
.text$mn:00001F18 ; Attributes: bp-based frame
.text$mn:00001F18
.text$mn:00001F18 ; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Grow(unsigned int, bool)
.text$mn:00001F18                 public ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
.text$mn:00001F18 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z proc near
.text$mn:00001F18                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+6Ap
.text$mn:00001F18                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+5Fp
.text$mn:00001F18
.text$mn:00001F18 var_C           = dword ptr -0Ch
.text$mn:00001F18 Size            = dword ptr -8
.text$mn:00001F18 var_4           = dword ptr -4
.text$mn:00001F18 arg_0           = dword ptr  8
.text$mn:00001F18 arg_4           = byte ptr  0Ch
.text$mn:00001F18
.text$mn:00001F18                 push    ebp
.text$mn:00001F19                 mov     ebp, esp
.text$mn:00001F1B                 sub     esp, 0Ch
.text$mn:00001F1E                 mov     [ebp+var_4], ecx
.text$mn:00001F21                 mov     ecx, [ebp+var_4]
.text$mn:00001F24                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00001F29                 cmp     eax, [ebp+arg_0]
.text$mn:00001F2C                 jnb     short loc_1F36
.text$mn:00001F2E                 mov     ecx, [ebp+var_4]
.text$mn:00001F31                 call    ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)
.text$mn:00001F36
.text$mn:00001F36 loc_1F36:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+14j
.text$mn:00001F36                 mov     eax, [ebp+var_4]
.text$mn:00001F39                 mov     ecx, [eax+18h]
.text$mn:00001F3C                 cmp     ecx, [ebp+arg_0]
.text$mn:00001F3F                 jnb     short loc_1F56
.text$mn:00001F41                 mov     edx, [ebp+var_4]
.text$mn:00001F44                 mov     eax, [edx+14h]
.text$mn:00001F47                 push    eax
.text$mn:00001F48                 mov     ecx, [ebp+arg_0]
.text$mn:00001F4B                 push    ecx
.text$mn:00001F4C                 mov     ecx, [ebp+var_4]
.text$mn:00001F4F                 call    ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)
.text$mn:00001F54                 jmp     short loc_1FA0
.text$mn:00001F56 ; ---------------------------------------------------------------------------
.text$mn:00001F56
.text$mn:00001F56 loc_1F56:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+27j
.text$mn:00001F56                 movzx   edx, [ebp+arg_4]
.text$mn:00001F5A                 test    edx, edx
.text$mn:00001F5C                 jz      short loc_1F90
.text$mn:00001F5E                 cmp     [ebp+arg_0], 10h
.text$mn:00001F62                 jnb     short loc_1F90
.text$mn:00001F64                 mov     eax, [ebp+var_4]
.text$mn:00001F67                 mov     ecx, [ebp+arg_0]
.text$mn:00001F6A                 cmp     ecx, [eax+14h]
.text$mn:00001F6D                 jnb     short loc_1F77
.text$mn:00001F6F                 mov     edx, [ebp+arg_0]
.text$mn:00001F72                 mov     [ebp+Size], edx
.text$mn:00001F75                 jmp     short loc_1F80
.text$mn:00001F77 ; ---------------------------------------------------------------------------
.text$mn:00001F77
.text$mn:00001F77 loc_1F77:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+55j
.text$mn:00001F77                 mov     eax, [ebp+var_4]
.text$mn:00001F7A                 mov     ecx, [eax+14h]
.text$mn:00001F7D                 mov     [ebp+Size], ecx
.text$mn:00001F80
.text$mn:00001F80 loc_1F80:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+5Dj
.text$mn:00001F80                 mov     edx, [ebp+Size]
.text$mn:00001F83                 push    edx             ; Size
.text$mn:00001F84                 push    1               ; char
.text$mn:00001F86                 mov     ecx, [ebp+var_4]
.text$mn:00001F89                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00001F8E                 jmp     short loc_1FA0
.text$mn:00001F90 ; ---------------------------------------------------------------------------
.text$mn:00001F90
.text$mn:00001F90 loc_1F90:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+44j
.text$mn:00001F90                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+4Aj
.text$mn:00001F90                 cmp     [ebp+arg_0], 0
.text$mn:00001F94                 jnz     short loc_1FA0
.text$mn:00001F96                 push    0
.text$mn:00001F98                 mov     ecx, [ebp+var_4]
.text$mn:00001F9B                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00001FA0
.text$mn:00001FA0 loc_1FA0:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+3Cj
.text$mn:00001FA0                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+76j ...
.text$mn:00001FA0                 cmp     [ebp+arg_0], 0
.text$mn:00001FA4                 jbe     short loc_1FAF
.text$mn:00001FA6                 mov     [ebp+var_C], 1
.text$mn:00001FAD                 jmp     short loc_1FB6
.text$mn:00001FAF ; ---------------------------------------------------------------------------
.text$mn:00001FAF
.text$mn:00001FAF loc_1FAF:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+8Cj
.text$mn:00001FAF                 mov     [ebp+var_C], 0
.text$mn:00001FB6
.text$mn:00001FB6 loc_1FB6:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+95j
.text$mn:00001FB6                 mov     al, byte ptr [ebp+var_C]
.text$mn:00001FB9                 mov     esp, ebp
.text$mn:00001FBB                 pop     ebp
.text$mn:00001FBC                 retn    8
.text$mn:00001FBC ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z endp
.text$mn:00001FBC
.text$mn:00001FBC ; ---------------------------------------------------------------------------
.text$mn:00001FBF                 align 10h
.text$mn:00001FBF _text$mn        ends
.text$mn:00001FBF
.text$mn:00001FC0 ; ===========================================================================
.text$mn:00001FC0
.text$mn:00001FC0 ; Segment type: Pure code
.text$mn:00001FC0 ; Segment permissions: Read/Execute
.text$mn:00001FC0 _text$mn        segment para public 'CODE' use32
.text$mn:00001FC0                 assume cs:_text$mn
.text$mn:00001FC0                 ;org 1FC0h
.text$mn:00001FC0 ; COMDAT (pick any)
.text$mn:00001FC0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001FC0
.text$mn:00001FC0 ; =============== S U B R O U T I N E =======================================
.text$mn:00001FC0
.text$mn:00001FC0 ; Attributes: bp-based frame
.text$mn:00001FC0
.text$mn:00001FC0 ; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Inside(char const *)
.text$mn:00001FC0                 public ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
.text$mn:00001FC0 ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z proc near
.text$mn:00001FC0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+2Ap
.text$mn:00001FC0
.text$mn:00001FC0 var_4           = dword ptr -4
.text$mn:00001FC0 arg_0           = dword ptr  8
.text$mn:00001FC0
.text$mn:00001FC0                 push    ebp
.text$mn:00001FC1                 mov     ebp, esp
.text$mn:00001FC3                 push    ecx
.text$mn:00001FC4                 mov     [ebp+var_4], ecx
.text$mn:00001FC7                 cmp     [ebp+arg_0], 0
.text$mn:00001FCB                 jz      short loc_1FED
.text$mn:00001FCD                 mov     ecx, [ebp+var_4]
.text$mn:00001FD0                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00001FD5                 cmp     [ebp+arg_0], eax
.text$mn:00001FD8                 jb      short loc_1FED
.text$mn:00001FDA                 mov     ecx, [ebp+var_4]
.text$mn:00001FDD                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00001FE2                 mov     ecx, [ebp+var_4]
.text$mn:00001FE5                 add     eax, [ecx+14h]
.text$mn:00001FE8                 cmp     eax, [ebp+arg_0]
.text$mn:00001FEB                 ja      short loc_1FF3
.text$mn:00001FED
.text$mn:00001FED loc_1FED:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+Bj
.text$mn:00001FED                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+18j
.text$mn:00001FED                 xor     al, al
.text$mn:00001FEF                 jmp     short loc_1FF5
.text$mn:00001FF1 ; ---------------------------------------------------------------------------
.text$mn:00001FF1                 jmp     short loc_1FF5
.text$mn:00001FF3 ; ---------------------------------------------------------------------------
.text$mn:00001FF3
.text$mn:00001FF3 loc_1FF3:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+2Bj
.text$mn:00001FF3                 mov     al, 1
.text$mn:00001FF5
.text$mn:00001FF5 loc_1FF5:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+2Fj
.text$mn:00001FF5                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+31j
.text$mn:00001FF5                 mov     esp, ebp
.text$mn:00001FF7                 pop     ebp
.text$mn:00001FF8                 retn    4
.text$mn:00001FF8 ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z endp
.text$mn:00001FF8
.text$mn:00001FF8 ; ---------------------------------------------------------------------------
.text$mn:00001FFB                 align 4
.text$mn:00001FFB _text$mn        ends
.text$mn:00001FFB
.text$mn:00001FFC ; ===========================================================================
.text$mn:00001FFC
.text$mn:00001FFC ; Segment type: Pure code
.text$mn:00001FFC ; Segment permissions: Read/Execute
.text$mn:00001FFC _text$mn        segment para public 'CODE' use32
.text$mn:00001FFC                 assume cs:_text$mn
.text$mn:00001FFC                 ;org 1FFCh
.text$mn:00001FFC ; COMDAT (pick any)
.text$mn:00001FFC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001FFC
.text$mn:00001FFC ; =============== S U B R O U T I N E =======================================
.text$mn:00001FFC
.text$mn:00001FFC ; Attributes: bp-based frame
.text$mn:00001FFC
.text$mn:00001FFC ; public: char * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)
.text$mn:00001FFC                 public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
.text$mn:00001FFC ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ proc near
.text$mn:00001FFC                                         ; CODE XREF: $LN19+14p
.text$mn:00001FFC                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+1Dp ...
.text$mn:00001FFC
.text$mn:00001FFC var_8           = dword ptr -8
.text$mn:00001FFC var_4           = dword ptr -4
.text$mn:00001FFC
.text$mn:00001FFC                 push    ebp
.text$mn:00001FFD                 mov     ebp, esp
.text$mn:00001FFF                 sub     esp, 8
.text$mn:00002002                 mov     [ebp+var_4], ecx
.text$mn:00002005                 mov     eax, [ebp+var_4]
.text$mn:00002008                 cmp     dword ptr [eax+18h], 10h
.text$mn:0000200C                 jb      short loc_2022
.text$mn:0000200E                 mov     ecx, [ebp+var_4]
.text$mn:00002011                 mov     edx, [ecx+4]
.text$mn:00002014                 push    edx
.text$mn:00002015                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:0000201A                 add     esp, 4
.text$mn:0000201D                 mov     [ebp+var_8], eax
.text$mn:00002020                 jmp     short loc_202B
.text$mn:00002022 ; ---------------------------------------------------------------------------
.text$mn:00002022
.text$mn:00002022 loc_2022:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+10j
.text$mn:00002022                 mov     eax, [ebp+var_4]
.text$mn:00002025                 add     eax, 4
.text$mn:00002028                 mov     [ebp+var_8], eax
.text$mn:0000202B
.text$mn:0000202B loc_202B:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+24j
.text$mn:0000202B                 mov     eax, [ebp+var_8]
.text$mn:0000202E                 mov     esp, ebp
.text$mn:00002030                 pop     ebp
.text$mn:00002031                 retn
.text$mn:00002031 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ endp
.text$mn:00002031
.text$mn:00002031 ; ---------------------------------------------------------------------------
.text$mn:00002032                 align 4
.text$mn:00002032 _text$mn        ends
.text$mn:00002032
.text$mn:00002034 ; ===========================================================================
.text$mn:00002034
.text$mn:00002034 ; Segment type: Pure code
.text$mn:00002034 ; Segment permissions: Read/Execute
.text$mn:00002034 _text$mn        segment para public 'CODE' use32
.text$mn:00002034                 assume cs:_text$mn
.text$mn:00002034                 ;org 2034h
.text$mn:00002034 ; COMDAT (pick any)
.text$mn:00002034                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002034
.text$mn:00002034 ; =============== S U B R O U T I N E =======================================
.text$mn:00002034
.text$mn:00002034 ; Attributes: bp-based frame
.text$mn:00002034
.text$mn:00002034 ; public: char const * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)const
.text$mn:00002034                 public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
.text$mn:00002034 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ proc near
.text$mn:00002034                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+7Dp
.text$mn:00002034
.text$mn:00002034 var_8           = dword ptr -8
.text$mn:00002034 var_4           = dword ptr -4
.text$mn:00002034
.text$mn:00002034                 push    ebp
.text$mn:00002035                 mov     ebp, esp
.text$mn:00002037                 sub     esp, 8
.text$mn:0000203A                 mov     [ebp+var_4], ecx
.text$mn:0000203D                 mov     eax, [ebp+var_4]
.text$mn:00002040                 cmp     dword ptr [eax+18h], 10h
.text$mn:00002044                 jb      short loc_205A
.text$mn:00002046                 mov     ecx, [ebp+var_4]
.text$mn:00002049                 mov     edx, [ecx+4]
.text$mn:0000204C                 push    edx
.text$mn:0000204D                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:00002052                 add     esp, 4
.text$mn:00002055                 mov     [ebp+var_8], eax
.text$mn:00002058                 jmp     short loc_2063
.text$mn:0000205A ; ---------------------------------------------------------------------------
.text$mn:0000205A
.text$mn:0000205A loc_205A:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+10j
.text$mn:0000205A                 mov     eax, [ebp+var_4]
.text$mn:0000205D                 add     eax, 4
.text$mn:00002060                 mov     [ebp+var_8], eax
.text$mn:00002063
.text$mn:00002063 loc_2063:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+24j
.text$mn:00002063                 mov     eax, [ebp+var_8]
.text$mn:00002066                 mov     esp, ebp
.text$mn:00002068                 pop     ebp
.text$mn:00002069                 retn
.text$mn:00002069 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ endp
.text$mn:00002069
.text$mn:00002069 ; ---------------------------------------------------------------------------
.text$mn:0000206A                 align 4
.text$mn:0000206A _text$mn        ends
.text$mn:0000206A
.text$mn:0000206C ; ===========================================================================
.text$mn:0000206C
.text$mn:0000206C ; Segment type: Pure code
.text$mn:0000206C ; Segment permissions: Read/Execute
.text$mn:0000206C _text$mn        segment para public 'CODE' use32
.text$mn:0000206C                 assume cs:_text$mn
.text$mn:0000206C                 ;org 206Ch
.text$mn:0000206C ; COMDAT (pick any)
.text$mn:0000206C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000206C
.text$mn:0000206C ; =============== S U B R O U T I N E =======================================
.text$mn:0000206C
.text$mn:0000206C ; Attributes: bp-based frame
.text$mn:0000206C
.text$mn:0000206C ; void __thiscall std::_Container_base12::_Orphan_all(std::_Container_base12 *__hidden this)
.text$mn:0000206C                 public ?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$mn:0000206C ?_Orphan_all@_Container_base12@std@@QAEXXZ proc near
.text$mn:0000206C                                         ; CODE XREF: std::_Container_base12::~_Container_base12(void)+Ap
.text$mn:0000206C                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+14p
.text$mn:0000206C
.text$mn:0000206C var_18          = byte ptr -18h
.text$mn:0000206C var_14          = dword ptr -14h
.text$mn:0000206C var_10          = dword ptr -10h
.text$mn:0000206C var_C           = dword ptr -0Ch
.text$mn:0000206C var_4           = dword ptr -4
.text$mn:0000206C
.text$mn:0000206C                 push    ebp
.text$mn:0000206D                 mov     ebp, esp
.text$mn:0000206F                 push    0FFFFFFFFh
.text$mn:00002071                 push    offset __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$mn:00002076                 mov     eax, large fs:0
.text$mn:0000207C                 push    eax
.text$mn:0000207D                 sub     esp, 0Ch
.text$mn:00002080                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002085                 xor     eax, ebp
.text$mn:00002087                 push    eax
.text$mn:00002088                 lea     eax, [ebp+var_C]
.text$mn:0000208B                 mov     large fs:0, eax
.text$mn:00002091                 mov     [ebp+var_14], ecx
.text$mn:00002094                 mov     eax, [ebp+var_14]
.text$mn:00002097                 cmp     dword ptr [eax], 0
.text$mn:0000209A                 jz      short loc_20F7
.text$mn:0000209C                 push    3               ; int
.text$mn:0000209E                 lea     ecx, [ebp+var_18] ; this
.text$mn:000020A1                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:000020A6                 mov     [ebp+var_4], 0
.text$mn:000020AD                 mov     ecx, [ebp+var_14]
.text$mn:000020B0                 mov     edx, [ecx]
.text$mn:000020B2                 add     edx, 4
.text$mn:000020B5                 mov     [ebp+var_10], edx
.text$mn:000020B8                 jmp     short loc_20C7
.text$mn:000020BA ; ---------------------------------------------------------------------------
.text$mn:000020BA
.text$mn:000020BA loc_20BA:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+6Ej
.text$mn:000020BA                 mov     eax, [ebp+var_10]
.text$mn:000020BD                 mov     ecx, [eax]
.text$mn:000020BF                 mov     edx, [ebp+var_10]
.text$mn:000020C2                 mov     eax, [ecx+4]
.text$mn:000020C5                 mov     [edx], eax
.text$mn:000020C7
.text$mn:000020C7 loc_20C7:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+4Cj
.text$mn:000020C7                 mov     ecx, [ebp+var_10]
.text$mn:000020CA                 cmp     dword ptr [ecx], 0
.text$mn:000020CD                 jz      short loc_20DC
.text$mn:000020CF                 mov     edx, [ebp+var_10]
.text$mn:000020D2                 mov     eax, [edx]
.text$mn:000020D4                 mov     dword ptr [eax], 0
.text$mn:000020DA                 jmp     short loc_20BA
.text$mn:000020DC ; ---------------------------------------------------------------------------
.text$mn:000020DC
.text$mn:000020DC loc_20DC:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+61j
.text$mn:000020DC                 mov     ecx, [ebp+var_14]
.text$mn:000020DF                 mov     edx, [ecx]
.text$mn:000020E1                 mov     dword ptr [edx+4], 0
.text$mn:000020E8                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000020EF                 lea     ecx, [ebp+var_18] ; this
.text$mn:000020F2                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:000020F7
.text$mn:000020F7 loc_20F7:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+2Ej
.text$mn:000020F7                 mov     ecx, [ebp+var_C]
.text$mn:000020FA                 mov     large fs:0, ecx
.text$mn:00002101                 pop     ecx
.text$mn:00002102                 mov     esp, ebp
.text$mn:00002104                 pop     ebp
.text$mn:00002105                 retn
.text$mn:00002105 ?_Orphan_all@_Container_base12@std@@QAEXXZ endp
.text$mn:00002105
.text$mn:00002105 ; ---------------------------------------------------------------------------
.text$mn:00002106                 align 4
.text$mn:00002106 _text$mn        ends
.text$mn:00002106
.text$x:00002108 ; ===========================================================================
.text$x:00002108
.text$x:00002108 ; Segment type: Pure code
.text$x:00002108 ; Segment permissions: Read/Execute
.text$x:00002108 _text$x         segment para public 'CODE' use32
.text$x:00002108                 assume cs:_text$x
.text$x:00002108                 ;org 2108h
.text$x:00002108 ; COMDAT (pick associative to section at 206C)
.text$x:00002108                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00002108
.text$x:00002108 ; =============== S U B R O U T I N E =======================================
.text$x:00002108
.text$x:00002108
.text$x:00002108 __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0 proc near
.text$x:00002108                                         ; DATA XREF: .xdata$x:00002AD8o
.text$x:00002108                 lea     ecx, [ebp-18h]  ; this
.text$x:0000210B                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:0000210B __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0 endp
.text$x:0000210B
.text$x:00002110
.text$x:00002110 ; =============== S U B R O U T I N E =======================================
.text$x:00002110
.text$x:00002110
.text$x:00002110 __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ proc near
.text$x:00002110                                         ; DATA XREF: std::_Container_base12::_Orphan_all(void)+5o
.text$x:00002110
.text$x:00002110 arg_4           = dword ptr  8
.text$x:00002110
.text$x:00002110                 mov     edx, [esp+arg_4]
.text$x:00002114                 lea     eax, [edx+0Ch]
.text$x:00002117                 mov     ecx, [edx-10h]
.text$x:0000211A                 xor     ecx, eax
.text$x:0000211C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002121                 mov     eax, offset __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$x:00002126                 jmp     ___CxxFrameHandler3
.text$x:00002126 __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ endp
.text$x:00002126
.text$x:00002126 ; ---------------------------------------------------------------------------
.text$x:0000212B                 align 4
.text$x:0000212B _text$x         ends
.text$x:0000212B
.text$mn:0000212C ; ===========================================================================
.text$mn:0000212C
.text$mn:0000212C ; Segment type: Pure code
.text$mn:0000212C ; Segment permissions: Read/Execute
.text$mn:0000212C _text$mn        segment para public 'CODE' use32
.text$mn:0000212C                 assume cs:_text$mn
.text$mn:0000212C                 ;org 212Ch
.text$mn:0000212C ; COMDAT (pick any)
.text$mn:0000212C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000212C
.text$mn:0000212C ; =============== S U B R O U T I N E =======================================
.text$mn:0000212C
.text$mn:0000212C ; Attributes: bp-based frame
.text$mn:0000212C
.text$mn:0000212C ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(char, size_t Size)
.text$mn:0000212C                 public ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
.text$mn:0000212C ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z proc near
.text$mn:0000212C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+47p
.text$mn:0000212C                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+34p ...
.text$mn:0000212C
.text$mn:0000212C var_C           = dword ptr -0Ch
.text$mn:0000212C var_8           = dword ptr -8
.text$mn:0000212C var_2           = byte ptr -2
.text$mn:0000212C var_1           = byte ptr -1
.text$mn:0000212C arg_0           = byte ptr  8
.text$mn:0000212C Size            = dword ptr  0Ch
.text$mn:0000212C
.text$mn:0000212C                 push    ebp
.text$mn:0000212D                 mov     ebp, esp
.text$mn:0000212F                 sub     esp, 0Ch
.text$mn:00002132                 mov     [ebp+var_8], ecx
.text$mn:00002135                 movzx   eax, [ebp+arg_0]
.text$mn:00002139                 test    eax, eax
.text$mn:0000213B                 jnz     short loc_213F
.text$mn:0000213D                 jmp     short loc_21B2
.text$mn:0000213F ; ---------------------------------------------------------------------------
.text$mn:0000213F
.text$mn:0000213F loc_213F:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+Fj
.text$mn:0000213F                 mov     ecx, [ebp+var_8]
.text$mn:00002142                 cmp     dword ptr [ecx+18h], 10h
.text$mn:00002146                 jb      short loc_21B2
.text$mn:00002148                 mov     edx, [ebp+var_8]
.text$mn:0000214B                 mov     eax, [edx+4]
.text$mn:0000214E                 mov     [ebp+var_C], eax
.text$mn:00002151                 mov     ecx, [ebp+var_8]
.text$mn:00002154                 add     ecx, 4
.text$mn:00002157                 push    ecx
.text$mn:00002158                 lea     edx, [ebp+var_1]
.text$mn:0000215B                 push    edx
.text$mn:0000215C                 mov     ecx, [ebp+var_8]
.text$mn:0000215F                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00002164                 mov     ecx, eax
.text$mn:00002166                 call    ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)
.text$mn:0000216B                 cmp     [ebp+Size], 0
.text$mn:0000216F                 jbe     short loc_2191
.text$mn:00002171                 mov     eax, [ebp+Size]
.text$mn:00002174                 push    eax             ; Size
.text$mn:00002175                 mov     ecx, [ebp+var_C]
.text$mn:00002178                 push    ecx
.text$mn:00002179                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:0000217E                 add     esp, 4
.text$mn:00002181                 push    eax             ; Src
.text$mn:00002182                 mov     edx, [ebp+var_8]
.text$mn:00002185                 add     edx, 4
.text$mn:00002188                 push    edx             ; Dst
.text$mn:00002189                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:0000218E                 add     esp, 0Ch
.text$mn:00002191
.text$mn:00002191 loc_2191:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+43j
.text$mn:00002191                 mov     eax, [ebp+var_8]
.text$mn:00002194                 mov     ecx, [eax+18h]
.text$mn:00002197                 add     ecx, 1
.text$mn:0000219A                 push    ecx             ; int
.text$mn:0000219B                 mov     edx, [ebp+var_C]
.text$mn:0000219E                 push    edx             ; void *
.text$mn:0000219F                 lea     eax, [ebp+var_2]
.text$mn:000021A2                 push    eax
.text$mn:000021A3                 mov     ecx, [ebp+var_8]
.text$mn:000021A6                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:000021AB                 mov     ecx, eax
.text$mn:000021AD                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)
.text$mn:000021B2
.text$mn:000021B2 loc_21B2:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+11j
.text$mn:000021B2                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+1Aj
.text$mn:000021B2                 mov     ecx, [ebp+var_8]
.text$mn:000021B5                 mov     dword ptr [ecx+18h], 0Fh
.text$mn:000021BC                 mov     edx, [ebp+Size]
.text$mn:000021BF                 push    edx
.text$mn:000021C0                 mov     ecx, [ebp+var_8]
.text$mn:000021C3                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000021C8                 mov     esp, ebp
.text$mn:000021CA                 pop     ebp
.text$mn:000021CB                 retn    8
.text$mn:000021CB ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z endp
.text$mn:000021CB
.text$mn:000021CB ; ---------------------------------------------------------------------------
.text$mn:000021CE                 align 10h
.text$mn:000021CE _text$mn        ends
.text$mn:000021CE
.text$mn:000021D0 ; ===========================================================================
.text$mn:000021D0
.text$mn:000021D0 ; Segment type: Pure code
.text$mn:000021D0 ; Segment permissions: Read/Execute
.text$mn:000021D0 _text$mn        segment para public 'CODE' use32
.text$mn:000021D0                 assume cs:_text$mn
.text$mn:000021D0                 ;org 21D0h
.text$mn:000021D0 ; COMDAT (pick any)
.text$mn:000021D0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000021D0
.text$mn:000021D0 ; =============== S U B R O U T I N E =======================================
.text$mn:000021D0
.text$mn:000021D0 ; Attributes: bp-based frame
.text$mn:000021D0
.text$mn:000021D0 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xlen(void)const
.text$mn:000021D0                 public ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
.text$mn:000021D0 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc near
.text$mn:000021D0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+19p
.text$mn:000021D0
.text$mn:000021D0 var_4           = dword ptr -4
.text$mn:000021D0
.text$mn:000021D0                 push    ebp
.text$mn:000021D1                 mov     ebp, esp
.text$mn:000021D3                 push    ecx
.text$mn:000021D4                 mov     [ebp+var_4], ecx
.text$mn:000021D7                 push    offset ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ ; "string too long"
.text$mn:000021DC                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:000021E1                 mov     esp, ebp
.text$mn:000021E3                 pop     ebp
.text$mn:000021E4                 retn
.text$mn:000021E4 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp
.text$mn:000021E4
.text$mn:000021E4 ; ---------------------------------------------------------------------------
.text$mn:000021E5                 align 4
.text$mn:000021E5 _text$mn        ends
.text$mn:000021E5
.text$mn:000021E8 ; ===========================================================================
.text$mn:000021E8
.text$mn:000021E8 ; Segment type: Pure code
.text$mn:000021E8 ; Segment permissions: Read/Execute
.text$mn:000021E8 _text$mn        segment para public 'CODE' use32
.text$mn:000021E8                 assume cs:_text$mn
.text$mn:000021E8                 ;org 21E8h
.text$mn:000021E8 ; COMDAT (pick any)
.text$mn:000021E8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000021E8
.text$mn:000021E8 ; =============== S U B R O U T I N E =======================================
.text$mn:000021E8
.text$mn:000021E8 ; Attributes: bp-based frame
.text$mn:000021E8
.text$mn:000021E8 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xran(void)const
.text$mn:000021E8                 public ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
.text$mn:000021E8 ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc near
.text$mn:000021E8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+19p
.text$mn:000021E8                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)+15p ...
.text$mn:000021E8
.text$mn:000021E8 var_4           = dword ptr -4
.text$mn:000021E8
.text$mn:000021E8                 push    ebp
.text$mn:000021E9                 mov     ebp, esp
.text$mn:000021EB                 push    ecx
.text$mn:000021EC                 mov     [ebp+var_4], ecx
.text$mn:000021EF                 push    offset ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; "invalid string position"
.text$mn:000021F4                 call    ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range(char const *)
.text$mn:000021F9                 mov     esp, ebp
.text$mn:000021FB                 pop     ebp
.text$mn:000021FC                 retn
.text$mn:000021FC ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp
.text$mn:000021FC
.text$mn:000021FC ; ---------------------------------------------------------------------------
.text$mn:000021FD                 align 10h
.text$mn:000021FD _text$mn        ends
.text$mn:000021FD
.text$mn:00002200 ; ===========================================================================
.text$mn:00002200
.text$mn:00002200 ; Segment type: Pure code
.text$mn:00002200 ; Segment permissions: Read/Execute
.text$mn:00002200 _text$mn        segment para public 'CODE' use32
.text$mn:00002200                 assume cs:_text$mn
.text$mn:00002200                 ;org 2200h
.text$mn:00002200 ; COMDAT (pick any)
.text$mn:00002200                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002200
.text$mn:00002200 ; =============== S U B R O U T I N E =======================================
.text$mn:00002200
.text$mn:00002200 ; Attributes: bp-based frame
.text$mn:00002200
.text$mn:00002200 ; public: char * __thiscall std::_Wrap_alloc<class std::allocator<char>>::allocate(unsigned int)
.text$mn:00002200                 public ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
.text$mn:00002200 ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z proc near
.text$mn:00002200                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+BBp
.text$mn:00002200                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+22p
.text$mn:00002200
.text$mn:00002200 var_4           = dword ptr -4
.text$mn:00002200 arg_0           = dword ptr  8
.text$mn:00002200
.text$mn:00002200                 push    ebp
.text$mn:00002201                 mov     ebp, esp
.text$mn:00002203                 push    ecx
.text$mn:00002204                 mov     [ebp+var_4], ecx
.text$mn:00002207                 mov     eax, [ebp+arg_0]
.text$mn:0000220A                 push    eax
.text$mn:0000220B                 mov     ecx, [ebp+var_4]
.text$mn:0000220E                 call    ?allocate@?$allocator@D@std@@QAEPADI@Z ; std::allocator<char>::allocate(uint)
.text$mn:00002213                 mov     esp, ebp
.text$mn:00002215                 pop     ebp
.text$mn:00002216                 retn    4
.text$mn:00002216 ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z endp
.text$mn:00002216
.text$mn:00002216 ; ---------------------------------------------------------------------------
.text$mn:00002219                 align 4
.text$mn:00002219 _text$mn        ends
.text$mn:00002219
.text$mn:0000221C ; ===========================================================================
.text$mn:0000221C
.text$mn:0000221C ; Segment type: Pure code
.text$mn:0000221C ; Segment permissions: Read/Execute
.text$mn:0000221C _text$mn        segment para public 'CODE' use32
.text$mn:0000221C                 assume cs:_text$mn
.text$mn:0000221C                 ;org 221Ch
.text$mn:0000221C ; COMDAT (pick any)
.text$mn:0000221C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000221C
.text$mn:0000221C ; =============== S U B R O U T I N E =======================================
.text$mn:0000221C
.text$mn:0000221C ; Attributes: bp-based frame
.text$mn:0000221C
.text$mn:0000221C ; public: char * __thiscall std::allocator<char>::allocate(unsigned int)
.text$mn:0000221C                 public ?allocate@?$allocator@D@std@@QAEPADI@Z
.text$mn:0000221C ?allocate@?$allocator@D@std@@QAEPADI@Z proc near
.text$mn:0000221C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::allocate(uint)+Ep
.text$mn:0000221C
.text$mn:0000221C var_4           = dword ptr -4
.text$mn:0000221C arg_0           = dword ptr  8
.text$mn:0000221C
.text$mn:0000221C                 push    ebp
.text$mn:0000221D                 mov     ebp, esp
.text$mn:0000221F                 push    ecx
.text$mn:00002220                 mov     [ebp+var_4], ecx
.text$mn:00002223                 push    0
.text$mn:00002225                 mov     eax, [ebp+arg_0]
.text$mn:00002228                 push    eax
.text$mn:00002229                 call    ??$_Allocate@D@std@@YAPADIPAD@Z ; std::_Allocate<char>(uint,char *)
.text$mn:0000222E                 add     esp, 8
.text$mn:00002231                 mov     esp, ebp
.text$mn:00002233                 pop     ebp
.text$mn:00002234                 retn    4
.text$mn:00002234 ?allocate@?$allocator@D@std@@QAEPADI@Z endp
.text$mn:00002234
.text$mn:00002234 ; ---------------------------------------------------------------------------
.text$mn:00002237                 align 4
.text$mn:00002237 _text$mn        ends
.text$mn:00002237
.text$mn:00002238 ; ===========================================================================
.text$mn:00002238
.text$mn:00002238 ; Segment type: Pure code
.text$mn:00002238 ; Segment permissions: Read/Execute
.text$mn:00002238 _text$mn        segment para public 'CODE' use32
.text$mn:00002238                 assume cs:_text$mn
.text$mn:00002238                 ;org 2238h
.text$mn:00002238 ; COMDAT (pick any)
.text$mn:00002238                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002238
.text$mn:00002238 ; =============== S U B R O U T I N E =======================================
.text$mn:00002238
.text$mn:00002238 ; Attributes: bp-based frame
.text$mn:00002238
.text$mn:00002238 ; public: struct std::_Container_proxy * __thiscall std::allocator<struct std::_Container_proxy>::allocate(unsigned int)
.text$mn:00002238                 public ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z
.text$mn:00002238 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z proc near
.text$mn:00002238                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+16p
.text$mn:00002238
.text$mn:00002238 var_4           = dword ptr -4
.text$mn:00002238 arg_0           = dword ptr  8
.text$mn:00002238
.text$mn:00002238                 push    ebp
.text$mn:00002239                 mov     ebp, esp
.text$mn:0000223B                 push    ecx
.text$mn:0000223C                 mov     [ebp+var_4], ecx
.text$mn:0000223F                 push    0
.text$mn:00002241                 mov     eax, [ebp+arg_0]
.text$mn:00002244                 push    eax
.text$mn:00002245                 call    ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)
.text$mn:0000224A                 add     esp, 8
.text$mn:0000224D                 mov     esp, ebp
.text$mn:0000224F                 pop     ebp
.text$mn:00002250                 retn    4
.text$mn:00002250 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z endp
.text$mn:00002250
.text$mn:00002250 ; ---------------------------------------------------------------------------
.text$mn:00002253                 align 4
.text$mn:00002253 _text$mn        ends
.text$mn:00002253
.text$mn:00002254 ; ===========================================================================
.text$mn:00002254
.text$mn:00002254 ; Segment type: Pure code
.text$mn:00002254 ; Segment permissions: Read/Execute
.text$mn:00002254 _text$mn        segment para public 'CODE' use32
.text$mn:00002254                 assume cs:_text$mn
.text$mn:00002254                 ;org 2254h
.text$mn:00002254 ; COMDAT (pick any)
.text$mn:00002254                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002254
.text$mn:00002254 ; =============== S U B R O U T I N E =======================================
.text$mn:00002254
.text$mn:00002254 ; Attributes: bp-based frame
.text$mn:00002254
.text$mn:00002254 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::assign(class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> const &, unsigned int, unsigned int)
.text$mn:00002254                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
.text$mn:00002254 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z proc near
.text$mn:00002254                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+4Fp
.text$mn:00002254
.text$mn:00002254 Size            = dword ptr -8
.text$mn:00002254 var_4           = dword ptr -4
.text$mn:00002254 arg_0           = dword ptr  8
.text$mn:00002254 arg_4           = dword ptr  0Ch
.text$mn:00002254 arg_8           = dword ptr  10h
.text$mn:00002254
.text$mn:00002254                 push    ebp
.text$mn:00002255                 mov     ebp, esp
.text$mn:00002257                 sub     esp, 8
.text$mn:0000225A                 mov     [ebp+var_4], ecx
.text$mn:0000225D                 mov     ecx, [ebp+arg_0]
.text$mn:00002260                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:00002265                 cmp     eax, [ebp+arg_4]
.text$mn:00002268                 jnb     short loc_2272
.text$mn:0000226A                 mov     ecx, [ebp+var_4]
.text$mn:0000226D                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:00002272
.text$mn:00002272 loc_2272:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+14j
.text$mn:00002272                 mov     ecx, [ebp+arg_0]
.text$mn:00002275                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:0000227A                 sub     eax, [ebp+arg_4]
.text$mn:0000227D                 mov     [ebp+Size], eax
.text$mn:00002280                 mov     eax, [ebp+arg_8]
.text$mn:00002283                 cmp     eax, [ebp+Size]
.text$mn:00002286                 jnb     short loc_228E
.text$mn:00002288                 mov     ecx, [ebp+arg_8]
.text$mn:0000228B                 mov     [ebp+Size], ecx
.text$mn:0000228E
.text$mn:0000228E loc_228E:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+32j
.text$mn:0000228E                 mov     edx, [ebp+var_4]
.text$mn:00002291                 cmp     edx, [ebp+arg_0]
.text$mn:00002294                 jnz     short loc_22B5
.text$mn:00002296                 mov     eax, [ebp+arg_4]
.text$mn:00002299                 add     eax, [ebp+Size]
.text$mn:0000229C                 push    eax
.text$mn:0000229D                 mov     ecx, [ebp+var_4]
.text$mn:000022A0                 call    ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)
.text$mn:000022A5                 mov     ecx, [ebp+arg_4]
.text$mn:000022A8                 push    ecx
.text$mn:000022A9                 push    0
.text$mn:000022AB                 mov     ecx, [ebp+var_4]
.text$mn:000022AE                 call    ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)
.text$mn:000022B3                 jmp     short loc_22F7
.text$mn:000022B5 ; ---------------------------------------------------------------------------
.text$mn:000022B5
.text$mn:000022B5 loc_22B5:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+40j
.text$mn:000022B5                 push    0
.text$mn:000022B7                 mov     edx, [ebp+Size]
.text$mn:000022BA                 push    edx
.text$mn:000022BB                 mov     ecx, [ebp+var_4]
.text$mn:000022BE                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:000022C3                 movzx   eax, al
.text$mn:000022C6                 test    eax, eax
.text$mn:000022C8                 jz      short loc_22F7
.text$mn:000022CA                 mov     ecx, [ebp+Size]
.text$mn:000022CD                 push    ecx             ; Size
.text$mn:000022CE                 mov     ecx, [ebp+arg_0]
.text$mn:000022D1                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000022D6                 add     eax, [ebp+arg_4]
.text$mn:000022D9                 push    eax             ; Src
.text$mn:000022DA                 mov     ecx, [ebp+var_4]
.text$mn:000022DD                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000022E2                 push    eax             ; Dst
.text$mn:000022E3                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:000022E8                 add     esp, 0Ch
.text$mn:000022EB                 mov     edx, [ebp+Size]
.text$mn:000022EE                 push    edx
.text$mn:000022EF                 mov     ecx, [ebp+var_4]
.text$mn:000022F2                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000022F7
.text$mn:000022F7 loc_22F7:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+5Fj
.text$mn:000022F7                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+74j
.text$mn:000022F7                 mov     eax, [ebp+var_4]
.text$mn:000022FA                 mov     esp, ebp
.text$mn:000022FC                 pop     ebp
.text$mn:000022FD                 retn    0Ch
.text$mn:000022FD ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z endp
.text$mn:000022FD
.text$mn:000022FD _text$mn        ends
.text$mn:000022FD
.text$mn:00002300 ; ===========================================================================
.text$mn:00002300
.text$mn:00002300 ; Segment type: Pure code
.text$mn:00002300 ; Segment permissions: Read/Execute
.text$mn:00002300 _text$mn        segment para public 'CODE' use32
.text$mn:00002300                 assume cs:_text$mn
.text$mn:00002300                 ;org 2300h
.text$mn:00002300 ; COMDAT (pick any)
.text$mn:00002300                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002300
.text$mn:00002300 ; =============== S U B R O U T I N E =======================================
.text$mn:00002300
.text$mn:00002300 ; Attributes: bp-based frame
.text$mn:00002300
.text$mn:00002300 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char *Str)
.text$mn:00002300                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
.text$mn:00002300 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z proc near
.text$mn:00002300                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+53p
.text$mn:00002300
.text$mn:00002300 var_4           = dword ptr -4
.text$mn:00002300 Str             = dword ptr  8
.text$mn:00002300
.text$mn:00002300                 push    ebp
.text$mn:00002301                 mov     ebp, esp
.text$mn:00002303                 push    ecx
.text$mn:00002304                 mov     [ebp+var_4], ecx
.text$mn:00002307                 push    490h            ; unsigned int
.text$mn:0000230C                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00002311                 mov     eax, [ebp+Str]
.text$mn:00002314                 push    eax             ; int
.text$mn:00002315                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:0000231A                 add     esp, 0Ch
.text$mn:0000231D                 mov     ecx, [ebp+Str]
.text$mn:00002320                 push    ecx             ; Str
.text$mn:00002321                 call    ?length@?$char_traits@D@std@@SAIPBD@Z ; std::char_traits<char>::length(char const *)
.text$mn:00002326                 add     esp, 4
.text$mn:00002329                 push    eax             ; Size
.text$mn:0000232A                 mov     edx, [ebp+Str]
.text$mn:0000232D                 push    edx             ; Src
.text$mn:0000232E                 mov     ecx, [ebp+var_4]
.text$mn:00002331                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)
.text$mn:00002336                 mov     esp, ebp
.text$mn:00002338                 pop     ebp
.text$mn:00002339                 retn    4
.text$mn:00002339 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z endp
.text$mn:00002339
.text$mn:00002339 _text$mn        ends
.text$mn:00002339
.text$mn:0000233C ; ===========================================================================
.text$mn:0000233C
.text$mn:0000233C ; Segment type: Pure code
.text$mn:0000233C ; Segment permissions: Read/Execute
.text$mn:0000233C _text$mn        segment para public 'CODE' use32
.text$mn:0000233C                 assume cs:_text$mn
.text$mn:0000233C                 ;org 233Ch
.text$mn:0000233C ; COMDAT (pick any)
.text$mn:0000233C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000233C
.text$mn:0000233C ; =============== S U B R O U T I N E =======================================
.text$mn:0000233C
.text$mn:0000233C ; Attributes: bp-based frame
.text$mn:0000233C
.text$mn:0000233C ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(void *Src, size_t Size)
.text$mn:0000233C                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
.text$mn:0000233C ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z proc near
.text$mn:0000233C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+31p
.text$mn:0000233C
.text$mn:0000233C var_4           = dword ptr -4
.text$mn:0000233C Src             = dword ptr  8
.text$mn:0000233C Size            = dword ptr  0Ch
.text$mn:0000233C
.text$mn:0000233C                 push    ebp
.text$mn:0000233D                 mov     ebp, esp
.text$mn:0000233F                 push    ecx
.text$mn:00002340                 mov     [ebp+var_4], ecx
.text$mn:00002343                 cmp     [ebp+Size], 0
.text$mn:00002347                 jz      short loc_235F
.text$mn:00002349                 push    47Fh            ; unsigned int
.text$mn:0000234E                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00002353                 mov     eax, [ebp+Src]
.text$mn:00002356                 push    eax             ; int
.text$mn:00002357                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:0000235C                 add     esp, 0Ch
.text$mn:0000235F
.text$mn:0000235F loc_235F:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+Bj
.text$mn:0000235F                 mov     ecx, [ebp+Src]
.text$mn:00002362                 push    ecx
.text$mn:00002363                 mov     ecx, [ebp+var_4]
.text$mn:00002366                 call    ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)
.text$mn:0000236B                 movzx   edx, al
.text$mn:0000236E                 test    edx, edx
.text$mn:00002370                 jz      short loc_2392
.text$mn:00002372                 mov     eax, [ebp+Size]
.text$mn:00002375                 push    eax
.text$mn:00002376                 mov     ecx, [ebp+var_4]
.text$mn:00002379                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000237E                 mov     ecx, [ebp+Src]
.text$mn:00002381                 sub     ecx, eax
.text$mn:00002383                 push    ecx
.text$mn:00002384                 mov     edx, [ebp+var_4]
.text$mn:00002387                 push    edx
.text$mn:00002388                 mov     ecx, [ebp+var_4]
.text$mn:0000238B                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)
.text$mn:00002390                 jmp     short loc_23CF
.text$mn:00002392 ; ---------------------------------------------------------------------------
.text$mn:00002392
.text$mn:00002392 loc_2392:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+34j
.text$mn:00002392                 push    0
.text$mn:00002394                 mov     eax, [ebp+Size]
.text$mn:00002397                 push    eax
.text$mn:00002398                 mov     ecx, [ebp+var_4]
.text$mn:0000239B                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:000023A0                 movzx   ecx, al
.text$mn:000023A3                 test    ecx, ecx
.text$mn:000023A5                 jz      short loc_23CC
.text$mn:000023A7                 mov     edx, [ebp+Size]
.text$mn:000023AA                 push    edx             ; Size
.text$mn:000023AB                 mov     eax, [ebp+Src]
.text$mn:000023AE                 push    eax             ; Src
.text$mn:000023AF                 mov     ecx, [ebp+var_4]
.text$mn:000023B2                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000023B7                 push    eax             ; Dst
.text$mn:000023B8                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:000023BD                 add     esp, 0Ch
.text$mn:000023C0                 mov     ecx, [ebp+Size]
.text$mn:000023C3                 push    ecx
.text$mn:000023C4                 mov     ecx, [ebp+var_4]
.text$mn:000023C7                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000023CC
.text$mn:000023CC loc_23CC:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+69j
.text$mn:000023CC                 mov     eax, [ebp+var_4]
.text$mn:000023CF
.text$mn:000023CF loc_23CF:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+54j
.text$mn:000023CF                 mov     esp, ebp
.text$mn:000023D1                 pop     ebp
.text$mn:000023D2                 retn    8
.text$mn:000023D2 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z endp
.text$mn:000023D2
.text$mn:000023D2 ; ---------------------------------------------------------------------------
.text$mn:000023D5                 align 4
.text$mn:000023D5 _text$mn        ends
.text$mn:000023D5
.text$mn:000023D8 ; ===========================================================================
.text$mn:000023D8
.text$mn:000023D8 ; Segment type: Pure code
.text$mn:000023D8 ; Segment permissions: Read/Execute
.text$mn:000023D8 _text$mn        segment para public 'CODE' use32
.text$mn:000023D8                 assume cs:_text$mn
.text$mn:000023D8                 ;org 23D8h
.text$mn:000023D8 ; COMDAT (pick any)
.text$mn:000023D8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000023D8
.text$mn:000023D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000023D8
.text$mn:000023D8 ; Attributes: bp-based frame
.text$mn:000023D8
.text$mn:000023D8 ; public: static void __cdecl std::char_traits<char>::assign(char &, char const &)
.text$mn:000023D8                 public ?assign@?$char_traits@D@std@@SAXAADABD@Z
.text$mn:000023D8 ?assign@?$char_traits@D@std@@SAXAADABD@Z proc near
.text$mn:000023D8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+26p
.text$mn:000023D8
.text$mn:000023D8 arg_0           = dword ptr  8
.text$mn:000023D8 arg_4           = dword ptr  0Ch
.text$mn:000023D8
.text$mn:000023D8                 push    ebp
.text$mn:000023D9                 mov     ebp, esp
.text$mn:000023DB                 mov     eax, [ebp+arg_0]
.text$mn:000023DE                 mov     ecx, [ebp+arg_4]
.text$mn:000023E1                 mov     dl, [ecx]
.text$mn:000023E3                 mov     [eax], dl
.text$mn:000023E5                 pop     ebp
.text$mn:000023E6                 retn
.text$mn:000023E6 ?assign@?$char_traits@D@std@@SAXAADABD@Z endp
.text$mn:000023E6
.text$mn:000023E6 ; ---------------------------------------------------------------------------
.text$mn:000023E7                 align 4
.text$mn:000023E7 _text$mn        ends
.text$mn:000023E7
.text$mn:000023E8 ; ===========================================================================
.text$mn:000023E8
.text$mn:000023E8 ; Segment type: Pure code
.text$mn:000023E8 ; Segment permissions: Read/Execute
.text$mn:000023E8 _text$mn        segment para public 'CODE' use32
.text$mn:000023E8                 assume cs:_text$mn
.text$mn:000023E8                 ;org 23E8h
.text$mn:000023E8 ; COMDAT (pick any)
.text$mn:000023E8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000023E8
.text$mn:000023E8 ; =============== S U B R O U T I N E =======================================
.text$mn:000023E8
.text$mn:000023E8 ; Attributes: bp-based frame
.text$mn:000023E8
.text$mn:000023E8 ; const struct std::error_category *__thiscall std::error_code::category(std::error_code *__hidden this)
.text$mn:000023E8                 public ?category@error_code@std@@QBEABVerror_category@2@XZ
.text$mn:000023E8 ?category@error_code@std@@QBEABVerror_category@2@XZ proc near
.text$mn:000023E8                                         ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+Cp
.text$mn:000023E8
.text$mn:000023E8 var_4           = dword ptr -4
.text$mn:000023E8
.text$mn:000023E8                 push    ebp
.text$mn:000023E9                 mov     ebp, esp
.text$mn:000023EB                 push    ecx
.text$mn:000023EC                 mov     [ebp+var_4], ecx
.text$mn:000023EF                 mov     eax, [ebp+var_4]
.text$mn:000023F2                 mov     eax, [eax+4]
.text$mn:000023F5                 mov     esp, ebp
.text$mn:000023F7                 pop     ebp
.text$mn:000023F8                 retn
.text$mn:000023F8 ?category@error_code@std@@QBEABVerror_category@2@XZ endp
.text$mn:000023F8
.text$mn:000023F8 ; ---------------------------------------------------------------------------
.text$mn:000023F9                 align 4
.text$mn:000023F9 _text$mn        ends
.text$mn:000023F9
.text$mn:000023FC ; ===========================================================================
.text$mn:000023FC
.text$mn:000023FC ; Segment type: Pure code
.text$mn:000023FC ; Segment permissions: Read/Execute
.text$mn:000023FC _text$mn        segment para public 'CODE' use32
.text$mn:000023FC                 assume cs:_text$mn
.text$mn:000023FC                 ;org 23FCh
.text$mn:000023FC ; COMDAT (pick any)
.text$mn:000023FC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000023FC
.text$mn:000023FC ; =============== S U B R O U T I N E =======================================
.text$mn:000023FC
.text$mn:000023FC ; Attributes: bp-based frame
.text$mn:000023FC
.text$mn:000023FC ; const struct std::error_category *__thiscall std::error_condition::category(std::error_condition *__hidden this)
.text$mn:000023FC                 public ?category@error_condition@std@@QBEABVerror_category@2@XZ
.text$mn:000023FC ?category@error_condition@std@@QBEABVerror_category@2@XZ proc near
.text$mn:000023FC                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+Dp
.text$mn:000023FC                                         ; std::error_condition::operator==(std::error_condition const &)+16p
.text$mn:000023FC
.text$mn:000023FC var_4           = dword ptr -4
.text$mn:000023FC
.text$mn:000023FC                 push    ebp
.text$mn:000023FD                 mov     ebp, esp
.text$mn:000023FF                 push    ecx
.text$mn:00002400                 mov     [ebp+var_4], ecx
.text$mn:00002403                 mov     eax, [ebp+var_4]
.text$mn:00002406                 mov     eax, [eax+4]
.text$mn:00002409                 mov     esp, ebp
.text$mn:0000240B                 pop     ebp
.text$mn:0000240C                 retn
.text$mn:0000240C ?category@error_condition@std@@QBEABVerror_category@2@XZ endp
.text$mn:0000240C
.text$mn:0000240C ; ---------------------------------------------------------------------------
.text$mn:0000240D                 align 10h
.text$mn:0000240D _text$mn        ends
.text$mn:0000240D
.text$mn:00002410 ; ===========================================================================
.text$mn:00002410
.text$mn:00002410 ; Segment type: Pure code
.text$mn:00002410 ; Segment permissions: Read/Execute
.text$mn:00002410 _text$mn        segment para public 'CODE' use32
.text$mn:00002410                 assume cs:_text$mn
.text$mn:00002410                 ;org 2410h
.text$mn:00002410 ; COMDAT (pick any)
.text$mn:00002410                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002410
.text$mn:00002410 ; =============== S U B R O U T I N E =======================================
.text$mn:00002410
.text$mn:00002410 ; Attributes: bp-based frame
.text$mn:00002410
.text$mn:00002410 ; void __thiscall GoToLineDlg::cleanLineEdit(GoToLineDlg *__hidden this)
.text$mn:00002410                 public ?cleanLineEdit@GoToLineDlg@@ABEXXZ
.text$mn:00002410 ?cleanLineEdit@GoToLineDlg@@ABEXXZ proc near
.text$mn:00002410                                         ; CODE XREF: GoToLineDlg::run_dlgProc(uint,uint,long)+9Ep
.text$mn:00002410                                         ; GoToLineDlg::run_dlgProc(uint,uint,long)+D4p
.text$mn:00002410
.text$mn:00002410 var_4           = dword ptr -4
.text$mn:00002410
.text$mn:00002410                 push    ebp
.text$mn:00002411                 mov     ebp, esp
.text$mn:00002413                 push    ecx
.text$mn:00002414                 mov     [ebp+var_4], ecx
.text$mn:00002417                 push    offset ??_C@_11LOCGONAA@?$AA?$AA@ ; lpString
.text$mn:0000241C                 push    7D1h            ; nIDDlgItem
.text$mn:00002421                 mov     eax, [ebp+var_4]
.text$mn:00002424                 mov     ecx, [eax+0Ch]
.text$mn:00002427                 push    ecx             ; hDlg
.text$mn:00002428                 call    dword ptr ds:__imp__SetDlgItemTextW@12 ; SetDlgItemTextW(x,x,x)
.text$mn:0000242E                 mov     esp, ebp
.text$mn:00002430                 pop     ebp
.text$mn:00002431                 retn
.text$mn:00002431 ?cleanLineEdit@GoToLineDlg@@ABEXXZ endp
.text$mn:00002431
.text$mn:00002431 ; ---------------------------------------------------------------------------
.text$mn:00002432                 align 4
.text$mn:00002432 _text$mn        ends
.text$mn:00002432
.text$mn:00002434 ; ===========================================================================
.text$mn:00002434
.text$mn:00002434 ; Segment type: Pure code
.text$mn:00002434 ; Segment permissions: Read/Execute
.text$mn:00002434 _text$mn        segment para public 'CODE' use32
.text$mn:00002434                 assume cs:_text$mn
.text$mn:00002434                 ;org 2434h
.text$mn:00002434 ; COMDAT (pick any)
.text$mn:00002434                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002434
.text$mn:00002434 ; =============== S U B R O U T I N E =======================================
.text$mn:00002434
.text$mn:00002434 ; Attributes: bp-based frame
.text$mn:00002434
.text$mn:00002434 ; int __cdecl std::char_traits<char>::copy(void *Dst, void *Src, size_t Size)
.text$mn:00002434                 public ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
.text$mn:00002434 ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z proc near ; CODE XREF: $LN19+1Ep
.text$mn:00002434                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+5Dp ...
.text$mn:00002434
.text$mn:00002434 var_4           = dword ptr -4
.text$mn:00002434 Dst             = dword ptr  8
.text$mn:00002434 Src             = dword ptr  0Ch
.text$mn:00002434 Size            = dword ptr  10h
.text$mn:00002434
.text$mn:00002434                 push    ebp
.text$mn:00002435                 mov     ebp, esp
.text$mn:00002437                 push    ecx
.text$mn:00002438                 cmp     [ebp+Size], 0
.text$mn:0000243C                 jnz     short loc_2446
.text$mn:0000243E                 mov     eax, [ebp+Dst]
.text$mn:00002441                 mov     [ebp+var_4], eax
.text$mn:00002444                 jmp     short loc_245D
.text$mn:00002446 ; ---------------------------------------------------------------------------
.text$mn:00002446
.text$mn:00002446 loc_2446:                               ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+8j
.text$mn:00002446                 mov     ecx, [ebp+Size]
.text$mn:00002449                 push    ecx             ; Size
.text$mn:0000244A                 mov     edx, [ebp+Src]
.text$mn:0000244D                 push    edx             ; Src
.text$mn:0000244E                 mov     eax, [ebp+Dst]
.text$mn:00002451                 push    eax             ; Dst
.text$mn:00002452                 call    _memcpy
.text$mn:00002457                 add     esp, 0Ch
.text$mn:0000245A                 mov     [ebp+var_4], eax
.text$mn:0000245D
.text$mn:0000245D loc_245D:                               ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+10j
.text$mn:0000245D                 mov     eax, [ebp+var_4]
.text$mn:00002460                 mov     esp, ebp
.text$mn:00002462                 pop     ebp
.text$mn:00002463                 retn
.text$mn:00002463 ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z endp
.text$mn:00002463
.text$mn:00002463 _text$mn        ends
.text$mn:00002463
.text$mn:00002464 ; ===========================================================================
.text$mn:00002464
.text$mn:00002464 ; Segment type: Pure code
.text$mn:00002464 ; Segment permissions: Read/Execute
.text$mn:00002464 _text$mn        segment para public 'CODE' use32
.text$mn:00002464                 assume cs:_text$mn
.text$mn:00002464                 ;org 2464h
.text$mn:00002464 ; COMDAT (pick any)
.text$mn:00002464                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002464
.text$mn:00002464 ; =============== S U B R O U T I N E =======================================
.text$mn:00002464
.text$mn:00002464 ; Attributes: bp-based frame
.text$mn:00002464
.text$mn:00002464 ; int __stdcall std::_Wrap_alloc<std::allocator<char>>::deallocate(void *, int)
.text$mn:00002464                 public ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
.text$mn:00002464 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z proc near
.text$mn:00002464                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+81p
.text$mn:00002464
.text$mn:00002464 var_4           = dword ptr -4
.text$mn:00002464 arg_0           = dword ptr  8
.text$mn:00002464 arg_4           = dword ptr  0Ch
.text$mn:00002464
.text$mn:00002464                 push    ebp
.text$mn:00002465                 mov     ebp, esp
.text$mn:00002467                 push    ecx
.text$mn:00002468                 mov     [ebp+var_4], ecx
.text$mn:0000246B                 mov     eax, [ebp+arg_4]
.text$mn:0000246E                 push    eax             ; int
.text$mn:0000246F                 mov     ecx, [ebp+arg_0]
.text$mn:00002472                 push    ecx             ; void *
.text$mn:00002473                 mov     ecx, [ebp+var_4]
.text$mn:00002476                 call    ?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate(char *,uint)
.text$mn:0000247B                 mov     esp, ebp
.text$mn:0000247D                 pop     ebp
.text$mn:0000247E                 retn    8
.text$mn:0000247E ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z endp
.text$mn:0000247E
.text$mn:0000247E ; ---------------------------------------------------------------------------
.text$mn:00002481                 align 4
.text$mn:00002481 _text$mn        ends
.text$mn:00002481
.text$mn:00002484 ; ===========================================================================
.text$mn:00002484
.text$mn:00002484 ; Segment type: Pure code
.text$mn:00002484 ; Segment permissions: Read/Execute
.text$mn:00002484 _text$mn        segment para public 'CODE' use32
.text$mn:00002484                 assume cs:_text$mn
.text$mn:00002484                 ;org 2484h
.text$mn:00002484 ; COMDAT (pick any)
.text$mn:00002484                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002484
.text$mn:00002484 ; =============== S U B R O U T I N E =======================================
.text$mn:00002484
.text$mn:00002484 ; Attributes: bp-based frame
.text$mn:00002484
.text$mn:00002484 ; int __stdcall std::allocator<char>::deallocate(void *, int)
.text$mn:00002484                 public ?deallocate@?$allocator@D@std@@QAEXPADI@Z
.text$mn:00002484 ?deallocate@?$allocator@D@std@@QAEXPADI@Z proc near
.text$mn:00002484                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)+12p
.text$mn:00002484
.text$mn:00002484 var_4           = dword ptr -4
.text$mn:00002484 arg_0           = dword ptr  8
.text$mn:00002484
.text$mn:00002484                 push    ebp
.text$mn:00002485                 mov     ebp, esp
.text$mn:00002487                 push    ecx
.text$mn:00002488                 mov     [ebp+var_4], ecx
.text$mn:0000248B                 mov     eax, [ebp+arg_0]
.text$mn:0000248E                 push    eax             ; void *
.text$mn:0000248F                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00002494                 add     esp, 4
.text$mn:00002497                 mov     esp, ebp
.text$mn:00002499                 pop     ebp
.text$mn:0000249A                 retn    8
.text$mn:0000249A ?deallocate@?$allocator@D@std@@QAEXPADI@Z endp
.text$mn:0000249A
.text$mn:0000249A ; ---------------------------------------------------------------------------
.text$mn:0000249D                 align 10h
.text$mn:0000249D _text$mn        ends
.text$mn:0000249D
.text$mn:000024A0 ; ===========================================================================
.text$mn:000024A0
.text$mn:000024A0 ; Segment type: Pure code
.text$mn:000024A0 ; Segment permissions: Read/Execute
.text$mn:000024A0 _text$mn        segment para public 'CODE' use32
.text$mn:000024A0                 assume cs:_text$mn
.text$mn:000024A0                 ;org 24A0h
.text$mn:000024A0 ; COMDAT (pick any)
.text$mn:000024A0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000024A0
.text$mn:000024A0 ; =============== S U B R O U T I N E =======================================
.text$mn:000024A0
.text$mn:000024A0 ; Attributes: bp-based frame
.text$mn:000024A0
.text$mn:000024A0 ; int __stdcall std::allocator<std::_Container_proxy>::deallocate(void *, int)
.text$mn:000024A0                 public ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z
.text$mn:000024A0 ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z proc near
.text$mn:000024A0                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+32p
.text$mn:000024A0
.text$mn:000024A0 var_4           = dword ptr -4
.text$mn:000024A0 arg_0           = dword ptr  8
.text$mn:000024A0
.text$mn:000024A0                 push    ebp
.text$mn:000024A1                 mov     ebp, esp
.text$mn:000024A3                 push    ecx
.text$mn:000024A4                 mov     [ebp+var_4], ecx
.text$mn:000024A7                 mov     eax, [ebp+arg_0]
.text$mn:000024AA                 push    eax             ; void *
.text$mn:000024AB                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:000024B0                 add     esp, 4
.text$mn:000024B3                 mov     esp, ebp
.text$mn:000024B5                 pop     ebp
.text$mn:000024B6                 retn    8
.text$mn:000024B6 ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z endp
.text$mn:000024B6
.text$mn:000024B6 ; ---------------------------------------------------------------------------
.text$mn:000024B9                 align 4
.text$mn:000024B9 _text$mn        ends
.text$mn:000024B9
.text$mn:000024BC ; ===========================================================================
.text$mn:000024BC
.text$mn:000024BC ; Segment type: Pure code
.text$mn:000024BC ; Segment permissions: Read/Execute
.text$mn:000024BC _text$mn        segment para public 'CODE' use32
.text$mn:000024BC                 assume cs:_text$mn
.text$mn:000024BC                 ;org 24BCh
.text$mn:000024BC ; COMDAT (pick any)
.text$mn:000024BC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000024BC
.text$mn:000024BC ; =============== S U B R O U T I N E =======================================
.text$mn:000024BC
.text$mn:000024BC ; Attributes: bp-based frame
.text$mn:000024BC
.text$mn:000024BC ; public: virtual class std::error_condition __thiscall std::_System_error_category::default_error_condition(int)const
.text$mn:000024BC                 public ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
.text$mn:000024BC ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z proc near
.text$mn:000024BC                                         ; DATA XREF: .rdata:00002F1Co
.text$mn:000024BC
.text$mn:000024BC var_4           = dword ptr -4
.text$mn:000024BC arg_0           = dword ptr  8
.text$mn:000024BC arg_4           = dword ptr  0Ch
.text$mn:000024BC
.text$mn:000024BC                 push    ebp
.text$mn:000024BD                 mov     ebp, esp
.text$mn:000024BF                 push    ecx
.text$mn:000024C0                 mov     [ebp+var_4], ecx
.text$mn:000024C3                 mov     eax, [ebp+arg_4]
.text$mn:000024C6                 push    eax             ; int
.text$mn:000024C7                 call    ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map(int)
.text$mn:000024CC                 add     esp, 4
.text$mn:000024CF                 test    eax, eax
.text$mn:000024D1                 jz      short loc_24EC
.text$mn:000024D3                 call    ?generic_category@std@@YAABVerror_category@1@XZ ; std::generic_category(void)
.text$mn:000024D8                 push    eax             ; struct std::error_category *
.text$mn:000024D9                 mov     ecx, [ebp+arg_4]
.text$mn:000024DC                 push    ecx             ; int
.text$mn:000024DD                 mov     ecx, [ebp+arg_0] ; this
.text$mn:000024E0                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:000024E5                 mov     eax, [ebp+arg_0]
.text$mn:000024E8                 jmp     short loc_2501
.text$mn:000024EA ; ---------------------------------------------------------------------------
.text$mn:000024EA                 jmp     short loc_2501
.text$mn:000024EC ; ---------------------------------------------------------------------------
.text$mn:000024EC
.text$mn:000024EC loc_24EC:                               ; CODE XREF: std::_System_error_category::default_error_condition(int)+15j
.text$mn:000024EC                 call    ?system_category@std@@YAABVerror_category@1@XZ ; std::system_category(void)
.text$mn:000024F1                 push    eax             ; struct std::error_category *
.text$mn:000024F2                 mov     edx, [ebp+arg_4]
.text$mn:000024F5                 push    edx             ; int
.text$mn:000024F6                 mov     ecx, [ebp+arg_0] ; this
.text$mn:000024F9                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:000024FE                 mov     eax, [ebp+arg_0]
.text$mn:00002501
.text$mn:00002501 loc_2501:                               ; CODE XREF: std::_System_error_category::default_error_condition(int)+2Cj
.text$mn:00002501                                         ; std::_System_error_category::default_error_condition(int)+2Ej
.text$mn:00002501                 mov     esp, ebp
.text$mn:00002503                 pop     ebp
.text$mn:00002504                 retn    8
.text$mn:00002504 ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z endp
.text$mn:00002504
.text$mn:00002504 ; ---------------------------------------------------------------------------
.text$mn:00002507                 align 4
.text$mn:00002507 _text$mn        ends
.text$mn:00002507
.text$mn:00002508 ; ===========================================================================
.text$mn:00002508
.text$mn:00002508 ; Segment type: Pure code
.text$mn:00002508 ; Segment permissions: Read/Execute
.text$mn:00002508 _text$mn        segment para public 'CODE' use32
.text$mn:00002508                 assume cs:_text$mn
.text$mn:00002508                 ;org 2508h
.text$mn:00002508 ; COMDAT (pick any)
.text$mn:00002508                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002508
.text$mn:00002508 ; =============== S U B R O U T I N E =======================================
.text$mn:00002508
.text$mn:00002508 ; Attributes: bp-based frame
.text$mn:00002508
.text$mn:00002508 ; public: virtual class std::error_condition __thiscall std::error_category::default_error_condition(int)const
.text$mn:00002508                 public ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
.text$mn:00002508 ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z proc near
.text$mn:00002508                                         ; DATA XREF: .rdata:00002E8Co
.text$mn:00002508                                         ; .rdata:00002EA8o ...
.text$mn:00002508
.text$mn:00002508 var_4           = dword ptr -4
.text$mn:00002508 arg_0           = dword ptr  8
.text$mn:00002508 arg_4           = dword ptr  0Ch
.text$mn:00002508
.text$mn:00002508                 push    ebp
.text$mn:00002509                 mov     ebp, esp
.text$mn:0000250B                 push    ecx
.text$mn:0000250C                 mov     [ebp+var_4], ecx
.text$mn:0000250F                 mov     eax, [ebp+var_4]
.text$mn:00002512                 push    eax             ; struct std::error_category *
.text$mn:00002513                 mov     ecx, [ebp+arg_4]
.text$mn:00002516                 push    ecx             ; int
.text$mn:00002517                 mov     ecx, [ebp+arg_0] ; this
.text$mn:0000251A                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:0000251F                 mov     eax, [ebp+arg_0]
.text$mn:00002522                 mov     esp, ebp
.text$mn:00002524                 pop     ebp
.text$mn:00002525                 retn    8
.text$mn:00002525 ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z endp
.text$mn:00002525
.text$mn:00002525 _text$mn        ends
.text$mn:00002525
.text$mn:00002528 ; ===========================================================================
.text$mn:00002528
.text$mn:00002528 ; Segment type: Pure code
.text$mn:00002528 ; Segment permissions: Read/Execute
.text$mn:00002528 _text$mn        segment para public 'CODE' use32
.text$mn:00002528                 assume cs:_text$mn
.text$mn:00002528                 ;org 2528h
.text$mn:00002528 ; COMDAT (pick any)
.text$mn:00002528                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002528
.text$mn:00002528 ; =============== S U B R O U T I N E =======================================
.text$mn:00002528
.text$mn:00002528 ; Attributes: bp-based frame
.text$mn:00002528
.text$mn:00002528 ; bool __thiscall std::error_category::equivalent(std::error_category *this, const struct std::error_code *, int)
.text$mn:00002528                 public ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
.text$mn:00002528 ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z proc near
.text$mn:00002528                                         ; DATA XREF: .rdata:00002E90o
.text$mn:00002528                                         ; .rdata:00002EACo ...
.text$mn:00002528
.text$mn:00002528 var_8           = dword ptr -8
.text$mn:00002528 var_4           = dword ptr -4
.text$mn:00002528 arg_0           = dword ptr  8
.text$mn:00002528 arg_4           = dword ptr  0Ch
.text$mn:00002528
.text$mn:00002528                 push    ebp
.text$mn:00002529                 mov     ebp, esp
.text$mn:0000252B                 sub     esp, 8
.text$mn:0000252E                 mov     [ebp+var_8], ecx
.text$mn:00002531                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00002534                 call    ?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category(void)
.text$mn:00002539                 push    eax
.text$mn:0000253A                 mov     ecx, [ebp+var_8]
.text$mn:0000253D                 call    ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
.text$mn:00002542                 movzx   eax, al
.text$mn:00002545                 test    eax, eax
.text$mn:00002547                 jz      short loc_255F
.text$mn:00002549                 mov     ecx, [ebp+arg_0] ; this
.text$mn:0000254C                 call    ?value@error_code@std@@QBEHXZ ; std::error_code::value(void)
.text$mn:00002551                 cmp     eax, [ebp+arg_4]
.text$mn:00002554                 jnz     short loc_255F
.text$mn:00002556                 mov     [ebp+var_4], 1
.text$mn:0000255D                 jmp     short loc_2566
.text$mn:0000255F ; ---------------------------------------------------------------------------
.text$mn:0000255F
.text$mn:0000255F loc_255F:                               ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+1Fj
.text$mn:0000255F                                         ; std::error_category::equivalent(std::error_code const &,int)+2Cj
.text$mn:0000255F                 mov     [ebp+var_4], 0
.text$mn:00002566
.text$mn:00002566 loc_2566:                               ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+35j
.text$mn:00002566                 mov     al, byte ptr [ebp+var_4]
.text$mn:00002569                 mov     esp, ebp
.text$mn:0000256B                 pop     ebp
.text$mn:0000256C                 retn    8
.text$mn:0000256C ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z endp
.text$mn:0000256C
.text$mn:0000256C ; ---------------------------------------------------------------------------
.text$mn:0000256F                 align 10h
.text$mn:0000256F _text$mn        ends
.text$mn:0000256F
.text$mn:00002570 ; ===========================================================================
.text$mn:00002570
.text$mn:00002570 ; Segment type: Pure code
.text$mn:00002570 ; Segment permissions: Read/Execute
.text$mn:00002570 _text$mn        segment para public 'CODE' use32
.text$mn:00002570                 assume cs:_text$mn
.text$mn:00002570                 ;org 2570h
.text$mn:00002570 ; COMDAT (pick any)
.text$mn:00002570                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002570
.text$mn:00002570 ; =============== S U B R O U T I N E =======================================
.text$mn:00002570
.text$mn:00002570 ; Attributes: bp-based frame
.text$mn:00002570
.text$mn:00002570 ; bool __thiscall std::error_category::equivalent(std::error_category *this, int, const struct std::error_condition *)
.text$mn:00002570                 public ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
.text$mn:00002570 ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z proc near
.text$mn:00002570                                         ; DATA XREF: .rdata:00002E94o
.text$mn:00002570                                         ; .rdata:00002EB0o ...
.text$mn:00002570
.text$mn:00002570 var_C           = byte ptr -0Ch
.text$mn:00002570 var_4           = dword ptr -4
.text$mn:00002570 arg_0           = dword ptr  8
.text$mn:00002570 arg_4           = dword ptr  0Ch
.text$mn:00002570
.text$mn:00002570                 push    ebp
.text$mn:00002571                 mov     ebp, esp
.text$mn:00002573                 sub     esp, 0Ch
.text$mn:00002576                 mov     [ebp+var_4], ecx
.text$mn:00002579                 mov     eax, [ebp+arg_4]
.text$mn:0000257C                 push    eax             ; std::error_condition *
.text$mn:0000257D                 mov     ecx, [ebp+arg_0]
.text$mn:00002580                 push    ecx
.text$mn:00002581                 lea     edx, [ebp+var_C]
.text$mn:00002584                 push    edx
.text$mn:00002585                 mov     eax, [ebp+var_4]
.text$mn:00002588                 mov     edx, [eax]
.text$mn:0000258A                 mov     ecx, [ebp+var_4]
.text$mn:0000258D                 mov     eax, [edx+0Ch]
.text$mn:00002590                 call    eax
.text$mn:00002592                 mov     ecx, eax
.text$mn:00002594                 call    ??8error_condition@std@@QBE_NABV01@@Z ; std::error_condition::operator==(std::error_condition const &)
.text$mn:00002599                 mov     esp, ebp
.text$mn:0000259B                 pop     ebp
.text$mn:0000259C                 retn    8
.text$mn:0000259C ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z endp
.text$mn:0000259C
.text$mn:0000259C ; ---------------------------------------------------------------------------
.text$mn:0000259F                 align 10h
.text$mn:0000259F _text$mn        ends
.text$mn:0000259F
.text$mn:000025A0 ; ===========================================================================
.text$mn:000025A0
.text$mn:000025A0 ; Segment type: Pure code
.text$mn:000025A0 ; Segment permissions: Read/Execute
.text$mn:000025A0 _text$mn        segment para public 'CODE' use32
.text$mn:000025A0                 assume cs:_text$mn
.text$mn:000025A0                 ;org 25A0h
.text$mn:000025A0 ; COMDAT (pick any)
.text$mn:000025A0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000025A0
.text$mn:000025A0 ; =============== S U B R O U T I N E =======================================
.text$mn:000025A0
.text$mn:000025A0 ; Attributes: bp-based frame
.text$mn:000025A0
.text$mn:000025A0 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int)
.text$mn:000025A0                 public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
.text$mn:000025A0 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z proc near
.text$mn:000025A0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+4Cp
.text$mn:000025A0
.text$mn:000025A0 var_4           = dword ptr -4
.text$mn:000025A0 arg_0           = dword ptr  8
.text$mn:000025A0
.text$mn:000025A0                 push    ebp
.text$mn:000025A1                 mov     ebp, esp
.text$mn:000025A3                 push    ecx
.text$mn:000025A4                 mov     [ebp+var_4], ecx
.text$mn:000025A7                 mov     eax, [ebp+var_4]
.text$mn:000025AA                 mov     ecx, [eax+14h]
.text$mn:000025AD                 cmp     ecx, [ebp+arg_0]
.text$mn:000025B0                 jnb     short loc_25BA
.text$mn:000025B2                 mov     ecx, [ebp+var_4]
.text$mn:000025B5                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:000025BA
.text$mn:000025BA loc_25BA:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)+10j
.text$mn:000025BA                 mov     edx, [ebp+arg_0]
.text$mn:000025BD                 push    edx
.text$mn:000025BE                 mov     ecx, [ebp+var_4]
.text$mn:000025C1                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000025C6                 mov     eax, [ebp+var_4]
.text$mn:000025C9                 mov     esp, ebp
.text$mn:000025CB                 pop     ebp
.text$mn:000025CC                 retn    4
.text$mn:000025CC ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z endp
.text$mn:000025CC
.text$mn:000025CC ; ---------------------------------------------------------------------------
.text$mn:000025CF                 align 10h
.text$mn:000025CF _text$mn        ends
.text$mn:000025CF
.text$mn:000025D0 ; ===========================================================================
.text$mn:000025D0
.text$mn:000025D0 ; Segment type: Pure code
.text$mn:000025D0 ; Segment permissions: Read/Execute
.text$mn:000025D0 _text$mn        segment para public 'CODE' use32
.text$mn:000025D0                 assume cs:_text$mn
.text$mn:000025D0                 ;org 25D0h
.text$mn:000025D0 ; COMDAT (pick any)
.text$mn:000025D0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000025D0
.text$mn:000025D0 ; =============== S U B R O U T I N E =======================================
.text$mn:000025D0
.text$mn:000025D0 ; Attributes: bp-based frame
.text$mn:000025D0
.text$mn:000025D0 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int, unsigned int)
.text$mn:000025D0                 public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
.text$mn:000025D0 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z proc near
.text$mn:000025D0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+5Ap
.text$mn:000025D0
.text$mn:000025D0 var_C           = dword ptr -0Ch
.text$mn:000025D0 Dst             = dword ptr -8
.text$mn:000025D0 var_4           = dword ptr -4
.text$mn:000025D0 arg_0           = dword ptr  8
.text$mn:000025D0 arg_4           = dword ptr  0Ch
.text$mn:000025D0
.text$mn:000025D0                 push    ebp
.text$mn:000025D1                 mov     ebp, esp
.text$mn:000025D3                 sub     esp, 0Ch
.text$mn:000025D6                 mov     [ebp+var_4], ecx
.text$mn:000025D9                 mov     eax, [ebp+var_4]
.text$mn:000025DC                 mov     ecx, [eax+14h]
.text$mn:000025DF                 cmp     ecx, [ebp+arg_0]
.text$mn:000025E2                 jnb     short loc_25EC
.text$mn:000025E4                 mov     ecx, [ebp+var_4]
.text$mn:000025E7                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:000025EC
.text$mn:000025EC loc_25EC:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+12j
.text$mn:000025EC                 mov     edx, [ebp+var_4]
.text$mn:000025EF                 mov     eax, [edx+14h]
.text$mn:000025F2                 sub     eax, [ebp+arg_0]
.text$mn:000025F5                 cmp     eax, [ebp+arg_4]
.text$mn:000025F8                 ja      short loc_2608
.text$mn:000025FA                 mov     ecx, [ebp+arg_0]
.text$mn:000025FD                 push    ecx
.text$mn:000025FE                 mov     ecx, [ebp+var_4]
.text$mn:00002601                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00002606                 jmp     short loc_264E
.text$mn:00002608 ; ---------------------------------------------------------------------------
.text$mn:00002608
.text$mn:00002608 loc_2608:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+28j
.text$mn:00002608                 cmp     [ebp+arg_4], 0
.text$mn:0000260C                 jbe     short loc_264E
.text$mn:0000260E                 mov     ecx, [ebp+var_4]
.text$mn:00002611                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00002616                 add     eax, [ebp+arg_0]
.text$mn:00002619                 mov     [ebp+Dst], eax
.text$mn:0000261C                 mov     edx, [ebp+var_4]
.text$mn:0000261F                 mov     eax, [edx+14h]
.text$mn:00002622                 sub     eax, [ebp+arg_4]
.text$mn:00002625                 mov     [ebp+var_C], eax
.text$mn:00002628                 mov     ecx, [ebp+var_C]
.text$mn:0000262B                 sub     ecx, [ebp+arg_0]
.text$mn:0000262E                 push    ecx             ; Size
.text$mn:0000262F                 mov     edx, [ebp+Dst]
.text$mn:00002632                 add     edx, [ebp+arg_4]
.text$mn:00002635                 push    edx             ; Src
.text$mn:00002636                 mov     eax, [ebp+Dst]
.text$mn:00002639                 push    eax             ; Dst
.text$mn:0000263A                 call    ?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move(char *,char const *,uint)
.text$mn:0000263F                 add     esp, 0Ch
.text$mn:00002642                 mov     ecx, [ebp+var_C]
.text$mn:00002645                 push    ecx
.text$mn:00002646                 mov     ecx, [ebp+var_4]
.text$mn:00002649                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:0000264E
.text$mn:0000264E loc_264E:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+36j
.text$mn:0000264E                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+3Cj
.text$mn:0000264E                 mov     eax, [ebp+var_4]
.text$mn:00002651                 mov     esp, ebp
.text$mn:00002653                 pop     ebp
.text$mn:00002654                 retn    8
.text$mn:00002654 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z endp
.text$mn:00002654
.text$mn:00002654 ; ---------------------------------------------------------------------------
.text$mn:00002657                 align 4
.text$mn:00002657 _text$mn        ends
.text$mn:00002657
.text$mn:00002658 ; ===========================================================================
.text$mn:00002658
.text$mn:00002658 ; Segment type: Pure code
.text$mn:00002658 ; Segment permissions: Read/Execute
.text$mn:00002658 _text$mn        segment para public 'CODE' use32
.text$mn:00002658                 assume cs:_text$mn
.text$mn:00002658                 ;org 2658h
.text$mn:00002658 ; COMDAT (pick any)
.text$mn:00002658                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002658
.text$mn:00002658 ; =============== S U B R O U T I N E =======================================
.text$mn:00002658
.text$mn:00002658 ; Attributes: bp-based frame
.text$mn:00002658
.text$mn:00002658 ; __int32 __thiscall ScintillaEditView::execute(ScintillaEditView *this, unsigned int, unsigned int, __int32)
.text$mn:00002658                 public ?execute@ScintillaEditView@@QBEJIIJ@Z
.text$mn:00002658 ?execute@ScintillaEditView@@QBEJIIJ@Z proc near
.text$mn:00002658                                         ; CODE XREF: GoToLineDlg::run_dlgProc(uint,uint,long)+F8p
.text$mn:00002658                                         ; GoToLineDlg::run_dlgProc(uint,uint,long)+113p ...
.text$mn:00002658
.text$mn:00002658 var_4           = dword ptr -4
.text$mn:00002658 arg_0           = dword ptr  8
.text$mn:00002658 arg_4           = dword ptr  0Ch
.text$mn:00002658 arg_8           = dword ptr  10h
.text$mn:00002658
.text$mn:00002658                 push    ebp
.text$mn:00002659                 mov     ebp, esp
.text$mn:0000265B                 push    ecx
.text$mn:0000265C                 mov     [ebp+var_4], ecx
.text$mn:0000265F                 mov     eax, [ebp+arg_8]
.text$mn:00002662                 push    eax
.text$mn:00002663                 mov     ecx, [ebp+arg_4]
.text$mn:00002666                 push    ecx
.text$mn:00002667                 mov     edx, [ebp+arg_0]
.text$mn:0000266A                 push    edx
.text$mn:0000266B                 mov     eax, [ebp+var_4]
.text$mn:0000266E                 mov     ecx, [eax+14h]
.text$mn:00002671                 push    ecx
.text$mn:00002672                 mov     edx, [ebp+var_4]
.text$mn:00002675                 mov     eax, [edx+10h]
.text$mn:00002678                 call    eax
.text$mn:0000267A                 add     esp, 10h
.text$mn:0000267D                 mov     esp, ebp
.text$mn:0000267F                 pop     ebp
.text$mn:00002680                 retn    0Ch
.text$mn:00002680 ?execute@ScintillaEditView@@QBEJIIJ@Z endp
.text$mn:00002680
.text$mn:00002680 ; ---------------------------------------------------------------------------
.text$mn:00002683                 align 4
.text$mn:00002683 _text$mn        ends
.text$mn:00002683
.text$mn:00002684 ; ===========================================================================
.text$mn:00002684
.text$mn:00002684 ; Segment type: Pure code
.text$mn:00002684 ; Segment permissions: Read/Execute
.text$mn:00002684 _text$mn        segment para public 'CODE' use32
.text$mn:00002684                 assume cs:_text$mn
.text$mn:00002684                 ;org 2684h
.text$mn:00002684 ; COMDAT (pick any)
.text$mn:00002684                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002684
.text$mn:00002684 ; =============== S U B R O U T I N E =======================================
.text$mn:00002684
.text$mn:00002684 ; Attributes: bp-based frame
.text$mn:00002684
.text$mn:00002684 ; const struct std::error_category *__cdecl std::generic_category()
.text$mn:00002684                 public ?generic_category@std@@YAABVerror_category@1@XZ
.text$mn:00002684 ?generic_category@std@@YAABVerror_category@1@XZ proc near
.text$mn:00002684                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+17p
.text$mn:00002684                 push    ebp
.text$mn:00002685                 mov     ebp, esp
.text$mn:00002687                 mov     eax, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
.text$mn:0000268C                 pop     ebp
.text$mn:0000268D                 retn
.text$mn:0000268D ?generic_category@std@@YAABVerror_category@1@XZ endp
.text$mn:0000268D
.text$mn:0000268D ; ---------------------------------------------------------------------------
.text$mn:0000268E                 align 10h
.text$mn:0000268E _text$mn        ends
.text$mn:0000268E
.text$mn:00002690 ; ===========================================================================
.text$mn:00002690
.text$mn:00002690 ; Segment type: Pure code
.text$mn:00002690 ; Segment permissions: Read/Execute
.text$mn:00002690 _text$mn        segment para public 'CODE' use32
.text$mn:00002690                 assume cs:_text$mn
.text$mn:00002690                 ;org 2690h
.text$mn:00002690 ; COMDAT (pick any)
.text$mn:00002690                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002690
.text$mn:00002690 ; =============== S U B R O U T I N E =======================================
.text$mn:00002690
.text$mn:00002690 ; Attributes: bp-based frame
.text$mn:00002690
.text$mn:00002690 ; int __thiscall ScintillaEditView::getCurrentDocLen(ScintillaEditView *__hidden this)
.text$mn:00002690                 public ?getCurrentDocLen@ScintillaEditView@@QBEHXZ
.text$mn:00002690 ?getCurrentDocLen@ScintillaEditView@@QBEHXZ proc near
.text$mn:00002690                                         ; CODE XREF: GoToLineDlg::updateLinesNumbers(void)+6Fp
.text$mn:00002690
.text$mn:00002690 var_4           = dword ptr -4
.text$mn:00002690
.text$mn:00002690                 push    ebp
.text$mn:00002691                 mov     ebp, esp
.text$mn:00002693                 push    ecx
.text$mn:00002694                 mov     [ebp+var_4], ecx
.text$mn:00002697                 push    0               ; __int32
.text$mn:00002699                 push    0               ; unsigned int
.text$mn:0000269B                 push    7D6h            ; unsigned int
.text$mn:000026A0                 mov     ecx, [ebp+var_4] ; this
.text$mn:000026A3                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:000026A8                 mov     esp, ebp
.text$mn:000026AA                 pop     ebp
.text$mn:000026AB                 retn
.text$mn:000026AB ?getCurrentDocLen@ScintillaEditView@@QBEHXZ endp
.text$mn:000026AB
.text$mn:000026AB _text$mn        ends
.text$mn:000026AB
.text$mn:000026AC ; ===========================================================================
.text$mn:000026AC
.text$mn:000026AC ; Segment type: Pure code
.text$mn:000026AC ; Segment permissions: Read/Execute
.text$mn:000026AC _text$mn        segment para public 'CODE' use32
.text$mn:000026AC                 assume cs:_text$mn
.text$mn:000026AC                 ;org 26ACh
.text$mn:000026AC ; COMDAT (pick any)
.text$mn:000026AC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000026AC
.text$mn:000026AC ; =============== S U B R O U T I N E =======================================
.text$mn:000026AC
.text$mn:000026AC ; Attributes: bp-based frame
.text$mn:000026AC
.text$mn:000026AC ; __int32 __thiscall ScintillaEditView::getCurrentLineNumber(ScintillaEditView *__hidden this)
.text$mn:000026AC                 public ?getCurrentLineNumber@ScintillaEditView@@QBEJXZ
.text$mn:000026AC ?getCurrentLineNumber@ScintillaEditView@@QBEJXZ proc near
.text$mn:000026AC                                         ; CODE XREF: GoToLineDlg::updateLinesNumbers(void)+28p
.text$mn:000026AC
.text$mn:000026AC var_4           = dword ptr -4
.text$mn:000026AC
.text$mn:000026AC                 push    ebp
.text$mn:000026AD                 mov     ebp, esp
.text$mn:000026AF                 push    ecx
.text$mn:000026B0                 mov     [ebp+var_4], ecx
.text$mn:000026B3                 push    0               ; __int32
.text$mn:000026B5                 push    0               ; __int32
.text$mn:000026B7                 push    0               ; unsigned int
.text$mn:000026B9                 push    7D8h            ; unsigned int
.text$mn:000026BE                 mov     ecx, [ebp+var_4] ; this
.text$mn:000026C1                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:000026C6                 push    eax             ; unsigned int
.text$mn:000026C7                 push    876h            ; unsigned int
.text$mn:000026CC                 mov     ecx, [ebp+var_4] ; this
.text$mn:000026CF                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:000026D4                 mov     esp, ebp
.text$mn:000026D6                 pop     ebp
.text$mn:000026D7                 retn
.text$mn:000026D7 ?getCurrentLineNumber@ScintillaEditView@@QBEJXZ endp
.text$mn:000026D7
.text$mn:000026D7 _text$mn        ends
.text$mn:000026D7
.text$mn:000026D8 ; ===========================================================================
.text$mn:000026D8
.text$mn:000026D8 ; Segment type: Pure code
.text$mn:000026D8 ; Segment permissions: Read/Execute
.text$mn:000026D8 _text$mn        segment para public 'CODE' use32
.text$mn:000026D8                 assume cs:_text$mn
.text$mn:000026D8                 ;org 26D8h
.text$mn:000026D8 ; COMDAT (pick any)
.text$mn:000026D8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000026D8
.text$mn:000026D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000026D8
.text$mn:000026D8 ; Attributes: bp-based frame
.text$mn:000026D8
.text$mn:000026D8 ; void __thiscall Window::getFocus(Window *__hidden this)
.text$mn:000026D8                 public ?getFocus@Window@@QBEXXZ
.text$mn:000026D8 ?getFocus@Window@@QBEXXZ proc near      ; CODE XREF: GoToLineDlg::run_dlgProc(uint,uint,long)+1B5p
.text$mn:000026D8
.text$mn:000026D8 var_4           = dword ptr -4
.text$mn:000026D8
.text$mn:000026D8                 push    ebp
.text$mn:000026D9                 mov     ebp, esp
.text$mn:000026DB                 push    ecx
.text$mn:000026DC                 mov     [ebp+var_4], ecx
.text$mn:000026DF                 mov     eax, [ebp+var_4]
.text$mn:000026E2                 mov     ecx, [eax+0Ch]
.text$mn:000026E5                 push    ecx             ; hWnd
.text$mn:000026E6                 call    dword ptr ds:__imp__SetFocus@4 ; SetFocus(x)
.text$mn:000026EC                 mov     esp, ebp
.text$mn:000026EE                 pop     ebp
.text$mn:000026EF                 retn
.text$mn:000026EF ?getFocus@Window@@QBEXXZ endp
.text$mn:000026EF
.text$mn:000026EF _text$mn        ends
.text$mn:000026EF
.text$mn:000026F0 ; ===========================================================================
.text$mn:000026F0
.text$mn:000026F0 ; Segment type: Pure code
.text$mn:000026F0 ; Segment permissions: Read/Execute
.text$mn:000026F0 _text$mn        segment para public 'CODE' use32
.text$mn:000026F0                 assume cs:_text$mn
.text$mn:000026F0                 ;org 26F0h
.text$mn:000026F0 ; COMDAT (pick any)
.text$mn:000026F0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000026F0
.text$mn:000026F0 ; =============== S U B R O U T I N E =======================================
.text$mn:000026F0
.text$mn:000026F0 ; Attributes: bp-based frame
.text$mn:000026F0
.text$mn:000026F0 ; int __thiscall GoToLineDlg::getLine(GoToLineDlg *__hidden this)
.text$mn:000026F0                 public ?getLine@GoToLineDlg@@ABEHXZ
.text$mn:000026F0 ?getLine@GoToLineDlg@@ABEHXZ proc near  ; CODE XREF: GoToLineDlg::run_dlgProc(uint,uint,long)+B0p
.text$mn:000026F0
.text$mn:000026F0 var_10          = dword ptr -10h
.text$mn:000026F0 Translated      = dword ptr -0Ch
.text$mn:000026F0 var_8           = dword ptr -8
.text$mn:000026F0 var_4           = dword ptr -4
.text$mn:000026F0
.text$mn:000026F0                 push    ebp
.text$mn:000026F1                 mov     ebp, esp
.text$mn:000026F3                 sub     esp, 10h
.text$mn:000026F6                 mov     [ebp+var_8], ecx
.text$mn:000026F9                 push    0               ; bSigned
.text$mn:000026FB                 lea     eax, [ebp+Translated]
.text$mn:000026FE                 push    eax             ; lpTranslated
.text$mn:000026FF                 push    7D1h            ; nIDDlgItem
.text$mn:00002704                 mov     ecx, [ebp+var_8]
.text$mn:00002707                 mov     edx, [ecx+0Ch]
.text$mn:0000270A                 push    edx             ; hDlg
.text$mn:0000270B                 call    dword ptr ds:__imp__GetDlgItemInt@16 ; GetDlgItemInt(x,x,x,x)
.text$mn:00002711                 mov     [ebp+var_10], eax
.text$mn:00002714                 cmp     [ebp+Translated], 0
.text$mn:00002718                 jz      short loc_2722
.text$mn:0000271A                 mov     eax, [ebp+var_10]
.text$mn:0000271D                 mov     [ebp+var_4], eax
.text$mn:00002720                 jmp     short loc_2729
.text$mn:00002722 ; ---------------------------------------------------------------------------
.text$mn:00002722
.text$mn:00002722 loc_2722:                               ; CODE XREF: GoToLineDlg::getLine(void)+28j
.text$mn:00002722                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002729
.text$mn:00002729 loc_2729:                               ; CODE XREF: GoToLineDlg::getLine(void)+30j
.text$mn:00002729                 mov     eax, [ebp+var_4]
.text$mn:0000272C                 mov     esp, ebp
.text$mn:0000272E                 pop     ebp
.text$mn:0000272F                 retn
.text$mn:0000272F ?getLine@GoToLineDlg@@ABEHXZ endp
.text$mn:0000272F
.text$mn:0000272F _text$mn        ends
.text$mn:0000272F
.text$mn:00002730 ; ===========================================================================
.text$mn:00002730
.text$mn:00002730 ; Segment type: Pure code
.text$mn:00002730 ; Segment permissions: Read/Execute
.text$mn:00002730 _text$mn        segment para public 'CODE' use32
.text$mn:00002730                 assume cs:_text$mn
.text$mn:00002730                 ;org 2730h
.text$mn:00002730 ; COMDAT (pick any)
.text$mn:00002730                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002730
.text$mn:00002730 ; =============== S U B R O U T I N E =======================================
.text$mn:00002730
.text$mn:00002730 ; Attributes: bp-based frame
.text$mn:00002730
.text$mn:00002730 ; int __cdecl std::char_traits<char>::length(char *Str)
.text$mn:00002730                 public ?length@?$char_traits@D@std@@SAIPBD@Z
.text$mn:00002730 ?length@?$char_traits@D@std@@SAIPBD@Z proc near
.text$mn:00002730                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+21p
.text$mn:00002730
.text$mn:00002730 var_4           = dword ptr -4
.text$mn:00002730 Str             = dword ptr  8
.text$mn:00002730
.text$mn:00002730                 push    ebp
.text$mn:00002731                 mov     ebp, esp
.text$mn:00002733                 push    ecx
.text$mn:00002734                 mov     eax, [ebp+Str]
.text$mn:00002737                 movsx   ecx, byte ptr [eax]
.text$mn:0000273A                 test    ecx, ecx
.text$mn:0000273C                 jnz     short loc_2747
.text$mn:0000273E                 mov     [ebp+var_4], 0
.text$mn:00002745                 jmp     short loc_2756
.text$mn:00002747 ; ---------------------------------------------------------------------------
.text$mn:00002747
.text$mn:00002747 loc_2747:                               ; CODE XREF: std::char_traits<char>::length(char const *)+Cj
.text$mn:00002747                 mov     edx, [ebp+Str]
.text$mn:0000274A                 push    edx             ; Str
.text$mn:0000274B                 call    _strlen
.text$mn:00002750                 add     esp, 4
.text$mn:00002753                 mov     [ebp+var_4], eax
.text$mn:00002756
.text$mn:00002756 loc_2756:                               ; CODE XREF: std::char_traits<char>::length(char const *)+15j
.text$mn:00002756                 mov     eax, [ebp+var_4]
.text$mn:00002759                 mov     esp, ebp
.text$mn:0000275B                 pop     ebp
.text$mn:0000275C                 retn
.text$mn:0000275C ?length@?$char_traits@D@std@@SAIPBD@Z endp
.text$mn:0000275C
.text$mn:0000275C ; ---------------------------------------------------------------------------
.text$mn:0000275D                 align 10h
.text$mn:0000275D _text$mn        ends
.text$mn:0000275D
.text$mn:00002760 ; ===========================================================================
.text$mn:00002760
.text$mn:00002760 ; Segment type: Pure code
.text$mn:00002760 ; Segment permissions: Read/Execute
.text$mn:00002760 _text$mn        segment para public 'CODE' use32
.text$mn:00002760                 assume cs:_text$mn
.text$mn:00002760                 ;org 2760h
.text$mn:00002760 ; COMDAT (pick any)
.text$mn:00002760                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002760
.text$mn:00002760 ; =============== S U B R O U T I N E =======================================
.text$mn:00002760
.text$mn:00002760 ; Attributes: bp-based frame
.text$mn:00002760
.text$mn:00002760 ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<char>>::max_size(void)const
.text$mn:00002760                 public ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
.text$mn:00002760 ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ proc near
.text$mn:00002760                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+17p
.text$mn:00002760
.text$mn:00002760 var_4           = dword ptr -4
.text$mn:00002760
.text$mn:00002760                 push    ebp
.text$mn:00002761                 mov     ebp, esp
.text$mn:00002763                 push    ecx
.text$mn:00002764                 mov     [ebp+var_4], ecx
.text$mn:00002767                 mov     eax, [ebp+var_4]
.text$mn:0000276A                 push    eax
.text$mn:0000276B                 call    ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char> const &)
.text$mn:00002770                 add     esp, 4
.text$mn:00002773                 mov     esp, ebp
.text$mn:00002775                 pop     ebp
.text$mn:00002776                 retn
.text$mn:00002776 ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ endp
.text$mn:00002776
.text$mn:00002776 ; ---------------------------------------------------------------------------
.text$mn:00002777                 align 4
.text$mn:00002777 _text$mn        ends
.text$mn:00002777
.text$mn:00002778 ; ===========================================================================
.text$mn:00002778
.text$mn:00002778 ; Segment type: Pure code
.text$mn:00002778 ; Segment permissions: Read/Execute
.text$mn:00002778 _text$mn        segment para public 'CODE' use32
.text$mn:00002778                 assume cs:_text$mn
.text$mn:00002778                 ;org 2778h
.text$mn:00002778 ; COMDAT (pick any)
.text$mn:00002778                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002778
.text$mn:00002778 ; =============== S U B R O U T I N E =======================================
.text$mn:00002778
.text$mn:00002778 ; Attributes: bp-based frame
.text$mn:00002778
.text$mn:00002778 ; public: unsigned int __thiscall std::allocator<char>::max_size(void)const
.text$mn:00002778                 public ?max_size@?$allocator@D@std@@QBEIXZ
.text$mn:00002778 ?max_size@?$allocator@D@std@@QBEIXZ proc near
.text$mn:00002778                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char> const &)+6p
.text$mn:00002778
.text$mn:00002778 var_4           = dword ptr -4
.text$mn:00002778
.text$mn:00002778                 push    ebp
.text$mn:00002779                 mov     ebp, esp
.text$mn:0000277B                 push    ecx
.text$mn:0000277C                 mov     [ebp+var_4], ecx
.text$mn:0000277F                 or      eax, 0FFFFFFFFh
.text$mn:00002782                 mov     esp, ebp
.text$mn:00002784                 pop     ebp
.text$mn:00002785                 retn
.text$mn:00002785 ?max_size@?$allocator@D@std@@QBEIXZ endp
.text$mn:00002785
.text$mn:00002785 ; ---------------------------------------------------------------------------
.text$mn:00002786                 align 4
.text$mn:00002786 _text$mn        ends
.text$mn:00002786
.text$mn:00002788 ; ===========================================================================
.text$mn:00002788
.text$mn:00002788 ; Segment type: Pure code
.text$mn:00002788 ; Segment permissions: Read/Execute
.text$mn:00002788 _text$mn        segment para public 'CODE' use32
.text$mn:00002788                 assume cs:_text$mn
.text$mn:00002788                 ;org 2788h
.text$mn:00002788 ; COMDAT (pick any)
.text$mn:00002788                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002788
.text$mn:00002788 ; =============== S U B R O U T I N E =======================================
.text$mn:00002788
.text$mn:00002788 ; Attributes: bp-based frame
.text$mn:00002788
.text$mn:00002788 ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<char>>::max_size(class std::allocator<char> const &)
.text$mn:00002788                 public ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
.text$mn:00002788 ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z proc near
.text$mn:00002788                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::max_size(void)+Bp
.text$mn:00002788
.text$mn:00002788 arg_0           = dword ptr  8
.text$mn:00002788
.text$mn:00002788                 push    ebp
.text$mn:00002789                 mov     ebp, esp
.text$mn:0000278B                 mov     ecx, [ebp+arg_0]
.text$mn:0000278E                 call    ?max_size@?$allocator@D@std@@QBEIXZ ; std::allocator<char>::max_size(void)
.text$mn:00002793                 pop     ebp
.text$mn:00002794                 retn
.text$mn:00002794 ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z endp
.text$mn:00002794
.text$mn:00002794 ; ---------------------------------------------------------------------------
.text$mn:00002795                 align 4
.text$mn:00002795 _text$mn        ends
.text$mn:00002795
.text$mn:00002798 ; ===========================================================================
.text$mn:00002798
.text$mn:00002798 ; Segment type: Pure code
.text$mn:00002798 ; Segment permissions: Read/Execute
.text$mn:00002798 _text$mn        segment para public 'CODE' use32
.text$mn:00002798                 assume cs:_text$mn
.text$mn:00002798                 ;org 2798h
.text$mn:00002798 ; COMDAT (pick any)
.text$mn:00002798                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002798
.text$mn:00002798 ; =============== S U B R O U T I N E =======================================
.text$mn:00002798
.text$mn:00002798 ; Attributes: bp-based frame
.text$mn:00002798
.text$mn:00002798 ; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::max_size(void)const
.text$mn:00002798                 public ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
.text$mn:00002798 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
.text$mn:00002798                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+3Bp
.text$mn:00002798                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+6Ap ...
.text$mn:00002798
.text$mn:00002798 var_10          = dword ptr -10h
.text$mn:00002798 var_C           = dword ptr -0Ch
.text$mn:00002798 var_8           = dword ptr -8
.text$mn:00002798 var_1           = byte ptr -1
.text$mn:00002798
.text$mn:00002798                 push    ebp
.text$mn:00002799                 mov     ebp, esp
.text$mn:0000279B                 sub     esp, 10h
.text$mn:0000279E                 mov     [ebp+var_10], ecx
.text$mn:000027A1                 lea     eax, [ebp+var_1]
.text$mn:000027A4                 push    eax
.text$mn:000027A5                 mov     ecx, [ebp+var_10]
.text$mn:000027A8                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:000027AD                 mov     ecx, eax
.text$mn:000027AF                 call    ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char>>::max_size(void)
.text$mn:000027B4                 mov     [ebp+var_8], eax
.text$mn:000027B7                 cmp     [ebp+var_8], 1
.text$mn:000027BB                 ja      short loc_27C6
.text$mn:000027BD                 mov     [ebp+var_C], 1
.text$mn:000027C4                 jmp     short loc_27CF
.text$mn:000027C6 ; ---------------------------------------------------------------------------
.text$mn:000027C6
.text$mn:000027C6 loc_27C6:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+23j
.text$mn:000027C6                 mov     ecx, [ebp+var_8]
.text$mn:000027C9                 sub     ecx, 1
.text$mn:000027CC                 mov     [ebp+var_C], ecx
.text$mn:000027CF
.text$mn:000027CF loc_27CF:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+2Cj
.text$mn:000027CF                 mov     eax, [ebp+var_C]
.text$mn:000027D2                 mov     esp, ebp
.text$mn:000027D4                 pop     ebp
.text$mn:000027D5                 retn
.text$mn:000027D5 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp
.text$mn:000027D5
.text$mn:000027D5 ; ---------------------------------------------------------------------------
.text$mn:000027D6                 align 4
.text$mn:000027D6 _text$mn        ends
.text$mn:000027D6
.text$mn:000027D8 ; ===========================================================================
.text$mn:000027D8
.text$mn:000027D8 ; Segment type: Pure code
.text$mn:000027D8 ; Segment permissions: Read/Execute
.text$mn:000027D8 _text$mn        segment para public 'CODE' use32
.text$mn:000027D8                 assume cs:_text$mn
.text$mn:000027D8                 ;org 27D8h
.text$mn:000027D8 ; COMDAT (pick any)
.text$mn:000027D8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000027D8
.text$mn:000027D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000027D8
.text$mn:000027D8 ; Attributes: bp-based frame
.text$mn:000027D8
.text$mn:000027D8 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Generic_error_category::message(int)const
.text$mn:000027D8                 public ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:000027D8 ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:000027D8                                         ; CODE XREF: std::_Iostream_error_category::message(int)+64p
.text$mn:000027D8                                         ; DATA XREF: .rdata:00002EA4o
.text$mn:000027D8
.text$mn:000027D8 var_1C          = dword ptr -1Ch
.text$mn:000027D8 var_18          = dword ptr -18h
.text$mn:000027D8 Str             = dword ptr -14h
.text$mn:000027D8 var_10          = dword ptr -10h
.text$mn:000027D8 var_C           = dword ptr -0Ch
.text$mn:000027D8 var_4           = dword ptr -4
.text$mn:000027D8 arg_0           = dword ptr  8
.text$mn:000027D8 arg_4           = dword ptr  0Ch
.text$mn:000027D8
.text$mn:000027D8                 push    ebp
.text$mn:000027D9                 mov     ebp, esp
.text$mn:000027DB                 push    0FFFFFFFFh
.text$mn:000027DD                 push    offset __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:000027E2                 mov     eax, large fs:0
.text$mn:000027E8                 push    eax
.text$mn:000027E9                 sub     esp, 10h
.text$mn:000027EC                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000027F1                 xor     eax, ebp
.text$mn:000027F3                 push    eax
.text$mn:000027F4                 lea     eax, [ebp+var_C]
.text$mn:000027F7                 mov     large fs:0, eax
.text$mn:000027FD                 mov     [ebp+var_1C], ecx
.text$mn:00002800                 mov     [ebp+var_18], 0
.text$mn:00002807                 mov     eax, [ebp+arg_4]
.text$mn:0000280A                 push    eax             ; int
.text$mn:0000280B                 call    ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map(int)
.text$mn:00002810                 add     esp, 4
.text$mn:00002813                 mov     [ebp+var_10], eax
.text$mn:00002816                 cmp     [ebp+var_10], 0
.text$mn:0000281A                 jz      short loc_2824
.text$mn:0000281C                 mov     ecx, [ebp+var_10]
.text$mn:0000281F                 mov     [ebp+Str], ecx
.text$mn:00002822                 jmp     short loc_282B
.text$mn:00002824 ; ---------------------------------------------------------------------------
.text$mn:00002824
.text$mn:00002824 loc_2824:                               ; CODE XREF: std::_Generic_error_category::message(int)+42j
.text$mn:00002824                 mov     [ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ ; "unknown error"
.text$mn:0000282B
.text$mn:0000282B loc_282B:                               ; CODE XREF: std::_Generic_error_category::message(int)+4Aj
.text$mn:0000282B                 mov     edx, [ebp+Str]
.text$mn:0000282E                 push    edx             ; Str
.text$mn:0000282F                 mov     ecx, [ebp+arg_0]
.text$mn:00002832                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:00002837                 mov     [ebp+var_4], 0
.text$mn:0000283E                 mov     eax, [ebp+var_18]
.text$mn:00002841                 or      eax, 1
.text$mn:00002844                 mov     [ebp+var_18], eax
.text$mn:00002847                 mov     eax, [ebp+arg_0]
.text$mn:0000284A                 mov     ecx, [ebp+var_C]
.text$mn:0000284D                 mov     large fs:0, ecx
.text$mn:00002854                 pop     ecx
.text$mn:00002855                 mov     esp, ebp
.text$mn:00002857                 pop     ebp
.text$mn:00002858                 retn    8
.text$mn:00002858 ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:00002858
.text$mn:00002858 ; ---------------------------------------------------------------------------
.text$mn:0000285B                 align 4
.text$mn:0000285B _text$mn        ends
.text$mn:0000285B
.text$x:0000285C ; ===========================================================================
.text$x:0000285C
.text$x:0000285C ; Segment type: Pure code
.text$x:0000285C ; Segment permissions: Read/Execute
.text$x:0000285C _text$x         segment para public 'CODE' use32
.text$x:0000285C                 assume cs:_text$x
.text$x:0000285C                 ;org 285Ch
.text$x:0000285C ; COMDAT (pick associative to section at 27D8)
.text$x:0000285C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000285C
.text$x:0000285C ; =============== S U B R O U T I N E =======================================
.text$x:0000285C
.text$x:0000285C
.text$x:0000285C __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:0000285C                                         ; DATA XREF: .xdata$x:00002CC4o
.text$x:0000285C                 mov     eax, [ebp-18h]
.text$x:0000285F                 and     eax, 1
.text$x:00002862                 jz      $LN6
.text$x:00002868                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:0000286C                 mov     ecx, [ebp+8]
.text$x:0000286F                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00002874 ; ---------------------------------------------------------------------------
.text$x:00002874
.text$x:00002874 $LN6:                                   ; CODE XREF: __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:00002874                 retn
.text$x:00002874 __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:00002874
.text$x:00002875
.text$x:00002875 ; =============== S U B R O U T I N E =======================================
.text$x:00002875
.text$x:00002875
.text$x:00002875 __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:00002875                                         ; DATA XREF: std::_Generic_error_category::message(int)+5o
.text$x:00002875
.text$x:00002875 arg_4           = dword ptr  8
.text$x:00002875
.text$x:00002875                 mov     edx, [esp+arg_4]
.text$x:00002879                 lea     eax, [edx+0Ch]
.text$x:0000287C                 mov     ecx, [edx-14h]
.text$x:0000287F                 xor     ecx, eax
.text$x:00002881                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002886                 mov     eax, offset __ehfuncinfo$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:0000288B                 jmp     ___CxxFrameHandler3
.text$x:0000288B __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:0000288B
.text$x:0000288B _text$x         ends
.text$x:0000288B
.text$mn:00002890 ; ===========================================================================
.text$mn:00002890
.text$mn:00002890 ; Segment type: Pure code
.text$mn:00002890 ; Segment permissions: Read/Execute
.text$mn:00002890 _text$mn        segment para public 'CODE' use32
.text$mn:00002890                 assume cs:_text$mn
.text$mn:00002890                 ;org 2890h
.text$mn:00002890 ; COMDAT (pick any)
.text$mn:00002890                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002890
.text$mn:00002890 ; =============== S U B R O U T I N E =======================================
.text$mn:00002890
.text$mn:00002890 ; Attributes: bp-based frame
.text$mn:00002890
.text$mn:00002890 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Iostream_error_category::message(int)const
.text$mn:00002890                 public ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00002890 ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:00002890                                         ; DATA XREF: .rdata:00002ED8o
.text$mn:00002890
.text$mn:00002890 var_14          = dword ptr -14h
.text$mn:00002890 var_10          = dword ptr -10h
.text$mn:00002890 var_C           = dword ptr -0Ch
.text$mn:00002890 var_4           = dword ptr -4
.text$mn:00002890 arg_0           = dword ptr  8
.text$mn:00002890 arg_4           = dword ptr  0Ch
.text$mn:00002890
.text$mn:00002890                 push    ebp
.text$mn:00002891                 mov     ebp, esp
.text$mn:00002893                 push    0FFFFFFFFh
.text$mn:00002895                 push    offset __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:0000289A                 mov     eax, large fs:0
.text$mn:000028A0                 push    eax
.text$mn:000028A1                 sub     esp, 8
.text$mn:000028A4                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000028A9                 xor     eax, ebp
.text$mn:000028AB                 push    eax
.text$mn:000028AC                 lea     eax, [ebp+var_C]
.text$mn:000028AF                 mov     large fs:0, eax
.text$mn:000028B5                 mov     [ebp+var_14], ecx
.text$mn:000028B8                 mov     [ebp+var_10], 0
.text$mn:000028BF                 cmp     [ebp+arg_4], 1
.text$mn:000028C3                 jnz     short loc_28E9
.text$mn:000028C5                 push    offset ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ ; "iostream stream error"
.text$mn:000028CA                 mov     ecx, [ebp+arg_0]
.text$mn:000028CD                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:000028D2                 mov     [ebp+var_4], 0
.text$mn:000028D9                 mov     eax, [ebp+var_10]
.text$mn:000028DC                 or      eax, 1
.text$mn:000028DF                 mov     [ebp+var_10], eax
.text$mn:000028E2                 mov     eax, [ebp+arg_0]
.text$mn:000028E5                 jmp     short loc_290C
.text$mn:000028E7 ; ---------------------------------------------------------------------------
.text$mn:000028E7                 jmp     short loc_290C
.text$mn:000028E9 ; ---------------------------------------------------------------------------
.text$mn:000028E9
.text$mn:000028E9 loc_28E9:                               ; CODE XREF: std::_Iostream_error_category::message(int)+33j
.text$mn:000028E9                 mov     ecx, [ebp+arg_4]
.text$mn:000028EC                 push    ecx
.text$mn:000028ED                 mov     edx, [ebp+arg_0]
.text$mn:000028F0                 push    edx
.text$mn:000028F1                 mov     ecx, [ebp+var_14]
.text$mn:000028F4                 call    ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
.text$mn:000028F9                 mov     [ebp+var_4], 0
.text$mn:00002900                 mov     eax, [ebp+var_10]
.text$mn:00002903                 or      eax, 1
.text$mn:00002906                 mov     [ebp+var_10], eax
.text$mn:00002909                 mov     eax, [ebp+arg_0]
.text$mn:0000290C
.text$mn:0000290C loc_290C:                               ; CODE XREF: std::_Iostream_error_category::message(int)+55j
.text$mn:0000290C                                         ; std::_Iostream_error_category::message(int)+57j
.text$mn:0000290C                 mov     ecx, [ebp+var_C]
.text$mn:0000290F                 mov     large fs:0, ecx
.text$mn:00002916                 pop     ecx
.text$mn:00002917                 mov     esp, ebp
.text$mn:00002919                 pop     ebp
.text$mn:0000291A                 retn    8
.text$mn:0000291A ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:0000291A
.text$mn:0000291A ; ---------------------------------------------------------------------------
.text$mn:0000291D                 align 10h
.text$mn:0000291D _text$mn        ends
.text$mn:0000291D
.text$x:00002920 ; ===========================================================================
.text$x:00002920
.text$x:00002920 ; Segment type: Pure code
.text$x:00002920 ; Segment permissions: Read/Execute
.text$x:00002920 _text$x         segment para public 'CODE' use32
.text$x:00002920                 assume cs:_text$x
.text$x:00002920                 ;org 2920h
.text$x:00002920 ; COMDAT (pick associative to section at 2890)
.text$x:00002920                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00002920
.text$x:00002920 ; =============== S U B R O U T I N E =======================================
.text$x:00002920
.text$x:00002920
.text$x:00002920 __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:00002920                                         ; DATA XREF: .xdata$x:00002D48o
.text$x:00002920                 mov     eax, [ebp-10h]
.text$x:00002923                 and     eax, 1
.text$x:00002926                 jz      $LN6_0
.text$x:0000292C                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:00002930                 mov     ecx, [ebp+8]
.text$x:00002933                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00002938 ; ---------------------------------------------------------------------------
.text$x:00002938
.text$x:00002938 $LN6_0:                                 ; CODE XREF: __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:00002938                 retn
.text$x:00002938 __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:00002938
.text$x:00002939
.text$x:00002939 ; =============== S U B R O U T I N E =======================================
.text$x:00002939
.text$x:00002939
.text$x:00002939 __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:00002939                                         ; DATA XREF: std::_Iostream_error_category::message(int)+5o
.text$x:00002939
.text$x:00002939 arg_4           = dword ptr  8
.text$x:00002939
.text$x:00002939                 mov     edx, [esp+arg_4]
.text$x:0000293D                 lea     eax, [edx+0Ch]
.text$x:00002940                 mov     ecx, [edx-0Ch]
.text$x:00002943                 xor     ecx, eax
.text$x:00002945                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000294A                 mov     eax, offset __ehfuncinfo$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:0000294F                 jmp     ___CxxFrameHandler3
.text$x:0000294F __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:0000294F
.text$x:0000294F _text$x         ends
.text$x:0000294F
.text$mn:00002954 ; ===========================================================================
.text$mn:00002954
.text$mn:00002954 ; Segment type: Pure code
.text$mn:00002954 ; Segment permissions: Read/Execute
.text$mn:00002954 _text$mn        segment para public 'CODE' use32
.text$mn:00002954                 assume cs:_text$mn
.text$mn:00002954                 ;org 2954h
.text$mn:00002954 ; COMDAT (pick any)
.text$mn:00002954                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002954
.text$mn:00002954 ; =============== S U B R O U T I N E =======================================
.text$mn:00002954
.text$mn:00002954 ; Attributes: bp-based frame
.text$mn:00002954
.text$mn:00002954 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_System_error_category::message(int)const
.text$mn:00002954                 public ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00002954 ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:00002954                                         ; DATA XREF: .rdata:00002F18o
.text$mn:00002954
.text$mn:00002954 var_1C          = dword ptr -1Ch
.text$mn:00002954 var_18          = dword ptr -18h
.text$mn:00002954 Str             = dword ptr -14h
.text$mn:00002954 var_10          = dword ptr -10h
.text$mn:00002954 var_C           = dword ptr -0Ch
.text$mn:00002954 var_4           = dword ptr -4
.text$mn:00002954 arg_0           = dword ptr  8
.text$mn:00002954 arg_4           = dword ptr  0Ch
.text$mn:00002954
.text$mn:00002954                 push    ebp
.text$mn:00002955                 mov     ebp, esp
.text$mn:00002957                 push    0FFFFFFFFh
.text$mn:00002959                 push    offset __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:0000295E                 mov     eax, large fs:0
.text$mn:00002964                 push    eax
.text$mn:00002965                 sub     esp, 10h
.text$mn:00002968                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000296D                 xor     eax, ebp
.text$mn:0000296F                 push    eax
.text$mn:00002970                 lea     eax, [ebp+var_C]
.text$mn:00002973                 mov     large fs:0, eax
.text$mn:00002979                 mov     [ebp+var_1C], ecx
.text$mn:0000297C                 mov     [ebp+var_18], 0
.text$mn:00002983                 mov     eax, [ebp+arg_4]
.text$mn:00002986                 push    eax             ; int
.text$mn:00002987                 call    ?_Winerror_map@std@@YAPBDH@Z ; std::_Winerror_map(int)
.text$mn:0000298C                 add     esp, 4
.text$mn:0000298F                 mov     [ebp+var_10], eax
.text$mn:00002992                 cmp     [ebp+var_10], 0
.text$mn:00002996                 jz      short loc_29A0
.text$mn:00002998                 mov     ecx, [ebp+var_10]
.text$mn:0000299B                 mov     [ebp+Str], ecx
.text$mn:0000299E                 jmp     short loc_29A7
.text$mn:000029A0 ; ---------------------------------------------------------------------------
.text$mn:000029A0
.text$mn:000029A0 loc_29A0:                               ; CODE XREF: std::_System_error_category::message(int)+42j
.text$mn:000029A0                 mov     [ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ ; "unknown error"
.text$mn:000029A7
.text$mn:000029A7 loc_29A7:                               ; CODE XREF: std::_System_error_category::message(int)+4Aj
.text$mn:000029A7                 mov     edx, [ebp+Str]
.text$mn:000029AA                 push    edx             ; Str
.text$mn:000029AB                 mov     ecx, [ebp+arg_0]
.text$mn:000029AE                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:000029B3                 mov     [ebp+var_4], 0
.text$mn:000029BA                 mov     eax, [ebp+var_18]
.text$mn:000029BD                 or      eax, 1
.text$mn:000029C0                 mov     [ebp+var_18], eax
.text$mn:000029C3                 mov     eax, [ebp+arg_0]
.text$mn:000029C6                 mov     ecx, [ebp+var_C]
.text$mn:000029C9                 mov     large fs:0, ecx
.text$mn:000029D0                 pop     ecx
.text$mn:000029D1                 mov     esp, ebp
.text$mn:000029D3                 pop     ebp
.text$mn:000029D4                 retn    8
.text$mn:000029D4 ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:000029D4
.text$mn:000029D4 ; ---------------------------------------------------------------------------
.text$mn:000029D7                 align 4
.text$mn:000029D7 _text$mn        ends
.text$mn:000029D7
.text$x:000029D8 ; ===========================================================================
.text$x:000029D8
.text$x:000029D8 ; Segment type: Pure code
.text$x:000029D8 ; Segment permissions: Read/Execute
.text$x:000029D8 _text$x         segment para public 'CODE' use32
.text$x:000029D8                 assume cs:_text$x
.text$x:000029D8                 ;org 29D8h
.text$x:000029D8 ; COMDAT (pick associative to section at 2954)
.text$x:000029D8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000029D8
.text$x:000029D8 ; =============== S U B R O U T I N E =======================================
.text$x:000029D8
.text$x:000029D8
.text$x:000029D8 __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:000029D8                                         ; DATA XREF: .xdata$x:00002DCCo
.text$x:000029D8                 mov     eax, [ebp-18h]
.text$x:000029DB                 and     eax, 1
.text$x:000029DE                 jz      $LN6_1
.text$x:000029E4                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:000029E8                 mov     ecx, [ebp+8]
.text$x:000029EB                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:000029F0 ; ---------------------------------------------------------------------------
.text$x:000029F0
.text$x:000029F0 $LN6_1:                                 ; CODE XREF: __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:000029F0                 retn
.text$x:000029F0 __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:000029F0
.text$x:000029F1
.text$x:000029F1 ; =============== S U B R O U T I N E =======================================
.text$x:000029F1
.text$x:000029F1
.text$x:000029F1 __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:000029F1                                         ; DATA XREF: std::_System_error_category::message(int)+5o
.text$x:000029F1
.text$x:000029F1 arg_4           = dword ptr  8
.text$x:000029F1
.text$x:000029F1                 mov     edx, [esp+arg_4]
.text$x:000029F5                 lea     eax, [edx+0Ch]
.text$x:000029F8                 mov     ecx, [edx-14h]
.text$x:000029FB                 xor     ecx, eax
.text$x:000029FD                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002A02                 mov     eax, offset __ehfuncinfo$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:00002A07                 jmp     ___CxxFrameHandler3
.text$x:00002A07 __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:00002A07
.text$x:00002A07 _text$x         ends
.text$x:00002A07
.text$mn:00002A0C ; ===========================================================================
.text$mn:00002A0C
.text$mn:00002A0C ; Segment type: Pure code
.text$mn:00002A0C ; Segment permissions: Read/Execute
.text$mn:00002A0C _text$mn        segment para public 'CODE' use32
.text$mn:00002A0C                 assume cs:_text$mn
.text$mn:00002A0C                 ;org 2A0Ch
.text$mn:00002A0C ; COMDAT (pick any)
.text$mn:00002A0C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002A0C
.text$mn:00002A0C ; =============== S U B R O U T I N E =======================================
.text$mn:00002A0C
.text$mn:00002A0C ; Attributes: bp-based frame
.text$mn:00002A0C
.text$mn:00002A0C ; int __cdecl std::char_traits<char>::move(void *Dst, void *Src, size_t Size)
.text$mn:00002A0C                 public ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
.text$mn:00002A0C ?move@?$char_traits@D@std@@SAPADPADPBDI@Z proc near
.text$mn:00002A0C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+6Ap
.text$mn:00002A0C
.text$mn:00002A0C var_4           = dword ptr -4
.text$mn:00002A0C Dst             = dword ptr  8
.text$mn:00002A0C Src             = dword ptr  0Ch
.text$mn:00002A0C Size            = dword ptr  10h
.text$mn:00002A0C
.text$mn:00002A0C                 push    ebp
.text$mn:00002A0D                 mov     ebp, esp
.text$mn:00002A0F                 push    ecx
.text$mn:00002A10                 cmp     [ebp+Size], 0
.text$mn:00002A14                 jnz     short loc_2A1E
.text$mn:00002A16                 mov     eax, [ebp+Dst]
.text$mn:00002A19                 mov     [ebp+var_4], eax
.text$mn:00002A1C                 jmp     short loc_2A35
.text$mn:00002A1E ; ---------------------------------------------------------------------------
.text$mn:00002A1E
.text$mn:00002A1E loc_2A1E:                               ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+8j
.text$mn:00002A1E                 mov     ecx, [ebp+Size]
.text$mn:00002A21                 push    ecx             ; Size
.text$mn:00002A22                 mov     edx, [ebp+Src]
.text$mn:00002A25                 push    edx             ; Src
.text$mn:00002A26                 mov     eax, [ebp+Dst]
.text$mn:00002A29                 push    eax             ; Dst
.text$mn:00002A2A                 call    _memmove
.text$mn:00002A2F                 add     esp, 0Ch
.text$mn:00002A32                 mov     [ebp+var_4], eax
.text$mn:00002A35
.text$mn:00002A35 loc_2A35:                               ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+10j
.text$mn:00002A35                 mov     eax, [ebp+var_4]
.text$mn:00002A38                 mov     esp, ebp
.text$mn:00002A3A                 pop     ebp
.text$mn:00002A3B                 retn
.text$mn:00002A3B ?move@?$char_traits@D@std@@SAPADPADPBDI@Z endp
.text$mn:00002A3B
.text$mn:00002A3B _text$mn        ends
.text$mn:00002A3B
.text$mn:00002A3C ; ===========================================================================
.text$mn:00002A3C
.text$mn:00002A3C ; Segment type: Pure code
.text$mn:00002A3C ; Segment permissions: Read/Execute
.text$mn:00002A3C _text$mn        segment para public 'CODE' use32
.text$mn:00002A3C                 assume cs:_text$mn
.text$mn:00002A3C                 ;org 2A3Ch
.text$mn:00002A3C ; COMDAT (pick any)
.text$mn:00002A3C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002A3C
.text$mn:00002A3C ; =============== S U B R O U T I N E =======================================
.text$mn:00002A3C
.text$mn:00002A3C ; Attributes: bp-based frame
.text$mn:00002A3C
.text$mn:00002A3C ; const char *__thiscall std::_Generic_error_category::name(std::_Generic_error_category *__hidden this)
.text$mn:00002A3C                 public ?name@_Generic_error_category@std@@UBEPBDXZ
.text$mn:00002A3C ?name@_Generic_error_category@std@@UBEPBDXZ proc near
.text$mn:00002A3C                                         ; DATA XREF: .rdata:00002EA0o
.text$mn:00002A3C
.text$mn:00002A3C var_4           = dword ptr -4
.text$mn:00002A3C
.text$mn:00002A3C                 push    ebp
.text$mn:00002A3D                 mov     ebp, esp
.text$mn:00002A3F                 push    ecx
.text$mn:00002A40                 mov     [ebp+var_4], ecx
.text$mn:00002A43                 mov     eax, offset ??_C@_07DCLBNMLN@generic?$AA@ ; "generic"
.text$mn:00002A48                 mov     esp, ebp
.text$mn:00002A4A                 pop     ebp
.text$mn:00002A4B                 retn
.text$mn:00002A4B ?name@_Generic_error_category@std@@UBEPBDXZ endp
.text$mn:00002A4B
.text$mn:00002A4B _text$mn        ends
.text$mn:00002A4B
.text$mn:00002A4C ; ===========================================================================
.text$mn:00002A4C
.text$mn:00002A4C ; Segment type: Pure code
.text$mn:00002A4C ; Segment permissions: Read/Execute
.text$mn:00002A4C _text$mn        segment para public 'CODE' use32
.text$mn:00002A4C                 assume cs:_text$mn
.text$mn:00002A4C                 ;org 2A4Ch
.text$mn:00002A4C ; COMDAT (pick any)
.text$mn:00002A4C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002A4C
.text$mn:00002A4C ; =============== S U B R O U T I N E =======================================
.text$mn:00002A4C
.text$mn:00002A4C ; Attributes: bp-based frame
.text$mn:00002A4C
.text$mn:00002A4C ; const char *__thiscall std::_Iostream_error_category::name(std::_Iostream_error_category *__hidden this)
.text$mn:00002A4C                 public ?name@_Iostream_error_category@std@@UBEPBDXZ
.text$mn:00002A4C ?name@_Iostream_error_category@std@@UBEPBDXZ proc near
.text$mn:00002A4C                                         ; DATA XREF: .rdata:00002ED4o
.text$mn:00002A4C
.text$mn:00002A4C var_4           = dword ptr -4
.text$mn:00002A4C
.text$mn:00002A4C                 push    ebp
.text$mn:00002A4D                 mov     ebp, esp
.text$mn:00002A4F                 push    ecx
.text$mn:00002A50                 mov     [ebp+var_4], ecx
.text$mn:00002A53                 mov     eax, offset ??_C@_08LLGCOLLL@iostream?$AA@ ; "iostream"
.text$mn:00002A58                 mov     esp, ebp
.text$mn:00002A5A                 pop     ebp
.text$mn:00002A5B                 retn
.text$mn:00002A5B ?name@_Iostream_error_category@std@@UBEPBDXZ endp
.text$mn:00002A5B
.text$mn:00002A5B _text$mn        ends
.text$mn:00002A5B
.text$mn:00002A5C ; ===========================================================================
.text$mn:00002A5C
.text$mn:00002A5C ; Segment type: Pure code
.text$mn:00002A5C ; Segment permissions: Read/Execute
.text$mn:00002A5C _text$mn        segment para public 'CODE' use32
.text$mn:00002A5C                 assume cs:_text$mn
.text$mn:00002A5C                 ;org 2A5Ch
.text$mn:00002A5C ; COMDAT (pick any)
.text$mn:00002A5C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002A5C
.text$mn:00002A5C ; =============== S U B R O U T I N E =======================================
.text$mn:00002A5C
.text$mn:00002A5C ; Attributes: bp-based frame
.text$mn:00002A5C
.text$mn:00002A5C ; const char *__thiscall std::_System_error_category::name(std::_System_error_category *__hidden this)
.text$mn:00002A5C                 public ?name@_System_error_category@std@@UBEPBDXZ
.text$mn:00002A5C ?name@_System_error_category@std@@UBEPBDXZ proc near
.text$mn:00002A5C                                         ; DATA XREF: .rdata:00002F14o
.text$mn:00002A5C
.text$mn:00002A5C var_4           = dword ptr -4
.text$mn:00002A5C
.text$mn:00002A5C                 push    ebp
.text$mn:00002A5D                 mov     ebp, esp
.text$mn:00002A5F                 push    ecx
.text$mn:00002A60                 mov     [ebp+var_4], ecx
.text$mn:00002A63                 mov     eax, offset ??_C@_06FHFOAHML@system?$AA@ ; "system"
.text$mn:00002A68                 mov     esp, ebp
.text$mn:00002A6A                 pop     ebp
.text$mn:00002A6B                 retn
.text$mn:00002A6B ?name@_System_error_category@std@@UBEPBDXZ endp
.text$mn:00002A6B
.text$mn:00002A6B _text$mn        ends
.text$mn:00002A6B
.text$mn:00002A6C ; ===========================================================================
.text$mn:00002A6C
.text$mn:00002A6C ; Segment type: Pure code
.text$mn:00002A6C ; Segment permissions: Read/Execute
.text$mn:00002A6C _text$mn        segment para public 'CODE' use32
.text$mn:00002A6C                 assume cs:_text$mn
.text$mn:00002A6C                 ;org 2A6Ch
.text$mn:00002A6C ; COMDAT (pick any)
.text$mn:00002A6C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002A6C
.text$mn:00002A6C ; =============== S U B R O U T I N E =======================================
.text$mn:00002A6C
.text$mn:00002A6C ; Attributes: bp-based frame
.text$mn:00002A6C
.text$mn:00002A6C ; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::size(void)const
.text$mn:00002A6C                 public ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
.text$mn:00002A6C ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
.text$mn:00002A6C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+Cp
.text$mn:00002A6C                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+21p
.text$mn:00002A6C
.text$mn:00002A6C var_4           = dword ptr -4
.text$mn:00002A6C
.text$mn:00002A6C                 push    ebp
.text$mn:00002A6D                 mov     ebp, esp
.text$mn:00002A6F                 push    ecx
.text$mn:00002A70                 mov     [ebp+var_4], ecx
.text$mn:00002A73                 mov     eax, [ebp+var_4]
.text$mn:00002A76                 mov     eax, [eax+14h]
.text$mn:00002A79                 mov     esp, ebp
.text$mn:00002A7B                 pop     ebp
.text$mn:00002A7C                 retn
.text$mn:00002A7C ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp
.text$mn:00002A7C
.text$mn:00002A7C ; ---------------------------------------------------------------------------
.text$mn:00002A7D                 align 10h
.text$mn:00002A7D _text$mn        ends
.text$mn:00002A7D
.text$mn:00002A80 ; ===========================================================================
.text$mn:00002A80
.text$mn:00002A80 ; Segment type: Pure code
.text$mn:00002A80 ; Segment permissions: Read/Execute
.text$mn:00002A80 _text$mn        segment para public 'CODE' use32
.text$mn:00002A80                 assume cs:_text$mn
.text$mn:00002A80                 ;org 2A80h
.text$mn:00002A80 ; COMDAT (pick any)
.text$mn:00002A80                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002A80
.text$mn:00002A80 ; =============== S U B R O U T I N E =======================================
.text$mn:00002A80
.text$mn:00002A80 ; Attributes: bp-based frame
.text$mn:00002A80
.text$mn:00002A80 ; const struct std::error_category *__cdecl std::system_category()
.text$mn:00002A80                 public ?system_category@std@@YAABVerror_category@1@XZ
.text$mn:00002A80 ?system_category@std@@YAABVerror_category@1@XZ proc near
.text$mn:00002A80                                         ; CODE XREF: std::_System_error_category::default_error_condition(int):loc_24ECp
.text$mn:00002A80                 push    ebp
.text$mn:00002A81                 mov     ebp, esp
.text$mn:00002A83                 mov     eax, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_System_error_category std::_Error_objects<int>::_System_object
.text$mn:00002A88                 pop     ebp
.text$mn:00002A89                 retn
.text$mn:00002A89 ?system_category@std@@YAABVerror_category@1@XZ endp
.text$mn:00002A89
.text$mn:00002A89 ; ---------------------------------------------------------------------------
.text$mn:00002A8A                 align 4
.text$mn:00002A8A _text$mn        ends
.text$mn:00002A8A
.text$mn:00002A8C ; ===========================================================================
.text$mn:00002A8C
.text$mn:00002A8C ; Segment type: Pure code
.text$mn:00002A8C ; Segment permissions: Read/Execute
.text$mn:00002A8C _text$mn        segment para public 'CODE' use32
.text$mn:00002A8C                 assume cs:_text$mn
.text$mn:00002A8C                 ;org 2A8Ch
.text$mn:00002A8C ; COMDAT (pick any)
.text$mn:00002A8C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002A8C
.text$mn:00002A8C ; =============== S U B R O U T I N E =======================================
.text$mn:00002A8C
.text$mn:00002A8C ; Attributes: bp-based frame
.text$mn:00002A8C
.text$mn:00002A8C ; int __thiscall std::error_code::value(std::error_code *__hidden this)
.text$mn:00002A8C                 public ?value@error_code@std@@QBEHXZ
.text$mn:00002A8C ?value@error_code@std@@QBEHXZ proc near ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+24p
.text$mn:00002A8C
.text$mn:00002A8C var_4           = dword ptr -4
.text$mn:00002A8C
.text$mn:00002A8C                 push    ebp
.text$mn:00002A8D                 mov     ebp, esp
.text$mn:00002A8F                 push    ecx
.text$mn:00002A90                 mov     [ebp+var_4], ecx
.text$mn:00002A93                 mov     eax, [ebp+var_4]
.text$mn:00002A96                 mov     eax, [eax]
.text$mn:00002A98                 mov     esp, ebp
.text$mn:00002A9A                 pop     ebp
.text$mn:00002A9B                 retn
.text$mn:00002A9B ?value@error_code@std@@QBEHXZ endp
.text$mn:00002A9B
.text$mn:00002A9B _text$mn        ends
.text$mn:00002A9B
.text$mn:00002A9C ; ===========================================================================
.text$mn:00002A9C
.text$mn:00002A9C ; Segment type: Pure code
.text$mn:00002A9C ; Segment permissions: Read/Execute
.text$mn:00002A9C _text$mn        segment para public 'CODE' use32
.text$mn:00002A9C                 assume cs:_text$mn
.text$mn:00002A9C                 ;org 2A9Ch
.text$mn:00002A9C ; COMDAT (pick any)
.text$mn:00002A9C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002A9C
.text$mn:00002A9C ; =============== S U B R O U T I N E =======================================
.text$mn:00002A9C
.text$mn:00002A9C ; Attributes: bp-based frame
.text$mn:00002A9C
.text$mn:00002A9C ; int __thiscall std::error_condition::value(std::error_condition *__hidden this)
.text$mn:00002A9C                 public ?value@error_condition@std@@QBEHXZ
.text$mn:00002A9C ?value@error_condition@std@@QBEHXZ proc near
.text$mn:00002A9C                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+2Cp
.text$mn:00002A9C                                         ; std::error_condition::operator==(std::error_condition const &)+36p
.text$mn:00002A9C
.text$mn:00002A9C var_4           = dword ptr -4
.text$mn:00002A9C
.text$mn:00002A9C                 push    ebp
.text$mn:00002A9D                 mov     ebp, esp
.text$mn:00002A9F                 push    ecx
.text$mn:00002AA0                 mov     [ebp+var_4], ecx
.text$mn:00002AA3                 mov     eax, [ebp+var_4]
.text$mn:00002AA6                 mov     eax, [eax]
.text$mn:00002AA8                 mov     esp, ebp
.text$mn:00002AAA                 pop     ebp
.text$mn:00002AAB                 retn
.text$mn:00002AAB ?value@error_condition@std@@QBEHXZ endp
.text$mn:00002AAB
.text$mn:00002AAB _text$mn        ends
.text$mn:00002AAB
.text$mn:00002AAC ; ===========================================================================
.text$mn:00002AAC
.text$mn:00002AAC ; Segment type: Pure code
.text$mn:00002AAC ; Segment permissions: Read/Execute
.text$mn:00002AAC _text$mn        segment para public 'CODE' use32
.text$mn:00002AAC                 assume cs:_text$mn
.text$mn:00002AAC                 ;org 2AACh
.text$mn:00002AAC ; COMDAT (pick any)
.text$mn:00002AAC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002AAC
.text$mn:00002AAC ; =============== S U B R O U T I N E =======================================
.text$mn:00002AAC
.text$mn:00002AAC ; Attributes: bp-based frame
.text$mn:00002AAC
.text$mn:00002AAC                 public _hypot
.text$mn:00002AAC _hypot          proc near
.text$mn:00002AAC
.text$mn:00002AAC var_10          = qword ptr -10h
.text$mn:00002AAC var_8           = qword ptr -8
.text$mn:00002AAC arg_0           = qword ptr  8
.text$mn:00002AAC arg_8           = qword ptr  10h
.text$mn:00002AAC
.text$mn:00002AAC                 push    ebp
.text$mn:00002AAD                 mov     ebp, esp
.text$mn:00002AAF                 sub     esp, 8
.text$mn:00002AB2                 movsd   xmm0, [ebp+arg_8]
.text$mn:00002AB7                 movsd   [esp+8+var_8], xmm0
.text$mn:00002ABC                 sub     esp, 8
.text$mn:00002ABF                 movsd   xmm0, [ebp+arg_0]
.text$mn:00002AC4                 movsd   [esp+10h+var_10], xmm0
.text$mn:00002AC9                 call    __hypot
.text$mn:00002ACE                 add     esp, 10h
.text$mn:00002AD1                 pop     ebp
.text$mn:00002AD2                 retn
.text$mn:00002AD2 _hypot          endp
.text$mn:00002AD2
.text$mn:00002AD2 ; ---------------------------------------------------------------------------
.text$mn:00002AD3                 align 4
.text$mn:00002AD3 _text$mn        ends
.text$mn:00002AD3
.xdata$x:00002AD4 ; ===========================================================================
.xdata$x:00002AD4
.xdata$x:00002AD4 ; Segment type: Pure data
.xdata$x:00002AD4 ; Segment permissions: Read
.xdata$x:00002AD4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002AD4                 assume cs:_xdata$x
.xdata$x:00002AD4                 ;org 2AD4h
.xdata$x:00002AD4 ; COMDAT (pick associative to section at 206C)
.xdata$x:00002AD4 __unwindtable$?_Orphan_all@_Container_base12@std@@QAEXXZ db 0FFh
.xdata$x:00002AD4                                         ; DATA XREF: .xdata$x:00002AE4o
.xdata$x:00002AD5                 db 0FFh
.xdata$x:00002AD6                 db 0FFh
.xdata$x:00002AD7                 db 0FFh
.xdata$x:00002AD8                 dd offset __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0
.xdata$x:00002ADC __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ db  22h ; "
.xdata$x:00002ADC                                         ; DATA XREF: __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ+11o
.xdata$x:00002ADD                 db    5
.xdata$x:00002ADE                 db  93h ; ô
.xdata$x:00002ADF                 db  19h
.xdata$x:00002AE0                 db    1
.xdata$x:00002AE1                 db    0
.xdata$x:00002AE2                 db    0
.xdata$x:00002AE3                 db    0
.xdata$x:00002AE4                 dd offset __unwindtable$?_Orphan_all@_Container_base12@std@@QAEXXZ
.xdata$x:00002AE8                 align 20h
.xdata$x:00002AE8 _xdata$x        ends
.xdata$x:00002AE8
.xdata$x:00002B00 ; ===========================================================================
.xdata$x:00002B00
.xdata$x:00002B00 ; Segment type: Pure data
.xdata$x:00002B00 ; Segment permissions: Read
.xdata$x:00002B00 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002B00                 assume cs:_xdata$x
.xdata$x:00002B00                 ;org 2B00h
.xdata$x:00002B00 ; COMDAT (pick associative to section at 13DC)
.xdata$x:00002B00 __unwindtable$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00002B00                                         ; DATA XREF: .xdata$x:00002B10o
.xdata$x:00002B01                 db 0FFh
.xdata$x:00002B02                 db 0FFh
.xdata$x:00002B03                 db 0FFh
.xdata$x:00002B04                 dd offset __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
.xdata$x:00002B08 __ehfuncinfo$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00002B08                                         ; DATA XREF: __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ+11o
.xdata$x:00002B09                 db    5
.xdata$x:00002B0A                 db  93h ; ô
.xdata$x:00002B0B                 db  19h
.xdata$x:00002B0C                 db    1
.xdata$x:00002B0D                 db    0
.xdata$x:00002B0E                 db    0
.xdata$x:00002B0F                 db    0
.xdata$x:00002B10                 dd offset __unwindtable$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.xdata$x:00002B14                 db    0
.xdata$x:00002B15                 db    0
.xdata$x:00002B16                 db    0
.xdata$x:00002B17                 db    0
.xdata$x:00002B18                 db    0
.xdata$x:00002B19                 db    0
.xdata$x:00002B1A                 db    0
.xdata$x:00002B1B                 db    0
.xdata$x:00002B1C                 db    0
.xdata$x:00002B1D                 db    0
.xdata$x:00002B1E                 db    0
.xdata$x:00002B1F                 db    0
.xdata$x:00002B20                 db    0
.xdata$x:00002B21                 db    0
.xdata$x:00002B22                 db    0
.xdata$x:00002B23                 db    0
.xdata$x:00002B24                 db    0
.xdata$x:00002B25                 db    0
.xdata$x:00002B26                 db    0
.xdata$x:00002B27                 db    0
.xdata$x:00002B28                 db    0
.xdata$x:00002B29                 db    0
.xdata$x:00002B2A                 db    0
.xdata$x:00002B2B                 db    0
.xdata$x:00002B2B _xdata$x        ends
.xdata$x:00002B2B
.xdata$x:00002B2C ; ===========================================================================
.xdata$x:00002B2C
.xdata$x:00002B2C ; Segment type: Pure data
.xdata$x:00002B2C ; Segment permissions: Read
.xdata$x:00002B2C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002B2C                 assume cs:_xdata$x
.xdata$x:00002B2C                 ;org 2B2Ch
.xdata$x:00002B2C ; COMDAT (pick associative to section at 17C0)
.xdata$x:00002B2C __unwindtable$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00002B2C                                         ; DATA XREF: .xdata$x:00002B3Co
.xdata$x:00002B2D                 db 0FFh
.xdata$x:00002B2E                 db 0FFh
.xdata$x:00002B2F                 db 0FFh
.xdata$x:00002B30                 dd offset __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
.xdata$x:00002B34 __ehfuncinfo$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00002B34                                         ; DATA XREF: __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ+11o
.xdata$x:00002B35                 db    5
.xdata$x:00002B36                 db  93h ; ô
.xdata$x:00002B37                 db  19h
.xdata$x:00002B38                 db    1
.xdata$x:00002B39                 db    0
.xdata$x:00002B3A                 db    0
.xdata$x:00002B3B                 db    0
.xdata$x:00002B3C                 dd offset __unwindtable$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.xdata$x:00002B40                 db    0
.xdata$x:00002B41                 db    0
.xdata$x:00002B42                 db    0
.xdata$x:00002B43                 db    0
.xdata$x:00002B44                 db    0
.xdata$x:00002B45                 db    0
.xdata$x:00002B46                 db    0
.xdata$x:00002B47                 db    0
.xdata$x:00002B48                 db    0
.xdata$x:00002B49                 db    0
.xdata$x:00002B4A                 db    0
.xdata$x:00002B4B                 db    0
.xdata$x:00002B4C                 db    0
.xdata$x:00002B4D                 db    0
.xdata$x:00002B4E                 db    0
.xdata$x:00002B4F                 db    0
.xdata$x:00002B50                 db    0
.xdata$x:00002B51                 db    0
.xdata$x:00002B52                 db    0
.xdata$x:00002B53                 db    0
.xdata$x:00002B54                 db    0
.xdata$x:00002B55                 db    0
.xdata$x:00002B56                 db    0
.xdata$x:00002B57                 db    0
.xdata$x:00002B57 _xdata$x        ends
.xdata$x:00002B57
.xdata$x:00002B58 ; ===========================================================================
.xdata$x:00002B58
.xdata$x:00002B58 ; Segment type: Pure data
.xdata$x:00002B58 ; Segment permissions: Read
.xdata$x:00002B58 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002B58                 assume cs:_xdata$x
.xdata$x:00002B58                 ;org 2B58h
.xdata$x:00002B58 ; COMDAT (pick associative to section at 1360)
.xdata$x:00002B58 __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z db 0FFh
.xdata$x:00002B58                                         ; DATA XREF: .xdata$x:00002B68o
.xdata$x:00002B59                 db 0FFh
.xdata$x:00002B5A                 db 0FFh
.xdata$x:00002B5B                 db 0FFh
.xdata$x:00002B5C                 dd offset __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0
.xdata$x:00002B60 __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z db  22h ; "
.xdata$x:00002B60                                         ; DATA XREF: __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z+11o
.xdata$x:00002B61                 db    5
.xdata$x:00002B62                 db  93h ; ô
.xdata$x:00002B63                 db  19h
.xdata$x:00002B64                 db    1
.xdata$x:00002B65                 db    0
.xdata$x:00002B66                 db    0
.xdata$x:00002B67                 db    0
.xdata$x:00002B68                 dd offset __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.xdata$x:00002B6C                 db    0
.xdata$x:00002B6D                 db    0
.xdata$x:00002B6E                 db    0
.xdata$x:00002B6F                 db    0
.xdata$x:00002B70                 db    0
.xdata$x:00002B71                 db    0
.xdata$x:00002B72                 db    0
.xdata$x:00002B73                 db    0
.xdata$x:00002B74                 db    0
.xdata$x:00002B75                 db    0
.xdata$x:00002B76                 db    0
.xdata$x:00002B77                 db    0
.xdata$x:00002B78                 db    0
.xdata$x:00002B79                 db    0
.xdata$x:00002B7A                 db    0
.xdata$x:00002B7B                 db    0
.xdata$x:00002B7C                 db    0
.xdata$x:00002B7D                 db    0
.xdata$x:00002B7E                 db    0
.xdata$x:00002B7F                 db    0
.xdata$x:00002B80                 db    0
.xdata$x:00002B81                 db    0
.xdata$x:00002B82                 db    0
.xdata$x:00002B83                 db    0
.xdata$x:00002B83 _xdata$x        ends
.xdata$x:00002B83
.xdata$x:00002B84 ; ===========================================================================
.xdata$x:00002B84
.xdata$x:00002B84 ; Segment type: Pure data
.xdata$x:00002B84 ; Segment permissions: Read
.xdata$x:00002B84 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002B84                 assume cs:_xdata$x
.xdata$x:00002B84                 ;org 2B84h
.xdata$x:00002B84 ; COMDAT (pick associative to section at 1748)
.xdata$x:00002B84 __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00002B84                                         ; DATA XREF: .xdata$x:00002B94o
.xdata$x:00002B85                 db 0FFh
.xdata$x:00002B86                 db 0FFh
.xdata$x:00002B87                 db 0FFh
.xdata$x:00002B88                 dd offset __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0
.xdata$x:00002B8C __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00002B8C                                         ; DATA XREF: __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:00002B8D                 db    5
.xdata$x:00002B8E                 db  93h ; ô
.xdata$x:00002B8F                 db  19h
.xdata$x:00002B90                 db    1
.xdata$x:00002B91                 db    0
.xdata$x:00002B92                 db    0
.xdata$x:00002B93                 db    0
.xdata$x:00002B94                 dd offset __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.xdata$x:00002B98                 db    0
.xdata$x:00002B99                 db    0
.xdata$x:00002B9A                 db    0
.xdata$x:00002B9B                 db    0
.xdata$x:00002B9C                 db    0
.xdata$x:00002B9D                 db    0
.xdata$x:00002B9E                 db    0
.xdata$x:00002B9F                 db    0
.xdata$x:00002BA0                 db    0
.xdata$x:00002BA1                 db    0
.xdata$x:00002BA2                 db    0
.xdata$x:00002BA3                 db    0
.xdata$x:00002BA4                 db    0
.xdata$x:00002BA5                 db    0
.xdata$x:00002BA6                 db    0
.xdata$x:00002BA7                 db    0
.xdata$x:00002BA8                 db    0
.xdata$x:00002BA9                 db    0
.xdata$x:00002BAA                 db    0
.xdata$x:00002BAB                 db    0
.xdata$x:00002BAC                 db    0
.xdata$x:00002BAD                 db    0
.xdata$x:00002BAE                 db    0
.xdata$x:00002BAF                 db    0
.xdata$x:00002BAF _xdata$x        ends
.xdata$x:00002BAF
.xdata$x:00002BB0 ; ===========================================================================
.xdata$x:00002BB0
.xdata$x:00002BB0 ; Segment type: Pure data
.xdata$x:00002BB0 ; Segment permissions: Read
.xdata$x:00002BB0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002BB0                 assume cs:_xdata$x
.xdata$x:00002BB0                 ;org 2BB0h
.xdata$x:00002BB0 ; COMDAT (pick associative to section at 149C)
.xdata$x:00002BB0 __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z db 0FFh
.xdata$x:00002BB0                                         ; DATA XREF: .xdata$x:00002BC0o
.xdata$x:00002BB1                 db 0FFh
.xdata$x:00002BB2                 db 0FFh
.xdata$x:00002BB3                 db 0FFh
.xdata$x:00002BB4                 dd offset __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0
.xdata$x:00002BB8 __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z db  22h ; "
.xdata$x:00002BB8                                         ; DATA XREF: __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z+11o
.xdata$x:00002BB9                 db    5
.xdata$x:00002BBA                 db  93h ; ô
.xdata$x:00002BBB                 db  19h
.xdata$x:00002BBC                 db    1
.xdata$x:00002BBD                 db    0
.xdata$x:00002BBE                 db    0
.xdata$x:00002BBF                 db    0
.xdata$x:00002BC0                 dd offset __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.xdata$x:00002BC4                 db    0
.xdata$x:00002BC5                 db    0
.xdata$x:00002BC6                 db    0
.xdata$x:00002BC7                 db    0
.xdata$x:00002BC8                 db    0
.xdata$x:00002BC9                 db    0
.xdata$x:00002BCA                 db    0
.xdata$x:00002BCB                 db    0
.xdata$x:00002BCC                 db    0
.xdata$x:00002BCD                 db    0
.xdata$x:00002BCE                 db    0
.xdata$x:00002BCF                 db    0
.xdata$x:00002BD0                 db    0
.xdata$x:00002BD1                 db    0
.xdata$x:00002BD2                 db    0
.xdata$x:00002BD3                 db    0
.xdata$x:00002BD4                 db    0
.xdata$x:00002BD5                 db    0
.xdata$x:00002BD6                 db    0
.xdata$x:00002BD7                 db    0
.xdata$x:00002BD8                 db    0
.xdata$x:00002BD9                 db    0
.xdata$x:00002BDA                 db    0
.xdata$x:00002BDB                 db    0
.xdata$x:00002BDB _xdata$x        ends
.xdata$x:00002BDB
.xdata$x:00002BDC ; ===========================================================================
.xdata$x:00002BDC
.xdata$x:00002BDC ; Segment type: Pure data
.xdata$x:00002BDC ; Segment permissions: Read
.xdata$x:00002BDC _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002BDC                 assume cs:_xdata$x
.xdata$x:00002BDC                 ;org 2BDCh
.xdata$x:00002BDC ; COMDAT (pick associative to section at 1830)
.xdata$x:00002BDC __unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db 0FFh
.xdata$x:00002BDC                                         ; DATA XREF: .xdata$x:00002BECo
.xdata$x:00002BDD                 db 0FFh
.xdata$x:00002BDE                 db 0FFh
.xdata$x:00002BDF                 db 0FFh
.xdata$x:00002BE0                 dd offset __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0
.xdata$x:00002BE4 __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db  22h ; "
.xdata$x:00002BE4                                         ; DATA XREF: __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ+11o
.xdata$x:00002BE5                 db    5
.xdata$x:00002BE6                 db  93h ; ô
.xdata$x:00002BE7                 db  19h
.xdata$x:00002BE8                 db    1
.xdata$x:00002BE9                 db    0
.xdata$x:00002BEA                 db    0
.xdata$x:00002BEB                 db    0
.xdata$x:00002BEC                 dd offset __unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.xdata$x:00002BF0                 db    0
.xdata$x:00002BF1                 db    0
.xdata$x:00002BF2                 db    0
.xdata$x:00002BF3                 db    0
.xdata$x:00002BF4                 db    0
.xdata$x:00002BF5                 db    0
.xdata$x:00002BF6                 db    0
.xdata$x:00002BF7                 db    0
.xdata$x:00002BF8                 db    0
.xdata$x:00002BF9                 db    0
.xdata$x:00002BFA                 db    0
.xdata$x:00002BFB                 db    0
.xdata$x:00002BFC                 db    0
.xdata$x:00002BFD                 db    0
.xdata$x:00002BFE                 db    0
.xdata$x:00002BFF                 db    0
.xdata$x:00002C00                 db    0
.xdata$x:00002C01                 db    0
.xdata$x:00002C02                 db    0
.xdata$x:00002C03                 db    0
.xdata$x:00002C04                 db    0
.xdata$x:00002C05                 db    0
.xdata$x:00002C06                 db    0
.xdata$x:00002C07                 db    0
.xdata$x:00002C07 _xdata$x        ends
.xdata$x:00002C07
.xdata$x:00002C08 ; ===========================================================================
.xdata$x:00002C08
.xdata$x:00002C08 ; Segment type: Pure data
.xdata$x:00002C08 ; Segment permissions: Read
.xdata$x:00002C08 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002C08                 assume cs:_xdata$x
.xdata$x:00002C08                 ;org 2C08h
.xdata$x:00002C08 ; COMDAT (pick associative to section at 1CC8)
.xdata$x:00002C08 __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 db    0
.xdata$x:00002C08                                         ; DATA XREF: .xdata$x:00002C90o
.xdata$x:00002C09                 db    0
.xdata$x:00002C0A                 db    0
.xdata$x:00002C0B                 db    0
.xdata$x:00002C0C                 db    0
.xdata$x:00002C0D                 db    0
.xdata$x:00002C0E                 db    0
.xdata$x:00002C0F                 db    0
.xdata$x:00002C10                 db    0
.xdata$x:00002C11                 db    0
.xdata$x:00002C12                 db    0
.xdata$x:00002C13                 db    0
.xdata$x:00002C14                 dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.xdata$x:00002C18 __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 db    0
.xdata$x:00002C18                                         ; DATA XREF: .xdata$x:00002C7Co
.xdata$x:00002C19                 db    0
.xdata$x:00002C1A                 db    0
.xdata$x:00002C1B                 db    0
.xdata$x:00002C1C                 db    0
.xdata$x:00002C1D                 db    0
.xdata$x:00002C1E                 db    0
.xdata$x:00002C1F                 db    0
.xdata$x:00002C20                 db    0
.xdata$x:00002C21                 db    0
.xdata$x:00002C22                 db    0
.xdata$x:00002C23                 db    0
.xdata$x:00002C24                 dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
.xdata$x:00002C28 __unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db 0FFh
.xdata$x:00002C28                                         ; DATA XREF: .xdata$x:00002C50o
.xdata$x:00002C29                 db 0FFh
.xdata$x:00002C2A                 db 0FFh
.xdata$x:00002C2B                 db 0FFh
.xdata$x:00002C2C                 db    0
.xdata$x:00002C2D                 db    0
.xdata$x:00002C2E                 db    0
.xdata$x:00002C2F                 db    0
.xdata$x:00002C30                 db 0FFh
.xdata$x:00002C31                 db 0FFh
.xdata$x:00002C32                 db 0FFh
.xdata$x:00002C33                 db 0FFh
.xdata$x:00002C34                 db    0
.xdata$x:00002C35                 db    0
.xdata$x:00002C36                 db    0
.xdata$x:00002C37                 db    0
.xdata$x:00002C38                 db    1
.xdata$x:00002C39                 db    0
.xdata$x:00002C3A                 db    0
.xdata$x:00002C3B                 db    0
.xdata$x:00002C3C                 db    0
.xdata$x:00002C3D                 db    0
.xdata$x:00002C3E                 db    0
.xdata$x:00002C3F                 db    0
.xdata$x:00002C40                 db    1
.xdata$x:00002C41                 db    0
.xdata$x:00002C42                 db    0
.xdata$x:00002C43                 db    0
.xdata$x:00002C44                 db    0
.xdata$x:00002C45                 db    0
.xdata$x:00002C46                 db    0
.xdata$x:00002C47                 db    0
.xdata$x:00002C48 __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db  22h ; "
.xdata$x:00002C48                                         ; DATA XREF: __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z+11o
.xdata$x:00002C49                 db    5
.xdata$x:00002C4A                 db  93h ; ô
.xdata$x:00002C4B                 db  19h
.xdata$x:00002C4C                 db    4
.xdata$x:00002C4D                 db    0
.xdata$x:00002C4E                 db    0
.xdata$x:00002C4F                 db    0
.xdata$x:00002C50                 dd offset __unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.xdata$x:00002C54                 db    2
.xdata$x:00002C55                 db    0
.xdata$x:00002C56                 db    0
.xdata$x:00002C57                 db    0
.xdata$x:00002C58                 dd offset __tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.xdata$x:00002C5C                 db    0
.xdata$x:00002C5D                 db    0
.xdata$x:00002C5E                 db    0
.xdata$x:00002C5F                 db    0
.xdata$x:00002C60                 db    0
.xdata$x:00002C61                 db    0
.xdata$x:00002C62                 db    0
.xdata$x:00002C63                 db    0
.xdata$x:00002C64                 db    0
.xdata$x:00002C65                 db    0
.xdata$x:00002C66                 db    0
.xdata$x:00002C67                 db    0
.xdata$x:00002C68                 db    0
.xdata$x:00002C69                 db    0
.xdata$x:00002C6A                 db    0
.xdata$x:00002C6B                 db    0
.xdata$x:00002C6C __tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db    2
.xdata$x:00002C6C                                         ; DATA XREF: .xdata$x:00002C58o
.xdata$x:00002C6D                 db    0
.xdata$x:00002C6E                 db    0
.xdata$x:00002C6F                 db    0
.xdata$x:00002C70                 db    2
.xdata$x:00002C71                 db    0
.xdata$x:00002C72                 db    0
.xdata$x:00002C73                 db    0
.xdata$x:00002C74                 db    3
.xdata$x:00002C75                 db    0
.xdata$x:00002C76                 db    0
.xdata$x:00002C77                 db    0
.xdata$x:00002C78                 db    1
.xdata$x:00002C79                 db    0
.xdata$x:00002C7A                 db    0
.xdata$x:00002C7B                 db    0
.xdata$x:00002C7C                 dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
.xdata$x:00002C80                 db    0
.xdata$x:00002C81                 db    0
.xdata$x:00002C82                 db    0
.xdata$x:00002C83                 db    0
.xdata$x:00002C84                 db    0
.xdata$x:00002C85                 db    0
.xdata$x:00002C86                 db    0
.xdata$x:00002C87                 db    0
.xdata$x:00002C88                 db    3
.xdata$x:00002C89                 db    0
.xdata$x:00002C8A                 db    0
.xdata$x:00002C8B                 db    0
.xdata$x:00002C8C                 db    1
.xdata$x:00002C8D                 db    0
.xdata$x:00002C8E                 db    0
.xdata$x:00002C8F                 db    0
.xdata$x:00002C90                 dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
.xdata$x:00002C90 _xdata$x        ends
.xdata$x:00002C90
.xdata$x:00002C94 ; ===========================================================================
.xdata$x:00002C94
.xdata$x:00002C94 ; Segment type: Pure data
.xdata$x:00002C94 ; Segment permissions: Read
.xdata$x:00002C94 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002C94                 assume cs:_xdata$x
.xdata$x:00002C94                 ;org 2C94h
.xdata$x:00002C94 ; COMDAT (pick associative to section at 1570)
.xdata$x:00002C94 __unwindtable$??0_Generic_error_category@std@@QAE@XZ db 0FFh
.xdata$x:00002C94                                         ; DATA XREF: .xdata$x:00002CA4o
.xdata$x:00002C95                 db 0FFh
.xdata$x:00002C96                 db 0FFh
.xdata$x:00002C97                 db 0FFh
.xdata$x:00002C98                 dd offset __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0
.xdata$x:00002C9C __ehfuncinfo$??0_Generic_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:00002C9C                                         ; DATA XREF: __ehhandler$??0_Generic_error_category@std@@QAE@XZ+11o
.xdata$x:00002C9D                 db    5
.xdata$x:00002C9E                 db  93h ; ô
.xdata$x:00002C9F                 db  19h
.xdata$x:00002CA0                 db    1
.xdata$x:00002CA1                 db    0
.xdata$x:00002CA2                 db    0
.xdata$x:00002CA3                 db    0
.xdata$x:00002CA4                 dd offset __unwindtable$??0_Generic_error_category@std@@QAE@XZ
.xdata$x:00002CA8                 align 20h
.xdata$x:00002CA8 _xdata$x        ends
.xdata$x:00002CA8
.xdata$x:00002CC0 ; ===========================================================================
.xdata$x:00002CC0
.xdata$x:00002CC0 ; Segment type: Pure data
.xdata$x:00002CC0 ; Segment permissions: Read
.xdata$x:00002CC0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002CC0                 assume cs:_xdata$x
.xdata$x:00002CC0                 ;org 2CC0h
.xdata$x:00002CC0 ; COMDAT (pick associative to section at 27D8)
.xdata$x:00002CC0 __unwindtable$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:00002CC0                                         ; DATA XREF: .xdata$x:00002CD0o
.xdata$x:00002CC1                 db 0FFh
.xdata$x:00002CC2                 db 0FFh
.xdata$x:00002CC3                 db 0FFh
.xdata$x:00002CC4                 dd offset __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:00002CC8 __ehfuncinfo$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:00002CC8                                         ; DATA XREF: __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:00002CC9                 db    5
.xdata$x:00002CCA                 db  93h ; ô
.xdata$x:00002CCB                 db  19h
.xdata$x:00002CCC                 db    1
.xdata$x:00002CCD                 db    0
.xdata$x:00002CCE                 db    0
.xdata$x:00002CCF                 db    0
.xdata$x:00002CD0                 dd offset __unwindtable$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:00002CD4                 db    0
.xdata$x:00002CD5                 db    0
.xdata$x:00002CD6                 db    0
.xdata$x:00002CD7                 db    0
.xdata$x:00002CD8                 db    0
.xdata$x:00002CD9                 db    0
.xdata$x:00002CDA                 db    0
.xdata$x:00002CDB                 db    0
.xdata$x:00002CDC                 db    0
.xdata$x:00002CDD                 db    0
.xdata$x:00002CDE                 db    0
.xdata$x:00002CDF                 db    0
.xdata$x:00002CE0                 db    0
.xdata$x:00002CE1                 db    0
.xdata$x:00002CE2                 db    0
.xdata$x:00002CE3                 db    0
.xdata$x:00002CE4                 db    0
.xdata$x:00002CE5                 db    0
.xdata$x:00002CE6                 db    0
.xdata$x:00002CE7                 db    0
.xdata$x:00002CE8                 db    0
.xdata$x:00002CE9                 db    0
.xdata$x:00002CEA                 db    0
.xdata$x:00002CEB                 db    0
.xdata$x:00002CEB _xdata$x        ends
.xdata$x:00002CEB
.xdata$x:00002CEC ; ===========================================================================
.xdata$x:00002CEC
.xdata$x:00002CEC ; Segment type: Pure data
.xdata$x:00002CEC ; Segment permissions: Read
.xdata$x:00002CEC _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002CEC                 assume cs:_xdata$x
.xdata$x:00002CEC                 ;org 2CECh
.xdata$x:00002CEC ; COMDAT (pick associative to section at 18C0)
.xdata$x:00002CEC __unwindtable$??1_Generic_error_category@std@@UAE@XZ db 0FFh
.xdata$x:00002CEC                                         ; DATA XREF: .xdata$x:00002CFCo
.xdata$x:00002CED                 db 0FFh
.xdata$x:00002CEE                 db 0FFh
.xdata$x:00002CEF                 db 0FFh
.xdata$x:00002CF0                 dd offset __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0
.xdata$x:00002CF4 __ehfuncinfo$??1_Generic_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:00002CF4                                         ; DATA XREF: __ehhandler$??1_Generic_error_category@std@@UAE@XZ+11o
.xdata$x:00002CF5                 db    5
.xdata$x:00002CF6                 db  93h ; ô
.xdata$x:00002CF7                 db  19h
.xdata$x:00002CF8                 db    1
.xdata$x:00002CF9                 db    0
.xdata$x:00002CFA                 db    0
.xdata$x:00002CFB                 db    0
.xdata$x:00002CFC                 dd offset __unwindtable$??1_Generic_error_category@std@@UAE@XZ
.xdata$x:00002D00                 db    0
.xdata$x:00002D01                 db    0
.xdata$x:00002D02                 db    0
.xdata$x:00002D03                 db    0
.xdata$x:00002D04                 db    0
.xdata$x:00002D05                 db    0
.xdata$x:00002D06                 db    0
.xdata$x:00002D07                 db    0
.xdata$x:00002D08                 db    0
.xdata$x:00002D09                 db    0
.xdata$x:00002D0A                 db    0
.xdata$x:00002D0B                 db    0
.xdata$x:00002D0C                 db    0
.xdata$x:00002D0D                 db    0
.xdata$x:00002D0E                 db    0
.xdata$x:00002D0F                 db    0
.xdata$x:00002D10                 db    0
.xdata$x:00002D11                 db    0
.xdata$x:00002D12                 db    0
.xdata$x:00002D13                 db    0
.xdata$x:00002D14                 db    0
.xdata$x:00002D15                 db    0
.xdata$x:00002D16                 db    0
.xdata$x:00002D17                 db    0
.xdata$x:00002D17 _xdata$x        ends
.xdata$x:00002D17
.xdata$x:00002D18 ; ===========================================================================
.xdata$x:00002D18
.xdata$x:00002D18 ; Segment type: Pure data
.xdata$x:00002D18 ; Segment permissions: Read
.xdata$x:00002D18 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002D18                 assume cs:_xdata$x
.xdata$x:00002D18                 ;org 2D18h
.xdata$x:00002D18 ; COMDAT (pick associative to section at 15FC)
.xdata$x:00002D18 __unwindtable$??0_Iostream_error_category@std@@QAE@XZ db 0FFh
.xdata$x:00002D18                                         ; DATA XREF: .xdata$x:00002D28o
.xdata$x:00002D19                 db 0FFh
.xdata$x:00002D1A                 db 0FFh
.xdata$x:00002D1B                 db 0FFh
.xdata$x:00002D1C                 dd offset __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0
.xdata$x:00002D20 __ehfuncinfo$??0_Iostream_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:00002D20                                         ; DATA XREF: __ehhandler$??0_Iostream_error_category@std@@QAE@XZ+11o
.xdata$x:00002D21                 db    5
.xdata$x:00002D22                 db  93h ; ô
.xdata$x:00002D23                 db  19h
.xdata$x:00002D24                 db    1
.xdata$x:00002D25                 db    0
.xdata$x:00002D26                 db    0
.xdata$x:00002D27                 db    0
.xdata$x:00002D28                 dd offset __unwindtable$??0_Iostream_error_category@std@@QAE@XZ
.xdata$x:00002D2C                 db    0
.xdata$x:00002D2D                 db    0
.xdata$x:00002D2E                 db    0
.xdata$x:00002D2F                 db    0
.xdata$x:00002D30                 db    0
.xdata$x:00002D31                 db    0
.xdata$x:00002D32                 db    0
.xdata$x:00002D33                 db    0
.xdata$x:00002D34                 db    0
.xdata$x:00002D35                 db    0
.xdata$x:00002D36                 db    0
.xdata$x:00002D37                 db    0
.xdata$x:00002D38                 db    0
.xdata$x:00002D39                 db    0
.xdata$x:00002D3A                 db    0
.xdata$x:00002D3B                 db    0
.xdata$x:00002D3C                 db    0
.xdata$x:00002D3D                 db    0
.xdata$x:00002D3E                 db    0
.xdata$x:00002D3F                 db    0
.xdata$x:00002D40                 db    0
.xdata$x:00002D41                 db    0
.xdata$x:00002D42                 db    0
.xdata$x:00002D43                 db    0
.xdata$x:00002D43 _xdata$x        ends
.xdata$x:00002D43
.xdata$x:00002D44 ; ===========================================================================
.xdata$x:00002D44
.xdata$x:00002D44 ; Segment type: Pure data
.xdata$x:00002D44 ; Segment permissions: Read
.xdata$x:00002D44 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002D44                 assume cs:_xdata$x
.xdata$x:00002D44                 ;org 2D44h
.xdata$x:00002D44 ; COMDAT (pick associative to section at 2890)
.xdata$x:00002D44 __unwindtable$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:00002D44                                         ; DATA XREF: .xdata$x:00002D54o
.xdata$x:00002D45                 db 0FFh
.xdata$x:00002D46                 db 0FFh
.xdata$x:00002D47                 db 0FFh
.xdata$x:00002D48                 dd offset __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:00002D4C __ehfuncinfo$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:00002D4C                                         ; DATA XREF: __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:00002D4D                 db    5
.xdata$x:00002D4E                 db  93h ; ô
.xdata$x:00002D4F                 db  19h
.xdata$x:00002D50                 db    1
.xdata$x:00002D51                 db    0
.xdata$x:00002D52                 db    0
.xdata$x:00002D53                 db    0
.xdata$x:00002D54                 dd offset __unwindtable$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:00002D58                 db    0
.xdata$x:00002D59                 db    0
.xdata$x:00002D5A                 db    0
.xdata$x:00002D5B                 db    0
.xdata$x:00002D5C                 db    0
.xdata$x:00002D5D                 db    0
.xdata$x:00002D5E                 db    0
.xdata$x:00002D5F                 db    0
.xdata$x:00002D60                 db    0
.xdata$x:00002D61                 db    0
.xdata$x:00002D62                 db    0
.xdata$x:00002D63                 db    0
.xdata$x:00002D64                 db    0
.xdata$x:00002D65                 db    0
.xdata$x:00002D66                 db    0
.xdata$x:00002D67                 db    0
.xdata$x:00002D68                 db    0
.xdata$x:00002D69                 db    0
.xdata$x:00002D6A                 db    0
.xdata$x:00002D6B                 db    0
.xdata$x:00002D6C                 db    0
.xdata$x:00002D6D                 db    0
.xdata$x:00002D6E                 db    0
.xdata$x:00002D6F                 db    0
.xdata$x:00002D6F _xdata$x        ends
.xdata$x:00002D6F
.xdata$x:00002D70 ; ===========================================================================
.xdata$x:00002D70
.xdata$x:00002D70 ; Segment type: Pure data
.xdata$x:00002D70 ; Segment permissions: Read
.xdata$x:00002D70 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002D70                 assume cs:_xdata$x
.xdata$x:00002D70                 ;org 2D70h
.xdata$x:00002D70 ; COMDAT (pick associative to section at 1930)
.xdata$x:00002D70 __unwindtable$??1_Iostream_error_category@std@@UAE@XZ db 0FFh
.xdata$x:00002D70                                         ; DATA XREF: .xdata$x:00002D80o
.xdata$x:00002D71                 db 0FFh
.xdata$x:00002D72                 db 0FFh
.xdata$x:00002D73                 db 0FFh
.xdata$x:00002D74                 dd offset __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0
.xdata$x:00002D78 __ehfuncinfo$??1_Iostream_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:00002D78                                         ; DATA XREF: __ehhandler$??1_Iostream_error_category@std@@UAE@XZ+11o
.xdata$x:00002D79                 db    5
.xdata$x:00002D7A                 db  93h ; ô
.xdata$x:00002D7B                 db  19h
.xdata$x:00002D7C                 db    1
.xdata$x:00002D7D                 db    0
.xdata$x:00002D7E                 db    0
.xdata$x:00002D7F                 db    0
.xdata$x:00002D80                 dd offset __unwindtable$??1_Iostream_error_category@std@@UAE@XZ
.xdata$x:00002D84                 db    0
.xdata$x:00002D85                 db    0
.xdata$x:00002D86                 db    0
.xdata$x:00002D87                 db    0
.xdata$x:00002D88                 db    0
.xdata$x:00002D89                 db    0
.xdata$x:00002D8A                 db    0
.xdata$x:00002D8B                 db    0
.xdata$x:00002D8C                 db    0
.xdata$x:00002D8D                 db    0
.xdata$x:00002D8E                 db    0
.xdata$x:00002D8F                 db    0
.xdata$x:00002D90                 db    0
.xdata$x:00002D91                 db    0
.xdata$x:00002D92                 db    0
.xdata$x:00002D93                 db    0
.xdata$x:00002D94                 db    0
.xdata$x:00002D95                 db    0
.xdata$x:00002D96                 db    0
.xdata$x:00002D97                 db    0
.xdata$x:00002D98                 db    0
.xdata$x:00002D99                 db    0
.xdata$x:00002D9A                 db    0
.xdata$x:00002D9B                 db    0
.xdata$x:00002D9B _xdata$x        ends
.xdata$x:00002D9B
.xdata$x:00002D9C ; ===========================================================================
.xdata$x:00002D9C
.xdata$x:00002D9C ; Segment type: Pure data
.xdata$x:00002D9C ; Segment permissions: Read
.xdata$x:00002D9C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002D9C                 assume cs:_xdata$x
.xdata$x:00002D9C                 ;org 2D9Ch
.xdata$x:00002D9C ; COMDAT (pick associative to section at 1678)
.xdata$x:00002D9C __unwindtable$??0_System_error_category@std@@QAE@XZ db 0FFh
.xdata$x:00002D9C                                         ; DATA XREF: .xdata$x:00002DACo
.xdata$x:00002D9D                 db 0FFh
.xdata$x:00002D9E                 db 0FFh
.xdata$x:00002D9F                 db 0FFh
.xdata$x:00002DA0                 dd offset __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0
.xdata$x:00002DA4 __ehfuncinfo$??0_System_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:00002DA4                                         ; DATA XREF: __ehhandler$??0_System_error_category@std@@QAE@XZ+11o
.xdata$x:00002DA5                 db    5
.xdata$x:00002DA6                 db  93h ; ô
.xdata$x:00002DA7                 db  19h
.xdata$x:00002DA8                 db    1
.xdata$x:00002DA9                 db    0
.xdata$x:00002DAA                 db    0
.xdata$x:00002DAB                 db    0
.xdata$x:00002DAC                 dd offset __unwindtable$??0_System_error_category@std@@QAE@XZ
.xdata$x:00002DB0                 db    0
.xdata$x:00002DB1                 db    0
.xdata$x:00002DB2                 db    0
.xdata$x:00002DB3                 db    0
.xdata$x:00002DB4                 db    0
.xdata$x:00002DB5                 db    0
.xdata$x:00002DB6                 db    0
.xdata$x:00002DB7                 db    0
.xdata$x:00002DB8                 db    0
.xdata$x:00002DB9                 db    0
.xdata$x:00002DBA                 db    0
.xdata$x:00002DBB                 db    0
.xdata$x:00002DBC                 db    0
.xdata$x:00002DBD                 db    0
.xdata$x:00002DBE                 db    0
.xdata$x:00002DBF                 db    0
.xdata$x:00002DC0                 db    0
.xdata$x:00002DC1                 db    0
.xdata$x:00002DC2                 db    0
.xdata$x:00002DC3                 db    0
.xdata$x:00002DC4                 db    0
.xdata$x:00002DC5                 db    0
.xdata$x:00002DC6                 db    0
.xdata$x:00002DC7                 db    0
.xdata$x:00002DC7 _xdata$x        ends
.xdata$x:00002DC7
.xdata$x:00002DC8 ; ===========================================================================
.xdata$x:00002DC8
.xdata$x:00002DC8 ; Segment type: Pure data
.xdata$x:00002DC8 ; Segment permissions: Read
.xdata$x:00002DC8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002DC8                 assume cs:_xdata$x
.xdata$x:00002DC8                 ;org 2DC8h
.xdata$x:00002DC8 ; COMDAT (pick associative to section at 2954)
.xdata$x:00002DC8 __unwindtable$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:00002DC8                                         ; DATA XREF: .xdata$x:00002DD8o
.xdata$x:00002DC9                 db 0FFh
.xdata$x:00002DCA                 db 0FFh
.xdata$x:00002DCB                 db 0FFh
.xdata$x:00002DCC                 dd offset __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:00002DD0 __ehfuncinfo$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:00002DD0                                         ; DATA XREF: __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:00002DD1                 db    5
.xdata$x:00002DD2                 db  93h ; ô
.xdata$x:00002DD3                 db  19h
.xdata$x:00002DD4                 db    1
.xdata$x:00002DD5                 db    0
.xdata$x:00002DD6                 db    0
.xdata$x:00002DD7                 db    0
.xdata$x:00002DD8                 dd offset __unwindtable$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:00002DDC                 db    0
.xdata$x:00002DDD                 db    0
.xdata$x:00002DDE                 db    0
.xdata$x:00002DDF                 db    0
.xdata$x:00002DE0                 db    0
.xdata$x:00002DE1                 db    0
.xdata$x:00002DE2                 db    0
.xdata$x:00002DE3                 db    0
.xdata$x:00002DE4                 db    0
.xdata$x:00002DE5                 db    0
.xdata$x:00002DE6                 db    0
.xdata$x:00002DE7                 db    0
.xdata$x:00002DE8                 db    0
.xdata$x:00002DE9                 db    0
.xdata$x:00002DEA                 db    0
.xdata$x:00002DEB                 db    0
.xdata$x:00002DEC                 db    0
.xdata$x:00002DED                 db    0
.xdata$x:00002DEE                 db    0
.xdata$x:00002DEF                 db    0
.xdata$x:00002DF0                 db    0
.xdata$x:00002DF1                 db    0
.xdata$x:00002DF2                 db    0
.xdata$x:00002DF3                 db    0
.xdata$x:00002DF3 _xdata$x        ends
.xdata$x:00002DF3
.xdata$x:00002DF4 ; ===========================================================================
.xdata$x:00002DF4
.xdata$x:00002DF4 ; Segment type: Pure data
.xdata$x:00002DF4 ; Segment permissions: Read
.xdata$x:00002DF4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002DF4                 assume cs:_xdata$x
.xdata$x:00002DF4                 ;org 2DF4h
.xdata$x:00002DF4 ; COMDAT (pick associative to section at 19A0)
.xdata$x:00002DF4 __unwindtable$??1_System_error_category@std@@UAE@XZ db 0FFh
.xdata$x:00002DF4                                         ; DATA XREF: .xdata$x:00002E04o
.xdata$x:00002DF5                 db 0FFh
.xdata$x:00002DF6                 db 0FFh
.xdata$x:00002DF7                 db 0FFh
.xdata$x:00002DF8                 dd offset __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0
.xdata$x:00002DFC __ehfuncinfo$??1_System_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:00002DFC                                         ; DATA XREF: __ehhandler$??1_System_error_category@std@@UAE@XZ+11o
.xdata$x:00002DFD                 db    5
.xdata$x:00002DFE                 db  93h ; ô
.xdata$x:00002DFF                 db  19h
.xdata$x:00002E00                 db    1
.xdata$x:00002E01                 db    0
.xdata$x:00002E02                 db    0
.xdata$x:00002E03                 db    0
.xdata$x:00002E04                 dd offset __unwindtable$??1_System_error_category@std@@UAE@XZ
.xdata$x:00002E08                 align 20h
.xdata$x:00002E08 _xdata$x        ends
.xdata$x:00002E08
.xdata$x:00002E20 ; ===========================================================================
.xdata$x:00002E20
.xdata$x:00002E20 ; Segment type: Pure data
.xdata$x:00002E20 ; Segment permissions: Read
.xdata$x:00002E20 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002E20                 assume cs:_xdata$x
.xdata$x:00002E20                 ;org 2E20h
.xdata$x:00002E20 ; COMDAT (pick associative to section at 1244)
.xdata$x:00002E20 __unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z db 0FFh
.xdata$x:00002E20                                         ; DATA XREF: .xdata$x:00002E30o
.xdata$x:00002E21                 db 0FFh
.xdata$x:00002E22                 db 0FFh
.xdata$x:00002E23                 db 0FFh
.xdata$x:00002E24                 dd offset __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0
.xdata$x:00002E28 __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z db  22h ; "
.xdata$x:00002E28                                         ; DATA XREF: __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z+11o
.xdata$x:00002E29                 db    5
.xdata$x:00002E2A                 db  93h ; ô
.xdata$x:00002E2B                 db  19h
.xdata$x:00002E2C                 db    1
.xdata$x:00002E2D                 db    0
.xdata$x:00002E2E                 db    0
.xdata$x:00002E2F                 db    0
.xdata$x:00002E30                 dd offset __unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.xdata$x:00002E34                 db    0
.xdata$x:00002E35                 db    0
.xdata$x:00002E36                 db    0
.xdata$x:00002E37                 db    0
.xdata$x:00002E38                 db    0
.xdata$x:00002E39                 db    0
.xdata$x:00002E3A                 db    0
.xdata$x:00002E3B                 db    0
.xdata$x:00002E3C                 db    0
.xdata$x:00002E3D                 db    0
.xdata$x:00002E3E                 db    0
.xdata$x:00002E3F                 db    0
.xdata$x:00002E40                 db    0
.xdata$x:00002E41                 db    0
.xdata$x:00002E42                 db    0
.xdata$x:00002E43                 db    0
.xdata$x:00002E44                 db    0
.xdata$x:00002E45                 db    0
.xdata$x:00002E46                 db    0
.xdata$x:00002E47                 db    0
.xdata$x:00002E48                 db    0
.xdata$x:00002E49                 db    0
.xdata$x:00002E4A                 db    0
.xdata$x:00002E4B                 db    0
.xdata$x:00002E4B _xdata$x        ends
.xdata$x:00002E4B
.xdata$x:00002E4C ; ===========================================================================
.xdata$x:00002E4C
.xdata$x:00002E4C ; Segment type: Pure data
.xdata$x:00002E4C ; Segment permissions: Read
.xdata$x:00002E4C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002E4C                 assume cs:_xdata$x
.xdata$x:00002E4C                 ;org 2E4Ch
.xdata$x:00002E4C ; COMDAT (pick associative to section at 1170)
.xdata$x:00002E4C __unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z db 0FFh
.xdata$x:00002E4C                                         ; DATA XREF: .xdata$x:00002E5Co
.xdata$x:00002E4D                 db 0FFh
.xdata$x:00002E4E                 db 0FFh
.xdata$x:00002E4F                 db 0FFh
.xdata$x:00002E50                 dd offset __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0
.xdata$x:00002E54 __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z db  22h ; "
.xdata$x:00002E54                                         ; DATA XREF: __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z+11o
.xdata$x:00002E55                 db    5
.xdata$x:00002E56                 db  93h ; ô
.xdata$x:00002E57                 db  19h
.xdata$x:00002E58                 db    1
.xdata$x:00002E59                 db    0
.xdata$x:00002E5A                 db    0
.xdata$x:00002E5B                 db    0
.xdata$x:00002E5C                 dd offset __unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.xdata$x:00002E60                 db    0
.xdata$x:00002E61                 db    0
.xdata$x:00002E62                 db    0
.xdata$x:00002E63                 db    0
.xdata$x:00002E64                 db    0
.xdata$x:00002E65                 db    0
.xdata$x:00002E66                 db    0
.xdata$x:00002E67                 db    0
.xdata$x:00002E68                 db    0
.xdata$x:00002E69                 db    0
.xdata$x:00002E6A                 db    0
.xdata$x:00002E6B                 db    0
.xdata$x:00002E6C                 db    0
.xdata$x:00002E6D                 db    0
.xdata$x:00002E6E                 db    0
.xdata$x:00002E6F                 db    0
.xdata$x:00002E70                 db    0
.xdata$x:00002E71                 db    0
.xdata$x:00002E72                 db    0
.xdata$x:00002E73                 db    0
.xdata$x:00002E74                 db    0
.xdata$x:00002E75                 db    0
.xdata$x:00002E76                 db    0
.xdata$x:00002E77                 db    0
.xdata$x:00002E77 _xdata$x        ends
.xdata$x:00002E77
.bss:00002E78 ; ===========================================================================
.bss:00002E78
.bss:00002E78 ; Segment type: Uninitialized
.bss:00002E78 ; Segment permissions: Read/Write
.bss:00002E78 _bss            segment byte public 'BSS' use32
.bss:00002E78                 assume cs:_bss
.bss:00002E78                 ;org 2E78h
.bss:00002E78                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:00002E78 __Tuple_alloc   db    ? ;
.bss:00002E79 ; std::_Ignore ignore
.bss:00002E79 _ignore         db    ? ;               ; DATA XREF: std::`dynamic initializer for 'ignore''(void)+3o
.bss:00002E7A _allocator_arg  db    ? ;
.bss:00002E7B _piecewise_construct db    ? ;
.bss:00002E7B _bss            ends
.bss:00002E7B
.rdata:00002E7C ; ===========================================================================
.rdata:00002E7C
.rdata:00002E7C ; Segment type: Pure data
.rdata:00002E7C ; Segment permissions: Read
.rdata:00002E7C _rdata          segment dword public 'DATA' use32
.rdata:00002E7C                 assume cs:_rdata
.rdata:00002E7C                 ;org 2E7Ch
.rdata:00002E7C ; COMDAT (pick largest)
.rdata:00002E7C                 dd offset ??_R4error_category@std@@6B@ ; const std::error_category::`RTTI Complete Object Locator'
.rdata:00002E80                 public ??_7error_category@std@@6B@
.rdata:00002E80 ; const std::error_category::`vftable'
.rdata:00002E80 ??_7error_category@std@@6B@ dd offset ??_Eerror_category@std@@UAEPAXI@Z
.rdata:00002E80                                         ; DATA XREF: std::error_category::error_category(void)+Ao
.rdata:00002E80                                         ; std::error_category::~error_category(void)+Ao
.rdata:00002E80                                         ; std::error_category::`vector deleting destructor'(uint)
.rdata:00002E84                 dd offset __purecall
.rdata:00002E88                 dd offset __purecall
.rdata:00002E8C                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:00002E90                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00002E94                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00002E94 _rdata          ends
.rdata:00002E94
.rdata:00002E98 ; ===========================================================================
.rdata:00002E98
.rdata:00002E98 ; Segment type: Pure data
.rdata:00002E98 ; Segment permissions: Read
.rdata:00002E98 _rdata          segment dword public 'DATA' use32
.rdata:00002E98                 assume cs:_rdata
.rdata:00002E98                 ;org 2E98h
.rdata:00002E98 ; COMDAT (pick largest)
.rdata:00002E98                 dd offset ??_R4_Generic_error_category@std@@6B@ ; const std::_Generic_error_category::`RTTI Complete Object Locator'
.rdata:00002E9C                 public ??_7_Generic_error_category@std@@6B@
.rdata:00002E9C ; const std::_Generic_error_category::`vftable'
.rdata:00002E9C ??_7_Generic_error_category@std@@6B@ dd offset ??_E_Generic_error_category@std@@UAEPAXI@Z
.rdata:00002E9C                                         ; DATA XREF: std::_Generic_error_category::_Generic_error_category(void)+38o
.rdata:00002E9C                                         ; std::_Generic_error_category::`vector deleting destructor'(uint)
.rdata:00002EA0                 dd offset ?name@_Generic_error_category@std@@UBEPBDXZ ; std::_Generic_error_category::name(void)
.rdata:00002EA4                 dd offset ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
.rdata:00002EA8                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:00002EAC                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00002EB0                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00002EB0 _rdata          ends
.rdata:00002EB0
.rdata:00002EB4 ; ===========================================================================
.rdata:00002EB4
.rdata:00002EB4 ; Segment type: Pure data
.rdata:00002EB4 ; Segment permissions: Read
.rdata:00002EB4 _rdata          segment dword public 'DATA' use32
.rdata:00002EB4                 assume cs:_rdata
.rdata:00002EB4                 ;org 2EB4h
.rdata:00002EB4 ; COMDAT (pick any)
.rdata:00002EB4                 public ??_C@_07DCLBNMLN@generic?$AA@
.rdata:00002EB4 ; `string'
.rdata:00002EB4 ??_C@_07DCLBNMLN@generic?$AA@ db 'generic',0
.rdata:00002EB4                                         ; DATA XREF: std::_Generic_error_category::name(void)+7o
.rdata:00002EB4 _rdata          ends
.rdata:00002EB4
.rdata:00002EBC ; ===========================================================================
.rdata:00002EBC
.rdata:00002EBC ; Segment type: Pure data
.rdata:00002EBC ; Segment permissions: Read
.rdata:00002EBC _rdata          segment dword public 'DATA' use32
.rdata:00002EBC                 assume cs:_rdata
.rdata:00002EBC                 ;org 2EBCh
.rdata:00002EBC ; COMDAT (pick any)
.rdata:00002EBC                 public ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
.rdata:00002EBC ; `string'
.rdata:00002EBC ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ db 'unknown error',0
.rdata:00002EBC                                         ; DATA XREF: std::_Generic_error_category::message(int):loc_2824o
.rdata:00002EBC                                         ; std::_System_error_category::message(int):loc_29A0o
.rdata:00002ECA                 align 4
.rdata:00002ECA _rdata          ends
.rdata:00002ECA
.rdata:00002ECC ; ===========================================================================
.rdata:00002ECC
.rdata:00002ECC ; Segment type: Pure data
.rdata:00002ECC ; Segment permissions: Read
.rdata:00002ECC _rdata          segment dword public 'DATA' use32
.rdata:00002ECC                 assume cs:_rdata
.rdata:00002ECC                 ;org 2ECCh
.rdata:00002ECC ; COMDAT (pick largest)
.rdata:00002ECC                 dd offset ??_R4_Iostream_error_category@std@@6B@ ; const std::_Iostream_error_category::`RTTI Complete Object Locator'
.rdata:00002ED0                 public ??_7_Iostream_error_category@std@@6B@
.rdata:00002ED0 ; const std::_Iostream_error_category::`vftable'
.rdata:00002ED0 ??_7_Iostream_error_category@std@@6B@ dd offset ??_E_Iostream_error_category@std@@UAEPAXI@Z
.rdata:00002ED0                                         ; DATA XREF: std::_Iostream_error_category::_Iostream_error_category(void)+38o
.rdata:00002ED0                                         ; std::_Iostream_error_category::`vector deleting destructor'(uint)
.rdata:00002ED4                 dd offset ?name@_Iostream_error_category@std@@UBEPBDXZ ; std::_Iostream_error_category::name(void)
.rdata:00002ED8                 dd offset ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message(int)
.rdata:00002EDC                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:00002EE0                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00002EE4                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00002EE4 _rdata          ends
.rdata:00002EE4
.rdata:00002EE8 ; ===========================================================================
.rdata:00002EE8
.rdata:00002EE8 ; Segment type: Pure data
.rdata:00002EE8 ; Segment permissions: Read
.rdata:00002EE8 _rdata          segment dword public 'DATA' use32
.rdata:00002EE8                 assume cs:_rdata
.rdata:00002EE8                 ;org 2EE8h
.rdata:00002EE8 ; COMDAT (pick any)
.rdata:00002EE8                 public ??_C@_08LLGCOLLL@iostream?$AA@
.rdata:00002EE8 ; `string'
.rdata:00002EE8 ??_C@_08LLGCOLLL@iostream?$AA@ db 'iostream',0
.rdata:00002EE8                                         ; DATA XREF: std::_Iostream_error_category::name(void)+7o
.rdata:00002EF1                 align 4
.rdata:00002EF1 _rdata          ends
.rdata:00002EF1
.rdata:00002EF4 ; ===========================================================================
.rdata:00002EF4
.rdata:00002EF4 ; Segment type: Pure data
.rdata:00002EF4 ; Segment permissions: Read
.rdata:00002EF4 _rdata          segment dword public 'DATA' use32
.rdata:00002EF4                 assume cs:_rdata
.rdata:00002EF4                 ;org 2EF4h
.rdata:00002EF4 ; COMDAT (pick any)
.rdata:00002EF4                 public ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
.rdata:00002EF4 ; char `string'[]
.rdata:00002EF4 ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ db 'iostream stream error',0
.rdata:00002EF4                                         ; DATA XREF: std::_Iostream_error_category::message(int)+35o
.rdata:00002F0A                 align 4
.rdata:00002F0A _rdata          ends
.rdata:00002F0A
.rdata:00002F0C ; ===========================================================================
.rdata:00002F0C
.rdata:00002F0C ; Segment type: Pure data
.rdata:00002F0C ; Segment permissions: Read
.rdata:00002F0C _rdata          segment dword public 'DATA' use32
.rdata:00002F0C                 assume cs:_rdata
.rdata:00002F0C                 ;org 2F0Ch
.rdata:00002F0C ; COMDAT (pick largest)
.rdata:00002F0C                 dd offset ??_R4_System_error_category@std@@6B@ ; const std::_System_error_category::`RTTI Complete Object Locator'
.rdata:00002F10                 public ??_7_System_error_category@std@@6B@
.rdata:00002F10 ; const std::_System_error_category::`vftable'
.rdata:00002F10 ??_7_System_error_category@std@@6B@ dd offset ??_E_System_error_category@std@@UAEPAXI@Z
.rdata:00002F10                                         ; DATA XREF: std::_System_error_category::_System_error_category(void)+38o
.rdata:00002F10                                         ; std::_System_error_category::`vector deleting destructor'(uint)
.rdata:00002F14                 dd offset ?name@_System_error_category@std@@UBEPBDXZ ; std::_System_error_category::name(void)
.rdata:00002F18                 dd offset ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message(int)
.rdata:00002F1C                 dd offset ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition(int)
.rdata:00002F20                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00002F24                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00002F24 _rdata          ends
.rdata:00002F24
.rdata:00002F28 ; ===========================================================================
.rdata:00002F28
.rdata:00002F28 ; Segment type: Pure data
.rdata:00002F28 ; Segment permissions: Read
.rdata:00002F28 _rdata          segment dword public 'DATA' use32
.rdata:00002F28                 assume cs:_rdata
.rdata:00002F28                 ;org 2F28h
.rdata:00002F28 ; COMDAT (pick any)
.rdata:00002F28                 public ??_C@_06FHFOAHML@system?$AA@
.rdata:00002F28 ; `string'
.rdata:00002F28 ??_C@_06FHFOAHML@system?$AA@ db 'system',0
.rdata:00002F28                                         ; DATA XREF: std::_System_error_category::name(void)+7o
.rdata:00002F2F                 align 10h
.rdata:00002F2F _rdata          ends
.rdata:00002F2F
.bss:00002F30 ; ===========================================================================
.bss:00002F30
.bss:00002F30 ; Segment type: Uninitialized
.bss:00002F30 ; Segment permissions: Read/Write
.bss:00002F30 _bss            segment dword public 'BSS' use32
.bss:00002F30                 assume cs:_bss
.bss:00002F30                 ;org 2F30h
.bss:00002F30 ; COMDAT (pick any)
.bss:00002F30                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:00002F30                 public ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
.bss:00002F30 ; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
.bss:00002F30 ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A db    ? ;
.bss:00002F30                                         ; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o
.bss:00002F30                                         ; `dynamic atexit destructor for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o ...
.bss:00002F31                 db    ? ;
.bss:00002F32                 db    ? ;
.bss:00002F33                 db    ? ;
.bss:00002F33 _bss            ends
.bss:00002F33
.bss:00002F34 ; ===========================================================================
.bss:00002F34
.bss:00002F34 ; Segment type: Uninitialized
.bss:00002F34 ; Segment permissions: Read/Write
.bss:00002F34 _bss            segment dword public 'BSS' use32
.bss:00002F34                 assume cs:_bss
.bss:00002F34                 ;org 2F34h
.bss:00002F34 ; COMDAT (pick any)
.bss:00002F34                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:00002F34                 public ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
.bss:00002F34 ; std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object
.bss:00002F34 ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A db    ? ;
.bss:00002F34                                         ; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
.bss:00002F34                                         ; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
.bss:00002F35                 db    ? ;
.bss:00002F36                 db    ? ;
.bss:00002F37                 db    ? ;
.bss:00002F37 _bss            ends
.bss:00002F37
.bss:00002F38 ; ===========================================================================
.bss:00002F38
.bss:00002F38 ; Segment type: Uninitialized
.bss:00002F38 ; Segment permissions: Read/Write
.bss:00002F38 _bss            segment dword public 'BSS' use32
.bss:00002F38                 assume cs:_bss
.bss:00002F38                 ;org 2F38h
.bss:00002F38 ; COMDAT (pick any)
.bss:00002F38                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:00002F38                 public ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
.bss:00002F38 ; std::_System_error_category std::_Error_objects<int>::_System_object
.bss:00002F38 ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A db    ? ;
.bss:00002F38                                         ; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o
.bss:00002F38                                         ; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o ...
.bss:00002F39                 db    ? ;
.bss:00002F3A                 db    ? ;
.bss:00002F3B                 db    ? ;
.bss:00002F3B _bss            ends
.bss:00002F3B
.bss:00002F3C ; ===========================================================================
.bss:00002F3C
.bss:00002F3C ; Segment type: Uninitialized
.bss:00002F3C ; Segment permissions: Read/Write
.bss:00002F3C _bss            segment dword public 'BSS' use32
.bss:00002F3C                 assume cs:_bss
.bss:00002F3C                 ;org 2F3Ch
.bss:00002F3C ; COMDAT (pick any)
.bss:00002F3C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:00002F3C                 public ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
.bss:00002F3C ; std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id
.bss:00002F3C ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A db    ? ;
.bss:00002F3C                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)+5o
.bss:00002F3D                 db    ? ;
.bss:00002F3E                 db    ? ;
.bss:00002F3F                 db    ? ;
.bss:00002F3F _bss            ends
.bss:00002F3F
.bss:00002F40 ; ===========================================================================
.bss:00002F40
.bss:00002F40 ; Segment type: Uninitialized
.bss:00002F40 ; Segment permissions: Read/Write
.bss:00002F40 _bss            segment dword public 'BSS' use32
.bss:00002F40                 assume cs:_bss
.bss:00002F40                 ;org 2F40h
.bss:00002F40 ; COMDAT (pick any)
.bss:00002F40                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:00002F40                 public ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
.bss:00002F40 ; std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id
.bss:00002F40 ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A db    ? ;
.bss:00002F40                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)+5o
.bss:00002F41                 db    ? ;
.bss:00002F42                 db    ? ;
.bss:00002F43                 db    ? ;
.bss:00002F43 _bss            ends
.bss:00002F43
.rdata:00002F44 ; ===========================================================================
.rdata:00002F44
.rdata:00002F44 ; Segment type: Pure data
.rdata:00002F44 ; Segment permissions: Read
.rdata:00002F44 _rdata          segment dword public 'DATA' use32
.rdata:00002F44                 assume cs:_rdata
.rdata:00002F44                 ;org 2F44h
.rdata:00002F44 ; COMDAT (pick any)
.rdata:00002F44                 public ??_C@_11LOCGONAA@?$AA?$AA@
.rdata:00002F44 ; const WCHAR `string'
.rdata:00002F44 ??_C@_11LOCGONAA@?$AA?$AA@ dw 0         ; DATA XREF: GoToLineDlg::cleanLineEdit(void)+7o
.rdata:00002F46                 align 4
.rdata:00002F46 _rdata          ends
.rdata:00002F46
.rdata:00002F48 ; ===========================================================================
.rdata:00002F48
.rdata:00002F48 ; Segment type: Pure data
.rdata:00002F48 ; Segment permissions: Read
.rdata:00002F48 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00002F48 _rdata          segment para public 'DATA' use32
.rdata:00002F48                 assume cs:_rdata
.rdata:00002F48                 ;org 2F48h
.rdata:00002F48 ; COMDAT (pick any)
.rdata:00002F48                 public ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:00002F48 ; wchar_t `string'
.rdata:00002F48 ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:00002F48                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+Co
.rdata:00002F48                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+12o
.rdata:00002F48                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:00002F48                 unicode 0, <clude\xstring>,0
.rdata:00002FD6                 align 4
.rdata:00002FD6 _rdata          ends
.rdata:00002FD6
.bss:00002FD8 ; ===========================================================================
.bss:00002FD8
.bss:00002FD8 ; Segment type: Uninitialized
.bss:00002FD8 ; Segment permissions: Read/Write
.bss:00002FD8 _bss            segment dword public 'BSS' use32
.bss:00002FD8                 assume cs:_bss
.bss:00002FD8                 ;org 2FD8h
.bss:00002FD8 ; COMDAT (pick any)
.bss:00002FD8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:00002FD8                 public ?id@?$numpunct@D@std@@2V0locale@2@A
.bss:00002FD8 ; std::locale::id std::numpunct<char>::id
.bss:00002FD8 ?id@?$numpunct@D@std@@2V0locale@2@A db    ? ;
.bss:00002FD8                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::numpunct<char>::id''(void)+5o
.bss:00002FD9                 db    ? ;
.bss:00002FDA                 db    ? ;
.bss:00002FDB                 db    ? ;
.bss:00002FDB _bss            ends
.bss:00002FDB
.bss:00002FDC ; ===========================================================================
.bss:00002FDC
.bss:00002FDC ; Segment type: Uninitialized
.bss:00002FDC ; Segment permissions: Read/Write
.bss:00002FDC _bss            segment dword public 'BSS' use32
.bss:00002FDC                 assume cs:_bss
.bss:00002FDC                 ;org 2FDCh
.bss:00002FDC ; COMDAT (pick any)
.bss:00002FDC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:00002FDC                 public ?id@?$numpunct@_W@std@@2V0locale@2@A
.bss:00002FDC ; std::locale::id std::numpunct<wchar_t>::id
.bss:00002FDC ?id@?$numpunct@_W@std@@2V0locale@2@A db    ? ;
.bss:00002FDC                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::numpunct<wchar_t>::id''(void)+5o
.bss:00002FDD                 db    ? ;
.bss:00002FDE                 db    ? ;
.bss:00002FDF                 db    ? ;
.bss:00002FDF _bss            ends
.bss:00002FDF
.rdata:00002FE0 ; ===========================================================================
.rdata:00002FE0
.rdata:00002FE0 ; Segment type: Pure data
.rdata:00002FE0 ; Segment permissions: Read
.rdata:00002FE0 _rdata          segment dword public 'DATA' use32
.rdata:00002FE0                 assume cs:_rdata
.rdata:00002FE0                 ;org 2FE0h
.rdata:00002FE0 ; COMDAT (pick any)
.rdata:00002FE0                 public ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
.rdata:00002FE0 ; char `string'[]
.rdata:00002FE0 ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ db 'string too long',0
.rdata:00002FE0                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+7o
.rdata:00002FE0 _rdata          ends
.rdata:00002FE0
.rdata:00002FF0 ; ===========================================================================
.rdata:00002FF0
.rdata:00002FF0 ; Segment type: Pure data
.rdata:00002FF0 ; Segment permissions: Read
.rdata:00002FF0 _rdata          segment dword public 'DATA' use32
.rdata:00002FF0                 assume cs:_rdata
.rdata:00002FF0                 ;org 2FF0h
.rdata:00002FF0 ; COMDAT (pick any)
.rdata:00002FF0                 public ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
.rdata:00002FF0 ; char `string'[]
.rdata:00002FF0 ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ db 'invalid string position',0
.rdata:00002FF0                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+7o
.rdata:00002FF0 _rdata          ends
.rdata:00002FF0
.rdata:00003008 ; ===========================================================================
.rdata:00003008
.rdata:00003008 ; Segment type: Pure data
.rdata:00003008 ; Segment permissions: Read
.rdata:00003008 _rdata          segment dword public 'DATA' use32
.rdata:00003008                 assume cs:_rdata
.rdata:00003008                 ;org 3008h
.rdata:00003008 ; COMDAT (pick any)
.rdata:00003008                 public ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
.rdata:00003008 ; wchar_t `string'
.rdata:00003008 ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@:
.rdata:00003008                                         ; DATA XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+11o
.rdata:00003008                 unicode 0, <invalid null pointer>,0
.rdata:00003032                 align 4
.rdata:00003032 _rdata          ends
.rdata:00003032
.rdata$r:00003034 ; ===========================================================================
.rdata$r:00003034
.rdata$r:00003034 ; Segment type: Pure data
.rdata$r:00003034 ; Segment permissions: Read
.rdata$r:00003034 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003034                 assume cs:_rdata$r
.rdata$r:00003034                 ;org 3034h
.rdata$r:00003034 ; COMDAT (pick any)
.rdata$r:00003034                 public ??_R4error_category@std@@6B@
.rdata$r:00003034 ; const std::error_category::`RTTI Complete Object Locator'
.rdata$r:00003034 ??_R4error_category@std@@6B@ db    0    ; DATA XREF: .rdata:00002E7Co
.rdata$r:00003035                 db    0
.rdata$r:00003036                 db    0
.rdata$r:00003037                 db    0
.rdata$r:00003038                 db    0
.rdata$r:00003039                 db    0
.rdata$r:0000303A                 db    0
.rdata$r:0000303B                 db    0
.rdata$r:0000303C                 db    0
.rdata$r:0000303D                 db    0
.rdata$r:0000303E                 db    0
.rdata$r:0000303F                 db    0
.rdata$r:00003040                 dd offset ??_R0?AVerror_category@std@@@8 ; std::error_category `RTTI Type Descriptor'
.rdata$r:00003044                 dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00003044 _rdata$r        ends
.rdata$r:00003044
.data$r:00003048 ; ===========================================================================
.data$r:00003048
.data$r:00003048 ; Segment type: Pure data
.data$r:00003048 ; Segment permissions: Read/Write
.data$r:00003048 _data$r         segment dword public 'DATA' use32
.data$r:00003048                 assume cs:_data$r
.data$r:00003048                 ;org 3048h
.data$r:00003048 ; COMDAT (pick any)
.data$r:00003048                 public ??_R0?AVerror_category@std@@@8
.data$r:00003048 ; class std::error_category `RTTI Type Descriptor'
.data$r:00003048 ??_R0?AVerror_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00003048                                         ; DATA XREF: .rdata$r:00003040o
.data$r:00003048                                         ; .rdata$r:std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00003048                                         ; const type_info::`vftable'
.data$r:0000304C                 align 10h
.data$r:00003050 a_?averror_cate db '.?AVerror_category@std@@',0
.data$r:00003069                 align 4
.data$r:00003069 _data$r         ends
.data$r:00003069
.rdata$r:0000306C ; ===========================================================================
.rdata$r:0000306C
.rdata$r:0000306C ; Segment type: Pure data
.rdata$r:0000306C ; Segment permissions: Read
.rdata$r:0000306C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000306C                 assume cs:_rdata$r
.rdata$r:0000306C                 ;org 306Ch
.rdata$r:0000306C ; COMDAT (pick any)
.rdata$r:0000306C                 public ??_R3error_category@std@@8
.rdata$r:0000306C ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000306C ??_R3error_category@std@@8 db    0      ; DATA XREF: .rdata$r:00003044o
.rdata$r:0000306C                                         ; .rdata$r:0000309Co
.rdata$r:0000306D                 db    0
.rdata$r:0000306E                 db    0
.rdata$r:0000306F                 db    0
.rdata$r:00003070                 db    0
.rdata$r:00003071                 db    0
.rdata$r:00003072                 db    0
.rdata$r:00003073                 db    0
.rdata$r:00003074                 db    1
.rdata$r:00003075                 db    0
.rdata$r:00003076                 db    0
.rdata$r:00003077                 db    0
.rdata$r:00003078                 dd offset ??_R2error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
.rdata$r:00003078 _rdata$r        ends
.rdata$r:00003078
.rdata$r:0000307C ; ===========================================================================
.rdata$r:0000307C
.rdata$r:0000307C ; Segment type: Pure data
.rdata$r:0000307C ; Segment permissions: Read
.rdata$r:0000307C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000307C                 assume cs:_rdata$r
.rdata$r:0000307C                 ;org 307Ch
.rdata$r:0000307C ; COMDAT (pick any)
.rdata$r:0000307C                 public ??_R2error_category@std@@8
.rdata$r:0000307C ; std::error_category::`RTTI Base Class Array'
.rdata$r:0000307C ??_R2error_category@std@@8 dd offset ??_R1A@?0A@EA@error_category@std@@8
.rdata$r:0000307C                                         ; DATA XREF: .rdata$r:00003078o
.rdata$r:0000307C                                         ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00003080                 db    0
.rdata$r:00003081                 align 4
.rdata$r:00003081 _rdata$r        ends
.rdata$r:00003081
.rdata$r:00003084 ; ===========================================================================
.rdata$r:00003084
.rdata$r:00003084 ; Segment type: Pure data
.rdata$r:00003084 ; Segment permissions: Read
.rdata$r:00003084 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003084                 assume cs:_rdata$r
.rdata$r:00003084                 ;org 3084h
.rdata$r:00003084 ; COMDAT (pick any)
.rdata$r:00003084                 public ??_R1A@?0A@EA@error_category@std@@8
.rdata$r:00003084 ; std::error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00003084 ??_R1A@?0A@EA@error_category@std@@8 dd offset ??_R0?AVerror_category@std@@@8
.rdata$r:00003084                                         ; DATA XREF: .rdata$r:std::error_category::`RTTI Base Class Array'o
.rdata$r:00003084                                         ; .rdata$r:000030F4o ...
.rdata$r:00003084                                         ; std::error_category `RTTI Type Descriptor'
.rdata$r:00003088                 align 10h
.rdata$r:00003090                 db 0FFh
.rdata$r:00003091                 db 0FFh
.rdata$r:00003092                 db 0FFh
.rdata$r:00003093                 db 0FFh
.rdata$r:00003094                 db    0
.rdata$r:00003095                 db    0
.rdata$r:00003096                 db    0
.rdata$r:00003097                 db    0
.rdata$r:00003098                 db  40h ; @
.rdata$r:00003099                 db    0
.rdata$r:0000309A                 db    0
.rdata$r:0000309B                 db    0
.rdata$r:0000309C                 dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000309C _rdata$r        ends
.rdata$r:0000309C
.rdata$r:000030A0 ; ===========================================================================
.rdata$r:000030A0
.rdata$r:000030A0 ; Segment type: Pure data
.rdata$r:000030A0 ; Segment permissions: Read
.rdata$r:000030A0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000030A0                 assume cs:_rdata$r
.rdata$r:000030A0                 ;org 30A0h
.rdata$r:000030A0 ; COMDAT (pick any)
.rdata$r:000030A0                 public ??_R4_Generic_error_category@std@@6B@
.rdata$r:000030A0 ; const std::_Generic_error_category::`RTTI Complete Object Locator'
.rdata$r:000030A0 ??_R4_Generic_error_category@std@@6B@ db    0
.rdata$r:000030A0                                         ; DATA XREF: .rdata:00002E98o
.rdata$r:000030A1                 db    0
.rdata$r:000030A2                 db    0
.rdata$r:000030A3                 db    0
.rdata$r:000030A4                 db    0
.rdata$r:000030A5                 db    0
.rdata$r:000030A6                 db    0
.rdata$r:000030A7                 db    0
.rdata$r:000030A8                 db    0
.rdata$r:000030A9                 db    0
.rdata$r:000030AA                 db    0
.rdata$r:000030AB                 db    0
.rdata$r:000030AC                 dd offset ??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category `RTTI Type Descriptor'
.rdata$r:000030B0                 dd offset ??_R3_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000030B0 _rdata$r        ends
.rdata$r:000030B0
.data$r:000030B4 ; ===========================================================================
.data$r:000030B4
.data$r:000030B4 ; Segment type: Pure data
.data$r:000030B4 ; Segment permissions: Read/Write
.data$r:000030B4 _data$r         segment dword public 'DATA' use32
.data$r:000030B4                 assume cs:_data$r
.data$r:000030B4                 ;org 30B4h
.data$r:000030B4 ; COMDAT (pick any)
.data$r:000030B4                 public ??_R0?AV_Generic_error_category@std@@@8
.data$r:000030B4 ; class std::_Generic_error_category `RTTI Type Descriptor'
.data$r:000030B4 ??_R0?AV_Generic_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:000030B4                                         ; DATA XREF: .rdata$r:000030ACo
.data$r:000030B4                                         ; .rdata$r:std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:000030B4                                         ; const type_info::`vftable'
.data$r:000030B8                 db    0
.data$r:000030B9                 db    0
.data$r:000030BA                 db    0
.data$r:000030BB                 db    0
.data$r:000030BC                 db  2Eh ; .
.data$r:000030BD                 db  3Fh ; ?
.data$r:000030BE                 db  41h ; A
.data$r:000030BF                 db  56h ; V
.data$r:000030C0                 db  5Fh ; _
.data$r:000030C1                 db  47h ; G
.data$r:000030C2                 db  65h ; e
.data$r:000030C3                 db  6Eh ; n
.data$r:000030C4                 db  65h ; e
.data$r:000030C5                 db  72h ; r
.data$r:000030C6                 db  69h ; i
.data$r:000030C7                 db  63h ; c
.data$r:000030C8                 db  5Fh ; _
.data$r:000030C9                 db  65h ; e
.data$r:000030CA                 db  72h ; r
.data$r:000030CB                 db  72h ; r
.data$r:000030CC                 db  6Fh ; o
.data$r:000030CD                 db  72h ; r
.data$r:000030CE                 db  5Fh ; _
.data$r:000030CF                 db  63h ; c
.data$r:000030D0                 db  61h ; a
.data$r:000030D1                 db  74h ; t
.data$r:000030D2                 db  65h ; e
.data$r:000030D3                 db  67h ; g
.data$r:000030D4                 db  6Fh ; o
.data$r:000030D5                 db  72h ; r
.data$r:000030D6                 db  79h ; y
.data$r:000030D7                 db  40h ; @
.data$r:000030D8                 db  73h ; s
.data$r:000030D9                 db  74h ; t
.data$r:000030DA                 db  64h ; d
.data$r:000030DB                 db  40h ; @
.data$r:000030DC                 db  40h ; @
.data$r:000030DD                 db    0
.data$r:000030DE                 align 10h
.data$r:000030DE _data$r         ends
.data$r:000030DE
.rdata$r:000030E0 ; ===========================================================================
.rdata$r:000030E0
.rdata$r:000030E0 ; Segment type: Pure data
.rdata$r:000030E0 ; Segment permissions: Read
.rdata$r:000030E0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000030E0                 assume cs:_rdata$r
.rdata$r:000030E0                 ;org 30E0h
.rdata$r:000030E0 ; COMDAT (pick any)
.rdata$r:000030E0                 public ??_R3_Generic_error_category@std@@8
.rdata$r:000030E0 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000030E0 ??_R3_Generic_error_category@std@@8 db    0
.rdata$r:000030E0                                         ; DATA XREF: .rdata$r:000030B0o
.rdata$r:000030E0                                         ; .rdata$r:00003114o
.rdata$r:000030E1                 db    0
.rdata$r:000030E2                 db    0
.rdata$r:000030E3                 db    0
.rdata$r:000030E4                 db    0
.rdata$r:000030E5                 db    0
.rdata$r:000030E6                 db    0
.rdata$r:000030E7                 db    0
.rdata$r:000030E8                 db    2
.rdata$r:000030E9                 db    0
.rdata$r:000030EA                 db    0
.rdata$r:000030EB                 db    0
.rdata$r:000030EC                 dd offset ??_R2_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
.rdata$r:000030EC _rdata$r        ends
.rdata$r:000030EC
.rdata$r:000030F0 ; ===========================================================================
.rdata$r:000030F0
.rdata$r:000030F0 ; Segment type: Pure data
.rdata$r:000030F0 ; Segment permissions: Read
.rdata$r:000030F0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000030F0                 assume cs:_rdata$r
.rdata$r:000030F0                 ;org 30F0h
.rdata$r:000030F0 ; COMDAT (pick any)
.rdata$r:000030F0                 public ??_R2_Generic_error_category@std@@8
.rdata$r:000030F0 ; std::_Generic_error_category::`RTTI Base Class Array'
.rdata$r:000030F0 ??_R2_Generic_error_category@std@@8 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8
.rdata$r:000030F0                                         ; DATA XREF: .rdata$r:000030ECo
.rdata$r:000030F0                                         ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000030F4                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000030F8                 db    0
.rdata$r:000030F9                 align 4
.rdata$r:000030F9 _rdata$r        ends
.rdata$r:000030F9
.rdata$r:000030FC ; ===========================================================================
.rdata$r:000030FC
.rdata$r:000030FC ; Segment type: Pure data
.rdata$r:000030FC ; Segment permissions: Read
.rdata$r:000030FC _rdata$r        segment dword public 'DATA' use32
.rdata$r:000030FC                 assume cs:_rdata$r
.rdata$r:000030FC                 ;org 30FCh
.rdata$r:000030FC ; COMDAT (pick any)
.rdata$r:000030FC                 public ??_R1A@?0A@EA@_Generic_error_category@std@@8
.rdata$r:000030FC ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:000030FC ??_R1A@?0A@EA@_Generic_error_category@std@@8 dd offset ??_R0?AV_Generic_error_category@std@@@8
.rdata$r:000030FC                                         ; DATA XREF: .rdata$r:std::_Generic_error_category::`RTTI Base Class Array'o
.rdata$r:000030FC                                         ; .rdata$r:0000316Co ...
.rdata$r:000030FC                                         ; std::_Generic_error_category `RTTI Type Descriptor'
.rdata$r:00003100                 db    1
.rdata$r:00003101                 db    0
.rdata$r:00003102                 db    0
.rdata$r:00003103                 db    0
.rdata$r:00003104                 db    0
.rdata$r:00003105                 db    0
.rdata$r:00003106                 db    0
.rdata$r:00003107                 db    0
.rdata$r:00003108                 db 0FFh
.rdata$r:00003109                 db 0FFh
.rdata$r:0000310A                 db 0FFh
.rdata$r:0000310B                 db 0FFh
.rdata$r:0000310C                 db    0
.rdata$r:0000310D                 db    0
.rdata$r:0000310E                 db    0
.rdata$r:0000310F                 db    0
.rdata$r:00003110                 db  40h ; @
.rdata$r:00003111                 db    0
.rdata$r:00003112                 db    0
.rdata$r:00003113                 db    0
.rdata$r:00003114                 dd offset ??_R3_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00003114 _rdata$r        ends
.rdata$r:00003114
.rdata$r:00003118 ; ===========================================================================
.rdata$r:00003118
.rdata$r:00003118 ; Segment type: Pure data
.rdata$r:00003118 ; Segment permissions: Read
.rdata$r:00003118 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003118                 assume cs:_rdata$r
.rdata$r:00003118                 ;org 3118h
.rdata$r:00003118 ; COMDAT (pick any)
.rdata$r:00003118                 public ??_R4_Iostream_error_category@std@@6B@
.rdata$r:00003118 ; const std::_Iostream_error_category::`RTTI Complete Object Locator'
.rdata$r:00003118 ??_R4_Iostream_error_category@std@@6B@ db    0
.rdata$r:00003118                                         ; DATA XREF: .rdata:00002ECCo
.rdata$r:00003119                 db    0
.rdata$r:0000311A                 db    0
.rdata$r:0000311B                 db    0
.rdata$r:0000311C                 db    0
.rdata$r:0000311D                 db    0
.rdata$r:0000311E                 db    0
.rdata$r:0000311F                 db    0
.rdata$r:00003120                 db    0
.rdata$r:00003121                 db    0
.rdata$r:00003122                 db    0
.rdata$r:00003123                 db    0
.rdata$r:00003124                 dd offset ??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category `RTTI Type Descriptor'
.rdata$r:00003128                 dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00003128 _rdata$r        ends
.rdata$r:00003128
.data$r:0000312C ; ===========================================================================
.data$r:0000312C
.data$r:0000312C ; Segment type: Pure data
.data$r:0000312C ; Segment permissions: Read/Write
.data$r:0000312C _data$r         segment dword public 'DATA' use32
.data$r:0000312C                 assume cs:_data$r
.data$r:0000312C                 ;org 312Ch
.data$r:0000312C ; COMDAT (pick any)
.data$r:0000312C                 public ??_R0?AV_Iostream_error_category@std@@@8
.data$r:0000312C ; class std::_Iostream_error_category `RTTI Type Descriptor'
.data$r:0000312C ??_R0?AV_Iostream_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:0000312C                                         ; DATA XREF: .rdata$r:00003124o
.data$r:0000312C                                         ; .rdata$r:std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:0000312C                                         ; const type_info::`vftable'
.data$r:00003130                 db    0
.data$r:00003131                 db    0
.data$r:00003132                 db    0
.data$r:00003133                 db    0
.data$r:00003134                 db  2Eh ; .
.data$r:00003135                 db  3Fh ; ?
.data$r:00003136                 db  41h ; A
.data$r:00003137                 db  56h ; V
.data$r:00003138                 db  5Fh ; _
.data$r:00003139                 db  49h ; I
.data$r:0000313A                 db  6Fh ; o
.data$r:0000313B                 db  73h ; s
.data$r:0000313C                 db  74h ; t
.data$r:0000313D                 db  72h ; r
.data$r:0000313E                 db  65h ; e
.data$r:0000313F                 db  61h ; a
.data$r:00003140                 db  6Dh ; m
.data$r:00003141                 db  5Fh ; _
.data$r:00003142                 db  65h ; e
.data$r:00003143                 db  72h ; r
.data$r:00003144                 db  72h ; r
.data$r:00003145                 db  6Fh ; o
.data$r:00003146                 db  72h ; r
.data$r:00003147                 db  5Fh ; _
.data$r:00003148                 db  63h ; c
.data$r:00003149                 db  61h ; a
.data$r:0000314A                 db  74h ; t
.data$r:0000314B                 db  65h ; e
.data$r:0000314C                 db  67h ; g
.data$r:0000314D                 db  6Fh ; o
.data$r:0000314E                 db  72h ; r
.data$r:0000314F                 db  79h ; y
.data$r:00003150                 db  40h ; @
.data$r:00003151                 db  73h ; s
.data$r:00003152                 db  74h ; t
.data$r:00003153                 db  64h ; d
.data$r:00003154                 db  40h ; @
.data$r:00003155                 db  40h ; @
.data$r:00003156                 db    0
.data$r:00003157                 align 4
.data$r:00003157 _data$r         ends
.data$r:00003157
.rdata$r:00003158 ; ===========================================================================
.rdata$r:00003158
.rdata$r:00003158 ; Segment type: Pure data
.rdata$r:00003158 ; Segment permissions: Read
.rdata$r:00003158 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003158                 assume cs:_rdata$r
.rdata$r:00003158                 ;org 3158h
.rdata$r:00003158 ; COMDAT (pick any)
.rdata$r:00003158                 public ??_R3_Iostream_error_category@std@@8
.rdata$r:00003158 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00003158 ??_R3_Iostream_error_category@std@@8 db    0
.rdata$r:00003158                                         ; DATA XREF: .rdata$r:00003128o
.rdata$r:00003158                                         ; .rdata$r:00003190o
.rdata$r:00003159                 db    0
.rdata$r:0000315A                 db    0
.rdata$r:0000315B                 db    0
.rdata$r:0000315C                 db    0
.rdata$r:0000315D                 db    0
.rdata$r:0000315E                 db    0
.rdata$r:0000315F                 db    0
.rdata$r:00003160                 db    3
.rdata$r:00003161                 db    0
.rdata$r:00003162                 db    0
.rdata$r:00003163                 db    0
.rdata$r:00003164                 dd offset ??_R2_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
.rdata$r:00003164 _rdata$r        ends
.rdata$r:00003164
.rdata$r:00003168 ; ===========================================================================
.rdata$r:00003168
.rdata$r:00003168 ; Segment type: Pure data
.rdata$r:00003168 ; Segment permissions: Read
.rdata$r:00003168 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003168                 assume cs:_rdata$r
.rdata$r:00003168                 ;org 3168h
.rdata$r:00003168 ; COMDAT (pick any)
.rdata$r:00003168                 public ??_R2_Iostream_error_category@std@@8
.rdata$r:00003168 ; std::_Iostream_error_category::`RTTI Base Class Array'
.rdata$r:00003168 ??_R2_Iostream_error_category@std@@8 dd offset ??_R1A@?0A@EA@_Iostream_error_category@std@@8
.rdata$r:00003168                                         ; DATA XREF: .rdata$r:00003164o
.rdata$r:00003168                                         ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000316C                 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00003170                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00003174                 db    0
.rdata$r:00003175                 align 4
.rdata$r:00003175 _rdata$r        ends
.rdata$r:00003175
.rdata$r:00003178 ; ===========================================================================
.rdata$r:00003178
.rdata$r:00003178 ; Segment type: Pure data
.rdata$r:00003178 ; Segment permissions: Read
.rdata$r:00003178 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003178                 assume cs:_rdata$r
.rdata$r:00003178                 ;org 3178h
.rdata$r:00003178 ; COMDAT (pick any)
.rdata$r:00003178                 public ??_R1A@?0A@EA@_Iostream_error_category@std@@8
.rdata$r:00003178 ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00003178 ??_R1A@?0A@EA@_Iostream_error_category@std@@8 dd offset ??_R0?AV_Iostream_error_category@std@@@8
.rdata$r:00003178                                         ; DATA XREF: .rdata$r:std::_Iostream_error_category::`RTTI Base Class Array'o
.rdata$r:00003178                                         ; std::_Iostream_error_category `RTTI Type Descriptor'
.rdata$r:0000317C                 db    2
.rdata$r:0000317D                 db    0
.rdata$r:0000317E                 db    0
.rdata$r:0000317F                 db    0
.rdata$r:00003180                 db    0
.rdata$r:00003181                 db    0
.rdata$r:00003182                 db    0
.rdata$r:00003183                 db    0
.rdata$r:00003184                 db 0FFh
.rdata$r:00003185                 db 0FFh
.rdata$r:00003186                 db 0FFh
.rdata$r:00003187                 db 0FFh
.rdata$r:00003188                 db    0
.rdata$r:00003189                 db    0
.rdata$r:0000318A                 db    0
.rdata$r:0000318B                 db    0
.rdata$r:0000318C                 db  40h ; @
.rdata$r:0000318D                 db    0
.rdata$r:0000318E                 db    0
.rdata$r:0000318F                 db    0
.rdata$r:00003190                 dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00003190 _rdata$r        ends
.rdata$r:00003190
.rdata$r:00003194 ; ===========================================================================
.rdata$r:00003194
.rdata$r:00003194 ; Segment type: Pure data
.rdata$r:00003194 ; Segment permissions: Read
.rdata$r:00003194 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003194                 assume cs:_rdata$r
.rdata$r:00003194                 ;org 3194h
.rdata$r:00003194 ; COMDAT (pick any)
.rdata$r:00003194                 public ??_R4_System_error_category@std@@6B@
.rdata$r:00003194 ; const std::_System_error_category::`RTTI Complete Object Locator'
.rdata$r:00003194 ??_R4_System_error_category@std@@6B@ db    0 ; DATA XREF: .rdata:00002F0Co
.rdata$r:00003195                 db    0
.rdata$r:00003196                 db    0
.rdata$r:00003197                 db    0
.rdata$r:00003198                 db    0
.rdata$r:00003199                 db    0
.rdata$r:0000319A                 db    0
.rdata$r:0000319B                 db    0
.rdata$r:0000319C                 db    0
.rdata$r:0000319D                 db    0
.rdata$r:0000319E                 db    0
.rdata$r:0000319F                 db    0
.rdata$r:000031A0                 dd offset ??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category `RTTI Type Descriptor'
.rdata$r:000031A4                 dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000031A4 _rdata$r        ends
.rdata$r:000031A4
.data$r:000031A8 ; ===========================================================================
.data$r:000031A8
.data$r:000031A8 ; Segment type: Pure data
.data$r:000031A8 ; Segment permissions: Read/Write
.data$r:000031A8 _data$r         segment dword public 'DATA' use32
.data$r:000031A8                 assume cs:_data$r
.data$r:000031A8                 ;org 31A8h
.data$r:000031A8 ; COMDAT (pick any)
.data$r:000031A8                 public ??_R0?AV_System_error_category@std@@@8
.data$r:000031A8 ; class std::_System_error_category `RTTI Type Descriptor'
.data$r:000031A8 ??_R0?AV_System_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:000031A8                                         ; DATA XREF: .rdata$r:000031A0o
.data$r:000031A8                                         ; .rdata$r:std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:000031A8                                         ; const type_info::`vftable'
.data$r:000031AC                 align 10h
.data$r:000031B0 a_?av_system_er db '.?AV_System_error_category@std@@',0
.data$r:000031D1                 align 4
.data$r:000031D1 _data$r         ends
.data$r:000031D1
.rdata$r:000031D4 ; ===========================================================================
.rdata$r:000031D4
.rdata$r:000031D4 ; Segment type: Pure data
.rdata$r:000031D4 ; Segment permissions: Read
.rdata$r:000031D4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000031D4                 assume cs:_rdata$r
.rdata$r:000031D4                 ;org 31D4h
.rdata$r:000031D4 ; COMDAT (pick any)
.rdata$r:000031D4                 public ??_R3_System_error_category@std@@8
.rdata$r:000031D4 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000031D4 ??_R3_System_error_category@std@@8 db    0 ; DATA XREF: .rdata$r:000031A4o
.rdata$r:000031D4                                         ; .rdata$r:0000320Co
.rdata$r:000031D5                 db    0
.rdata$r:000031D6                 db    0
.rdata$r:000031D7                 db    0
.rdata$r:000031D8                 db    0
.rdata$r:000031D9                 db    0
.rdata$r:000031DA                 db    0
.rdata$r:000031DB                 db    0
.rdata$r:000031DC                 db    3
.rdata$r:000031DD                 db    0
.rdata$r:000031DE                 db    0
.rdata$r:000031DF                 db    0
.rdata$r:000031E0                 dd offset ??_R2_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
.rdata$r:000031E0 _rdata$r        ends
.rdata$r:000031E0
.rdata$r:000031E4 ; ===========================================================================
.rdata$r:000031E4
.rdata$r:000031E4 ; Segment type: Pure data
.rdata$r:000031E4 ; Segment permissions: Read
.rdata$r:000031E4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000031E4                 assume cs:_rdata$r
.rdata$r:000031E4                 ;org 31E4h
.rdata$r:000031E4 ; COMDAT (pick any)
.rdata$r:000031E4                 public ??_R2_System_error_category@std@@8
.rdata$r:000031E4 ; std::_System_error_category::`RTTI Base Class Array'
.rdata$r:000031E4 ??_R2_System_error_category@std@@8 dd offset ??_R1A@?0A@EA@_System_error_category@std@@8
.rdata$r:000031E4                                         ; DATA XREF: .rdata$r:000031E0o
.rdata$r:000031E4                                         ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000031E8                 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000031EC                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000031F0                 db    0
.rdata$r:000031F1                 align 4
.rdata$r:000031F1 _rdata$r        ends
.rdata$r:000031F1
.rdata$r:000031F4 ; ===========================================================================
.rdata$r:000031F4
.rdata$r:000031F4 ; Segment type: Pure data
.rdata$r:000031F4 ; Segment permissions: Read
.rdata$r:000031F4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000031F4                 assume cs:_rdata$r
.rdata$r:000031F4                 ;org 31F4h
.rdata$r:000031F4 ; COMDAT (pick any)
.rdata$r:000031F4                 public ??_R1A@?0A@EA@_System_error_category@std@@8
.rdata$r:000031F4 ; std::_System_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:000031F4 ??_R1A@?0A@EA@_System_error_category@std@@8 dd offset ??_R0?AV_System_error_category@std@@@8
.rdata$r:000031F4                                         ; DATA XREF: .rdata$r:std::_System_error_category::`RTTI Base Class Array'o
.rdata$r:000031F4                                         ; std::_System_error_category `RTTI Type Descriptor'
.rdata$r:000031F8                 db    2
.rdata$r:000031F9                 db    0
.rdata$r:000031FA                 db    0
.rdata$r:000031FB                 db    0
.rdata$r:000031FC                 db    0
.rdata$r:000031FD                 db    0
.rdata$r:000031FE                 db    0
.rdata$r:000031FF                 db    0
.rdata$r:00003200                 db 0FFh
.rdata$r:00003201                 db 0FFh
.rdata$r:00003202                 db 0FFh
.rdata$r:00003203                 db 0FFh
.rdata$r:00003204                 db    0
.rdata$r:00003205                 db    0
.rdata$r:00003206                 db    0
.rdata$r:00003207                 db    0
.rdata$r:00003208                 db  40h ; @
.rdata$r:00003209                 db    0
.rdata$r:0000320A                 db    0
.rdata$r:0000320B                 db    0
.rdata$r:0000320C                 dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000320C _rdata$r        ends
.rdata$r:0000320C
.CRT$XCU:00003210 ; ===========================================================================
.CRT$XCU:00003210
.CRT$XCU:00003210 ; Segment type: Pure data
.CRT$XCU:00003210 ; Segment permissions: Read
.CRT$XCU:00003210 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00003210                 assume cs:_CRT$XCU
.CRT$XCU:00003210                 ;org 3210h
.CRT$XCU:00003210 _piecewise_construct$initializer$ dd offset ??__Epiecewise_construct@std@@YAXXZ ; std::`dynamic initializer for 'piecewise_construct''(void)
.CRT$XCU:00003214 _allocator_arg$initializer$ dd offset ??__Eallocator_arg@std@@YAXXZ ; std::`dynamic initializer for 'allocator_arg''(void)
.CRT$XCU:00003218 _ignore$initializer$ dd offset ??__Eignore@std@@YAXXZ ; std::`dynamic initializer for 'ignore''(void)
.CRT$XCU:0000321C __Tuple_alloc$initializer$ dd offset ??__E_Tuple_alloc@std@@YAXXZ ; std::`dynamic initializer for '_Tuple_alloc''(void)
.CRT$XCU:0000321C _CRT$XCU        ends
.CRT$XCU:0000321C
.CRT$XCU:00003220 ; ===========================================================================
.CRT$XCU:00003220
.CRT$XCU:00003220 ; Segment type: Pure data
.CRT$XCU:00003220 ; Segment permissions: Read
.CRT$XCU:00003220 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00003220                 assume cs:_CRT$XCU
.CRT$XCU:00003220                 ;org 3220h
.CRT$XCU:00003220 ; COMDAT (pick associative to section at 2F30)
.CRT$XCU:00003220 ; public: static void (__cdecl *std::_Error_objects<int>::_Generic_object$initializer$)(void)
.CRT$XCU:00003220 ?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
.CRT$XCU:00003220 _CRT$XCU        ends
.CRT$XCU:00003220
.CRT$XCU:00003224 ; ===========================================================================
.CRT$XCU:00003224
.CRT$XCU:00003224 ; Segment type: Pure data
.CRT$XCU:00003224 ; Segment permissions: Read
.CRT$XCU:00003224 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00003224                 assume cs:_CRT$XCU
.CRT$XCU:00003224                 ;org 3224h
.CRT$XCU:00003224 ; COMDAT (pick associative to section at 2F34)
.CRT$XCU:00003224 ; public: static void (__cdecl *std::_Error_objects<int>::_Iostream_object$initializer$)(void)
.CRT$XCU:00003224 ?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
.CRT$XCU:00003224 _CRT$XCU        ends
.CRT$XCU:00003224
.CRT$XCU:00003228 ; ===========================================================================
.CRT$XCU:00003228
.CRT$XCU:00003228 ; Segment type: Pure data
.CRT$XCU:00003228 ; Segment permissions: Read
.CRT$XCU:00003228 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00003228                 assume cs:_CRT$XCU
.CRT$XCU:00003228                 ;org 3228h
.CRT$XCU:00003228 ; COMDAT (pick associative to section at 2F38)
.CRT$XCU:00003228 ; public: static void (__cdecl *std::_Error_objects<int>::_System_object$initializer$)(void)
.CRT$XCU:00003228 ?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)
.CRT$XCU:00003228 _CRT$XCU        ends
.CRT$XCU:00003228
.CRT$XCU:0000322C ; ===========================================================================
.CRT$XCU:0000322C
.CRT$XCU:0000322C ; Segment type: Pure data
.CRT$XCU:0000322C ; Segment permissions: Read
.CRT$XCU:0000322C _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0000322C                 assume cs:_CRT$XCU
.CRT$XCU:0000322C                 ;org 322Ch
.CRT$XCU:0000322C ; COMDAT (pick associative to section at 2F3C)
.CRT$XCU:0000322C ; public: static void (__cdecl *std::num_put<char, class std::back_insert_iterator<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>::id$initializer$)(void)
.CRT$XCU:0000322C ?id$initializer$@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2P6AXXZA dd offset ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)
.CRT$XCU:0000322C _CRT$XCU        ends
.CRT$XCU:0000322C
.CRT$XCU:00003230 ; ===========================================================================
.CRT$XCU:00003230
.CRT$XCU:00003230 ; Segment type: Pure data
.CRT$XCU:00003230 ; Segment permissions: Read
.CRT$XCU:00003230 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00003230                 assume cs:_CRT$XCU
.CRT$XCU:00003230                 ;org 3230h
.CRT$XCU:00003230 ; COMDAT (pick associative to section at 2F40)
.CRT$XCU:00003230 ; public: static void (__cdecl *std::num_put<wchar_t, class std::back_insert_iterator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::id$initializer$)(void)
.CRT$XCU:00003230 ?id$initializer$@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2P6AXXZA dd offset ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)
.CRT$XCU:00003230 _CRT$XCU        ends
.CRT$XCU:00003230
.CRT$XCU:00003234 ; ===========================================================================
.CRT$XCU:00003234
.CRT$XCU:00003234 ; Segment type: Pure data
.CRT$XCU:00003234 ; Segment permissions: Read
.CRT$XCU:00003234 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00003234                 assume cs:_CRT$XCU
.CRT$XCU:00003234                 ;org 3234h
.CRT$XCU:00003234 ; COMDAT (pick associative to section at 2FD8)
.CRT$XCU:00003234 ; public: static void (__cdecl *std::numpunct<char>::id$initializer$)(void)
.CRT$XCU:00003234 ?id$initializer$@?$numpunct@D@std@@2P6AXXZA dd offset ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::numpunct<char>::id''(void)
.CRT$XCU:00003234 _CRT$XCU        ends
.CRT$XCU:00003234
.CRT$XCU:00003238 ; ===========================================================================
.CRT$XCU:00003238
.CRT$XCU:00003238 ; Segment type: Pure data
.CRT$XCU:00003238 ; Segment permissions: Read
.CRT$XCU:00003238 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00003238                 assume cs:_CRT$XCU
.CRT$XCU:00003238                 ;org 3238h
.CRT$XCU:00003238 ; COMDAT (pick associative to section at 2FDC)
.CRT$XCU:00003238 ; public: static void (__cdecl *std::numpunct<wchar_t>::id$initializer$)(void)
.CRT$XCU:00003238 ?id$initializer$@?$numpunct@_W@std@@2P6AXXZA dd offset ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::numpunct<wchar_t>::id''(void)
.CRT$XCU:00003238 _CRT$XCU        ends
.CRT$XCU:00003238
UNDEF:00003240 ; ===========================================================================
UNDEF:00003240
UNDEF:00003240 ; Segment type: Externs
UNDEF:00003240 ; UNDEF
UNDEF:00003240                 extrn __purecall:near   ; DATA XREF: .rdata:00002E84o
UNDEF:00003240                                         ; .rdata:00002E88o
UNDEF:00003244 ; void *__cdecl operator new(unsigned int)
UNDEF:00003244                 extrn ??2@YAPAXI@Z:near ; CODE XREF: std::_Allocate<char>(uint,char *)+1Dp
UNDEF:00003244                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+23p
UNDEF:00003248 ; void __cdecl operator delete(void *)
UNDEF:00003248                 extrn ??3@YAXPAX@Z:near ; CODE XREF: std::_Generic_error_category::`scalar deleting destructor'(uint)+1Bp
UNDEF:00003248                                         ; std::_Iostream_error_category::`scalar deleting destructor'(uint)+1Bp ...
UNDEF:0000324C ; int __cdecl atexit(void (__cdecl *)())
UNDEF:0000324C                 extrn _atexit:near      ; CODE XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+12p
UNDEF:0000324C                                         ; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+12p ...
UNDEF:00003250 ; void *__cdecl memcpy(void *Dst, const void *Src, size_t Size)
UNDEF:00003250                 extrn _memcpy:near      ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+1Ep
UNDEF:00003254 ; size_t __cdecl strlen(const char *Str)
UNDEF:00003254                 extrn _strlen:near      ; CODE XREF: std::char_traits<char>::length(char const *)+1Bp
UNDEF:00003258 ; void *__cdecl memmove(void *Dst, const void *Src, size_t Size)
UNDEF:00003258                 extrn _memmove:near     ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+1Ep
UNDEF:0000325C ; LRESULT __stdcall SendMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
UNDEF:0000325C                 extrn __imp__SendMessageW@16:near
UNDEF:0000325C                                         ; CODE XREF: GoToLineDlg::run_dlgProc(uint,uint,long)+1A7p
UNDEF:0000325C                                         ; DATA XREF: GoToLineDlg::run_dlgProc(uint,uint,long)+1A7r
UNDEF:00003260 ; BOOL __stdcall SetDlgItemInt(HWND hDlg, int nIDDlgItem, UINT uValue, BOOL bSigned)
UNDEF:00003260                 extrn __imp__SetDlgItemInt@16:near
UNDEF:00003260                                         ; CODE XREF: GoToLineDlg::updateLinesNumbers(void)+8Cp
UNDEF:00003260                                         ; GoToLineDlg::updateLinesNumbers(void)+A4p
UNDEF:00003260                                         ; DATA XREF: ...
UNDEF:00003264 ; UINT __stdcall GetDlgItemInt(HWND hDlg, int nIDDlgItem, BOOL *lpTranslated, BOOL bSigned)
UNDEF:00003264                 extrn __imp__GetDlgItemInt@16:near
UNDEF:00003264                                         ; CODE XREF: GoToLineDlg::getLine(void)+1Bp
UNDEF:00003264                                         ; DATA XREF: GoToLineDlg::getLine(void)+1Br
UNDEF:00003268 ; BOOL __stdcall SetDlgItemTextW(HWND hDlg, int nIDDlgItem, LPCWSTR lpString)
UNDEF:00003268                 extrn __imp__SetDlgItemTextW@12:near
UNDEF:00003268                                         ; CODE XREF: GoToLineDlg::cleanLineEdit(void)+18p
UNDEF:00003268                                         ; DATA XREF: GoToLineDlg::cleanLineEdit(void)+18r
UNDEF:0000326C ; LRESULT __stdcall SendDlgItemMessageW(HWND hDlg, int nIDDlgItem, UINT Msg, WPARAM wParam, LPARAM lParam)
UNDEF:0000326C                 extrn __imp__SendDlgItemMessageW@20:near
UNDEF:0000326C                                         ; CODE XREF: GoToLineDlg::run_dlgProc(uint,uint,long)+38p
UNDEF:0000326C                                         ; GoToLineDlg::run_dlgProc(uint,uint,long)+20Bp ...
UNDEF:00003270 ; int __stdcall GetDlgCtrlID(HWND hWnd)
UNDEF:00003270                 extrn __imp__GetDlgCtrlID@4:near
UNDEF:00003270                                         ; CODE XREF: GoToLineDlg::run_dlgProc(uint,uint,long)+18Cp
UNDEF:00003270                                         ; DATA XREF: GoToLineDlg::run_dlgProc(uint,uint,long)+18Cr
UNDEF:00003274 ; HWND __stdcall SetFocus(HWND hWnd)
UNDEF:00003274                 extrn __imp__SetFocus@4:near
UNDEF:00003274                                         ; CODE XREF: Window::getFocus(void)+Ep
UNDEF:00003274                                         ; DATA XREF: Window::getFocus(void)+Er
UNDEF:00003278 ; _DWORD __thiscall std::_Lockit::_Lockit(std::_Lockit *__hidden this, int)
UNDEF:00003278                 extrn ??0_Lockit@std@@QAE@H@Z:near
UNDEF:00003278                                         ; CODE XREF: std::_Container_base12::_Orphan_all(void)+35p
UNDEF:0000327C ; _DWORD __thiscall std::_Lockit::~_Lockit(std::_Lockit *__hidden this)
UNDEF:0000327C                 extrn ??1_Lockit@std@@QAE@XZ:near
UNDEF:0000327C                                         ; CODE XREF: std::_Container_base12::_Orphan_all(void)+86p
UNDEF:0000327C                                         ; __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0+3j
UNDEF:00003280                 extrn __hypot:near      ; CODE XREF: _hypot+1Dp
UNDEF:00003284 ; void __cdecl std::_Debug_message(const wchar_t *, const wchar_t *, unsigned int)
UNDEF:00003284                 extrn ?_Debug_message@std@@YAXPB_W0I@Z:near
UNDEF:00003284                                         ; CODE XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+16p
UNDEF:00003288 ; void __cdecl std::_Xbad_alloc()
UNDEF:00003288                 extrn ?_Xbad_alloc@std@@YAXXZ:near
UNDEF:00003288                                         ; CODE XREF: std::_Allocate<char>(uint,char *):loc_10CEp
UNDEF:00003288                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *):loc_1110p
UNDEF:0000328C ; void __cdecl std::_Xlength_error(const char *)
UNDEF:0000328C                 extrn ?_Xlength_error@std@@YAXPBD@Z:near
UNDEF:0000328C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+Cp
UNDEF:00003290 ; void __cdecl std::_Xout_of_range(const char *)
UNDEF:00003290                 extrn ?_Xout_of_range@std@@YAXPBD@Z:near
UNDEF:00003290                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+Cp
UNDEF:00003294 ; public: virtual void * __thiscall std::error_category::`vector deleting destructor'(unsigned int)
UNDEF:00003294                 extrn ??_Eerror_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00003294                                         ; DATA XREF: .rdata:const std::error_category::`vftable'o
UNDEF:00003298 ; const char *__cdecl std::_Syserror_map(int)
UNDEF:00003298                 extrn ?_Syserror_map@std@@YAPBDH@Z:near
UNDEF:00003298                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+Bp
UNDEF:00003298                                         ; std::_Generic_error_category::message(int)+33p
UNDEF:0000329C ; const char *__cdecl std::_Winerror_map(int)
UNDEF:0000329C                 extrn ?_Winerror_map@std@@YAPBDH@Z:near
UNDEF:0000329C                                         ; CODE XREF: std::_System_error_category::message(int)+33p
UNDEF:000032A0 ; public: virtual void * __thiscall std::_Generic_error_category::`vector deleting destructor'(unsigned int)
UNDEF:000032A0                 extrn ??_E_Generic_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:000032A0                                         ; DATA XREF: .rdata:const std::_Generic_error_category::`vftable'o
UNDEF:000032A4 ; public: virtual void * __thiscall std::_Iostream_error_category::`vector deleting destructor'(unsigned int)
UNDEF:000032A4                 extrn ??_E_Iostream_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:000032A4                                         ; DATA XREF: .rdata:const std::_Iostream_error_category::`vftable'o
UNDEF:000032A8 ; public: virtual void * __thiscall std::_System_error_category::`vector deleting destructor'(unsigned int)
UNDEF:000032A8                 extrn ??_E_System_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:000032A8                                         ; DATA XREF: .rdata:const std::_System_error_category::`vftable'o
UNDEF:000032AC ; void __thiscall StaticDialog::goToCenter(StaticDialog *__hidden this)
UNDEF:000032AC                 extrn ?goToCenter@StaticDialog@@QAEXXZ:near
UNDEF:000032AC                                         ; CODE XREF: GoToLineDlg::run_dlgProc(uint,uint,long)+41p
UNDEF:000032B0 ; __fastcall __security_check_cookie(x)
UNDEF:000032B0                 extrn @__security_check_cookie@4:near
UNDEF:000032B0                                         ; CODE XREF: __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z+Cp
UNDEF:000032B0                                         ; __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z+Cp ...
UNDEF:000032B4 ; __stdcall _CxxThrowException(x, x)
UNDEF:000032B4                 extrn __CxxThrowException@8:near
UNDEF:000032B4                                         ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1+10p
UNDEF:000032B8                 extrn ___CxxFrameHandler3:near
UNDEF:000032B8                                         ; CODE XREF: __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z+16j
UNDEF:000032B8                                         ; __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z+16j ...
UNDEF:000032BC ; void *__cdecl memset(void *Dst, int Val, size_t Size)
UNDEF:000032BC                 extrn _memset:near      ; CODE XREF: GoToLineDlg::run_dlgProc(uint,uint,long)+16Dp
UNDEF:000032C0 ; const type_info::`vftable'
UNDEF:000032C0                 extrn ??_7type_info@@6B@:near
UNDEF:000032C0                                         ; DATA XREF: .data$r:std::error_category `RTTI Type Descriptor'o
UNDEF:000032C0                                         ; .data$r:std::_Generic_error_category `RTTI Type Descriptor'o ...
UNDEF:000032C4                 extrn ___security_cookie:near
UNDEF:000032C4                                         ; DATA XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+14r
UNDEF:000032C4                                         ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+14r ...
UNDEF:000032C8                 extrn __fltused:near
UNDEF:000032C8
UNDEF:000032C8
UNDEF:000032C8                 end